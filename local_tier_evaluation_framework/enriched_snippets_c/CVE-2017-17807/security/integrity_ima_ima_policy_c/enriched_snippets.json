[
  {
    "function_name": "ima_policy_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "1025-1148",
    "snippet": "int ima_policy_show(struct seq_file *m, void *v)\n{\n\tstruct ima_rule_entry *entry = v;\n\tint i;\n\tchar tbuf[64] = {0,};\n\n\trcu_read_lock();\n\n\tif (entry->action & MEASURE)\n\t\tseq_puts(m, pt(Opt_measure));\n\tif (entry->action & DONT_MEASURE)\n\t\tseq_puts(m, pt(Opt_dont_measure));\n\tif (entry->action & APPRAISE)\n\t\tseq_puts(m, pt(Opt_appraise));\n\tif (entry->action & DONT_APPRAISE)\n\t\tseq_puts(m, pt(Opt_dont_appraise));\n\tif (entry->action & AUDIT)\n\t\tseq_puts(m, pt(Opt_audit));\n\n\tseq_puts(m, \" \");\n\n\tif (entry->flags & IMA_FUNC)\n\t\tpolicy_func_show(m, entry->func);\n\n\tif (entry->flags & IMA_MASK) {\n\t\tif (entry->mask & MAY_EXEC)\n\t\t\tseq_printf(m, pt(Opt_mask), mt(mask_exec));\n\t\tif (entry->mask & MAY_WRITE)\n\t\t\tseq_printf(m, pt(Opt_mask), mt(mask_write));\n\t\tif (entry->mask & MAY_READ)\n\t\t\tseq_printf(m, pt(Opt_mask), mt(mask_read));\n\t\tif (entry->mask & MAY_APPEND)\n\t\t\tseq_printf(m, pt(Opt_mask), mt(mask_append));\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_FSMAGIC) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"0x%lx\", entry->fsmagic);\n\t\tseq_printf(m, pt(Opt_fsmagic), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_PCR) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", entry->pcr);\n\t\tseq_printf(m, pt(Opt_pcr), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_FSUUID) {\n\t\tseq_printf(m, \"fsuuid=%pU\", &entry->fsuuid);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_UID) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", __kuid_val(entry->uid));\n\t\tif (entry->uid_op == &uid_gt)\n\t\t\tseq_printf(m, pt(Opt_uid_gt), tbuf);\n\t\telse if (entry->uid_op == &uid_lt)\n\t\t\tseq_printf(m, pt(Opt_uid_lt), tbuf);\n\t\telse\n\t\t\tseq_printf(m, pt(Opt_uid_eq), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_EUID) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", __kuid_val(entry->uid));\n\t\tif (entry->uid_op == &uid_gt)\n\t\t\tseq_printf(m, pt(Opt_euid_gt), tbuf);\n\t\telse if (entry->uid_op == &uid_lt)\n\t\t\tseq_printf(m, pt(Opt_euid_lt), tbuf);\n\t\telse\n\t\t\tseq_printf(m, pt(Opt_euid_eq), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_FOWNER) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", __kuid_val(entry->fowner));\n\t\tif (entry->fowner_op == &uid_gt)\n\t\t\tseq_printf(m, pt(Opt_fowner_gt), tbuf);\n\t\telse if (entry->fowner_op == &uid_lt)\n\t\t\tseq_printf(m, pt(Opt_fowner_lt), tbuf);\n\t\telse\n\t\t\tseq_printf(m, pt(Opt_fowner_eq), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tif (entry->lsm[i].rule) {\n\t\t\tswitch (i) {\n\t\t\tcase LSM_OBJ_USER:\n\t\t\t\tseq_printf(m, pt(Opt_obj_user),\n\t\t\t\t\t   (char *)entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_OBJ_ROLE:\n\t\t\t\tseq_printf(m, pt(Opt_obj_role),\n\t\t\t\t\t   (char *)entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_OBJ_TYPE:\n\t\t\t\tseq_printf(m, pt(Opt_obj_type),\n\t\t\t\t\t   (char *)entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_SUBJ_USER:\n\t\t\t\tseq_printf(m, pt(Opt_subj_user),\n\t\t\t\t\t   (char *)entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_SUBJ_ROLE:\n\t\t\t\tseq_printf(m, pt(Opt_subj_role),\n\t\t\t\t\t   (char *)entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_SUBJ_TYPE:\n\t\t\t\tseq_printf(m, pt(Opt_subj_type),\n\t\t\t\t\t   (char *)entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (entry->flags & IMA_DIGSIG_REQUIRED)\n\t\tseq_puts(m, \"appraise_type=imasig \");\n\tif (entry->flags & IMA_PERMIT_DIRECTIO)\n\t\tseq_puts(m, \"permit_directio \");\n\trcu_read_unlock();\n\tseq_puts(m, \"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MAX_LSM_RULES 6",
      "#define AUDIT\t\t0x0040",
      "#define DONT_APPRAISE\t0x0008",
      "#define APPRAISE\t0x0004\t/* same as IMA_APPRAISE */",
      "#define DONT_MEASURE\t0x0002",
      "#define MEASURE\t\t0x0001\t/* same as IMA_MEASURE */",
      "#define IMA_PCR\t\t0x0100",
      "#define IMA_EUID\t0x0080",
      "#define IMA_FSUUID\t0x0020",
      "#define IMA_FOWNER\t0x0010",
      "#define IMA_UID\t\t0x0008",
      "#define IMA_FSMAGIC\t0x0004",
      "#define IMA_MASK\t0x0002",
      "#define IMA_FUNC\t0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"permit_directio \""
          ],
          "line": 1144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"appraise_type=imasig \""
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_subj_type)",
            "(char *)entry->lsm[i].args_p"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pt",
          "args": [
            "Opt_subj_type"
          ],
          "line": 1135
        },
        "resolved": true,
        "details": {
          "function_name": "security_ptrace_traceme",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "252-255",
          "snippet": "int security_ptrace_traceme(struct task_struct *parent)\n{\n\treturn call_int_hook(ptrace_traceme, 0, parent);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nint security_ptrace_traceme(struct task_struct *parent)\n{\n\treturn call_int_hook(ptrace_traceme, 0, parent);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_subj_role)",
            "(char *)entry->lsm[i].args_p"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_subj_user)",
            "(char *)entry->lsm[i].args_p"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_obj_type)",
            "(char *)entry->lsm[i].args_p"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_obj_role)",
            "(char *)entry->lsm[i].args_p"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_obj_user)",
            "(char *)entry->lsm[i].args_p"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" \""
          ],
          "line": 1108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_fowner_eq)",
            "tbuf"
          ],
          "line": 1107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_fowner_lt)",
            "tbuf"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_fowner_gt)",
            "tbuf"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tbuf",
            "sizeof(tbuf)",
            "\"%d\"",
            "__kuid_val(entry->fowner)"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kuid_val",
          "args": [
            "entry->fowner"
          ],
          "line": 1101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" \""
          ],
          "line": 1097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_euid_eq)",
            "tbuf"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_euid_lt)",
            "tbuf"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_euid_gt)",
            "tbuf"
          ],
          "line": 1092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tbuf",
            "sizeof(tbuf)",
            "\"%d\"",
            "__kuid_val(entry->uid)"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kuid_val",
          "args": [
            "entry->uid"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" \""
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_uid_eq)",
            "tbuf"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_uid_lt)",
            "tbuf"
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_uid_gt)",
            "tbuf"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tbuf",
            "sizeof(tbuf)",
            "\"%d\"",
            "__kuid_val(entry->uid)"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kuid_val",
          "args": [
            "entry->uid"
          ],
          "line": 1079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" \""
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"fsuuid=%pU\"",
            "&entry->fsuuid"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" \""
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_pcr)",
            "tbuf"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tbuf",
            "sizeof(tbuf)",
            "\"%d\"",
            "entry->pcr"
          ],
          "line": 1068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" \""
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_fsmagic)",
            "tbuf"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tbuf",
            "sizeof(tbuf)",
            "\"0x%lx\"",
            "entry->fsmagic"
          ],
          "line": 1062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" \""
          ],
          "line": 1058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_mask)",
            "mt(mask_append)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mt",
          "args": [
            "mask_append"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "default_canonical_fmt_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
          "lines": "32-38",
          "snippet": "static int __init default_canonical_fmt_setup(char *str)\n{\n#ifdef __BIG_ENDIAN\n\tima_canonical_fmt = true;\n#endif\n\treturn 1;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/parser.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rculist.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool ima_canonical_fmt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nbool ima_canonical_fmt;\n\nstatic int __init default_canonical_fmt_setup(char *str)\n{\n#ifdef __BIG_ENDIAN\n\tima_canonical_fmt = true;\n#endif\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_mask)",
            "mt(mask_read)"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_mask)",
            "mt(mask_write)"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "pt(Opt_mask)",
            "mt(mask_exec)"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policy_func_show",
          "args": [
            "m",
            "entry->func"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "policy_func_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "1017-1023",
          "snippet": "static void policy_func_show(struct seq_file *m, enum ima_hooks func)\n{\n\tif (func > 0 && func < MAX_CHECK)\n\t\tseq_printf(m, \"func=%s \", func_tokens[func]);\n\telse\n\t\tseq_printf(m, \"func=%d \", func);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic void policy_func_show(struct seq_file *m, enum ima_hooks func)\n{\n\tif (func > 0 && func < MAX_CHECK)\n\t\tseq_printf(m, \"func=%s \", func_tokens[func]);\n\telse\n\t\tseq_printf(m, \"func=%d \", func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" \""
          ],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "pt(Opt_audit)"
          ],
          "line": 1042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "pt(Opt_dont_appraise)"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "pt(Opt_appraise)"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "pt(Opt_dont_measure)"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "pt(Opt_measure)"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define MAX_LSM_RULES 6\n#define AUDIT\t\t0x0040\n#define DONT_APPRAISE\t0x0008\n#define APPRAISE\t0x0004\t/* same as IMA_APPRAISE */\n#define DONT_MEASURE\t0x0002\n#define MEASURE\t\t0x0001\t/* same as IMA_MEASURE */\n#define IMA_PCR\t\t0x0100\n#define IMA_EUID\t0x0080\n#define IMA_FSUUID\t0x0020\n#define IMA_FOWNER\t0x0010\n#define IMA_UID\t\t0x0008\n#define IMA_FSMAGIC\t0x0004\n#define IMA_MASK\t0x0002\n#define IMA_FUNC\t0x0001\n\nint ima_policy_show(struct seq_file *m, void *v)\n{\n\tstruct ima_rule_entry *entry = v;\n\tint i;\n\tchar tbuf[64] = {0,};\n\n\trcu_read_lock();\n\n\tif (entry->action & MEASURE)\n\t\tseq_puts(m, pt(Opt_measure));\n\tif (entry->action & DONT_MEASURE)\n\t\tseq_puts(m, pt(Opt_dont_measure));\n\tif (entry->action & APPRAISE)\n\t\tseq_puts(m, pt(Opt_appraise));\n\tif (entry->action & DONT_APPRAISE)\n\t\tseq_puts(m, pt(Opt_dont_appraise));\n\tif (entry->action & AUDIT)\n\t\tseq_puts(m, pt(Opt_audit));\n\n\tseq_puts(m, \" \");\n\n\tif (entry->flags & IMA_FUNC)\n\t\tpolicy_func_show(m, entry->func);\n\n\tif (entry->flags & IMA_MASK) {\n\t\tif (entry->mask & MAY_EXEC)\n\t\t\tseq_printf(m, pt(Opt_mask), mt(mask_exec));\n\t\tif (entry->mask & MAY_WRITE)\n\t\t\tseq_printf(m, pt(Opt_mask), mt(mask_write));\n\t\tif (entry->mask & MAY_READ)\n\t\t\tseq_printf(m, pt(Opt_mask), mt(mask_read));\n\t\tif (entry->mask & MAY_APPEND)\n\t\t\tseq_printf(m, pt(Opt_mask), mt(mask_append));\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_FSMAGIC) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"0x%lx\", entry->fsmagic);\n\t\tseq_printf(m, pt(Opt_fsmagic), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_PCR) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", entry->pcr);\n\t\tseq_printf(m, pt(Opt_pcr), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_FSUUID) {\n\t\tseq_printf(m, \"fsuuid=%pU\", &entry->fsuuid);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_UID) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", __kuid_val(entry->uid));\n\t\tif (entry->uid_op == &uid_gt)\n\t\t\tseq_printf(m, pt(Opt_uid_gt), tbuf);\n\t\telse if (entry->uid_op == &uid_lt)\n\t\t\tseq_printf(m, pt(Opt_uid_lt), tbuf);\n\t\telse\n\t\t\tseq_printf(m, pt(Opt_uid_eq), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_EUID) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", __kuid_val(entry->uid));\n\t\tif (entry->uid_op == &uid_gt)\n\t\t\tseq_printf(m, pt(Opt_euid_gt), tbuf);\n\t\telse if (entry->uid_op == &uid_lt)\n\t\t\tseq_printf(m, pt(Opt_euid_lt), tbuf);\n\t\telse\n\t\t\tseq_printf(m, pt(Opt_euid_eq), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tif (entry->flags & IMA_FOWNER) {\n\t\tsnprintf(tbuf, sizeof(tbuf), \"%d\", __kuid_val(entry->fowner));\n\t\tif (entry->fowner_op == &uid_gt)\n\t\t\tseq_printf(m, pt(Opt_fowner_gt), tbuf);\n\t\telse if (entry->fowner_op == &uid_lt)\n\t\t\tseq_printf(m, pt(Opt_fowner_lt), tbuf);\n\t\telse\n\t\t\tseq_printf(m, pt(Opt_fowner_eq), tbuf);\n\t\tseq_puts(m, \" \");\n\t}\n\n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tif (entry->lsm[i].rule) {\n\t\t\tswitch (i) {\n\t\t\tcase LSM_OBJ_USER:\n\t\t\t\tseq_printf(m, pt(Opt_obj_user),\n\t\t\t\t\t   (char *)entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_OBJ_ROLE:\n\t\t\t\tseq_printf(m, pt(Opt_obj_role),\n\t\t\t\t\t   (char *)entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_OBJ_TYPE:\n\t\t\t\tseq_printf(m, pt(Opt_obj_type),\n\t\t\t\t\t   (char *)entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_SUBJ_USER:\n\t\t\t\tseq_printf(m, pt(Opt_subj_user),\n\t\t\t\t\t   (char *)entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_SUBJ_ROLE:\n\t\t\t\tseq_printf(m, pt(Opt_subj_role),\n\t\t\t\t\t   (char *)entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\tcase LSM_SUBJ_TYPE:\n\t\t\t\tseq_printf(m, pt(Opt_subj_type),\n\t\t\t\t\t   (char *)entry->lsm[i].args_p);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (entry->flags & IMA_DIGSIG_REQUIRED)\n\t\tseq_puts(m, \"appraise_type=imasig \");\n\tif (entry->flags & IMA_PERMIT_DIRECTIO)\n\t\tseq_puts(m, \"permit_directio \");\n\trcu_read_unlock();\n\tseq_puts(m, \"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "policy_func_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "1017-1023",
    "snippet": "static void policy_func_show(struct seq_file *m, enum ima_hooks func)\n{\n\tif (func > 0 && func < MAX_CHECK)\n\t\tseq_printf(m, \"func=%s \", func_tokens[func]);\n\telse\n\t\tseq_printf(m, \"func=%d \", func);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"func=%d \"",
            "func"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"func=%s \"",
            "func_tokens[func]"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic void policy_func_show(struct seq_file *m, enum ima_hooks func)\n{\n\tif (func > 0 && func < MAX_CHECK)\n\t\tseq_printf(m, \"func=%s \", func_tokens[func]);\n\telse\n\t\tseq_printf(m, \"func=%d \", func);\n}"
  },
  {
    "function_name": "ima_policy_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "1007-1009",
    "snippet": "void ima_policy_stop(struct seq_file *m, void *v)\n{\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nvoid ima_policy_stop(struct seq_file *m, void *v)\n{\n}"
  },
  {
    "function_name": "ima_policy_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "995-1005",
    "snippet": "void *ima_policy_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ima_rule_entry *entry = v;\n\n\trcu_read_lock();\n\tentry = list_entry_rcu(entry->list.next, struct ima_rule_entry, list);\n\trcu_read_unlock();\n\t(*pos)++;\n\n\treturn (&entry->list == ima_rules) ? NULL : entry;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head *ima_rules;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "entry->list.next",
            "structima_rule_entry",
            "list"
          ],
          "line": 1000
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic struct list_head *ima_rules;\n\nvoid *ima_policy_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ima_rule_entry *entry = v;\n\n\trcu_read_lock();\n\tentry = list_entry_rcu(entry->list.next, struct ima_rule_entry, list);\n\trcu_read_unlock();\n\t(*pos)++;\n\n\treturn (&entry->list == ima_rules) ? NULL : entry;\n}"
  },
  {
    "function_name": "ima_policy_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "979-993",
    "snippet": "void *ima_policy_start(struct seq_file *m, loff_t *pos)\n{\n\tloff_t l = *pos;\n\tstruct ima_rule_entry *entry;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, ima_rules, list) {\n\t\tif (!l--) {\n\t\t\trcu_read_unlock();\n\t\t\treturn entry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head *ima_rules;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "entry",
            "ima_rules",
            "list"
          ],
          "line": 985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic struct list_head *ima_rules;\n\nvoid *ima_policy_start(struct seq_file *m, loff_t *pos)\n{\n\tloff_t l = *pos;\n\tstruct ima_rule_entry *entry;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, ima_rules, list) {\n\t\tif (!l--) {\n\t\t\trcu_read_unlock();\n\t\t\treturn entry;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}"
  },
  {
    "function_name": "ima_delete_rules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "946-959",
    "snippet": "void ima_delete_rules(void)\n{\n\tstruct ima_rule_entry *entry, *tmp;\n\tint i;\n\n\ttemp_ima_appraise = 0;\n\tlist_for_each_entry_safe(entry, tmp, &ima_temp_rules, list) {\n\t\tfor (i = 0; i < MAX_LSM_RULES; i++)\n\t\t\tkfree(entry->lsm[i].args_p);\n\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MAX_LSM_RULES 6"
    ],
    "globals_used": [
      "static int temp_ima_appraise;",
      "static LIST_HEAD(ima_temp_rules);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&entry->list"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry->lsm[i].args_p"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "entry",
            "tmp",
            "&ima_temp_rules",
            "list"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define MAX_LSM_RULES 6\n\nstatic int temp_ima_appraise;\nstatic LIST_HEAD(ima_temp_rules);\n\nvoid ima_delete_rules(void)\n{\n\tstruct ima_rule_entry *entry, *tmp;\n\tint i;\n\n\ttemp_ima_appraise = 0;\n\tlist_for_each_entry_safe(entry, tmp, &ima_temp_rules, list) {\n\t\tfor (i = 0; i < MAX_LSM_RULES; i++)\n\t\t\tkfree(entry->lsm[i].args_p);\n\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n}"
  },
  {
    "function_name": "ima_parse_add_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "902-938",
    "snippet": "ssize_t ima_parse_add_rule(char *rule)\n{\n\tstatic const char op[] = \"update_policy\";\n\tchar *p;\n\tstruct ima_rule_entry *entry;\n\tssize_t result, len;\n\tint audit_info = 0;\n\n\tp = strsep(&rule, \"\\n\");\n\tlen = strlen(p) + 1;\n\tp += strspn(p, \" \\t\");\n\n\tif (*p == '#' || *p == '\\0')\n\t\treturn len;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"-ENOMEM\", -ENOMEM, audit_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&entry->list);\n\n\tresult = ima_parse_rule(p, entry);\n\tif (result) {\n\t\tkfree(entry);\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"invalid-policy\", result,\n\t\t\t\t    audit_info);\n\t\treturn result;\n\t}\n\n\tlist_add_tail(&entry->list, &ima_temp_rules);\n\n\treturn len;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ima_temp_rules);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->list",
            "&ima_temp_rules"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_STATUS",
            "NULL",
            "NULL",
            "op",
            "\"invalid-policy\"",
            "result",
            "audit_info"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_parse_rule",
          "args": [
            "p",
            "entry"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "ima_parse_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "608-893",
          "snippet": "static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)\n{\n\tstruct audit_buffer *ab;\n\tchar *from;\n\tchar *p;\n\tbool uid_token;\n\tint result = 0;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_INTEGRITY_RULE);\n\n\tentry->uid = INVALID_UID;\n\tentry->fowner = INVALID_UID;\n\tentry->uid_op = &uid_eq;\n\tentry->fowner_op = &uid_eq;\n\tentry->action = UNKNOWN;\n\twhile ((p = strsep(&rule, \" \\t\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned long lnum;\n\n\t\tif (result < 0)\n\t\t\tbreak;\n\t\tif ((*p == '\\0') || (*p == ' ') || (*p == '\\t'))\n\t\t\tcontinue;\n\t\ttoken = match_token(p, policy_tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_measure:\n\t\t\tima_log_string(ab, \"action\", \"measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_dont_measure:\n\t\t\tima_log_string(ab, \"action\", \"dont_measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_appraise:\n\t\t\tima_log_string(ab, \"action\", \"appraise\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = APPRAISE;\n\t\t\tbreak;\n\t\tcase Opt_dont_appraise:\n\t\t\tima_log_string(ab, \"action\", \"dont_appraise\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_APPRAISE;\n\t\t\tbreak;\n\t\tcase Opt_audit:\n\t\t\tima_log_string(ab, \"action\", \"audit\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = AUDIT;\n\t\t\tbreak;\n\t\tcase Opt_func:\n\t\t\tima_log_string(ab, \"func\", args[0].from);\n\n\t\t\tif (entry->func)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tif (strcmp(args[0].from, \"FILE_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\t/* PATH_CHECK is for backwards compat */\n\t\t\telse if (strcmp(args[0].from, \"PATH_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"MODULE_CHECK\") == 0)\n\t\t\t\tentry->func = MODULE_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"FIRMWARE_CHECK\") == 0)\n\t\t\t\tentry->func = FIRMWARE_CHECK;\n\t\t\telse if ((strcmp(args[0].from, \"FILE_MMAP\") == 0)\n\t\t\t\t|| (strcmp(args[0].from, \"MMAP_CHECK\") == 0))\n\t\t\t\tentry->func = MMAP_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"BPRM_CHECK\") == 0)\n\t\t\t\tentry->func = BPRM_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"KEXEC_KERNEL_CHECK\") ==\n\t\t\t\t 0)\n\t\t\t\tentry->func = KEXEC_KERNEL_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"KEXEC_INITRAMFS_CHECK\")\n\t\t\t\t == 0)\n\t\t\t\tentry->func = KEXEC_INITRAMFS_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"POLICY_CHECK\") == 0)\n\t\t\t\tentry->func = POLICY_CHECK;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FUNC;\n\t\t\tbreak;\n\t\tcase Opt_mask:\n\t\t\tima_log_string(ab, \"mask\", args[0].from);\n\n\t\t\tif (entry->mask)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tfrom = args[0].from;\n\t\t\tif (*from == '^')\n\t\t\t\tfrom++;\n\n\t\t\tif ((strcmp(from, \"MAY_EXEC\")) == 0)\n\t\t\t\tentry->mask = MAY_EXEC;\n\t\t\telse if (strcmp(from, \"MAY_WRITE\") == 0)\n\t\t\t\tentry->mask = MAY_WRITE;\n\t\t\telse if (strcmp(from, \"MAY_READ\") == 0)\n\t\t\t\tentry->mask = MAY_READ;\n\t\t\telse if (strcmp(from, \"MAY_APPEND\") == 0)\n\t\t\t\tentry->mask = MAY_APPEND;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= (*args[0].from == '^')\n\t\t\t\t     ? IMA_INMASK : IMA_MASK;\n\t\t\tbreak;\n\t\tcase Opt_fsmagic:\n\t\t\tima_log_string(ab, \"fsmagic\", args[0].from);\n\n\t\t\tif (entry->fsmagic) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 16, &entry->fsmagic);\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FSMAGIC;\n\t\t\tbreak;\n\t\tcase Opt_fsuuid:\n\t\t\tima_log_string(ab, \"fsuuid\", args[0].from);\n\n\t\t\tif (uuid_is_null(&entry->fsuuid)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = uuid_parse(args[0].from, &entry->fsuuid);\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FSUUID;\n\t\t\tbreak;\n\t\tcase Opt_uid_gt:\n\t\tcase Opt_euid_gt:\n\t\t\tentry->uid_op = &uid_gt;\n\t\tcase Opt_uid_lt:\n\t\tcase Opt_euid_lt:\n\t\t\tif ((token == Opt_uid_lt) || (token == Opt_euid_lt))\n\t\t\t\tentry->uid_op = &uid_lt;\n\t\tcase Opt_uid_eq:\n\t\tcase Opt_euid_eq:\n\t\t\tuid_token = (token == Opt_uid_eq) ||\n\t\t\t\t    (token == Opt_uid_gt) ||\n\t\t\t\t    (token == Opt_uid_lt);\n\n\t\t\tima_log_string_op(ab, uid_token ? \"uid\" : \"euid\",\n\t\t\t\t\t  args[0].from, entry->uid_op);\n\n\t\t\tif (uid_valid(entry->uid)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->uid = make_kuid(current_user_ns(),\n\t\t\t\t\t\t       (uid_t) lnum);\n\t\t\t\tif (!uid_valid(entry->uid) ||\n\t\t\t\t    (uid_t)lnum != lnum)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= uid_token\n\t\t\t\t\t    ? IMA_UID : IMA_EUID;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_fowner_gt:\n\t\t\tentry->fowner_op = &uid_gt;\n\t\tcase Opt_fowner_lt:\n\t\t\tif (token == Opt_fowner_lt)\n\t\t\t\tentry->fowner_op = &uid_lt;\n\t\tcase Opt_fowner_eq:\n\t\t\tima_log_string_op(ab, \"fowner\", args[0].from,\n\t\t\t\t\t  entry->fowner_op);\n\n\t\t\tif (uid_valid(entry->fowner)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->fowner = make_kuid(current_user_ns(), (uid_t)lnum);\n\t\t\t\tif (!uid_valid(entry->fowner) || (((uid_t)lnum) != lnum))\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= IMA_FOWNER;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_obj_user:\n\t\t\tima_log_string(ab, \"obj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_USER,\n\t\t\t\t\t\t   AUDIT_OBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_obj_role:\n\t\t\tima_log_string(ab, \"obj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_OBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_obj_type:\n\t\t\tima_log_string(ab, \"obj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_OBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_subj_user:\n\t\t\tima_log_string(ab, \"subj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_USER,\n\t\t\t\t\t\t   AUDIT_SUBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_subj_role:\n\t\t\tima_log_string(ab, \"subj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_SUBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_subj_type:\n\t\t\tima_log_string(ab, \"subj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_SUBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_appraise_type:\n\t\t\tif (entry->action != APPRAISE) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tima_log_string(ab, \"appraise_type\", args[0].from);\n\t\t\tif ((strcmp(args[0].from, \"imasig\")) == 0)\n\t\t\t\tentry->flags |= IMA_DIGSIG_REQUIRED;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_permit_directio:\n\t\t\tentry->flags |= IMA_PERMIT_DIRECTIO;\n\t\t\tbreak;\n\t\tcase Opt_pcr:\n\t\t\tif (entry->action != MEASURE) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tima_log_string(ab, \"pcr\", args[0].from);\n\n\t\t\tresult = kstrtoint(args[0].from, 10, &entry->pcr);\n\t\t\tif (result || INVALID_PCR(entry->pcr))\n\t\t\t\tresult = -EINVAL;\n\t\t\telse\n\t\t\t\tentry->flags |= IMA_PCR;\n\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tima_log_string(ab, \"UNKNOWN\", p);\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!result && (entry->action == UNKNOWN))\n\t\tresult = -EINVAL;\n\telse if (entry->func == MODULE_CHECK)\n\t\ttemp_ima_appraise |= IMA_APPRAISE_MODULES;\n\telse if (entry->func == FIRMWARE_CHECK)\n\t\ttemp_ima_appraise |= IMA_APPRAISE_FIRMWARE;\n\telse if (entry->func == POLICY_CHECK)\n\t\ttemp_ima_appraise |= IMA_APPRAISE_POLICY;\n\taudit_log_format(ab, \"res=%d\", !result);\n\taudit_log_end(ab);\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define AUDIT\t\t0x0040",
            "#define DONT_APPRAISE\t0x0008",
            "#define APPRAISE\t0x0004\t/* same as IMA_APPRAISE */",
            "#define DONT_MEASURE\t0x0002",
            "#define MEASURE\t\t0x0001\t/* same as IMA_MEASURE */",
            "#define UNKNOWN\t\t0",
            "#define IMA_PCR\t\t0x0100",
            "#define IMA_EUID\t0x0080",
            "#define IMA_INMASK\t0x0040",
            "#define IMA_FSUUID\t0x0020",
            "#define IMA_FOWNER\t0x0010",
            "#define IMA_UID\t\t0x0008",
            "#define IMA_FSMAGIC\t0x0004",
            "#define IMA_MASK\t0x0002",
            "#define IMA_FUNC\t0x0001"
          ],
          "globals_used": [
            "static int temp_ima_appraise;",
            "static match_table_t policy_tokens = {\n\t{Opt_measure, \"measure\"},\n\t{Opt_dont_measure, \"dont_measure\"},\n\t{Opt_appraise, \"appraise\"},\n\t{Opt_dont_appraise, \"dont_appraise\"},\n\t{Opt_audit, \"audit\"},\n\t{Opt_obj_user, \"obj_user=%s\"},\n\t{Opt_obj_role, \"obj_role=%s\"},\n\t{Opt_obj_type, \"obj_type=%s\"},\n\t{Opt_subj_user, \"subj_user=%s\"},\n\t{Opt_subj_role, \"subj_role=%s\"},\n\t{Opt_subj_type, \"subj_type=%s\"},\n\t{Opt_func, \"func=%s\"},\n\t{Opt_mask, \"mask=%s\"},\n\t{Opt_fsmagic, \"fsmagic=%s\"},\n\t{Opt_fsuuid, \"fsuuid=%s\"},\n\t{Opt_uid_eq, \"uid=%s\"},\n\t{Opt_euid_eq, \"euid=%s\"},\n\t{Opt_fowner_eq, \"fowner=%s\"},\n\t{Opt_uid_gt, \"uid>%s\"},\n\t{Opt_euid_gt, \"euid>%s\"},\n\t{Opt_fowner_gt, \"fowner>%s\"},\n\t{Opt_uid_lt, \"uid<%s\"},\n\t{Opt_euid_lt, \"euid<%s\"},\n\t{Opt_fowner_lt, \"fowner<%s\"},\n\t{Opt_appraise_type, \"appraise_type=%s\"},\n\t{Opt_permit_directio, \"permit_directio\"},\n\t{Opt_pcr, \"pcr=%s\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define AUDIT\t\t0x0040\n#define DONT_APPRAISE\t0x0008\n#define APPRAISE\t0x0004\t/* same as IMA_APPRAISE */\n#define DONT_MEASURE\t0x0002\n#define MEASURE\t\t0x0001\t/* same as IMA_MEASURE */\n#define UNKNOWN\t\t0\n#define IMA_PCR\t\t0x0100\n#define IMA_EUID\t0x0080\n#define IMA_INMASK\t0x0040\n#define IMA_FSUUID\t0x0020\n#define IMA_FOWNER\t0x0010\n#define IMA_UID\t\t0x0008\n#define IMA_FSMAGIC\t0x0004\n#define IMA_MASK\t0x0002\n#define IMA_FUNC\t0x0001\n\nstatic int temp_ima_appraise;\nstatic match_table_t policy_tokens = {\n\t{Opt_measure, \"measure\"},\n\t{Opt_dont_measure, \"dont_measure\"},\n\t{Opt_appraise, \"appraise\"},\n\t{Opt_dont_appraise, \"dont_appraise\"},\n\t{Opt_audit, \"audit\"},\n\t{Opt_obj_user, \"obj_user=%s\"},\n\t{Opt_obj_role, \"obj_role=%s\"},\n\t{Opt_obj_type, \"obj_type=%s\"},\n\t{Opt_subj_user, \"subj_user=%s\"},\n\t{Opt_subj_role, \"subj_role=%s\"},\n\t{Opt_subj_type, \"subj_type=%s\"},\n\t{Opt_func, \"func=%s\"},\n\t{Opt_mask, \"mask=%s\"},\n\t{Opt_fsmagic, \"fsmagic=%s\"},\n\t{Opt_fsuuid, \"fsuuid=%s\"},\n\t{Opt_uid_eq, \"uid=%s\"},\n\t{Opt_euid_eq, \"euid=%s\"},\n\t{Opt_fowner_eq, \"fowner=%s\"},\n\t{Opt_uid_gt, \"uid>%s\"},\n\t{Opt_euid_gt, \"euid>%s\"},\n\t{Opt_fowner_gt, \"fowner>%s\"},\n\t{Opt_uid_lt, \"uid<%s\"},\n\t{Opt_euid_lt, \"euid<%s\"},\n\t{Opt_fowner_lt, \"fowner<%s\"},\n\t{Opt_appraise_type, \"appraise_type=%s\"},\n\t{Opt_permit_directio, \"permit_directio\"},\n\t{Opt_pcr, \"pcr=%s\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ima_parse_rule(char *rule, struct ima_rule_entry *entry)\n{\n\tstruct audit_buffer *ab;\n\tchar *from;\n\tchar *p;\n\tbool uid_token;\n\tint result = 0;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_INTEGRITY_RULE);\n\n\tentry->uid = INVALID_UID;\n\tentry->fowner = INVALID_UID;\n\tentry->uid_op = &uid_eq;\n\tentry->fowner_op = &uid_eq;\n\tentry->action = UNKNOWN;\n\twhile ((p = strsep(&rule, \" \\t\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned long lnum;\n\n\t\tif (result < 0)\n\t\t\tbreak;\n\t\tif ((*p == '\\0') || (*p == ' ') || (*p == '\\t'))\n\t\t\tcontinue;\n\t\ttoken = match_token(p, policy_tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_measure:\n\t\t\tima_log_string(ab, \"action\", \"measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_dont_measure:\n\t\t\tima_log_string(ab, \"action\", \"dont_measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_appraise:\n\t\t\tima_log_string(ab, \"action\", \"appraise\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = APPRAISE;\n\t\t\tbreak;\n\t\tcase Opt_dont_appraise:\n\t\t\tima_log_string(ab, \"action\", \"dont_appraise\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_APPRAISE;\n\t\t\tbreak;\n\t\tcase Opt_audit:\n\t\t\tima_log_string(ab, \"action\", \"audit\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = AUDIT;\n\t\t\tbreak;\n\t\tcase Opt_func:\n\t\t\tima_log_string(ab, \"func\", args[0].from);\n\n\t\t\tif (entry->func)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tif (strcmp(args[0].from, \"FILE_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\t/* PATH_CHECK is for backwards compat */\n\t\t\telse if (strcmp(args[0].from, \"PATH_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"MODULE_CHECK\") == 0)\n\t\t\t\tentry->func = MODULE_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"FIRMWARE_CHECK\") == 0)\n\t\t\t\tentry->func = FIRMWARE_CHECK;\n\t\t\telse if ((strcmp(args[0].from, \"FILE_MMAP\") == 0)\n\t\t\t\t|| (strcmp(args[0].from, \"MMAP_CHECK\") == 0))\n\t\t\t\tentry->func = MMAP_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"BPRM_CHECK\") == 0)\n\t\t\t\tentry->func = BPRM_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"KEXEC_KERNEL_CHECK\") ==\n\t\t\t\t 0)\n\t\t\t\tentry->func = KEXEC_KERNEL_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"KEXEC_INITRAMFS_CHECK\")\n\t\t\t\t == 0)\n\t\t\t\tentry->func = KEXEC_INITRAMFS_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"POLICY_CHECK\") == 0)\n\t\t\t\tentry->func = POLICY_CHECK;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FUNC;\n\t\t\tbreak;\n\t\tcase Opt_mask:\n\t\t\tima_log_string(ab, \"mask\", args[0].from);\n\n\t\t\tif (entry->mask)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tfrom = args[0].from;\n\t\t\tif (*from == '^')\n\t\t\t\tfrom++;\n\n\t\t\tif ((strcmp(from, \"MAY_EXEC\")) == 0)\n\t\t\t\tentry->mask = MAY_EXEC;\n\t\t\telse if (strcmp(from, \"MAY_WRITE\") == 0)\n\t\t\t\tentry->mask = MAY_WRITE;\n\t\t\telse if (strcmp(from, \"MAY_READ\") == 0)\n\t\t\t\tentry->mask = MAY_READ;\n\t\t\telse if (strcmp(from, \"MAY_APPEND\") == 0)\n\t\t\t\tentry->mask = MAY_APPEND;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= (*args[0].from == '^')\n\t\t\t\t     ? IMA_INMASK : IMA_MASK;\n\t\t\tbreak;\n\t\tcase Opt_fsmagic:\n\t\t\tima_log_string(ab, \"fsmagic\", args[0].from);\n\n\t\t\tif (entry->fsmagic) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 16, &entry->fsmagic);\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FSMAGIC;\n\t\t\tbreak;\n\t\tcase Opt_fsuuid:\n\t\t\tima_log_string(ab, \"fsuuid\", args[0].from);\n\n\t\t\tif (uuid_is_null(&entry->fsuuid)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = uuid_parse(args[0].from, &entry->fsuuid);\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FSUUID;\n\t\t\tbreak;\n\t\tcase Opt_uid_gt:\n\t\tcase Opt_euid_gt:\n\t\t\tentry->uid_op = &uid_gt;\n\t\tcase Opt_uid_lt:\n\t\tcase Opt_euid_lt:\n\t\t\tif ((token == Opt_uid_lt) || (token == Opt_euid_lt))\n\t\t\t\tentry->uid_op = &uid_lt;\n\t\tcase Opt_uid_eq:\n\t\tcase Opt_euid_eq:\n\t\t\tuid_token = (token == Opt_uid_eq) ||\n\t\t\t\t    (token == Opt_uid_gt) ||\n\t\t\t\t    (token == Opt_uid_lt);\n\n\t\t\tima_log_string_op(ab, uid_token ? \"uid\" : \"euid\",\n\t\t\t\t\t  args[0].from, entry->uid_op);\n\n\t\t\tif (uid_valid(entry->uid)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->uid = make_kuid(current_user_ns(),\n\t\t\t\t\t\t       (uid_t) lnum);\n\t\t\t\tif (!uid_valid(entry->uid) ||\n\t\t\t\t    (uid_t)lnum != lnum)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= uid_token\n\t\t\t\t\t    ? IMA_UID : IMA_EUID;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_fowner_gt:\n\t\t\tentry->fowner_op = &uid_gt;\n\t\tcase Opt_fowner_lt:\n\t\t\tif (token == Opt_fowner_lt)\n\t\t\t\tentry->fowner_op = &uid_lt;\n\t\tcase Opt_fowner_eq:\n\t\t\tima_log_string_op(ab, \"fowner\", args[0].from,\n\t\t\t\t\t  entry->fowner_op);\n\n\t\t\tif (uid_valid(entry->fowner)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->fowner = make_kuid(current_user_ns(), (uid_t)lnum);\n\t\t\t\tif (!uid_valid(entry->fowner) || (((uid_t)lnum) != lnum))\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= IMA_FOWNER;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_obj_user:\n\t\t\tima_log_string(ab, \"obj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_USER,\n\t\t\t\t\t\t   AUDIT_OBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_obj_role:\n\t\t\tima_log_string(ab, \"obj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_OBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_obj_type:\n\t\t\tima_log_string(ab, \"obj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_OBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_subj_user:\n\t\t\tima_log_string(ab, \"subj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_USER,\n\t\t\t\t\t\t   AUDIT_SUBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_subj_role:\n\t\t\tima_log_string(ab, \"subj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_SUBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_subj_type:\n\t\t\tima_log_string(ab, \"subj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_SUBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_appraise_type:\n\t\t\tif (entry->action != APPRAISE) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tima_log_string(ab, \"appraise_type\", args[0].from);\n\t\t\tif ((strcmp(args[0].from, \"imasig\")) == 0)\n\t\t\t\tentry->flags |= IMA_DIGSIG_REQUIRED;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_permit_directio:\n\t\t\tentry->flags |= IMA_PERMIT_DIRECTIO;\n\t\t\tbreak;\n\t\tcase Opt_pcr:\n\t\t\tif (entry->action != MEASURE) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tima_log_string(ab, \"pcr\", args[0].from);\n\n\t\t\tresult = kstrtoint(args[0].from, 10, &entry->pcr);\n\t\t\tif (result || INVALID_PCR(entry->pcr))\n\t\t\t\tresult = -EINVAL;\n\t\t\telse\n\t\t\t\tentry->flags |= IMA_PCR;\n\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tima_log_string(ab, \"UNKNOWN\", p);\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!result && (entry->action == UNKNOWN))\n\t\tresult = -EINVAL;\n\telse if (entry->func == MODULE_CHECK)\n\t\ttemp_ima_appraise |= IMA_APPRAISE_MODULES;\n\telse if (entry->func == FIRMWARE_CHECK)\n\t\ttemp_ima_appraise |= IMA_APPRAISE_FIRMWARE;\n\telse if (entry->func == POLICY_CHECK)\n\t\ttemp_ima_appraise |= IMA_APPRAISE_POLICY;\n\taudit_log_format(ab, \"res=%d\", !result);\n\taudit_log_end(ab);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->list"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*entry)",
            "GFP_KERNEL"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strspn",
          "args": [
            "p",
            "\" \\t\""
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "p"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&rule",
            "\"\\n\""
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(ima_temp_rules);\n\nssize_t ima_parse_add_rule(char *rule)\n{\n\tstatic const char op[] = \"update_policy\";\n\tchar *p;\n\tstruct ima_rule_entry *entry;\n\tssize_t result, len;\n\tint audit_info = 0;\n\n\tp = strsep(&rule, \"\\n\");\n\tlen = strlen(p) + 1;\n\tp += strspn(p, \" \\t\");\n\n\tif (*p == '#' || *p == '\\0')\n\t\treturn len;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"-ENOMEM\", -ENOMEM, audit_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&entry->list);\n\n\tresult = ima_parse_rule(p, entry);\n\tif (result) {\n\t\tkfree(entry);\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"invalid-policy\", result,\n\t\t\t\t    audit_info);\n\t\treturn result;\n\t}\n\n\tlist_add_tail(&entry->list, &ima_temp_rules);\n\n\treturn len;\n}"
  },
  {
    "function_name": "ima_parse_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "608-893",
    "snippet": "static int ima_parse_rule(char *rule, struct ima_rule_entry *entry)\n{\n\tstruct audit_buffer *ab;\n\tchar *from;\n\tchar *p;\n\tbool uid_token;\n\tint result = 0;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_INTEGRITY_RULE);\n\n\tentry->uid = INVALID_UID;\n\tentry->fowner = INVALID_UID;\n\tentry->uid_op = &uid_eq;\n\tentry->fowner_op = &uid_eq;\n\tentry->action = UNKNOWN;\n\twhile ((p = strsep(&rule, \" \\t\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned long lnum;\n\n\t\tif (result < 0)\n\t\t\tbreak;\n\t\tif ((*p == '\\0') || (*p == ' ') || (*p == '\\t'))\n\t\t\tcontinue;\n\t\ttoken = match_token(p, policy_tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_measure:\n\t\t\tima_log_string(ab, \"action\", \"measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_dont_measure:\n\t\t\tima_log_string(ab, \"action\", \"dont_measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_appraise:\n\t\t\tima_log_string(ab, \"action\", \"appraise\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = APPRAISE;\n\t\t\tbreak;\n\t\tcase Opt_dont_appraise:\n\t\t\tima_log_string(ab, \"action\", \"dont_appraise\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_APPRAISE;\n\t\t\tbreak;\n\t\tcase Opt_audit:\n\t\t\tima_log_string(ab, \"action\", \"audit\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = AUDIT;\n\t\t\tbreak;\n\t\tcase Opt_func:\n\t\t\tima_log_string(ab, \"func\", args[0].from);\n\n\t\t\tif (entry->func)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tif (strcmp(args[0].from, \"FILE_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\t/* PATH_CHECK is for backwards compat */\n\t\t\telse if (strcmp(args[0].from, \"PATH_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"MODULE_CHECK\") == 0)\n\t\t\t\tentry->func = MODULE_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"FIRMWARE_CHECK\") == 0)\n\t\t\t\tentry->func = FIRMWARE_CHECK;\n\t\t\telse if ((strcmp(args[0].from, \"FILE_MMAP\") == 0)\n\t\t\t\t|| (strcmp(args[0].from, \"MMAP_CHECK\") == 0))\n\t\t\t\tentry->func = MMAP_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"BPRM_CHECK\") == 0)\n\t\t\t\tentry->func = BPRM_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"KEXEC_KERNEL_CHECK\") ==\n\t\t\t\t 0)\n\t\t\t\tentry->func = KEXEC_KERNEL_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"KEXEC_INITRAMFS_CHECK\")\n\t\t\t\t == 0)\n\t\t\t\tentry->func = KEXEC_INITRAMFS_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"POLICY_CHECK\") == 0)\n\t\t\t\tentry->func = POLICY_CHECK;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FUNC;\n\t\t\tbreak;\n\t\tcase Opt_mask:\n\t\t\tima_log_string(ab, \"mask\", args[0].from);\n\n\t\t\tif (entry->mask)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tfrom = args[0].from;\n\t\t\tif (*from == '^')\n\t\t\t\tfrom++;\n\n\t\t\tif ((strcmp(from, \"MAY_EXEC\")) == 0)\n\t\t\t\tentry->mask = MAY_EXEC;\n\t\t\telse if (strcmp(from, \"MAY_WRITE\") == 0)\n\t\t\t\tentry->mask = MAY_WRITE;\n\t\t\telse if (strcmp(from, \"MAY_READ\") == 0)\n\t\t\t\tentry->mask = MAY_READ;\n\t\t\telse if (strcmp(from, \"MAY_APPEND\") == 0)\n\t\t\t\tentry->mask = MAY_APPEND;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= (*args[0].from == '^')\n\t\t\t\t     ? IMA_INMASK : IMA_MASK;\n\t\t\tbreak;\n\t\tcase Opt_fsmagic:\n\t\t\tima_log_string(ab, \"fsmagic\", args[0].from);\n\n\t\t\tif (entry->fsmagic) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 16, &entry->fsmagic);\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FSMAGIC;\n\t\t\tbreak;\n\t\tcase Opt_fsuuid:\n\t\t\tima_log_string(ab, \"fsuuid\", args[0].from);\n\n\t\t\tif (uuid_is_null(&entry->fsuuid)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = uuid_parse(args[0].from, &entry->fsuuid);\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FSUUID;\n\t\t\tbreak;\n\t\tcase Opt_uid_gt:\n\t\tcase Opt_euid_gt:\n\t\t\tentry->uid_op = &uid_gt;\n\t\tcase Opt_uid_lt:\n\t\tcase Opt_euid_lt:\n\t\t\tif ((token == Opt_uid_lt) || (token == Opt_euid_lt))\n\t\t\t\tentry->uid_op = &uid_lt;\n\t\tcase Opt_uid_eq:\n\t\tcase Opt_euid_eq:\n\t\t\tuid_token = (token == Opt_uid_eq) ||\n\t\t\t\t    (token == Opt_uid_gt) ||\n\t\t\t\t    (token == Opt_uid_lt);\n\n\t\t\tima_log_string_op(ab, uid_token ? \"uid\" : \"euid\",\n\t\t\t\t\t  args[0].from, entry->uid_op);\n\n\t\t\tif (uid_valid(entry->uid)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->uid = make_kuid(current_user_ns(),\n\t\t\t\t\t\t       (uid_t) lnum);\n\t\t\t\tif (!uid_valid(entry->uid) ||\n\t\t\t\t    (uid_t)lnum != lnum)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= uid_token\n\t\t\t\t\t    ? IMA_UID : IMA_EUID;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_fowner_gt:\n\t\t\tentry->fowner_op = &uid_gt;\n\t\tcase Opt_fowner_lt:\n\t\t\tif (token == Opt_fowner_lt)\n\t\t\t\tentry->fowner_op = &uid_lt;\n\t\tcase Opt_fowner_eq:\n\t\t\tima_log_string_op(ab, \"fowner\", args[0].from,\n\t\t\t\t\t  entry->fowner_op);\n\n\t\t\tif (uid_valid(entry->fowner)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->fowner = make_kuid(current_user_ns(), (uid_t)lnum);\n\t\t\t\tif (!uid_valid(entry->fowner) || (((uid_t)lnum) != lnum))\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= IMA_FOWNER;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_obj_user:\n\t\t\tima_log_string(ab, \"obj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_USER,\n\t\t\t\t\t\t   AUDIT_OBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_obj_role:\n\t\t\tima_log_string(ab, \"obj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_OBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_obj_type:\n\t\t\tima_log_string(ab, \"obj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_OBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_subj_user:\n\t\t\tima_log_string(ab, \"subj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_USER,\n\t\t\t\t\t\t   AUDIT_SUBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_subj_role:\n\t\t\tima_log_string(ab, \"subj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_SUBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_subj_type:\n\t\t\tima_log_string(ab, \"subj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_SUBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_appraise_type:\n\t\t\tif (entry->action != APPRAISE) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tima_log_string(ab, \"appraise_type\", args[0].from);\n\t\t\tif ((strcmp(args[0].from, \"imasig\")) == 0)\n\t\t\t\tentry->flags |= IMA_DIGSIG_REQUIRED;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_permit_directio:\n\t\t\tentry->flags |= IMA_PERMIT_DIRECTIO;\n\t\t\tbreak;\n\t\tcase Opt_pcr:\n\t\t\tif (entry->action != MEASURE) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tima_log_string(ab, \"pcr\", args[0].from);\n\n\t\t\tresult = kstrtoint(args[0].from, 10, &entry->pcr);\n\t\t\tif (result || INVALID_PCR(entry->pcr))\n\t\t\t\tresult = -EINVAL;\n\t\t\telse\n\t\t\t\tentry->flags |= IMA_PCR;\n\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tima_log_string(ab, \"UNKNOWN\", p);\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!result && (entry->action == UNKNOWN))\n\t\tresult = -EINVAL;\n\telse if (entry->func == MODULE_CHECK)\n\t\ttemp_ima_appraise |= IMA_APPRAISE_MODULES;\n\telse if (entry->func == FIRMWARE_CHECK)\n\t\ttemp_ima_appraise |= IMA_APPRAISE_FIRMWARE;\n\telse if (entry->func == POLICY_CHECK)\n\t\ttemp_ima_appraise |= IMA_APPRAISE_POLICY;\n\taudit_log_format(ab, \"res=%d\", !result);\n\taudit_log_end(ab);\n\treturn result;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define AUDIT\t\t0x0040",
      "#define DONT_APPRAISE\t0x0008",
      "#define APPRAISE\t0x0004\t/* same as IMA_APPRAISE */",
      "#define DONT_MEASURE\t0x0002",
      "#define MEASURE\t\t0x0001\t/* same as IMA_MEASURE */",
      "#define UNKNOWN\t\t0",
      "#define IMA_PCR\t\t0x0100",
      "#define IMA_EUID\t0x0080",
      "#define IMA_INMASK\t0x0040",
      "#define IMA_FSUUID\t0x0020",
      "#define IMA_FOWNER\t0x0010",
      "#define IMA_UID\t\t0x0008",
      "#define IMA_FSMAGIC\t0x0004",
      "#define IMA_MASK\t0x0002",
      "#define IMA_FUNC\t0x0001"
    ],
    "globals_used": [
      "static int temp_ima_appraise;",
      "static match_table_t policy_tokens = {\n\t{Opt_measure, \"measure\"},\n\t{Opt_dont_measure, \"dont_measure\"},\n\t{Opt_appraise, \"appraise\"},\n\t{Opt_dont_appraise, \"dont_appraise\"},\n\t{Opt_audit, \"audit\"},\n\t{Opt_obj_user, \"obj_user=%s\"},\n\t{Opt_obj_role, \"obj_role=%s\"},\n\t{Opt_obj_type, \"obj_type=%s\"},\n\t{Opt_subj_user, \"subj_user=%s\"},\n\t{Opt_subj_role, \"subj_role=%s\"},\n\t{Opt_subj_type, \"subj_type=%s\"},\n\t{Opt_func, \"func=%s\"},\n\t{Opt_mask, \"mask=%s\"},\n\t{Opt_fsmagic, \"fsmagic=%s\"},\n\t{Opt_fsuuid, \"fsuuid=%s\"},\n\t{Opt_uid_eq, \"uid=%s\"},\n\t{Opt_euid_eq, \"euid=%s\"},\n\t{Opt_fowner_eq, \"fowner=%s\"},\n\t{Opt_uid_gt, \"uid>%s\"},\n\t{Opt_euid_gt, \"euid>%s\"},\n\t{Opt_fowner_gt, \"fowner>%s\"},\n\t{Opt_uid_lt, \"uid<%s\"},\n\t{Opt_euid_lt, \"euid<%s\"},\n\t{Opt_fowner_lt, \"fowner<%s\"},\n\t{Opt_appraise_type, \"appraise_type=%s\"},\n\t{Opt_permit_directio, \"permit_directio\"},\n\t{Opt_pcr, \"pcr=%s\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"res=%d\"",
            "!result"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_log_string",
          "args": [
            "ab",
            "\"UNKNOWN\"",
            "p"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "ima_log_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "603-606",
          "snippet": "static void ima_log_string(struct audit_buffer *ab, char *key, char *value)\n{\n\tima_log_string_op(ab, key, value, NULL);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic void ima_log_string(struct audit_buffer *ab, char *key, char *value)\n{\n\tima_log_string_op(ab, key, value, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "INVALID_PCR",
          "args": [
            "entry->pcr"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoint",
          "args": [
            "args[0].from",
            "10",
            "&entry->pcr"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"imasig\""
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_lsm_rule_init",
          "args": [
            "entry",
            "args",
            "LSM_SUBJ_TYPE",
            "AUDIT_SUBJ_TYPE"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "ima_lsm_rule_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "566-589",
          "snippet": "static int ima_lsm_rule_init(struct ima_rule_entry *entry,\n\t\t\t     substring_t *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\n\tentry->lsm[lsm_rule].args_p = match_strdup(args);\n\tif (!entry->lsm[lsm_rule].args_p)\n\t\treturn -ENOMEM;\n\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n\t\t\t\t\t   Audit_equal,\n\t\t\t\t\t   entry->lsm[lsm_rule].args_p,\n\t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n\tif (!entry->lsm[lsm_rule].rule) {\n\t\tkfree(entry->lsm[lsm_rule].args_p);\n\t\treturn -EINVAL;\n\t}\n\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic int ima_lsm_rule_init(struct ima_rule_entry *entry,\n\t\t\t     substring_t *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\n\tentry->lsm[lsm_rule].args_p = match_strdup(args);\n\tif (!entry->lsm[lsm_rule].args_p)\n\t\treturn -ENOMEM;\n\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n\t\t\t\t\t   Audit_equal,\n\t\t\t\t\t   entry->lsm[lsm_rule].args_p,\n\t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n\tif (!entry->lsm[lsm_rule].rule) {\n\t\tkfree(entry->lsm[lsm_rule].args_p);\n\t\treturn -EINVAL;\n\t}\n\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "entry->fowner"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "(uid_t)lnum"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "args[0].from",
            "10",
            "&lnum"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "entry->fowner"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_log_string_op",
          "args": [
            "ab",
            "\"fowner\"",
            "args[0].from",
            "entry->fowner_op"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "ima_log_string_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "591-602",
          "snippet": "static void ima_log_string_op(struct audit_buffer *ab, char *key, char *value,\n\t\t\t      bool (*rule_operator)(kuid_t, kuid_t))\n{\n\tif (rule_operator == &uid_gt)\n\t\taudit_log_format(ab, \"%s>\", key);\n\telse if (rule_operator == &uid_lt)\n\t\taudit_log_format(ab, \"%s<\", key);\n\telse\n\t\taudit_log_format(ab, \"%s=\", key);\n\taudit_log_untrustedstring(ab, value);\n\taudit_log_format(ab, \" \");\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic void ima_log_string_op(struct audit_buffer *ab, char *key, char *value,\n\t\t\t      bool (*rule_operator)(kuid_t, kuid_t))\n{\n\tif (rule_operator == &uid_gt)\n\t\taudit_log_format(ab, \"%s>\", key);\n\telse if (rule_operator == &uid_lt)\n\t\taudit_log_format(ab, \"%s<\", key);\n\telse\n\t\taudit_log_format(ab, \"%s=\", key);\n\taudit_log_untrustedstring(ab, value);\n\taudit_log_format(ab, \" \");\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "entry->uid"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "(uid_t) lnum"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "args[0].from",
            "10",
            "&lnum"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "entry->uid"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_parse",
          "args": [
            "args[0].from",
            "&entry->fsuuid"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_is_null",
          "args": [
            "&entry->fsuuid"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "args[0].from",
            "16",
            "&entry->fsmagic"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "from",
            "\"MAY_APPEND\""
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "from",
            "\"MAY_READ\""
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "from",
            "\"MAY_WRITE\""
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "from",
            "\"MAY_EXEC\""
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"POLICY_CHECK\""
          ],
          "line": 700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"KEXEC_INITRAMFS_CHECK\""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"KEXEC_KERNEL_CHECK\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"BPRM_CHECK\""
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"MMAP_CHECK\""
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"FILE_MMAP\""
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"FIRMWARE_CHECK\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"MODULE_CHECK\""
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"PATH_CHECK\""
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "\"FILE_CHECK\""
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "policy_tokens",
            "args"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&rule",
            "\" \\t\""
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "NULL",
            "GFP_KERNEL",
            "AUDIT_INTEGRITY_RULE"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define AUDIT\t\t0x0040\n#define DONT_APPRAISE\t0x0008\n#define APPRAISE\t0x0004\t/* same as IMA_APPRAISE */\n#define DONT_MEASURE\t0x0002\n#define MEASURE\t\t0x0001\t/* same as IMA_MEASURE */\n#define UNKNOWN\t\t0\n#define IMA_PCR\t\t0x0100\n#define IMA_EUID\t0x0080\n#define IMA_INMASK\t0x0040\n#define IMA_FSUUID\t0x0020\n#define IMA_FOWNER\t0x0010\n#define IMA_UID\t\t0x0008\n#define IMA_FSMAGIC\t0x0004\n#define IMA_MASK\t0x0002\n#define IMA_FUNC\t0x0001\n\nstatic int temp_ima_appraise;\nstatic match_table_t policy_tokens = {\n\t{Opt_measure, \"measure\"},\n\t{Opt_dont_measure, \"dont_measure\"},\n\t{Opt_appraise, \"appraise\"},\n\t{Opt_dont_appraise, \"dont_appraise\"},\n\t{Opt_audit, \"audit\"},\n\t{Opt_obj_user, \"obj_user=%s\"},\n\t{Opt_obj_role, \"obj_role=%s\"},\n\t{Opt_obj_type, \"obj_type=%s\"},\n\t{Opt_subj_user, \"subj_user=%s\"},\n\t{Opt_subj_role, \"subj_role=%s\"},\n\t{Opt_subj_type, \"subj_type=%s\"},\n\t{Opt_func, \"func=%s\"},\n\t{Opt_mask, \"mask=%s\"},\n\t{Opt_fsmagic, \"fsmagic=%s\"},\n\t{Opt_fsuuid, \"fsuuid=%s\"},\n\t{Opt_uid_eq, \"uid=%s\"},\n\t{Opt_euid_eq, \"euid=%s\"},\n\t{Opt_fowner_eq, \"fowner=%s\"},\n\t{Opt_uid_gt, \"uid>%s\"},\n\t{Opt_euid_gt, \"euid>%s\"},\n\t{Opt_fowner_gt, \"fowner>%s\"},\n\t{Opt_uid_lt, \"uid<%s\"},\n\t{Opt_euid_lt, \"euid<%s\"},\n\t{Opt_fowner_lt, \"fowner<%s\"},\n\t{Opt_appraise_type, \"appraise_type=%s\"},\n\t{Opt_permit_directio, \"permit_directio\"},\n\t{Opt_pcr, \"pcr=%s\"},\n\t{Opt_err, NULL}\n};\n\nstatic int ima_parse_rule(char *rule, struct ima_rule_entry *entry)\n{\n\tstruct audit_buffer *ab;\n\tchar *from;\n\tchar *p;\n\tbool uid_token;\n\tint result = 0;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_INTEGRITY_RULE);\n\n\tentry->uid = INVALID_UID;\n\tentry->fowner = INVALID_UID;\n\tentry->uid_op = &uid_eq;\n\tentry->fowner_op = &uid_eq;\n\tentry->action = UNKNOWN;\n\twhile ((p = strsep(&rule, \" \\t\")) != NULL) {\n\t\tsubstring_t args[MAX_OPT_ARGS];\n\t\tint token;\n\t\tunsigned long lnum;\n\n\t\tif (result < 0)\n\t\t\tbreak;\n\t\tif ((*p == '\\0') || (*p == ' ') || (*p == '\\t'))\n\t\t\tcontinue;\n\t\ttoken = match_token(p, policy_tokens, args);\n\t\tswitch (token) {\n\t\tcase Opt_measure:\n\t\t\tima_log_string(ab, \"action\", \"measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_dont_measure:\n\t\t\tima_log_string(ab, \"action\", \"dont_measure\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_MEASURE;\n\t\t\tbreak;\n\t\tcase Opt_appraise:\n\t\t\tima_log_string(ab, \"action\", \"appraise\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = APPRAISE;\n\t\t\tbreak;\n\t\tcase Opt_dont_appraise:\n\t\t\tima_log_string(ab, \"action\", \"dont_appraise\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = DONT_APPRAISE;\n\t\t\tbreak;\n\t\tcase Opt_audit:\n\t\t\tima_log_string(ab, \"action\", \"audit\");\n\n\t\t\tif (entry->action != UNKNOWN)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tentry->action = AUDIT;\n\t\t\tbreak;\n\t\tcase Opt_func:\n\t\t\tima_log_string(ab, \"func\", args[0].from);\n\n\t\t\tif (entry->func)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tif (strcmp(args[0].from, \"FILE_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\t/* PATH_CHECK is for backwards compat */\n\t\t\telse if (strcmp(args[0].from, \"PATH_CHECK\") == 0)\n\t\t\t\tentry->func = FILE_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"MODULE_CHECK\") == 0)\n\t\t\t\tentry->func = MODULE_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"FIRMWARE_CHECK\") == 0)\n\t\t\t\tentry->func = FIRMWARE_CHECK;\n\t\t\telse if ((strcmp(args[0].from, \"FILE_MMAP\") == 0)\n\t\t\t\t|| (strcmp(args[0].from, \"MMAP_CHECK\") == 0))\n\t\t\t\tentry->func = MMAP_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"BPRM_CHECK\") == 0)\n\t\t\t\tentry->func = BPRM_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"KEXEC_KERNEL_CHECK\") ==\n\t\t\t\t 0)\n\t\t\t\tentry->func = KEXEC_KERNEL_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"KEXEC_INITRAMFS_CHECK\")\n\t\t\t\t == 0)\n\t\t\t\tentry->func = KEXEC_INITRAMFS_CHECK;\n\t\t\telse if (strcmp(args[0].from, \"POLICY_CHECK\") == 0)\n\t\t\t\tentry->func = POLICY_CHECK;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FUNC;\n\t\t\tbreak;\n\t\tcase Opt_mask:\n\t\t\tima_log_string(ab, \"mask\", args[0].from);\n\n\t\t\tif (entry->mask)\n\t\t\t\tresult = -EINVAL;\n\n\t\t\tfrom = args[0].from;\n\t\t\tif (*from == '^')\n\t\t\t\tfrom++;\n\n\t\t\tif ((strcmp(from, \"MAY_EXEC\")) == 0)\n\t\t\t\tentry->mask = MAY_EXEC;\n\t\t\telse if (strcmp(from, \"MAY_WRITE\") == 0)\n\t\t\t\tentry->mask = MAY_WRITE;\n\t\t\telse if (strcmp(from, \"MAY_READ\") == 0)\n\t\t\t\tentry->mask = MAY_READ;\n\t\t\telse if (strcmp(from, \"MAY_APPEND\") == 0)\n\t\t\t\tentry->mask = MAY_APPEND;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= (*args[0].from == '^')\n\t\t\t\t     ? IMA_INMASK : IMA_MASK;\n\t\t\tbreak;\n\t\tcase Opt_fsmagic:\n\t\t\tima_log_string(ab, \"fsmagic\", args[0].from);\n\n\t\t\tif (entry->fsmagic) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 16, &entry->fsmagic);\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FSMAGIC;\n\t\t\tbreak;\n\t\tcase Opt_fsuuid:\n\t\t\tima_log_string(ab, \"fsuuid\", args[0].from);\n\n\t\t\tif (uuid_is_null(&entry->fsuuid)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = uuid_parse(args[0].from, &entry->fsuuid);\n\t\t\tif (!result)\n\t\t\t\tentry->flags |= IMA_FSUUID;\n\t\t\tbreak;\n\t\tcase Opt_uid_gt:\n\t\tcase Opt_euid_gt:\n\t\t\tentry->uid_op = &uid_gt;\n\t\tcase Opt_uid_lt:\n\t\tcase Opt_euid_lt:\n\t\t\tif ((token == Opt_uid_lt) || (token == Opt_euid_lt))\n\t\t\t\tentry->uid_op = &uid_lt;\n\t\tcase Opt_uid_eq:\n\t\tcase Opt_euid_eq:\n\t\t\tuid_token = (token == Opt_uid_eq) ||\n\t\t\t\t    (token == Opt_uid_gt) ||\n\t\t\t\t    (token == Opt_uid_lt);\n\n\t\t\tima_log_string_op(ab, uid_token ? \"uid\" : \"euid\",\n\t\t\t\t\t  args[0].from, entry->uid_op);\n\n\t\t\tif (uid_valid(entry->uid)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->uid = make_kuid(current_user_ns(),\n\t\t\t\t\t\t       (uid_t) lnum);\n\t\t\t\tif (!uid_valid(entry->uid) ||\n\t\t\t\t    (uid_t)lnum != lnum)\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= uid_token\n\t\t\t\t\t    ? IMA_UID : IMA_EUID;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_fowner_gt:\n\t\t\tentry->fowner_op = &uid_gt;\n\t\tcase Opt_fowner_lt:\n\t\t\tif (token == Opt_fowner_lt)\n\t\t\t\tentry->fowner_op = &uid_lt;\n\t\tcase Opt_fowner_eq:\n\t\t\tima_log_string_op(ab, \"fowner\", args[0].from,\n\t\t\t\t\t  entry->fowner_op);\n\n\t\t\tif (uid_valid(entry->fowner)) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tresult = kstrtoul(args[0].from, 10, &lnum);\n\t\t\tif (!result) {\n\t\t\t\tentry->fowner = make_kuid(current_user_ns(), (uid_t)lnum);\n\t\t\t\tif (!uid_valid(entry->fowner) || (((uid_t)lnum) != lnum))\n\t\t\t\t\tresult = -EINVAL;\n\t\t\t\telse\n\t\t\t\t\tentry->flags |= IMA_FOWNER;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_obj_user:\n\t\t\tima_log_string(ab, \"obj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_USER,\n\t\t\t\t\t\t   AUDIT_OBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_obj_role:\n\t\t\tima_log_string(ab, \"obj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_OBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_obj_type:\n\t\t\tima_log_string(ab, \"obj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_OBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_OBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_subj_user:\n\t\t\tima_log_string(ab, \"subj_user\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_USER,\n\t\t\t\t\t\t   AUDIT_SUBJ_USER);\n\t\t\tbreak;\n\t\tcase Opt_subj_role:\n\t\t\tima_log_string(ab, \"subj_role\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_ROLE,\n\t\t\t\t\t\t   AUDIT_SUBJ_ROLE);\n\t\t\tbreak;\n\t\tcase Opt_subj_type:\n\t\t\tima_log_string(ab, \"subj_type\", args[0].from);\n\t\t\tresult = ima_lsm_rule_init(entry, args,\n\t\t\t\t\t\t   LSM_SUBJ_TYPE,\n\t\t\t\t\t\t   AUDIT_SUBJ_TYPE);\n\t\t\tbreak;\n\t\tcase Opt_appraise_type:\n\t\t\tif (entry->action != APPRAISE) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tima_log_string(ab, \"appraise_type\", args[0].from);\n\t\t\tif ((strcmp(args[0].from, \"imasig\")) == 0)\n\t\t\t\tentry->flags |= IMA_DIGSIG_REQUIRED;\n\t\t\telse\n\t\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_permit_directio:\n\t\t\tentry->flags |= IMA_PERMIT_DIRECTIO;\n\t\t\tbreak;\n\t\tcase Opt_pcr:\n\t\t\tif (entry->action != MEASURE) {\n\t\t\t\tresult = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tima_log_string(ab, \"pcr\", args[0].from);\n\n\t\t\tresult = kstrtoint(args[0].from, 10, &entry->pcr);\n\t\t\tif (result || INVALID_PCR(entry->pcr))\n\t\t\t\tresult = -EINVAL;\n\t\t\telse\n\t\t\t\tentry->flags |= IMA_PCR;\n\n\t\t\tbreak;\n\t\tcase Opt_err:\n\t\t\tima_log_string(ab, \"UNKNOWN\", p);\n\t\t\tresult = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!result && (entry->action == UNKNOWN))\n\t\tresult = -EINVAL;\n\telse if (entry->func == MODULE_CHECK)\n\t\ttemp_ima_appraise |= IMA_APPRAISE_MODULES;\n\telse if (entry->func == FIRMWARE_CHECK)\n\t\ttemp_ima_appraise |= IMA_APPRAISE_FIRMWARE;\n\telse if (entry->func == POLICY_CHECK)\n\t\ttemp_ima_appraise |= IMA_APPRAISE_POLICY;\n\taudit_log_format(ab, \"res=%d\", !result);\n\taudit_log_end(ab);\n\treturn result;\n}"
  },
  {
    "function_name": "ima_log_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "603-606",
    "snippet": "static void ima_log_string(struct audit_buffer *ab, char *key, char *value)\n{\n\tima_log_string_op(ab, key, value, NULL);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_log_string_op",
          "args": [
            "ab",
            "key",
            "value",
            "NULL"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "ima_log_string_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "591-602",
          "snippet": "static void ima_log_string_op(struct audit_buffer *ab, char *key, char *value,\n\t\t\t      bool (*rule_operator)(kuid_t, kuid_t))\n{\n\tif (rule_operator == &uid_gt)\n\t\taudit_log_format(ab, \"%s>\", key);\n\telse if (rule_operator == &uid_lt)\n\t\taudit_log_format(ab, \"%s<\", key);\n\telse\n\t\taudit_log_format(ab, \"%s=\", key);\n\taudit_log_untrustedstring(ab, value);\n\taudit_log_format(ab, \" \");\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic void ima_log_string_op(struct audit_buffer *ab, char *key, char *value,\n\t\t\t      bool (*rule_operator)(kuid_t, kuid_t))\n{\n\tif (rule_operator == &uid_gt)\n\t\taudit_log_format(ab, \"%s>\", key);\n\telse if (rule_operator == &uid_lt)\n\t\taudit_log_format(ab, \"%s<\", key);\n\telse\n\t\taudit_log_format(ab, \"%s=\", key);\n\taudit_log_untrustedstring(ab, value);\n\taudit_log_format(ab, \" \");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic void ima_log_string(struct audit_buffer *ab, char *key, char *value)\n{\n\tima_log_string_op(ab, key, value, NULL);\n}"
  },
  {
    "function_name": "ima_log_string_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "591-602",
    "snippet": "static void ima_log_string_op(struct audit_buffer *ab, char *key, char *value,\n\t\t\t      bool (*rule_operator)(kuid_t, kuid_t))\n{\n\tif (rule_operator == &uid_gt)\n\t\taudit_log_format(ab, \"%s>\", key);\n\telse if (rule_operator == &uid_lt)\n\t\taudit_log_format(ab, \"%s<\", key);\n\telse\n\t\taudit_log_format(ab, \"%s=\", key);\n\taudit_log_untrustedstring(ab, value);\n\taudit_log_format(ab, \" \");\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" \""
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "value"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"%s=\"",
            "key"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"%s<\"",
            "key"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"%s>\"",
            "key"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic void ima_log_string_op(struct audit_buffer *ab, char *key, char *value,\n\t\t\t      bool (*rule_operator)(kuid_t, kuid_t))\n{\n\tif (rule_operator == &uid_gt)\n\t\taudit_log_format(ab, \"%s>\", key);\n\telse if (rule_operator == &uid_lt)\n\t\taudit_log_format(ab, \"%s<\", key);\n\telse\n\t\taudit_log_format(ab, \"%s=\", key);\n\taudit_log_untrustedstring(ab, value);\n\taudit_log_format(ab, \" \");\n}"
  },
  {
    "function_name": "ima_lsm_rule_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "566-589",
    "snippet": "static int ima_lsm_rule_init(struct ima_rule_entry *entry,\n\t\t\t     substring_t *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\n\tentry->lsm[lsm_rule].args_p = match_strdup(args);\n\tif (!entry->lsm[lsm_rule].args_p)\n\t\treturn -ENOMEM;\n\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n\t\t\t\t\t   Audit_equal,\n\t\t\t\t\t   entry->lsm[lsm_rule].args_p,\n\t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n\tif (!entry->lsm[lsm_rule].rule) {\n\t\tkfree(entry->lsm[lsm_rule].args_p);\n\t\treturn -EINVAL;\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry->lsm[lsm_rule].args_p"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_filter_rule_init",
          "args": [
            "entry->lsm[lsm_rule].type",
            "Audit_equal",
            "entry->lsm[lsm_rule].args_p",
            "&entry->lsm[lsm_rule].rule"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "security_filter_rule_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima.h",
          "lines": "302-306",
          "snippet": "static inline int security_filter_rule_init(u32 field, u32 op, char *rulestr,\n\t\t\t\t\t    void **lsmrule)\n{\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/ima.h>",
            "#include \"../integrity.h\"",
            "#include <crypto/hash_info.h>",
            "#include <linux/audit.h>",
            "#include <linux/tpm.h>",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/crypto.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define security_filter_rule_init security_audit_rule_init"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ima.h>\n#include \"../integrity.h\"\n#include <crypto/hash_info.h>\n#include <linux/audit.h>\n#include <linux/tpm.h>\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n\n#define security_filter_rule_init security_audit_rule_init\n\nstatic inline int security_filter_rule_init(u32 field, u32 op, char *rulestr,\n\t\t\t\t\t    void **lsmrule)\n{\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_strdup",
          "args": [
            "args"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic int ima_lsm_rule_init(struct ima_rule_entry *entry,\n\t\t\t     substring_t *args, int lsm_rule, int audit_type)\n{\n\tint result;\n\n\tif (entry->lsm[lsm_rule].rule)\n\t\treturn -EINVAL;\n\n\tentry->lsm[lsm_rule].args_p = match_strdup(args);\n\tif (!entry->lsm[lsm_rule].args_p)\n\t\treturn -ENOMEM;\n\n\tentry->lsm[lsm_rule].type = audit_type;\n\tresult = security_filter_rule_init(entry->lsm[lsm_rule].type,\n\t\t\t\t\t   Audit_equal,\n\t\t\t\t\t   entry->lsm[lsm_rule].args_p,\n\t\t\t\t\t   &entry->lsm[lsm_rule].rule);\n\tif (!entry->lsm[lsm_rule].rule) {\n\t\tkfree(entry->lsm[lsm_rule].args_p);\n\t\treturn -EINVAL;\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "ima_update_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "494-518",
    "snippet": "void ima_update_policy(void)\n{\n\tstruct list_head *first, *last, *policy;\n\n\t/* append current policy with the new rules */\n\tfirst = (&ima_temp_rules)->next;\n\tlast = (&ima_temp_rules)->prev;\n\tpolicy = &ima_policy_rules;\n\n\tsynchronize_rcu();\n\n\tlast->next = policy;\n\trcu_assign_pointer(list_next_rcu(policy->prev), first);\n\tfirst->prev = policy->prev;\n\tpolicy->prev = last;\n\n\t/* prepare for the next policy rules addition */\n\tINIT_LIST_HEAD(&ima_temp_rules);\n\n\tif (ima_rules != policy) {\n\t\tima_policy_flag = 0;\n\t\tima_rules = policy;\n\t}\n\tima_update_policy_flag();\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ima_policy_flag;",
      "static LIST_HEAD(ima_policy_rules);",
      "static LIST_HEAD(ima_temp_rules);",
      "static struct list_head *ima_rules;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_update_policy_flag",
          "args": [],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "ima_update_policy_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "408-420",
          "snippet": "void ima_update_policy_flag(void)\n{\n\tstruct ima_rule_entry *entry;\n\n\tlist_for_each_entry(entry, ima_rules, list) {\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tima_policy_flag |= entry->action;\n\t}\n\n\tima_appraise |= temp_ima_appraise;\n\tif (!ima_appraise)\n\t\tima_policy_flag &= ~IMA_APPRAISE;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ima_policy_flag;",
            "static int temp_ima_appraise;",
            "static struct list_head *ima_rules;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nint ima_policy_flag;\nstatic int temp_ima_appraise;\nstatic struct list_head *ima_rules;\n\nvoid ima_update_policy_flag(void)\n{\n\tstruct ima_rule_entry *entry;\n\n\tlist_for_each_entry(entry, ima_rules, list) {\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tima_policy_flag |= entry->action;\n\t}\n\n\tima_appraise |= temp_ima_appraise;\n\tif (!ima_appraise)\n\t\tima_policy_flag &= ~IMA_APPRAISE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&ima_temp_rules"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "list_next_rcu(policy->prev)",
            "first"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_rcu",
          "args": [
            "policy->prev"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nint ima_policy_flag;\nstatic LIST_HEAD(ima_policy_rules);\nstatic LIST_HEAD(ima_temp_rules);\nstatic struct list_head *ima_rules;\n\nvoid ima_update_policy(void)\n{\n\tstruct list_head *first, *last, *policy;\n\n\t/* append current policy with the new rules */\n\tfirst = (&ima_temp_rules)->next;\n\tlast = (&ima_temp_rules)->prev;\n\tpolicy = &ima_policy_rules;\n\n\tsynchronize_rcu();\n\n\tlast->next = policy;\n\trcu_assign_pointer(list_next_rcu(policy->prev), first);\n\tfirst->prev = policy->prev;\n\tpolicy->prev = last;\n\n\t/* prepare for the next policy rules addition */\n\tINIT_LIST_HEAD(&ima_temp_rules);\n\n\tif (ima_rules != policy) {\n\t\tima_policy_flag = 0;\n\t\tima_rules = policy;\n\t}\n\tima_update_policy_flag();\n}"
  },
  {
    "function_name": "ima_check_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "476-481",
    "snippet": "int ima_check_policy(void)\n{\n\tif (list_empty(&ima_temp_rules))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(ima_temp_rules);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&ima_temp_rules"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(ima_temp_rules);\n\nint ima_check_policy(void)\n{\n\tif (list_empty(&ima_temp_rules))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
  },
  {
    "function_name": "ima_init_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "428-473",
    "snippet": "void __init ima_init_policy(void)\n{\n\tint i, measure_entries, appraise_entries, secure_boot_entries;\n\n\t/* if !ima_policy set entries = 0 so we load NO default rules */\n\tmeasure_entries = ima_policy ? ARRAY_SIZE(dont_measure_rules) : 0;\n\tappraise_entries = ima_use_appraise_tcb ?\n\t\t\t ARRAY_SIZE(default_appraise_rules) : 0;\n\tsecure_boot_entries = ima_use_secure_boot ?\n\t\t\tARRAY_SIZE(secure_boot_rules) : 0;\n\n\tfor (i = 0; i < measure_entries; i++)\n\t\tlist_add_tail(&dont_measure_rules[i].list, &ima_default_rules);\n\n\tswitch (ima_policy) {\n\tcase ORIGINAL_TCB:\n\t\tfor (i = 0; i < ARRAY_SIZE(original_measurement_rules); i++)\n\t\t\tlist_add_tail(&original_measurement_rules[i].list,\n\t\t\t\t      &ima_default_rules);\n\t\tbreak;\n\tcase DEFAULT_TCB:\n\t\tfor (i = 0; i < ARRAY_SIZE(default_measurement_rules); i++)\n\t\t\tlist_add_tail(&default_measurement_rules[i].list,\n\t\t\t\t      &ima_default_rules);\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Insert the appraise rules requiring file signatures, prior to\n\t * any other appraise rules.\n\t */\n\tfor (i = 0; i < secure_boot_entries; i++)\n\t\tlist_add_tail(&secure_boot_rules[i].list,\n\t\t\t      &ima_default_rules);\n\n\tfor (i = 0; i < appraise_entries; i++) {\n\t\tlist_add_tail(&default_appraise_rules[i].list,\n\t\t\t      &ima_default_rules);\n\t\tif (default_appraise_rules[i].func == POLICY_CHECK)\n\t\t\ttemp_ima_appraise |= IMA_APPRAISE_POLICY;\n\t}\n\n\tima_rules = &ima_default_rules;\n\tima_update_policy_flag();\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int temp_ima_appraise;",
      "static struct ima_rule_entry dont_measure_rules[] __ro_after_init = {\n\t{.action = DONT_MEASURE, .fsmagic = PROC_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SYSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = DEBUGFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = TMPFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = DEVPTS_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = CGROUP_SUPER_MAGIC,\n\t .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = CGROUP2_SUPER_MAGIC,\n\t .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC}\n};",
      "static struct ima_rule_entry original_measurement_rules[] __ro_after_init = {\n\t{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_MASK | IMA_UID},\n\t{.action = MEASURE, .func = MODULE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},\n};",
      "static struct ima_rule_entry default_measurement_rules[] __ro_after_init = {\n\t{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_INMASK | IMA_EUID},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_INMASK | IMA_UID},\n\t{.action = MEASURE, .func = MODULE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = POLICY_CHECK, .flags = IMA_FUNC},\n};",
      "static struct ima_rule_entry default_appraise_rules[] __ro_after_init = {\n\t{.action = DONT_APPRAISE, .fsmagic = PROC_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SYSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = DEBUGFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = TMPFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = RAMFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = DEVPTS_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = CGROUP_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = CGROUP2_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n#ifdef CONFIG_IMA_WRITE_POLICY\n\t{.action = APPRAISE, .func = POLICY_CHECK,\n\t.flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n#endif\n#ifndef CONFIG_IMA_APPRAISE_SIGNED_INIT\n\t{.action = APPRAISE, .fowner = GLOBAL_ROOT_UID, .fowner_op = &uid_eq,\n\t .flags = IMA_FOWNER},\n#else\n\t/* force signature */\n\t{.action = APPRAISE, .fowner = GLOBAL_ROOT_UID, .fowner_op = &uid_eq,\n\t .flags = IMA_FOWNER | IMA_DIGSIG_REQUIRED},\n#endif\n};",
      "static struct ima_rule_entry secure_boot_rules[] __ro_after_init = {\n\t{.action = APPRAISE, .func = MODULE_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = FIRMWARE_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = KEXEC_KERNEL_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = POLICY_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n};",
      "static LIST_HEAD(ima_default_rules);",
      "static struct list_head *ima_rules;",
      "static int ima_policy",
      "static bool ima_use_appraise_tcb",
      "static bool ima_use_secure_boot"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_update_policy_flag",
          "args": [],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "ima_update_policy_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "408-420",
          "snippet": "void ima_update_policy_flag(void)\n{\n\tstruct ima_rule_entry *entry;\n\n\tlist_for_each_entry(entry, ima_rules, list) {\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tima_policy_flag |= entry->action;\n\t}\n\n\tima_appraise |= temp_ima_appraise;\n\tif (!ima_appraise)\n\t\tima_policy_flag &= ~IMA_APPRAISE;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ima_policy_flag;",
            "static int temp_ima_appraise;",
            "static struct list_head *ima_rules;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nint ima_policy_flag;\nstatic int temp_ima_appraise;\nstatic struct list_head *ima_rules;\n\nvoid ima_update_policy_flag(void)\n{\n\tstruct ima_rule_entry *entry;\n\n\tlist_for_each_entry(entry, ima_rules, list) {\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tima_policy_flag |= entry->action;\n\t}\n\n\tima_appraise |= temp_ima_appraise;\n\tif (!ima_appraise)\n\t\tima_policy_flag &= ~IMA_APPRAISE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&default_appraise_rules[i].list",
            "&ima_default_rules"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&secure_boot_rules[i].list",
            "&ima_default_rules"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&default_measurement_rules[i].list",
            "&ima_default_rules"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "default_measurement_rules"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&original_measurement_rules[i].list",
            "&ima_default_rules"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "original_measurement_rules"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&dont_measure_rules[i].list",
            "&ima_default_rules"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "secure_boot_rules"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "default_appraise_rules"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "dont_measure_rules"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic int temp_ima_appraise;\nstatic struct ima_rule_entry dont_measure_rules[] __ro_after_init = {\n\t{.action = DONT_MEASURE, .fsmagic = PROC_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SYSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = DEBUGFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = TMPFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = DEVPTS_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = CGROUP_SUPER_MAGIC,\n\t .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = CGROUP2_SUPER_MAGIC,\n\t .flags = IMA_FSMAGIC},\n\t{.action = DONT_MEASURE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC}\n};\nstatic struct ima_rule_entry original_measurement_rules[] __ro_after_init = {\n\t{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_MASK | IMA_UID},\n\t{.action = MEASURE, .func = MODULE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},\n};\nstatic struct ima_rule_entry default_measurement_rules[] __ro_after_init = {\n\t{.action = MEASURE, .func = MMAP_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = BPRM_CHECK, .mask = MAY_EXEC,\n\t .flags = IMA_FUNC | IMA_MASK},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_INMASK | IMA_EUID},\n\t{.action = MEASURE, .func = FILE_CHECK, .mask = MAY_READ,\n\t .uid = GLOBAL_ROOT_UID, .uid_op = &uid_eq,\n\t .flags = IMA_FUNC | IMA_INMASK | IMA_UID},\n\t{.action = MEASURE, .func = MODULE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = FIRMWARE_CHECK, .flags = IMA_FUNC},\n\t{.action = MEASURE, .func = POLICY_CHECK, .flags = IMA_FUNC},\n};\nstatic struct ima_rule_entry default_appraise_rules[] __ro_after_init = {\n\t{.action = DONT_APPRAISE, .fsmagic = PROC_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SYSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = DEBUGFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = TMPFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = RAMFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = DEVPTS_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = BINFMTFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SECURITYFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = SELINUX_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = NSFS_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = CGROUP_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n\t{.action = DONT_APPRAISE, .fsmagic = CGROUP2_SUPER_MAGIC, .flags = IMA_FSMAGIC},\n#ifdef CONFIG_IMA_WRITE_POLICY\n\t{.action = APPRAISE, .func = POLICY_CHECK,\n\t.flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n#endif\n#ifndef CONFIG_IMA_APPRAISE_SIGNED_INIT\n\t{.action = APPRAISE, .fowner = GLOBAL_ROOT_UID, .fowner_op = &uid_eq,\n\t .flags = IMA_FOWNER},\n#else\n\t/* force signature */\n\t{.action = APPRAISE, .fowner = GLOBAL_ROOT_UID, .fowner_op = &uid_eq,\n\t .flags = IMA_FOWNER | IMA_DIGSIG_REQUIRED},\n#endif\n};\nstatic struct ima_rule_entry secure_boot_rules[] __ro_after_init = {\n\t{.action = APPRAISE, .func = MODULE_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = FIRMWARE_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = KEXEC_KERNEL_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n\t{.action = APPRAISE, .func = POLICY_CHECK,\n\t .flags = IMA_FUNC | IMA_DIGSIG_REQUIRED},\n};\nstatic LIST_HEAD(ima_default_rules);\nstatic struct list_head *ima_rules;\nstatic int ima_policy;\nstatic bool ima_use_appraise_tcb;\nstatic bool ima_use_secure_boot;\n\nvoid __init ima_init_policy(void)\n{\n\tint i, measure_entries, appraise_entries, secure_boot_entries;\n\n\t/* if !ima_policy set entries = 0 so we load NO default rules */\n\tmeasure_entries = ima_policy ? ARRAY_SIZE(dont_measure_rules) : 0;\n\tappraise_entries = ima_use_appraise_tcb ?\n\t\t\t ARRAY_SIZE(default_appraise_rules) : 0;\n\tsecure_boot_entries = ima_use_secure_boot ?\n\t\t\tARRAY_SIZE(secure_boot_rules) : 0;\n\n\tfor (i = 0; i < measure_entries; i++)\n\t\tlist_add_tail(&dont_measure_rules[i].list, &ima_default_rules);\n\n\tswitch (ima_policy) {\n\tcase ORIGINAL_TCB:\n\t\tfor (i = 0; i < ARRAY_SIZE(original_measurement_rules); i++)\n\t\t\tlist_add_tail(&original_measurement_rules[i].list,\n\t\t\t\t      &ima_default_rules);\n\t\tbreak;\n\tcase DEFAULT_TCB:\n\t\tfor (i = 0; i < ARRAY_SIZE(default_measurement_rules); i++)\n\t\t\tlist_add_tail(&default_measurement_rules[i].list,\n\t\t\t\t      &ima_default_rules);\n\tdefault:\n\t\tbreak;\n\t}\n\n\t/*\n\t * Insert the appraise rules requiring file signatures, prior to\n\t * any other appraise rules.\n\t */\n\tfor (i = 0; i < secure_boot_entries; i++)\n\t\tlist_add_tail(&secure_boot_rules[i].list,\n\t\t\t      &ima_default_rules);\n\n\tfor (i = 0; i < appraise_entries; i++) {\n\t\tlist_add_tail(&default_appraise_rules[i].list,\n\t\t\t      &ima_default_rules);\n\t\tif (default_appraise_rules[i].func == POLICY_CHECK)\n\t\t\ttemp_ima_appraise |= IMA_APPRAISE_POLICY;\n\t}\n\n\tima_rules = &ima_default_rules;\n\tima_update_policy_flag();\n}"
  },
  {
    "function_name": "ima_update_policy_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "408-420",
    "snippet": "void ima_update_policy_flag(void)\n{\n\tstruct ima_rule_entry *entry;\n\n\tlist_for_each_entry(entry, ima_rules, list) {\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tima_policy_flag |= entry->action;\n\t}\n\n\tima_appraise |= temp_ima_appraise;\n\tif (!ima_appraise)\n\t\tima_policy_flag &= ~IMA_APPRAISE;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int ima_policy_flag;",
      "static int temp_ima_appraise;",
      "static struct list_head *ima_rules;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "ima_rules",
            "list"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nint ima_policy_flag;\nstatic int temp_ima_appraise;\nstatic struct list_head *ima_rules;\n\nvoid ima_update_policy_flag(void)\n{\n\tstruct ima_rule_entry *entry;\n\n\tlist_for_each_entry(entry, ima_rules, list) {\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tima_policy_flag |= entry->action;\n\t}\n\n\tima_appraise |= temp_ima_appraise;\n\tif (!ima_appraise)\n\t\tima_policy_flag &= ~IMA_APPRAISE;\n}"
  },
  {
    "function_name": "ima_match_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "365-400",
    "snippet": "int ima_match_policy(struct inode *inode, enum ima_hooks func, int mask,\n\t\t     int flags, int *pcr)\n{\n\tstruct ima_rule_entry *entry;\n\tint action = 0, actmask = flags | (flags << 1);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, ima_rules, list) {\n\n\t\tif (!(entry->action & actmask))\n\t\t\tcontinue;\n\n\t\tif (!ima_match_rules(entry, inode, func, mask))\n\t\t\tcontinue;\n\n\t\taction |= entry->flags & IMA_ACTION_FLAGS;\n\n\t\taction |= entry->action & IMA_DO_MASK;\n\t\tif (entry->action & IMA_APPRAISE)\n\t\t\taction |= get_subaction(entry, func);\n\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tactmask &= ~(entry->action | entry->action << 1);\n\t\telse\n\t\t\tactmask &= ~(entry->action | entry->action >> 1);\n\n\t\tif ((pcr) && (entry->flags & IMA_PCR))\n\t\t\t*pcr = entry->pcr;\n\n\t\tif (!actmask)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn action;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define IMA_PCR\t\t0x0100"
    ],
    "globals_used": [
      "static struct list_head *ima_rules;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_subaction",
          "args": [
            "entry",
            "func"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "get_subaction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "332-349",
          "snippet": "static int get_subaction(struct ima_rule_entry *rule, enum ima_hooks func)\n{\n\tif (!(rule->flags & IMA_FUNC))\n\t\treturn IMA_FILE_APPRAISE;\n\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\treturn IMA_MMAP_APPRAISE;\n\tcase BPRM_CHECK:\n\t\treturn IMA_BPRM_APPRAISE;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\treturn IMA_FILE_APPRAISE;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\treturn IMA_READ_APPRAISE;\n\t}\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define IMA_FUNC\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define IMA_FUNC\t0x0001\n\nstatic int get_subaction(struct ima_rule_entry *rule, enum ima_hooks func)\n{\n\tif (!(rule->flags & IMA_FUNC))\n\t\treturn IMA_FILE_APPRAISE;\n\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\treturn IMA_MMAP_APPRAISE;\n\tcase BPRM_CHECK:\n\t\treturn IMA_BPRM_APPRAISE;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\treturn IMA_FILE_APPRAISE;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\treturn IMA_READ_APPRAISE;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_match_rules",
          "args": [
            "entry",
            "inode",
            "func",
            "mask"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "ima_match_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "249-326",
          "snippet": "static bool ima_match_rules(struct ima_rule_entry *rule, struct inode *inode,\n\t\t\t    enum ima_hooks func, int mask)\n{\n\tstruct task_struct *tsk = current;\n\tconst struct cred *cred = current_cred();\n\tint i;\n\n\tif ((rule->flags & IMA_FUNC) &&\n\t    (rule->func != func && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_MASK) &&\n\t    (rule->mask != mask && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_INMASK) &&\n\t    (!(rule->mask & mask) && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_FSMAGIC)\n\t    && rule->fsmagic != inode->i_sb->s_magic)\n\t\treturn false;\n\tif ((rule->flags & IMA_FSUUID) &&\n\t    !uuid_equal(&rule->fsuuid, &inode->i_sb->s_uuid))\n\t\treturn false;\n\tif ((rule->flags & IMA_UID) && !rule->uid_op(cred->uid, rule->uid))\n\t\treturn false;\n\tif (rule->flags & IMA_EUID) {\n\t\tif (has_capability_noaudit(current, CAP_SETUID)) {\n\t\t\tif (!rule->uid_op(cred->euid, rule->uid)\n\t\t\t    && !rule->uid_op(cred->suid, rule->uid)\n\t\t\t    && !rule->uid_op(cred->uid, rule->uid))\n\t\t\t\treturn false;\n\t\t} else if (!rule->uid_op(cred->euid, rule->uid))\n\t\t\treturn false;\n\t}\n\n\tif ((rule->flags & IMA_FOWNER) &&\n\t    !rule->fowner_op(inode->i_uid, rule->fowner))\n\t\treturn false;\n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tint rc = 0;\n\t\tu32 osid, sid;\n\t\tint retried = 0;\n\n\t\tif (!rule->lsm[i].rule)\n\t\t\tcontinue;\nretry:\n\t\tswitch (i) {\n\t\tcase LSM_OBJ_USER:\n\t\tcase LSM_OBJ_ROLE:\n\t\tcase LSM_OBJ_TYPE:\n\t\t\tsecurity_inode_getsecid(inode, &osid);\n\t\t\trc = security_filter_rule_match(osid,\n\t\t\t\t\t\t\trule->lsm[i].type,\n\t\t\t\t\t\t\tAudit_equal,\n\t\t\t\t\t\t\trule->lsm[i].rule,\n\t\t\t\t\t\t\tNULL);\n\t\t\tbreak;\n\t\tcase LSM_SUBJ_USER:\n\t\tcase LSM_SUBJ_ROLE:\n\t\tcase LSM_SUBJ_TYPE:\n\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\trc = security_filter_rule_match(sid,\n\t\t\t\t\t\t\trule->lsm[i].type,\n\t\t\t\t\t\t\tAudit_equal,\n\t\t\t\t\t\t\trule->lsm[i].rule,\n\t\t\t\t\t\t\tNULL);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif ((rc < 0) && (!retried)) {\n\t\t\tretried = 1;\n\t\t\tima_lsm_update_rules();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!rc)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAX_LSM_RULES 6",
            "#define IMA_EUID\t0x0080",
            "#define IMA_INMASK\t0x0040",
            "#define IMA_FSUUID\t0x0020",
            "#define IMA_FOWNER\t0x0010",
            "#define IMA_UID\t\t0x0008",
            "#define IMA_FSMAGIC\t0x0004",
            "#define IMA_MASK\t0x0002",
            "#define IMA_FUNC\t0x0001"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define MAX_LSM_RULES 6\n#define IMA_EUID\t0x0080\n#define IMA_INMASK\t0x0040\n#define IMA_FSUUID\t0x0020\n#define IMA_FOWNER\t0x0010\n#define IMA_UID\t\t0x0008\n#define IMA_FSMAGIC\t0x0004\n#define IMA_MASK\t0x0002\n#define IMA_FUNC\t0x0001\n\nstatic bool ima_match_rules(struct ima_rule_entry *rule, struct inode *inode,\n\t\t\t    enum ima_hooks func, int mask)\n{\n\tstruct task_struct *tsk = current;\n\tconst struct cred *cred = current_cred();\n\tint i;\n\n\tif ((rule->flags & IMA_FUNC) &&\n\t    (rule->func != func && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_MASK) &&\n\t    (rule->mask != mask && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_INMASK) &&\n\t    (!(rule->mask & mask) && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_FSMAGIC)\n\t    && rule->fsmagic != inode->i_sb->s_magic)\n\t\treturn false;\n\tif ((rule->flags & IMA_FSUUID) &&\n\t    !uuid_equal(&rule->fsuuid, &inode->i_sb->s_uuid))\n\t\treturn false;\n\tif ((rule->flags & IMA_UID) && !rule->uid_op(cred->uid, rule->uid))\n\t\treturn false;\n\tif (rule->flags & IMA_EUID) {\n\t\tif (has_capability_noaudit(current, CAP_SETUID)) {\n\t\t\tif (!rule->uid_op(cred->euid, rule->uid)\n\t\t\t    && !rule->uid_op(cred->suid, rule->uid)\n\t\t\t    && !rule->uid_op(cred->uid, rule->uid))\n\t\t\t\treturn false;\n\t\t} else if (!rule->uid_op(cred->euid, rule->uid))\n\t\t\treturn false;\n\t}\n\n\tif ((rule->flags & IMA_FOWNER) &&\n\t    !rule->fowner_op(inode->i_uid, rule->fowner))\n\t\treturn false;\n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tint rc = 0;\n\t\tu32 osid, sid;\n\t\tint retried = 0;\n\n\t\tif (!rule->lsm[i].rule)\n\t\t\tcontinue;\nretry:\n\t\tswitch (i) {\n\t\tcase LSM_OBJ_USER:\n\t\tcase LSM_OBJ_ROLE:\n\t\tcase LSM_OBJ_TYPE:\n\t\t\tsecurity_inode_getsecid(inode, &osid);\n\t\t\trc = security_filter_rule_match(osid,\n\t\t\t\t\t\t\trule->lsm[i].type,\n\t\t\t\t\t\t\tAudit_equal,\n\t\t\t\t\t\t\trule->lsm[i].rule,\n\t\t\t\t\t\t\tNULL);\n\t\t\tbreak;\n\t\tcase LSM_SUBJ_USER:\n\t\tcase LSM_SUBJ_ROLE:\n\t\tcase LSM_SUBJ_TYPE:\n\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\trc = security_filter_rule_match(sid,\n\t\t\t\t\t\t\trule->lsm[i].type,\n\t\t\t\t\t\t\tAudit_equal,\n\t\t\t\t\t\t\trule->lsm[i].rule,\n\t\t\t\t\t\t\tNULL);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif ((rc < 0) && (!retried)) {\n\t\t\tretried = 1;\n\t\t\tima_lsm_update_rules();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!rc)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "entry",
            "ima_rules",
            "list"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define IMA_PCR\t\t0x0100\n\nstatic struct list_head *ima_rules;\n\nint ima_match_policy(struct inode *inode, enum ima_hooks func, int mask,\n\t\t     int flags, int *pcr)\n{\n\tstruct ima_rule_entry *entry;\n\tint action = 0, actmask = flags | (flags << 1);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, ima_rules, list) {\n\n\t\tif (!(entry->action & actmask))\n\t\t\tcontinue;\n\n\t\tif (!ima_match_rules(entry, inode, func, mask))\n\t\t\tcontinue;\n\n\t\taction |= entry->flags & IMA_ACTION_FLAGS;\n\n\t\taction |= entry->action & IMA_DO_MASK;\n\t\tif (entry->action & IMA_APPRAISE)\n\t\t\taction |= get_subaction(entry, func);\n\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tactmask &= ~(entry->action | entry->action << 1);\n\t\telse\n\t\t\tactmask &= ~(entry->action | entry->action >> 1);\n\n\t\tif ((pcr) && (entry->flags & IMA_PCR))\n\t\t\t*pcr = entry->pcr;\n\n\t\tif (!actmask)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn action;\n}"
  },
  {
    "function_name": "get_subaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "332-349",
    "snippet": "static int get_subaction(struct ima_rule_entry *rule, enum ima_hooks func)\n{\n\tif (!(rule->flags & IMA_FUNC))\n\t\treturn IMA_FILE_APPRAISE;\n\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\treturn IMA_MMAP_APPRAISE;\n\tcase BPRM_CHECK:\n\t\treturn IMA_BPRM_APPRAISE;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\treturn IMA_FILE_APPRAISE;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\treturn IMA_READ_APPRAISE;\n\t}\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define IMA_FUNC\t0x0001"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define IMA_FUNC\t0x0001\n\nstatic int get_subaction(struct ima_rule_entry *rule, enum ima_hooks func)\n{\n\tif (!(rule->flags & IMA_FUNC))\n\t\treturn IMA_FILE_APPRAISE;\n\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\treturn IMA_MMAP_APPRAISE;\n\tcase BPRM_CHECK:\n\t\treturn IMA_BPRM_APPRAISE;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\treturn IMA_FILE_APPRAISE;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\treturn IMA_READ_APPRAISE;\n\t}\n}"
  },
  {
    "function_name": "ima_match_rules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "249-326",
    "snippet": "static bool ima_match_rules(struct ima_rule_entry *rule, struct inode *inode,\n\t\t\t    enum ima_hooks func, int mask)\n{\n\tstruct task_struct *tsk = current;\n\tconst struct cred *cred = current_cred();\n\tint i;\n\n\tif ((rule->flags & IMA_FUNC) &&\n\t    (rule->func != func && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_MASK) &&\n\t    (rule->mask != mask && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_INMASK) &&\n\t    (!(rule->mask & mask) && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_FSMAGIC)\n\t    && rule->fsmagic != inode->i_sb->s_magic)\n\t\treturn false;\n\tif ((rule->flags & IMA_FSUUID) &&\n\t    !uuid_equal(&rule->fsuuid, &inode->i_sb->s_uuid))\n\t\treturn false;\n\tif ((rule->flags & IMA_UID) && !rule->uid_op(cred->uid, rule->uid))\n\t\treturn false;\n\tif (rule->flags & IMA_EUID) {\n\t\tif (has_capability_noaudit(current, CAP_SETUID)) {\n\t\t\tif (!rule->uid_op(cred->euid, rule->uid)\n\t\t\t    && !rule->uid_op(cred->suid, rule->uid)\n\t\t\t    && !rule->uid_op(cred->uid, rule->uid))\n\t\t\t\treturn false;\n\t\t} else if (!rule->uid_op(cred->euid, rule->uid))\n\t\t\treturn false;\n\t}\n\n\tif ((rule->flags & IMA_FOWNER) &&\n\t    !rule->fowner_op(inode->i_uid, rule->fowner))\n\t\treturn false;\n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tint rc = 0;\n\t\tu32 osid, sid;\n\t\tint retried = 0;\n\n\t\tif (!rule->lsm[i].rule)\n\t\t\tcontinue;\nretry:\n\t\tswitch (i) {\n\t\tcase LSM_OBJ_USER:\n\t\tcase LSM_OBJ_ROLE:\n\t\tcase LSM_OBJ_TYPE:\n\t\t\tsecurity_inode_getsecid(inode, &osid);\n\t\t\trc = security_filter_rule_match(osid,\n\t\t\t\t\t\t\trule->lsm[i].type,\n\t\t\t\t\t\t\tAudit_equal,\n\t\t\t\t\t\t\trule->lsm[i].rule,\n\t\t\t\t\t\t\tNULL);\n\t\t\tbreak;\n\t\tcase LSM_SUBJ_USER:\n\t\tcase LSM_SUBJ_ROLE:\n\t\tcase LSM_SUBJ_TYPE:\n\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\trc = security_filter_rule_match(sid,\n\t\t\t\t\t\t\trule->lsm[i].type,\n\t\t\t\t\t\t\tAudit_equal,\n\t\t\t\t\t\t\trule->lsm[i].rule,\n\t\t\t\t\t\t\tNULL);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif ((rc < 0) && (!retried)) {\n\t\t\tretried = 1;\n\t\t\tima_lsm_update_rules();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!rc)\n\t\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MAX_LSM_RULES 6",
      "#define IMA_EUID\t0x0080",
      "#define IMA_INMASK\t0x0040",
      "#define IMA_FSUUID\t0x0020",
      "#define IMA_FOWNER\t0x0010",
      "#define IMA_UID\t\t0x0008",
      "#define IMA_FSMAGIC\t0x0004",
      "#define IMA_MASK\t0x0002",
      "#define IMA_FUNC\t0x0001"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_lsm_update_rules",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "ima_lsm_update_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "221-238",
          "snippet": "static void ima_lsm_update_rules(void)\n{\n\tstruct ima_rule_entry *entry;\n\tint result;\n\tint i;\n\n\tlist_for_each_entry(entry, &ima_policy_rules, list) {\n\t\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\t\tif (!entry->lsm[i].rule)\n\t\t\t\tcontinue;\n\t\t\tresult = security_filter_rule_init(entry->lsm[i].type,\n\t\t\t\t\t\t\t   Audit_equal,\n\t\t\t\t\t\t\t   entry->lsm[i].args_p,\n\t\t\t\t\t\t\t   &entry->lsm[i].rule);\n\t\t\tBUG_ON(!entry->lsm[i].rule);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAX_LSM_RULES 6"
          ],
          "globals_used": [
            "static LIST_HEAD(ima_policy_rules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define MAX_LSM_RULES 6\n\nstatic LIST_HEAD(ima_policy_rules);\n\nstatic void ima_lsm_update_rules(void)\n{\n\tstruct ima_rule_entry *entry;\n\tint result;\n\tint i;\n\n\tlist_for_each_entry(entry, &ima_policy_rules, list) {\n\t\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\t\tif (!entry->lsm[i].rule)\n\t\t\t\tcontinue;\n\t\t\tresult = security_filter_rule_init(entry->lsm[i].type,\n\t\t\t\t\t\t\t   Audit_equal,\n\t\t\t\t\t\t\t   entry->lsm[i].args_p,\n\t\t\t\t\t\t\t   &entry->lsm[i].rule);\n\t\t\tBUG_ON(!entry->lsm[i].rule);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_filter_rule_match",
          "args": [
            "sid",
            "rule->lsm[i].type",
            "Audit_equal",
            "rule->lsm[i].rule",
            "NULL"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "security_filter_rule_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima.h",
          "lines": "308-313",
          "snippet": "static inline int security_filter_rule_match(u32 secid, u32 field, u32 op,\n\t\t\t\t\t     void *lsmrule,\n\t\t\t\t\t     struct audit_context *actx)\n{\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/ima.h>",
            "#include \"../integrity.h\"",
            "#include <crypto/hash_info.h>",
            "#include <linux/audit.h>",
            "#include <linux/tpm.h>",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/crypto.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define security_filter_rule_match security_audit_rule_match"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ima.h>\n#include \"../integrity.h\"\n#include <crypto/hash_info.h>\n#include <linux/audit.h>\n#include <linux/tpm.h>\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n\n#define security_filter_rule_match security_audit_rule_match\n\nstatic inline int security_filter_rule_match(u32 secid, u32 field, u32 op,\n\t\t\t\t\t     void *lsmrule,\n\t\t\t\t\t     struct audit_context *actx)\n{\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_getsecid",
          "args": [
            "tsk",
            "&sid"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "security_task_getsecid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "1067-1071",
          "snippet": "void security_task_getsecid(struct task_struct *p, u32 *secid)\n{\n\t*secid = 0;\n\tcall_void_hook(task_getsecid, p, secid);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nvoid security_task_getsecid(struct task_struct *p, u32 *secid)\n{\n\t*secid = 0;\n\tcall_void_hook(task_getsecid, p, secid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_inode_getsecid",
          "args": [
            "inode",
            "&osid"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "security_inode_getsecid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "843-846",
          "snippet": "void security_inode_getsecid(struct inode *inode, u32 *secid)\n{\n\tcall_void_hook(inode_getsecid, inode, secid);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nvoid security_inode_getsecid(struct inode *inode, u32 *secid)\n{\n\tcall_void_hook(inode_getsecid, inode, secid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rule->fowner_op",
          "args": [
            "inode->i_uid",
            "rule->fowner"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rule->uid_op",
          "args": [
            "cred->euid",
            "rule->uid"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rule->uid_op",
          "args": [
            "cred->uid",
            "rule->uid"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rule->uid_op",
          "args": [
            "cred->suid",
            "rule->uid"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rule->uid_op",
          "args": [
            "cred->euid",
            "rule->uid"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_capability_noaudit",
          "args": [
            "current",
            "CAP_SETUID"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rule->uid_op",
          "args": [
            "cred->uid",
            "rule->uid"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uuid_equal",
          "args": [
            "&rule->fsuuid",
            "&inode->i_sb->s_uuid"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define MAX_LSM_RULES 6\n#define IMA_EUID\t0x0080\n#define IMA_INMASK\t0x0040\n#define IMA_FSUUID\t0x0020\n#define IMA_FOWNER\t0x0010\n#define IMA_UID\t\t0x0008\n#define IMA_FSMAGIC\t0x0004\n#define IMA_MASK\t0x0002\n#define IMA_FUNC\t0x0001\n\nstatic bool ima_match_rules(struct ima_rule_entry *rule, struct inode *inode,\n\t\t\t    enum ima_hooks func, int mask)\n{\n\tstruct task_struct *tsk = current;\n\tconst struct cred *cred = current_cred();\n\tint i;\n\n\tif ((rule->flags & IMA_FUNC) &&\n\t    (rule->func != func && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_MASK) &&\n\t    (rule->mask != mask && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_INMASK) &&\n\t    (!(rule->mask & mask) && func != POST_SETATTR))\n\t\treturn false;\n\tif ((rule->flags & IMA_FSMAGIC)\n\t    && rule->fsmagic != inode->i_sb->s_magic)\n\t\treturn false;\n\tif ((rule->flags & IMA_FSUUID) &&\n\t    !uuid_equal(&rule->fsuuid, &inode->i_sb->s_uuid))\n\t\treturn false;\n\tif ((rule->flags & IMA_UID) && !rule->uid_op(cred->uid, rule->uid))\n\t\treturn false;\n\tif (rule->flags & IMA_EUID) {\n\t\tif (has_capability_noaudit(current, CAP_SETUID)) {\n\t\t\tif (!rule->uid_op(cred->euid, rule->uid)\n\t\t\t    && !rule->uid_op(cred->suid, rule->uid)\n\t\t\t    && !rule->uid_op(cred->uid, rule->uid))\n\t\t\t\treturn false;\n\t\t} else if (!rule->uid_op(cred->euid, rule->uid))\n\t\t\treturn false;\n\t}\n\n\tif ((rule->flags & IMA_FOWNER) &&\n\t    !rule->fowner_op(inode->i_uid, rule->fowner))\n\t\treturn false;\n\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\tint rc = 0;\n\t\tu32 osid, sid;\n\t\tint retried = 0;\n\n\t\tif (!rule->lsm[i].rule)\n\t\t\tcontinue;\nretry:\n\t\tswitch (i) {\n\t\tcase LSM_OBJ_USER:\n\t\tcase LSM_OBJ_ROLE:\n\t\tcase LSM_OBJ_TYPE:\n\t\t\tsecurity_inode_getsecid(inode, &osid);\n\t\t\trc = security_filter_rule_match(osid,\n\t\t\t\t\t\t\trule->lsm[i].type,\n\t\t\t\t\t\t\tAudit_equal,\n\t\t\t\t\t\t\trule->lsm[i].rule,\n\t\t\t\t\t\t\tNULL);\n\t\t\tbreak;\n\t\tcase LSM_SUBJ_USER:\n\t\tcase LSM_SUBJ_ROLE:\n\t\tcase LSM_SUBJ_TYPE:\n\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\trc = security_filter_rule_match(sid,\n\t\t\t\t\t\t\trule->lsm[i].type,\n\t\t\t\t\t\t\tAudit_equal,\n\t\t\t\t\t\t\trule->lsm[i].rule,\n\t\t\t\t\t\t\tNULL);\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tif ((rc < 0) && (!retried)) {\n\t\t\tretried = 1;\n\t\t\tima_lsm_update_rules();\n\t\t\tgoto retry;\n\t\t}\n\t\tif (!rc)\n\t\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "ima_lsm_update_rules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "221-238",
    "snippet": "static void ima_lsm_update_rules(void)\n{\n\tstruct ima_rule_entry *entry;\n\tint result;\n\tint i;\n\n\tlist_for_each_entry(entry, &ima_policy_rules, list) {\n\t\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\t\tif (!entry->lsm[i].rule)\n\t\t\t\tcontinue;\n\t\t\tresult = security_filter_rule_init(entry->lsm[i].type,\n\t\t\t\t\t\t\t   Audit_equal,\n\t\t\t\t\t\t\t   entry->lsm[i].args_p,\n\t\t\t\t\t\t\t   &entry->lsm[i].rule);\n\t\t\tBUG_ON(!entry->lsm[i].rule);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MAX_LSM_RULES 6"
    ],
    "globals_used": [
      "static LIST_HEAD(ima_policy_rules);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!entry->lsm[i].rule"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_filter_rule_init",
          "args": [
            "entry->lsm[i].type",
            "Audit_equal",
            "entry->lsm[i].args_p",
            "&entry->lsm[i].rule"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "security_filter_rule_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima.h",
          "lines": "302-306",
          "snippet": "static inline int security_filter_rule_init(u32 field, u32 op, char *rulestr,\n\t\t\t\t\t    void **lsmrule)\n{\n\treturn -EINVAL;\n}",
          "includes": [
            "#include <asm/ima.h>",
            "#include \"../integrity.h\"",
            "#include <crypto/hash_info.h>",
            "#include <linux/audit.h>",
            "#include <linux/tpm.h>",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/crypto.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define security_filter_rule_init security_audit_rule_init"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ima.h>\n#include \"../integrity.h\"\n#include <crypto/hash_info.h>\n#include <linux/audit.h>\n#include <linux/tpm.h>\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n\n#define security_filter_rule_init security_audit_rule_init\n\nstatic inline int security_filter_rule_init(u32 field, u32 op, char *rulestr,\n\t\t\t\t\t    void **lsmrule)\n{\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "entry",
            "&ima_policy_rules",
            "list"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define MAX_LSM_RULES 6\n\nstatic LIST_HEAD(ima_policy_rules);\n\nstatic void ima_lsm_update_rules(void)\n{\n\tstruct ima_rule_entry *entry;\n\tint result;\n\tint i;\n\n\tlist_for_each_entry(entry, &ima_policy_rules, list) {\n\t\tfor (i = 0; i < MAX_LSM_RULES; i++) {\n\t\t\tif (!entry->lsm[i].rule)\n\t\t\t\tcontinue;\n\t\t\tresult = security_filter_rule_init(entry->lsm[i].type,\n\t\t\t\t\t\t\t   Audit_equal,\n\t\t\t\t\t\t\t   entry->lsm[i].args_p,\n\t\t\t\t\t\t\t   &entry->lsm[i].rule);\n\t\t\tBUG_ON(!entry->lsm[i].rule);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "default_appraise_policy_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "208-212",
    "snippet": "static int __init default_appraise_policy_setup(char *str)\n{\n\tima_use_appraise_tcb = true;\n\treturn 1;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static bool ima_use_appraise_tcb"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic bool ima_use_appraise_tcb;\n\nstatic int __init default_appraise_policy_setup(char *str)\n{\n\tima_use_appraise_tcb = true;\n\treturn 1;\n}"
  },
  {
    "function_name": "policy_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "189-205",
    "snippet": "static int __init policy_setup(char *str)\n{\n\tchar *p;\n\n\twhile ((p = strsep(&str, \" |\\n\")) != NULL) {\n\t\tif (*p == ' ')\n\t\t\tcontinue;\n\t\tif ((strcmp(p, \"tcb\") == 0) && !ima_policy)\n\t\t\tima_policy = DEFAULT_TCB;\n\t\telse if (strcmp(p, \"appraise_tcb\") == 0)\n\t\t\tima_use_appraise_tcb = true;\n\t\telse if (strcmp(p, \"secure_boot\") == 0)\n\t\t\tima_use_secure_boot = true;\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ima_policy",
      "static bool ima_use_appraise_tcb",
      "static bool ima_use_secure_boot"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"secure_boot\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"appraise_tcb\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "p",
            "\"tcb\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\" |\\n\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic int ima_policy;\nstatic bool ima_use_appraise_tcb;\nstatic bool ima_use_secure_boot;\n\nstatic int __init policy_setup(char *str)\n{\n\tchar *p;\n\n\twhile ((p = strsep(&str, \" |\\n\")) != NULL) {\n\t\tif (*p == ' ')\n\t\t\tcontinue;\n\t\tif ((strcmp(p, \"tcb\") == 0) && !ima_policy)\n\t\t\tima_policy = DEFAULT_TCB;\n\t\telse if (strcmp(p, \"appraise_tcb\") == 0)\n\t\t\tima_use_appraise_tcb = true;\n\t\telse if (strcmp(p, \"secure_boot\") == 0)\n\t\t\tima_use_secure_boot = true;\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "default_measure_policy_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
    "lines": "177-184",
    "snippet": "static int __init default_measure_policy_setup(char *str)\n{\n\tif (ima_policy)\n\t\treturn 1;\n\n\tima_policy = ORIGINAL_TCB;\n\treturn 1;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/seq_file.h>",
      "#include <linux/genhd.h>",
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/parser.h>",
      "#include <linux/magic.h>",
      "#include <linux/security.h>",
      "#include <linux/fs.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ima_policy"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic int ima_policy;\n\nstatic int __init default_measure_policy_setup(char *str)\n{\n\tif (ima_policy)\n\t\treturn 1;\n\n\tima_policy = ORIGINAL_TCB;\n\treturn 1;\n}"
  }
]