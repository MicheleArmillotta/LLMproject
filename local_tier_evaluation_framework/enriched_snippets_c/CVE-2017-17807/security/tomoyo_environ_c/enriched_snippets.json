[
  {
    "function_name": "tomoyo_write_misc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/environ.c",
    "lines": "118-123",
    "snippet": "int tomoyo_write_misc(struct tomoyo_acl_param *param)\n{\n\tif (tomoyo_str_starts(&param->data, \"env \"))\n\t\treturn tomoyo_write_env(param);\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_write_env",
          "args": [
            "param"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_write_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/environ.c",
          "lines": "94-109",
          "snippet": "static int tomoyo_write_env(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_env_acl e = { .head.type = TOMOYO_TYPE_ENV_ACL };\n\tint error = -ENOMEM;\n\tconst char *data = tomoyo_read_token(param);\n\n\tif (!tomoyo_correct_word(data) || strchr(data, '='))\n\t\treturn -EINVAL;\n\te.env = tomoyo_get_name(data);\n\tif (!e.env)\n\t\treturn error;\n\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t  tomoyo_same_env_acl, NULL);\n\ttomoyo_put_name(e.env);\n\treturn error;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nstatic int tomoyo_write_env(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_env_acl e = { .head.type = TOMOYO_TYPE_ENV_ACL };\n\tint error = -ENOMEM;\n\tconst char *data = tomoyo_read_token(param);\n\n\tif (!tomoyo_correct_word(data) || strchr(data, '='))\n\t\treturn -EINVAL;\n\te.env = tomoyo_get_name(data);\n\tif (!e.env)\n\t\treturn error;\n\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t  tomoyo_same_env_acl, NULL);\n\ttomoyo_put_name(e.env);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_str_starts",
          "args": [
            "&param->data",
            "\"env \""
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_str_starts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "374-384",
          "snippet": "bool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_str_starts(char **src, const char *find)\n{\n\tconst int len = strlen(find);\n\tchar *tmp = *src;\n\n\tif (strncmp(tmp, find, len))\n\t\treturn false;\n\ttmp += len;\n\t*src = tmp;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nint tomoyo_write_misc(struct tomoyo_acl_param *param)\n{\n\tif (tomoyo_str_starts(&param->data, \"env \"))\n\t\treturn tomoyo_write_env(param);\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "tomoyo_write_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/environ.c",
    "lines": "94-109",
    "snippet": "static int tomoyo_write_env(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_env_acl e = { .head.type = TOMOYO_TYPE_ENV_ACL };\n\tint error = -ENOMEM;\n\tconst char *data = tomoyo_read_token(param);\n\n\tif (!tomoyo_correct_word(data) || strchr(data, '='))\n\t\treturn -EINVAL;\n\te.env = tomoyo_get_name(data);\n\tif (!e.env)\n\t\treturn error;\n\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t  tomoyo_same_env_acl, NULL);\n\ttomoyo_put_name(e.env);\n\treturn error;\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "e.env"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_update_domain",
          "args": [
            "&e.head",
            "sizeof(e)",
            "param",
            "tomoyo_same_env_acl",
            "NULL"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "91-147",
          "snippet": "int tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_info\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_info\n\t\t\t\t\t\t  *),\n\t\t\t bool (*merge_duplicate) (struct tomoyo_acl_info *,\n\t\t\t\t\t\t  struct tomoyo_acl_info *,\n\t\t\t\t\t\t  const bool))\n{\n\tconst bool is_delete = param->is_delete;\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_info *entry;\n\tstruct list_head * const list = param->list;\n\n\tif (param->data[0]) {\n\t\tnew_entry->cond = tomoyo_get_condition(param);\n\t\tif (!new_entry->cond)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Domain transition preference is allowed for only\n\t\t * \"file execute\" entries.\n\t\t */\n\t\tif (new_entry->cond->transit &&\n\t\t    !(new_entry->type == TOMOYO_TYPE_PATH_ACL &&\n\t\t      container_of(new_entry, struct tomoyo_path_acl, head)\n\t\t      ->perm == 1 << TOMOYO_TYPE_EXECUTE))\n\t\t\tgoto out;\n\t}\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!tomoyo_same_acl_head(entry, new_entry) ||\n\t\t    !check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tif (merge_duplicate)\n\t\t\tentry->is_deleted = merge_duplicate(entry, new_entry,\n\t\t\t\t\t\t\t    is_delete);\n\t\telse\n\t\t\tentry->is_deleted = is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_condition(new_entry->cond);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_info\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_info\n\t\t\t\t\t\t  *),\n\t\t\t bool (*merge_duplicate) (struct tomoyo_acl_info *,\n\t\t\t\t\t\t  struct tomoyo_acl_info *,\n\t\t\t\t\t\t  const bool))\n{\n\tconst bool is_delete = param->is_delete;\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_info *entry;\n\tstruct list_head * const list = param->list;\n\n\tif (param->data[0]) {\n\t\tnew_entry->cond = tomoyo_get_condition(param);\n\t\tif (!new_entry->cond)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Domain transition preference is allowed for only\n\t\t * \"file execute\" entries.\n\t\t */\n\t\tif (new_entry->cond->transit &&\n\t\t    !(new_entry->type == TOMOYO_TYPE_PATH_ACL &&\n\t\t      container_of(new_entry, struct tomoyo_path_acl, head)\n\t\t      ->perm == 1 << TOMOYO_TYPE_EXECUTE))\n\t\t\tgoto out;\n\t}\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!tomoyo_same_acl_head(entry, new_entry) ||\n\t\t    !check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tif (merge_duplicate)\n\t\t\tentry->is_deleted = merge_duplicate(entry, new_entry,\n\t\t\t\t\t\t\t    is_delete);\n\t\telse\n\t\t\tentry->is_deleted = is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_condition(new_entry->cond);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_get_name",
          "args": [
            "data"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "148-183",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "data",
            "'='"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_word",
          "args": [
            "data"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_word",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "502-505",
          "snippet": "bool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_token",
          "args": [
            "param"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "131-141",
          "snippet": "char *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nchar *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic int tomoyo_write_env(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_env_acl e = { .head.type = TOMOYO_TYPE_ENV_ACL };\n\tint error = -ENOMEM;\n\tconst char *data = tomoyo_read_token(param);\n\n\tif (!tomoyo_correct_word(data) || strchr(data, '='))\n\t\treturn -EINVAL;\n\te.env = tomoyo_get_name(data);\n\tif (!e.env)\n\t\treturn error;\n\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t  tomoyo_same_env_acl, NULL);\n\ttomoyo_put_name(e.env);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_same_env_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/environ.c",
    "lines": "76-83",
    "snippet": "static bool tomoyo_same_env_acl(const struct tomoyo_acl_info *a,\n\t\t\t\tconst struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_env_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_env_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn p1->env == p2->env;\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "typeof(*p2)",
            "head"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p2"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "typeof(*p1)",
            "head"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p1"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic bool tomoyo_same_env_acl(const struct tomoyo_acl_info *a,\n\t\t\t\tconst struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_env_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_env_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn p1->env == p2->env;\n}"
  },
  {
    "function_name": "tomoyo_env_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/environ.c",
    "lines": "50-66",
    "snippet": "int tomoyo_env_perm(struct tomoyo_request_info *r, const char *env)\n{\n\tstruct tomoyo_path_info environ;\n\tint error;\n\n\tif (!env || !*env)\n\t\treturn 0;\n\tenviron.name = env;\n\ttomoyo_fill_path_info(&environ);\n\tr->param_type = TOMOYO_TYPE_ENV_ACL;\n\tr->param.environ.name = &environ;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_env_acl);\n\t\terror = tomoyo_audit_env_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\treturn error;\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_audit_env_log",
          "args": [
            "r"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_audit_env_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/environ.c",
          "lines": "34-38",
          "snippet": "static int tomoyo_audit_env_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_supervisor(r, \"misc env %s\\n\",\n\t\t\t\t r->param.environ.name->name);\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nstatic int tomoyo_audit_env_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_supervisor(r, \"misc env %s\\n\",\n\t\t\t\t r->param.environ.name->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_check_acl",
          "args": [
            "r",
            "tomoyo_check_env_acl"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "159-186",
          "snippet": "void tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tbool retried = false;\n\tconst struct list_head *list = &domain->acl_info_list;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tif (!retried) {\n\t\tretried = true;\n\t\tlist = &domain->ns->acl_group[domain->group];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nvoid tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tbool retried = false;\n\tconst struct list_head *list = &domain->acl_info_list;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tif (!retried) {\n\t\tretried = true;\n\t\tlist = &domain->ns->acl_group[domain->group];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_fill_path_info",
          "args": [
            "&environ"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_fill_path_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "643-652",
          "snippet": "void tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nint tomoyo_env_perm(struct tomoyo_request_info *r, const char *env)\n{\n\tstruct tomoyo_path_info environ;\n\tint error;\n\n\tif (!env || !*env)\n\t\treturn 0;\n\tenviron.name = env;\n\ttomoyo_fill_path_info(&environ);\n\tr->param_type = TOMOYO_TYPE_ENV_ACL;\n\tr->param.environ.name = &environ;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_env_acl);\n\t\terror = tomoyo_audit_env_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_audit_env_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/environ.c",
    "lines": "34-38",
    "snippet": "static int tomoyo_audit_env_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_supervisor(r, \"misc env %s\\n\",\n\t\t\t\t r->param.environ.name->name);\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_supervisor",
          "args": [
            "r",
            "\"misc env %s\\n\"",
            "r->param.environ.name->name"
          ],
          "line": 36
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_supervisor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1996-2088",
          "snippet": "int tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint error;\n\tint len;\n\tstatic unsigned int tomoyo_serial;\n\tstruct tomoyo_query entry = { };\n\tbool quota_exceeded = false;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\t/* Write /sys/kernel/security/tomoyo/audit. */\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n\t/* Nothing more to do if granted. */\n\tif (r->granted)\n\t\treturn 0;\n\tif (r->mode)\n\t\ttomoyo_update_stat(r->mode);\n\tswitch (r->mode) {\n\tcase TOMOYO_CONFIG_ENFORCING:\n\t\terror = -EPERM;\n\t\tif (atomic_read(&tomoyo_query_observers))\n\t\t\tbreak;\n\t\tgoto out;\n\tcase TOMOYO_CONFIG_LEARNING:\n\t\terror = 0;\n\t\t/* Check max_learning_entry parameter. */\n\t\tif (tomoyo_domain_quota_is_ok(r))\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* Get message. */\n\tva_start(args, fmt);\n\tentry.query = tomoyo_init_log(r, len, fmt, args);\n\tva_end(args);\n\tif (!entry.query)\n\t\tgoto out;\n\tentry.query_len = strlen(entry.query) + 1;\n\tif (!error) {\n\t\ttomoyo_add_entry(r->domain, entry.query);\n\t\tgoto out;\n\t}\n\tlen = tomoyo_round2(entry.query_len);\n\tentry.domain = r->domain;\n\tspin_lock(&tomoyo_query_list_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_QUERY] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_QUERY] + len\n\t    >= tomoyo_memory_quota[TOMOYO_MEMORY_QUERY]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\tentry.serial = tomoyo_serial++;\n\t\tentry.retry = r->retry;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] += len;\n\t\tlist_add_tail(&entry.list, &tomoyo_query_list);\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (quota_exceeded)\n\t\tgoto out;\n\t/* Give 10 seconds for supervisor's opinion. */\n\twhile (entry.timer < 10) {\n\t\twake_up_all(&tomoyo_query_wait);\n\t\tif (wait_event_interruptible_timeout\n\t\t    (tomoyo_answer_wait, entry.answer ||\n\t\t     !atomic_read(&tomoyo_query_observers), HZ))\n\t\t\tbreak;\n\t\telse\n\t\t\tentry.timer++;\n\t}\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_del(&entry.list);\n\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] -= len;\n\tspin_unlock(&tomoyo_query_list_lock);\n\tswitch (entry.answer) {\n\tcase 3: /* Asked to retry by administrator. */\n\t\terror = TOMOYO_RETRY_REQUEST;\n\t\tr->retry++;\n\t\tbreak;\n\tcase 1:\n\t\t/* Granted by administrator. */\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\t/* Timed out or rejected by administrator. */\n\t\tbreak;\n\t}\nout:\n\tkfree(entry.query);\n\treturn error;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);",
            "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_query_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);",
            "static LIST_HEAD(tomoyo_query_list);",
            "static DEFINE_SPINLOCK(tomoyo_query_list_lock);",
            "static atomic_t tomoyo_query_observers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_query_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);\nstatic LIST_HEAD(tomoyo_query_list);\nstatic DEFINE_SPINLOCK(tomoyo_query_list_lock);\nstatic atomic_t tomoyo_query_observers = ATOMIC_INIT(0);\n\nint tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint error;\n\tint len;\n\tstatic unsigned int tomoyo_serial;\n\tstruct tomoyo_query entry = { };\n\tbool quota_exceeded = false;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\t/* Write /sys/kernel/security/tomoyo/audit. */\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n\t/* Nothing more to do if granted. */\n\tif (r->granted)\n\t\treturn 0;\n\tif (r->mode)\n\t\ttomoyo_update_stat(r->mode);\n\tswitch (r->mode) {\n\tcase TOMOYO_CONFIG_ENFORCING:\n\t\terror = -EPERM;\n\t\tif (atomic_read(&tomoyo_query_observers))\n\t\t\tbreak;\n\t\tgoto out;\n\tcase TOMOYO_CONFIG_LEARNING:\n\t\terror = 0;\n\t\t/* Check max_learning_entry parameter. */\n\t\tif (tomoyo_domain_quota_is_ok(r))\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* Get message. */\n\tva_start(args, fmt);\n\tentry.query = tomoyo_init_log(r, len, fmt, args);\n\tva_end(args);\n\tif (!entry.query)\n\t\tgoto out;\n\tentry.query_len = strlen(entry.query) + 1;\n\tif (!error) {\n\t\ttomoyo_add_entry(r->domain, entry.query);\n\t\tgoto out;\n\t}\n\tlen = tomoyo_round2(entry.query_len);\n\tentry.domain = r->domain;\n\tspin_lock(&tomoyo_query_list_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_QUERY] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_QUERY] + len\n\t    >= tomoyo_memory_quota[TOMOYO_MEMORY_QUERY]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\tentry.serial = tomoyo_serial++;\n\t\tentry.retry = r->retry;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] += len;\n\t\tlist_add_tail(&entry.list, &tomoyo_query_list);\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (quota_exceeded)\n\t\tgoto out;\n\t/* Give 10 seconds for supervisor's opinion. */\n\twhile (entry.timer < 10) {\n\t\twake_up_all(&tomoyo_query_wait);\n\t\tif (wait_event_interruptible_timeout\n\t\t    (tomoyo_answer_wait, entry.answer ||\n\t\t     !atomic_read(&tomoyo_query_observers), HZ))\n\t\t\tbreak;\n\t\telse\n\t\t\tentry.timer++;\n\t}\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_del(&entry.list);\n\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] -= len;\n\tspin_unlock(&tomoyo_query_list_lock);\n\tswitch (entry.answer) {\n\tcase 3: /* Asked to retry by administrator. */\n\t\terror = TOMOYO_RETRY_REQUEST;\n\t\tr->retry++;\n\t\tbreak;\n\tcase 1:\n\t\t/* Granted by administrator. */\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\t/* Timed out or rejected by administrator. */\n\t\tbreak;\n\t}\nout:\n\tkfree(entry.query);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic int tomoyo_audit_env_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_supervisor(r, \"misc env %s\\n\",\n\t\t\t\t r->param.environ.name->name);\n}"
  },
  {
    "function_name": "tomoyo_check_env_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/environ.c",
    "lines": "18-25",
    "snippet": "static bool tomoyo_check_env_acl(struct tomoyo_request_info *r,\n\t\t\t\t const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_env_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\n\treturn tomoyo_path_matches_pattern(r->param.environ.name, acl->env);\n}",
    "includes": [
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_matches_pattern",
          "args": [
            "r->param.environ.name",
            "acl->env"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_matches_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "902-921",
          "snippet": "bool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,\n\t\t\t\t const struct tomoyo_path_info *pattern)\n{\n\tconst char *f = filename->name;\n\tconst char *p = pattern->name;\n\tconst int len = pattern->const_len;\n\n\t/* If @pattern doesn't contain pattern, I can use strcmp(). */\n\tif (!pattern->is_patterned)\n\t\treturn !tomoyo_pathcmp(filename, pattern);\n\t/* Don't compare directory and non-directory. */\n\tif (filename->is_dir != pattern->is_dir)\n\t\treturn false;\n\t/* Compare the initial length without patterns. */\n\tif (strncmp(f, p, len))\n\t\treturn false;\n\tf += len;\n\tp += len;\n\treturn tomoyo_path_matches_pattern2(f, p);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,\n\t\t\t\t const struct tomoyo_path_info *pattern)\n{\n\tconst char *f = filename->name;\n\tconst char *p = pattern->name;\n\tconst int len = pattern->const_len;\n\n\t/* If @pattern doesn't contain pattern, I can use strcmp(). */\n\tif (!pattern->is_patterned)\n\t\treturn !tomoyo_pathcmp(filename, pattern);\n\t/* Don't compare directory and non-directory. */\n\tif (filename->is_dir != pattern->is_dir)\n\t\treturn false;\n\t/* Compare the initial length without patterns. */\n\tif (strncmp(f, p, len))\n\t\treturn false;\n\tf += len;\n\tp += len;\n\treturn tomoyo_path_matches_pattern2(f, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ptr",
            "typeof(*acl)",
            "head"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*acl"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n\nstatic bool tomoyo_check_env_acl(struct tomoyo_request_info *r,\n\t\t\t\t const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_env_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\n\treturn tomoyo_path_matches_pattern(r->param.environ.name, acl->env);\n}"
  }
]