[
  {
    "function_name": "tomoyo_poll_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
    "lines": "461-469",
    "snippet": "unsigned int tomoyo_poll_log(struct file *file, poll_table *wait)\n{\n\tif (tomoyo_log_count)\n\t\treturn POLLIN | POLLRDNORM;\n\tpoll_wait(file, &tomoyo_log_wait, wait);\n\tif (tomoyo_log_count)\n\t\treturn POLLIN | POLLRDNORM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_log_wait);",
      "static unsigned int tomoyo_log_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "poll_wait",
          "args": [
            "file",
            "&tomoyo_log_wait",
            "wait"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_log_wait);\nstatic unsigned int tomoyo_log_count;\n\nunsigned int tomoyo_poll_log(struct file *file, poll_table *wait)\n{\n\tif (tomoyo_log_count)\n\t\treturn POLLIN | POLLRDNORM;\n\tpoll_wait(file, &tomoyo_log_wait, wait);\n\tif (tomoyo_log_count)\n\t\treturn POLLIN | POLLRDNORM;\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_read_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
    "lines": "431-451",
    "snippet": "void tomoyo_read_log(struct tomoyo_io_buffer *head)\n{\n\tstruct tomoyo_log *ptr = NULL;\n\tif (head->r.w_pos)\n\t\treturn;\n\tkfree(head->read_buf);\n\thead->read_buf = NULL;\n\tspin_lock(&tomoyo_log_lock);\n\tif (!list_empty(&tomoyo_log)) {\n\t\tptr = list_entry(tomoyo_log.next, typeof(*ptr), list);\n\t\tlist_del(&ptr->list);\n\t\ttomoyo_log_count--;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_AUDIT] -= ptr->size;\n\t}\n\tspin_unlock(&tomoyo_log_lock);\n\tif (ptr) {\n\t\thead->read_buf = ptr->log;\n\t\thead->r.w[head->r.w_pos++] = head->read_buf;\n\t\tkfree(ptr);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tomoyo_log);",
      "static DEFINE_SPINLOCK(tomoyo_log_lock);",
      "static unsigned int tomoyo_log_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ptr"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_log_lock"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&ptr->list"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "tomoyo_log.next",
            "typeof(*ptr)",
            "list"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tomoyo_log"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_log_lock"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "head->read_buf"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic LIST_HEAD(tomoyo_log);\nstatic DEFINE_SPINLOCK(tomoyo_log_lock);\nstatic unsigned int tomoyo_log_count;\n\nvoid tomoyo_read_log(struct tomoyo_io_buffer *head)\n{\n\tstruct tomoyo_log *ptr = NULL;\n\tif (head->r.w_pos)\n\t\treturn;\n\tkfree(head->read_buf);\n\thead->read_buf = NULL;\n\tspin_lock(&tomoyo_log_lock);\n\tif (!list_empty(&tomoyo_log)) {\n\t\tptr = list_entry(tomoyo_log.next, typeof(*ptr), list);\n\t\tlist_del(&ptr->list);\n\t\ttomoyo_log_count--;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_AUDIT] -= ptr->size;\n\t}\n\tspin_unlock(&tomoyo_log_lock);\n\tif (ptr) {\n\t\thead->read_buf = ptr->log;\n\t\thead->r.w[head->r.w_pos++] = head->read_buf;\n\t\tkfree(ptr);\n\t}\n}"
  },
  {
    "function_name": "tomoyo_write_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
    "lines": "412-422",
    "snippet": "void tomoyo_write_log(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint len;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_write_log2",
          "args": [
            "r",
            "len",
            "fmt",
            "args"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_write_log2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
          "lines": "359-402",
          "snippet": "void tomoyo_write_log2(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t       va_list args)\n{\n\tchar *buf;\n\tstruct tomoyo_log *entry;\n\tbool quota_exceeded = false;\n\tif (!tomoyo_get_audit(r->domain->ns, r->profile, r->type,\n\t\t\t      r->matched_acl, r->granted))\n\t\tgoto out;\n\tbuf = tomoyo_init_log(r, len, fmt, args);\n\tif (!buf)\n\t\tgoto out;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS);\n\tif (!entry) {\n\t\tkfree(buf);\n\t\tgoto out;\n\t}\n\tentry->log = buf;\n\tlen = tomoyo_round2(strlen(buf) + 1);\n\t/*\n\t * The entry->size is used for memory quota checks.\n\t * Don't go beyond strlen(entry->log).\n\t */\n\tentry->size = len + tomoyo_round2(sizeof(*entry));\n\tspin_lock(&tomoyo_log_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_AUDIT] + entry->size >=\n\t    tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_AUDIT] += entry->size;\n\t\tlist_add_tail(&entry->list, &tomoyo_log);\n\t\ttomoyo_log_count++;\n\t}\n\tspin_unlock(&tomoyo_log_lock);\n\tif (quota_exceeded) {\n\t\tkfree(buf);\n\t\tkfree(entry);\n\t\tgoto out;\n\t}\n\twake_up(&tomoyo_log_wait);\nout:\n\treturn;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_log_wait);",
            "static LIST_HEAD(tomoyo_log);",
            "static DEFINE_SPINLOCK(tomoyo_log_lock);",
            "static unsigned int tomoyo_log_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_log_wait);\nstatic LIST_HEAD(tomoyo_log);\nstatic DEFINE_SPINLOCK(tomoyo_log_lock);\nstatic unsigned int tomoyo_log_count;\n\nvoid tomoyo_write_log2(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t       va_list args)\n{\n\tchar *buf;\n\tstruct tomoyo_log *entry;\n\tbool quota_exceeded = false;\n\tif (!tomoyo_get_audit(r->domain->ns, r->profile, r->type,\n\t\t\t      r->matched_acl, r->granted))\n\t\tgoto out;\n\tbuf = tomoyo_init_log(r, len, fmt, args);\n\tif (!buf)\n\t\tgoto out;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS);\n\tif (!entry) {\n\t\tkfree(buf);\n\t\tgoto out;\n\t}\n\tentry->log = buf;\n\tlen = tomoyo_round2(strlen(buf) + 1);\n\t/*\n\t * The entry->size is used for memory quota checks.\n\t * Don't go beyond strlen(entry->log).\n\t */\n\tentry->size = len + tomoyo_round2(sizeof(*entry));\n\tspin_lock(&tomoyo_log_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_AUDIT] + entry->size >=\n\t    tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_AUDIT] += entry->size;\n\t\tlist_add_tail(&entry->list, &tomoyo_log);\n\t\ttomoyo_log_count++;\n\t}\n\tspin_unlock(&tomoyo_log_lock);\n\tif (quota_exceeded) {\n\t\tkfree(buf);\n\t\tkfree(entry);\n\t\tgoto out;\n\t}\n\twake_up(&tomoyo_log_wait);\nout:\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "(char *) &len",
            "1",
            "fmt",
            "args"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_write_log(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint len;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n}"
  },
  {
    "function_name": "tomoyo_write_log2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
    "lines": "359-402",
    "snippet": "void tomoyo_write_log2(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t       va_list args)\n{\n\tchar *buf;\n\tstruct tomoyo_log *entry;\n\tbool quota_exceeded = false;\n\tif (!tomoyo_get_audit(r->domain->ns, r->profile, r->type,\n\t\t\t      r->matched_acl, r->granted))\n\t\tgoto out;\n\tbuf = tomoyo_init_log(r, len, fmt, args);\n\tif (!buf)\n\t\tgoto out;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS);\n\tif (!entry) {\n\t\tkfree(buf);\n\t\tgoto out;\n\t}\n\tentry->log = buf;\n\tlen = tomoyo_round2(strlen(buf) + 1);\n\t/*\n\t * The entry->size is used for memory quota checks.\n\t * Don't go beyond strlen(entry->log).\n\t */\n\tentry->size = len + tomoyo_round2(sizeof(*entry));\n\tspin_lock(&tomoyo_log_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_AUDIT] + entry->size >=\n\t    tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_AUDIT] += entry->size;\n\t\tlist_add_tail(&entry->list, &tomoyo_log);\n\t\ttomoyo_log_count++;\n\t}\n\tspin_unlock(&tomoyo_log_lock);\n\tif (quota_exceeded) {\n\t\tkfree(buf);\n\t\tkfree(entry);\n\t\tgoto out;\n\t}\n\twake_up(&tomoyo_log_wait);\nout:\n\treturn;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_log_wait);",
      "static LIST_HEAD(tomoyo_log);",
      "static DEFINE_SPINLOCK(tomoyo_log_lock);",
      "static unsigned int tomoyo_log_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&tomoyo_log_wait"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_log_lock"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&entry->list",
            "&tomoyo_log"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_log_lock"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_round2",
          "args": [
            "sizeof(*entry)"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_round2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1305-1317",
          "snippet": "static inline int tomoyo_round2(size_t size)\n{\n#if PAGE_SIZE == 4096\n\tsize_t bsize = 32;\n#else\n\tsize_t bsize = 64;\n#endif\n\tif (!size)\n\t\treturn 0;\n\twhile (size > bsize)\n\t\tbsize <<= 1;\n\treturn bsize;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline int tomoyo_round2(size_t size)\n{\n#if PAGE_SIZE == 4096\n\tsize_t bsize = 32;\n#else\n\tsize_t bsize = 64;\n#endif\n\tif (!size)\n\t\treturn 0;\n\twhile (size > bsize)\n\t\tbsize <<= 1;\n\treturn bsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*entry)",
            "GFP_NOFS"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_init_log",
          "args": [
            "r",
            "len",
            "fmt",
            "args"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_init_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
          "lines": "242-291",
          "snippet": "char *tomoyo_init_log(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t      va_list args)\n{\n\tchar *buf = NULL;\n\tchar *bprm_info = NULL;\n\tconst char *header = NULL;\n\tchar *realpath = NULL;\n\tconst char *symlink = NULL;\n\tint pos;\n\tconst char *domainname = r->domain->domainname->name;\n\theader = tomoyo_print_header(r);\n\tif (!header)\n\t\treturn NULL;\n\t/* +10 is for '\\n' etc. and '\\0'. */\n\tlen += strlen(domainname) + strlen(header) + 10;\n\tif (r->ee) {\n\t\tstruct file *file = r->ee->bprm->file;\n\t\trealpath = tomoyo_realpath_from_path(&file->f_path);\n\t\tbprm_info = tomoyo_print_bprm(r->ee->bprm, &r->ee->dump);\n\t\tif (!realpath || !bprm_info)\n\t\t\tgoto out;\n\t\t/* +80 is for \" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\" */\n\t\tlen += strlen(realpath) + 80 + strlen(bprm_info);\n\t} else if (r->obj && r->obj->symlink_target) {\n\t\tsymlink = r->obj->symlink_target->name;\n\t\t/* +18 is for \" symlink.target=\\\"%s\\\"\" */\n\t\tlen += 18 + strlen(symlink);\n\t}\n\tlen = tomoyo_round2(len);\n\tbuf = kzalloc(len, GFP_NOFS);\n\tif (!buf)\n\t\tgoto out;\n\tlen--;\n\tpos = snprintf(buf, len, \"%s\", header);\n\tif (realpath) {\n\t\tstruct linux_binprm *bprm = r->ee->bprm;\n\t\tpos += snprintf(buf + pos, len - pos,\n\t\t\t\t\" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\",\n\t\t\t\trealpath, bprm->argc, bprm->envc, bprm_info);\n\t} else if (symlink)\n\t\tpos += snprintf(buf + pos, len - pos, \" symlink.target=\\\"%s\\\"\",\n\t\t\t\tsymlink);\n\tpos += snprintf(buf + pos, len - pos, \"\\n%s\\n\", domainname);\n\tvsnprintf(buf + pos, len - pos, fmt, args);\nout:\n\tkfree(realpath);\n\tkfree(bprm_info);\n\tkfree(header);\n\treturn buf;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nchar *tomoyo_init_log(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t      va_list args)\n{\n\tchar *buf = NULL;\n\tchar *bprm_info = NULL;\n\tconst char *header = NULL;\n\tchar *realpath = NULL;\n\tconst char *symlink = NULL;\n\tint pos;\n\tconst char *domainname = r->domain->domainname->name;\n\theader = tomoyo_print_header(r);\n\tif (!header)\n\t\treturn NULL;\n\t/* +10 is for '\\n' etc. and '\\0'. */\n\tlen += strlen(domainname) + strlen(header) + 10;\n\tif (r->ee) {\n\t\tstruct file *file = r->ee->bprm->file;\n\t\trealpath = tomoyo_realpath_from_path(&file->f_path);\n\t\tbprm_info = tomoyo_print_bprm(r->ee->bprm, &r->ee->dump);\n\t\tif (!realpath || !bprm_info)\n\t\t\tgoto out;\n\t\t/* +80 is for \" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\" */\n\t\tlen += strlen(realpath) + 80 + strlen(bprm_info);\n\t} else if (r->obj && r->obj->symlink_target) {\n\t\tsymlink = r->obj->symlink_target->name;\n\t\t/* +18 is for \" symlink.target=\\\"%s\\\"\" */\n\t\tlen += 18 + strlen(symlink);\n\t}\n\tlen = tomoyo_round2(len);\n\tbuf = kzalloc(len, GFP_NOFS);\n\tif (!buf)\n\t\tgoto out;\n\tlen--;\n\tpos = snprintf(buf, len, \"%s\", header);\n\tif (realpath) {\n\t\tstruct linux_binprm *bprm = r->ee->bprm;\n\t\tpos += snprintf(buf + pos, len - pos,\n\t\t\t\t\" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\",\n\t\t\t\trealpath, bprm->argc, bprm->envc, bprm_info);\n\t} else if (symlink)\n\t\tpos += snprintf(buf + pos, len - pos, \" symlink.target=\\\"%s\\\"\",\n\t\t\t\tsymlink);\n\tpos += snprintf(buf + pos, len - pos, \"\\n%s\\n\", domainname);\n\tvsnprintf(buf + pos, len - pos, fmt, args);\nout:\n\tkfree(realpath);\n\tkfree(bprm_info);\n\tkfree(header);\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_get_audit",
          "args": [
            "r->domain->ns",
            "r->profile",
            "r->type",
            "r->matched_acl",
            "r->granted"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
          "lines": "322-347",
          "snippet": "static bool tomoyo_get_audit(const struct tomoyo_policy_namespace *ns,\n\t\t\t     const u8 profile, const u8 index,\n\t\t\t     const struct tomoyo_acl_info *matched_acl,\n\t\t\t     const bool is_granted)\n{\n\tu8 mode;\n\tconst u8 category = tomoyo_index2category[index] +\n\t\tTOMOYO_MAX_MAC_INDEX;\n\tstruct tomoyo_profile *p;\n\tif (!tomoyo_policy_loaded)\n\t\treturn false;\n\tp = tomoyo_profile(ns, profile);\n\tif (tomoyo_log_count >= p->pref[TOMOYO_PREF_MAX_AUDIT_LOG])\n\t\treturn false;\n\tif (is_granted && matched_acl && matched_acl->cond &&\n\t    matched_acl->cond->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\treturn matched_acl->cond->grant_log == TOMOYO_GRANTLOG_YES;\n\tmode = p->config[index];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->config[category];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->default_config;\n\tif (is_granted)\n\t\treturn mode & TOMOYO_CONFIG_WANT_GRANT_LOG;\n\treturn mode & TOMOYO_CONFIG_WANT_REJECT_LOG;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int tomoyo_log_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic unsigned int tomoyo_log_count;\n\nstatic bool tomoyo_get_audit(const struct tomoyo_policy_namespace *ns,\n\t\t\t     const u8 profile, const u8 index,\n\t\t\t     const struct tomoyo_acl_info *matched_acl,\n\t\t\t     const bool is_granted)\n{\n\tu8 mode;\n\tconst u8 category = tomoyo_index2category[index] +\n\t\tTOMOYO_MAX_MAC_INDEX;\n\tstruct tomoyo_profile *p;\n\tif (!tomoyo_policy_loaded)\n\t\treturn false;\n\tp = tomoyo_profile(ns, profile);\n\tif (tomoyo_log_count >= p->pref[TOMOYO_PREF_MAX_AUDIT_LOG])\n\t\treturn false;\n\tif (is_granted && matched_acl && matched_acl->cond &&\n\t    matched_acl->cond->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\treturn matched_acl->cond->grant_log == TOMOYO_GRANTLOG_YES;\n\tmode = p->config[index];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->config[category];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->default_config;\n\tif (is_granted)\n\t\treturn mode & TOMOYO_CONFIG_WANT_GRANT_LOG;\n\treturn mode & TOMOYO_CONFIG_WANT_REJECT_LOG;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_log_wait);\nstatic LIST_HEAD(tomoyo_log);\nstatic DEFINE_SPINLOCK(tomoyo_log_lock);\nstatic unsigned int tomoyo_log_count;\n\nvoid tomoyo_write_log2(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t       va_list args)\n{\n\tchar *buf;\n\tstruct tomoyo_log *entry;\n\tbool quota_exceeded = false;\n\tif (!tomoyo_get_audit(r->domain->ns, r->profile, r->type,\n\t\t\t      r->matched_acl, r->granted))\n\t\tgoto out;\n\tbuf = tomoyo_init_log(r, len, fmt, args);\n\tif (!buf)\n\t\tgoto out;\n\tentry = kzalloc(sizeof(*entry), GFP_NOFS);\n\tif (!entry) {\n\t\tkfree(buf);\n\t\tgoto out;\n\t}\n\tentry->log = buf;\n\tlen = tomoyo_round2(strlen(buf) + 1);\n\t/*\n\t * The entry->size is used for memory quota checks.\n\t * Don't go beyond strlen(entry->log).\n\t */\n\tentry->size = len + tomoyo_round2(sizeof(*entry));\n\tspin_lock(&tomoyo_log_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_AUDIT] + entry->size >=\n\t    tomoyo_memory_quota[TOMOYO_MEMORY_AUDIT]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_AUDIT] += entry->size;\n\t\tlist_add_tail(&entry->list, &tomoyo_log);\n\t\ttomoyo_log_count++;\n\t}\n\tspin_unlock(&tomoyo_log_lock);\n\tif (quota_exceeded) {\n\t\tkfree(buf);\n\t\tkfree(entry);\n\t\tgoto out;\n\t}\n\twake_up(&tomoyo_log_wait);\nout:\n\treturn;\n}"
  },
  {
    "function_name": "tomoyo_get_audit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
    "lines": "322-347",
    "snippet": "static bool tomoyo_get_audit(const struct tomoyo_policy_namespace *ns,\n\t\t\t     const u8 profile, const u8 index,\n\t\t\t     const struct tomoyo_acl_info *matched_acl,\n\t\t\t     const bool is_granted)\n{\n\tu8 mode;\n\tconst u8 category = tomoyo_index2category[index] +\n\t\tTOMOYO_MAX_MAC_INDEX;\n\tstruct tomoyo_profile *p;\n\tif (!tomoyo_policy_loaded)\n\t\treturn false;\n\tp = tomoyo_profile(ns, profile);\n\tif (tomoyo_log_count >= p->pref[TOMOYO_PREF_MAX_AUDIT_LOG])\n\t\treturn false;\n\tif (is_granted && matched_acl && matched_acl->cond &&\n\t    matched_acl->cond->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\treturn matched_acl->cond->grant_log == TOMOYO_GRANTLOG_YES;\n\tmode = p->config[index];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->config[category];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->default_config;\n\tif (is_granted)\n\t\treturn mode & TOMOYO_CONFIG_WANT_GRANT_LOG;\n\treturn mode & TOMOYO_CONFIG_WANT_REJECT_LOG;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int tomoyo_log_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_profile",
          "args": [
            "ns",
            "profile"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_profile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "528-536",
          "snippet": "struct tomoyo_profile *tomoyo_profile(const struct tomoyo_policy_namespace *ns,\n\t\t\t\t      const u8 profile)\n{\n\tstatic struct tomoyo_profile tomoyo_null_profile;\n\tstruct tomoyo_profile *ptr = ns->profile_ptr[profile];\n\tif (!ptr)\n\t\tptr = &tomoyo_null_profile;\n\treturn ptr;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstruct tomoyo_profile *tomoyo_profile(const struct tomoyo_policy_namespace *ns,\n\t\t\t\t      const u8 profile)\n{\n\tstatic struct tomoyo_profile tomoyo_null_profile;\n\tstruct tomoyo_profile *ptr = ns->profile_ptr[profile];\n\tif (!ptr)\n\t\tptr = &tomoyo_null_profile;\n\treturn ptr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic unsigned int tomoyo_log_count;\n\nstatic bool tomoyo_get_audit(const struct tomoyo_policy_namespace *ns,\n\t\t\t     const u8 profile, const u8 index,\n\t\t\t     const struct tomoyo_acl_info *matched_acl,\n\t\t\t     const bool is_granted)\n{\n\tu8 mode;\n\tconst u8 category = tomoyo_index2category[index] +\n\t\tTOMOYO_MAX_MAC_INDEX;\n\tstruct tomoyo_profile *p;\n\tif (!tomoyo_policy_loaded)\n\t\treturn false;\n\tp = tomoyo_profile(ns, profile);\n\tif (tomoyo_log_count >= p->pref[TOMOYO_PREF_MAX_AUDIT_LOG])\n\t\treturn false;\n\tif (is_granted && matched_acl && matched_acl->cond &&\n\t    matched_acl->cond->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\treturn matched_acl->cond->grant_log == TOMOYO_GRANTLOG_YES;\n\tmode = p->config[index];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->config[category];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->default_config;\n\tif (is_granted)\n\t\treturn mode & TOMOYO_CONFIG_WANT_GRANT_LOG;\n\treturn mode & TOMOYO_CONFIG_WANT_REJECT_LOG;\n}"
  },
  {
    "function_name": "tomoyo_init_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
    "lines": "242-291",
    "snippet": "char *tomoyo_init_log(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t      va_list args)\n{\n\tchar *buf = NULL;\n\tchar *bprm_info = NULL;\n\tconst char *header = NULL;\n\tchar *realpath = NULL;\n\tconst char *symlink = NULL;\n\tint pos;\n\tconst char *domainname = r->domain->domainname->name;\n\theader = tomoyo_print_header(r);\n\tif (!header)\n\t\treturn NULL;\n\t/* +10 is for '\\n' etc. and '\\0'. */\n\tlen += strlen(domainname) + strlen(header) + 10;\n\tif (r->ee) {\n\t\tstruct file *file = r->ee->bprm->file;\n\t\trealpath = tomoyo_realpath_from_path(&file->f_path);\n\t\tbprm_info = tomoyo_print_bprm(r->ee->bprm, &r->ee->dump);\n\t\tif (!realpath || !bprm_info)\n\t\t\tgoto out;\n\t\t/* +80 is for \" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\" */\n\t\tlen += strlen(realpath) + 80 + strlen(bprm_info);\n\t} else if (r->obj && r->obj->symlink_target) {\n\t\tsymlink = r->obj->symlink_target->name;\n\t\t/* +18 is for \" symlink.target=\\\"%s\\\"\" */\n\t\tlen += 18 + strlen(symlink);\n\t}\n\tlen = tomoyo_round2(len);\n\tbuf = kzalloc(len, GFP_NOFS);\n\tif (!buf)\n\t\tgoto out;\n\tlen--;\n\tpos = snprintf(buf, len, \"%s\", header);\n\tif (realpath) {\n\t\tstruct linux_binprm *bprm = r->ee->bprm;\n\t\tpos += snprintf(buf + pos, len - pos,\n\t\t\t\t\" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\",\n\t\t\t\trealpath, bprm->argc, bprm->envc, bprm_info);\n\t} else if (symlink)\n\t\tpos += snprintf(buf + pos, len - pos, \" symlink.target=\\\"%s\\\"\",\n\t\t\t\tsymlink);\n\tpos += snprintf(buf + pos, len - pos, \"\\n%s\\n\", domainname);\n\tvsnprintf(buf + pos, len - pos, fmt, args);\nout:\n\tkfree(realpath);\n\tkfree(bprm_info);\n\tkfree(header);\n\treturn buf;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "header"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "bprm_info"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "realpath"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "buf + pos",
            "len - pos",
            "fmt",
            "args"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "len - pos",
            "\"\\n%s\\n\"",
            "domainname"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "len - pos",
            "\" symlink.target=\\\"%s\\\"\"",
            "symlink"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "len - pos",
            "\" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\"",
            "realpath",
            "bprm->argc",
            "bprm->envc",
            "bprm_info"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "len",
            "\"%s\"",
            "header"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len",
            "GFP_NOFS"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_round2",
          "args": [
            "len"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_round2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1305-1317",
          "snippet": "static inline int tomoyo_round2(size_t size)\n{\n#if PAGE_SIZE == 4096\n\tsize_t bsize = 32;\n#else\n\tsize_t bsize = 64;\n#endif\n\tif (!size)\n\t\treturn 0;\n\twhile (size > bsize)\n\t\tbsize <<= 1;\n\treturn bsize;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline int tomoyo_round2(size_t size)\n{\n#if PAGE_SIZE == 4096\n\tsize_t bsize = 32;\n#else\n\tsize_t bsize = 64;\n#endif\n\tif (!size)\n\t\treturn 0;\n\twhile (size > bsize)\n\t\tbsize <<= 1;\n\treturn bsize;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "symlink"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "bprm_info"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "realpath"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_print_bprm",
          "args": [
            "r->ee->bprm",
            "&r->ee->dump"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_bprm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
          "lines": "22-107",
          "snippet": "static char *tomoyo_print_bprm(struct linux_binprm *bprm,\n\t\t\t       struct tomoyo_page_dump *dump)\n{\n\tstatic const int tomoyo_buffer_len = 4096 * 2;\n\tchar *buffer = kzalloc(tomoyo_buffer_len, GFP_NOFS);\n\tchar *cp;\n\tchar *last_start;\n\tint len;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tbool truncated = false;\n\tif (!buffer)\n\t\treturn NULL;\n\tlen = snprintf(buffer, tomoyo_buffer_len - 1, \"argv[]={ \");\n\tcp = buffer + len;\n\tif (!argv_count) {\n\t\tmemmove(cp, \"} envp[]={ \", 11);\n\t\tcp += 11;\n\t}\n\tlast_start = cp;\n\twhile (argv_count || envp_count) {\n\t\tif (!tomoyo_dump_page(bprm, pos, dump))\n\t\t\tgoto out;\n\t\tpos += PAGE_SIZE - offset;\n\t\t/* Read. */\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\tconst char *kaddr = dump->data;\n\t\t\tconst unsigned char c = kaddr[offset++];\n\t\t\tif (cp == last_start)\n\t\t\t\t*cp++ = '\"';\n\t\t\tif (cp >= buffer + tomoyo_buffer_len - 32) {\n\t\t\t\t/* Reserve some room for \"...\" string. */\n\t\t\t\ttruncated = true;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t*cp++ = c;\n\t\t\t} else if (!c) {\n\t\t\t\t*cp++ = '\"';\n\t\t\t\t*cp++ = ' ';\n\t\t\t\tlast_start = cp;\n\t\t\t} else {\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t\t*cp++ = (c >> 6) + '0';\n\t\t\t\t*cp++ = ((c >> 3) & 7) + '0';\n\t\t\t\t*cp++ = (c & 7) + '0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\tif (argv_count) {\n\t\t\t\tif (--argv_count == 0) {\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\tcp = last_start;\n\t\t\t\t\t\tmemmove(cp, \"... \", 4);\n\t\t\t\t\t\tcp += 4;\n\t\t\t\t\t}\n\t\t\t\t\tmemmove(cp, \"} envp[]={ \", 11);\n\t\t\t\t\tcp += 11;\n\t\t\t\t\tlast_start = cp;\n\t\t\t\t\ttruncated = false;\n\t\t\t\t}\n\t\t\t} else if (envp_count) {\n\t\t\t\tif (--envp_count == 0) {\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\tcp = last_start;\n\t\t\t\t\t\tmemmove(cp, \"... \", 4);\n\t\t\t\t\t\tcp += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!argv_count && !envp_count)\n\t\t\t\tbreak;\n\t\t}\n\t\toffset = 0;\n\t}\n\t*cp++ = '}';\n\t*cp = '\\0';\n\treturn buffer;\nout:\n\tsnprintf(buffer, tomoyo_buffer_len - 1,\n\t\t \"argv[]={ ... } envp[]= { ... }\");\n\treturn buffer;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic char *tomoyo_print_bprm(struct linux_binprm *bprm,\n\t\t\t       struct tomoyo_page_dump *dump)\n{\n\tstatic const int tomoyo_buffer_len = 4096 * 2;\n\tchar *buffer = kzalloc(tomoyo_buffer_len, GFP_NOFS);\n\tchar *cp;\n\tchar *last_start;\n\tint len;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tbool truncated = false;\n\tif (!buffer)\n\t\treturn NULL;\n\tlen = snprintf(buffer, tomoyo_buffer_len - 1, \"argv[]={ \");\n\tcp = buffer + len;\n\tif (!argv_count) {\n\t\tmemmove(cp, \"} envp[]={ \", 11);\n\t\tcp += 11;\n\t}\n\tlast_start = cp;\n\twhile (argv_count || envp_count) {\n\t\tif (!tomoyo_dump_page(bprm, pos, dump))\n\t\t\tgoto out;\n\t\tpos += PAGE_SIZE - offset;\n\t\t/* Read. */\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\tconst char *kaddr = dump->data;\n\t\t\tconst unsigned char c = kaddr[offset++];\n\t\t\tif (cp == last_start)\n\t\t\t\t*cp++ = '\"';\n\t\t\tif (cp >= buffer + tomoyo_buffer_len - 32) {\n\t\t\t\t/* Reserve some room for \"...\" string. */\n\t\t\t\ttruncated = true;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t*cp++ = c;\n\t\t\t} else if (!c) {\n\t\t\t\t*cp++ = '\"';\n\t\t\t\t*cp++ = ' ';\n\t\t\t\tlast_start = cp;\n\t\t\t} else {\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t\t*cp++ = (c >> 6) + '0';\n\t\t\t\t*cp++ = ((c >> 3) & 7) + '0';\n\t\t\t\t*cp++ = (c & 7) + '0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\tif (argv_count) {\n\t\t\t\tif (--argv_count == 0) {\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\tcp = last_start;\n\t\t\t\t\t\tmemmove(cp, \"... \", 4);\n\t\t\t\t\t\tcp += 4;\n\t\t\t\t\t}\n\t\t\t\t\tmemmove(cp, \"} envp[]={ \", 11);\n\t\t\t\t\tcp += 11;\n\t\t\t\t\tlast_start = cp;\n\t\t\t\t\ttruncated = false;\n\t\t\t\t}\n\t\t\t} else if (envp_count) {\n\t\t\t\tif (--envp_count == 0) {\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\tcp = last_start;\n\t\t\t\t\t\tmemmove(cp, \"... \", 4);\n\t\t\t\t\t\tcp += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!argv_count && !envp_count)\n\t\t\t\tbreak;\n\t\t}\n\t\toffset = 0;\n\t}\n\t*cp++ = '}';\n\t*cp = '\\0';\n\treturn buffer;\nout:\n\tsnprintf(buffer, tomoyo_buffer_len - 1,\n\t\t \"argv[]={ ... } envp[]= { ... }\");\n\treturn buffer;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_realpath_from_path",
          "args": [
            "&file->f_path"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_realpath_from_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "251-311",
          "snippet": "char *tomoyo_realpath_from_path(const struct path *path)\n{\n\tchar *buf = NULL;\n\tchar *name = NULL;\n\tunsigned int buf_len = PAGE_SIZE / 2;\n\tstruct dentry *dentry = path->dentry;\n\tstruct super_block *sb;\n\tif (!dentry)\n\t\treturn NULL;\n\tsb = dentry->d_sb;\n\twhile (1) {\n\t\tchar *pos;\n\t\tstruct inode *inode;\n\t\tbuf_len <<= 1;\n\t\tkfree(buf);\n\t\tbuf = kmalloc(buf_len, GFP_NOFS);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\t/* To make sure that pos is '\\0' terminated. */\n\t\tbuf[buf_len - 1] = '\\0';\n\t\t/* Get better name for socket. */\n\t\tif (sb->s_magic == SOCKFS_MAGIC) {\n\t\t\tpos = tomoyo_get_socket_name(path, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\t/* For \"pipe:[\\$]\". */\n\t\tif (dentry->d_op && dentry->d_op->d_dname) {\n\t\t\tpos = dentry->d_op->d_dname(dentry, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\tinode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Get local name for filesystems without rename() operation\n\t\t * or dentry without vfsmount.\n\t\t */\n\t\tif (!path->mnt ||\n\t\t    (!inode->i_op->rename))\n\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t    buf_len - 1);\n\t\t/* Get absolute name for the rest. */\n\t\telse {\n\t\t\tpos = tomoyo_get_absolute_path(path, buf, buf_len - 1);\n\t\t\t/*\n\t\t\t * Fall back to local name if absolute name is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tif (pos == ERR_PTR(-EINVAL))\n\t\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t\t    buf_len - 1);\n\t\t}\nencode:\n\t\tif (IS_ERR(pos))\n\t\t\tcontinue;\n\t\tname = tomoyo_encode(pos);\n\t\tbreak;\n\t}\n\tkfree(buf);\n\tif (!name)\n\t\ttomoyo_warn_oom(__func__);\n\treturn name;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_realpath_from_path(const struct path *path)\n{\n\tchar *buf = NULL;\n\tchar *name = NULL;\n\tunsigned int buf_len = PAGE_SIZE / 2;\n\tstruct dentry *dentry = path->dentry;\n\tstruct super_block *sb;\n\tif (!dentry)\n\t\treturn NULL;\n\tsb = dentry->d_sb;\n\twhile (1) {\n\t\tchar *pos;\n\t\tstruct inode *inode;\n\t\tbuf_len <<= 1;\n\t\tkfree(buf);\n\t\tbuf = kmalloc(buf_len, GFP_NOFS);\n\t\tif (!buf)\n\t\t\tbreak;\n\t\t/* To make sure that pos is '\\0' terminated. */\n\t\tbuf[buf_len - 1] = '\\0';\n\t\t/* Get better name for socket. */\n\t\tif (sb->s_magic == SOCKFS_MAGIC) {\n\t\t\tpos = tomoyo_get_socket_name(path, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\t/* For \"pipe:[\\$]\". */\n\t\tif (dentry->d_op && dentry->d_op->d_dname) {\n\t\t\tpos = dentry->d_op->d_dname(dentry, buf, buf_len - 1);\n\t\t\tgoto encode;\n\t\t}\n\t\tinode = d_backing_inode(sb->s_root);\n\t\t/*\n\t\t * Get local name for filesystems without rename() operation\n\t\t * or dentry without vfsmount.\n\t\t */\n\t\tif (!path->mnt ||\n\t\t    (!inode->i_op->rename))\n\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t    buf_len - 1);\n\t\t/* Get absolute name for the rest. */\n\t\telse {\n\t\t\tpos = tomoyo_get_absolute_path(path, buf, buf_len - 1);\n\t\t\t/*\n\t\t\t * Fall back to local name if absolute name is not\n\t\t\t * available.\n\t\t\t */\n\t\t\tif (pos == ERR_PTR(-EINVAL))\n\t\t\t\tpos = tomoyo_get_local_path(path->dentry, buf,\n\t\t\t\t\t\t\t    buf_len - 1);\n\t\t}\nencode:\n\t\tif (IS_ERR(pos))\n\t\t\tcontinue;\n\t\tname = tomoyo_encode(pos);\n\t\tbreak;\n\t}\n\tkfree(buf);\n\tif (!name)\n\t\ttomoyo_warn_oom(__func__);\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "header"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "domainname"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_print_header",
          "args": [
            "r"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_header",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
          "lines": "148-227",
          "snippet": "static char *tomoyo_print_header(struct tomoyo_request_info *r)\n{\n\tstruct tomoyo_time stamp;\n\tconst pid_t gpid = task_pid_nr(current);\n\tstruct tomoyo_obj_info *obj = r->obj;\n\tstatic const int tomoyo_buffer_len = 4096;\n\tchar *buffer = kmalloc(tomoyo_buffer_len, GFP_NOFS);\n\tint pos;\n\tu8 i;\n\tif (!buffer)\n\t\treturn NULL;\n\n\ttomoyo_convert_time(ktime_get_real_seconds(), &stamp);\n\n\tpos = snprintf(buffer, tomoyo_buffer_len - 1,\n\t\t       \"#%04u/%02u/%02u %02u:%02u:%02u# profile=%u mode=%s \"\n\t\t       \"granted=%s (global-pid=%u) task={ pid=%u ppid=%u \"\n\t\t       \"uid=%u gid=%u euid=%u egid=%u suid=%u sgid=%u \"\n\t\t       \"fsuid=%u fsgid=%u }\", stamp.year, stamp.month,\n\t\t       stamp.day, stamp.hour, stamp.min, stamp.sec, r->profile,\n\t\t       tomoyo_mode[r->mode], tomoyo_yesno(r->granted), gpid,\n\t\t       tomoyo_sys_getpid(), tomoyo_sys_getppid(),\n\t\t       from_kuid(&init_user_ns, current_uid()),\n\t\t       from_kgid(&init_user_ns, current_gid()),\n\t\t       from_kuid(&init_user_ns, current_euid()),\n\t\t       from_kgid(&init_user_ns, current_egid()),\n\t\t       from_kuid(&init_user_ns, current_suid()),\n\t\t       from_kgid(&init_user_ns, current_sgid()),\n\t\t       from_kuid(&init_user_ns, current_fsuid()),\n\t\t       from_kgid(&init_user_ns, current_fsgid()));\n\tif (!obj)\n\t\tgoto no_obj_info;\n\tif (!obj->validate_done) {\n\t\ttomoyo_get_attributes(obj);\n\t\tobj->validate_done = true;\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\n\t\tstruct tomoyo_mini_stat *stat;\n\t\tunsigned int dev;\n\t\tumode_t mode;\n\t\tif (!obj->stat_valid[i])\n\t\t\tcontinue;\n\t\tstat = &obj->stat[i];\n\t\tdev = stat->dev;\n\t\tmode = stat->mode;\n\t\tif (i & 1) {\n\t\t\tpos += snprintf(buffer + pos,\n\t\t\t\t\ttomoyo_buffer_len - 1 - pos,\n\t\t\t\t\t\" path%u.parent={ uid=%u gid=%u \"\n\t\t\t\t\t\"ino=%lu perm=0%o }\", (i >> 1) + 1,\n\t\t\t\t\tfrom_kuid(&init_user_ns, stat->uid),\n\t\t\t\t\tfrom_kgid(&init_user_ns, stat->gid),\n\t\t\t\t\t(unsigned long)stat->ino,\n\t\t\t\t\tstat->mode & S_IALLUGO);\n\t\t\tcontinue;\n\t\t}\n\t\tpos += snprintf(buffer + pos, tomoyo_buffer_len - 1 - pos,\n\t\t\t\t\" path%u={ uid=%u gid=%u ino=%lu major=%u\"\n\t\t\t\t\" minor=%u perm=0%o type=%s\", (i >> 1) + 1,\n\t\t\t\tfrom_kuid(&init_user_ns, stat->uid),\n\t\t\t\tfrom_kgid(&init_user_ns, stat->gid),\n\t\t\t\t(unsigned long)stat->ino,\n\t\t\t\tMAJOR(dev), MINOR(dev),\n\t\t\t\tmode & S_IALLUGO, tomoyo_filetype(mode));\n\t\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\t\tdev = stat->rdev;\n\t\t\tpos += snprintf(buffer + pos,\n\t\t\t\t\ttomoyo_buffer_len - 1 - pos,\n\t\t\t\t\t\" dev_major=%u dev_minor=%u\",\n\t\t\t\t\tMAJOR(dev), MINOR(dev));\n\t\t}\n\t\tpos += snprintf(buffer + pos, tomoyo_buffer_len - 1 - pos,\n\t\t\t\t\" }\");\n\t}\nno_obj_info:\n\tif (pos < tomoyo_buffer_len - 1)\n\t\treturn buffer;\n\tkfree(buffer);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic char *tomoyo_print_header(struct tomoyo_request_info *r)\n{\n\tstruct tomoyo_time stamp;\n\tconst pid_t gpid = task_pid_nr(current);\n\tstruct tomoyo_obj_info *obj = r->obj;\n\tstatic const int tomoyo_buffer_len = 4096;\n\tchar *buffer = kmalloc(tomoyo_buffer_len, GFP_NOFS);\n\tint pos;\n\tu8 i;\n\tif (!buffer)\n\t\treturn NULL;\n\n\ttomoyo_convert_time(ktime_get_real_seconds(), &stamp);\n\n\tpos = snprintf(buffer, tomoyo_buffer_len - 1,\n\t\t       \"#%04u/%02u/%02u %02u:%02u:%02u# profile=%u mode=%s \"\n\t\t       \"granted=%s (global-pid=%u) task={ pid=%u ppid=%u \"\n\t\t       \"uid=%u gid=%u euid=%u egid=%u suid=%u sgid=%u \"\n\t\t       \"fsuid=%u fsgid=%u }\", stamp.year, stamp.month,\n\t\t       stamp.day, stamp.hour, stamp.min, stamp.sec, r->profile,\n\t\t       tomoyo_mode[r->mode], tomoyo_yesno(r->granted), gpid,\n\t\t       tomoyo_sys_getpid(), tomoyo_sys_getppid(),\n\t\t       from_kuid(&init_user_ns, current_uid()),\n\t\t       from_kgid(&init_user_ns, current_gid()),\n\t\t       from_kuid(&init_user_ns, current_euid()),\n\t\t       from_kgid(&init_user_ns, current_egid()),\n\t\t       from_kuid(&init_user_ns, current_suid()),\n\t\t       from_kgid(&init_user_ns, current_sgid()),\n\t\t       from_kuid(&init_user_ns, current_fsuid()),\n\t\t       from_kgid(&init_user_ns, current_fsgid()));\n\tif (!obj)\n\t\tgoto no_obj_info;\n\tif (!obj->validate_done) {\n\t\ttomoyo_get_attributes(obj);\n\t\tobj->validate_done = true;\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\n\t\tstruct tomoyo_mini_stat *stat;\n\t\tunsigned int dev;\n\t\tumode_t mode;\n\t\tif (!obj->stat_valid[i])\n\t\t\tcontinue;\n\t\tstat = &obj->stat[i];\n\t\tdev = stat->dev;\n\t\tmode = stat->mode;\n\t\tif (i & 1) {\n\t\t\tpos += snprintf(buffer + pos,\n\t\t\t\t\ttomoyo_buffer_len - 1 - pos,\n\t\t\t\t\t\" path%u.parent={ uid=%u gid=%u \"\n\t\t\t\t\t\"ino=%lu perm=0%o }\", (i >> 1) + 1,\n\t\t\t\t\tfrom_kuid(&init_user_ns, stat->uid),\n\t\t\t\t\tfrom_kgid(&init_user_ns, stat->gid),\n\t\t\t\t\t(unsigned long)stat->ino,\n\t\t\t\t\tstat->mode & S_IALLUGO);\n\t\t\tcontinue;\n\t\t}\n\t\tpos += snprintf(buffer + pos, tomoyo_buffer_len - 1 - pos,\n\t\t\t\t\" path%u={ uid=%u gid=%u ino=%lu major=%u\"\n\t\t\t\t\" minor=%u perm=0%o type=%s\", (i >> 1) + 1,\n\t\t\t\tfrom_kuid(&init_user_ns, stat->uid),\n\t\t\t\tfrom_kgid(&init_user_ns, stat->gid),\n\t\t\t\t(unsigned long)stat->ino,\n\t\t\t\tMAJOR(dev), MINOR(dev),\n\t\t\t\tmode & S_IALLUGO, tomoyo_filetype(mode));\n\t\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\t\tdev = stat->rdev;\n\t\t\tpos += snprintf(buffer + pos,\n\t\t\t\t\ttomoyo_buffer_len - 1 - pos,\n\t\t\t\t\t\" dev_major=%u dev_minor=%u\",\n\t\t\t\t\tMAJOR(dev), MINOR(dev));\n\t\t}\n\t\tpos += snprintf(buffer + pos, tomoyo_buffer_len - 1 - pos,\n\t\t\t\t\" }\");\n\t}\nno_obj_info:\n\tif (pos < tomoyo_buffer_len - 1)\n\t\treturn buffer;\n\tkfree(buffer);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nchar *tomoyo_init_log(struct tomoyo_request_info *r, int len, const char *fmt,\n\t\t      va_list args)\n{\n\tchar *buf = NULL;\n\tchar *bprm_info = NULL;\n\tconst char *header = NULL;\n\tchar *realpath = NULL;\n\tconst char *symlink = NULL;\n\tint pos;\n\tconst char *domainname = r->domain->domainname->name;\n\theader = tomoyo_print_header(r);\n\tif (!header)\n\t\treturn NULL;\n\t/* +10 is for '\\n' etc. and '\\0'. */\n\tlen += strlen(domainname) + strlen(header) + 10;\n\tif (r->ee) {\n\t\tstruct file *file = r->ee->bprm->file;\n\t\trealpath = tomoyo_realpath_from_path(&file->f_path);\n\t\tbprm_info = tomoyo_print_bprm(r->ee->bprm, &r->ee->dump);\n\t\tif (!realpath || !bprm_info)\n\t\t\tgoto out;\n\t\t/* +80 is for \" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\" */\n\t\tlen += strlen(realpath) + 80 + strlen(bprm_info);\n\t} else if (r->obj && r->obj->symlink_target) {\n\t\tsymlink = r->obj->symlink_target->name;\n\t\t/* +18 is for \" symlink.target=\\\"%s\\\"\" */\n\t\tlen += 18 + strlen(symlink);\n\t}\n\tlen = tomoyo_round2(len);\n\tbuf = kzalloc(len, GFP_NOFS);\n\tif (!buf)\n\t\tgoto out;\n\tlen--;\n\tpos = snprintf(buf, len, \"%s\", header);\n\tif (realpath) {\n\t\tstruct linux_binprm *bprm = r->ee->bprm;\n\t\tpos += snprintf(buf + pos, len - pos,\n\t\t\t\t\" exec={ realpath=\\\"%s\\\" argc=%d envc=%d %s }\",\n\t\t\t\trealpath, bprm->argc, bprm->envc, bprm_info);\n\t} else if (symlink)\n\t\tpos += snprintf(buf + pos, len - pos, \" symlink.target=\\\"%s\\\"\",\n\t\t\t\tsymlink);\n\tpos += snprintf(buf + pos, len - pos, \"\\n%s\\n\", domainname);\n\tvsnprintf(buf + pos, len - pos, fmt, args);\nout:\n\tkfree(realpath);\n\tkfree(bprm_info);\n\tkfree(header);\n\treturn buf;\n}"
  },
  {
    "function_name": "tomoyo_print_header",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
    "lines": "148-227",
    "snippet": "static char *tomoyo_print_header(struct tomoyo_request_info *r)\n{\n\tstruct tomoyo_time stamp;\n\tconst pid_t gpid = task_pid_nr(current);\n\tstruct tomoyo_obj_info *obj = r->obj;\n\tstatic const int tomoyo_buffer_len = 4096;\n\tchar *buffer = kmalloc(tomoyo_buffer_len, GFP_NOFS);\n\tint pos;\n\tu8 i;\n\tif (!buffer)\n\t\treturn NULL;\n\n\ttomoyo_convert_time(ktime_get_real_seconds(), &stamp);\n\n\tpos = snprintf(buffer, tomoyo_buffer_len - 1,\n\t\t       \"#%04u/%02u/%02u %02u:%02u:%02u# profile=%u mode=%s \"\n\t\t       \"granted=%s (global-pid=%u) task={ pid=%u ppid=%u \"\n\t\t       \"uid=%u gid=%u euid=%u egid=%u suid=%u sgid=%u \"\n\t\t       \"fsuid=%u fsgid=%u }\", stamp.year, stamp.month,\n\t\t       stamp.day, stamp.hour, stamp.min, stamp.sec, r->profile,\n\t\t       tomoyo_mode[r->mode], tomoyo_yesno(r->granted), gpid,\n\t\t       tomoyo_sys_getpid(), tomoyo_sys_getppid(),\n\t\t       from_kuid(&init_user_ns, current_uid()),\n\t\t       from_kgid(&init_user_ns, current_gid()),\n\t\t       from_kuid(&init_user_ns, current_euid()),\n\t\t       from_kgid(&init_user_ns, current_egid()),\n\t\t       from_kuid(&init_user_ns, current_suid()),\n\t\t       from_kgid(&init_user_ns, current_sgid()),\n\t\t       from_kuid(&init_user_ns, current_fsuid()),\n\t\t       from_kgid(&init_user_ns, current_fsgid()));\n\tif (!obj)\n\t\tgoto no_obj_info;\n\tif (!obj->validate_done) {\n\t\ttomoyo_get_attributes(obj);\n\t\tobj->validate_done = true;\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\n\t\tstruct tomoyo_mini_stat *stat;\n\t\tunsigned int dev;\n\t\tumode_t mode;\n\t\tif (!obj->stat_valid[i])\n\t\t\tcontinue;\n\t\tstat = &obj->stat[i];\n\t\tdev = stat->dev;\n\t\tmode = stat->mode;\n\t\tif (i & 1) {\n\t\t\tpos += snprintf(buffer + pos,\n\t\t\t\t\ttomoyo_buffer_len - 1 - pos,\n\t\t\t\t\t\" path%u.parent={ uid=%u gid=%u \"\n\t\t\t\t\t\"ino=%lu perm=0%o }\", (i >> 1) + 1,\n\t\t\t\t\tfrom_kuid(&init_user_ns, stat->uid),\n\t\t\t\t\tfrom_kgid(&init_user_ns, stat->gid),\n\t\t\t\t\t(unsigned long)stat->ino,\n\t\t\t\t\tstat->mode & S_IALLUGO);\n\t\t\tcontinue;\n\t\t}\n\t\tpos += snprintf(buffer + pos, tomoyo_buffer_len - 1 - pos,\n\t\t\t\t\" path%u={ uid=%u gid=%u ino=%lu major=%u\"\n\t\t\t\t\" minor=%u perm=0%o type=%s\", (i >> 1) + 1,\n\t\t\t\tfrom_kuid(&init_user_ns, stat->uid),\n\t\t\t\tfrom_kgid(&init_user_ns, stat->gid),\n\t\t\t\t(unsigned long)stat->ino,\n\t\t\t\tMAJOR(dev), MINOR(dev),\n\t\t\t\tmode & S_IALLUGO, tomoyo_filetype(mode));\n\t\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\t\tdev = stat->rdev;\n\t\t\tpos += snprintf(buffer + pos,\n\t\t\t\t\ttomoyo_buffer_len - 1 - pos,\n\t\t\t\t\t\" dev_major=%u dev_minor=%u\",\n\t\t\t\t\tMAJOR(dev), MINOR(dev));\n\t\t}\n\t\tpos += snprintf(buffer + pos, tomoyo_buffer_len - 1 - pos,\n\t\t\t\t\" }\");\n\t}\nno_obj_info:\n\tif (pos < tomoyo_buffer_len - 1)\n\t\treturn buffer;\n\tkfree(buffer);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buffer"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer + pos",
            "tomoyo_buffer_len - 1 - pos",
            "\" }\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer + pos",
            "tomoyo_buffer_len - 1 - pos",
            "\" dev_major=%u dev_minor=%u\"",
            "MAJOR(dev)",
            "MINOR(dev)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISBLK",
          "args": [
            "mode"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISCHR",
          "args": [
            "mode"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer + pos",
            "tomoyo_buffer_len - 1 - pos",
            "\" path%u={ uid=%u gid=%u ino=%lu major=%u\"\n\t\t\t\t\" minor=%u perm=0%o type=%s\"",
            "(i >> 1) + 1",
            "from_kuid(&init_user_ns, stat->uid)",
            "from_kgid(&init_user_ns, stat->gid)",
            "(unsigned long)stat->ino",
            "MAJOR(dev)",
            "MINOR(dev)",
            "mode & S_IALLUGO",
            "tomoyo_filetype(mode)"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_filetype",
          "args": [
            "mode"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_filetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
          "lines": "116-136",
          "snippet": "static inline const char *tomoyo_filetype(const umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase 0:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_FILE];\n\tcase S_IFDIR:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_DIRECTORY];\n\tcase S_IFLNK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_SYMLINK];\n\tcase S_IFIFO:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_FIFO];\n\tcase S_IFSOCK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_SOCKET];\n\tcase S_IFBLK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_BLOCK_DEV];\n\tcase S_IFCHR:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_CHAR_DEV];\n\t}\n\treturn \"unknown\"; /* This should not happen. */\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic inline const char *tomoyo_filetype(const umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase 0:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_FILE];\n\tcase S_IFDIR:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_DIRECTORY];\n\tcase S_IFLNK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_SYMLINK];\n\tcase S_IFIFO:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_FIFO];\n\tcase S_IFSOCK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_SOCKET];\n\tcase S_IFBLK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_BLOCK_DEV];\n\tcase S_IFCHR:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_CHAR_DEV];\n\t}\n\treturn \"unknown\"; /* This should not happen. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "dev"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "dev"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "stat->gid"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "stat->uid"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer + pos",
            "tomoyo_buffer_len - 1 - pos",
            "\" path%u.parent={ uid=%u gid=%u \"\n\t\t\t\t\t\"ino=%lu perm=0%o }\"",
            "(i >> 1) + 1",
            "from_kuid(&init_user_ns, stat->uid)",
            "from_kgid(&init_user_ns, stat->gid)",
            "(unsigned long)stat->ino",
            "stat->mode & S_IALLUGO"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "stat->gid"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "stat->uid"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_attributes",
          "args": [
            "obj"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_attributes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "694-733",
          "snippet": "void tomoyo_get_attributes(struct tomoyo_obj_info *obj)\n{\n\tu8 i;\n\tstruct dentry *dentry = NULL;\n\n\tfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\n\t\tstruct inode *inode;\n\t\tswitch (i) {\n\t\tcase TOMOYO_PATH1:\n\t\t\tdentry = obj->path1.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase TOMOYO_PATH2:\n\t\t\tdentry = obj->path2.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tdentry = dget_parent(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tinode = d_backing_inode(dentry);\n\t\tif (inode) {\n\t\t\tstruct tomoyo_mini_stat *stat = &obj->stat[i];\n\t\t\tstat->uid  = inode->i_uid;\n\t\t\tstat->gid  = inode->i_gid;\n\t\t\tstat->ino  = inode->i_ino;\n\t\t\tstat->mode = inode->i_mode;\n\t\t\tstat->dev  = inode->i_sb->s_dev;\n\t\t\tstat->rdev = inode->i_rdev;\n\t\t\tobj->stat_valid[i] = true;\n\t\t}\n\t\tif (i & 1) /* i == TOMOYO_PATH1_PARENT ||\n\t\t\t      i == TOMOYO_PATH2_PARENT */\n\t\t\tdput(dentry);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_get_attributes(struct tomoyo_obj_info *obj)\n{\n\tu8 i;\n\tstruct dentry *dentry = NULL;\n\n\tfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\n\t\tstruct inode *inode;\n\t\tswitch (i) {\n\t\tcase TOMOYO_PATH1:\n\t\t\tdentry = obj->path1.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tcase TOMOYO_PATH2:\n\t\t\tdentry = obj->path2.dentry;\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (!dentry)\n\t\t\t\tcontinue;\n\t\t\tdentry = dget_parent(dentry);\n\t\t\tbreak;\n\t\t}\n\t\tinode = d_backing_inode(dentry);\n\t\tif (inode) {\n\t\t\tstruct tomoyo_mini_stat *stat = &obj->stat[i];\n\t\t\tstat->uid  = inode->i_uid;\n\t\t\tstat->gid  = inode->i_gid;\n\t\t\tstat->ino  = inode->i_ino;\n\t\t\tstat->mode = inode->i_mode;\n\t\t\tstat->dev  = inode->i_sb->s_dev;\n\t\t\tstat->rdev = inode->i_rdev;\n\t\t\tobj->stat_valid[i] = true;\n\t\t}\n\t\tif (i & 1) /* i == TOMOYO_PATH1_PARENT ||\n\t\t\t      i == TOMOYO_PATH2_PARENT */\n\t\t\tdput(dentry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "tomoyo_buffer_len - 1",
            "\"#%04u/%02u/%02u %02u:%02u:%02u# profile=%u mode=%s \"\n\t\t       \"granted=%s (global-pid=%u) task={ pid=%u ppid=%u \"\n\t\t       \"uid=%u gid=%u euid=%u egid=%u suid=%u sgid=%u \"\n\t\t       \"fsuid=%u fsgid=%u }\"",
            "stamp.year",
            "stamp.month",
            "stamp.day",
            "stamp.hour",
            "stamp.min",
            "stamp.sec",
            "r->profile",
            "tomoyo_mode[r->mode]",
            "tomoyo_yesno(r->granted)",
            "gpid",
            "tomoyo_sys_getpid()",
            "tomoyo_sys_getppid()",
            "from_kuid(&init_user_ns, current_uid())",
            "from_kgid(&init_user_ns, current_gid())",
            "from_kuid(&init_user_ns, current_euid())",
            "from_kgid(&init_user_ns, current_egid())",
            "from_kuid(&init_user_ns, current_suid())",
            "from_kgid(&init_user_ns, current_sgid())",
            "from_kuid(&init_user_ns, current_fsuid())",
            "from_kgid(&init_user_ns, current_fsgid())"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "current_fsgid()"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsgid",
          "args": [],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "current_fsuid()"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "current_sgid()"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_sgid",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "current_suid()"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_suid",
          "args": [],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "current_egid()"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_egid",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "current_euid()"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "current_gid()"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_gid",
          "args": [],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "current_uid()"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_sys_getppid",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_sys_getppid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1121-1128",
          "snippet": "static inline pid_t tomoyo_sys_getppid(void)\n{\n\tpid_t pid;\n\trcu_read_lock();\n\tpid = task_tgid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\treturn pid;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline pid_t tomoyo_sys_getppid(void)\n{\n\tpid_t pid;\n\trcu_read_lock();\n\tpid = task_tgid_vnr(rcu_dereference(current->real_parent));\n\trcu_read_unlock();\n\treturn pid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_sys_getpid",
          "args": [],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_sys_getpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1138-1141",
          "snippet": "static inline pid_t tomoyo_sys_getpid(void)\n{\n\treturn task_tgid_vnr(current);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline pid_t tomoyo_sys_getpid(void)\n{\n\treturn task_tgid_vnr(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_yesno",
          "args": [
            "r->granted"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_yesno",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "182-185",
          "snippet": "const char *tomoyo_yesno(const unsigned int value)\n{\n\treturn value ? \"yes\" : \"no\";\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nconst char *tomoyo_yesno(const unsigned int value)\n{\n\treturn value ? \"yes\" : \"no\";\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_convert_time",
          "args": [
            "ktime_get_real_seconds()",
            "&stamp"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_convert_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "91-101",
          "snippet": "void tomoyo_convert_time(time64_t time64, struct tomoyo_time *stamp)\n{\n\tstruct tm tm;\n\ttime64_to_tm(time64, 0, &tm);\n\tstamp->sec = tm.tm_sec;\n\tstamp->min = tm.tm_min;\n\tstamp->hour = tm.tm_hour;\n\tstamp->day = tm.tm_mday;\n\tstamp->month = tm.tm_mon + 1;\n\tstamp->year = tm.tm_year + 1900;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_convert_time(time64_t time64, struct tomoyo_time *stamp)\n{\n\tstruct tm tm;\n\ttime64_to_tm(time64, 0, &tm);\n\tstamp->sec = tm.tm_sec;\n\tstamp->min = tm.tm_min;\n\tstamp->hour = tm.tm_hour;\n\tstamp->day = tm.tm_mday;\n\tstamp->month = tm.tm_mon + 1;\n\tstamp->year = tm.tm_year + 1900;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "tomoyo_buffer_len",
            "GFP_NOFS"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic char *tomoyo_print_header(struct tomoyo_request_info *r)\n{\n\tstruct tomoyo_time stamp;\n\tconst pid_t gpid = task_pid_nr(current);\n\tstruct tomoyo_obj_info *obj = r->obj;\n\tstatic const int tomoyo_buffer_len = 4096;\n\tchar *buffer = kmalloc(tomoyo_buffer_len, GFP_NOFS);\n\tint pos;\n\tu8 i;\n\tif (!buffer)\n\t\treturn NULL;\n\n\ttomoyo_convert_time(ktime_get_real_seconds(), &stamp);\n\n\tpos = snprintf(buffer, tomoyo_buffer_len - 1,\n\t\t       \"#%04u/%02u/%02u %02u:%02u:%02u# profile=%u mode=%s \"\n\t\t       \"granted=%s (global-pid=%u) task={ pid=%u ppid=%u \"\n\t\t       \"uid=%u gid=%u euid=%u egid=%u suid=%u sgid=%u \"\n\t\t       \"fsuid=%u fsgid=%u }\", stamp.year, stamp.month,\n\t\t       stamp.day, stamp.hour, stamp.min, stamp.sec, r->profile,\n\t\t       tomoyo_mode[r->mode], tomoyo_yesno(r->granted), gpid,\n\t\t       tomoyo_sys_getpid(), tomoyo_sys_getppid(),\n\t\t       from_kuid(&init_user_ns, current_uid()),\n\t\t       from_kgid(&init_user_ns, current_gid()),\n\t\t       from_kuid(&init_user_ns, current_euid()),\n\t\t       from_kgid(&init_user_ns, current_egid()),\n\t\t       from_kuid(&init_user_ns, current_suid()),\n\t\t       from_kgid(&init_user_ns, current_sgid()),\n\t\t       from_kuid(&init_user_ns, current_fsuid()),\n\t\t       from_kgid(&init_user_ns, current_fsgid()));\n\tif (!obj)\n\t\tgoto no_obj_info;\n\tif (!obj->validate_done) {\n\t\ttomoyo_get_attributes(obj);\n\t\tobj->validate_done = true;\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_PATH_STAT; i++) {\n\t\tstruct tomoyo_mini_stat *stat;\n\t\tunsigned int dev;\n\t\tumode_t mode;\n\t\tif (!obj->stat_valid[i])\n\t\t\tcontinue;\n\t\tstat = &obj->stat[i];\n\t\tdev = stat->dev;\n\t\tmode = stat->mode;\n\t\tif (i & 1) {\n\t\t\tpos += snprintf(buffer + pos,\n\t\t\t\t\ttomoyo_buffer_len - 1 - pos,\n\t\t\t\t\t\" path%u.parent={ uid=%u gid=%u \"\n\t\t\t\t\t\"ino=%lu perm=0%o }\", (i >> 1) + 1,\n\t\t\t\t\tfrom_kuid(&init_user_ns, stat->uid),\n\t\t\t\t\tfrom_kgid(&init_user_ns, stat->gid),\n\t\t\t\t\t(unsigned long)stat->ino,\n\t\t\t\t\tstat->mode & S_IALLUGO);\n\t\t\tcontinue;\n\t\t}\n\t\tpos += snprintf(buffer + pos, tomoyo_buffer_len - 1 - pos,\n\t\t\t\t\" path%u={ uid=%u gid=%u ino=%lu major=%u\"\n\t\t\t\t\" minor=%u perm=0%o type=%s\", (i >> 1) + 1,\n\t\t\t\tfrom_kuid(&init_user_ns, stat->uid),\n\t\t\t\tfrom_kgid(&init_user_ns, stat->gid),\n\t\t\t\t(unsigned long)stat->ino,\n\t\t\t\tMAJOR(dev), MINOR(dev),\n\t\t\t\tmode & S_IALLUGO, tomoyo_filetype(mode));\n\t\tif (S_ISCHR(mode) || S_ISBLK(mode)) {\n\t\t\tdev = stat->rdev;\n\t\t\tpos += snprintf(buffer + pos,\n\t\t\t\t\ttomoyo_buffer_len - 1 - pos,\n\t\t\t\t\t\" dev_major=%u dev_minor=%u\",\n\t\t\t\t\tMAJOR(dev), MINOR(dev));\n\t\t}\n\t\tpos += snprintf(buffer + pos, tomoyo_buffer_len - 1 - pos,\n\t\t\t\t\" }\");\n\t}\nno_obj_info:\n\tif (pos < tomoyo_buffer_len - 1)\n\t\treturn buffer;\n\tkfree(buffer);\n\treturn NULL;\n}"
  },
  {
    "function_name": "tomoyo_filetype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
    "lines": "116-136",
    "snippet": "static inline const char *tomoyo_filetype(const umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase 0:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_FILE];\n\tcase S_IFDIR:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_DIRECTORY];\n\tcase S_IFLNK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_SYMLINK];\n\tcase S_IFIFO:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_FIFO];\n\tcase S_IFSOCK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_SOCKET];\n\tcase S_IFBLK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_BLOCK_DEV];\n\tcase S_IFCHR:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_CHAR_DEV];\n\t}\n\treturn \"unknown\"; /* This should not happen. */\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic inline const char *tomoyo_filetype(const umode_t mode)\n{\n\tswitch (mode & S_IFMT) {\n\tcase S_IFREG:\n\tcase 0:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_FILE];\n\tcase S_IFDIR:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_DIRECTORY];\n\tcase S_IFLNK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_SYMLINK];\n\tcase S_IFIFO:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_FIFO];\n\tcase S_IFSOCK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_SOCKET];\n\tcase S_IFBLK:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_BLOCK_DEV];\n\tcase S_IFCHR:\n\t\treturn tomoyo_condition_keyword[TOMOYO_TYPE_IS_CHAR_DEV];\n\t}\n\treturn \"unknown\"; /* This should not happen. */\n}"
  },
  {
    "function_name": "tomoyo_print_bprm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
    "lines": "22-107",
    "snippet": "static char *tomoyo_print_bprm(struct linux_binprm *bprm,\n\t\t\t       struct tomoyo_page_dump *dump)\n{\n\tstatic const int tomoyo_buffer_len = 4096 * 2;\n\tchar *buffer = kzalloc(tomoyo_buffer_len, GFP_NOFS);\n\tchar *cp;\n\tchar *last_start;\n\tint len;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tbool truncated = false;\n\tif (!buffer)\n\t\treturn NULL;\n\tlen = snprintf(buffer, tomoyo_buffer_len - 1, \"argv[]={ \");\n\tcp = buffer + len;\n\tif (!argv_count) {\n\t\tmemmove(cp, \"} envp[]={ \", 11);\n\t\tcp += 11;\n\t}\n\tlast_start = cp;\n\twhile (argv_count || envp_count) {\n\t\tif (!tomoyo_dump_page(bprm, pos, dump))\n\t\t\tgoto out;\n\t\tpos += PAGE_SIZE - offset;\n\t\t/* Read. */\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\tconst char *kaddr = dump->data;\n\t\t\tconst unsigned char c = kaddr[offset++];\n\t\t\tif (cp == last_start)\n\t\t\t\t*cp++ = '\"';\n\t\t\tif (cp >= buffer + tomoyo_buffer_len - 32) {\n\t\t\t\t/* Reserve some room for \"...\" string. */\n\t\t\t\ttruncated = true;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t*cp++ = c;\n\t\t\t} else if (!c) {\n\t\t\t\t*cp++ = '\"';\n\t\t\t\t*cp++ = ' ';\n\t\t\t\tlast_start = cp;\n\t\t\t} else {\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t\t*cp++ = (c >> 6) + '0';\n\t\t\t\t*cp++ = ((c >> 3) & 7) + '0';\n\t\t\t\t*cp++ = (c & 7) + '0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\tif (argv_count) {\n\t\t\t\tif (--argv_count == 0) {\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\tcp = last_start;\n\t\t\t\t\t\tmemmove(cp, \"... \", 4);\n\t\t\t\t\t\tcp += 4;\n\t\t\t\t\t}\n\t\t\t\t\tmemmove(cp, \"} envp[]={ \", 11);\n\t\t\t\t\tcp += 11;\n\t\t\t\t\tlast_start = cp;\n\t\t\t\t\ttruncated = false;\n\t\t\t\t}\n\t\t\t} else if (envp_count) {\n\t\t\t\tif (--envp_count == 0) {\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\tcp = last_start;\n\t\t\t\t\t\tmemmove(cp, \"... \", 4);\n\t\t\t\t\t\tcp += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!argv_count && !envp_count)\n\t\t\t\tbreak;\n\t\t}\n\t\toffset = 0;\n\t}\n\t*cp++ = '}';\n\t*cp = '\\0';\n\treturn buffer;\nout:\n\tsnprintf(buffer, tomoyo_buffer_len - 1,\n\t\t \"argv[]={ ... } envp[]= { ... }\");\n\treturn buffer;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "tomoyo_buffer_len - 1",
            "\"argv[]={ ... } envp[]= { ... }\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "cp",
            "\"... \"",
            "4"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "cp",
            "\"} envp[]={ \"",
            "11"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "cp",
            "\"... \"",
            "4"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_dump_page",
          "args": [
            "bprm",
            "pos",
            "dump"
          ],
          "line": 45
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_dump_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "867-911",
          "snippet": "bool tomoyo_dump_page(struct linux_binprm *bprm, unsigned long pos,\n\t\t      struct tomoyo_page_dump *dump)\n{\n\tstruct page *page;\n\n\t/* dump->data is released by tomoyo_find_next_domain(). */\n\tif (!dump->data) {\n\t\tdump->data = kzalloc(PAGE_SIZE, GFP_NOFS);\n\t\tif (!dump->data)\n\t\t\treturn false;\n\t}\n\t/* Same with get_arg_page(bprm, pos, 0) in fs/exec.c */\n#ifdef CONFIG_MMU\n\t/*\n\t * This is called at execve() time in order to dig around\n\t * in the argv/environment of the new proceess\n\t * (represented by bprm).  'current' is the process doing\n\t * the execve().\n\t */\n\tif (get_user_pages_remote(current, bprm->mm, pos, 1,\n\t\t\t\tFOLL_FORCE, &page, NULL, NULL) <= 0)\n\t\treturn false;\n#else\n\tpage = bprm->page[pos / PAGE_SIZE];\n#endif\n\tif (page != dump->page) {\n\t\tconst unsigned int offset = pos % PAGE_SIZE;\n\t\t/*\n\t\t * Maybe kmap()/kunmap() should be used here.\n\t\t * But remove_arg_zero() uses kmap_atomic()/kunmap_atomic().\n\t\t * So do I.\n\t\t */\n\t\tchar *kaddr = kmap_atomic(page);\n\n\t\tdump->page = page;\n\t\tmemcpy(dump->data + offset, kaddr + offset,\n\t\t       PAGE_SIZE - offset);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Same with put_arg_page(page) in fs/exec.c */\n#ifdef CONFIG_MMU\n\tput_page(page);\n#endif\n\treturn true;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nbool tomoyo_dump_page(struct linux_binprm *bprm, unsigned long pos,\n\t\t      struct tomoyo_page_dump *dump)\n{\n\tstruct page *page;\n\n\t/* dump->data is released by tomoyo_find_next_domain(). */\n\tif (!dump->data) {\n\t\tdump->data = kzalloc(PAGE_SIZE, GFP_NOFS);\n\t\tif (!dump->data)\n\t\t\treturn false;\n\t}\n\t/* Same with get_arg_page(bprm, pos, 0) in fs/exec.c */\n#ifdef CONFIG_MMU\n\t/*\n\t * This is called at execve() time in order to dig around\n\t * in the argv/environment of the new proceess\n\t * (represented by bprm).  'current' is the process doing\n\t * the execve().\n\t */\n\tif (get_user_pages_remote(current, bprm->mm, pos, 1,\n\t\t\t\tFOLL_FORCE, &page, NULL, NULL) <= 0)\n\t\treturn false;\n#else\n\tpage = bprm->page[pos / PAGE_SIZE];\n#endif\n\tif (page != dump->page) {\n\t\tconst unsigned int offset = pos % PAGE_SIZE;\n\t\t/*\n\t\t * Maybe kmap()/kunmap() should be used here.\n\t\t * But remove_arg_zero() uses kmap_atomic()/kunmap_atomic().\n\t\t * So do I.\n\t\t */\n\t\tchar *kaddr = kmap_atomic(page);\n\n\t\tdump->page = page;\n\t\tmemcpy(dump->data + offset, kaddr + offset,\n\t\t       PAGE_SIZE - offset);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Same with put_arg_page(page) in fs/exec.c */\n#ifdef CONFIG_MMU\n\tput_page(page);\n#endif\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "cp",
            "\"} envp[]={ \"",
            "11"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "tomoyo_buffer_len - 1",
            "\"argv[]={ \""
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "tomoyo_buffer_len",
            "GFP_NOFS"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic char *tomoyo_print_bprm(struct linux_binprm *bprm,\n\t\t\t       struct tomoyo_page_dump *dump)\n{\n\tstatic const int tomoyo_buffer_len = 4096 * 2;\n\tchar *buffer = kzalloc(tomoyo_buffer_len, GFP_NOFS);\n\tchar *cp;\n\tchar *last_start;\n\tint len;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tbool truncated = false;\n\tif (!buffer)\n\t\treturn NULL;\n\tlen = snprintf(buffer, tomoyo_buffer_len - 1, \"argv[]={ \");\n\tcp = buffer + len;\n\tif (!argv_count) {\n\t\tmemmove(cp, \"} envp[]={ \", 11);\n\t\tcp += 11;\n\t}\n\tlast_start = cp;\n\twhile (argv_count || envp_count) {\n\t\tif (!tomoyo_dump_page(bprm, pos, dump))\n\t\t\tgoto out;\n\t\tpos += PAGE_SIZE - offset;\n\t\t/* Read. */\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\tconst char *kaddr = dump->data;\n\t\t\tconst unsigned char c = kaddr[offset++];\n\t\t\tif (cp == last_start)\n\t\t\t\t*cp++ = '\"';\n\t\t\tif (cp >= buffer + tomoyo_buffer_len - 32) {\n\t\t\t\t/* Reserve some room for \"...\" string. */\n\t\t\t\ttruncated = true;\n\t\t\t} else if (c == '\\\\') {\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t*cp++ = c;\n\t\t\t} else if (!c) {\n\t\t\t\t*cp++ = '\"';\n\t\t\t\t*cp++ = ' ';\n\t\t\t\tlast_start = cp;\n\t\t\t} else {\n\t\t\t\t*cp++ = '\\\\';\n\t\t\t\t*cp++ = (c >> 6) + '0';\n\t\t\t\t*cp++ = ((c >> 3) & 7) + '0';\n\t\t\t\t*cp++ = (c & 7) + '0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\tif (argv_count) {\n\t\t\t\tif (--argv_count == 0) {\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\tcp = last_start;\n\t\t\t\t\t\tmemmove(cp, \"... \", 4);\n\t\t\t\t\t\tcp += 4;\n\t\t\t\t\t}\n\t\t\t\t\tmemmove(cp, \"} envp[]={ \", 11);\n\t\t\t\t\tcp += 11;\n\t\t\t\t\tlast_start = cp;\n\t\t\t\t\ttruncated = false;\n\t\t\t\t}\n\t\t\t} else if (envp_count) {\n\t\t\t\tif (--envp_count == 0) {\n\t\t\t\t\tif (truncated) {\n\t\t\t\t\t\tcp = last_start;\n\t\t\t\t\t\tmemmove(cp, \"... \", 4);\n\t\t\t\t\t\tcp += 4;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!argv_count && !envp_count)\n\t\t\t\tbreak;\n\t\t}\n\t\toffset = 0;\n\t}\n\t*cp++ = '}';\n\t*cp = '\\0';\n\treturn buffer;\nout:\n\tsnprintf(buffer, tomoyo_buffer_len - 1,\n\t\t \"argv[]={ ... } envp[]= { ... }\");\n\treturn buffer;\n}"
  }
]