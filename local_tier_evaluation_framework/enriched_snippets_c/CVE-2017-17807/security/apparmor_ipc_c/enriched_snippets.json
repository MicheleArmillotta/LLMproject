[
  {
    "function_name": "aa_may_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
    "lines": "215-222",
    "snippet": "int aa_may_signal(struct aa_label *sender, struct aa_label *target, int sig)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SIGNAL);\n\n\taad(&sa)->signal = map_signal_num(sig);\n\treturn xcheck_labels_profiles(sender, target, aa_signal_cross_perm,\n\t\t\t\t      &sa);\n}",
    "includes": [
      "#include \"include/sig_names.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/ptrace.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xcheck_labels_profiles",
          "args": [
            "sender",
            "target",
            "aa_signal_cross_perm",
            "&sa"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_signal_num",
          "args": [
            "sig"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "map_signal_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
          "lines": "125-134",
          "snippet": "static inline int map_signal_num(int sig)\n{\n\tif (sig > SIGRTMAX)\n\t\treturn SIGUNKNOWN;\n\telse if (sig >= SIGRTMIN)\n\t\treturn sig - SIGRTMIN + 128;\t/* rt sigs mapped to 128 */\n\telse if (sig < MAXMAPPED_SIG)\n\t\treturn sig_map[sig];\n\treturn SIGUNKNOWN;\n}",
          "includes": [
            "#include \"include/sig_names.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic inline int map_signal_num(int sig)\n{\n\tif (sig > SIGRTMAX)\n\t\treturn SIGUNKNOWN;\n\telse if (sig >= SIGRTMIN)\n\t\treturn sig - SIGRTMIN + 128;\t/* rt sigs mapped to 128 */\n\telse if (sig < MAXMAPPED_SIG)\n\t\treturn sig_map[sig];\n\treturn SIGUNKNOWN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_AUDIT_DATA",
          "args": [
            "sa",
            "LSM_AUDIT_DATA_NONE",
            "OP_SIGNAL"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nint aa_may_signal(struct aa_label *sender, struct aa_label *target, int sig)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SIGNAL);\n\n\taad(&sa)->signal = map_signal_num(sig);\n\treturn xcheck_labels_profiles(sender, target, aa_signal_cross_perm,\n\t\t\t\t      &sa);\n}"
  },
  {
    "function_name": "aa_signal_cross_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
    "lines": "207-213",
    "snippet": "static int aa_signal_cross_perm(struct aa_profile *sender,\n\t\t\t\tstruct aa_profile *target,\n\t\t\t\tstruct common_audit_data *sa)\n{\n\treturn xcheck(profile_signal_perm(sender, target, MAY_WRITE, sa),\n\t\t      profile_signal_perm(target, sender, MAY_READ, sa));\n}",
    "includes": [
      "#include \"include/sig_names.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/ptrace.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xcheck",
          "args": [
            "profile_signal_perm(sender, target, MAY_WRITE, sa)",
            "profile_signal_perm(target, sender, MAY_READ, sa)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_signal_perm",
          "args": [
            "target",
            "sender",
            "MAY_READ",
            "sa"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "profile_signal_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
          "lines": "190-205",
          "snippet": "static int profile_signal_perm(struct aa_profile *profile,\n\t\t\t       struct aa_profile *peer, u32 request,\n\t\t\t       struct common_audit_data *sa)\n{\n\tstruct aa_perms perms;\n\n\tif (profile_unconfined(profile) ||\n\t    !PROFILE_MEDIATES(profile, AA_CLASS_SIGNAL))\n\t\treturn 0;\n\n\taad(sa)->peer = &peer->label;\n\tprofile_match_signal(profile, peer->base.hname, aad(sa)->signal,\n\t\t\t     &perms);\n\taa_apply_modes_to_perms(profile, &perms);\n\treturn aa_check_perms(profile, &perms, request, sa, audit_signal_cb);\n}",
          "includes": [
            "#include \"include/sig_names.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic int profile_signal_perm(struct aa_profile *profile,\n\t\t\t       struct aa_profile *peer, u32 request,\n\t\t\t       struct common_audit_data *sa)\n{\n\tstruct aa_perms perms;\n\n\tif (profile_unconfined(profile) ||\n\t    !PROFILE_MEDIATES(profile, AA_CLASS_SIGNAL))\n\t\treturn 0;\n\n\taad(sa)->peer = &peer->label;\n\tprofile_match_signal(profile, peer->base.hname, aad(sa)->signal,\n\t\t\t     &perms);\n\taa_apply_modes_to_perms(profile, &perms);\n\treturn aa_check_perms(profile, &perms, request, sa, audit_signal_cb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic int aa_signal_cross_perm(struct aa_profile *sender,\n\t\t\t\tstruct aa_profile *target,\n\t\t\t\tstruct common_audit_data *sa)\n{\n\treturn xcheck(profile_signal_perm(sender, target, MAY_WRITE, sa),\n\t\t      profile_signal_perm(target, sender, MAY_READ, sa));\n}"
  },
  {
    "function_name": "profile_signal_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
    "lines": "190-205",
    "snippet": "static int profile_signal_perm(struct aa_profile *profile,\n\t\t\t       struct aa_profile *peer, u32 request,\n\t\t\t       struct common_audit_data *sa)\n{\n\tstruct aa_perms perms;\n\n\tif (profile_unconfined(profile) ||\n\t    !PROFILE_MEDIATES(profile, AA_CLASS_SIGNAL))\n\t\treturn 0;\n\n\taad(sa)->peer = &peer->label;\n\tprofile_match_signal(profile, peer->base.hname, aad(sa)->signal,\n\t\t\t     &perms);\n\taa_apply_modes_to_perms(profile, &perms);\n\treturn aa_check_perms(profile, &perms, request, sa, audit_signal_cb);\n}",
    "includes": [
      "#include \"include/sig_names.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/ptrace.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_check_perms",
          "args": [
            "profile",
            "&perms",
            "request",
            "sa",
            "audit_signal_cb"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "aa_check_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "421-466",
          "snippet": "int aa_check_perms(struct aa_profile *profile, struct aa_perms *perms,\n\t\t   u32 request, struct common_audit_data *sa,\n\t\t   void (*cb)(struct audit_buffer *, void *))\n{\n\tint type, error;\n\tu32 denied = request & (~perms->allow | perms->deny);\n\n\tif (likely(!denied)) {\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= perms->audit;\n\t\tif (!request || !sa)\n\t\t\treturn 0;\n\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\terror = 0;\n\t} else {\n\t\terror = -EACCES;\n\n\t\tif (denied & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\t\telse if (denied == (denied & perms->complain))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\n\t\tif (denied == (denied & perms->hide))\n\t\t\terror = -ENOENT;\n\n\t\tdenied &= ~perms->quiet;\n\t\tif (!sa || !denied)\n\t\t\treturn error;\n\t}\n\n\tif (sa) {\n\t\taad(sa)->label = &profile->label;\n\t\taad(sa)->request = request;\n\t\taad(sa)->denied = denied;\n\t\taad(sa)->error = error;\n\t\taa_audit_msg(type, sa, cb);\n\t}\n\n\tif (type == AUDIT_APPARMOR_ALLOWED)\n\t\terror = 0;\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nint aa_check_perms(struct aa_profile *profile, struct aa_perms *perms,\n\t\t   u32 request, struct common_audit_data *sa,\n\t\t   void (*cb)(struct audit_buffer *, void *))\n{\n\tint type, error;\n\tu32 denied = request & (~perms->allow | perms->deny);\n\n\tif (likely(!denied)) {\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= perms->audit;\n\t\tif (!request || !sa)\n\t\t\treturn 0;\n\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\terror = 0;\n\t} else {\n\t\terror = -EACCES;\n\n\t\tif (denied & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\t\telse if (denied == (denied & perms->complain))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\n\t\tif (denied == (denied & perms->hide))\n\t\t\terror = -ENOENT;\n\n\t\tdenied &= ~perms->quiet;\n\t\tif (!sa || !denied)\n\t\t\treturn error;\n\t}\n\n\tif (sa) {\n\t\taad(sa)->label = &profile->label;\n\t\taad(sa)->request = request;\n\t\taad(sa)->denied = denied;\n\t\taad(sa)->error = error;\n\t\taa_audit_msg(type, sa, cb);\n\t}\n\n\tif (type == AUDIT_APPARMOR_ALLOWED)\n\t\terror = 0;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_apply_modes_to_perms",
          "args": [
            "profile",
            "&perms"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "aa_apply_modes_to_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "282-308",
          "snippet": "void aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_match_signal",
          "args": [
            "profile",
            "peer->base.hname",
            "aad(sa)->signal",
            "&perms"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "profile_match_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
          "lines": "177-188",
          "snippet": "static void profile_match_signal(struct aa_profile *profile, const char *label,\n\t\t\t\t int signal, struct aa_perms *perms)\n{\n\tunsigned int state;\n\n\t/* TODO: secondary cache check <profile, profile, perm> */\n\tstate = aa_dfa_next(profile->policy.dfa,\n\t\t\t    profile->policy.start[AA_CLASS_SIGNAL],\n\t\t\t    signal);\n\tstate = aa_dfa_match(profile->policy.dfa, state, label);\n\taa_compute_perms(profile->policy.dfa, state, perms);\n}",
          "includes": [
            "#include \"include/sig_names.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic void profile_match_signal(struct aa_profile *profile, const char *label,\n\t\t\t\t int signal, struct aa_perms *perms)\n{\n\tunsigned int state;\n\n\t/* TODO: secondary cache check <profile, profile, perm> */\n\tstate = aa_dfa_next(profile->policy.dfa,\n\t\t\t    profile->policy.start[AA_CLASS_SIGNAL],\n\t\t\t    signal);\n\tstate = aa_dfa_match(profile->policy.dfa, state, label);\n\taa_compute_perms(profile->policy.dfa, state, perms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROFILE_MEDIATES",
          "args": [
            "profile",
            "AA_CLASS_SIGNAL"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "PROFILE_MEDIATES_SAFE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "214-221",
          "snippet": "static inline unsigned int PROFILE_MEDIATES_SAFE(struct aa_profile *profile,\n\t\t\t\t\t\t unsigned char class)\n{\n\tif (profile->policy.dfa)\n\t\treturn aa_dfa_match_len(profile->policy.dfa,\n\t\t\t\t\tprofile->policy.start[0], &class, 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline unsigned int PROFILE_MEDIATES_SAFE(struct aa_profile *profile,\n\t\t\t\t\t\t unsigned char class)\n{\n\tif (profile->policy.dfa)\n\t\treturn aa_dfa_match_len(profile->policy.dfa,\n\t\t\t\t\tprofile->policy.start[0], &class, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic int profile_signal_perm(struct aa_profile *profile,\n\t\t\t       struct aa_profile *peer, u32 request,\n\t\t\t       struct common_audit_data *sa)\n{\n\tstruct aa_perms perms;\n\n\tif (profile_unconfined(profile) ||\n\t    !PROFILE_MEDIATES(profile, AA_CLASS_SIGNAL))\n\t\treturn 0;\n\n\taad(sa)->peer = &peer->label;\n\tprofile_match_signal(profile, peer->base.hname, aad(sa)->signal,\n\t\t\t     &perms);\n\taa_apply_modes_to_perms(profile, &perms);\n\treturn aa_check_perms(profile, &perms, request, sa, audit_signal_cb);\n}"
  },
  {
    "function_name": "profile_match_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
    "lines": "177-188",
    "snippet": "static void profile_match_signal(struct aa_profile *profile, const char *label,\n\t\t\t\t int signal, struct aa_perms *perms)\n{\n\tunsigned int state;\n\n\t/* TODO: secondary cache check <profile, profile, perm> */\n\tstate = aa_dfa_next(profile->policy.dfa,\n\t\t\t    profile->policy.start[AA_CLASS_SIGNAL],\n\t\t\t    signal);\n\tstate = aa_dfa_match(profile->policy.dfa, state, label);\n\taa_compute_perms(profile->policy.dfa, state, perms);\n}",
    "includes": [
      "#include \"include/sig_names.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/ptrace.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_compute_perms",
          "args": [
            "profile->policy.dfa",
            "state",
            "perms"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "aa_compute_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "317-333",
          "snippet": "void aa_compute_perms(struct aa_dfa *dfa, unsigned int state,\n\t\t      struct aa_perms *perms)\n{\n\t*perms = (struct aa_perms) {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t};\n\n\t/* for v5 perm mapping in the policydb, the other set is used\n\t * to extend the general perm set\n\t */\n\tperms->allow |= map_other(dfa_other_allow(dfa, state));\n\tperms->audit |= map_other(dfa_other_audit(dfa, state));\n\tperms->quiet |= map_other(dfa_other_quiet(dfa, state));\n//\tperms->xindex = dfa_user_xindex(dfa, state);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_compute_perms(struct aa_dfa *dfa, unsigned int state,\n\t\t      struct aa_perms *perms)\n{\n\t*perms = (struct aa_perms) {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t};\n\n\t/* for v5 perm mapping in the policydb, the other set is used\n\t * to extend the general perm set\n\t */\n\tperms->allow |= map_other(dfa_other_allow(dfa, state));\n\tperms->audit |= map_other(dfa_other_audit(dfa, state));\n\tperms->quiet |= map_other(dfa_other_quiet(dfa, state));\n//\tperms->xindex = dfa_user_xindex(dfa, state);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_match",
          "args": [
            "profile->policy.dfa",
            "state",
            "label"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "381-417",
          "snippet": "unsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_next",
          "args": [
            "profile->policy.dfa",
            "profile->policy.start[AA_CLASS_SIGNAL]",
            "signal"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "429-459",
          "snippet": "unsigned int aa_dfa_next(struct aa_dfa *dfa, unsigned int state,\n\t\t\t  const char c)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int pos;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\n\t\tpos = base_idx(base[state]) + equiv[(u8) c];\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t} else {\n\t\t/* default is direct to next state */\n\t\tpos = base_idx(base[state]) + (u8) c;\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_next(struct aa_dfa *dfa, unsigned int state,\n\t\t\t  const char c)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int pos;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\n\t\tpos = base_idx(base[state]) + equiv[(u8) c];\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t} else {\n\t\t/* default is direct to next state */\n\t\tpos = base_idx(base[state]) + (u8) c;\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t}\n\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic void profile_match_signal(struct aa_profile *profile, const char *label,\n\t\t\t\t int signal, struct aa_perms *perms)\n{\n\tunsigned int state;\n\n\t/* TODO: secondary cache check <profile, profile, perm> */\n\tstate = aa_dfa_next(profile->policy.dfa,\n\t\t\t    profile->policy.start[AA_CLASS_SIGNAL],\n\t\t\t    signal);\n\tstate = aa_dfa_match(profile->policy.dfa, state, label);\n\taa_compute_perms(profile->policy.dfa, state, perms);\n}"
  },
  {
    "function_name": "audit_signal_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
    "lines": "154-174",
    "snippet": "static void audit_signal_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\tif (aad(sa)->request & AA_SIGNAL_PERM_MASK) {\n\t\taudit_log_format(ab, \" requested_mask=\");\n\t\taudit_signal_mask(ab, aad(sa)->request);\n\t\tif (aad(sa)->denied & AA_SIGNAL_PERM_MASK) {\n\t\t\taudit_log_format(ab, \" denied_mask=\");\n\t\t\taudit_signal_mask(ab, aad(sa)->denied);\n\t\t}\n\t}\n\tif (aad(sa)->signal < MAXMAPPED_SIG)\n\t\taudit_log_format(ab, \" signal=%s\", sig_names[aad(sa)->signal]);\n\telse\n\t\taudit_log_format(ab, \" signal=rtmin+%d\",\n\t\t\t\t aad(sa)->signal - 128);\n\taudit_log_format(ab, \" peer=\");\n\taa_label_xaudit(ab, labels_ns(aad(sa)->label), aad(sa)->peer,\n\t\t\tFLAGS_NONE, GFP_ATOMIC);\n}",
    "includes": [
      "#include \"include/sig_names.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/ptrace.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_label_xaudit",
          "args": [
            "ab",
            "labels_ns(aad(sa)->label)",
            "aad(sa)->peer",
            "FLAGS_NONE",
            "GFP_ATOMIC"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1710-1738",
          "snippet": "void aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "aad(sa)->label"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" peer=\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" signal=rtmin+%d\"",
            "aad(sa)->signal - 128"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" signal=%s\"",
            "sig_names[aad(sa)->signal]"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_signal_mask",
          "args": [
            "ab",
            "aad(sa)->denied"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "audit_signal_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
          "lines": "141-147",
          "snippet": "static void audit_signal_mask(struct audit_buffer *ab, u32 mask)\n{\n\tif (mask & MAY_READ)\n\t\taudit_log_string(ab, \"receive\");\n\tif (mask & MAY_WRITE)\n\t\taudit_log_string(ab, \"send\");\n}",
          "includes": [
            "#include \"include/sig_names.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic void audit_signal_mask(struct audit_buffer *ab, u32 mask)\n{\n\tif (mask & MAY_READ)\n\t\taudit_log_string(ab, \"receive\");\n\tif (mask & MAY_WRITE)\n\t\taudit_log_string(ab, \"send\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" denied_mask=\""
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" requested_mask=\""
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic void audit_signal_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\tif (aad(sa)->request & AA_SIGNAL_PERM_MASK) {\n\t\taudit_log_format(ab, \" requested_mask=\");\n\t\taudit_signal_mask(ab, aad(sa)->request);\n\t\tif (aad(sa)->denied & AA_SIGNAL_PERM_MASK) {\n\t\t\taudit_log_format(ab, \" denied_mask=\");\n\t\t\taudit_signal_mask(ab, aad(sa)->denied);\n\t\t}\n\t}\n\tif (aad(sa)->signal < MAXMAPPED_SIG)\n\t\taudit_log_format(ab, \" signal=%s\", sig_names[aad(sa)->signal]);\n\telse\n\t\taudit_log_format(ab, \" signal=rtmin+%d\",\n\t\t\t\t aad(sa)->signal - 128);\n\taudit_log_format(ab, \" peer=\");\n\taa_label_xaudit(ab, labels_ns(aad(sa)->label), aad(sa)->peer,\n\t\t\tFLAGS_NONE, GFP_ATOMIC);\n}"
  },
  {
    "function_name": "audit_signal_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
    "lines": "141-147",
    "snippet": "static void audit_signal_mask(struct audit_buffer *ab, u32 mask)\n{\n\tif (mask & MAY_READ)\n\t\taudit_log_string(ab, \"receive\");\n\tif (mask & MAY_WRITE)\n\t\taudit_log_string(ab, \"send\");\n}",
    "includes": [
      "#include \"include/sig_names.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/ptrace.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_string",
          "args": [
            "ab",
            "\"send\""
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_string",
          "args": [
            "ab",
            "\"receive\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic void audit_signal_mask(struct audit_buffer *ab, u32 mask)\n{\n\tif (mask & MAY_READ)\n\t\taudit_log_string(ab, \"receive\");\n\tif (mask & MAY_WRITE)\n\t\taudit_log_string(ab, \"send\");\n}"
  },
  {
    "function_name": "map_signal_num",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
    "lines": "125-134",
    "snippet": "static inline int map_signal_num(int sig)\n{\n\tif (sig > SIGRTMAX)\n\t\treturn SIGUNKNOWN;\n\telse if (sig >= SIGRTMIN)\n\t\treturn sig - SIGRTMIN + 128;\t/* rt sigs mapped to 128 */\n\telse if (sig < MAXMAPPED_SIG)\n\t\treturn sig_map[sig];\n\treturn SIGUNKNOWN;\n}",
    "includes": [
      "#include \"include/sig_names.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/ptrace.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic inline int map_signal_num(int sig)\n{\n\tif (sig > SIGRTMAX)\n\t\treturn SIGUNKNOWN;\n\telse if (sig >= SIGRTMIN)\n\t\treturn sig - SIGRTMIN + 128;\t/* rt sigs mapped to 128 */\n\telse if (sig < MAXMAPPED_SIG)\n\t\treturn sig_map[sig];\n\treturn SIGUNKNOWN;\n}"
  },
  {
    "function_name": "aa_may_ptrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
    "lines": "115-122",
    "snippet": "int aa_may_ptrace(struct aa_label *tracer, struct aa_label *tracee,\n\t\t  u32 request)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_PTRACE);\n\n\treturn xcheck_labels_profiles(tracer, tracee, cross_ptrace_perm,\n\t\t\t\t      request, &sa);\n}",
    "includes": [
      "#include \"include/sig_names.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/ptrace.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xcheck_labels_profiles",
          "args": [
            "tracer",
            "tracee",
            "cross_ptrace_perm",
            "request",
            "&sa"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_AUDIT_DATA",
          "args": [
            "sa",
            "LSM_AUDIT_DATA_NONE",
            "OP_PTRACE"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nint aa_may_ptrace(struct aa_label *tracer, struct aa_label *tracee,\n\t\t  u32 request)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_PTRACE);\n\n\treturn xcheck_labels_profiles(tracer, tracee, cross_ptrace_perm,\n\t\t\t\t      request, &sa);\n}"
  },
  {
    "function_name": "cross_ptrace_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
    "lines": "86-105",
    "snippet": "static int cross_ptrace_perm(struct aa_profile *tracer,\n\t\t\t     struct aa_profile *tracee, u32 request,\n\t\t\t     struct common_audit_data *sa)\n{\n\tif (PROFILE_MEDIATES(tracer, AA_CLASS_PTRACE))\n\t\treturn xcheck(profile_ptrace_perm(tracer, tracee, request, sa),\n\t\t\t      profile_ptrace_perm(tracee, tracer,\n\t\t\t\t\t\t  request << PTRACE_PERM_SHIFT,\n\t\t\t\t\t\t  sa));\n\t/* policy uses the old style capability check for ptrace */\n\tif (profile_unconfined(tracer) || tracer == tracee)\n\t\treturn 0;\n\n\taad(sa)->label = &tracer->label;\n\taad(sa)->peer = &tracee->label;\n\taad(sa)->request = 0;\n\taad(sa)->error = aa_capable(&tracer->label, CAP_SYS_PTRACE, 1);\n\n\treturn aa_audit(AUDIT_APPARMOR_AUTO, tracer, sa, audit_ptrace_cb);\n}",
    "includes": [
      "#include \"include/sig_names.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/ptrace.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_audit",
          "args": [
            "AUDIT_APPARMOR_AUTO",
            "tracer",
            "sa",
            "audit_ptrace_cb"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/audit.c",
          "lines": "129-165",
          "snippet": "int aa_audit(int type, struct aa_profile *profile, struct common_audit_data *sa,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!aad(sa)->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET))\n\t\treturn aad(sa)->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\taad(sa)->label = &profile->label;\n\n\taa_audit_msg(type, sa, cb);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tsa->type == LSM_AUDIT_DATA_TASK && sa->u.tsk ?\n\t\t\t\t    sa->u.tsk : current);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(aad(sa)->error);\n\n\treturn aad(sa)->error;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/socket.h>\n#include <linux/audit.h>\n\nint aa_audit(int type, struct aa_profile *profile, struct common_audit_data *sa,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!aad(sa)->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET))\n\t\treturn aad(sa)->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\taad(sa)->label = &profile->label;\n\n\taa_audit_msg(type, sa, cb);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tsa->type == LSM_AUDIT_DATA_TASK && sa->u.tsk ?\n\t\t\t\t    sa->u.tsk : current);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(aad(sa)->error);\n\n\treturn aad(sa)->error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_capable",
          "args": [
            "&tracer->label",
            "CAP_SYS_PTRACE",
            "1"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "aa_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/capability.c",
          "lines": "151-162",
          "snippet": "int aa_capable(struct aa_label *label, int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_CAP, OP_CAPABLE);\n\n\tsa.u.cap = cap;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_capable(profile, cap, audit, &sa));\n\n\treturn error;\n}",
          "includes": [
            "#include \"capability_names.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/security.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability_names.h\"\n#include \"include/audit.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/security.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nint aa_capable(struct aa_label *label, int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_CAP, OP_CAPABLE);\n\n\tsa.u.cap = cap;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_capable(profile, cap, audit, &sa));\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "tracer"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcheck",
          "args": [
            "profile_ptrace_perm(tracer, tracee, request, sa)",
            "profile_ptrace_perm(tracee, tracer,\n\t\t\t\t\t\t  request << PTRACE_PERM_SHIFT,\n\t\t\t\t\t\t  sa)"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_ptrace_perm",
          "args": [
            "tracee",
            "tracer",
            "request << PTRACE_PERM_SHIFT",
            "sa"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "profile_ptrace_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
          "lines": "68-84",
          "snippet": "static int profile_ptrace_perm(struct aa_profile *profile,\n\t\t\t       struct aa_profile *peer, u32 request,\n\t\t\t       struct common_audit_data *sa)\n{\n\tstruct aa_perms perms = { };\n\n\t/* need because of peer in cross check */\n\tif (profile_unconfined(profile) ||\n\t    !PROFILE_MEDIATES(profile, AA_CLASS_PTRACE))\n\t\treturn 0;\n\n\taad(sa)->peer = &peer->label;\n\taa_profile_match_label(profile, &peer->label, AA_CLASS_PTRACE, request,\n\t\t\t       &perms);\n\taa_apply_modes_to_perms(profile, &perms);\n\treturn aa_check_perms(profile, &perms, request, sa, audit_ptrace_cb);\n}",
          "includes": [
            "#include \"include/sig_names.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic int profile_ptrace_perm(struct aa_profile *profile,\n\t\t\t       struct aa_profile *peer, u32 request,\n\t\t\t       struct common_audit_data *sa)\n{\n\tstruct aa_perms perms = { };\n\n\t/* need because of peer in cross check */\n\tif (profile_unconfined(profile) ||\n\t    !PROFILE_MEDIATES(profile, AA_CLASS_PTRACE))\n\t\treturn 0;\n\n\taad(sa)->peer = &peer->label;\n\taa_profile_match_label(profile, &peer->label, AA_CLASS_PTRACE, request,\n\t\t\t       &perms);\n\taa_apply_modes_to_perms(profile, &perms);\n\treturn aa_check_perms(profile, &perms, request, sa, audit_ptrace_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PROFILE_MEDIATES",
          "args": [
            "tracer",
            "AA_CLASS_PTRACE"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "PROFILE_MEDIATES_SAFE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "214-221",
          "snippet": "static inline unsigned int PROFILE_MEDIATES_SAFE(struct aa_profile *profile,\n\t\t\t\t\t\t unsigned char class)\n{\n\tif (profile->policy.dfa)\n\t\treturn aa_dfa_match_len(profile->policy.dfa,\n\t\t\t\t\tprofile->policy.start[0], &class, 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline unsigned int PROFILE_MEDIATES_SAFE(struct aa_profile *profile,\n\t\t\t\t\t\t unsigned char class)\n{\n\tif (profile->policy.dfa)\n\t\treturn aa_dfa_match_len(profile->policy.dfa,\n\t\t\t\t\tprofile->policy.start[0], &class, 1);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic int cross_ptrace_perm(struct aa_profile *tracer,\n\t\t\t     struct aa_profile *tracee, u32 request,\n\t\t\t     struct common_audit_data *sa)\n{\n\tif (PROFILE_MEDIATES(tracer, AA_CLASS_PTRACE))\n\t\treturn xcheck(profile_ptrace_perm(tracer, tracee, request, sa),\n\t\t\t      profile_ptrace_perm(tracee, tracer,\n\t\t\t\t\t\t  request << PTRACE_PERM_SHIFT,\n\t\t\t\t\t\t  sa));\n\t/* policy uses the old style capability check for ptrace */\n\tif (profile_unconfined(tracer) || tracer == tracee)\n\t\treturn 0;\n\n\taad(sa)->label = &tracer->label;\n\taad(sa)->peer = &tracee->label;\n\taad(sa)->request = 0;\n\taad(sa)->error = aa_capable(&tracer->label, CAP_SYS_PTRACE, 1);\n\n\treturn aa_audit(AUDIT_APPARMOR_AUTO, tracer, sa, audit_ptrace_cb);\n}"
  },
  {
    "function_name": "profile_ptrace_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
    "lines": "68-84",
    "snippet": "static int profile_ptrace_perm(struct aa_profile *profile,\n\t\t\t       struct aa_profile *peer, u32 request,\n\t\t\t       struct common_audit_data *sa)\n{\n\tstruct aa_perms perms = { };\n\n\t/* need because of peer in cross check */\n\tif (profile_unconfined(profile) ||\n\t    !PROFILE_MEDIATES(profile, AA_CLASS_PTRACE))\n\t\treturn 0;\n\n\taad(sa)->peer = &peer->label;\n\taa_profile_match_label(profile, &peer->label, AA_CLASS_PTRACE, request,\n\t\t\t       &perms);\n\taa_apply_modes_to_perms(profile, &perms);\n\treturn aa_check_perms(profile, &perms, request, sa, audit_ptrace_cb);\n}",
    "includes": [
      "#include \"include/sig_names.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/ptrace.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_check_perms",
          "args": [
            "profile",
            "&perms",
            "request",
            "sa",
            "audit_ptrace_cb"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "aa_check_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "421-466",
          "snippet": "int aa_check_perms(struct aa_profile *profile, struct aa_perms *perms,\n\t\t   u32 request, struct common_audit_data *sa,\n\t\t   void (*cb)(struct audit_buffer *, void *))\n{\n\tint type, error;\n\tu32 denied = request & (~perms->allow | perms->deny);\n\n\tif (likely(!denied)) {\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= perms->audit;\n\t\tif (!request || !sa)\n\t\t\treturn 0;\n\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\terror = 0;\n\t} else {\n\t\terror = -EACCES;\n\n\t\tif (denied & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\t\telse if (denied == (denied & perms->complain))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\n\t\tif (denied == (denied & perms->hide))\n\t\t\terror = -ENOENT;\n\n\t\tdenied &= ~perms->quiet;\n\t\tif (!sa || !denied)\n\t\t\treturn error;\n\t}\n\n\tif (sa) {\n\t\taad(sa)->label = &profile->label;\n\t\taad(sa)->request = request;\n\t\taad(sa)->denied = denied;\n\t\taad(sa)->error = error;\n\t\taa_audit_msg(type, sa, cb);\n\t}\n\n\tif (type == AUDIT_APPARMOR_ALLOWED)\n\t\terror = 0;\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nint aa_check_perms(struct aa_profile *profile, struct aa_perms *perms,\n\t\t   u32 request, struct common_audit_data *sa,\n\t\t   void (*cb)(struct audit_buffer *, void *))\n{\n\tint type, error;\n\tu32 denied = request & (~perms->allow | perms->deny);\n\n\tif (likely(!denied)) {\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= perms->audit;\n\t\tif (!request || !sa)\n\t\t\treturn 0;\n\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\terror = 0;\n\t} else {\n\t\terror = -EACCES;\n\n\t\tif (denied & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\t\telse if (denied == (denied & perms->complain))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\n\t\tif (denied == (denied & perms->hide))\n\t\t\terror = -ENOENT;\n\n\t\tdenied &= ~perms->quiet;\n\t\tif (!sa || !denied)\n\t\t\treturn error;\n\t}\n\n\tif (sa) {\n\t\taad(sa)->label = &profile->label;\n\t\taad(sa)->request = request;\n\t\taad(sa)->denied = denied;\n\t\taad(sa)->error = error;\n\t\taa_audit_msg(type, sa, cb);\n\t}\n\n\tif (type == AUDIT_APPARMOR_ALLOWED)\n\t\terror = 0;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_apply_modes_to_perms",
          "args": [
            "profile",
            "&perms"
          ],
          "line": 82
        },
        "resolved": true,
        "details": {
          "function_name": "aa_apply_modes_to_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "282-308",
          "snippet": "void aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_apply_modes_to_perms(struct aa_profile *profile, struct aa_perms *perms)\n{\n\tswitch (AUDIT_MODE(profile)) {\n\tcase AUDIT_ALL:\n\t\tperms->audit = ALL_PERMS_MASK;\n\t\t/* fall through */\n\tcase AUDIT_NOQUIET:\n\t\tperms->quiet = 0;\n\t\tbreak;\n\tcase AUDIT_QUIET:\n\t\tperms->audit = 0;\n\t\t/* fall through */\n\tcase AUDIT_QUIET_DENIED:\n\t\tperms->quiet = ALL_PERMS_MASK;\n\t\tbreak;\n\t}\n\n\tif (KILL_MODE(profile))\n\t\tperms->kill = ALL_PERMS_MASK;\n\telse if (COMPLAIN_MODE(profile))\n\t\tperms->complain = ALL_PERMS_MASK;\n/*\n *  TODO:\n *\telse if (PROMPT_MODE(profile))\n *\t\tperms->prompt = ALL_PERMS_MASK;\n */\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_profile_match_label",
          "args": [
            "profile",
            "&peer->label",
            "AA_CLASS_PTRACE",
            "request",
            "&perms"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "aa_profile_match_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "373-383",
          "snippet": "void aa_profile_match_label(struct aa_profile *profile, struct aa_label *label,\n\t\t\t    int type, u32 request, struct aa_perms *perms)\n{\n\t/* TODO: doesn't yet handle extended types */\n\tunsigned int state;\n\n\tstate = aa_dfa_next(profile->policy.dfa,\n\t\t\t    profile->policy.start[AA_CLASS_LABEL],\n\t\t\t    type);\n\taa_label_match(profile, label, state, false, request, perms);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_profile_match_label(struct aa_profile *profile, struct aa_label *label,\n\t\t\t    int type, u32 request, struct aa_perms *perms)\n{\n\t/* TODO: doesn't yet handle extended types */\n\tunsigned int state;\n\n\tstate = aa_dfa_next(profile->policy.dfa,\n\t\t\t    profile->policy.start[AA_CLASS_LABEL],\n\t\t\t    type);\n\taa_label_match(profile, label, state, false, request, perms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PROFILE_MEDIATES",
          "args": [
            "profile",
            "AA_CLASS_PTRACE"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "PROFILE_MEDIATES_SAFE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "214-221",
          "snippet": "static inline unsigned int PROFILE_MEDIATES_SAFE(struct aa_profile *profile,\n\t\t\t\t\t\t unsigned char class)\n{\n\tif (profile->policy.dfa)\n\t\treturn aa_dfa_match_len(profile->policy.dfa,\n\t\t\t\t\tprofile->policy.start[0], &class, 1);\n\treturn 0;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline unsigned int PROFILE_MEDIATES_SAFE(struct aa_profile *profile,\n\t\t\t\t\t\t unsigned char class)\n{\n\tif (profile->policy.dfa)\n\t\treturn aa_dfa_match_len(profile->policy.dfa,\n\t\t\t\t\tprofile->policy.start[0], &class, 1);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic int profile_ptrace_perm(struct aa_profile *profile,\n\t\t\t       struct aa_profile *peer, u32 request,\n\t\t\t       struct common_audit_data *sa)\n{\n\tstruct aa_perms perms = { };\n\n\t/* need because of peer in cross check */\n\tif (profile_unconfined(profile) ||\n\t    !PROFILE_MEDIATES(profile, AA_CLASS_PTRACE))\n\t\treturn 0;\n\n\taad(sa)->peer = &peer->label;\n\taa_profile_match_label(profile, &peer->label, AA_CLASS_PTRACE, request,\n\t\t\t       &perms);\n\taa_apply_modes_to_perms(profile, &perms);\n\treturn aa_check_perms(profile, &perms, request, sa, audit_ptrace_cb);\n}"
  },
  {
    "function_name": "audit_ptrace_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
    "lines": "49-65",
    "snippet": "static void audit_ptrace_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\tif (aad(sa)->request & AA_PTRACE_PERM_MASK) {\n\t\taudit_log_format(ab, \" requested_mask=\");\n\t\taudit_ptrace_mask(ab, aad(sa)->request);\n\n\t\tif (aad(sa)->denied & AA_PTRACE_PERM_MASK) {\n\t\t\taudit_log_format(ab, \" denied_mask=\");\n\t\t\taudit_ptrace_mask(ab, aad(sa)->denied);\n\t\t}\n\t}\n\taudit_log_format(ab, \" peer=\");\n\taa_label_xaudit(ab, labels_ns(aad(sa)->label), aad(sa)->peer,\n\t\t\tFLAGS_NONE, GFP_ATOMIC);\n}",
    "includes": [
      "#include \"include/sig_names.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/ptrace.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_label_xaudit",
          "args": [
            "ab",
            "labels_ns(aad(sa)->label)",
            "aad(sa)->peer",
            "FLAGS_NONE",
            "GFP_ATOMIC"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1710-1738",
          "snippet": "void aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "aad(sa)->label"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" peer=\""
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_ptrace_mask",
          "args": [
            "ab",
            "aad(sa)->denied"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "audit_ptrace_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
          "lines": "30-46",
          "snippet": "static void audit_ptrace_mask(struct audit_buffer *ab, u32 mask)\n{\n\tswitch (mask) {\n\tcase MAY_READ:\n\t\taudit_log_string(ab, \"read\");\n\t\tbreak;\n\tcase MAY_WRITE:\n\t\taudit_log_string(ab, \"trace\");\n\t\tbreak;\n\tcase AA_MAY_BE_READ:\n\t\taudit_log_string(ab, \"readby\");\n\t\tbreak;\n\tcase AA_MAY_BE_TRACED:\n\t\taudit_log_string(ab, \"tracedby\");\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"include/sig_names.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/ptrace.h>",
            "#include <linux/gfp.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic void audit_ptrace_mask(struct audit_buffer *ab, u32 mask)\n{\n\tswitch (mask) {\n\tcase MAY_READ:\n\t\taudit_log_string(ab, \"read\");\n\t\tbreak;\n\tcase MAY_WRITE:\n\t\taudit_log_string(ab, \"trace\");\n\t\tbreak;\n\tcase AA_MAY_BE_READ:\n\t\taudit_log_string(ab, \"readby\");\n\t\tbreak;\n\tcase AA_MAY_BE_TRACED:\n\t\taudit_log_string(ab, \"tracedby\");\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" denied_mask=\""
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" requested_mask=\""
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic void audit_ptrace_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\tif (aad(sa)->request & AA_PTRACE_PERM_MASK) {\n\t\taudit_log_format(ab, \" requested_mask=\");\n\t\taudit_ptrace_mask(ab, aad(sa)->request);\n\n\t\tif (aad(sa)->denied & AA_PTRACE_PERM_MASK) {\n\t\t\taudit_log_format(ab, \" denied_mask=\");\n\t\t\taudit_ptrace_mask(ab, aad(sa)->denied);\n\t\t}\n\t}\n\taudit_log_format(ab, \" peer=\");\n\taa_label_xaudit(ab, labels_ns(aad(sa)->label), aad(sa)->peer,\n\t\t\tFLAGS_NONE, GFP_ATOMIC);\n}"
  },
  {
    "function_name": "audit_ptrace_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/ipc.c",
    "lines": "30-46",
    "snippet": "static void audit_ptrace_mask(struct audit_buffer *ab, u32 mask)\n{\n\tswitch (mask) {\n\tcase MAY_READ:\n\t\taudit_log_string(ab, \"read\");\n\t\tbreak;\n\tcase MAY_WRITE:\n\t\taudit_log_string(ab, \"trace\");\n\t\tbreak;\n\tcase AA_MAY_BE_READ:\n\t\taudit_log_string(ab, \"readby\");\n\t\tbreak;\n\tcase AA_MAY_BE_TRACED:\n\t\taudit_log_string(ab, \"tracedby\");\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"include/sig_names.h\"",
      "#include \"include/ipc.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/capability.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/ptrace.h>",
      "#include <linux/gfp.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_string",
          "args": [
            "ab",
            "\"tracedby\""
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_string",
          "args": [
            "ab",
            "\"readby\""
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_string",
          "args": [
            "ab",
            "\"trace\""
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_string",
          "args": [
            "ab",
            "\"read\""
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/sig_names.h\"\n#include \"include/ipc.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/audit.h\"\n#include <linux/ptrace.h>\n#include <linux/gfp.h>\n\nstatic void audit_ptrace_mask(struct audit_buffer *ab, u32 mask)\n{\n\tswitch (mask) {\n\tcase MAY_READ:\n\t\taudit_log_string(ab, \"read\");\n\t\tbreak;\n\tcase MAY_WRITE:\n\t\taudit_log_string(ab, \"trace\");\n\t\tbreak;\n\tcase AA_MAY_BE_READ:\n\t\taudit_log_string(ab, \"readby\");\n\t\tbreak;\n\tcase AA_MAY_BE_TRACED:\n\t\taudit_log_string(ab, \"tracedby\");\n\t\tbreak;\n\t}\n}"
  }
]