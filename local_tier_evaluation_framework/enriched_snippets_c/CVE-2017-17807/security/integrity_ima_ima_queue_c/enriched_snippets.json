[
  {
    "function_name": "ima_restore_measurement_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
    "lines": "206-214",
    "snippet": "int ima_restore_measurement_entry(struct ima_template_entry *entry)\n{\n\tint result = 0;\n\n\tmutex_lock(&ima_extend_list_mutex);\n\tresult = ima_add_digest_entry(entry, 0);\n\tmutex_unlock(&ima_extend_list_mutex);\n\treturn result;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ima_extend_list_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ima_extend_list_mutex"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_add_digest_entry",
          "args": [
            "entry",
            "0"
          ],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "ima_add_digest_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
          "lines": "96-126",
          "snippet": "static int ima_add_digest_entry(struct ima_template_entry *entry,\n\t\t\t\tbool update_htable)\n{\n\tstruct ima_queue_entry *qe;\n\tunsigned int key;\n\n\tqe = kmalloc(sizeof(*qe), GFP_KERNEL);\n\tif (qe == NULL) {\n\t\tpr_err(\"OUT OF MEMORY ERROR creating queue entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tqe->entry = entry;\n\n\tINIT_LIST_HEAD(&qe->later);\n\tlist_add_tail_rcu(&qe->later, &ima_measurements);\n\n\tatomic_long_inc(&ima_htable.len);\n\tif (update_htable) {\n\t\tkey = ima_hash_key(entry->digest);\n\t\thlist_add_head_rcu(&qe->hnext, &ima_htable.queue[key]);\n\t}\n\n\tif (binary_runtime_size != ULONG_MAX) {\n\t\tint size;\n\n\t\tsize = get_binary_runtime_size(entry);\n\t\tbinary_runtime_size = (binary_runtime_size < ULONG_MAX - size) ?\n\t\t     binary_runtime_size + size : ULONG_MAX;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ima_h_table ima_htable = {\n\t.len = ATOMIC_LONG_INIT(0),\n\t.violations = ATOMIC_LONG_INIT(0),\n\t.queue[0 ... IMA_MEASURE_HTABLE_SIZE - 1] = HLIST_HEAD_INIT\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nstruct ima_h_table ima_htable = {\n\t.len = ATOMIC_LONG_INIT(0),\n\t.violations = ATOMIC_LONG_INIT(0),\n\t.queue[0 ... IMA_MEASURE_HTABLE_SIZE - 1] = HLIST_HEAD_INIT\n};\n\nstatic int ima_add_digest_entry(struct ima_template_entry *entry,\n\t\t\t\tbool update_htable)\n{\n\tstruct ima_queue_entry *qe;\n\tunsigned int key;\n\n\tqe = kmalloc(sizeof(*qe), GFP_KERNEL);\n\tif (qe == NULL) {\n\t\tpr_err(\"OUT OF MEMORY ERROR creating queue entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tqe->entry = entry;\n\n\tINIT_LIST_HEAD(&qe->later);\n\tlist_add_tail_rcu(&qe->later, &ima_measurements);\n\n\tatomic_long_inc(&ima_htable.len);\n\tif (update_htable) {\n\t\tkey = ima_hash_key(entry->digest);\n\t\thlist_add_head_rcu(&qe->hnext, &ima_htable.queue[key]);\n\t}\n\n\tif (binary_runtime_size != ULONG_MAX) {\n\t\tint size;\n\n\t\tsize = get_binary_runtime_size(entry);\n\t\tbinary_runtime_size = (binary_runtime_size < ULONG_MAX - size) ?\n\t\t     binary_runtime_size + size : ULONG_MAX;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ima_extend_list_mutex"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(ima_extend_list_mutex);\n\nint ima_restore_measurement_entry(struct ima_template_entry *entry)\n{\n\tint result = 0;\n\n\tmutex_lock(&ima_extend_list_mutex);\n\tresult = ima_add_digest_entry(entry, 0);\n\tmutex_unlock(&ima_extend_list_mutex);\n\treturn result;\n}"
  },
  {
    "function_name": "ima_add_template_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
    "lines": "162-204",
    "snippet": "int ima_add_template_entry(struct ima_template_entry *entry, int violation,\n\t\t\t   const char *op, struct inode *inode,\n\t\t\t   const unsigned char *filename)\n{\n\tu8 digest[TPM_DIGEST_SIZE];\n\tconst char *audit_cause = \"hash_added\";\n\tchar tpm_audit_cause[AUDIT_CAUSE_LEN_MAX];\n\tint audit_info = 1;\n\tint result = 0, tpmresult = 0;\n\n\tmutex_lock(&ima_extend_list_mutex);\n\tif (!violation) {\n\t\tmemcpy(digest, entry->digest, sizeof(digest));\n\t\tif (ima_lookup_digest_entry(digest, entry->pcr)) {\n\t\t\taudit_cause = \"hash_exists\";\n\t\t\tresult = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tresult = ima_add_digest_entry(entry, 1);\n\tif (result < 0) {\n\t\taudit_cause = \"ENOMEM\";\n\t\taudit_info = 0;\n\t\tgoto out;\n\t}\n\n\tif (violation)\t\t/* invalidate pcr */\n\t\tmemset(digest, 0xff, sizeof(digest));\n\n\ttpmresult = ima_pcr_extend(digest, entry->pcr);\n\tif (tpmresult != 0) {\n\t\tsnprintf(tpm_audit_cause, AUDIT_CAUSE_LEN_MAX, \"TPM_error(%d)\",\n\t\t\t tpmresult);\n\t\taudit_cause = tpm_audit_cause;\n\t\taudit_info = 0;\n\t}\nout:\n\tmutex_unlock(&ima_extend_list_mutex);\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t    op, audit_cause, result, audit_info);\n\treturn result;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define AUDIT_CAUSE_LEN_MAX 32"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(ima_extend_list_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_PCR",
            "inode",
            "filename",
            "op",
            "audit_cause",
            "result",
            "audit_info"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ima_extend_list_mutex"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "tpm_audit_cause",
            "AUDIT_CAUSE_LEN_MAX",
            "\"TPM_error(%d)\"",
            "tpmresult"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_pcr_extend",
          "args": [
            "digest",
            "entry->pcr"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "ima_pcr_extend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
          "lines": "141-152",
          "snippet": "static int ima_pcr_extend(const u8 *hash, int pcr)\n{\n\tint result = 0;\n\n\tif (!ima_used_chip)\n\t\treturn result;\n\n\tresult = tpm_pcr_extend(TPM_ANY_NUM, pcr, hash);\n\tif (result != 0)\n\t\tpr_err(\"Error Communicating to TPM chip, result: %d\\n\", result);\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nstatic int ima_pcr_extend(const u8 *hash, int pcr)\n{\n\tint result = 0;\n\n\tif (!ima_used_chip)\n\t\treturn result;\n\n\tresult = tpm_pcr_extend(TPM_ANY_NUM, pcr, hash);\n\tif (result != 0)\n\t\tpr_err(\"Error Communicating to TPM chip, result: %d\\n\", result);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "digest",
            "0xff",
            "sizeof(digest)"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_add_digest_entry",
          "args": [
            "entry",
            "1"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "ima_add_digest_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
          "lines": "96-126",
          "snippet": "static int ima_add_digest_entry(struct ima_template_entry *entry,\n\t\t\t\tbool update_htable)\n{\n\tstruct ima_queue_entry *qe;\n\tunsigned int key;\n\n\tqe = kmalloc(sizeof(*qe), GFP_KERNEL);\n\tif (qe == NULL) {\n\t\tpr_err(\"OUT OF MEMORY ERROR creating queue entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tqe->entry = entry;\n\n\tINIT_LIST_HEAD(&qe->later);\n\tlist_add_tail_rcu(&qe->later, &ima_measurements);\n\n\tatomic_long_inc(&ima_htable.len);\n\tif (update_htable) {\n\t\tkey = ima_hash_key(entry->digest);\n\t\thlist_add_head_rcu(&qe->hnext, &ima_htable.queue[key]);\n\t}\n\n\tif (binary_runtime_size != ULONG_MAX) {\n\t\tint size;\n\n\t\tsize = get_binary_runtime_size(entry);\n\t\tbinary_runtime_size = (binary_runtime_size < ULONG_MAX - size) ?\n\t\t     binary_runtime_size + size : ULONG_MAX;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ima_h_table ima_htable = {\n\t.len = ATOMIC_LONG_INIT(0),\n\t.violations = ATOMIC_LONG_INIT(0),\n\t.queue[0 ... IMA_MEASURE_HTABLE_SIZE - 1] = HLIST_HEAD_INIT\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nstruct ima_h_table ima_htable = {\n\t.len = ATOMIC_LONG_INIT(0),\n\t.violations = ATOMIC_LONG_INIT(0),\n\t.queue[0 ... IMA_MEASURE_HTABLE_SIZE - 1] = HLIST_HEAD_INIT\n};\n\nstatic int ima_add_digest_entry(struct ima_template_entry *entry,\n\t\t\t\tbool update_htable)\n{\n\tstruct ima_queue_entry *qe;\n\tunsigned int key;\n\n\tqe = kmalloc(sizeof(*qe), GFP_KERNEL);\n\tif (qe == NULL) {\n\t\tpr_err(\"OUT OF MEMORY ERROR creating queue entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tqe->entry = entry;\n\n\tINIT_LIST_HEAD(&qe->later);\n\tlist_add_tail_rcu(&qe->later, &ima_measurements);\n\n\tatomic_long_inc(&ima_htable.len);\n\tif (update_htable) {\n\t\tkey = ima_hash_key(entry->digest);\n\t\thlist_add_head_rcu(&qe->hnext, &ima_htable.queue[key]);\n\t}\n\n\tif (binary_runtime_size != ULONG_MAX) {\n\t\tint size;\n\n\t\tsize = get_binary_runtime_size(entry);\n\t\tbinary_runtime_size = (binary_runtime_size < ULONG_MAX - size) ?\n\t\t     binary_runtime_size + size : ULONG_MAX;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_lookup_digest_entry",
          "args": [
            "digest",
            "entry->pcr"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "ima_lookup_digest_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
          "lines": "52-70",
          "snippet": "static struct ima_queue_entry *ima_lookup_digest_entry(u8 *digest_value,\n\t\t\t\t\t\t       int pcr)\n{\n\tstruct ima_queue_entry *qe, *ret = NULL;\n\tunsigned int key;\n\tint rc;\n\n\tkey = ima_hash_key(digest_value);\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(qe, &ima_htable.queue[key], hnext) {\n\t\trc = memcmp(qe->entry->digest, digest_value, TPM_DIGEST_SIZE);\n\t\tif ((rc == 0) && (qe->entry->pcr == pcr)) {\n\t\t\tret = qe;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ima_h_table ima_htable = {\n\t.len = ATOMIC_LONG_INIT(0),\n\t.violations = ATOMIC_LONG_INIT(0),\n\t.queue[0 ... IMA_MEASURE_HTABLE_SIZE - 1] = HLIST_HEAD_INIT\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nstruct ima_h_table ima_htable = {\n\t.len = ATOMIC_LONG_INIT(0),\n\t.violations = ATOMIC_LONG_INIT(0),\n\t.queue[0 ... IMA_MEASURE_HTABLE_SIZE - 1] = HLIST_HEAD_INIT\n};\n\nstatic struct ima_queue_entry *ima_lookup_digest_entry(u8 *digest_value,\n\t\t\t\t\t\t       int pcr)\n{\n\tstruct ima_queue_entry *qe, *ret = NULL;\n\tunsigned int key;\n\tint rc;\n\n\tkey = ima_hash_key(digest_value);\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(qe, &ima_htable.queue[key], hnext) {\n\t\trc = memcmp(qe->entry->digest, digest_value, TPM_DIGEST_SIZE);\n\t\tif ((rc == 0) && (qe->entry->pcr == pcr)) {\n\t\t\tret = qe;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "digest",
            "entry->digest",
            "sizeof(digest)"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&ima_extend_list_mutex"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\n#define AUDIT_CAUSE_LEN_MAX 32\n\nstatic DEFINE_MUTEX(ima_extend_list_mutex);\n\nint ima_add_template_entry(struct ima_template_entry *entry, int violation,\n\t\t\t   const char *op, struct inode *inode,\n\t\t\t   const unsigned char *filename)\n{\n\tu8 digest[TPM_DIGEST_SIZE];\n\tconst char *audit_cause = \"hash_added\";\n\tchar tpm_audit_cause[AUDIT_CAUSE_LEN_MAX];\n\tint audit_info = 1;\n\tint result = 0, tpmresult = 0;\n\n\tmutex_lock(&ima_extend_list_mutex);\n\tif (!violation) {\n\t\tmemcpy(digest, entry->digest, sizeof(digest));\n\t\tif (ima_lookup_digest_entry(digest, entry->pcr)) {\n\t\t\taudit_cause = \"hash_exists\";\n\t\t\tresult = -EEXIST;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tresult = ima_add_digest_entry(entry, 1);\n\tif (result < 0) {\n\t\taudit_cause = \"ENOMEM\";\n\t\taudit_info = 0;\n\t\tgoto out;\n\t}\n\n\tif (violation)\t\t/* invalidate pcr */\n\t\tmemset(digest, 0xff, sizeof(digest));\n\n\ttpmresult = ima_pcr_extend(digest, entry->pcr);\n\tif (tpmresult != 0) {\n\t\tsnprintf(tpm_audit_cause, AUDIT_CAUSE_LEN_MAX, \"TPM_error(%d)\",\n\t\t\t tpmresult);\n\t\taudit_cause = tpm_audit_cause;\n\t\taudit_info = 0;\n\t}\nout:\n\tmutex_unlock(&ima_extend_list_mutex);\n\tintegrity_audit_msg(AUDIT_INTEGRITY_PCR, inode, filename,\n\t\t\t    op, audit_cause, result, audit_info);\n\treturn result;\n}"
  },
  {
    "function_name": "ima_pcr_extend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
    "lines": "141-152",
    "snippet": "static int ima_pcr_extend(const u8 *hash, int pcr)\n{\n\tint result = 0;\n\n\tif (!ima_used_chip)\n\t\treturn result;\n\n\tresult = tpm_pcr_extend(TPM_ANY_NUM, pcr, hash);\n\tif (result != 0)\n\t\tpr_err(\"Error Communicating to TPM chip, result: %d\\n\", result);\n\treturn result;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error Communicating to TPM chip, result: %d\\n\"",
            "result"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_pcr_extend",
          "args": [
            "TPM_ANY_NUM",
            "pcr",
            "hash"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nstatic int ima_pcr_extend(const u8 *hash, int pcr)\n{\n\tint result = 0;\n\n\tif (!ima_used_chip)\n\t\treturn result;\n\n\tresult = tpm_pcr_extend(TPM_ANY_NUM, pcr, hash);\n\tif (result != 0)\n\t\tpr_err(\"Error Communicating to TPM chip, result: %d\\n\", result);\n\treturn result;\n}"
  },
  {
    "function_name": "ima_get_binary_runtime_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
    "lines": "133-139",
    "snippet": "unsigned long ima_get_binary_runtime_size(void)\n{\n\tif (binary_runtime_size >= (ULONG_MAX - sizeof(struct ima_kexec_hdr)))\n\t\treturn ULONG_MAX;\n\telse\n\t\treturn binary_runtime_size + sizeof(struct ima_kexec_hdr);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nunsigned long ima_get_binary_runtime_size(void)\n{\n\tif (binary_runtime_size >= (ULONG_MAX - sizeof(struct ima_kexec_hdr)))\n\t\treturn ULONG_MAX;\n\telse\n\t\treturn binary_runtime_size + sizeof(struct ima_kexec_hdr);\n}"
  },
  {
    "function_name": "ima_add_digest_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
    "lines": "96-126",
    "snippet": "static int ima_add_digest_entry(struct ima_template_entry *entry,\n\t\t\t\tbool update_htable)\n{\n\tstruct ima_queue_entry *qe;\n\tunsigned int key;\n\n\tqe = kmalloc(sizeof(*qe), GFP_KERNEL);\n\tif (qe == NULL) {\n\t\tpr_err(\"OUT OF MEMORY ERROR creating queue entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tqe->entry = entry;\n\n\tINIT_LIST_HEAD(&qe->later);\n\tlist_add_tail_rcu(&qe->later, &ima_measurements);\n\n\tatomic_long_inc(&ima_htable.len);\n\tif (update_htable) {\n\t\tkey = ima_hash_key(entry->digest);\n\t\thlist_add_head_rcu(&qe->hnext, &ima_htable.queue[key]);\n\t}\n\n\tif (binary_runtime_size != ULONG_MAX) {\n\t\tint size;\n\n\t\tsize = get_binary_runtime_size(entry);\n\t\tbinary_runtime_size = (binary_runtime_size < ULONG_MAX - size) ?\n\t\t     binary_runtime_size + size : ULONG_MAX;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ima_h_table ima_htable = {\n\t.len = ATOMIC_LONG_INIT(0),\n\t.violations = ATOMIC_LONG_INIT(0),\n\t.queue[0 ... IMA_MEASURE_HTABLE_SIZE - 1] = HLIST_HEAD_INIT\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_binary_runtime_size",
          "args": [
            "entry"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "get_binary_runtime_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
          "lines": "77-88",
          "snippet": "static int get_binary_runtime_size(struct ima_template_entry *entry)\n{\n\tint size = 0;\n\n\tsize += sizeof(u32);\t/* pcr */\n\tsize += sizeof(entry->digest);\n\tsize += sizeof(int);\t/* template name size field */\n\tsize += strlen(entry->template_desc->name);\n\tsize += sizeof(entry->template_data_len);\n\tsize += entry->template_data_len;\n\treturn size;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nstatic int get_binary_runtime_size(struct ima_template_entry *entry)\n{\n\tint size = 0;\n\n\tsize += sizeof(u32);\t/* pcr */\n\tsize += sizeof(entry->digest);\n\tsize += sizeof(int);\t/* template name size field */\n\tsize += strlen(entry->template_desc->name);\n\tsize += sizeof(entry->template_data_len);\n\tsize += entry->template_data_len;\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&qe->hnext",
            "&ima_htable.queue[key]"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_hash_key",
          "args": [
            "entry->digest"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "ima_hash_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima.h",
          "lines": "170-173",
          "snippet": "static inline unsigned long ima_hash_key(u8 *digest)\n{\n\treturn hash_long(*digest, IMA_HASH_BITS);\n}",
          "includes": [
            "#include <asm/ima.h>",
            "#include \"../integrity.h\"",
            "#include <crypto/hash_info.h>",
            "#include <linux/audit.h>",
            "#include <linux/tpm.h>",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/crypto.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define IMA_HASH_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ima.h>\n#include \"../integrity.h\"\n#include <crypto/hash_info.h>\n#include <linux/audit.h>\n#include <linux/tpm.h>\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n\n#define IMA_HASH_BITS 9\n\nstatic inline unsigned long ima_hash_key(u8 *digest)\n{\n\treturn hash_long(*digest, IMA_HASH_BITS);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_inc",
          "args": [
            "&ima_htable.len"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&qe->later",
            "&ima_measurements"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&qe->later"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"OUT OF MEMORY ERROR creating queue entry\\n\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*qe)",
            "GFP_KERNEL"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nstruct ima_h_table ima_htable = {\n\t.len = ATOMIC_LONG_INIT(0),\n\t.violations = ATOMIC_LONG_INIT(0),\n\t.queue[0 ... IMA_MEASURE_HTABLE_SIZE - 1] = HLIST_HEAD_INIT\n};\n\nstatic int ima_add_digest_entry(struct ima_template_entry *entry,\n\t\t\t\tbool update_htable)\n{\n\tstruct ima_queue_entry *qe;\n\tunsigned int key;\n\n\tqe = kmalloc(sizeof(*qe), GFP_KERNEL);\n\tif (qe == NULL) {\n\t\tpr_err(\"OUT OF MEMORY ERROR creating queue entry\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tqe->entry = entry;\n\n\tINIT_LIST_HEAD(&qe->later);\n\tlist_add_tail_rcu(&qe->later, &ima_measurements);\n\n\tatomic_long_inc(&ima_htable.len);\n\tif (update_htable) {\n\t\tkey = ima_hash_key(entry->digest);\n\t\thlist_add_head_rcu(&qe->hnext, &ima_htable.queue[key]);\n\t}\n\n\tif (binary_runtime_size != ULONG_MAX) {\n\t\tint size;\n\n\t\tsize = get_binary_runtime_size(entry);\n\t\tbinary_runtime_size = (binary_runtime_size < ULONG_MAX - size) ?\n\t\t     binary_runtime_size + size : ULONG_MAX;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "get_binary_runtime_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
    "lines": "77-88",
    "snippet": "static int get_binary_runtime_size(struct ima_template_entry *entry)\n{\n\tint size = 0;\n\n\tsize += sizeof(u32);\t/* pcr */\n\tsize += sizeof(entry->digest);\n\tsize += sizeof(int);\t/* template name size field */\n\tsize += strlen(entry->template_desc->name);\n\tsize += sizeof(entry->template_data_len);\n\tsize += entry->template_data_len;\n\treturn size;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "entry->template_desc->name"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nstatic int get_binary_runtime_size(struct ima_template_entry *entry)\n{\n\tint size = 0;\n\n\tsize += sizeof(u32);\t/* pcr */\n\tsize += sizeof(entry->digest);\n\tsize += sizeof(int);\t/* template name size field */\n\tsize += strlen(entry->template_desc->name);\n\tsize += sizeof(entry->template_data_len);\n\tsize += entry->template_data_len;\n\treturn size;\n}"
  },
  {
    "function_name": "ima_lookup_digest_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
    "lines": "52-70",
    "snippet": "static struct ima_queue_entry *ima_lookup_digest_entry(u8 *digest_value,\n\t\t\t\t\t\t       int pcr)\n{\n\tstruct ima_queue_entry *qe, *ret = NULL;\n\tunsigned int key;\n\tint rc;\n\n\tkey = ima_hash_key(digest_value);\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(qe, &ima_htable.queue[key], hnext) {\n\t\trc = memcmp(qe->entry->digest, digest_value, TPM_DIGEST_SIZE);\n\t\tif ((rc == 0) && (qe->entry->pcr == pcr)) {\n\t\t\tret = qe;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/slab.h>",
      "#include <linux/rculist.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct ima_h_table ima_htable = {\n\t.len = ATOMIC_LONG_INIT(0),\n\t.violations = ATOMIC_LONG_INIT(0),\n\t.queue[0 ... IMA_MEASURE_HTABLE_SIZE - 1] = HLIST_HEAD_INIT\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "qe->entry->digest",
            "digest_value",
            "TPM_DIGEST_SIZE"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry_rcu",
          "args": [
            "qe",
            "&ima_htable.queue[key]",
            "hnext"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_hash_key",
          "args": [
            "digest_value"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "ima_hash_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima.h",
          "lines": "170-173",
          "snippet": "static inline unsigned long ima_hash_key(u8 *digest)\n{\n\treturn hash_long(*digest, IMA_HASH_BITS);\n}",
          "includes": [
            "#include <asm/ima.h>",
            "#include \"../integrity.h\"",
            "#include <crypto/hash_info.h>",
            "#include <linux/audit.h>",
            "#include <linux/tpm.h>",
            "#include <linux/hash.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/crypto.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define IMA_HASH_BITS 9"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/ima.h>\n#include \"../integrity.h\"\n#include <crypto/hash_info.h>\n#include <linux/audit.h>\n#include <linux/tpm.h>\n#include <linux/hash.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/crypto.h>\n#include <linux/types.h>\n\n#define IMA_HASH_BITS 9\n\nstatic inline unsigned long ima_hash_key(u8 *digest)\n{\n\treturn hash_long(*digest, IMA_HASH_BITS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nstruct ima_h_table ima_htable = {\n\t.len = ATOMIC_LONG_INIT(0),\n\t.violations = ATOMIC_LONG_INIT(0),\n\t.queue[0 ... IMA_MEASURE_HTABLE_SIZE - 1] = HLIST_HEAD_INIT\n};\n\nstatic struct ima_queue_entry *ima_lookup_digest_entry(u8 *digest_value,\n\t\t\t\t\t\t       int pcr)\n{\n\tstruct ima_queue_entry *qe, *ret = NULL;\n\tunsigned int key;\n\tint rc;\n\n\tkey = ima_hash_key(digest_value);\n\trcu_read_lock();\n\thlist_for_each_entry_rcu(qe, &ima_htable.queue[key], hnext) {\n\t\trc = memcmp(qe->entry->digest, digest_value, TPM_DIGEST_SIZE);\n\t\tif ((rc == 0) && (qe->entry->pcr == pcr)) {\n\t\t\tret = qe;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn ret;\n}"
  }
]