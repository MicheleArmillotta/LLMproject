[
  {
    "function_name": "init_smk_fs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2972-3014",
    "snippet": "static int __init init_smk_fs(void)\n{\n\tint err;\n\tint rc;\n\n\tif (smack_enabled == 0)\n\t\treturn 0;\n\n\terr = smk_init_sysfs();\n\tif (err)\n\t\tprintk(KERN_ERR \"smackfs: sysfs mountpoint problem.\\n\");\n\n\terr = register_filesystem(&smk_fs_type);\n\tif (!err) {\n\t\tsmackfs_mount = kern_mount(&smk_fs_type);\n\t\tif (IS_ERR(smackfs_mount)) {\n\t\t\tprintk(KERN_ERR \"smackfs:  could not mount!\\n\");\n\t\t\terr = PTR_ERR(smackfs_mount);\n\t\t\tsmackfs_mount = NULL;\n\t\t}\n\t}\n\n\tsmk_cipso_doi();\n\tsmk_unlbl_ambient(NULL);\n\n\trc = smk_preset_netlabel(&smack_known_floor);\n\tif (err == 0 && rc < 0)\n\t\terr = rc;\n\trc = smk_preset_netlabel(&smack_known_hat);\n\tif (err == 0 && rc < 0)\n\t\terr = rc;\n\trc = smk_preset_netlabel(&smack_known_huh);\n\tif (err == 0 && rc < 0)\n\t\terr = rc;\n\trc = smk_preset_netlabel(&smack_known_star);\n\tif (err == 0 && rc < 0)\n\t\terr = rc;\n\trc = smk_preset_netlabel(&smack_known_web);\n\tif (err == 0 && rc < 0)\n\t\terr = rc;\n\n\treturn err;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type smk_fs_type = {\n\t.name\t\t= \"smackfs\",\n\t.mount\t\t= smk_mount,\n\t.kill_sb\t= kill_litter_super,\n};",
      "static struct vfsmount *smackfs_mount;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_preset_netlabel",
          "args": [
            "&smack_known_web"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "smk_preset_netlabel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "2950-2957",
          "snippet": "static int __init smk_preset_netlabel(struct smack_known *skp)\n{\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\treturn smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t\t&skp->smk_netlabel, strlen(skp->smk_known));\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int smack_cipso_direct = SMACK_CIPSO_DIRECT_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nint smack_cipso_direct = SMACK_CIPSO_DIRECT_DEFAULT;\n\nstatic int __init smk_preset_netlabel(struct smack_known *skp)\n{\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\treturn smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t\t&skp->smk_netlabel, strlen(skp->smk_known));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_unlbl_ambient",
          "args": [
            "NULL"
          ],
          "line": 2995
        },
        "resolved": true,
        "details": {
          "function_name": "smk_unlbl_ambient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "754-775",
          "snippet": "static void smk_unlbl_ambient(char *oldambient)\n{\n\tint rc;\n\tstruct netlbl_audit nai;\n\n\tsmk_netlabel_audit_set(&nai);\n\n\tif (oldambient != NULL) {\n\t\trc = netlbl_cfg_map_del(oldambient, PF_INET, NULL, NULL, &nai);\n\t\tif (rc != 0)\n\t\t\tprintk(KERN_WARNING \"%s:%d remove rc = %d\\n\",\n\t\t\t       __func__, __LINE__, rc);\n\t}\n\tif (smack_net_ambient == NULL)\n\t\tsmack_net_ambient = &smack_known_floor;\n\n\trc = netlbl_cfg_unlbl_map_add(smack_net_ambient->smk_known, PF_INET,\n\t\t\t\t      NULL, NULL, &nai);\n\tif (rc != 0)\n\t\tprintk(KERN_WARNING \"%s:%d add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known *smack_net_ambient;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstruct smack_known *smack_net_ambient;\n\nstatic void smk_unlbl_ambient(char *oldambient)\n{\n\tint rc;\n\tstruct netlbl_audit nai;\n\n\tsmk_netlabel_audit_set(&nai);\n\n\tif (oldambient != NULL) {\n\t\trc = netlbl_cfg_map_del(oldambient, PF_INET, NULL, NULL, &nai);\n\t\tif (rc != 0)\n\t\t\tprintk(KERN_WARNING \"%s:%d remove rc = %d\\n\",\n\t\t\t       __func__, __LINE__, rc);\n\t}\n\tif (smack_net_ambient == NULL)\n\t\tsmack_net_ambient = &smack_known_floor;\n\n\trc = netlbl_cfg_unlbl_map_add(smack_net_ambient->smk_known, PF_INET,\n\t\t\t\t      NULL, NULL, &nai);\n\tif (rc != 0)\n\t\tprintk(KERN_WARNING \"%s:%d add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_cipso_doi",
          "args": [],
          "line": 2994
        },
        "resolved": true,
        "details": {
          "function_name": "smk_cipso_doi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "711-748",
          "snippet": "static void smk_cipso_doi(void)\n{\n\tint rc;\n\tstruct cipso_v4_doi *doip;\n\tstruct netlbl_audit nai;\n\n\tsmk_netlabel_audit_set(&nai);\n\n\trc = netlbl_cfg_map_del(NULL, PF_INET, NULL, NULL, &nai);\n\tif (rc != 0)\n\t\tprintk(KERN_WARNING \"%s:%d remove rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\n\tdoip = kmalloc(sizeof(struct cipso_v4_doi), GFP_KERNEL);\n\tif (doip == NULL)\n\t\tpanic(\"smack:  Failed to initialize cipso DOI.\\n\");\n\tdoip->map.std = NULL;\n\tdoip->doi = smk_cipso_doi_value;\n\tdoip->type = CIPSO_V4_MAP_PASS;\n\tdoip->tags[0] = CIPSO_V4_TAG_RBITMAP;\n\tfor (rc = 1; rc < CIPSO_V4_TAG_MAXCNT; rc++)\n\t\tdoip->tags[rc] = CIPSO_V4_TAG_INVALID;\n\n\trc = netlbl_cfg_cipsov4_add(doip, &nai);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING \"%s:%d cipso add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\t\tkfree(doip);\n\t\treturn;\n\t}\n\trc = netlbl_cfg_cipsov4_map_add(doip->doi, NULL, NULL, NULL, &nai);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING \"%s:%d map add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\t\tkfree(doip);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int smk_cipso_doi_value = SMACK_CIPSO_DOI_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_cipso_doi_value = SMACK_CIPSO_DOI_DEFAULT;\n\nstatic void smk_cipso_doi(void)\n{\n\tint rc;\n\tstruct cipso_v4_doi *doip;\n\tstruct netlbl_audit nai;\n\n\tsmk_netlabel_audit_set(&nai);\n\n\trc = netlbl_cfg_map_del(NULL, PF_INET, NULL, NULL, &nai);\n\tif (rc != 0)\n\t\tprintk(KERN_WARNING \"%s:%d remove rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\n\tdoip = kmalloc(sizeof(struct cipso_v4_doi), GFP_KERNEL);\n\tif (doip == NULL)\n\t\tpanic(\"smack:  Failed to initialize cipso DOI.\\n\");\n\tdoip->map.std = NULL;\n\tdoip->doi = smk_cipso_doi_value;\n\tdoip->type = CIPSO_V4_MAP_PASS;\n\tdoip->tags[0] = CIPSO_V4_TAG_RBITMAP;\n\tfor (rc = 1; rc < CIPSO_V4_TAG_MAXCNT; rc++)\n\t\tdoip->tags[rc] = CIPSO_V4_TAG_INVALID;\n\n\trc = netlbl_cfg_cipsov4_add(doip, &nai);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING \"%s:%d cipso add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\t\tkfree(doip);\n\t\treturn;\n\t}\n\trc = netlbl_cfg_cipsov4_map_add(doip->doi, NULL, NULL, NULL, &nai);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING \"%s:%d map add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\t\tkfree(doip);\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "smackfs_mount"
          ],
          "line": 2989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"smackfs:  could not mount!\\n\""
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "smackfs_mount"
          ],
          "line": 2987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_mount",
          "args": [
            "&smk_fs_type"
          ],
          "line": 2986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&smk_fs_type"
          ],
          "line": 2984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"smackfs: sysfs mountpoint problem.\\n\""
          ],
          "line": 2982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_init_sysfs",
          "args": [],
          "line": 2980
        },
        "resolved": true,
        "details": {
          "function_name": "smk_init_sysfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "2574-2577",
          "snippet": "static int smk_init_sysfs(void)\n{\n\treturn sysfs_create_mount_point(fs_kobj, \"smackfs\");\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_init_sysfs(void)\n{\n\treturn sysfs_create_mount_point(fs_kobj, \"smackfs\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic struct file_system_type smk_fs_type = {\n\t.name\t\t= \"smackfs\",\n\t.mount\t\t= smk_mount,\n\t.kill_sb\t= kill_litter_super,\n};\nstatic struct vfsmount *smackfs_mount;\n\nstatic int __init init_smk_fs(void)\n{\n\tint err;\n\tint rc;\n\n\tif (smack_enabled == 0)\n\t\treturn 0;\n\n\terr = smk_init_sysfs();\n\tif (err)\n\t\tprintk(KERN_ERR \"smackfs: sysfs mountpoint problem.\\n\");\n\n\terr = register_filesystem(&smk_fs_type);\n\tif (!err) {\n\t\tsmackfs_mount = kern_mount(&smk_fs_type);\n\t\tif (IS_ERR(smackfs_mount)) {\n\t\t\tprintk(KERN_ERR \"smackfs:  could not mount!\\n\");\n\t\t\terr = PTR_ERR(smackfs_mount);\n\t\t\tsmackfs_mount = NULL;\n\t\t}\n\t}\n\n\tsmk_cipso_doi();\n\tsmk_unlbl_ambient(NULL);\n\n\trc = smk_preset_netlabel(&smack_known_floor);\n\tif (err == 0 && rc < 0)\n\t\terr = rc;\n\trc = smk_preset_netlabel(&smack_known_hat);\n\tif (err == 0 && rc < 0)\n\t\terr = rc;\n\trc = smk_preset_netlabel(&smack_known_huh);\n\tif (err == 0 && rc < 0)\n\t\terr = rc;\n\trc = smk_preset_netlabel(&smack_known_star);\n\tif (err == 0 && rc < 0)\n\t\terr = rc;\n\trc = smk_preset_netlabel(&smack_known_web);\n\tif (err == 0 && rc < 0)\n\t\terr = rc;\n\n\treturn err;\n}"
  },
  {
    "function_name": "smk_preset_netlabel",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2950-2957",
    "snippet": "static int __init smk_preset_netlabel(struct smack_known *skp)\n{\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\treturn smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t\t&skp->smk_netlabel, strlen(skp->smk_known));\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int smack_cipso_direct = SMACK_CIPSO_DIRECT_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_netlbl_mls",
          "args": [
            "smack_cipso_direct",
            "skp->smk_known",
            "&skp->smk_netlabel",
            "strlen(skp->smk_known)"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "smk_netlbl_mls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "489-515",
          "snippet": "int smk_netlbl_mls(int level, char *catset, struct netlbl_lsm_secattr *sap,\n\t\t\tint len)\n{\n\tunsigned char *cp;\n\tunsigned char m;\n\tint cat;\n\tint rc;\n\tint byte;\n\n\tsap->flags |= NETLBL_SECATTR_MLS_CAT;\n\tsap->attr.mls.lvl = level;\n\tsap->attr.mls.cat = NULL;\n\n\tfor (cat = 1, cp = catset, byte = 0; byte < len; cp++, byte++)\n\t\tfor (m = 0x80; m != 0; m >>= 1, cat++) {\n\t\t\tif ((m & *cp) == 0)\n\t\t\t\tcontinue;\n\t\t\trc = netlbl_catmap_setbit(&sap->attr.mls.cat,\n\t\t\t\t\t\t  cat, GFP_KERNEL);\n\t\t\tif (rc < 0) {\n\t\t\t\tnetlbl_catmap_free(sap->attr.mls.cat);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_netlbl_mls(int level, char *catset, struct netlbl_lsm_secattr *sap,\n\t\t\tint len)\n{\n\tunsigned char *cp;\n\tunsigned char m;\n\tint cat;\n\tint rc;\n\tint byte;\n\n\tsap->flags |= NETLBL_SECATTR_MLS_CAT;\n\tsap->attr.mls.lvl = level;\n\tsap->attr.mls.cat = NULL;\n\n\tfor (cat = 1, cp = catset, byte = 0; byte < len; cp++, byte++)\n\t\tfor (m = 0x80; m != 0; m >>= 1, cat++) {\n\t\t\tif ((m & *cp) == 0)\n\t\t\t\tcontinue;\n\t\t\trc = netlbl_catmap_setbit(&sap->attr.mls.cat,\n\t\t\t\t\t\t  cat, GFP_KERNEL);\n\t\t\tif (rc < 0) {\n\t\t\t\tnetlbl_catmap_free(sap->attr.mls.cat);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "skp->smk_known"
          ],
          "line": 2956
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nint smack_cipso_direct = SMACK_CIPSO_DIRECT_DEFAULT;\n\nstatic int __init smk_preset_netlabel(struct smack_known *skp)\n{\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\treturn smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t\t&skp->smk_netlabel, strlen(skp->smk_known));\n}"
  },
  {
    "function_name": "smk_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2936-2940",
    "snippet": "static struct dentry *smk_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, smk_fill_super);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_single",
          "args": [
            "fs_type",
            "flags",
            "data",
            "smk_fill_super"
          ],
          "line": 2939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic struct dentry *smk_mount(struct file_system_type *fs_type,\n\t\t      int flags, const char *dev_name, void *data)\n{\n\treturn mount_single(fs_type, flags, data, smk_fill_super);\n}"
  },
  {
    "function_name": "smk_fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2853-2923",
    "snippet": "static int smk_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tint rc;\n\tstruct inode *root_inode;\n\n\tstatic const struct tree_descr smack_files[] = {\n\t\t[SMK_LOAD] = {\n\t\t\t\"load\", &smk_load_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_CIPSO] = {\n\t\t\t\"cipso\", &smk_cipso_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_DOI] = {\n\t\t\t\"doi\", &smk_doi_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_DIRECT] = {\n\t\t\t\"direct\", &smk_direct_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_AMBIENT] = {\n\t\t\t\"ambient\", &smk_ambient_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_NET4ADDR] = {\n\t\t\t\"netlabel\", &smk_net4addr_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_ONLYCAP] = {\n\t\t\t\"onlycap\", &smk_onlycap_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_LOGGING] = {\n\t\t\t\"logging\", &smk_logging_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_LOAD_SELF] = {\n\t\t\t\"load-self\", &smk_load_self_ops, S_IRUGO|S_IWUGO},\n\t\t[SMK_ACCESSES] = {\n\t\t\t\"access\", &smk_access_ops, S_IRUGO|S_IWUGO},\n\t\t[SMK_MAPPED] = {\n\t\t\t\"mapped\", &smk_mapped_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_LOAD2] = {\n\t\t\t\"load2\", &smk_load2_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_LOAD_SELF2] = {\n\t\t\t\"load-self2\", &smk_load_self2_ops, S_IRUGO|S_IWUGO},\n\t\t[SMK_ACCESS2] = {\n\t\t\t\"access2\", &smk_access2_ops, S_IRUGO|S_IWUGO},\n\t\t[SMK_CIPSO2] = {\n\t\t\t\"cipso2\", &smk_cipso2_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_REVOKE_SUBJ] = {\n\t\t\t\"revoke-subject\", &smk_revoke_subj_ops,\n\t\t\tS_IRUGO|S_IWUSR},\n\t\t[SMK_CHANGE_RULE] = {\n\t\t\t\"change-rule\", &smk_change_rule_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_SYSLOG] = {\n\t\t\t\"syslog\", &smk_syslog_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_PTRACE] = {\n\t\t\t\"ptrace\", &smk_ptrace_ops, S_IRUGO|S_IWUSR},\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t\t[SMK_UNCONFINED] = {\n\t\t\t\"unconfined\", &smk_unconfined_ops, S_IRUGO|S_IWUSR},\n#endif\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t[SMK_NET6ADDR] = {\n\t\t\t\"ipv6host\", &smk_net6addr_ops, S_IRUGO|S_IWUSR},\n#endif /* CONFIG_IPV6 */\n\t\t[SMK_RELABEL_SELF] = {\n\t\t\t\"relabel-self\", &smk_relabel_self_ops,\n\t\t\t\tS_IRUGO|S_IWUGO},\n\t\t/* last one */\n\t\t\t{\"\"}\n\t};\n\n\trc = simple_fill_super(sb, SMACK_MAGIC, smack_files);\n\tif (rc != 0) {\n\t\tprintk(KERN_ERR \"%s failed %d while creating inodes\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\n\troot_inode = d_inode(sb->s_root);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations smk_load_ops = {\n\t.open           = smk_open_load,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_load,\n\t.release        = seq_release,\n};",
      "static const struct file_operations smk_cipso_ops = {\n\t.open           = smk_open_cipso,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_cipso,\n\t.release        = seq_release,\n};",
      "static const struct file_operations smk_cipso2_ops = {\n\t.open           = smk_open_cipso2,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_cipso2,\n\t.release        = seq_release,\n};",
      "static const struct file_operations smk_net4addr_ops = {\n\t.open           = smk_open_net4addr,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_net4addr,\n\t.release        = seq_release,\n};",
      "static const struct file_operations smk_doi_ops = {\n\t.read\t\t= smk_read_doi,\n\t.write\t\t= smk_write_doi,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct file_operations smk_direct_ops = {\n\t.read\t\t= smk_read_direct,\n\t.write\t\t= smk_write_direct,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct file_operations smk_mapped_ops = {\n\t.read\t\t= smk_read_mapped,\n\t.write\t\t= smk_write_mapped,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct file_operations smk_ambient_ops = {\n\t.read\t\t= smk_read_ambient,\n\t.write\t\t= smk_write_ambient,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct file_operations smk_onlycap_ops = {\n\t.open\t\t= smk_open_onlycap,\n\t.read\t\t= seq_read,\n\t.write\t\t= smk_write_onlycap,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};",
      "static const struct file_operations smk_logging_ops = {\n\t.read\t\t= smk_read_logging,\n\t.write\t\t= smk_write_logging,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct file_operations smk_load_self_ops = {\n\t.open           = smk_open_load_self,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_load_self,\n\t.release        = seq_release,\n};",
      "static const struct file_operations smk_access_ops = {\n\t.write\t\t= smk_write_access,\n\t.read\t\t= simple_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations smk_load2_ops = {\n\t.open           = smk_open_load2,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_load2,\n\t.release        = seq_release,\n};",
      "static const struct file_operations smk_load_self2_ops = {\n\t.open           = smk_open_load_self2,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_load_self2,\n\t.release        = seq_release,\n};",
      "static const struct file_operations smk_access2_ops = {\n\t.write\t\t= smk_write_access2,\n\t.read\t\t= simple_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations smk_revoke_subj_ops = {\n\t.write\t\t= smk_write_revoke_subj,\n\t.read\t\t= simple_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations smk_change_rule_ops = {\n\t.write\t\t= smk_write_change_rule,\n\t.read\t\t= simple_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= generic_file_llseek,\n};",
      "static const struct file_operations smk_syslog_ops = {\n\t.read\t\t= smk_read_syslog,\n\t.write\t\t= smk_write_syslog,\n\t.llseek\t\t= default_llseek,\n};",
      "static const struct file_operations smk_relabel_self_ops = {\n\t.open\t\t= smk_open_relabel_self,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= smk_write_relabel_self,\n\t.release\t= seq_release,\n};",
      "static const struct file_operations smk_ptrace_ops = {\n\t.write\t\t= smk_write_ptrace,\n\t.read\t\t= smk_read_ptrace,\n\t.llseek\t\t= default_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "sb->s_root"
          ],
          "line": 2920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"%s failed %d while creating inodes\\n\"",
            "__func__",
            "rc"
          ],
          "line": 2915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_fill_super",
          "args": [
            "sb",
            "SMACK_MAGIC",
            "smack_files"
          ],
          "line": 2913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_IPV6"
          ],
          "line": 2902
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic const struct file_operations smk_load_ops = {\n\t.open           = smk_open_load,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_load,\n\t.release        = seq_release,\n};\nstatic const struct file_operations smk_cipso_ops = {\n\t.open           = smk_open_cipso,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_cipso,\n\t.release        = seq_release,\n};\nstatic const struct file_operations smk_cipso2_ops = {\n\t.open           = smk_open_cipso2,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_cipso2,\n\t.release        = seq_release,\n};\nstatic const struct file_operations smk_net4addr_ops = {\n\t.open           = smk_open_net4addr,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_net4addr,\n\t.release        = seq_release,\n};\nstatic const struct file_operations smk_doi_ops = {\n\t.read\t\t= smk_read_doi,\n\t.write\t\t= smk_write_doi,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations smk_direct_ops = {\n\t.read\t\t= smk_read_direct,\n\t.write\t\t= smk_write_direct,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations smk_mapped_ops = {\n\t.read\t\t= smk_read_mapped,\n\t.write\t\t= smk_write_mapped,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations smk_ambient_ops = {\n\t.read\t\t= smk_read_ambient,\n\t.write\t\t= smk_write_ambient,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations smk_onlycap_ops = {\n\t.open\t\t= smk_open_onlycap,\n\t.read\t\t= seq_read,\n\t.write\t\t= smk_write_onlycap,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\nstatic const struct file_operations smk_logging_ops = {\n\t.read\t\t= smk_read_logging,\n\t.write\t\t= smk_write_logging,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations smk_load_self_ops = {\n\t.open           = smk_open_load_self,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_load_self,\n\t.release        = seq_release,\n};\nstatic const struct file_operations smk_access_ops = {\n\t.write\t\t= smk_write_access,\n\t.read\t\t= simple_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations smk_load2_ops = {\n\t.open           = smk_open_load2,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_load2,\n\t.release        = seq_release,\n};\nstatic const struct file_operations smk_load_self2_ops = {\n\t.open           = smk_open_load_self2,\n\t.read\t\t= seq_read,\n\t.llseek         = seq_lseek,\n\t.write\t\t= smk_write_load_self2,\n\t.release        = seq_release,\n};\nstatic const struct file_operations smk_access2_ops = {\n\t.write\t\t= smk_write_access2,\n\t.read\t\t= simple_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations smk_revoke_subj_ops = {\n\t.write\t\t= smk_write_revoke_subj,\n\t.read\t\t= simple_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations smk_change_rule_ops = {\n\t.write\t\t= smk_write_change_rule,\n\t.read\t\t= simple_transaction_read,\n\t.release\t= simple_transaction_release,\n\t.llseek\t\t= generic_file_llseek,\n};\nstatic const struct file_operations smk_syslog_ops = {\n\t.read\t\t= smk_read_syslog,\n\t.write\t\t= smk_write_syslog,\n\t.llseek\t\t= default_llseek,\n};\nstatic const struct file_operations smk_relabel_self_ops = {\n\t.open\t\t= smk_open_relabel_self,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.write\t\t= smk_write_relabel_self,\n\t.release\t= seq_release,\n};\nstatic const struct file_operations smk_ptrace_ops = {\n\t.write\t\t= smk_write_ptrace,\n\t.read\t\t= smk_read_ptrace,\n\t.llseek\t\t= default_llseek,\n};\n\nstatic int smk_fill_super(struct super_block *sb, void *data, int silent)\n{\n\tint rc;\n\tstruct inode *root_inode;\n\n\tstatic const struct tree_descr smack_files[] = {\n\t\t[SMK_LOAD] = {\n\t\t\t\"load\", &smk_load_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_CIPSO] = {\n\t\t\t\"cipso\", &smk_cipso_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_DOI] = {\n\t\t\t\"doi\", &smk_doi_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_DIRECT] = {\n\t\t\t\"direct\", &smk_direct_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_AMBIENT] = {\n\t\t\t\"ambient\", &smk_ambient_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_NET4ADDR] = {\n\t\t\t\"netlabel\", &smk_net4addr_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_ONLYCAP] = {\n\t\t\t\"onlycap\", &smk_onlycap_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_LOGGING] = {\n\t\t\t\"logging\", &smk_logging_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_LOAD_SELF] = {\n\t\t\t\"load-self\", &smk_load_self_ops, S_IRUGO|S_IWUGO},\n\t\t[SMK_ACCESSES] = {\n\t\t\t\"access\", &smk_access_ops, S_IRUGO|S_IWUGO},\n\t\t[SMK_MAPPED] = {\n\t\t\t\"mapped\", &smk_mapped_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_LOAD2] = {\n\t\t\t\"load2\", &smk_load2_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_LOAD_SELF2] = {\n\t\t\t\"load-self2\", &smk_load_self2_ops, S_IRUGO|S_IWUGO},\n\t\t[SMK_ACCESS2] = {\n\t\t\t\"access2\", &smk_access2_ops, S_IRUGO|S_IWUGO},\n\t\t[SMK_CIPSO2] = {\n\t\t\t\"cipso2\", &smk_cipso2_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_REVOKE_SUBJ] = {\n\t\t\t\"revoke-subject\", &smk_revoke_subj_ops,\n\t\t\tS_IRUGO|S_IWUSR},\n\t\t[SMK_CHANGE_RULE] = {\n\t\t\t\"change-rule\", &smk_change_rule_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_SYSLOG] = {\n\t\t\t\"syslog\", &smk_syslog_ops, S_IRUGO|S_IWUSR},\n\t\t[SMK_PTRACE] = {\n\t\t\t\"ptrace\", &smk_ptrace_ops, S_IRUGO|S_IWUSR},\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t\t[SMK_UNCONFINED] = {\n\t\t\t\"unconfined\", &smk_unconfined_ops, S_IRUGO|S_IWUSR},\n#endif\n#if IS_ENABLED(CONFIG_IPV6)\n\t\t[SMK_NET6ADDR] = {\n\t\t\t\"ipv6host\", &smk_net6addr_ops, S_IRUGO|S_IWUSR},\n#endif /* CONFIG_IPV6 */\n\t\t[SMK_RELABEL_SELF] = {\n\t\t\t\"relabel-self\", &smk_relabel_self_ops,\n\t\t\t\tS_IRUGO|S_IWUGO},\n\t\t/* last one */\n\t\t\t{\"\"}\n\t};\n\n\trc = simple_fill_super(sb, SMACK_MAGIC, smack_files);\n\tif (rc != 0) {\n\t\tprintk(KERN_ERR \"%s failed %d while creating inodes\\n\",\n\t\t\t__func__, rc);\n\t\treturn rc;\n\t}\n\n\troot_inode = d_inode(sb->s_root);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_write_ptrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2811-2835",
    "snippet": "static ssize_t smk_write_ptrace(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar temp[32];\n\tint i;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (*ppos != 0 || count >= sizeof(temp) || count == 0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(temp, buf, count) != 0)\n\t\treturn -EFAULT;\n\n\ttemp[count] = '\\0';\n\n\tif (sscanf(temp, \"%d\", &i) != 1)\n\t\treturn -EINVAL;\n\tif (i < SMACK_PTRACE_DEFAULT || i > SMACK_PTRACE_MAX)\n\t\treturn -EINVAL;\n\tsmack_ptrace_rule = i;\n\n\treturn count;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int smack_ptrace_rule = SMACK_PTRACE_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "temp",
            "\"%d\"",
            "&i"
          ],
          "line": 2828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "temp",
            "buf",
            "count"
          ],
          "line": 2823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 2817
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nint smack_ptrace_rule = SMACK_PTRACE_DEFAULT;\n\nstatic ssize_t smk_write_ptrace(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar temp[32];\n\tint i;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (*ppos != 0 || count >= sizeof(temp) || count == 0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(temp, buf, count) != 0)\n\t\treturn -EFAULT;\n\n\ttemp[count] = '\\0';\n\n\tif (sscanf(temp, \"%d\", &i) != 1)\n\t\treturn -EINVAL;\n\tif (i < SMACK_PTRACE_DEFAULT || i > SMACK_PTRACE_MAX)\n\t\treturn -EINVAL;\n\tsmack_ptrace_rule = i;\n\n\treturn count;\n}"
  },
  {
    "function_name": "smk_read_ptrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2790-2802",
    "snippet": "static ssize_t smk_read_ptrace(struct file *filp, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar temp[32];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\\n\", smack_ptrace_rule);\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int smack_ptrace_rule = SMACK_PTRACE_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "temp",
            "strlen(temp)"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "temp"
          ],
          "line": 2800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "temp",
            "\"%d\\n\"",
            "smack_ptrace_rule"
          ],
          "line": 2799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nint smack_ptrace_rule = SMACK_PTRACE_DEFAULT;\n\nstatic ssize_t smk_read_ptrace(struct file *filp, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar temp[32];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\\n\", smack_ptrace_rule);\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_write_relabel_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2736-2771",
    "snippet": "static ssize_t smk_write_relabel_self(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar *data;\n\tint rc;\n\tLIST_HEAD(list_tmp);\n\n\t/*\n\t * Must have privilege.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trc = smk_parse_label_list(data, &list_tmp);\n\tkfree(data);\n\n\tif (!rc || (rc == -EINVAL && list_empty(&list_tmp))) {\n\t\tsmk_destroy_label_list(&tsp->smk_relabel);\n\t\tlist_splice(&list_tmp, &tsp->smk_relabel);\n\t\treturn count;\n\t}\n\n\tsmk_destroy_label_list(&list_tmp);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_destroy_label_list",
          "args": [
            "&list_tmp"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "smk_destroy_label_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "1988-1997",
          "snippet": "void smk_destroy_label_list(struct list_head *list)\n{\n\tstruct smack_known_list_elem *sklep;\n\tstruct smack_known_list_elem *sklep2;\n\n\tlist_for_each_entry_safe(sklep, sklep2, list, list)\n\t\tkfree(sklep);\n\n\tINIT_LIST_HEAD(list);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nvoid smk_destroy_label_list(struct list_head *list)\n{\n\tstruct smack_known_list_elem *sklep;\n\tstruct smack_known_list_elem *sklep2;\n\n\tlist_for_each_entry_safe(sklep, sklep2, list, list)\n\t\tkfree(sklep);\n\n\tINIT_LIST_HEAD(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice",
          "args": [
            "&list_tmp",
            "&tsp->smk_relabel"
          ],
          "line": 2765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&list_tmp"
          ],
          "line": 2763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 2761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_parse_label_list",
          "args": [
            "data",
            "&list_tmp"
          ],
          "line": 2760
        },
        "resolved": true,
        "details": {
          "function_name": "smk_parse_label_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "1959-1982",
          "snippet": "static int smk_parse_label_list(char *data, struct list_head *list)\n{\n\tchar *tok;\n\tstruct smack_known *skp;\n\tstruct smack_known_list_elem *sklep;\n\n\twhile ((tok = strsep(&data, \" \")) != NULL) {\n\t\tif (!*tok)\n\t\t\tcontinue;\n\n\t\tskp = smk_import_entry(tok, 0);\n\t\tif (IS_ERR(skp))\n\t\t\treturn PTR_ERR(skp);\n\n\t\tsklep = kzalloc(sizeof(*sklep), GFP_KERNEL);\n\t\tif (sklep == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tsklep->smk_label = skp;\n\t\tlist_add(&sklep->list, list);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_parse_label_list(char *data, struct list_head *list)\n{\n\tchar *tok;\n\tstruct smack_known *skp;\n\tstruct smack_known_list_elem *sklep;\n\n\twhile ((tok = strsep(&data, \" \")) != NULL) {\n\t\tif (!*tok)\n\t\t\tcontinue;\n\n\t\tskp = smk_import_entry(tok, 0);\n\t\tif (IS_ERR(skp))\n\t\t\treturn PTR_ERR(skp);\n\n\t\tsklep = kzalloc(sizeof(*sklep), GFP_KERNEL);\n\t\tif (sklep == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tsklep->smk_label = skp;\n\t\tlist_add(&sklep->list, list);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 2757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 2756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 2747
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list_tmp"
          ],
          "line": 2742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 2739
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic ssize_t smk_write_relabel_self(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct task_smack *tsp = current_security();\n\tchar *data;\n\tint rc;\n\tLIST_HEAD(list_tmp);\n\n\t/*\n\t * Must have privilege.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trc = smk_parse_label_list(data, &list_tmp);\n\tkfree(data);\n\n\tif (!rc || (rc == -EINVAL && list_empty(&list_tmp))) {\n\t\tsmk_destroy_label_list(&tsp->smk_relabel);\n\t\tlist_splice(&list_tmp, &tsp->smk_relabel);\n\t\treturn count;\n\t}\n\n\tsmk_destroy_label_list(&list_tmp);\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_open_relabel_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2723-2726",
    "snippet": "static int smk_open_relabel_self(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &relabel_self_seq_ops);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations relabel_self_seq_ops = {\n\t.start = relabel_self_seq_start,\n\t.next  = relabel_self_seq_next,\n\t.show  = relabel_self_seq_show,\n\t.stop  = smk_seq_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&relabel_self_seq_ops"
          ],
          "line": 2725
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic const struct seq_operations relabel_self_seq_ops = {\n\t.start = relabel_self_seq_start,\n\t.next  = relabel_self_seq_next,\n\t.show  = relabel_self_seq_show,\n\t.stop  = smk_seq_stop,\n};\n\nstatic int smk_open_relabel_self(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &relabel_self_seq_ops);\n}"
  },
  {
    "function_name": "relabel_self_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2696-2706",
    "snippet": "static int relabel_self_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smack_known_list_elem *sklep =\n\t\tlist_entry(list, struct smack_known_list_elem, list);\n\n\tseq_puts(s, sklep->smk_label->smk_known);\n\tseq_putc(s, ' ');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 2703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "sklep->smk_label->smk_known"
          ],
          "line": 2702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "list",
            "structsmack_known_list_elem",
            "list"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int relabel_self_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smack_known_list_elem *sklep =\n\t\tlist_entry(list, struct smack_known_list_elem, list);\n\n\tseq_puts(s, sklep->smk_label->smk_known);\n\tseq_putc(s, ' ');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "relabel_self_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2689-2694",
    "snippet": "static void *relabel_self_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_seq_next(s, v, pos, &tsp->smk_relabel);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_next",
          "args": [
            "s",
            "v",
            "pos",
            "&tsp->smk_relabel"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "578-587",
          "snippet": "static void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 2691
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *relabel_self_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_seq_next(s, v, pos, &tsp->smk_relabel);\n}"
  },
  {
    "function_name": "relabel_self_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2682-2687",
    "snippet": "static void *relabel_self_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_seq_start(s, pos, &tsp->smk_relabel);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_start",
          "args": [
            "s",
            "pos",
            "&tsp->smk_relabel"
          ],
          "line": 2686
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "561-576",
          "snippet": "static void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 2684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *relabel_self_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_seq_start(s, pos, &tsp->smk_relabel);\n}"
  },
  {
    "function_name": "smk_write_syslog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2648-2670",
    "snippet": "static ssize_t smk_write_syslog(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *data;\n\tstruct smack_known *skp;\n\tint rc = count;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tskp = smk_import_entry(data, count);\n\tif (IS_ERR(skp))\n\t\trc = PTR_ERR(skp);\n\telse\n\t\tsmack_syslog_label = skp;\n\n\tkfree(data);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct smack_known *smack_syslog_label;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 2668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 2664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "data",
            "count"
          ],
          "line": 2662
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 2659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 2658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 2655
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstruct smack_known *smack_syslog_label;\n\nstatic ssize_t smk_write_syslog(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *data;\n\tstruct smack_known *skp;\n\tint rc = count;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tskp = smk_import_entry(data, count);\n\tif (IS_ERR(skp))\n\t\trc = PTR_ERR(skp);\n\telse\n\t\tsmack_syslog_label = skp;\n\n\tkfree(data);\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_read_syslog",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2615-2637",
    "snippet": "static ssize_t smk_read_syslog(struct file *filp, char __user *buf,\n\t\t\t\tsize_t cn, loff_t *ppos)\n{\n\tstruct smack_known *skp;\n\tssize_t rc = -EINVAL;\n\tint asize;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tif (smack_syslog_label == NULL)\n\t\tskp = &smack_known_star;\n\telse\n\t\tskp = smack_syslog_label;\n\n\tasize = strlen(skp->smk_known) + 1;\n\n\tif (cn >= asize)\n\t\trc = simple_read_from_buffer(buf, cn, ppos, skp->smk_known,\n\t\t\t\t\t\tasize);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct smack_known *smack_syslog_label;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "cn",
            "ppos",
            "skp->smk_known",
            "asize"
          ],
          "line": 2633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "skp->smk_known"
          ],
          "line": 2630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstruct smack_known *smack_syslog_label;\n\nstatic ssize_t smk_read_syslog(struct file *filp, char __user *buf,\n\t\t\t\tsize_t cn, loff_t *ppos)\n{\n\tstruct smack_known *skp;\n\tssize_t rc = -EINVAL;\n\tint asize;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tif (smack_syslog_label == NULL)\n\t\tskp = &smack_known_star;\n\telse\n\t\tskp = smack_syslog_label;\n\n\tasize = strlen(skp->smk_known) + 1;\n\n\tif (cn >= asize)\n\t\trc = simple_read_from_buffer(buf, cn, ppos, skp->smk_known,\n\t\t\t\t\t\tasize);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_write_change_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2586-2597",
    "snippet": "static ssize_t smk_write_change_rule(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\t/*\n\t * Must have privilege.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\treturn smk_write_rules_list(file, buf, count, ppos, NULL, NULL,\n\t\t\t\t    SMK_CHANGE_FMT);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_CHANGE_FMT\t2\t/* Rule modification format */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_write_rules_list",
          "args": [
            "file",
            "buf",
            "count",
            "ppos",
            "NULL",
            "NULL",
            "SMK_CHANGE_FMT"
          ],
          "line": 2595
        },
        "resolved": true,
        "details": {
          "function_name": "smk_write_rules_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "473-555",
          "snippet": "static ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\t\tstruct list_head *rule_list,\n\t\t\t\t\tstruct mutex *rule_lock, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint rc;\n\tint trunc = 0;\n\tint tokens;\n\tssize_t cnt = 0;\n\n\t/*\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\t/*\n\t\t * Minor hack for backward compatibility\n\t\t */\n\t\tif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (count >= PAGE_SIZE) {\n\t\t\tcount = PAGE_SIZE - 1;\n\t\t\ttrunc = 1;\n\t\t}\n\t}\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * In case of parsing only part of user buf,\n\t * avoid having partial rule at the data buffer\n\t */\n\tif (trunc) {\n\t\twhile (count > 0 && (data[count - 1] != '\\n'))\n\t\t\t--count;\n\t\tif (count == 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdata[count] = '\\0';\n\ttokens = (format == SMK_CHANGE_FMT ? 4 : 3);\n\twhile (cnt < count) {\n\t\tif (format == SMK_FIXED24_FMT) {\n\t\t\trc = smk_parse_rule(data, &rule, 1);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tcnt = count;\n\t\t} else {\n\t\t\trc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tif (rc == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcnt += rc;\n\t\t}\n\n\t\tif (rule_list == NULL)\n\t\t\trc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\n\t\t\t\t&rule.smk_subject->smk_rules_lock, 1);\n\t\telse\n\t\t\trc = smk_set_access(&rule, rule_list, rule_lock, 0);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = cnt;\nout:\n\tkfree(data);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SMK_CHANGE_FMT\t2\t/* Rule modification format */",
            "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */",
            "#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)",
            "#define SMK_OLOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_CHANGE_FMT\t2\t/* Rule modification format */\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)\n#define SMK_OLOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)\n\nstatic ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\t\tstruct list_head *rule_list,\n\t\t\t\t\tstruct mutex *rule_lock, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint rc;\n\tint trunc = 0;\n\tint tokens;\n\tssize_t cnt = 0;\n\n\t/*\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\t/*\n\t\t * Minor hack for backward compatibility\n\t\t */\n\t\tif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (count >= PAGE_SIZE) {\n\t\t\tcount = PAGE_SIZE - 1;\n\t\t\ttrunc = 1;\n\t\t}\n\t}\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * In case of parsing only part of user buf,\n\t * avoid having partial rule at the data buffer\n\t */\n\tif (trunc) {\n\t\twhile (count > 0 && (data[count - 1] != '\\n'))\n\t\t\t--count;\n\t\tif (count == 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdata[count] = '\\0';\n\ttokens = (format == SMK_CHANGE_FMT ? 4 : 3);\n\twhile (cnt < count) {\n\t\tif (format == SMK_FIXED24_FMT) {\n\t\t\trc = smk_parse_rule(data, &rule, 1);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tcnt = count;\n\t\t} else {\n\t\t\trc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tif (rc == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcnt += rc;\n\t\t}\n\n\t\tif (rule_list == NULL)\n\t\t\trc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\n\t\t\t\t&rule.smk_subject->smk_rules_lock, 1);\n\t\telse\n\t\t\trc = smk_set_access(&rule, rule_list, rule_lock, 0);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = cnt;\nout:\n\tkfree(data);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 2592
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_CHANGE_FMT\t2\t/* Rule modification format */\n\nstatic ssize_t smk_write_change_rule(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\t/*\n\t * Must have privilege.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\treturn smk_write_rules_list(file, buf, count, ppos, NULL, NULL,\n\t\t\t\t    SMK_CHANGE_FMT);\n}"
  },
  {
    "function_name": "smk_init_sysfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2574-2577",
    "snippet": "static int smk_init_sysfs(void)\n{\n\treturn sysfs_create_mount_point(fs_kobj, \"smackfs\");\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sysfs_create_mount_point",
          "args": [
            "fs_kobj",
            "\"smackfs\""
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_init_sysfs(void)\n{\n\treturn sysfs_create_mount_point(fs_kobj, \"smackfs\");\n}"
  },
  {
    "function_name": "smk_write_revoke_subj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2511-2561",
    "snippet": "static ssize_t smk_write_revoke_subj(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *data;\n\tconst char *cp;\n\tstruct smack_known *skp;\n\tstruct smack_rule *sp;\n\tstruct list_head *rule_list;\n\tstruct mutex *rule_lock;\n\tint rc = count;\n\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (count == 0 || count > SMK_LONGLABEL)\n\t\treturn -EINVAL;\n\n\tdata = memdup_user(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tcp = smk_parse_smack(data, count);\n\tif (IS_ERR(cp)) {\n\t\trc = PTR_ERR(cp);\n\t\tgoto out_data;\n\t}\n\n\tskp = smk_find_entry(cp);\n\tif (skp == NULL)\n\t\tgoto out_cp;\n\n\trule_list = &skp->smk_rules;\n\trule_lock = &skp->smk_rules_lock;\n\n\tmutex_lock(rule_lock);\n\n\tlist_for_each_entry_rcu(sp, rule_list, list)\n\t\tsp->smk_access = 0;\n\n\tmutex_unlock(rule_lock);\n\nout_cp:\n\tkfree(cp);\nout_data:\n\tkfree(data);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 2558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cp"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "rule_lock"
          ],
          "line": 2553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "sp",
            "rule_list",
            "list"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "rule_lock"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_find_entry",
          "args": [
            "cp"
          ],
          "line": 2541
        },
        "resolved": true,
        "details": {
          "function_name": "smk_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "425-439",
          "snippet": "struct smack_known *smk_find_entry(const char *string)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\tstruct smack_known *skp;\n\n\thash = full_name_hash(NULL, string, strlen(string));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_for_each_entry_rcu(skp, head, smk_hashed)\n\t\tif (strcmp(skp->smk_known, string) == 0)\n\t\t\treturn skp;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct hlist_head smack_known_hash[SMACK_HASH_SLOTS];\n\nstruct smack_known *smk_find_entry(const char *string)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\tstruct smack_known *skp;\n\n\thash = full_name_hash(NULL, string, strlen(string));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_for_each_entry_rcu(skp, head, smk_hashed)\n\t\tif (strcmp(skp->smk_known, string) == 0)\n\t\t\treturn skp;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cp"
          ],
          "line": 2537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cp"
          ],
          "line": 2536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_parse_smack",
          "args": [
            "data",
            "count"
          ],
          "line": 2535
        },
        "resolved": true,
        "details": {
          "function_name": "smk_parse_smack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "448-479",
          "snippet": "char *smk_parse_smack(const char *string, int len)\n{\n\tchar *smack;\n\tint i;\n\n\tif (len <= 0)\n\t\tlen = strlen(string) + 1;\n\n\t/*\n\t * Reserve a leading '-' as an indicator that\n\t * this isn't a label, but an option to interfaces\n\t * including /smack/cipso and /smack/cipso2\n\t */\n\tif (string[0] == '-')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (string[i] > '~' || string[i] <= ' ' || string[i] == '/' ||\n\t\t    string[i] == '\"' || string[i] == '\\\\' || string[i] == '\\'')\n\t\t\tbreak;\n\n\tif (i == 0 || i >= SMK_LONGLABEL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsmack = kzalloc(i + 1, GFP_KERNEL);\n\tif (smack == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(smack, string, i);\n\n\treturn smack;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nchar *smk_parse_smack(const char *string, int len)\n{\n\tchar *smack;\n\tint i;\n\n\tif (len <= 0)\n\t\tlen = strlen(string) + 1;\n\n\t/*\n\t * Reserve a leading '-' as an indicator that\n\t * this isn't a label, but an option to interfaces\n\t * including /smack/cipso and /smack/cipso2\n\t */\n\tif (string[0] == '-')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (string[i] > '~' || string[i] <= ' ' || string[i] == '/' ||\n\t\t    string[i] == '\"' || string[i] == '\\\\' || string[i] == '\\'')\n\t\t\tbreak;\n\n\tif (i == 0 || i >= SMK_LONGLABEL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsmack = kzalloc(i + 1, GFP_KERNEL);\n\tif (smack == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(smack, string, i);\n\n\treturn smack;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 2533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 2532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "buf",
            "count"
          ],
          "line": 2531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 2525
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic ssize_t smk_write_revoke_subj(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *data;\n\tconst char *cp;\n\tstruct smack_known *skp;\n\tstruct smack_rule *sp;\n\tstruct list_head *rule_list;\n\tstruct mutex *rule_lock;\n\tint rc = count;\n\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (count == 0 || count > SMK_LONGLABEL)\n\t\treturn -EINVAL;\n\n\tdata = memdup_user(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tcp = smk_parse_smack(data, count);\n\tif (IS_ERR(cp)) {\n\t\trc = PTR_ERR(cp);\n\t\tgoto out_data;\n\t}\n\n\tskp = smk_find_entry(cp);\n\tif (skp == NULL)\n\t\tgoto out_cp;\n\n\trule_list = &skp->smk_rules;\n\trule_lock = &skp->smk_rules_lock;\n\n\tmutex_lock(rule_lock);\n\n\tlist_for_each_entry_rcu(sp, rule_list, list)\n\t\tsp->smk_access = 0;\n\n\tmutex_unlock(rule_lock);\n\nout_cp:\n\tkfree(cp);\nout_data:\n\tkfree(data);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_write_access2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2491-2495",
    "snippet": "static ssize_t smk_write_access2(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn smk_user_access(file, buf, count, ppos, SMK_LONG_FMT);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_LONG_FMT\t1\t/* Variable long label format */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_user_access",
          "args": [
            "file",
            "buf",
            "count",
            "ppos",
            "SMK_LONG_FMT"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "smk_user_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "2286-2325",
          "snippet": "static ssize_t smk_user_access(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint res;\n\n\tdata = simple_transaction_get(file, buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\tif (count < SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t\tres = smk_parse_rule(data, &rule, 0);\n\t} else {\n\t\t/*\n\t\t * simple_transaction_get() returns null-terminated data\n\t\t */\n\t\tres = smk_parse_long_rule(data, &rule, 0, 3);\n\t}\n\n\tif (res >= 0)\n\t\tres = smk_access(rule.smk_subject, rule.smk_object,\n\t\t\t\t rule.smk_access1, NULL);\n\telse if (res != -ENOENT)\n\t\treturn res;\n\n\t/*\n\t * smk_access() can return a value > 0 in the \"bringup\" case.\n\t */\n\tdata[0] = res >= 0 ? '1' : '0';\n\tdata[1] = '\\0';\n\n\tsimple_transaction_set(file, 2);\n\n\tif (format == SMK_FIXED24_FMT)\n\t\treturn SMK_LOADLEN;\n\treturn count;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */",
            "#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)\n\nstatic ssize_t smk_user_access(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint res;\n\n\tdata = simple_transaction_get(file, buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\tif (count < SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t\tres = smk_parse_rule(data, &rule, 0);\n\t} else {\n\t\t/*\n\t\t * simple_transaction_get() returns null-terminated data\n\t\t */\n\t\tres = smk_parse_long_rule(data, &rule, 0, 3);\n\t}\n\n\tif (res >= 0)\n\t\tres = smk_access(rule.smk_subject, rule.smk_object,\n\t\t\t\t rule.smk_access1, NULL);\n\telse if (res != -ENOENT)\n\t\treturn res;\n\n\t/*\n\t * smk_access() can return a value > 0 in the \"bringup\" case.\n\t */\n\tdata[0] = res >= 0 ? '1' : '0';\n\tdata[1] = '\\0';\n\n\tsimple_transaction_set(file, 2);\n\n\tif (format == SMK_FIXED24_FMT)\n\t\treturn SMK_LOADLEN;\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_LONG_FMT\t1\t/* Variable long label format */\n\nstatic ssize_t smk_write_access2(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn smk_user_access(file, buf, count, ppos, SMK_LONG_FMT);\n}"
  },
  {
    "function_name": "smk_write_load_self2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2467-2474",
    "snippet": "static ssize_t smk_write_load_self2(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_write_rules_list(file, buf, count, ppos, &tsp->smk_rules,\n\t\t\t\t    &tsp->smk_rules_lock, SMK_LONG_FMT);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_LONG_FMT\t1\t/* Variable long label format */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_write_rules_list",
          "args": [
            "file",
            "buf",
            "count",
            "ppos",
            "&tsp->smk_rules",
            "&tsp->smk_rules_lock",
            "SMK_LONG_FMT"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "smk_write_rules_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "473-555",
          "snippet": "static ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\t\tstruct list_head *rule_list,\n\t\t\t\t\tstruct mutex *rule_lock, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint rc;\n\tint trunc = 0;\n\tint tokens;\n\tssize_t cnt = 0;\n\n\t/*\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\t/*\n\t\t * Minor hack for backward compatibility\n\t\t */\n\t\tif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (count >= PAGE_SIZE) {\n\t\t\tcount = PAGE_SIZE - 1;\n\t\t\ttrunc = 1;\n\t\t}\n\t}\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * In case of parsing only part of user buf,\n\t * avoid having partial rule at the data buffer\n\t */\n\tif (trunc) {\n\t\twhile (count > 0 && (data[count - 1] != '\\n'))\n\t\t\t--count;\n\t\tif (count == 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdata[count] = '\\0';\n\ttokens = (format == SMK_CHANGE_FMT ? 4 : 3);\n\twhile (cnt < count) {\n\t\tif (format == SMK_FIXED24_FMT) {\n\t\t\trc = smk_parse_rule(data, &rule, 1);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tcnt = count;\n\t\t} else {\n\t\t\trc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tif (rc == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcnt += rc;\n\t\t}\n\n\t\tif (rule_list == NULL)\n\t\t\trc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\n\t\t\t\t&rule.smk_subject->smk_rules_lock, 1);\n\t\telse\n\t\t\trc = smk_set_access(&rule, rule_list, rule_lock, 0);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = cnt;\nout:\n\tkfree(data);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SMK_CHANGE_FMT\t2\t/* Rule modification format */",
            "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */",
            "#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)",
            "#define SMK_OLOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_CHANGE_FMT\t2\t/* Rule modification format */\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)\n#define SMK_OLOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)\n\nstatic ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\t\tstruct list_head *rule_list,\n\t\t\t\t\tstruct mutex *rule_lock, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint rc;\n\tint trunc = 0;\n\tint tokens;\n\tssize_t cnt = 0;\n\n\t/*\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\t/*\n\t\t * Minor hack for backward compatibility\n\t\t */\n\t\tif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (count >= PAGE_SIZE) {\n\t\t\tcount = PAGE_SIZE - 1;\n\t\t\ttrunc = 1;\n\t\t}\n\t}\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * In case of parsing only part of user buf,\n\t * avoid having partial rule at the data buffer\n\t */\n\tif (trunc) {\n\t\twhile (count > 0 && (data[count - 1] != '\\n'))\n\t\t\t--count;\n\t\tif (count == 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdata[count] = '\\0';\n\ttokens = (format == SMK_CHANGE_FMT ? 4 : 3);\n\twhile (cnt < count) {\n\t\tif (format == SMK_FIXED24_FMT) {\n\t\t\trc = smk_parse_rule(data, &rule, 1);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tcnt = count;\n\t\t} else {\n\t\t\trc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tif (rc == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcnt += rc;\n\t\t}\n\n\t\tif (rule_list == NULL)\n\t\t\trc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\n\t\t\t\t&rule.smk_subject->smk_rules_lock, 1);\n\t\telse\n\t\t\trc = smk_set_access(&rule, rule_list, rule_lock, 0);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = cnt;\nout:\n\tkfree(data);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_LONG_FMT\t1\t/* Variable long label format */\n\nstatic ssize_t smk_write_load_self2(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_write_rules_list(file, buf, count, ppos, &tsp->smk_rules,\n\t\t\t\t    &tsp->smk_rules_lock, SMK_LONG_FMT);\n}"
  },
  {
    "function_name": "smk_open_load_self2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2454-2457",
    "snippet": "static int smk_open_load_self2(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &load_self2_seq_ops);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations load_self2_seq_ops = {\n\t.start = load_self2_seq_start,\n\t.next  = load_self2_seq_next,\n\t.show  = load_self2_seq_show,\n\t.stop  = smk_seq_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&load_self2_seq_ops"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic const struct seq_operations load_self2_seq_ops = {\n\t.start = load_self2_seq_start,\n\t.next  = load_self2_seq_next,\n\t.show  = load_self2_seq_show,\n\t.stop  = smk_seq_stop,\n};\n\nstatic int smk_open_load_self2(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &load_self2_seq_ops);\n}"
  },
  {
    "function_name": "load_self2_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2429-2438",
    "snippet": "static int load_self2_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smack_rule *srp =\n\t\tlist_entry_rcu(list, struct smack_rule, list);\n\n\tsmk_rule_show(s, srp, SMK_LONGLABEL);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_rule_show",
          "args": [
            "s",
            "srp",
            "SMK_LONGLABEL"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "smk_rule_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "594-631",
          "snippet": "static void smk_rule_show(struct seq_file *s, struct smack_rule *srp, int max)\n{\n\t/*\n\t * Don't show any rules with label names too long for\n\t * interface file (/smack/load or /smack/load2)\n\t * because you should expect to be able to write\n\t * anything you read back.\n\t */\n\tif (strlen(srp->smk_subject->smk_known) >= max ||\n\t    strlen(srp->smk_object->smk_known) >= max)\n\t\treturn;\n\n\tif (srp->smk_access == 0)\n\t\treturn;\n\n\tseq_printf(s, \"%s %s\",\n\t\t   srp->smk_subject->smk_known,\n\t\t   srp->smk_object->smk_known);\n\n\tseq_putc(s, ' ');\n\n\tif (srp->smk_access & MAY_READ)\n\t\tseq_putc(s, 'r');\n\tif (srp->smk_access & MAY_WRITE)\n\t\tseq_putc(s, 'w');\n\tif (srp->smk_access & MAY_EXEC)\n\t\tseq_putc(s, 'x');\n\tif (srp->smk_access & MAY_APPEND)\n\t\tseq_putc(s, 'a');\n\tif (srp->smk_access & MAY_TRANSMUTE)\n\t\tseq_putc(s, 't');\n\tif (srp->smk_access & MAY_LOCK)\n\t\tseq_putc(s, 'l');\n\tif (srp->smk_access & MAY_BRINGUP)\n\t\tseq_putc(s, 'b');\n\n\tseq_putc(s, '\\n');\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_rule_show(struct seq_file *s, struct smack_rule *srp, int max)\n{\n\t/*\n\t * Don't show any rules with label names too long for\n\t * interface file (/smack/load or /smack/load2)\n\t * because you should expect to be able to write\n\t * anything you read back.\n\t */\n\tif (strlen(srp->smk_subject->smk_known) >= max ||\n\t    strlen(srp->smk_object->smk_known) >= max)\n\t\treturn;\n\n\tif (srp->smk_access == 0)\n\t\treturn;\n\n\tseq_printf(s, \"%s %s\",\n\t\t   srp->smk_subject->smk_known,\n\t\t   srp->smk_object->smk_known);\n\n\tseq_putc(s, ' ');\n\n\tif (srp->smk_access & MAY_READ)\n\t\tseq_putc(s, 'r');\n\tif (srp->smk_access & MAY_WRITE)\n\t\tseq_putc(s, 'w');\n\tif (srp->smk_access & MAY_EXEC)\n\t\tseq_putc(s, 'x');\n\tif (srp->smk_access & MAY_APPEND)\n\t\tseq_putc(s, 'a');\n\tif (srp->smk_access & MAY_TRANSMUTE)\n\t\tseq_putc(s, 't');\n\tif (srp->smk_access & MAY_LOCK)\n\t\tseq_putc(s, 'l');\n\tif (srp->smk_access & MAY_BRINGUP)\n\t\tseq_putc(s, 'b');\n\n\tseq_putc(s, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "list",
            "structsmack_rule",
            "list"
          ],
          "line": 2433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int load_self2_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smack_rule *srp =\n\t\tlist_entry_rcu(list, struct smack_rule, list);\n\n\tsmk_rule_show(s, srp, SMK_LONGLABEL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "load_self2_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2422-2427",
    "snippet": "static void *load_self2_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_seq_next(s, v, pos, &tsp->smk_rules);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_next",
          "args": [
            "s",
            "v",
            "pos",
            "&tsp->smk_rules"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "578-587",
          "snippet": "static void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *load_self2_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_seq_next(s, v, pos, &tsp->smk_rules);\n}"
  },
  {
    "function_name": "load_self2_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2415-2420",
    "snippet": "static void *load_self2_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_seq_start(s, pos, &tsp->smk_rules);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_start",
          "args": [
            "s",
            "pos",
            "&tsp->smk_rules"
          ],
          "line": 2419
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "561-576",
          "snippet": "static void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 2417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *load_self2_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_seq_start(s, pos, &tsp->smk_rules);\n}"
  },
  {
    "function_name": "smk_write_load2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2390-2401",
    "snippet": "static ssize_t smk_write_load2(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\t/*\n\t * Must have privilege.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\treturn smk_write_rules_list(file, buf, count, ppos, NULL, NULL,\n\t\t\t\t    SMK_LONG_FMT);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_LONG_FMT\t1\t/* Variable long label format */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_write_rules_list",
          "args": [
            "file",
            "buf",
            "count",
            "ppos",
            "NULL",
            "NULL",
            "SMK_LONG_FMT"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "smk_write_rules_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "473-555",
          "snippet": "static ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\t\tstruct list_head *rule_list,\n\t\t\t\t\tstruct mutex *rule_lock, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint rc;\n\tint trunc = 0;\n\tint tokens;\n\tssize_t cnt = 0;\n\n\t/*\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\t/*\n\t\t * Minor hack for backward compatibility\n\t\t */\n\t\tif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (count >= PAGE_SIZE) {\n\t\t\tcount = PAGE_SIZE - 1;\n\t\t\ttrunc = 1;\n\t\t}\n\t}\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * In case of parsing only part of user buf,\n\t * avoid having partial rule at the data buffer\n\t */\n\tif (trunc) {\n\t\twhile (count > 0 && (data[count - 1] != '\\n'))\n\t\t\t--count;\n\t\tif (count == 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdata[count] = '\\0';\n\ttokens = (format == SMK_CHANGE_FMT ? 4 : 3);\n\twhile (cnt < count) {\n\t\tif (format == SMK_FIXED24_FMT) {\n\t\t\trc = smk_parse_rule(data, &rule, 1);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tcnt = count;\n\t\t} else {\n\t\t\trc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tif (rc == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcnt += rc;\n\t\t}\n\n\t\tif (rule_list == NULL)\n\t\t\trc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\n\t\t\t\t&rule.smk_subject->smk_rules_lock, 1);\n\t\telse\n\t\t\trc = smk_set_access(&rule, rule_list, rule_lock, 0);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = cnt;\nout:\n\tkfree(data);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SMK_CHANGE_FMT\t2\t/* Rule modification format */",
            "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */",
            "#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)",
            "#define SMK_OLOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_CHANGE_FMT\t2\t/* Rule modification format */\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)\n#define SMK_OLOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)\n\nstatic ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\t\tstruct list_head *rule_list,\n\t\t\t\t\tstruct mutex *rule_lock, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint rc;\n\tint trunc = 0;\n\tint tokens;\n\tssize_t cnt = 0;\n\n\t/*\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\t/*\n\t\t * Minor hack for backward compatibility\n\t\t */\n\t\tif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (count >= PAGE_SIZE) {\n\t\t\tcount = PAGE_SIZE - 1;\n\t\t\ttrunc = 1;\n\t\t}\n\t}\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * In case of parsing only part of user buf,\n\t * avoid having partial rule at the data buffer\n\t */\n\tif (trunc) {\n\t\twhile (count > 0 && (data[count - 1] != '\\n'))\n\t\t\t--count;\n\t\tif (count == 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdata[count] = '\\0';\n\ttokens = (format == SMK_CHANGE_FMT ? 4 : 3);\n\twhile (cnt < count) {\n\t\tif (format == SMK_FIXED24_FMT) {\n\t\t\trc = smk_parse_rule(data, &rule, 1);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tcnt = count;\n\t\t} else {\n\t\t\trc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tif (rc == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcnt += rc;\n\t\t}\n\n\t\tif (rule_list == NULL)\n\t\t\trc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\n\t\t\t\t&rule.smk_subject->smk_rules_lock, 1);\n\t\telse\n\t\t\trc = smk_set_access(&rule, rule_list, rule_lock, 0);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = cnt;\nout:\n\tkfree(data);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 2396
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_LONG_FMT\t1\t/* Variable long label format */\n\nstatic ssize_t smk_write_load2(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\t/*\n\t * Must have privilege.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\treturn smk_write_rules_list(file, buf, count, ppos, NULL, NULL,\n\t\t\t\t    SMK_LONG_FMT);\n}"
  },
  {
    "function_name": "smk_open_load2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2377-2380",
    "snippet": "static int smk_open_load2(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &load2_seq_ops);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations load2_seq_ops = {\n\t.start = load2_seq_start,\n\t.next  = load2_seq_next,\n\t.show  = load2_seq_show,\n\t.stop  = smk_seq_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&load2_seq_ops"
          ],
          "line": 2379
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic const struct seq_operations load2_seq_ops = {\n\t.start = load2_seq_start,\n\t.next  = load2_seq_next,\n\t.show  = load2_seq_show,\n\t.stop  = smk_seq_stop,\n};\n\nstatic int smk_open_load2(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &load2_seq_ops);\n}"
  },
  {
    "function_name": "load2_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2352-2361",
    "snippet": "static int load2_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smack_master_list *smlp =\n\t\tlist_entry_rcu(list, struct smack_master_list, list);\n\n\tsmk_rule_show(s, smlp->smk_rule, SMK_LONGLABEL);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_rule_show",
          "args": [
            "s",
            "smlp->smk_rule",
            "SMK_LONGLABEL"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "smk_rule_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "594-631",
          "snippet": "static void smk_rule_show(struct seq_file *s, struct smack_rule *srp, int max)\n{\n\t/*\n\t * Don't show any rules with label names too long for\n\t * interface file (/smack/load or /smack/load2)\n\t * because you should expect to be able to write\n\t * anything you read back.\n\t */\n\tif (strlen(srp->smk_subject->smk_known) >= max ||\n\t    strlen(srp->smk_object->smk_known) >= max)\n\t\treturn;\n\n\tif (srp->smk_access == 0)\n\t\treturn;\n\n\tseq_printf(s, \"%s %s\",\n\t\t   srp->smk_subject->smk_known,\n\t\t   srp->smk_object->smk_known);\n\n\tseq_putc(s, ' ');\n\n\tif (srp->smk_access & MAY_READ)\n\t\tseq_putc(s, 'r');\n\tif (srp->smk_access & MAY_WRITE)\n\t\tseq_putc(s, 'w');\n\tif (srp->smk_access & MAY_EXEC)\n\t\tseq_putc(s, 'x');\n\tif (srp->smk_access & MAY_APPEND)\n\t\tseq_putc(s, 'a');\n\tif (srp->smk_access & MAY_TRANSMUTE)\n\t\tseq_putc(s, 't');\n\tif (srp->smk_access & MAY_LOCK)\n\t\tseq_putc(s, 'l');\n\tif (srp->smk_access & MAY_BRINGUP)\n\t\tseq_putc(s, 'b');\n\n\tseq_putc(s, '\\n');\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_rule_show(struct seq_file *s, struct smack_rule *srp, int max)\n{\n\t/*\n\t * Don't show any rules with label names too long for\n\t * interface file (/smack/load or /smack/load2)\n\t * because you should expect to be able to write\n\t * anything you read back.\n\t */\n\tif (strlen(srp->smk_subject->smk_known) >= max ||\n\t    strlen(srp->smk_object->smk_known) >= max)\n\t\treturn;\n\n\tif (srp->smk_access == 0)\n\t\treturn;\n\n\tseq_printf(s, \"%s %s\",\n\t\t   srp->smk_subject->smk_known,\n\t\t   srp->smk_object->smk_known);\n\n\tseq_putc(s, ' ');\n\n\tif (srp->smk_access & MAY_READ)\n\t\tseq_putc(s, 'r');\n\tif (srp->smk_access & MAY_WRITE)\n\t\tseq_putc(s, 'w');\n\tif (srp->smk_access & MAY_EXEC)\n\t\tseq_putc(s, 'x');\n\tif (srp->smk_access & MAY_APPEND)\n\t\tseq_putc(s, 'a');\n\tif (srp->smk_access & MAY_TRANSMUTE)\n\t\tseq_putc(s, 't');\n\tif (srp->smk_access & MAY_LOCK)\n\t\tseq_putc(s, 'l');\n\tif (srp->smk_access & MAY_BRINGUP)\n\t\tseq_putc(s, 'b');\n\n\tseq_putc(s, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "list",
            "structsmack_master_list",
            "list"
          ],
          "line": 2356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int load2_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smack_master_list *smlp =\n\t\tlist_entry_rcu(list, struct smack_master_list, list);\n\n\tsmk_rule_show(s, smlp->smk_rule, SMK_LONGLABEL);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_write_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2334-2338",
    "snippet": "static ssize_t smk_write_access(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn smk_user_access(file, buf, count, ppos, SMK_FIXED24_FMT);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_user_access",
          "args": [
            "file",
            "buf",
            "count",
            "ppos",
            "SMK_FIXED24_FMT"
          ],
          "line": 2337
        },
        "resolved": true,
        "details": {
          "function_name": "smk_user_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "2286-2325",
          "snippet": "static ssize_t smk_user_access(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint res;\n\n\tdata = simple_transaction_get(file, buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\tif (count < SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t\tres = smk_parse_rule(data, &rule, 0);\n\t} else {\n\t\t/*\n\t\t * simple_transaction_get() returns null-terminated data\n\t\t */\n\t\tres = smk_parse_long_rule(data, &rule, 0, 3);\n\t}\n\n\tif (res >= 0)\n\t\tres = smk_access(rule.smk_subject, rule.smk_object,\n\t\t\t\t rule.smk_access1, NULL);\n\telse if (res != -ENOENT)\n\t\treturn res;\n\n\t/*\n\t * smk_access() can return a value > 0 in the \"bringup\" case.\n\t */\n\tdata[0] = res >= 0 ? '1' : '0';\n\tdata[1] = '\\0';\n\n\tsimple_transaction_set(file, 2);\n\n\tif (format == SMK_FIXED24_FMT)\n\t\treturn SMK_LOADLEN;\n\treturn count;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */",
            "#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)\n\nstatic ssize_t smk_user_access(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint res;\n\n\tdata = simple_transaction_get(file, buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\tif (count < SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t\tres = smk_parse_rule(data, &rule, 0);\n\t} else {\n\t\t/*\n\t\t * simple_transaction_get() returns null-terminated data\n\t\t */\n\t\tres = smk_parse_long_rule(data, &rule, 0, 3);\n\t}\n\n\tif (res >= 0)\n\t\tres = smk_access(rule.smk_subject, rule.smk_object,\n\t\t\t\t rule.smk_access1, NULL);\n\telse if (res != -ENOENT)\n\t\treturn res;\n\n\t/*\n\t * smk_access() can return a value > 0 in the \"bringup\" case.\n\t */\n\tdata[0] = res >= 0 ? '1' : '0';\n\tdata[1] = '\\0';\n\n\tsimple_transaction_set(file, 2);\n\n\tif (format == SMK_FIXED24_FMT)\n\t\treturn SMK_LOADLEN;\n\treturn count;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n\nstatic ssize_t smk_write_access(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\treturn smk_user_access(file, buf, count, ppos, SMK_FIXED24_FMT);\n}"
  },
  {
    "function_name": "smk_user_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2286-2325",
    "snippet": "static ssize_t smk_user_access(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint res;\n\n\tdata = simple_transaction_get(file, buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\tif (count < SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t\tres = smk_parse_rule(data, &rule, 0);\n\t} else {\n\t\t/*\n\t\t * simple_transaction_get() returns null-terminated data\n\t\t */\n\t\tres = smk_parse_long_rule(data, &rule, 0, 3);\n\t}\n\n\tif (res >= 0)\n\t\tres = smk_access(rule.smk_subject, rule.smk_object,\n\t\t\t\t rule.smk_access1, NULL);\n\telse if (res != -ENOENT)\n\t\treturn res;\n\n\t/*\n\t * smk_access() can return a value > 0 in the \"bringup\" case.\n\t */\n\tdata[0] = res >= 0 ? '1' : '0';\n\tdata[1] = '\\0';\n\n\tsimple_transaction_set(file, 2);\n\n\tif (format == SMK_FIXED24_FMT)\n\t\treturn SMK_LOADLEN;\n\treturn count;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */",
      "#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_transaction_set",
          "args": [
            "file",
            "2"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_access",
          "args": [
            "rule.smk_subject",
            "rule.smk_object",
            "rule.smk_access1",
            "NULL"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "smk_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "120-209",
          "snippet": "int smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};",
            "struct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};",
            "struct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};",
            "struct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct smack_known smack_known_hat = {\n\t.smk_known\t= \"^\",\n\t.smk_secid\t= 3,\n};\nstruct smack_known smack_known_star = {\n\t.smk_known\t= \"*\",\n\t.smk_secid\t= 4,\n};\nstruct smack_known smack_known_floor = {\n\t.smk_known\t= \"_\",\n\t.smk_secid\t= 5,\n};\nstruct smack_known smack_known_web = {\n\t.smk_known\t= \"@\",\n\t.smk_secid\t= 7,\n};\n\nint smk_access(struct smack_known *subject, struct smack_known *object,\n\t       int request, struct smk_audit_info *a)\n{\n\tint may = MAY_NOT;\n\tint rc = 0;\n\n\t/*\n\t * Hardcoded comparisons.\n\t */\n\t/*\n\t * A star subject can't access any object.\n\t */\n\tif (subject == &smack_known_star) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n\t/*\n\t * An internet object can be accessed by any subject.\n\t * Tasks cannot be assigned the internet label.\n\t * An internet subject can access any object.\n\t */\n\tif (object == &smack_known_web || subject == &smack_known_web)\n\t\tgoto out_audit;\n\t/*\n\t * A star object can be accessed by any subject.\n\t */\n\tif (object == &smack_known_star)\n\t\tgoto out_audit;\n\t/*\n\t * An object can be accessed in any way by a subject\n\t * with the same label.\n\t */\n\tif (subject->smk_known == object->smk_known)\n\t\tgoto out_audit;\n\t/*\n\t * A hat subject can read or lock any object.\n\t * A floor object can be read or locked by any subject.\n\t */\n\tif ((request & MAY_ANYREAD) == request ||\n\t    (request & MAY_LOCK) == request) {\n\t\tif (object == &smack_known_floor)\n\t\t\tgoto out_audit;\n\t\tif (subject == &smack_known_hat)\n\t\t\tgoto out_audit;\n\t}\n\t/*\n\t * Beyond here an explicit relationship is required.\n\t * If the requested access is contained in the available\n\t * access (e.g. read is included in readwrite) it's\n\t * good. A negative response from smk_access_entry()\n\t * indicates there is no entry for this pair.\n\t */\n\trcu_read_lock();\n\tmay = smk_access_entry(subject->smk_known, object->smk_known,\n\t\t\t       &subject->smk_rules);\n\trcu_read_unlock();\n\n\tif (may <= 0 || (request & may) != request) {\n\t\trc = -EACCES;\n\t\tgoto out_audit;\n\t}\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\t/*\n\t * Return a positive value if using bringup mode.\n\t * This allows the hooks to identify checks that\n\t * succeed because of \"b\" rules.\n\t */\n\tif (may & MAY_BRINGUP)\n\t\trc = SMACK_BRINGUP_ALLOW;\n#endif\n\nout_audit:\n\n#ifdef CONFIG_SECURITY_SMACK_BRINGUP\n\tif (rc < 0) {\n\t\tif (object == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_OBJECT;\n\t\tif (subject == smack_unconfined)\n\t\t\trc = SMACK_UNCONFINED_SUBJECT;\n\t}\n#endif\n\n#ifdef CONFIG_AUDIT\n\tif (a)\n\t\tsmack_log(subject->smk_known, object->smk_known,\n\t\t\t  request, rc, a);\n#endif\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_parse_long_rule",
          "args": [
            "data",
            "&rule",
            "0",
            "3"
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "smk_parse_long_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "417-449",
          "snippet": "static ssize_t smk_parse_long_rule(char *data, struct smack_parsed_rule *rule,\n\t\t\t\tint import, int tokens)\n{\n\tssize_t cnt = 0;\n\tchar *tok[4];\n\tint rc;\n\tint i;\n\n\t/*\n\t * Parsing the rule in-place, filling all white-spaces with '\\0'\n\t */\n\tfor (i = 0; i < tokens; ++i) {\n\t\twhile (isspace(data[cnt]))\n\t\t\tdata[cnt++] = '\\0';\n\n\t\tif (data[cnt] == '\\0')\n\t\t\t/* Unexpected end of data */\n\t\t\treturn -EINVAL;\n\n\t\ttok[i] = data + cnt;\n\n\t\twhile (data[cnt] && !isspace(data[cnt]))\n\t\t\t++cnt;\n\t}\n\twhile (isspace(data[cnt]))\n\t\tdata[cnt++] = '\\0';\n\n\twhile (i < 4)\n\t\ttok[i++] = NULL;\n\n\trc = smk_fill_rule(tok[0], tok[1], tok[2], tok[3], rule, import, 0);\n\treturn rc == 0 ? cnt : rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic ssize_t smk_parse_long_rule(char *data, struct smack_parsed_rule *rule,\n\t\t\t\tint import, int tokens)\n{\n\tssize_t cnt = 0;\n\tchar *tok[4];\n\tint rc;\n\tint i;\n\n\t/*\n\t * Parsing the rule in-place, filling all white-spaces with '\\0'\n\t */\n\tfor (i = 0; i < tokens; ++i) {\n\t\twhile (isspace(data[cnt]))\n\t\t\tdata[cnt++] = '\\0';\n\n\t\tif (data[cnt] == '\\0')\n\t\t\t/* Unexpected end of data */\n\t\t\treturn -EINVAL;\n\n\t\ttok[i] = data + cnt;\n\n\t\twhile (data[cnt] && !isspace(data[cnt]))\n\t\t\t++cnt;\n\t}\n\twhile (isspace(data[cnt]))\n\t\tdata[cnt++] = '\\0';\n\n\twhile (i < 4)\n\t\ttok[i++] = NULL;\n\n\trc = smk_fill_rule(tok[0], tok[1], tok[2], tok[3], rule, import, 0);\n\treturn rc == 0 ? cnt : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_parse_rule",
          "args": [
            "data",
            "&rule",
            "0"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "smk_parse_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "397-406",
          "snippet": "static int smk_parse_rule(const char *data, struct smack_parsed_rule *rule,\n\t\t\t\tint import)\n{\n\tint rc;\n\n\trc = smk_fill_rule(data, data + SMK_LABELLEN,\n\t\t\t   data + SMK_LABELLEN + SMK_LABELLEN, NULL, rule,\n\t\t\t   import, SMK_LABELLEN);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_parse_rule(const char *data, struct smack_parsed_rule *rule,\n\t\t\t\tint import)\n{\n\tint rc;\n\n\trc = smk_fill_rule(data, data + SMK_LABELLEN,\n\t\t\t   data + SMK_LABELLEN + SMK_LABELLEN, NULL, rule,\n\t\t\t   import, SMK_LABELLEN);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 2294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_transaction_get",
          "args": [
            "file",
            "buf",
            "count"
          ],
          "line": 2293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)\n\nstatic ssize_t smk_user_access(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint res;\n\n\tdata = simple_transaction_get(file, buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\tif (count < SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t\tres = smk_parse_rule(data, &rule, 0);\n\t} else {\n\t\t/*\n\t\t * simple_transaction_get() returns null-terminated data\n\t\t */\n\t\tres = smk_parse_long_rule(data, &rule, 0, 3);\n\t}\n\n\tif (res >= 0)\n\t\tres = smk_access(rule.smk_subject, rule.smk_object,\n\t\t\t\t rule.smk_access1, NULL);\n\telse if (res != -ENOENT)\n\t\treturn res;\n\n\t/*\n\t * smk_access() can return a value > 0 in the \"bringup\" case.\n\t */\n\tdata[0] = res >= 0 ? '1' : '0';\n\tdata[1] = '\\0';\n\n\tsimple_transaction_set(file, 2);\n\n\tif (format == SMK_FIXED24_FMT)\n\t\treturn SMK_LOADLEN;\n\treturn count;\n}"
  },
  {
    "function_name": "smk_write_load_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2262-2269",
    "snippet": "static ssize_t smk_write_load_self(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_write_rules_list(file, buf, count, ppos, &tsp->smk_rules,\n\t\t\t\t    &tsp->smk_rules_lock, SMK_FIXED24_FMT);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_write_rules_list",
          "args": [
            "file",
            "buf",
            "count",
            "ppos",
            "&tsp->smk_rules",
            "&tsp->smk_rules_lock",
            "SMK_FIXED24_FMT"
          ],
          "line": 2267
        },
        "resolved": true,
        "details": {
          "function_name": "smk_write_rules_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "473-555",
          "snippet": "static ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\t\tstruct list_head *rule_list,\n\t\t\t\t\tstruct mutex *rule_lock, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint rc;\n\tint trunc = 0;\n\tint tokens;\n\tssize_t cnt = 0;\n\n\t/*\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\t/*\n\t\t * Minor hack for backward compatibility\n\t\t */\n\t\tif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (count >= PAGE_SIZE) {\n\t\t\tcount = PAGE_SIZE - 1;\n\t\t\ttrunc = 1;\n\t\t}\n\t}\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * In case of parsing only part of user buf,\n\t * avoid having partial rule at the data buffer\n\t */\n\tif (trunc) {\n\t\twhile (count > 0 && (data[count - 1] != '\\n'))\n\t\t\t--count;\n\t\tif (count == 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdata[count] = '\\0';\n\ttokens = (format == SMK_CHANGE_FMT ? 4 : 3);\n\twhile (cnt < count) {\n\t\tif (format == SMK_FIXED24_FMT) {\n\t\t\trc = smk_parse_rule(data, &rule, 1);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tcnt = count;\n\t\t} else {\n\t\t\trc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tif (rc == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcnt += rc;\n\t\t}\n\n\t\tif (rule_list == NULL)\n\t\t\trc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\n\t\t\t\t&rule.smk_subject->smk_rules_lock, 1);\n\t\telse\n\t\t\trc = smk_set_access(&rule, rule_list, rule_lock, 0);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = cnt;\nout:\n\tkfree(data);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SMK_CHANGE_FMT\t2\t/* Rule modification format */",
            "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */",
            "#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)",
            "#define SMK_OLOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_CHANGE_FMT\t2\t/* Rule modification format */\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)\n#define SMK_OLOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)\n\nstatic ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\t\tstruct list_head *rule_list,\n\t\t\t\t\tstruct mutex *rule_lock, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint rc;\n\tint trunc = 0;\n\tint tokens;\n\tssize_t cnt = 0;\n\n\t/*\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\t/*\n\t\t * Minor hack for backward compatibility\n\t\t */\n\t\tif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (count >= PAGE_SIZE) {\n\t\t\tcount = PAGE_SIZE - 1;\n\t\t\ttrunc = 1;\n\t\t}\n\t}\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * In case of parsing only part of user buf,\n\t * avoid having partial rule at the data buffer\n\t */\n\tif (trunc) {\n\t\twhile (count > 0 && (data[count - 1] != '\\n'))\n\t\t\t--count;\n\t\tif (count == 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdata[count] = '\\0';\n\ttokens = (format == SMK_CHANGE_FMT ? 4 : 3);\n\twhile (cnt < count) {\n\t\tif (format == SMK_FIXED24_FMT) {\n\t\t\trc = smk_parse_rule(data, &rule, 1);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tcnt = count;\n\t\t} else {\n\t\t\trc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tif (rc == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcnt += rc;\n\t\t}\n\n\t\tif (rule_list == NULL)\n\t\t\trc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\n\t\t\t\t&rule.smk_subject->smk_rules_lock, 1);\n\t\telse\n\t\t\trc = smk_set_access(&rule, rule_list, rule_lock, 0);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = cnt;\nout:\n\tkfree(data);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 2265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n\nstatic ssize_t smk_write_load_self(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_write_rules_list(file, buf, count, ppos, &tsp->smk_rules,\n\t\t\t\t    &tsp->smk_rules_lock, SMK_FIXED24_FMT);\n}"
  },
  {
    "function_name": "smk_open_load_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2249-2252",
    "snippet": "static int smk_open_load_self(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &load_self_seq_ops);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations load_self_seq_ops = {\n\t.start = load_self_seq_start,\n\t.next  = load_self_seq_next,\n\t.show  = load_self_seq_show,\n\t.stop  = smk_seq_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&load_self_seq_ops"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic const struct seq_operations load_self_seq_ops = {\n\t.start = load_self_seq_start,\n\t.next  = load_self_seq_next,\n\t.show  = load_self_seq_show,\n\t.stop  = smk_seq_stop,\n};\n\nstatic int smk_open_load_self(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &load_self_seq_ops);\n}"
  },
  {
    "function_name": "load_self_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2223-2232",
    "snippet": "static int load_self_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smack_rule *srp =\n\t\tlist_entry_rcu(list, struct smack_rule, list);\n\n\tsmk_rule_show(s, srp, SMK_LABELLEN);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_rule_show",
          "args": [
            "s",
            "srp",
            "SMK_LABELLEN"
          ],
          "line": 2229
        },
        "resolved": true,
        "details": {
          "function_name": "smk_rule_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "594-631",
          "snippet": "static void smk_rule_show(struct seq_file *s, struct smack_rule *srp, int max)\n{\n\t/*\n\t * Don't show any rules with label names too long for\n\t * interface file (/smack/load or /smack/load2)\n\t * because you should expect to be able to write\n\t * anything you read back.\n\t */\n\tif (strlen(srp->smk_subject->smk_known) >= max ||\n\t    strlen(srp->smk_object->smk_known) >= max)\n\t\treturn;\n\n\tif (srp->smk_access == 0)\n\t\treturn;\n\n\tseq_printf(s, \"%s %s\",\n\t\t   srp->smk_subject->smk_known,\n\t\t   srp->smk_object->smk_known);\n\n\tseq_putc(s, ' ');\n\n\tif (srp->smk_access & MAY_READ)\n\t\tseq_putc(s, 'r');\n\tif (srp->smk_access & MAY_WRITE)\n\t\tseq_putc(s, 'w');\n\tif (srp->smk_access & MAY_EXEC)\n\t\tseq_putc(s, 'x');\n\tif (srp->smk_access & MAY_APPEND)\n\t\tseq_putc(s, 'a');\n\tif (srp->smk_access & MAY_TRANSMUTE)\n\t\tseq_putc(s, 't');\n\tif (srp->smk_access & MAY_LOCK)\n\t\tseq_putc(s, 'l');\n\tif (srp->smk_access & MAY_BRINGUP)\n\t\tseq_putc(s, 'b');\n\n\tseq_putc(s, '\\n');\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_rule_show(struct seq_file *s, struct smack_rule *srp, int max)\n{\n\t/*\n\t * Don't show any rules with label names too long for\n\t * interface file (/smack/load or /smack/load2)\n\t * because you should expect to be able to write\n\t * anything you read back.\n\t */\n\tif (strlen(srp->smk_subject->smk_known) >= max ||\n\t    strlen(srp->smk_object->smk_known) >= max)\n\t\treturn;\n\n\tif (srp->smk_access == 0)\n\t\treturn;\n\n\tseq_printf(s, \"%s %s\",\n\t\t   srp->smk_subject->smk_known,\n\t\t   srp->smk_object->smk_known);\n\n\tseq_putc(s, ' ');\n\n\tif (srp->smk_access & MAY_READ)\n\t\tseq_putc(s, 'r');\n\tif (srp->smk_access & MAY_WRITE)\n\t\tseq_putc(s, 'w');\n\tif (srp->smk_access & MAY_EXEC)\n\t\tseq_putc(s, 'x');\n\tif (srp->smk_access & MAY_APPEND)\n\t\tseq_putc(s, 'a');\n\tif (srp->smk_access & MAY_TRANSMUTE)\n\t\tseq_putc(s, 't');\n\tif (srp->smk_access & MAY_LOCK)\n\t\tseq_putc(s, 'l');\n\tif (srp->smk_access & MAY_BRINGUP)\n\t\tseq_putc(s, 'b');\n\n\tseq_putc(s, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "list",
            "structsmack_rule",
            "list"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int load_self_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smack_rule *srp =\n\t\tlist_entry_rcu(list, struct smack_rule, list);\n\n\tsmk_rule_show(s, srp, SMK_LABELLEN);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "load_self_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2216-2221",
    "snippet": "static void *load_self_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_seq_next(s, v, pos, &tsp->smk_rules);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_next",
          "args": [
            "s",
            "v",
            "pos",
            "&tsp->smk_rules"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "578-587",
          "snippet": "static void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *load_self_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_seq_next(s, v, pos, &tsp->smk_rules);\n}"
  },
  {
    "function_name": "load_self_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2209-2214",
    "snippet": "static void *load_self_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_seq_start(s, pos, &tsp->smk_rules);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_start",
          "args": [
            "s",
            "pos",
            "&tsp->smk_rules"
          ],
          "line": 2213
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "561-576",
          "snippet": "static void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 2211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *load_self_seq_start(struct seq_file *s, loff_t *pos)\n{\n\tstruct task_smack *tsp = current_security();\n\n\treturn smk_seq_start(s, pos, &tsp->smk_rules);\n}"
  },
  {
    "function_name": "smk_write_logging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2172-2195",
    "snippet": "static ssize_t smk_write_logging(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar temp[32];\n\tint i;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (count >= sizeof(temp) || count == 0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(temp, buf, count) != 0)\n\t\treturn -EFAULT;\n\n\ttemp[count] = '\\0';\n\n\tif (sscanf(temp, \"%d\", &i) != 1)\n\t\treturn -EINVAL;\n\tif (i < 0 || i > 3)\n\t\treturn -EINVAL;\n\tlog_policy = i;\n\treturn count;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "temp",
            "\"%d\"",
            "&i"
          ],
          "line": 2189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "temp",
            "buf",
            "count"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic ssize_t smk_write_logging(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar temp[32];\n\tint i;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (count >= sizeof(temp) || count == 0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(temp, buf, count) != 0)\n\t\treturn -EFAULT;\n\n\ttemp[count] = '\\0';\n\n\tif (sscanf(temp, \"%d\", &i) != 1)\n\t\treturn -EINVAL;\n\tif (i < 0 || i > 3)\n\t\treturn -EINVAL;\n\tlog_policy = i;\n\treturn count;\n}"
  },
  {
    "function_name": "smk_read_logging",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2149-2161",
    "snippet": "static ssize_t smk_read_logging(struct file *filp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar temp[32];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\\n\", log_policy);\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "temp",
            "strlen(temp)"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "temp"
          ],
          "line": 2159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "temp",
            "\"%d\\n\"",
            "log_policy"
          ],
          "line": 2158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic ssize_t smk_read_logging(struct file *filp, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar temp[32];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\\n\", log_policy);\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_write_unconfined",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2095-2131",
    "snippet": "static ssize_t smk_write_unconfined(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *data;\n\tstruct smack_known *skp;\n\tint rc = count;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * Clear the smack_unconfined on invalid label errors. This means\n\t * that we can pass a null string to unset the unconfined value.\n\t *\n\t * Importing will also reject a label beginning with '-',\n\t * so \"-confine\" will also work.\n\t *\n\t * But do so only on invalid label, not on system errors.\n\t */\n\tskp = smk_import_entry(data, count);\n\tif (PTR_ERR(skp) == -EINVAL)\n\t\tskp = NULL;\n\telse if (IS_ERR(skp)) {\n\t\trc = PTR_ERR(skp);\n\t\tgoto freeout;\n\t}\n\n\tsmack_unconfined = skp;\n\nfreeout:\n\tkfree(data);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 2122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 2121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "data",
            "count"
          ],
          "line": 2118
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 2107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic ssize_t smk_write_unconfined(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tchar *data;\n\tstruct smack_known *skp;\n\tint rc = count;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * Clear the smack_unconfined on invalid label errors. This means\n\t * that we can pass a null string to unset the unconfined value.\n\t *\n\t * Importing will also reject a label beginning with '-',\n\t * so \"-confine\" will also work.\n\t *\n\t * But do so only on invalid label, not on system errors.\n\t */\n\tskp = smk_import_entry(data, count);\n\tif (PTR_ERR(skp) == -EINVAL)\n\t\tskp = NULL;\n\telse if (IS_ERR(skp)) {\n\t\trc = PTR_ERR(skp);\n\t\tgoto freeout;\n\t}\n\n\tsmack_unconfined = skp;\n\nfreeout:\n\tkfree(data);\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_read_unconfined",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2065-2084",
    "snippet": "static ssize_t smk_read_unconfined(struct file *filp, char __user *buf,\n\t\t\t\t\tsize_t cn, loff_t *ppos)\n{\n\tchar *smack = \"\";\n\tssize_t rc = -EINVAL;\n\tint asize;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tif (smack_unconfined != NULL)\n\t\tsmack = smack_unconfined->smk_known;\n\n\tasize = strlen(smack) + 1;\n\n\tif (cn >= asize)\n\t\trc = simple_read_from_buffer(buf, cn, ppos, smack, asize);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "cn",
            "ppos",
            "smack",
            "asize"
          ],
          "line": 2081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "smack"
          ],
          "line": 2078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic ssize_t smk_read_unconfined(struct file *filp, char __user *buf,\n\t\t\t\t\tsize_t cn, loff_t *ppos)\n{\n\tchar *smack = \"\";\n\tssize_t rc = -EINVAL;\n\tint asize;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tif (smack_unconfined != NULL)\n\t\tsmack = smack_unconfined->smk_known;\n\n\tasize = strlen(smack) + 1;\n\n\tif (cn >= asize)\n\t\trc = simple_read_from_buffer(buf, cn, ppos, smack, asize);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_write_onlycap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "2008-2045",
    "snippet": "static ssize_t smk_write_onlycap(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tchar *data;\n\tLIST_HEAD(list_tmp);\n\tint rc;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trc = smk_parse_label_list(data, &list_tmp);\n\tkfree(data);\n\n\t/*\n\t * Clear the smack_onlycap on invalid label errors. This means\n\t * that we can pass a null string to unset the onlycap value.\n\t *\n\t * Importing will also reject a label beginning with '-',\n\t * so \"-usecapabilities\" will also work.\n\t *\n\t * But do so only on invalid label, not on system errors.\n\t * The invalid label must be first to count as clearing attempt.\n\t */\n\tif (!rc || (rc == -EINVAL && list_empty(&list_tmp))) {\n\t\tmutex_lock(&smack_onlycap_lock);\n\t\tsmk_list_swap_rcu(&smack_onlycap_list, &list_tmp);\n\t\tmutex_unlock(&smack_onlycap_lock);\n\t\trc = count;\n\t}\n\n\tsmk_destroy_label_list(&list_tmp);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_destroy_label_list",
          "args": [
            "&list_tmp"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "smk_destroy_label_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "1988-1997",
          "snippet": "void smk_destroy_label_list(struct list_head *list)\n{\n\tstruct smack_known_list_elem *sklep;\n\tstruct smack_known_list_elem *sklep2;\n\n\tlist_for_each_entry_safe(sklep, sklep2, list, list)\n\t\tkfree(sklep);\n\n\tINIT_LIST_HEAD(list);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nvoid smk_destroy_label_list(struct list_head *list)\n{\n\tstruct smack_known_list_elem *sklep;\n\tstruct smack_known_list_elem *sklep2;\n\n\tlist_for_each_entry_safe(sklep, sklep2, list, list)\n\t\tkfree(sklep);\n\n\tINIT_LIST_HEAD(list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&smack_onlycap_lock"
          ],
          "line": 2038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_list_swap_rcu",
          "args": [
            "&smack_onlycap_list",
            "&list_tmp"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "smk_list_swap_rcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "1922-1949",
          "snippet": "static void smk_list_swap_rcu(struct list_head *public,\n\t\t\t      struct list_head *private)\n{\n\tstruct list_head *first, *last;\n\n\tif (list_empty(public)) {\n\t\tlist_splice_init_rcu(private, public, synchronize_rcu);\n\t} else {\n\t\t/* Remember public list before replacing it */\n\t\tfirst = public->next;\n\t\tlast = public->prev;\n\n\t\t/* Publish private list in place of public in RCU-safe way */\n\t\tprivate->prev->next = public;\n\t\tprivate->next->prev = public;\n\t\trcu_assign_pointer(public->next, private->next);\n\t\tpublic->prev = private->prev;\n\n\t\tsynchronize_rcu();\n\n\t\t/* When all readers are done with the old public list,\n\t\t * attach it in place of private */\n\t\tprivate->next = first;\n\t\tprivate->prev = last;\n\t\tfirst->prev = private;\n\t\tlast->next = private;\n\t}\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_list_swap_rcu(struct list_head *public,\n\t\t\t      struct list_head *private)\n{\n\tstruct list_head *first, *last;\n\n\tif (list_empty(public)) {\n\t\tlist_splice_init_rcu(private, public, synchronize_rcu);\n\t} else {\n\t\t/* Remember public list before replacing it */\n\t\tfirst = public->next;\n\t\tlast = public->prev;\n\n\t\t/* Publish private list in place of public in RCU-safe way */\n\t\tprivate->prev->next = public;\n\t\tprivate->next->prev = public;\n\t\trcu_assign_pointer(public->next, private->next);\n\t\tpublic->prev = private->prev;\n\n\t\tsynchronize_rcu();\n\n\t\t/* When all readers are done with the old public list,\n\t\t * attach it in place of private */\n\t\tprivate->next = first;\n\t\tprivate->prev = last;\n\t\tfirst->prev = private;\n\t\tlast->next = private;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&smack_onlycap_lock"
          ],
          "line": 2036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&list_tmp"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 2023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_parse_label_list",
          "args": [
            "data",
            "&list_tmp"
          ],
          "line": 2022
        },
        "resolved": true,
        "details": {
          "function_name": "smk_parse_label_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "1959-1982",
          "snippet": "static int smk_parse_label_list(char *data, struct list_head *list)\n{\n\tchar *tok;\n\tstruct smack_known *skp;\n\tstruct smack_known_list_elem *sklep;\n\n\twhile ((tok = strsep(&data, \" \")) != NULL) {\n\t\tif (!*tok)\n\t\t\tcontinue;\n\n\t\tskp = smk_import_entry(tok, 0);\n\t\tif (IS_ERR(skp))\n\t\t\treturn PTR_ERR(skp);\n\n\t\tsklep = kzalloc(sizeof(*sklep), GFP_KERNEL);\n\t\tif (sklep == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tsklep->smk_label = skp;\n\t\tlist_add(&sklep->list, list);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_parse_label_list(char *data, struct list_head *list)\n{\n\tchar *tok;\n\tstruct smack_known *skp;\n\tstruct smack_known_list_elem *sklep;\n\n\twhile ((tok = strsep(&data, \" \")) != NULL) {\n\t\tif (!*tok)\n\t\t\tcontinue;\n\n\t\tskp = smk_import_entry(tok, 0);\n\t\tif (IS_ERR(skp))\n\t\t\treturn PTR_ERR(skp);\n\n\t\tsklep = kzalloc(sizeof(*sklep), GFP_KERNEL);\n\t\tif (sklep == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tsklep->smk_label = skp;\n\t\tlist_add(&sklep->list, list);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 2018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "list_tmp"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic ssize_t smk_write_onlycap(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tchar *data;\n\tLIST_HEAD(list_tmp);\n\tint rc;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trc = smk_parse_label_list(data, &list_tmp);\n\tkfree(data);\n\n\t/*\n\t * Clear the smack_onlycap on invalid label errors. This means\n\t * that we can pass a null string to unset the onlycap value.\n\t *\n\t * Importing will also reject a label beginning with '-',\n\t * so \"-usecapabilities\" will also work.\n\t *\n\t * But do so only on invalid label, not on system errors.\n\t * The invalid label must be first to count as clearing attempt.\n\t */\n\tif (!rc || (rc == -EINVAL && list_empty(&list_tmp))) {\n\t\tmutex_lock(&smack_onlycap_lock);\n\t\tsmk_list_swap_rcu(&smack_onlycap_list, &list_tmp);\n\t\tmutex_unlock(&smack_onlycap_lock);\n\t\trc = count;\n\t}\n\n\tsmk_destroy_label_list(&list_tmp);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_destroy_label_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1988-1997",
    "snippet": "void smk_destroy_label_list(struct list_head *list)\n{\n\tstruct smack_known_list_elem *sklep;\n\tstruct smack_known_list_elem *sklep2;\n\n\tlist_for_each_entry_safe(sklep, sklep2, list, list)\n\t\tkfree(sklep);\n\n\tINIT_LIST_HEAD(list);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "list"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sklep"
          ],
          "line": 1994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "sklep",
            "sklep2",
            "list",
            "list"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nvoid smk_destroy_label_list(struct list_head *list)\n{\n\tstruct smack_known_list_elem *sklep;\n\tstruct smack_known_list_elem *sklep2;\n\n\tlist_for_each_entry_safe(sklep, sklep2, list, list)\n\t\tkfree(sklep);\n\n\tINIT_LIST_HEAD(list);\n}"
  },
  {
    "function_name": "smk_parse_label_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1959-1982",
    "snippet": "static int smk_parse_label_list(char *data, struct list_head *list)\n{\n\tchar *tok;\n\tstruct smack_known *skp;\n\tstruct smack_known_list_elem *sklep;\n\n\twhile ((tok = strsep(&data, \" \")) != NULL) {\n\t\tif (!*tok)\n\t\t\tcontinue;\n\n\t\tskp = smk_import_entry(tok, 0);\n\t\tif (IS_ERR(skp))\n\t\t\treturn PTR_ERR(skp);\n\n\t\tsklep = kzalloc(sizeof(*sklep), GFP_KERNEL);\n\t\tif (sklep == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tsklep->smk_label = skp;\n\t\tlist_add(&sklep->list, list);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&sklep->list",
            "list"
          ],
          "line": 1978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sklep)",
            "GFP_KERNEL"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 1971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "tok",
            "0"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&data",
            "\" \""
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_parse_label_list(char *data, struct list_head *list)\n{\n\tchar *tok;\n\tstruct smack_known *skp;\n\tstruct smack_known_list_elem *sklep;\n\n\twhile ((tok = strsep(&data, \" \")) != NULL) {\n\t\tif (!*tok)\n\t\t\tcontinue;\n\n\t\tskp = smk_import_entry(tok, 0);\n\t\tif (IS_ERR(skp))\n\t\t\treturn PTR_ERR(skp);\n\n\t\tsklep = kzalloc(sizeof(*sklep), GFP_KERNEL);\n\t\tif (sklep == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tsklep->smk_label = skp;\n\t\tlist_add(&sklep->list, list);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_list_swap_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1922-1949",
    "snippet": "static void smk_list_swap_rcu(struct list_head *public,\n\t\t\t      struct list_head *private)\n{\n\tstruct list_head *first, *last;\n\n\tif (list_empty(public)) {\n\t\tlist_splice_init_rcu(private, public, synchronize_rcu);\n\t} else {\n\t\t/* Remember public list before replacing it */\n\t\tfirst = public->next;\n\t\tlast = public->prev;\n\n\t\t/* Publish private list in place of public in RCU-safe way */\n\t\tprivate->prev->next = public;\n\t\tprivate->next->prev = public;\n\t\trcu_assign_pointer(public->next, private->next);\n\t\tpublic->prev = private->prev;\n\n\t\tsynchronize_rcu();\n\n\t\t/* When all readers are done with the old public list,\n\t\t * attach it in place of private */\n\t\tprivate->next = first;\n\t\tprivate->prev = last;\n\t\tfirst->prev = private;\n\t\tlast->next = private;\n\t}\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "public->next",
            "private->next"
          ],
          "line": 1937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_splice_init_rcu",
          "args": [
            "private",
            "public",
            "synchronize_rcu"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "public"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_list_swap_rcu(struct list_head *public,\n\t\t\t      struct list_head *private)\n{\n\tstruct list_head *first, *last;\n\n\tif (list_empty(public)) {\n\t\tlist_splice_init_rcu(private, public, synchronize_rcu);\n\t} else {\n\t\t/* Remember public list before replacing it */\n\t\tfirst = public->next;\n\t\tlast = public->prev;\n\n\t\t/* Publish private list in place of public in RCU-safe way */\n\t\tprivate->prev->next = public;\n\t\tprivate->next->prev = public;\n\t\trcu_assign_pointer(public->next, private->next);\n\t\tpublic->prev = private->prev;\n\n\t\tsynchronize_rcu();\n\n\t\t/* When all readers are done with the old public list,\n\t\t * attach it in place of private */\n\t\tprivate->next = first;\n\t\tprivate->prev = last;\n\t\tfirst->prev = private;\n\t\tlast->next = private;\n\t}\n}"
  },
  {
    "function_name": "smk_open_onlycap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1908-1911",
    "snippet": "static int smk_open_onlycap(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &onlycap_seq_ops);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations onlycap_seq_ops = {\n\t.start = onlycap_seq_start,\n\t.next  = onlycap_seq_next,\n\t.show  = onlycap_seq_show,\n\t.stop  = smk_seq_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&onlycap_seq_ops"
          ],
          "line": 1910
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic const struct seq_operations onlycap_seq_ops = {\n\t.start = onlycap_seq_start,\n\t.next  = onlycap_seq_next,\n\t.show  = onlycap_seq_show,\n\t.stop  = smk_seq_stop,\n};\n\nstatic int smk_open_onlycap(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &onlycap_seq_ops);\n}"
  },
  {
    "function_name": "onlycap_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1889-1899",
    "snippet": "static int onlycap_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smack_known_list_elem *sklep =\n\t\tlist_entry_rcu(list, struct smack_known_list_elem, list);\n\n\tseq_puts(s, sklep->smk_label->smk_known);\n\tseq_putc(s, ' ');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "s",
            "sklep->smk_label->smk_known"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "list",
            "structsmack_known_list_elem",
            "list"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int onlycap_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smack_known_list_elem *sklep =\n\t\tlist_entry_rcu(list, struct smack_known_list_elem, list);\n\n\tseq_puts(s, sklep->smk_label->smk_known);\n\tseq_putc(s, ' ');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "onlycap_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1884-1887",
    "snippet": "static void *onlycap_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\treturn smk_seq_next(s, v, pos, &smack_onlycap_list);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_next",
          "args": [
            "s",
            "v",
            "pos",
            "&smack_onlycap_list"
          ],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "578-587",
          "snippet": "static void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *onlycap_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\treturn smk_seq_next(s, v, pos, &smack_onlycap_list);\n}"
  },
  {
    "function_name": "onlycap_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1879-1882",
    "snippet": "static void *onlycap_seq_start(struct seq_file *s, loff_t *pos)\n{\n\treturn smk_seq_start(s, pos, &smack_onlycap_list);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_start",
          "args": [
            "s",
            "pos",
            "&smack_onlycap_list"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "561-576",
          "snippet": "static void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *onlycap_seq_start(struct seq_file *s, loff_t *pos)\n{\n\treturn smk_seq_start(s, pos, &smack_onlycap_list);\n}"
  },
  {
    "function_name": "smk_write_ambient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1836-1868",
    "snippet": "static ssize_t smk_write_ambient(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct smack_known *skp;\n\tchar *oldambient;\n\tchar *data;\n\tint rc = count;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tskp = smk_import_entry(data, count);\n\tif (IS_ERR(skp)) {\n\t\trc = PTR_ERR(skp);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&smack_ambient_lock);\n\n\toldambient = smack_net_ambient->smk_known;\n\tsmack_net_ambient = skp;\n\tsmk_unlbl_ambient(oldambient);\n\n\tmutex_unlock(&smack_ambient_lock);\n\nout:\n\tkfree(data);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(smack_ambient_lock);",
      "struct smack_known *smack_net_ambient;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&smack_ambient_lock"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_unlbl_ambient",
          "args": [
            "oldambient"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "smk_unlbl_ambient",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "754-775",
          "snippet": "static void smk_unlbl_ambient(char *oldambient)\n{\n\tint rc;\n\tstruct netlbl_audit nai;\n\n\tsmk_netlabel_audit_set(&nai);\n\n\tif (oldambient != NULL) {\n\t\trc = netlbl_cfg_map_del(oldambient, PF_INET, NULL, NULL, &nai);\n\t\tif (rc != 0)\n\t\t\tprintk(KERN_WARNING \"%s:%d remove rc = %d\\n\",\n\t\t\t       __func__, __LINE__, rc);\n\t}\n\tif (smack_net_ambient == NULL)\n\t\tsmack_net_ambient = &smack_known_floor;\n\n\trc = netlbl_cfg_unlbl_map_add(smack_net_ambient->smk_known, PF_INET,\n\t\t\t\t      NULL, NULL, &nai);\n\tif (rc != 0)\n\t\tprintk(KERN_WARNING \"%s:%d add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct smack_known *smack_net_ambient;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstruct smack_known *smack_net_ambient;\n\nstatic void smk_unlbl_ambient(char *oldambient)\n{\n\tint rc;\n\tstruct netlbl_audit nai;\n\n\tsmk_netlabel_audit_set(&nai);\n\n\tif (oldambient != NULL) {\n\t\trc = netlbl_cfg_map_del(oldambient, PF_INET, NULL, NULL, &nai);\n\t\tif (rc != 0)\n\t\t\tprintk(KERN_WARNING \"%s:%d remove rc = %d\\n\",\n\t\t\t       __func__, __LINE__, rc);\n\t}\n\tif (smack_net_ambient == NULL)\n\t\tsmack_net_ambient = &smack_known_floor;\n\n\trc = netlbl_cfg_unlbl_map_add(smack_net_ambient->smk_known, PF_INET,\n\t\t\t\t      NULL, NULL, &nai);\n\tif (rc != 0)\n\t\tprintk(KERN_WARNING \"%s:%d add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&smack_ambient_lock"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 1853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 1852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "data",
            "count"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 1849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 1847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 1844
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(smack_ambient_lock);\nstruct smack_known *smack_net_ambient;\n\nstatic ssize_t smk_write_ambient(struct file *file, const char __user *buf,\n\t\t\t\t size_t count, loff_t *ppos)\n{\n\tstruct smack_known *skp;\n\tchar *oldambient;\n\tchar *data;\n\tint rc = count;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tskp = smk_import_entry(data, count);\n\tif (IS_ERR(skp)) {\n\t\trc = PTR_ERR(skp);\n\t\tgoto out;\n\t}\n\n\tmutex_lock(&smack_ambient_lock);\n\n\toldambient = smack_net_ambient->smk_known;\n\tsmack_net_ambient = skp;\n\tsmk_unlbl_ambient(oldambient);\n\n\tmutex_unlock(&smack_ambient_lock);\n\nout:\n\tkfree(data);\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_read_ambient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1799-1825",
    "snippet": "static ssize_t smk_read_ambient(struct file *filp, char __user *buf,\n\t\t\t\tsize_t cn, loff_t *ppos)\n{\n\tssize_t rc;\n\tint asize;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\t/*\n\t * Being careful to avoid a problem in the case where\n\t * smack_net_ambient gets changed in midstream.\n\t */\n\tmutex_lock(&smack_ambient_lock);\n\n\tasize = strlen(smack_net_ambient->smk_known) + 1;\n\n\tif (cn >= asize)\n\t\trc = simple_read_from_buffer(buf, cn, ppos,\n\t\t\t\t\t     smack_net_ambient->smk_known,\n\t\t\t\t\t     asize);\n\telse\n\t\trc = -EINVAL;\n\n\tmutex_unlock(&smack_ambient_lock);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(smack_ambient_lock);",
      "struct smack_known *smack_net_ambient;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&smack_ambient_lock"
          ],
          "line": 1822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "cn",
            "ppos",
            "smack_net_ambient->smk_known",
            "asize"
          ],
          "line": 1816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "smack_net_ambient->smk_known"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&smack_ambient_lock"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(smack_ambient_lock);\nstruct smack_known *smack_net_ambient;\n\nstatic ssize_t smk_read_ambient(struct file *filp, char __user *buf,\n\t\t\t\tsize_t cn, loff_t *ppos)\n{\n\tssize_t rc;\n\tint asize;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\t/*\n\t * Being careful to avoid a problem in the case where\n\t * smack_net_ambient gets changed in midstream.\n\t */\n\tmutex_lock(&smack_ambient_lock);\n\n\tasize = strlen(smack_net_ambient->smk_known) + 1;\n\n\tif (cn >= asize)\n\t\trc = simple_read_from_buffer(buf, cn, ppos,\n\t\t\t\t\t     smack_net_ambient->smk_known,\n\t\t\t\t\t     asize);\n\telse\n\t\trc = -EINVAL;\n\n\tmutex_unlock(&smack_ambient_lock);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_write_mapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1745-1782",
    "snippet": "static ssize_t smk_write_mapped(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct smack_known *skp;\n\tchar temp[80];\n\tint i;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (count >= sizeof(temp) || count == 0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(temp, buf, count) != 0)\n\t\treturn -EFAULT;\n\n\ttemp[count] = '\\0';\n\n\tif (sscanf(temp, \"%d\", &i) != 1)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't do anything if the value hasn't actually changed.\n\t * If it is changing reset the level on entries that were\n\t * set up to be mapped when they were created.\n\t */\n\tif (smack_cipso_mapped != i) {\n\t\tmutex_lock(&smack_known_lock);\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list)\n\t\t\tif (skp->smk_netlabel.attr.mls.lvl ==\n\t\t\t    smack_cipso_mapped)\n\t\t\t\tskp->smk_netlabel.attr.mls.lvl = i;\n\t\tsmack_cipso_mapped = i;\n\t\tmutex_unlock(&smack_known_lock);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int smack_cipso_mapped = SMACK_CIPSO_MAPPED_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&smack_known_lock"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "skp",
            "&smack_known_list",
            "list"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&smack_known_lock"
          ],
          "line": 1772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "temp",
            "\"%d\"",
            "&i"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "temp",
            "buf",
            "count"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nint smack_cipso_mapped = SMACK_CIPSO_MAPPED_DEFAULT;\n\nstatic ssize_t smk_write_mapped(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct smack_known *skp;\n\tchar temp[80];\n\tint i;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (count >= sizeof(temp) || count == 0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(temp, buf, count) != 0)\n\t\treturn -EFAULT;\n\n\ttemp[count] = '\\0';\n\n\tif (sscanf(temp, \"%d\", &i) != 1)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't do anything if the value hasn't actually changed.\n\t * If it is changing reset the level on entries that were\n\t * set up to be mapped when they were created.\n\t */\n\tif (smack_cipso_mapped != i) {\n\t\tmutex_lock(&smack_known_lock);\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list)\n\t\t\tif (skp->smk_netlabel.attr.mls.lvl ==\n\t\t\t    smack_cipso_mapped)\n\t\t\t\tskp->smk_netlabel.attr.mls.lvl = i;\n\t\tsmack_cipso_mapped = i;\n\t\tmutex_unlock(&smack_known_lock);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "smk_read_mapped",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1721-1734",
    "snippet": "static ssize_t smk_read_mapped(struct file *filp, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar temp[80];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\", smack_cipso_mapped);\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int smack_cipso_mapped = SMACK_CIPSO_MAPPED_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "temp",
            "strlen(temp)"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "temp"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "temp",
            "\"%d\"",
            "smack_cipso_mapped"
          ],
          "line": 1730
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nint smack_cipso_mapped = SMACK_CIPSO_MAPPED_DEFAULT;\n\nstatic ssize_t smk_read_mapped(struct file *filp, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar temp[80];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\", smack_cipso_mapped);\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_write_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1667-1704",
    "snippet": "static ssize_t smk_write_direct(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct smack_known *skp;\n\tchar temp[80];\n\tint i;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (count >= sizeof(temp) || count == 0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(temp, buf, count) != 0)\n\t\treturn -EFAULT;\n\n\ttemp[count] = '\\0';\n\n\tif (sscanf(temp, \"%d\", &i) != 1)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't do anything if the value hasn't actually changed.\n\t * If it is changing reset the level on entries that were\n\t * set up to be direct when they were created.\n\t */\n\tif (smack_cipso_direct != i) {\n\t\tmutex_lock(&smack_known_lock);\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list)\n\t\t\tif (skp->smk_netlabel.attr.mls.lvl ==\n\t\t\t    smack_cipso_direct)\n\t\t\t\tskp->smk_netlabel.attr.mls.lvl = i;\n\t\tsmack_cipso_direct = i;\n\t\tmutex_unlock(&smack_known_lock);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int smack_cipso_direct = SMACK_CIPSO_DIRECT_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&smack_known_lock"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "skp",
            "&smack_known_list",
            "list"
          ],
          "line": 1695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&smack_known_lock"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "temp",
            "\"%d\"",
            "&i"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "temp",
            "buf",
            "count"
          ],
          "line": 1680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 1674
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nint smack_cipso_direct = SMACK_CIPSO_DIRECT_DEFAULT;\n\nstatic ssize_t smk_write_direct(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct smack_known *skp;\n\tchar temp[80];\n\tint i;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (count >= sizeof(temp) || count == 0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(temp, buf, count) != 0)\n\t\treturn -EFAULT;\n\n\ttemp[count] = '\\0';\n\n\tif (sscanf(temp, \"%d\", &i) != 1)\n\t\treturn -EINVAL;\n\n\t/*\n\t * Don't do anything if the value hasn't actually changed.\n\t * If it is changing reset the level on entries that were\n\t * set up to be direct when they were created.\n\t */\n\tif (smack_cipso_direct != i) {\n\t\tmutex_lock(&smack_known_lock);\n\t\tlist_for_each_entry_rcu(skp, &smack_known_list, list)\n\t\t\tif (skp->smk_netlabel.attr.mls.lvl ==\n\t\t\t    smack_cipso_direct)\n\t\t\t\tskp->smk_netlabel.attr.mls.lvl = i;\n\t\tsmack_cipso_direct = i;\n\t\tmutex_unlock(&smack_known_lock);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "smk_read_direct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1643-1656",
    "snippet": "static ssize_t smk_read_direct(struct file *filp, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar temp[80];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\", smack_cipso_direct);\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int smack_cipso_direct = SMACK_CIPSO_DIRECT_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "temp",
            "strlen(temp)"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "temp"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "temp",
            "\"%d\"",
            "smack_cipso_direct"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nint smack_cipso_direct = SMACK_CIPSO_DIRECT_DEFAULT;\n\nstatic ssize_t smk_read_direct(struct file *filp, char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\tchar temp[80];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\", smack_cipso_direct);\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_write_doi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1601-1626",
    "snippet": "static ssize_t smk_write_doi(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar temp[80];\n\tint i;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (count >= sizeof(temp) || count == 0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(temp, buf, count) != 0)\n\t\treturn -EFAULT;\n\n\ttemp[count] = '\\0';\n\n\tif (sscanf(temp, \"%d\", &i) != 1)\n\t\treturn -EINVAL;\n\n\tsmk_cipso_doi_value = i;\n\n\tsmk_cipso_doi();\n\n\treturn count;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int smk_cipso_doi_value = SMACK_CIPSO_DOI_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_cipso_doi",
          "args": [],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "smk_cipso_doi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "711-748",
          "snippet": "static void smk_cipso_doi(void)\n{\n\tint rc;\n\tstruct cipso_v4_doi *doip;\n\tstruct netlbl_audit nai;\n\n\tsmk_netlabel_audit_set(&nai);\n\n\trc = netlbl_cfg_map_del(NULL, PF_INET, NULL, NULL, &nai);\n\tif (rc != 0)\n\t\tprintk(KERN_WARNING \"%s:%d remove rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\n\tdoip = kmalloc(sizeof(struct cipso_v4_doi), GFP_KERNEL);\n\tif (doip == NULL)\n\t\tpanic(\"smack:  Failed to initialize cipso DOI.\\n\");\n\tdoip->map.std = NULL;\n\tdoip->doi = smk_cipso_doi_value;\n\tdoip->type = CIPSO_V4_MAP_PASS;\n\tdoip->tags[0] = CIPSO_V4_TAG_RBITMAP;\n\tfor (rc = 1; rc < CIPSO_V4_TAG_MAXCNT; rc++)\n\t\tdoip->tags[rc] = CIPSO_V4_TAG_INVALID;\n\n\trc = netlbl_cfg_cipsov4_add(doip, &nai);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING \"%s:%d cipso add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\t\tkfree(doip);\n\t\treturn;\n\t}\n\trc = netlbl_cfg_cipsov4_map_add(doip->doi, NULL, NULL, NULL, &nai);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING \"%s:%d map add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\t\tkfree(doip);\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int smk_cipso_doi_value = SMACK_CIPSO_DOI_DEFAULT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_cipso_doi_value = SMACK_CIPSO_DOI_DEFAULT;\n\nstatic void smk_cipso_doi(void)\n{\n\tint rc;\n\tstruct cipso_v4_doi *doip;\n\tstruct netlbl_audit nai;\n\n\tsmk_netlabel_audit_set(&nai);\n\n\trc = netlbl_cfg_map_del(NULL, PF_INET, NULL, NULL, &nai);\n\tif (rc != 0)\n\t\tprintk(KERN_WARNING \"%s:%d remove rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\n\tdoip = kmalloc(sizeof(struct cipso_v4_doi), GFP_KERNEL);\n\tif (doip == NULL)\n\t\tpanic(\"smack:  Failed to initialize cipso DOI.\\n\");\n\tdoip->map.std = NULL;\n\tdoip->doi = smk_cipso_doi_value;\n\tdoip->type = CIPSO_V4_MAP_PASS;\n\tdoip->tags[0] = CIPSO_V4_TAG_RBITMAP;\n\tfor (rc = 1; rc < CIPSO_V4_TAG_MAXCNT; rc++)\n\t\tdoip->tags[rc] = CIPSO_V4_TAG_INVALID;\n\n\trc = netlbl_cfg_cipsov4_add(doip, &nai);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING \"%s:%d cipso add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\t\tkfree(doip);\n\t\treturn;\n\t}\n\trc = netlbl_cfg_cipsov4_map_add(doip->doi, NULL, NULL, NULL, &nai);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING \"%s:%d map add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\t\tkfree(doip);\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "temp",
            "\"%d\"",
            "&i"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "temp",
            "buf",
            "count"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 1607
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_cipso_doi_value = SMACK_CIPSO_DOI_DEFAULT;\n\nstatic ssize_t smk_write_doi(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tchar temp[80];\n\tint i;\n\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\tif (count >= sizeof(temp) || count == 0)\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(temp, buf, count) != 0)\n\t\treturn -EFAULT;\n\n\ttemp[count] = '\\0';\n\n\tif (sscanf(temp, \"%d\", &i) != 1)\n\t\treturn -EINVAL;\n\n\tsmk_cipso_doi_value = i;\n\n\tsmk_cipso_doi();\n\n\treturn count;\n}"
  },
  {
    "function_name": "smk_read_doi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1577-1590",
    "snippet": "static ssize_t smk_read_doi(struct file *filp, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar temp[80];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\", smk_cipso_doi_value);\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int smk_cipso_doi_value = SMACK_CIPSO_DOI_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "temp",
            "strlen(temp)"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "temp"
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "temp",
            "\"%d\"",
            "smk_cipso_doi_value"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_cipso_doi_value = SMACK_CIPSO_DOI_DEFAULT;\n\nstatic ssize_t smk_read_doi(struct file *filp, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar temp[80];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\", smk_cipso_doi_value);\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_write_net6addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1413-1557",
    "snippet": "static ssize_t smk_write_net6addr(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr newname;\n\tstruct in6_addr fullmask;\n\tstruct smack_known *skp = NULL;\n\tchar *smack;\n\tchar *data;\n\tint rc = 0;\n\tint found = 0;\n\tint i;\n\tunsigned int scanned[8];\n\tunsigned int m;\n\tunsigned int mask = 128;\n\n\t/*\n\t * Must have privilege.\n\t * No partial writes.\n\t * Enough data must be present.\n\t * \"<addr/mask, as a:b:c:d:e:f:g:h/e><space><label>\"\n\t * \"<addr, as a:b:c:d:e:f:g:h><space><label>\"\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\tif (count < SMK_NETLBLADDRMIN)\n\t\treturn -EINVAL;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tsmack = kzalloc(count + 1, GFP_KERNEL);\n\tif (smack == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto free_data_out;\n\t}\n\n\ti = sscanf(data, \"%x:%x:%x:%x:%x:%x:%x:%x/%u %s\",\n\t\t\t&scanned[0], &scanned[1], &scanned[2], &scanned[3],\n\t\t\t&scanned[4], &scanned[5], &scanned[6], &scanned[7],\n\t\t\t&mask, smack);\n\tif (i != 10) {\n\t\ti = sscanf(data, \"%x:%x:%x:%x:%x:%x:%x:%x %s\",\n\t\t\t\t&scanned[0], &scanned[1], &scanned[2],\n\t\t\t\t&scanned[3], &scanned[4], &scanned[5],\n\t\t\t\t&scanned[6], &scanned[7], smack);\n\t\tif (i != 9) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\tif (mask > 128) {\n\t\trc = -EINVAL;\n\t\tgoto free_out;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tif (scanned[i] > 0xffff) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_out;\n\t\t}\n\t\tnewname.s6_addr16[i] = htons(scanned[i]);\n\t}\n\n\t/*\n\t * If smack begins with '-', it is an option, don't import it\n\t */\n\tif (smack[0] != '-') {\n\t\tskp = smk_import_entry(smack, 0);\n\t\tif (IS_ERR(skp)) {\n\t\t\trc = PTR_ERR(skp);\n\t\t\tgoto free_out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Only -DELETE is supported for IPv6\n\t\t */\n\t\tif (strcmp(smack, SMACK_DELETE_OPTION) != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\n\tfor (i = 0, m = mask; i < 8; i++) {\n\t\tif (m >= 16) {\n\t\t\tfullmask.s6_addr16[i] = 0xffff;\n\t\t\tm -= 16;\n\t\t} else if (m > 0) {\n\t\t\tfullmask.s6_addr16[i] = (1 << m) - 1;\n\t\t\tm = 0;\n\t\t} else\n\t\t\tfullmask.s6_addr16[i] = 0;\n\t\tnewname.s6_addr16[i] &= fullmask.s6_addr16[i];\n\t}\n\n\t/*\n\t * Only allow one writer at a time. Writes should be\n\t * quite rare and small in any case.\n\t */\n\tmutex_lock(&smk_net6addr_lock);\n\t/*\n\t * Try to find the prefix in the list\n\t */\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\tif (mask != snp->smk_masks)\n\t\t\tcontinue;\n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif (newname.s6_addr16[i] !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found == 1)\n\t\t\tbreak;\n\t}\n\tif (found == 0) {\n\t\tsnp = kzalloc(sizeof(*snp), GFP_KERNEL);\n\t\tif (snp == NULL)\n\t\t\trc = -ENOMEM;\n\t\telse {\n\t\t\tsnp->smk_host = newname;\n\t\t\tsnp->smk_mask = fullmask;\n\t\t\tsnp->smk_masks = mask;\n\t\t\tsnp->smk_label = skp;\n\t\t\tsmk_net6addr_insert(snp);\n\t\t}\n\t} else {\n\t\tsnp->smk_label = skp;\n\t}\n\n\tif (rc == 0)\n\t\trc = count;\n\n\tmutex_unlock(&smk_net6addr_lock);\n\nfree_out:\n\tkfree(smack);\nfree_data_out:\n\tkfree(data);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_NETLBLADDRMIN\t9"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "smack"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&smk_net6addr_lock"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_net6addr_insert",
          "args": [
            "snp"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "smk_net6addr_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "1370-1400",
          "snippet": "static void smk_net6addr_insert(struct smk_net6addr *new)\n{\n\tstruct smk_net6addr *m_next;\n\tstruct smk_net6addr *m;\n\n\tif (list_empty(&smk_net6addr_list)) {\n\t\tlist_add_rcu(&new->list, &smk_net6addr_list);\n\t\treturn;\n\t}\n\n\tm = list_entry_rcu(smk_net6addr_list.next,\n\t\t\t   struct smk_net6addr, list);\n\n\tif (new->smk_masks > m->smk_masks) {\n\t\tlist_add_rcu(&new->list, &smk_net6addr_list);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_rcu(m, &smk_net6addr_list, list) {\n\t\tif (list_is_last(&m->list, &smk_net6addr_list)) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t\tm_next = list_entry_rcu(m->list.next,\n\t\t\t\t\tstruct smk_net6addr, list);\n\t\tif (new->smk_masks > m_next->smk_masks) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_net6addr_insert(struct smk_net6addr *new)\n{\n\tstruct smk_net6addr *m_next;\n\tstruct smk_net6addr *m;\n\n\tif (list_empty(&smk_net6addr_list)) {\n\t\tlist_add_rcu(&new->list, &smk_net6addr_list);\n\t\treturn;\n\t}\n\n\tm = list_entry_rcu(smk_net6addr_list.next,\n\t\t\t   struct smk_net6addr, list);\n\n\tif (new->smk_masks > m->smk_masks) {\n\t\tlist_add_rcu(&new->list, &smk_net6addr_list);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_rcu(m, &smk_net6addr_list, list) {\n\t\tif (list_is_last(&m->list, &smk_net6addr_list)) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t\tm_next = list_entry_rcu(m->list.next,\n\t\t\t\t\tstruct smk_net6addr, list);\n\t\tif (new->smk_masks > m_next->smk_masks) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*snp)",
            "GFP_KERNEL"
          ],
          "line": 1532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "snp",
            "&smk_net6addr_list",
            "list"
          ],
          "line": 1518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&smk_net6addr_lock"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "smack",
            "SMACK_DELETE_OPTION"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 1485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "smack",
            "0"
          ],
          "line": 1483
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "scanned[i]"
          ],
          "line": 1476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data",
            "\"%x:%x:%x:%x:%x:%x:%x:%x %s\"",
            "&scanned[0]",
            "&scanned[1]",
            "&scanned[2]",
            "&scanned[3]",
            "&scanned[4]",
            "&scanned[5]",
            "&scanned[6]",
            "&scanned[7]",
            "smack"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data",
            "\"%x:%x:%x:%x:%x:%x:%x:%x/%u %s\"",
            "&scanned[0]",
            "&scanned[1]",
            "&scanned[2]",
            "&scanned[3]",
            "&scanned[4]",
            "&scanned[5]",
            "&scanned[6]",
            "&scanned[7]",
            "&mask",
            "smack"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "count + 1",
            "GFP_KERNEL"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 1444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 1443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 1436
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_NETLBLADDRMIN\t9\n\nstatic ssize_t smk_write_net6addr(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct smk_net6addr *snp;\n\tstruct in6_addr newname;\n\tstruct in6_addr fullmask;\n\tstruct smack_known *skp = NULL;\n\tchar *smack;\n\tchar *data;\n\tint rc = 0;\n\tint found = 0;\n\tint i;\n\tunsigned int scanned[8];\n\tunsigned int m;\n\tunsigned int mask = 128;\n\n\t/*\n\t * Must have privilege.\n\t * No partial writes.\n\t * Enough data must be present.\n\t * \"<addr/mask, as a:b:c:d:e:f:g:h/e><space><label>\"\n\t * \"<addr, as a:b:c:d:e:f:g:h><space><label>\"\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\tif (count < SMK_NETLBLADDRMIN)\n\t\treturn -EINVAL;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tsmack = kzalloc(count + 1, GFP_KERNEL);\n\tif (smack == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto free_data_out;\n\t}\n\n\ti = sscanf(data, \"%x:%x:%x:%x:%x:%x:%x:%x/%u %s\",\n\t\t\t&scanned[0], &scanned[1], &scanned[2], &scanned[3],\n\t\t\t&scanned[4], &scanned[5], &scanned[6], &scanned[7],\n\t\t\t&mask, smack);\n\tif (i != 10) {\n\t\ti = sscanf(data, \"%x:%x:%x:%x:%x:%x:%x:%x %s\",\n\t\t\t\t&scanned[0], &scanned[1], &scanned[2],\n\t\t\t\t&scanned[3], &scanned[4], &scanned[5],\n\t\t\t\t&scanned[6], &scanned[7], smack);\n\t\tif (i != 9) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\tif (mask > 128) {\n\t\trc = -EINVAL;\n\t\tgoto free_out;\n\t}\n\tfor (i = 0; i < 8; i++) {\n\t\tif (scanned[i] > 0xffff) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_out;\n\t\t}\n\t\tnewname.s6_addr16[i] = htons(scanned[i]);\n\t}\n\n\t/*\n\t * If smack begins with '-', it is an option, don't import it\n\t */\n\tif (smack[0] != '-') {\n\t\tskp = smk_import_entry(smack, 0);\n\t\tif (IS_ERR(skp)) {\n\t\t\trc = PTR_ERR(skp);\n\t\t\tgoto free_out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Only -DELETE is supported for IPv6\n\t\t */\n\t\tif (strcmp(smack, SMACK_DELETE_OPTION) != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\n\tfor (i = 0, m = mask; i < 8; i++) {\n\t\tif (m >= 16) {\n\t\t\tfullmask.s6_addr16[i] = 0xffff;\n\t\t\tm -= 16;\n\t\t} else if (m > 0) {\n\t\t\tfullmask.s6_addr16[i] = (1 << m) - 1;\n\t\t\tm = 0;\n\t\t} else\n\t\t\tfullmask.s6_addr16[i] = 0;\n\t\tnewname.s6_addr16[i] &= fullmask.s6_addr16[i];\n\t}\n\n\t/*\n\t * Only allow one writer at a time. Writes should be\n\t * quite rare and small in any case.\n\t */\n\tmutex_lock(&smk_net6addr_lock);\n\t/*\n\t * Try to find the prefix in the list\n\t */\n\tlist_for_each_entry_rcu(snp, &smk_net6addr_list, list) {\n\t\tif (mask != snp->smk_masks)\n\t\t\tcontinue;\n\t\tfor (found = 1, i = 0; i < 8; i++) {\n\t\t\tif (newname.s6_addr16[i] !=\n\t\t\t    snp->smk_host.s6_addr16[i]) {\n\t\t\t\tfound = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (found == 1)\n\t\t\tbreak;\n\t}\n\tif (found == 0) {\n\t\tsnp = kzalloc(sizeof(*snp), GFP_KERNEL);\n\t\tif (snp == NULL)\n\t\t\trc = -ENOMEM;\n\t\telse {\n\t\t\tsnp->smk_host = newname;\n\t\t\tsnp->smk_mask = fullmask;\n\t\t\tsnp->smk_masks = mask;\n\t\t\tsnp->smk_label = skp;\n\t\t\tsmk_net6addr_insert(snp);\n\t\t}\n\t} else {\n\t\tsnp->smk_label = skp;\n\t}\n\n\tif (rc == 0)\n\t\trc = count;\n\n\tmutex_unlock(&smk_net6addr_lock);\n\nfree_out:\n\tkfree(smack);\nfree_data_out:\n\tkfree(data);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_net6addr_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1370-1400",
    "snippet": "static void smk_net6addr_insert(struct smk_net6addr *new)\n{\n\tstruct smk_net6addr *m_next;\n\tstruct smk_net6addr *m;\n\n\tif (list_empty(&smk_net6addr_list)) {\n\t\tlist_add_rcu(&new->list, &smk_net6addr_list);\n\t\treturn;\n\t}\n\n\tm = list_entry_rcu(smk_net6addr_list.next,\n\t\t\t   struct smk_net6addr, list);\n\n\tif (new->smk_masks > m->smk_masks) {\n\t\tlist_add_rcu(&new->list, &smk_net6addr_list);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_rcu(m, &smk_net6addr_list, list) {\n\t\tif (list_is_last(&m->list, &smk_net6addr_list)) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t\tm_next = list_entry_rcu(m->list.next,\n\t\t\t\t\tstruct smk_net6addr, list);\n\t\tif (new->smk_masks > m_next->smk_masks) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&new->list",
            "&m->list"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "m->list.next",
            "structsmk_net6addr",
            "list"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&new->list",
            "&m->list"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_last",
          "args": [
            "&m->list",
            "&smk_net6addr_list"
          ],
          "line": 1389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "m",
            "&smk_net6addr_list",
            "list"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&new->list",
            "&smk_net6addr_list"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "smk_net6addr_list.next",
            "structsmk_net6addr",
            "list"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&new->list",
            "&smk_net6addr_list"
          ],
          "line": 1376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&smk_net6addr_list"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_net6addr_insert(struct smk_net6addr *new)\n{\n\tstruct smk_net6addr *m_next;\n\tstruct smk_net6addr *m;\n\n\tif (list_empty(&smk_net6addr_list)) {\n\t\tlist_add_rcu(&new->list, &smk_net6addr_list);\n\t\treturn;\n\t}\n\n\tm = list_entry_rcu(smk_net6addr_list.next,\n\t\t\t   struct smk_net6addr, list);\n\n\tif (new->smk_masks > m->smk_masks) {\n\t\tlist_add_rcu(&new->list, &smk_net6addr_list);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_rcu(m, &smk_net6addr_list, list) {\n\t\tif (list_is_last(&m->list, &smk_net6addr_list)) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t\tm_next = list_entry_rcu(m->list.next,\n\t\t\t\t\tstruct smk_net6addr, list);\n\t\tif (new->smk_masks > m_next->smk_masks) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "smk_open_net6addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1356-1359",
    "snippet": "static int smk_open_net6addr(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &net6addr_seq_ops);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&net6addr_seq_ops"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_open_net6addr(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &net6addr_seq_ops);\n}"
  },
  {
    "function_name": "net6addr_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1328-1339",
    "snippet": "static int net6addr_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smk_net6addr *skp =\n\t\t\t list_entry(list, struct smk_net6addr, list);\n\n\tif (skp->smk_label != NULL)\n\t\tseq_printf(s, \"%pI6/%d %s\\n\", &skp->smk_host, skp->smk_masks,\n\t\t\t\tskp->smk_label->smk_known);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%pI6/%d %s\\n\"",
            "&skp->smk_host",
            "skp->smk_masks",
            "skp->smk_label->smk_known"
          ],
          "line": 1335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "list",
            "structsmk_net6addr",
            "list"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int net6addr_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smk_net6addr *skp =\n\t\t\t list_entry(list, struct smk_net6addr, list);\n\n\tif (skp->smk_label != NULL)\n\t\tseq_printf(s, \"%pI6/%d %s\\n\", &skp->smk_host, skp->smk_masks,\n\t\t\t\tskp->smk_label->smk_known);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "net6addr_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1320-1323",
    "snippet": "static void *net6addr_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\treturn smk_seq_next(s, v, pos, &smk_net6addr_list);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_next",
          "args": [
            "s",
            "v",
            "pos",
            "&smk_net6addr_list"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "578-587",
          "snippet": "static void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *net6addr_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\treturn smk_seq_next(s, v, pos, &smk_net6addr_list);\n}"
  },
  {
    "function_name": "net6addr_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1315-1318",
    "snippet": "static void *net6addr_seq_start(struct seq_file *s, loff_t *pos)\n{\n\treturn smk_seq_start(s, pos, &smk_net6addr_list);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_start",
          "args": [
            "s",
            "pos",
            "&smk_net6addr_list"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "561-576",
          "snippet": "static void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *net6addr_seq_start(struct seq_file *s, loff_t *pos)\n{\n\treturn smk_seq_start(s, pos, &smk_net6addr_list);\n}"
  },
  {
    "function_name": "smk_write_net4addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1150-1300",
    "snippet": "static ssize_t smk_write_net4addr(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct smk_net4addr *snp;\n\tstruct sockaddr_in newname;\n\tchar *smack;\n\tstruct smack_known *skp = NULL;\n\tchar *data;\n\tchar *host = (char *)&newname.sin_addr.s_addr;\n\tint rc;\n\tstruct netlbl_audit audit_info;\n\tstruct in_addr mask;\n\tunsigned int m;\n\tunsigned int masks;\n\tint found;\n\tu32 mask_bits = (1<<31);\n\t__be32 nsa;\n\tu32 temp_mask;\n\n\t/*\n\t * Must have privilege.\n\t * No partial writes.\n\t * Enough data must be present.\n\t * \"<addr/mask, as a.b.c.d/e><space><label>\"\n\t * \"<addr, as a.b.c.d><space><label>\"\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\tif (count < SMK_NETLBLADDRMIN)\n\t\treturn -EINVAL;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tsmack = kzalloc(count + 1, GFP_KERNEL);\n\tif (smack == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto free_data_out;\n\t}\n\n\trc = sscanf(data, \"%hhd.%hhd.%hhd.%hhd/%u %s\",\n\t\t&host[0], &host[1], &host[2], &host[3], &masks, smack);\n\tif (rc != 6) {\n\t\trc = sscanf(data, \"%hhd.%hhd.%hhd.%hhd %s\",\n\t\t\t&host[0], &host[1], &host[2], &host[3], smack);\n\t\tif (rc != 5) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_out;\n\t\t}\n\t\tm = BEBITS;\n\t\tmasks = 32;\n\t}\n\tif (masks > BEBITS) {\n\t\trc = -EINVAL;\n\t\tgoto free_out;\n\t}\n\n\t/*\n\t * If smack begins with '-', it is an option, don't import it\n\t */\n\tif (smack[0] != '-') {\n\t\tskp = smk_import_entry(smack, 0);\n\t\tif (IS_ERR(skp)) {\n\t\t\trc = PTR_ERR(skp);\n\t\t\tgoto free_out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Only the -CIPSO option is supported for IPv4\n\t\t */\n\t\tif (strcmp(smack, SMACK_CIPSO_OPTION) != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\n\tfor (m = masks, temp_mask = 0; m > 0; m--) {\n\t\ttemp_mask |= mask_bits;\n\t\tmask_bits >>= 1;\n\t}\n\tmask.s_addr = cpu_to_be32(temp_mask);\n\n\tnewname.sin_addr.s_addr &= mask.s_addr;\n\t/*\n\t * Only allow one writer at a time. Writes should be\n\t * quite rare and small in any case.\n\t */\n\tmutex_lock(&smk_net4addr_lock);\n\n\tnsa = newname.sin_addr.s_addr;\n\t/* try to find if the prefix is already in the list */\n\tfound = 0;\n\tlist_for_each_entry_rcu(snp, &smk_net4addr_list, list) {\n\t\tif (snp->smk_host.s_addr == nsa && snp->smk_masks == masks) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tsmk_netlabel_audit_set(&audit_info);\n\n\tif (found == 0) {\n\t\tsnp = kzalloc(sizeof(*snp), GFP_KERNEL);\n\t\tif (snp == NULL)\n\t\t\trc = -ENOMEM;\n\t\telse {\n\t\t\trc = 0;\n\t\t\tsnp->smk_host.s_addr = newname.sin_addr.s_addr;\n\t\t\tsnp->smk_mask.s_addr = mask.s_addr;\n\t\t\tsnp->smk_label = skp;\n\t\t\tsnp->smk_masks = masks;\n\t\t\tsmk_net4addr_insert(snp);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Delete the unlabeled entry, only if the previous label\n\t\t * wasn't the special CIPSO option\n\t\t */\n\t\tif (snp->smk_label != NULL)\n\t\t\trc = netlbl_cfg_unlbl_static_del(&init_net, NULL,\n\t\t\t\t\t&snp->smk_host, &snp->smk_mask,\n\t\t\t\t\tPF_INET, &audit_info);\n\t\telse\n\t\t\trc = 0;\n\t\tsnp->smk_label = skp;\n\t}\n\n\t/*\n\t * Now tell netlabel about the single label nature of\n\t * this host so that incoming packets get labeled.\n\t * but only if we didn't get the special CIPSO option\n\t */\n\tif (rc == 0 && skp != NULL)\n\t\trc = netlbl_cfg_unlbl_static_add(&init_net, NULL,\n\t\t\t&snp->smk_host, &snp->smk_mask, PF_INET,\n\t\t\tsnp->smk_label->smk_secid, &audit_info);\n\n\tif (rc == 0)\n\t\trc = count;\n\n\tmutex_unlock(&smk_net4addr_lock);\n\nfree_out:\n\tkfree(smack);\nfree_data_out:\n\tkfree(data);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_NETLBLADDRMIN\t9",
      "#define BEBITS\t(sizeof(__be32) * 8)"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(smk_net4addr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "smack"
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&smk_net4addr_lock"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_cfg_unlbl_static_add",
          "args": [
            "&init_net",
            "NULL",
            "&snp->smk_host",
            "&snp->smk_mask",
            "PF_INET",
            "snp->smk_label->smk_secid",
            "&audit_info"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_cfg_unlbl_static_del",
          "args": [
            "&init_net",
            "NULL",
            "&snp->smk_host",
            "&snp->smk_mask",
            "PF_INET",
            "&audit_info"
          ],
          "line": 1271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_net4addr_insert",
          "args": [
            "snp"
          ],
          "line": 1263
        },
        "resolved": true,
        "details": {
          "function_name": "smk_net4addr_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "1106-1137",
          "snippet": "static void smk_net4addr_insert(struct smk_net4addr *new)\n{\n\tstruct smk_net4addr *m;\n\tstruct smk_net4addr *m_next;\n\n\tif (list_empty(&smk_net4addr_list)) {\n\t\tlist_add_rcu(&new->list, &smk_net4addr_list);\n\t\treturn;\n\t}\n\n\tm = list_entry_rcu(smk_net4addr_list.next,\n\t\t\t   struct smk_net4addr, list);\n\n\t/* the comparison '>' is a bit hacky, but works */\n\tif (new->smk_masks > m->smk_masks) {\n\t\tlist_add_rcu(&new->list, &smk_net4addr_list);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_rcu(m, &smk_net4addr_list, list) {\n\t\tif (list_is_last(&m->list, &smk_net4addr_list)) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t\tm_next = list_entry_rcu(m->list.next,\n\t\t\t\t\tstruct smk_net4addr, list);\n\t\tif (new->smk_masks > m_next->smk_masks) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_net4addr_insert(struct smk_net4addr *new)\n{\n\tstruct smk_net4addr *m;\n\tstruct smk_net4addr *m_next;\n\n\tif (list_empty(&smk_net4addr_list)) {\n\t\tlist_add_rcu(&new->list, &smk_net4addr_list);\n\t\treturn;\n\t}\n\n\tm = list_entry_rcu(smk_net4addr_list.next,\n\t\t\t   struct smk_net4addr, list);\n\n\t/* the comparison '>' is a bit hacky, but works */\n\tif (new->smk_masks > m->smk_masks) {\n\t\tlist_add_rcu(&new->list, &smk_net4addr_list);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_rcu(m, &smk_net4addr_list, list) {\n\t\tif (list_is_last(&m->list, &smk_net4addr_list)) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t\tm_next = list_entry_rcu(m->list.next,\n\t\t\t\t\tstruct smk_net4addr, list);\n\t\tif (new->smk_masks > m_next->smk_masks) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*snp)",
            "GFP_KERNEL"
          ],
          "line": 1254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_netlabel_audit_set",
          "args": [
            "&audit_info"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "smk_netlabel_audit_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "194-201",
          "snippet": "static void smk_netlabel_audit_set(struct netlbl_audit *nap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tnap->loginuid = audit_get_loginuid(current);\n\tnap->sessionid = audit_get_sessionid(current);\n\tnap->secid = skp->smk_secid;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_netlabel_audit_set(struct netlbl_audit *nap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tnap->loginuid = audit_get_loginuid(current);\n\tnap->sessionid = audit_get_sessionid(current);\n\tnap->secid = skp->smk_secid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "snp",
            "&smk_net4addr_list",
            "list"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&smk_net4addr_lock"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "temp_mask"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "smack",
            "SMACK_CIPSO_OPTION"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 1216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "smack",
            "0"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data",
            "\"%hhd.%hhd.%hhd.%hhd %s\"",
            "&host[0]",
            "&host[1]",
            "&host[2]",
            "&host[3]",
            "smack"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "data",
            "\"%hhd.%hhd.%hhd.%hhd/%u %s\"",
            "&host[0]",
            "&host[1]",
            "&host[2]",
            "&host[3]",
            "&masks",
            "smack"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "count + 1",
            "GFP_KERNEL"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_NETLBLADDRMIN\t9\n#define BEBITS\t(sizeof(__be32) * 8)\n\nstatic DEFINE_MUTEX(smk_net4addr_lock);\n\nstatic ssize_t smk_write_net4addr(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tstruct smk_net4addr *snp;\n\tstruct sockaddr_in newname;\n\tchar *smack;\n\tstruct smack_known *skp = NULL;\n\tchar *data;\n\tchar *host = (char *)&newname.sin_addr.s_addr;\n\tint rc;\n\tstruct netlbl_audit audit_info;\n\tstruct in_addr mask;\n\tunsigned int m;\n\tunsigned int masks;\n\tint found;\n\tu32 mask_bits = (1<<31);\n\t__be32 nsa;\n\tu32 temp_mask;\n\n\t/*\n\t * Must have privilege.\n\t * No partial writes.\n\t * Enough data must be present.\n\t * \"<addr/mask, as a.b.c.d/e><space><label>\"\n\t * \"<addr, as a.b.c.d><space><label>\"\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\tif (count < SMK_NETLBLADDRMIN)\n\t\treturn -EINVAL;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\tsmack = kzalloc(count + 1, GFP_KERNEL);\n\tif (smack == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto free_data_out;\n\t}\n\n\trc = sscanf(data, \"%hhd.%hhd.%hhd.%hhd/%u %s\",\n\t\t&host[0], &host[1], &host[2], &host[3], &masks, smack);\n\tif (rc != 6) {\n\t\trc = sscanf(data, \"%hhd.%hhd.%hhd.%hhd %s\",\n\t\t\t&host[0], &host[1], &host[2], &host[3], smack);\n\t\tif (rc != 5) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_out;\n\t\t}\n\t\tm = BEBITS;\n\t\tmasks = 32;\n\t}\n\tif (masks > BEBITS) {\n\t\trc = -EINVAL;\n\t\tgoto free_out;\n\t}\n\n\t/*\n\t * If smack begins with '-', it is an option, don't import it\n\t */\n\tif (smack[0] != '-') {\n\t\tskp = smk_import_entry(smack, 0);\n\t\tif (IS_ERR(skp)) {\n\t\t\trc = PTR_ERR(skp);\n\t\t\tgoto free_out;\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Only the -CIPSO option is supported for IPv4\n\t\t */\n\t\tif (strcmp(smack, SMACK_CIPSO_OPTION) != 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto free_out;\n\t\t}\n\t}\n\n\tfor (m = masks, temp_mask = 0; m > 0; m--) {\n\t\ttemp_mask |= mask_bits;\n\t\tmask_bits >>= 1;\n\t}\n\tmask.s_addr = cpu_to_be32(temp_mask);\n\n\tnewname.sin_addr.s_addr &= mask.s_addr;\n\t/*\n\t * Only allow one writer at a time. Writes should be\n\t * quite rare and small in any case.\n\t */\n\tmutex_lock(&smk_net4addr_lock);\n\n\tnsa = newname.sin_addr.s_addr;\n\t/* try to find if the prefix is already in the list */\n\tfound = 0;\n\tlist_for_each_entry_rcu(snp, &smk_net4addr_list, list) {\n\t\tif (snp->smk_host.s_addr == nsa && snp->smk_masks == masks) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tsmk_netlabel_audit_set(&audit_info);\n\n\tif (found == 0) {\n\t\tsnp = kzalloc(sizeof(*snp), GFP_KERNEL);\n\t\tif (snp == NULL)\n\t\t\trc = -ENOMEM;\n\t\telse {\n\t\t\trc = 0;\n\t\t\tsnp->smk_host.s_addr = newname.sin_addr.s_addr;\n\t\t\tsnp->smk_mask.s_addr = mask.s_addr;\n\t\t\tsnp->smk_label = skp;\n\t\t\tsnp->smk_masks = masks;\n\t\t\tsmk_net4addr_insert(snp);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Delete the unlabeled entry, only if the previous label\n\t\t * wasn't the special CIPSO option\n\t\t */\n\t\tif (snp->smk_label != NULL)\n\t\t\trc = netlbl_cfg_unlbl_static_del(&init_net, NULL,\n\t\t\t\t\t&snp->smk_host, &snp->smk_mask,\n\t\t\t\t\tPF_INET, &audit_info);\n\t\telse\n\t\t\trc = 0;\n\t\tsnp->smk_label = skp;\n\t}\n\n\t/*\n\t * Now tell netlabel about the single label nature of\n\t * this host so that incoming packets get labeled.\n\t * but only if we didn't get the special CIPSO option\n\t */\n\tif (rc == 0 && skp != NULL)\n\t\trc = netlbl_cfg_unlbl_static_add(&init_net, NULL,\n\t\t\t&snp->smk_host, &snp->smk_mask, PF_INET,\n\t\t\tsnp->smk_label->smk_secid, &audit_info);\n\n\tif (rc == 0)\n\t\trc = count;\n\n\tmutex_unlock(&smk_net4addr_lock);\n\nfree_out:\n\tkfree(smack);\nfree_data_out:\n\tkfree(data);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_net4addr_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1106-1137",
    "snippet": "static void smk_net4addr_insert(struct smk_net4addr *new)\n{\n\tstruct smk_net4addr *m;\n\tstruct smk_net4addr *m_next;\n\n\tif (list_empty(&smk_net4addr_list)) {\n\t\tlist_add_rcu(&new->list, &smk_net4addr_list);\n\t\treturn;\n\t}\n\n\tm = list_entry_rcu(smk_net4addr_list.next,\n\t\t\t   struct smk_net4addr, list);\n\n\t/* the comparison '>' is a bit hacky, but works */\n\tif (new->smk_masks > m->smk_masks) {\n\t\tlist_add_rcu(&new->list, &smk_net4addr_list);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_rcu(m, &smk_net4addr_list, list) {\n\t\tif (list_is_last(&m->list, &smk_net4addr_list)) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t\tm_next = list_entry_rcu(m->list.next,\n\t\t\t\t\tstruct smk_net4addr, list);\n\t\tif (new->smk_masks > m_next->smk_masks) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&new->list",
            "&m->list"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "m->list.next",
            "structsmk_net4addr",
            "list"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&new->list",
            "&m->list"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_last",
          "args": [
            "&m->list",
            "&smk_net4addr_list"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "m",
            "&smk_net4addr_list",
            "list"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&new->list",
            "&smk_net4addr_list"
          ],
          "line": 1121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "smk_net4addr_list.next",
            "structsmk_net4addr",
            "list"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&new->list",
            "&smk_net4addr_list"
          ],
          "line": 1112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&smk_net4addr_list"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_net4addr_insert(struct smk_net4addr *new)\n{\n\tstruct smk_net4addr *m;\n\tstruct smk_net4addr *m_next;\n\n\tif (list_empty(&smk_net4addr_list)) {\n\t\tlist_add_rcu(&new->list, &smk_net4addr_list);\n\t\treturn;\n\t}\n\n\tm = list_entry_rcu(smk_net4addr_list.next,\n\t\t\t   struct smk_net4addr, list);\n\n\t/* the comparison '>' is a bit hacky, but works */\n\tif (new->smk_masks > m->smk_masks) {\n\t\tlist_add_rcu(&new->list, &smk_net4addr_list);\n\t\treturn;\n\t}\n\n\tlist_for_each_entry_rcu(m, &smk_net4addr_list, list) {\n\t\tif (list_is_last(&m->list, &smk_net4addr_list)) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t\tm_next = list_entry_rcu(m->list.next,\n\t\t\t\t\tstruct smk_net4addr, list);\n\t\tif (new->smk_masks > m_next->smk_masks) {\n\t\t\tlist_add_rcu(&new->list, &m->list);\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "smk_open_net4addr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1092-1095",
    "snippet": "static int smk_open_net4addr(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &net4addr_seq_ops);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations net4addr_seq_ops = {\n\t.start = net4addr_seq_start,\n\t.next  = net4addr_seq_next,\n\t.show  = net4addr_seq_show,\n\t.stop  = smk_seq_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&net4addr_seq_ops"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic const struct seq_operations net4addr_seq_ops = {\n\t.start = net4addr_seq_start,\n\t.next  = net4addr_seq_next,\n\t.show  = net4addr_seq_show,\n\t.stop  = smk_seq_stop,\n};\n\nstatic int smk_open_net4addr(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &net4addr_seq_ops);\n}"
  },
  {
    "function_name": "net4addr_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1062-1075",
    "snippet": "static int net4addr_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smk_net4addr *skp =\n\t\t\tlist_entry_rcu(list, struct smk_net4addr, list);\n\tchar *kp = SMACK_CIPSO_OPTION;\n\n\tif (skp->smk_label != NULL)\n\t\tkp = skp->smk_label->smk_known;\n\tseq_printf(s, \"%pI4/%d %s\\n\", &skp->smk_host.s_addr,\n\t\t\tskp->smk_masks, kp);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%pI4/%d %s\\n\"",
            "&skp->smk_host.s_addr",
            "skp->smk_masks",
            "kp"
          ],
          "line": 1071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "list",
            "structsmk_net4addr",
            "list"
          ],
          "line": 1066
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int net4addr_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smk_net4addr *skp =\n\t\t\tlist_entry_rcu(list, struct smk_net4addr, list);\n\tchar *kp = SMACK_CIPSO_OPTION;\n\n\tif (skp->smk_label != NULL)\n\t\tkp = skp->smk_label->smk_known;\n\tseq_printf(s, \"%pI4/%d %s\\n\", &skp->smk_host.s_addr,\n\t\t\tskp->smk_masks, kp);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "net4addr_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1054-1057",
    "snippet": "static void *net4addr_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\treturn smk_seq_next(s, v, pos, &smk_net4addr_list);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_next",
          "args": [
            "s",
            "v",
            "pos",
            "&smk_net4addr_list"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "578-587",
          "snippet": "static void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *net4addr_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\treturn smk_seq_next(s, v, pos, &smk_net4addr_list);\n}"
  },
  {
    "function_name": "net4addr_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1049-1052",
    "snippet": "static void *net4addr_seq_start(struct seq_file *s, loff_t *pos)\n{\n\treturn smk_seq_start(s, pos, &smk_net4addr_list);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_start",
          "args": [
            "s",
            "pos",
            "&smk_net4addr_list"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "561-576",
          "snippet": "static void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *net4addr_seq_start(struct seq_file *s, loff_t *pos)\n{\n\treturn smk_seq_start(s, pos, &smk_net4addr_list);\n}"
  },
  {
    "function_name": "smk_write_cipso2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1031-1035",
    "snippet": "static ssize_t smk_write_cipso2(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\treturn smk_set_cipso(file, buf, count, ppos, SMK_LONG_FMT);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_LONG_FMT\t1\t/* Variable long label format */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_set_cipso",
          "args": [
            "file",
            "buf",
            "count",
            "ppos",
            "SMK_LONG_FMT"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "smk_set_cipso",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "859-945",
          "snippet": "static ssize_t smk_set_cipso(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos, int format)\n{\n\tstruct smack_known *skp;\n\tstruct netlbl_lsm_secattr ncats;\n\tchar mapcatset[SMK_CIPSOLEN];\n\tint maplevel;\n\tunsigned int cat;\n\tint catlen;\n\tssize_t rc = -EINVAL;\n\tchar *data = NULL;\n\tchar *rule;\n\tint ret;\n\tint i;\n\n\t/*\n\t * Must have privilege.\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\tif (format == SMK_FIXED24_FMT &&\n\t    (count < SMK_CIPSOMIN || count > SMK_CIPSOMAX))\n\t\treturn -EINVAL;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trule = data;\n\t/*\n\t * Only allow one writer at a time. Writes should be\n\t * quite rare and small in any case.\n\t */\n\tmutex_lock(&smack_cipso_lock);\n\n\tskp = smk_import_entry(rule, 0);\n\tif (IS_ERR(skp)) {\n\t\trc = PTR_ERR(skp);\n\t\tgoto out;\n\t}\n\n\tif (format == SMK_FIXED24_FMT)\n\t\trule += SMK_LABELLEN;\n\telse\n\t\trule += strlen(skp->smk_known) + 1;\n\n\tret = sscanf(rule, \"%d\", &maplevel);\n\tif (ret != 1 || maplevel > SMACK_CIPSO_MAXLEVEL)\n\t\tgoto out;\n\n\trule += SMK_DIGITLEN;\n\tret = sscanf(rule, \"%d\", &catlen);\n\tif (ret != 1 || catlen > SMACK_CIPSO_MAXCATNUM)\n\t\tgoto out;\n\n\tif (format == SMK_FIXED24_FMT &&\n\t    count != (SMK_CIPSOMIN + catlen * SMK_DIGITLEN))\n\t\tgoto out;\n\n\tmemset(mapcatset, 0, sizeof(mapcatset));\n\n\tfor (i = 0; i < catlen; i++) {\n\t\trule += SMK_DIGITLEN;\n\t\tret = sscanf(rule, \"%u\", &cat);\n\t\tif (ret != 1 || cat > SMACK_CIPSO_MAXCATNUM)\n\t\t\tgoto out;\n\n\t\tsmack_catset_bit(cat, mapcatset);\n\t}\n\n\trc = smk_netlbl_mls(maplevel, mapcatset, &ncats, SMK_CIPSOLEN);\n\tif (rc >= 0) {\n\t\tnetlbl_catmap_free(skp->smk_netlabel.attr.mls.cat);\n\t\tskp->smk_netlabel.attr.mls.cat = ncats.attr.mls.cat;\n\t\tskp->smk_netlabel.attr.mls.lvl = ncats.attr.mls.lvl;\n\t\trc = count;\n\t}\n\nout:\n\tmutex_unlock(&smack_cipso_lock);\n\tkfree(data);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */",
            "#define SMK_CIPSOMAX (SMK_CIPSOMIN + SMACK_CIPSO_MAXCATNUM * SMK_DIGITLEN)",
            "#define SMK_CIPSOMIN (SMK_LABELLEN + 2 * SMK_DIGITLEN)",
            "#define SMK_DIGITLEN 4"
          ],
          "globals_used": [
            "static DEFINE_MUTEX(smack_cipso_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n#define SMK_CIPSOMAX (SMK_CIPSOMIN + SMACK_CIPSO_MAXCATNUM * SMK_DIGITLEN)\n#define SMK_CIPSOMIN (SMK_LABELLEN + 2 * SMK_DIGITLEN)\n#define SMK_DIGITLEN 4\n\nstatic DEFINE_MUTEX(smack_cipso_lock);\n\nstatic ssize_t smk_set_cipso(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos, int format)\n{\n\tstruct smack_known *skp;\n\tstruct netlbl_lsm_secattr ncats;\n\tchar mapcatset[SMK_CIPSOLEN];\n\tint maplevel;\n\tunsigned int cat;\n\tint catlen;\n\tssize_t rc = -EINVAL;\n\tchar *data = NULL;\n\tchar *rule;\n\tint ret;\n\tint i;\n\n\t/*\n\t * Must have privilege.\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\tif (format == SMK_FIXED24_FMT &&\n\t    (count < SMK_CIPSOMIN || count > SMK_CIPSOMAX))\n\t\treturn -EINVAL;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trule = data;\n\t/*\n\t * Only allow one writer at a time. Writes should be\n\t * quite rare and small in any case.\n\t */\n\tmutex_lock(&smack_cipso_lock);\n\n\tskp = smk_import_entry(rule, 0);\n\tif (IS_ERR(skp)) {\n\t\trc = PTR_ERR(skp);\n\t\tgoto out;\n\t}\n\n\tif (format == SMK_FIXED24_FMT)\n\t\trule += SMK_LABELLEN;\n\telse\n\t\trule += strlen(skp->smk_known) + 1;\n\n\tret = sscanf(rule, \"%d\", &maplevel);\n\tif (ret != 1 || maplevel > SMACK_CIPSO_MAXLEVEL)\n\t\tgoto out;\n\n\trule += SMK_DIGITLEN;\n\tret = sscanf(rule, \"%d\", &catlen);\n\tif (ret != 1 || catlen > SMACK_CIPSO_MAXCATNUM)\n\t\tgoto out;\n\n\tif (format == SMK_FIXED24_FMT &&\n\t    count != (SMK_CIPSOMIN + catlen * SMK_DIGITLEN))\n\t\tgoto out;\n\n\tmemset(mapcatset, 0, sizeof(mapcatset));\n\n\tfor (i = 0; i < catlen; i++) {\n\t\trule += SMK_DIGITLEN;\n\t\tret = sscanf(rule, \"%u\", &cat);\n\t\tif (ret != 1 || cat > SMACK_CIPSO_MAXCATNUM)\n\t\t\tgoto out;\n\n\t\tsmack_catset_bit(cat, mapcatset);\n\t}\n\n\trc = smk_netlbl_mls(maplevel, mapcatset, &ncats, SMK_CIPSOLEN);\n\tif (rc >= 0) {\n\t\tnetlbl_catmap_free(skp->smk_netlabel.attr.mls.cat);\n\t\tskp->smk_netlabel.attr.mls.cat = ncats.attr.mls.cat;\n\t\tskp->smk_netlabel.attr.mls.lvl = ncats.attr.mls.lvl;\n\t\trc = count;\n\t}\n\nout:\n\tmutex_unlock(&smack_cipso_lock);\n\tkfree(data);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_LONG_FMT\t1\t/* Variable long label format */\n\nstatic ssize_t smk_write_cipso2(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\treturn smk_set_cipso(file, buf, count, ppos, SMK_LONG_FMT);\n}"
  },
  {
    "function_name": "smk_open_cipso2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "1016-1019",
    "snippet": "static int smk_open_cipso2(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &cipso2_seq_ops);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations cipso2_seq_ops = {\n\t.start = cipso_seq_start,\n\t.next  = cipso_seq_next,\n\t.show  = cipso2_seq_show,\n\t.stop  = smk_seq_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&cipso2_seq_ops"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic const struct seq_operations cipso2_seq_ops = {\n\t.start = cipso_seq_start,\n\t.next  = cipso_seq_next,\n\t.show  = cipso2_seq_show,\n\t.stop  = smk_seq_stop,\n};\n\nstatic int smk_open_cipso2(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &cipso2_seq_ops);\n}"
  },
  {
    "function_name": "cipso2_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "979-999",
    "snippet": "static int cipso2_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head  *list = v;\n\tstruct smack_known *skp =\n\t\tlist_entry_rcu(list, struct smack_known, list);\n\tstruct netlbl_lsm_catmap *cmp = skp->smk_netlabel.attr.mls.cat;\n\tchar sep = '/';\n\tint i;\n\n\tseq_printf(s, \"%s %3d\", skp->smk_known, skp->smk_netlabel.attr.mls.lvl);\n\n\tfor (i = netlbl_catmap_walk(cmp, 0); i >= 0;\n\t     i = netlbl_catmap_walk(cmp, i + 1)) {\n\t\tseq_printf(s, \"%c%d\", sep, i);\n\t\tsep = ',';\n\t}\n\n\tseq_putc(s, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%c%d\"",
            "sep",
            "i"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_catmap_walk",
          "args": [
            "cmp",
            "i + 1"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_catmap_walk",
          "args": [
            "cmp",
            "0"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%s %3d\"",
            "skp->smk_known",
            "skp->smk_netlabel.attr.mls.lvl"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "list",
            "structsmack_known",
            "list"
          ],
          "line": 983
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int cipso2_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head  *list = v;\n\tstruct smack_known *skp =\n\t\tlist_entry_rcu(list, struct smack_known, list);\n\tstruct netlbl_lsm_catmap *cmp = skp->smk_netlabel.attr.mls.cat;\n\tchar sep = '/';\n\tint i;\n\n\tseq_printf(s, \"%s %3d\", skp->smk_known, skp->smk_netlabel.attr.mls.lvl);\n\n\tfor (i = netlbl_catmap_walk(cmp, 0); i >= 0;\n\t     i = netlbl_catmap_walk(cmp, i + 1)) {\n\t\tseq_printf(s, \"%c%d\", sep, i);\n\t\tsep = ',';\n\t}\n\n\tseq_putc(s, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_write_cipso",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "957-961",
    "snippet": "static ssize_t smk_write_cipso(struct file *file, const char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\treturn smk_set_cipso(file, buf, count, ppos, SMK_FIXED24_FMT);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_set_cipso",
          "args": [
            "file",
            "buf",
            "count",
            "ppos",
            "SMK_FIXED24_FMT"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "smk_set_cipso",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "859-945",
          "snippet": "static ssize_t smk_set_cipso(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos, int format)\n{\n\tstruct smack_known *skp;\n\tstruct netlbl_lsm_secattr ncats;\n\tchar mapcatset[SMK_CIPSOLEN];\n\tint maplevel;\n\tunsigned int cat;\n\tint catlen;\n\tssize_t rc = -EINVAL;\n\tchar *data = NULL;\n\tchar *rule;\n\tint ret;\n\tint i;\n\n\t/*\n\t * Must have privilege.\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\tif (format == SMK_FIXED24_FMT &&\n\t    (count < SMK_CIPSOMIN || count > SMK_CIPSOMAX))\n\t\treturn -EINVAL;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trule = data;\n\t/*\n\t * Only allow one writer at a time. Writes should be\n\t * quite rare and small in any case.\n\t */\n\tmutex_lock(&smack_cipso_lock);\n\n\tskp = smk_import_entry(rule, 0);\n\tif (IS_ERR(skp)) {\n\t\trc = PTR_ERR(skp);\n\t\tgoto out;\n\t}\n\n\tif (format == SMK_FIXED24_FMT)\n\t\trule += SMK_LABELLEN;\n\telse\n\t\trule += strlen(skp->smk_known) + 1;\n\n\tret = sscanf(rule, \"%d\", &maplevel);\n\tif (ret != 1 || maplevel > SMACK_CIPSO_MAXLEVEL)\n\t\tgoto out;\n\n\trule += SMK_DIGITLEN;\n\tret = sscanf(rule, \"%d\", &catlen);\n\tif (ret != 1 || catlen > SMACK_CIPSO_MAXCATNUM)\n\t\tgoto out;\n\n\tif (format == SMK_FIXED24_FMT &&\n\t    count != (SMK_CIPSOMIN + catlen * SMK_DIGITLEN))\n\t\tgoto out;\n\n\tmemset(mapcatset, 0, sizeof(mapcatset));\n\n\tfor (i = 0; i < catlen; i++) {\n\t\trule += SMK_DIGITLEN;\n\t\tret = sscanf(rule, \"%u\", &cat);\n\t\tif (ret != 1 || cat > SMACK_CIPSO_MAXCATNUM)\n\t\t\tgoto out;\n\n\t\tsmack_catset_bit(cat, mapcatset);\n\t}\n\n\trc = smk_netlbl_mls(maplevel, mapcatset, &ncats, SMK_CIPSOLEN);\n\tif (rc >= 0) {\n\t\tnetlbl_catmap_free(skp->smk_netlabel.attr.mls.cat);\n\t\tskp->smk_netlabel.attr.mls.cat = ncats.attr.mls.cat;\n\t\tskp->smk_netlabel.attr.mls.lvl = ncats.attr.mls.lvl;\n\t\trc = count;\n\t}\n\nout:\n\tmutex_unlock(&smack_cipso_lock);\n\tkfree(data);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */",
            "#define SMK_CIPSOMAX (SMK_CIPSOMIN + SMACK_CIPSO_MAXCATNUM * SMK_DIGITLEN)",
            "#define SMK_CIPSOMIN (SMK_LABELLEN + 2 * SMK_DIGITLEN)",
            "#define SMK_DIGITLEN 4"
          ],
          "globals_used": [
            "static DEFINE_MUTEX(smack_cipso_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n#define SMK_CIPSOMAX (SMK_CIPSOMIN + SMACK_CIPSO_MAXCATNUM * SMK_DIGITLEN)\n#define SMK_CIPSOMIN (SMK_LABELLEN + 2 * SMK_DIGITLEN)\n#define SMK_DIGITLEN 4\n\nstatic DEFINE_MUTEX(smack_cipso_lock);\n\nstatic ssize_t smk_set_cipso(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos, int format)\n{\n\tstruct smack_known *skp;\n\tstruct netlbl_lsm_secattr ncats;\n\tchar mapcatset[SMK_CIPSOLEN];\n\tint maplevel;\n\tunsigned int cat;\n\tint catlen;\n\tssize_t rc = -EINVAL;\n\tchar *data = NULL;\n\tchar *rule;\n\tint ret;\n\tint i;\n\n\t/*\n\t * Must have privilege.\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\tif (format == SMK_FIXED24_FMT &&\n\t    (count < SMK_CIPSOMIN || count > SMK_CIPSOMAX))\n\t\treturn -EINVAL;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trule = data;\n\t/*\n\t * Only allow one writer at a time. Writes should be\n\t * quite rare and small in any case.\n\t */\n\tmutex_lock(&smack_cipso_lock);\n\n\tskp = smk_import_entry(rule, 0);\n\tif (IS_ERR(skp)) {\n\t\trc = PTR_ERR(skp);\n\t\tgoto out;\n\t}\n\n\tif (format == SMK_FIXED24_FMT)\n\t\trule += SMK_LABELLEN;\n\telse\n\t\trule += strlen(skp->smk_known) + 1;\n\n\tret = sscanf(rule, \"%d\", &maplevel);\n\tif (ret != 1 || maplevel > SMACK_CIPSO_MAXLEVEL)\n\t\tgoto out;\n\n\trule += SMK_DIGITLEN;\n\tret = sscanf(rule, \"%d\", &catlen);\n\tif (ret != 1 || catlen > SMACK_CIPSO_MAXCATNUM)\n\t\tgoto out;\n\n\tif (format == SMK_FIXED24_FMT &&\n\t    count != (SMK_CIPSOMIN + catlen * SMK_DIGITLEN))\n\t\tgoto out;\n\n\tmemset(mapcatset, 0, sizeof(mapcatset));\n\n\tfor (i = 0; i < catlen; i++) {\n\t\trule += SMK_DIGITLEN;\n\t\tret = sscanf(rule, \"%u\", &cat);\n\t\tif (ret != 1 || cat > SMACK_CIPSO_MAXCATNUM)\n\t\t\tgoto out;\n\n\t\tsmack_catset_bit(cat, mapcatset);\n\t}\n\n\trc = smk_netlbl_mls(maplevel, mapcatset, &ncats, SMK_CIPSOLEN);\n\tif (rc >= 0) {\n\t\tnetlbl_catmap_free(skp->smk_netlabel.attr.mls.cat);\n\t\tskp->smk_netlabel.attr.mls.cat = ncats.attr.mls.cat;\n\t\tskp->smk_netlabel.attr.mls.lvl = ncats.attr.mls.lvl;\n\t\trc = count;\n\t}\n\nout:\n\tmutex_unlock(&smack_cipso_lock);\n\tkfree(data);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n\nstatic ssize_t smk_write_cipso(struct file *file, const char __user *buf,\n\t\t\t       size_t count, loff_t *ppos)\n{\n\treturn smk_set_cipso(file, buf, count, ppos, SMK_FIXED24_FMT);\n}"
  },
  {
    "function_name": "smk_set_cipso",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "859-945",
    "snippet": "static ssize_t smk_set_cipso(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos, int format)\n{\n\tstruct smack_known *skp;\n\tstruct netlbl_lsm_secattr ncats;\n\tchar mapcatset[SMK_CIPSOLEN];\n\tint maplevel;\n\tunsigned int cat;\n\tint catlen;\n\tssize_t rc = -EINVAL;\n\tchar *data = NULL;\n\tchar *rule;\n\tint ret;\n\tint i;\n\n\t/*\n\t * Must have privilege.\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\tif (format == SMK_FIXED24_FMT &&\n\t    (count < SMK_CIPSOMIN || count > SMK_CIPSOMAX))\n\t\treturn -EINVAL;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trule = data;\n\t/*\n\t * Only allow one writer at a time. Writes should be\n\t * quite rare and small in any case.\n\t */\n\tmutex_lock(&smack_cipso_lock);\n\n\tskp = smk_import_entry(rule, 0);\n\tif (IS_ERR(skp)) {\n\t\trc = PTR_ERR(skp);\n\t\tgoto out;\n\t}\n\n\tif (format == SMK_FIXED24_FMT)\n\t\trule += SMK_LABELLEN;\n\telse\n\t\trule += strlen(skp->smk_known) + 1;\n\n\tret = sscanf(rule, \"%d\", &maplevel);\n\tif (ret != 1 || maplevel > SMACK_CIPSO_MAXLEVEL)\n\t\tgoto out;\n\n\trule += SMK_DIGITLEN;\n\tret = sscanf(rule, \"%d\", &catlen);\n\tif (ret != 1 || catlen > SMACK_CIPSO_MAXCATNUM)\n\t\tgoto out;\n\n\tif (format == SMK_FIXED24_FMT &&\n\t    count != (SMK_CIPSOMIN + catlen * SMK_DIGITLEN))\n\t\tgoto out;\n\n\tmemset(mapcatset, 0, sizeof(mapcatset));\n\n\tfor (i = 0; i < catlen; i++) {\n\t\trule += SMK_DIGITLEN;\n\t\tret = sscanf(rule, \"%u\", &cat);\n\t\tif (ret != 1 || cat > SMACK_CIPSO_MAXCATNUM)\n\t\t\tgoto out;\n\n\t\tsmack_catset_bit(cat, mapcatset);\n\t}\n\n\trc = smk_netlbl_mls(maplevel, mapcatset, &ncats, SMK_CIPSOLEN);\n\tif (rc >= 0) {\n\t\tnetlbl_catmap_free(skp->smk_netlabel.attr.mls.cat);\n\t\tskp->smk_netlabel.attr.mls.cat = ncats.attr.mls.cat;\n\t\tskp->smk_netlabel.attr.mls.lvl = ncats.attr.mls.lvl;\n\t\trc = count;\n\t}\n\nout:\n\tmutex_unlock(&smack_cipso_lock);\n\tkfree(data);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */",
      "#define SMK_CIPSOMAX (SMK_CIPSOMIN + SMACK_CIPSO_MAXCATNUM * SMK_DIGITLEN)",
      "#define SMK_CIPSOMIN (SMK_LABELLEN + 2 * SMK_DIGITLEN)",
      "#define SMK_DIGITLEN 4"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(smack_cipso_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&smack_cipso_lock"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_catmap_free",
          "args": [
            "skp->smk_netlabel.attr.mls.cat"
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_netlbl_mls",
          "args": [
            "maplevel",
            "mapcatset",
            "&ncats",
            "SMK_CIPSOLEN"
          ],
          "line": 933
        },
        "resolved": true,
        "details": {
          "function_name": "smk_netlbl_mls",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "489-515",
          "snippet": "int smk_netlbl_mls(int level, char *catset, struct netlbl_lsm_secattr *sap,\n\t\t\tint len)\n{\n\tunsigned char *cp;\n\tunsigned char m;\n\tint cat;\n\tint rc;\n\tint byte;\n\n\tsap->flags |= NETLBL_SECATTR_MLS_CAT;\n\tsap->attr.mls.lvl = level;\n\tsap->attr.mls.cat = NULL;\n\n\tfor (cat = 1, cp = catset, byte = 0; byte < len; cp++, byte++)\n\t\tfor (m = 0x80; m != 0; m >>= 1, cat++) {\n\t\t\tif ((m & *cp) == 0)\n\t\t\t\tcontinue;\n\t\t\trc = netlbl_catmap_setbit(&sap->attr.mls.cat,\n\t\t\t\t\t\t  cat, GFP_KERNEL);\n\t\t\tif (rc < 0) {\n\t\t\t\tnetlbl_catmap_free(sap->attr.mls.cat);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nint smk_netlbl_mls(int level, char *catset, struct netlbl_lsm_secattr *sap,\n\t\t\tint len)\n{\n\tunsigned char *cp;\n\tunsigned char m;\n\tint cat;\n\tint rc;\n\tint byte;\n\n\tsap->flags |= NETLBL_SECATTR_MLS_CAT;\n\tsap->attr.mls.lvl = level;\n\tsap->attr.mls.cat = NULL;\n\n\tfor (cat = 1, cp = catset, byte = 0; byte < len; cp++, byte++)\n\t\tfor (m = 0x80; m != 0; m >>= 1, cat++) {\n\t\t\tif ((m & *cp) == 0)\n\t\t\t\tcontinue;\n\t\t\trc = netlbl_catmap_setbit(&sap->attr.mls.cat,\n\t\t\t\t\t\t  cat, GFP_KERNEL);\n\t\t\tif (rc < 0) {\n\t\t\t\tnetlbl_catmap_free(sap->attr.mls.cat);\n\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_catset_bit",
          "args": [
            "cat",
            "mapcatset"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "smack_catset_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "182-188",
          "snippet": "static inline void smack_catset_bit(unsigned int cat, char *catsetp)\n{\n\tif (cat == 0 || cat > (SMK_CIPSOLEN * 8))\n\t\treturn;\n\n\tcatsetp[(cat - 1) / 8] |= 0x80 >> ((cat - 1) % 8);\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic inline void smack_catset_bit(unsigned int cat, char *catsetp)\n{\n\tif (cat == 0 || cat > (SMK_CIPSOLEN * 8))\n\t\treturn;\n\n\tcatsetp[(cat - 1) / 8] |= 0x80 >> ((cat - 1) % 8);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "rule",
            "\"%u\"",
            "&cat"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "mapcatset",
            "0",
            "sizeof(mapcatset)"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "rule",
            "\"%d\"",
            "&catlen"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "rule",
            "\"%d\"",
            "&maplevel"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "skp->smk_known"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "skp"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skp"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "rule",
            "0"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&smack_cipso_lock"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n#define SMK_CIPSOMAX (SMK_CIPSOMIN + SMACK_CIPSO_MAXCATNUM * SMK_DIGITLEN)\n#define SMK_CIPSOMIN (SMK_LABELLEN + 2 * SMK_DIGITLEN)\n#define SMK_DIGITLEN 4\n\nstatic DEFINE_MUTEX(smack_cipso_lock);\n\nstatic ssize_t smk_set_cipso(struct file *file, const char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos, int format)\n{\n\tstruct smack_known *skp;\n\tstruct netlbl_lsm_secattr ncats;\n\tchar mapcatset[SMK_CIPSOLEN];\n\tint maplevel;\n\tunsigned int cat;\n\tint catlen;\n\tssize_t rc = -EINVAL;\n\tchar *data = NULL;\n\tchar *rule;\n\tint ret;\n\tint i;\n\n\t/*\n\t * Must have privilege.\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\tif (format == SMK_FIXED24_FMT &&\n\t    (count < SMK_CIPSOMIN || count > SMK_CIPSOMAX))\n\t\treturn -EINVAL;\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\trule = data;\n\t/*\n\t * Only allow one writer at a time. Writes should be\n\t * quite rare and small in any case.\n\t */\n\tmutex_lock(&smack_cipso_lock);\n\n\tskp = smk_import_entry(rule, 0);\n\tif (IS_ERR(skp)) {\n\t\trc = PTR_ERR(skp);\n\t\tgoto out;\n\t}\n\n\tif (format == SMK_FIXED24_FMT)\n\t\trule += SMK_LABELLEN;\n\telse\n\t\trule += strlen(skp->smk_known) + 1;\n\n\tret = sscanf(rule, \"%d\", &maplevel);\n\tif (ret != 1 || maplevel > SMACK_CIPSO_MAXLEVEL)\n\t\tgoto out;\n\n\trule += SMK_DIGITLEN;\n\tret = sscanf(rule, \"%d\", &catlen);\n\tif (ret != 1 || catlen > SMACK_CIPSO_MAXCATNUM)\n\t\tgoto out;\n\n\tif (format == SMK_FIXED24_FMT &&\n\t    count != (SMK_CIPSOMIN + catlen * SMK_DIGITLEN))\n\t\tgoto out;\n\n\tmemset(mapcatset, 0, sizeof(mapcatset));\n\n\tfor (i = 0; i < catlen; i++) {\n\t\trule += SMK_DIGITLEN;\n\t\tret = sscanf(rule, \"%u\", &cat);\n\t\tif (ret != 1 || cat > SMACK_CIPSO_MAXCATNUM)\n\t\t\tgoto out;\n\n\t\tsmack_catset_bit(cat, mapcatset);\n\t}\n\n\trc = smk_netlbl_mls(maplevel, mapcatset, &ncats, SMK_CIPSOLEN);\n\tif (rc >= 0) {\n\t\tnetlbl_catmap_free(skp->smk_netlabel.attr.mls.cat);\n\t\tskp->smk_netlabel.attr.mls.cat = ncats.attr.mls.cat;\n\t\tskp->smk_netlabel.attr.mls.lvl = ncats.attr.mls.lvl;\n\t\trc = count;\n\t}\n\nout:\n\tmutex_unlock(&smack_cipso_lock);\n\tkfree(data);\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_open_cipso",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "843-846",
    "snippet": "static int smk_open_cipso(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &cipso_seq_ops);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations cipso_seq_ops = {\n\t.start = cipso_seq_start,\n\t.next  = cipso_seq_next,\n\t.show  = cipso_seq_show,\n\t.stop  = smk_seq_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&cipso_seq_ops"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic const struct seq_operations cipso_seq_ops = {\n\t.start = cipso_seq_start,\n\t.next  = cipso_seq_next,\n\t.show  = cipso_seq_show,\n\t.stop  = smk_seq_stop,\n};\n\nstatic int smk_open_cipso(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &cipso_seq_ops);\n}"
  },
  {
    "function_name": "cipso_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "795-826",
    "snippet": "static int cipso_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head  *list = v;\n\tstruct smack_known *skp =\n\t\tlist_entry_rcu(list, struct smack_known, list);\n\tstruct netlbl_lsm_catmap *cmp = skp->smk_netlabel.attr.mls.cat;\n\tchar sep = '/';\n\tint i;\n\n\t/*\n\t * Don't show a label that could not have been set using\n\t * /smack/cipso. This is in support of the notion that\n\t * anything read from /smack/cipso ought to be writeable\n\t * to /smack/cipso.\n\t *\n\t * /smack/cipso2 should be used instead.\n\t */\n\tif (strlen(skp->smk_known) >= SMK_LABELLEN)\n\t\treturn 0;\n\n\tseq_printf(s, \"%s %3d\", skp->smk_known, skp->smk_netlabel.attr.mls.lvl);\n\n\tfor (i = netlbl_catmap_walk(cmp, 0); i >= 0;\n\t     i = netlbl_catmap_walk(cmp, i + 1)) {\n\t\tseq_printf(s, \"%c%d\", sep, i);\n\t\tsep = ',';\n\t}\n\n\tseq_putc(s, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%c%d\"",
            "sep",
            "i"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_catmap_walk",
          "args": [
            "cmp",
            "i + 1"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_catmap_walk",
          "args": [
            "cmp",
            "0"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%s %3d\"",
            "skp->smk_known",
            "skp->smk_netlabel.attr.mls.lvl"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "skp->smk_known"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "list",
            "structsmack_known",
            "list"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int cipso_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head  *list = v;\n\tstruct smack_known *skp =\n\t\tlist_entry_rcu(list, struct smack_known, list);\n\tstruct netlbl_lsm_catmap *cmp = skp->smk_netlabel.attr.mls.cat;\n\tchar sep = '/';\n\tint i;\n\n\t/*\n\t * Don't show a label that could not have been set using\n\t * /smack/cipso. This is in support of the notion that\n\t * anything read from /smack/cipso ought to be writeable\n\t * to /smack/cipso.\n\t *\n\t * /smack/cipso2 should be used instead.\n\t */\n\tif (strlen(skp->smk_known) >= SMK_LABELLEN)\n\t\treturn 0;\n\n\tseq_printf(s, \"%s %3d\", skp->smk_known, skp->smk_netlabel.attr.mls.lvl);\n\n\tfor (i = netlbl_catmap_walk(cmp, 0); i >= 0;\n\t     i = netlbl_catmap_walk(cmp, i + 1)) {\n\t\tseq_printf(s, \"%c%d\", sep, i);\n\t\tsep = ',';\n\t}\n\n\tseq_putc(s, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cipso_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "786-789",
    "snippet": "static void *cipso_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\treturn smk_seq_next(s, v, pos, &smack_known_list);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_next",
          "args": [
            "s",
            "v",
            "pos",
            "&smack_known_list"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "578-587",
          "snippet": "static void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *cipso_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\treturn smk_seq_next(s, v, pos, &smack_known_list);\n}"
  },
  {
    "function_name": "cipso_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "781-784",
    "snippet": "static void *cipso_seq_start(struct seq_file *s, loff_t *pos)\n{\n\treturn smk_seq_start(s, pos, &smack_known_list);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_start",
          "args": [
            "s",
            "pos",
            "&smack_known_list"
          ],
          "line": 783
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "561-576",
          "snippet": "static void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *cipso_seq_start(struct seq_file *s, loff_t *pos)\n{\n\treturn smk_seq_start(s, pos, &smack_known_list);\n}"
  },
  {
    "function_name": "smk_unlbl_ambient",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "754-775",
    "snippet": "static void smk_unlbl_ambient(char *oldambient)\n{\n\tint rc;\n\tstruct netlbl_audit nai;\n\n\tsmk_netlabel_audit_set(&nai);\n\n\tif (oldambient != NULL) {\n\t\trc = netlbl_cfg_map_del(oldambient, PF_INET, NULL, NULL, &nai);\n\t\tif (rc != 0)\n\t\t\tprintk(KERN_WARNING \"%s:%d remove rc = %d\\n\",\n\t\t\t       __func__, __LINE__, rc);\n\t}\n\tif (smack_net_ambient == NULL)\n\t\tsmack_net_ambient = &smack_known_floor;\n\n\trc = netlbl_cfg_unlbl_map_add(smack_net_ambient->smk_known, PF_INET,\n\t\t\t\t      NULL, NULL, &nai);\n\tif (rc != 0)\n\t\tprintk(KERN_WARNING \"%s:%d add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct smack_known *smack_net_ambient;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s:%d add rc = %d\\n\"",
            "__func__",
            "__LINE__",
            "rc"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1764-1785",
          "snippet": "void aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_cfg_unlbl_map_add",
          "args": [
            "smack_net_ambient->smk_known",
            "PF_INET",
            "NULL",
            "NULL",
            "&nai"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_cfg_map_del",
          "args": [
            "oldambient",
            "PF_INET",
            "NULL",
            "NULL",
            "&nai"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_netlabel_audit_set",
          "args": [
            "&nai"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "smk_netlabel_audit_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "194-201",
          "snippet": "static void smk_netlabel_audit_set(struct netlbl_audit *nap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tnap->loginuid = audit_get_loginuid(current);\n\tnap->sessionid = audit_get_sessionid(current);\n\tnap->secid = skp->smk_secid;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_netlabel_audit_set(struct netlbl_audit *nap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tnap->loginuid = audit_get_loginuid(current);\n\tnap->sessionid = audit_get_sessionid(current);\n\tnap->secid = skp->smk_secid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstruct smack_known *smack_net_ambient;\n\nstatic void smk_unlbl_ambient(char *oldambient)\n{\n\tint rc;\n\tstruct netlbl_audit nai;\n\n\tsmk_netlabel_audit_set(&nai);\n\n\tif (oldambient != NULL) {\n\t\trc = netlbl_cfg_map_del(oldambient, PF_INET, NULL, NULL, &nai);\n\t\tif (rc != 0)\n\t\t\tprintk(KERN_WARNING \"%s:%d remove rc = %d\\n\",\n\t\t\t       __func__, __LINE__, rc);\n\t}\n\tif (smack_net_ambient == NULL)\n\t\tsmack_net_ambient = &smack_known_floor;\n\n\trc = netlbl_cfg_unlbl_map_add(smack_net_ambient->smk_known, PF_INET,\n\t\t\t\t      NULL, NULL, &nai);\n\tif (rc != 0)\n\t\tprintk(KERN_WARNING \"%s:%d add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n}"
  },
  {
    "function_name": "smk_cipso_doi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "711-748",
    "snippet": "static void smk_cipso_doi(void)\n{\n\tint rc;\n\tstruct cipso_v4_doi *doip;\n\tstruct netlbl_audit nai;\n\n\tsmk_netlabel_audit_set(&nai);\n\n\trc = netlbl_cfg_map_del(NULL, PF_INET, NULL, NULL, &nai);\n\tif (rc != 0)\n\t\tprintk(KERN_WARNING \"%s:%d remove rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\n\tdoip = kmalloc(sizeof(struct cipso_v4_doi), GFP_KERNEL);\n\tif (doip == NULL)\n\t\tpanic(\"smack:  Failed to initialize cipso DOI.\\n\");\n\tdoip->map.std = NULL;\n\tdoip->doi = smk_cipso_doi_value;\n\tdoip->type = CIPSO_V4_MAP_PASS;\n\tdoip->tags[0] = CIPSO_V4_TAG_RBITMAP;\n\tfor (rc = 1; rc < CIPSO_V4_TAG_MAXCNT; rc++)\n\t\tdoip->tags[rc] = CIPSO_V4_TAG_INVALID;\n\n\trc = netlbl_cfg_cipsov4_add(doip, &nai);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING \"%s:%d cipso add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\t\tkfree(doip);\n\t\treturn;\n\t}\n\trc = netlbl_cfg_cipsov4_map_add(doip->doi, NULL, NULL, NULL, &nai);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING \"%s:%d map add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\t\tkfree(doip);\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int smk_cipso_doi_value = SMACK_CIPSO_DOI_DEFAULT;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "doip"
          ],
          "line": 745
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"%s:%d map add rc = %d\\n\"",
            "__func__",
            "__LINE__",
            "rc"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1764-1785",
          "snippet": "void aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_cfg_cipsov4_map_add",
          "args": [
            "doip->doi",
            "NULL",
            "NULL",
            "NULL",
            "&nai"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "doip"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_cfg_cipsov4_add",
          "args": [
            "doip",
            "&nai"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"smack:  Failed to initialize cipso DOI.\\n\""
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct cipso_v4_doi)",
            "GFP_KERNEL"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_cfg_map_del",
          "args": [
            "NULL",
            "PF_INET",
            "NULL",
            "NULL",
            "&nai"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_netlabel_audit_set",
          "args": [
            "&nai"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "smk_netlabel_audit_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "194-201",
          "snippet": "static void smk_netlabel_audit_set(struct netlbl_audit *nap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tnap->loginuid = audit_get_loginuid(current);\n\tnap->sessionid = audit_get_sessionid(current);\n\tnap->secid = skp->smk_secid;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_netlabel_audit_set(struct netlbl_audit *nap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tnap->loginuid = audit_get_loginuid(current);\n\tnap->sessionid = audit_get_sessionid(current);\n\tnap->secid = skp->smk_secid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_cipso_doi_value = SMACK_CIPSO_DOI_DEFAULT;\n\nstatic void smk_cipso_doi(void)\n{\n\tint rc;\n\tstruct cipso_v4_doi *doip;\n\tstruct netlbl_audit nai;\n\n\tsmk_netlabel_audit_set(&nai);\n\n\trc = netlbl_cfg_map_del(NULL, PF_INET, NULL, NULL, &nai);\n\tif (rc != 0)\n\t\tprintk(KERN_WARNING \"%s:%d remove rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\n\tdoip = kmalloc(sizeof(struct cipso_v4_doi), GFP_KERNEL);\n\tif (doip == NULL)\n\t\tpanic(\"smack:  Failed to initialize cipso DOI.\\n\");\n\tdoip->map.std = NULL;\n\tdoip->doi = smk_cipso_doi_value;\n\tdoip->type = CIPSO_V4_MAP_PASS;\n\tdoip->tags[0] = CIPSO_V4_TAG_RBITMAP;\n\tfor (rc = 1; rc < CIPSO_V4_TAG_MAXCNT; rc++)\n\t\tdoip->tags[rc] = CIPSO_V4_TAG_INVALID;\n\n\trc = netlbl_cfg_cipsov4_add(doip, &nai);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING \"%s:%d cipso add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\t\tkfree(doip);\n\t\treturn;\n\t}\n\trc = netlbl_cfg_cipsov4_map_add(doip->doi, NULL, NULL, NULL, &nai);\n\tif (rc != 0) {\n\t\tprintk(KERN_WARNING \"%s:%d map add rc = %d\\n\",\n\t\t       __func__, __LINE__, rc);\n\t\tkfree(doip);\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "smk_write_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "685-698",
    "snippet": "static ssize_t smk_write_load(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\t/*\n\t * Must have privilege.\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\treturn smk_write_rules_list(file, buf, count, ppos, NULL, NULL,\n\t\t\t\t    SMK_FIXED24_FMT);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_write_rules_list",
          "args": [
            "file",
            "buf",
            "count",
            "ppos",
            "NULL",
            "NULL",
            "SMK_FIXED24_FMT"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "smk_write_rules_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "473-555",
          "snippet": "static ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\t\tstruct list_head *rule_list,\n\t\t\t\t\tstruct mutex *rule_lock, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint rc;\n\tint trunc = 0;\n\tint tokens;\n\tssize_t cnt = 0;\n\n\t/*\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\t/*\n\t\t * Minor hack for backward compatibility\n\t\t */\n\t\tif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (count >= PAGE_SIZE) {\n\t\t\tcount = PAGE_SIZE - 1;\n\t\t\ttrunc = 1;\n\t\t}\n\t}\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * In case of parsing only part of user buf,\n\t * avoid having partial rule at the data buffer\n\t */\n\tif (trunc) {\n\t\twhile (count > 0 && (data[count - 1] != '\\n'))\n\t\t\t--count;\n\t\tif (count == 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdata[count] = '\\0';\n\ttokens = (format == SMK_CHANGE_FMT ? 4 : 3);\n\twhile (cnt < count) {\n\t\tif (format == SMK_FIXED24_FMT) {\n\t\t\trc = smk_parse_rule(data, &rule, 1);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tcnt = count;\n\t\t} else {\n\t\t\trc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tif (rc == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcnt += rc;\n\t\t}\n\n\t\tif (rule_list == NULL)\n\t\t\trc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\n\t\t\t\t&rule.smk_subject->smk_rules_lock, 1);\n\t\telse\n\t\t\trc = smk_set_access(&rule, rule_list, rule_lock, 0);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = cnt;\nout:\n\tkfree(data);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define SMK_CHANGE_FMT\t2\t/* Rule modification format */",
            "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */",
            "#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)",
            "#define SMK_OLOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_CHANGE_FMT\t2\t/* Rule modification format */\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)\n#define SMK_OLOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)\n\nstatic ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\t\tstruct list_head *rule_list,\n\t\t\t\t\tstruct mutex *rule_lock, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint rc;\n\tint trunc = 0;\n\tint tokens;\n\tssize_t cnt = 0;\n\n\t/*\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\t/*\n\t\t * Minor hack for backward compatibility\n\t\t */\n\t\tif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (count >= PAGE_SIZE) {\n\t\t\tcount = PAGE_SIZE - 1;\n\t\t\ttrunc = 1;\n\t\t}\n\t}\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * In case of parsing only part of user buf,\n\t * avoid having partial rule at the data buffer\n\t */\n\tif (trunc) {\n\t\twhile (count > 0 && (data[count - 1] != '\\n'))\n\t\t\t--count;\n\t\tif (count == 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdata[count] = '\\0';\n\ttokens = (format == SMK_CHANGE_FMT ? 4 : 3);\n\twhile (cnt < count) {\n\t\tif (format == SMK_FIXED24_FMT) {\n\t\t\trc = smk_parse_rule(data, &rule, 1);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tcnt = count;\n\t\t} else {\n\t\t\trc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tif (rc == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcnt += rc;\n\t\t}\n\n\t\tif (rule_list == NULL)\n\t\t\trc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\n\t\t\t\t&rule.smk_subject->smk_rules_lock, 1);\n\t\telse\n\t\t\trc = smk_set_access(&rule, rule_list, rule_lock, 0);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = cnt;\nout:\n\tkfree(data);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smack_privileged",
          "args": [
            "CAP_MAC_ADMIN"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "smack_privileged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "632-664",
          "snippet": "bool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nbool smack_privileged(int cap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\tstruct smack_known_list_elem *sklep;\n\tint rc;\n\n\t/*\n\t * All kernel tasks are privileged\n\t */\n\tif (unlikely(current->flags & PF_KTHREAD))\n\t\treturn true;\n\n\trc = cap_capable(current_cred(), &init_user_ns, cap,\n\t\t\t\tSECURITY_CAP_AUDIT);\n\tif (rc)\n\t\treturn false;\n\n\trcu_read_lock();\n\tif (list_empty(&smack_onlycap_list)) {\n\t\trcu_read_unlock();\n\t\treturn true;\n\t}\n\n\tlist_for_each_entry_rcu(sklep, &smack_onlycap_list, list) {\n\t\tif (sklep->smk_label == skp) {\n\t\t\trcu_read_unlock();\n\t\t\treturn true;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n\nstatic ssize_t smk_write_load(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\t/*\n\t * Must have privilege.\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (!smack_privileged(CAP_MAC_ADMIN))\n\t\treturn -EPERM;\n\n\treturn smk_write_rules_list(file, buf, count, ppos, NULL, NULL,\n\t\t\t\t    SMK_FIXED24_FMT);\n}"
  },
  {
    "function_name": "smk_open_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "672-675",
    "snippet": "static int smk_open_load(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &load_seq_ops);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations load_seq_ops = {\n\t.start = load2_seq_start,\n\t.next  = load2_seq_next,\n\t.show  = load_seq_show,\n\t.stop  = smk_seq_stop,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&load_seq_ops"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic const struct seq_operations load_seq_ops = {\n\t.start = load2_seq_start,\n\t.next  = load2_seq_next,\n\t.show  = load_seq_show,\n\t.stop  = smk_seq_stop,\n};\n\nstatic int smk_open_load(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &load_seq_ops);\n}"
  },
  {
    "function_name": "load_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "647-656",
    "snippet": "static int load_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smack_master_list *smlp =\n\t\tlist_entry_rcu(list, struct smack_master_list, list);\n\n\tsmk_rule_show(s, smlp->smk_rule, SMK_LABELLEN);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_rule_show",
          "args": [
            "s",
            "smlp->smk_rule",
            "SMK_LABELLEN"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "smk_rule_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "594-631",
          "snippet": "static void smk_rule_show(struct seq_file *s, struct smack_rule *srp, int max)\n{\n\t/*\n\t * Don't show any rules with label names too long for\n\t * interface file (/smack/load or /smack/load2)\n\t * because you should expect to be able to write\n\t * anything you read back.\n\t */\n\tif (strlen(srp->smk_subject->smk_known) >= max ||\n\t    strlen(srp->smk_object->smk_known) >= max)\n\t\treturn;\n\n\tif (srp->smk_access == 0)\n\t\treturn;\n\n\tseq_printf(s, \"%s %s\",\n\t\t   srp->smk_subject->smk_known,\n\t\t   srp->smk_object->smk_known);\n\n\tseq_putc(s, ' ');\n\n\tif (srp->smk_access & MAY_READ)\n\t\tseq_putc(s, 'r');\n\tif (srp->smk_access & MAY_WRITE)\n\t\tseq_putc(s, 'w');\n\tif (srp->smk_access & MAY_EXEC)\n\t\tseq_putc(s, 'x');\n\tif (srp->smk_access & MAY_APPEND)\n\t\tseq_putc(s, 'a');\n\tif (srp->smk_access & MAY_TRANSMUTE)\n\t\tseq_putc(s, 't');\n\tif (srp->smk_access & MAY_LOCK)\n\t\tseq_putc(s, 'l');\n\tif (srp->smk_access & MAY_BRINGUP)\n\t\tseq_putc(s, 'b');\n\n\tseq_putc(s, '\\n');\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_rule_show(struct seq_file *s, struct smack_rule *srp, int max)\n{\n\t/*\n\t * Don't show any rules with label names too long for\n\t * interface file (/smack/load or /smack/load2)\n\t * because you should expect to be able to write\n\t * anything you read back.\n\t */\n\tif (strlen(srp->smk_subject->smk_known) >= max ||\n\t    strlen(srp->smk_object->smk_known) >= max)\n\t\treturn;\n\n\tif (srp->smk_access == 0)\n\t\treturn;\n\n\tseq_printf(s, \"%s %s\",\n\t\t   srp->smk_subject->smk_known,\n\t\t   srp->smk_object->smk_known);\n\n\tseq_putc(s, ' ');\n\n\tif (srp->smk_access & MAY_READ)\n\t\tseq_putc(s, 'r');\n\tif (srp->smk_access & MAY_WRITE)\n\t\tseq_putc(s, 'w');\n\tif (srp->smk_access & MAY_EXEC)\n\t\tseq_putc(s, 'x');\n\tif (srp->smk_access & MAY_APPEND)\n\t\tseq_putc(s, 'a');\n\tif (srp->smk_access & MAY_TRANSMUTE)\n\t\tseq_putc(s, 't');\n\tif (srp->smk_access & MAY_LOCK)\n\t\tseq_putc(s, 'l');\n\tif (srp->smk_access & MAY_BRINGUP)\n\t\tseq_putc(s, 'b');\n\n\tseq_putc(s, '\\n');\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "list",
            "structsmack_master_list",
            "list"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int load_seq_show(struct seq_file *s, void *v)\n{\n\tstruct list_head *list = v;\n\tstruct smack_master_list *smlp =\n\t\tlist_entry_rcu(list, struct smack_master_list, list);\n\n\tsmk_rule_show(s, smlp->smk_rule, SMK_LABELLEN);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "load2_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "642-645",
    "snippet": "static void *load2_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\treturn smk_seq_next(s, v, pos, &smack_rule_list);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(smack_rule_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_next",
          "args": [
            "s",
            "v",
            "pos",
            "&smack_rule_list"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "578-587",
          "snippet": "static void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(smack_rule_list);\n\nstatic void *load2_seq_next(struct seq_file *s, void *v, loff_t *pos)\n{\n\treturn smk_seq_next(s, v, pos, &smack_rule_list);\n}"
  },
  {
    "function_name": "load2_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "637-640",
    "snippet": "static void *load2_seq_start(struct seq_file *s, loff_t *pos)\n{\n\treturn smk_seq_start(s, pos, &smack_rule_list);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(smack_rule_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_seq_start",
          "args": [
            "s",
            "pos",
            "&smack_rule_list"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "smk_seq_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "561-576",
          "snippet": "static void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(smack_rule_list);\n\nstatic void *load2_seq_start(struct seq_file *s, loff_t *pos)\n{\n\treturn smk_seq_start(s, pos, &smack_rule_list);\n}"
  },
  {
    "function_name": "smk_rule_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "594-631",
    "snippet": "static void smk_rule_show(struct seq_file *s, struct smack_rule *srp, int max)\n{\n\t/*\n\t * Don't show any rules with label names too long for\n\t * interface file (/smack/load or /smack/load2)\n\t * because you should expect to be able to write\n\t * anything you read back.\n\t */\n\tif (strlen(srp->smk_subject->smk_known) >= max ||\n\t    strlen(srp->smk_object->smk_known) >= max)\n\t\treturn;\n\n\tif (srp->smk_access == 0)\n\t\treturn;\n\n\tseq_printf(s, \"%s %s\",\n\t\t   srp->smk_subject->smk_known,\n\t\t   srp->smk_object->smk_known);\n\n\tseq_putc(s, ' ');\n\n\tif (srp->smk_access & MAY_READ)\n\t\tseq_putc(s, 'r');\n\tif (srp->smk_access & MAY_WRITE)\n\t\tseq_putc(s, 'w');\n\tif (srp->smk_access & MAY_EXEC)\n\t\tseq_putc(s, 'x');\n\tif (srp->smk_access & MAY_APPEND)\n\t\tseq_putc(s, 'a');\n\tif (srp->smk_access & MAY_TRANSMUTE)\n\t\tseq_putc(s, 't');\n\tif (srp->smk_access & MAY_LOCK)\n\t\tseq_putc(s, 'l');\n\tif (srp->smk_access & MAY_BRINGUP)\n\t\tseq_putc(s, 'b');\n\n\tseq_putc(s, '\\n');\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'b'"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'l'"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'t'"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'a'"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'x'"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'w'"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "'r'"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "s",
            "' '"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"%s %s\"",
            "srp->smk_subject->smk_known",
            "srp->smk_object->smk_known"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "srp->smk_object->smk_known"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "srp->smk_subject->smk_known"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_rule_show(struct seq_file *s, struct smack_rule *srp, int max)\n{\n\t/*\n\t * Don't show any rules with label names too long for\n\t * interface file (/smack/load or /smack/load2)\n\t * because you should expect to be able to write\n\t * anything you read back.\n\t */\n\tif (strlen(srp->smk_subject->smk_known) >= max ||\n\t    strlen(srp->smk_object->smk_known) >= max)\n\t\treturn;\n\n\tif (srp->smk_access == 0)\n\t\treturn;\n\n\tseq_printf(s, \"%s %s\",\n\t\t   srp->smk_subject->smk_known,\n\t\t   srp->smk_object->smk_known);\n\n\tseq_putc(s, ' ');\n\n\tif (srp->smk_access & MAY_READ)\n\t\tseq_putc(s, 'r');\n\tif (srp->smk_access & MAY_WRITE)\n\t\tseq_putc(s, 'w');\n\tif (srp->smk_access & MAY_EXEC)\n\t\tseq_putc(s, 'x');\n\tif (srp->smk_access & MAY_APPEND)\n\t\tseq_putc(s, 'a');\n\tif (srp->smk_access & MAY_TRANSMUTE)\n\t\tseq_putc(s, 't');\n\tif (srp->smk_access & MAY_LOCK)\n\t\tseq_putc(s, 'l');\n\tif (srp->smk_access & MAY_BRINGUP)\n\t\tseq_putc(s, 'b');\n\n\tseq_putc(s, '\\n');\n}"
  },
  {
    "function_name": "smk_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "589-592",
    "snippet": "static void smk_seq_stop(struct seq_file *s, void *v)\n{\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_seq_stop(struct seq_file *s, void *v)\n{\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "smk_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "578-587",
    "snippet": "static void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "list_next_rcu(list)"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_rcu",
          "args": [
            "list"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_next(struct seq_file *s, void *v, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list = v;\n\n\t++*pos;\n\tlist = rcu_dereference(list_next_rcu(list));\n\n\treturn (list == head) ? NULL : list;\n}"
  },
  {
    "function_name": "smk_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "561-576",
    "snippet": "static void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "list_next_rcu(list)"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_rcu",
          "args": [
            "list"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "list_next_rcu(head)"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next_rcu",
          "args": [
            "head"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void *smk_seq_start(struct seq_file *s, loff_t *pos,\n\t\t\t\tstruct list_head *head)\n{\n\tstruct list_head *list;\n\tint i = *pos;\n\n\trcu_read_lock();\n\tfor (list = rcu_dereference(list_next_rcu(head));\n\t\tlist != head;\n\t\tlist = rcu_dereference(list_next_rcu(list))) {\n\t\tif (i-- == 0)\n\t\t\treturn list;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "smk_write_rules_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "473-555",
    "snippet": "static ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\t\tstruct list_head *rule_list,\n\t\t\t\t\tstruct mutex *rule_lock, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint rc;\n\tint trunc = 0;\n\tint tokens;\n\tssize_t cnt = 0;\n\n\t/*\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\t/*\n\t\t * Minor hack for backward compatibility\n\t\t */\n\t\tif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (count >= PAGE_SIZE) {\n\t\t\tcount = PAGE_SIZE - 1;\n\t\t\ttrunc = 1;\n\t\t}\n\t}\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * In case of parsing only part of user buf,\n\t * avoid having partial rule at the data buffer\n\t */\n\tif (trunc) {\n\t\twhile (count > 0 && (data[count - 1] != '\\n'))\n\t\t\t--count;\n\t\tif (count == 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdata[count] = '\\0';\n\ttokens = (format == SMK_CHANGE_FMT ? 4 : 3);\n\twhile (cnt < count) {\n\t\tif (format == SMK_FIXED24_FMT) {\n\t\t\trc = smk_parse_rule(data, &rule, 1);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tcnt = count;\n\t\t} else {\n\t\t\trc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tif (rc == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcnt += rc;\n\t\t}\n\n\t\tif (rule_list == NULL)\n\t\t\trc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\n\t\t\t\t&rule.smk_subject->smk_rules_lock, 1);\n\t\telse\n\t\t\trc = smk_set_access(&rule, rule_list, rule_lock, 0);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = cnt;\nout:\n\tkfree(data);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define SMK_CHANGE_FMT\t2\t/* Rule modification format */",
      "#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */",
      "#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)",
      "#define SMK_OLOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_set_access",
          "args": [
            "&rule",
            "rule_list",
            "rule_lock",
            "0"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "smk_set_access",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "224-282",
          "snippet": "static int smk_set_access(struct smack_parsed_rule *srp,\n\t\t\t\tstruct list_head *rule_list,\n\t\t\t\tstruct mutex *rule_lock, int global)\n{\n\tstruct smack_rule *sp;\n\tstruct smack_master_list *smlp;\n\tint found = 0;\n\tint rc = 0;\n\n\tmutex_lock(rule_lock);\n\n\t/*\n\t * Because the object label is less likely to match\n\t * than the subject label check it first\n\t */\n\tlist_for_each_entry_rcu(sp, rule_list, list) {\n\t\tif (sp->smk_object == srp->smk_object &&\n\t\t    sp->smk_subject == srp->smk_subject) {\n\t\t\tfound = 1;\n\t\t\tsp->smk_access |= srp->smk_access1;\n\t\t\tsp->smk_access &= ~srp->smk_access2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found == 0) {\n\t\tsp = kzalloc(sizeof(*sp), GFP_KERNEL);\n\t\tif (sp == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsp->smk_subject = srp->smk_subject;\n\t\tsp->smk_object = srp->smk_object;\n\t\tsp->smk_access = srp->smk_access1 & ~srp->smk_access2;\n\n\t\tlist_add_rcu(&sp->list, rule_list);\n\t\t/*\n\t\t * If this is a global as opposed to self and a new rule\n\t\t * it needs to get added for reporting.\n\t\t */\n\t\tif (global) {\n\t\t\tmutex_unlock(rule_lock);\n\t\t\tsmlp = kzalloc(sizeof(*smlp), GFP_KERNEL);\n\t\t\tif (smlp != NULL) {\n\t\t\t\tsmlp->smk_rule = sp;\n\t\t\t\tmutex_lock(&smack_master_list_lock);\n\t\t\t\tlist_add_rcu(&smlp->list, &smack_rule_list);\n\t\t\t\tmutex_unlock(&smack_master_list_lock);\n\t\t\t} else\n\t\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(rule_lock);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(smack_master_list_lock);",
            "static LIST_HEAD(smack_rule_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(smack_master_list_lock);\nstatic LIST_HEAD(smack_rule_list);\n\nstatic int smk_set_access(struct smack_parsed_rule *srp,\n\t\t\t\tstruct list_head *rule_list,\n\t\t\t\tstruct mutex *rule_lock, int global)\n{\n\tstruct smack_rule *sp;\n\tstruct smack_master_list *smlp;\n\tint found = 0;\n\tint rc = 0;\n\n\tmutex_lock(rule_lock);\n\n\t/*\n\t * Because the object label is less likely to match\n\t * than the subject label check it first\n\t */\n\tlist_for_each_entry_rcu(sp, rule_list, list) {\n\t\tif (sp->smk_object == srp->smk_object &&\n\t\t    sp->smk_subject == srp->smk_subject) {\n\t\t\tfound = 1;\n\t\t\tsp->smk_access |= srp->smk_access1;\n\t\t\tsp->smk_access &= ~srp->smk_access2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found == 0) {\n\t\tsp = kzalloc(sizeof(*sp), GFP_KERNEL);\n\t\tif (sp == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsp->smk_subject = srp->smk_subject;\n\t\tsp->smk_object = srp->smk_object;\n\t\tsp->smk_access = srp->smk_access1 & ~srp->smk_access2;\n\n\t\tlist_add_rcu(&sp->list, rule_list);\n\t\t/*\n\t\t * If this is a global as opposed to self and a new rule\n\t\t * it needs to get added for reporting.\n\t\t */\n\t\tif (global) {\n\t\t\tmutex_unlock(rule_lock);\n\t\t\tsmlp = kzalloc(sizeof(*smlp), GFP_KERNEL);\n\t\t\tif (smlp != NULL) {\n\t\t\t\tsmlp->smk_rule = sp;\n\t\t\t\tmutex_lock(&smack_master_list_lock);\n\t\t\t\tlist_add_rcu(&smlp->list, &smack_rule_list);\n\t\t\t\tmutex_unlock(&smack_master_list_lock);\n\t\t\t} else\n\t\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(rule_lock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_parse_long_rule",
          "args": [
            "data + cnt",
            "&rule",
            "1",
            "tokens"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "smk_parse_long_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "417-449",
          "snippet": "static ssize_t smk_parse_long_rule(char *data, struct smack_parsed_rule *rule,\n\t\t\t\tint import, int tokens)\n{\n\tssize_t cnt = 0;\n\tchar *tok[4];\n\tint rc;\n\tint i;\n\n\t/*\n\t * Parsing the rule in-place, filling all white-spaces with '\\0'\n\t */\n\tfor (i = 0; i < tokens; ++i) {\n\t\twhile (isspace(data[cnt]))\n\t\t\tdata[cnt++] = '\\0';\n\n\t\tif (data[cnt] == '\\0')\n\t\t\t/* Unexpected end of data */\n\t\t\treturn -EINVAL;\n\n\t\ttok[i] = data + cnt;\n\n\t\twhile (data[cnt] && !isspace(data[cnt]))\n\t\t\t++cnt;\n\t}\n\twhile (isspace(data[cnt]))\n\t\tdata[cnt++] = '\\0';\n\n\twhile (i < 4)\n\t\ttok[i++] = NULL;\n\n\trc = smk_fill_rule(tok[0], tok[1], tok[2], tok[3], rule, import, 0);\n\treturn rc == 0 ? cnt : rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic ssize_t smk_parse_long_rule(char *data, struct smack_parsed_rule *rule,\n\t\t\t\tint import, int tokens)\n{\n\tssize_t cnt = 0;\n\tchar *tok[4];\n\tint rc;\n\tint i;\n\n\t/*\n\t * Parsing the rule in-place, filling all white-spaces with '\\0'\n\t */\n\tfor (i = 0; i < tokens; ++i) {\n\t\twhile (isspace(data[cnt]))\n\t\t\tdata[cnt++] = '\\0';\n\n\t\tif (data[cnt] == '\\0')\n\t\t\t/* Unexpected end of data */\n\t\t\treturn -EINVAL;\n\n\t\ttok[i] = data + cnt;\n\n\t\twhile (data[cnt] && !isspace(data[cnt]))\n\t\t\t++cnt;\n\t}\n\twhile (isspace(data[cnt]))\n\t\tdata[cnt++] = '\\0';\n\n\twhile (i < 4)\n\t\ttok[i++] = NULL;\n\n\trc = smk_fill_rule(tok[0], tok[1], tok[2], tok[3], rule, import, 0);\n\treturn rc == 0 ? cnt : rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smk_parse_rule",
          "args": [
            "data",
            "&rule",
            "1"
          ],
          "line": 526
        },
        "resolved": true,
        "details": {
          "function_name": "smk_parse_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "397-406",
          "snippet": "static int smk_parse_rule(const char *data, struct smack_parsed_rule *rule,\n\t\t\t\tint import)\n{\n\tint rc;\n\n\trc = smk_fill_rule(data, data + SMK_LABELLEN,\n\t\t\t   data + SMK_LABELLEN + SMK_LABELLEN, NULL, rule,\n\t\t\t   import, SMK_LABELLEN);\n\treturn rc;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_parse_rule(const char *data, struct smack_parsed_rule *rule,\n\t\t\t\tint import)\n{\n\tint rc;\n\n\trc = smk_fill_rule(data, data + SMK_LABELLEN,\n\t\t\t   data + SMK_LABELLEN + SMK_LABELLEN, NULL, rule,\n\t\t\t   import, SMK_LABELLEN);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\n#define SMK_CHANGE_FMT\t2\t/* Rule modification format */\n#define SMK_FIXED24_FMT\t0\t/* Fixed 24byte label format */\n#define SMK_LOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_ACCESSLEN)\n#define SMK_OLOADLEN\t(SMK_LABELLEN + SMK_LABELLEN + SMK_OACCESSLEN)\n\nstatic ssize_t smk_write_rules_list(struct file *file, const char __user *buf,\n\t\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\t\tstruct list_head *rule_list,\n\t\t\t\t\tstruct mutex *rule_lock, int format)\n{\n\tstruct smack_parsed_rule rule;\n\tchar *data;\n\tint rc;\n\tint trunc = 0;\n\tint tokens;\n\tssize_t cnt = 0;\n\n\t/*\n\t * No partial writes.\n\t * Enough data must be present.\n\t */\n\tif (*ppos != 0)\n\t\treturn -EINVAL;\n\n\tif (format == SMK_FIXED24_FMT) {\n\t\t/*\n\t\t * Minor hack for backward compatibility\n\t\t */\n\t\tif (count < SMK_OLOADLEN || count > SMK_LOADLEN)\n\t\t\treturn -EINVAL;\n\t} else {\n\t\tif (count >= PAGE_SIZE) {\n\t\t\tcount = PAGE_SIZE - 1;\n\t\t\ttrunc = 1;\n\t\t}\n\t}\n\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\n\t/*\n\t * In case of parsing only part of user buf,\n\t * avoid having partial rule at the data buffer\n\t */\n\tif (trunc) {\n\t\twhile (count > 0 && (data[count - 1] != '\\n'))\n\t\t\t--count;\n\t\tif (count == 0) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tdata[count] = '\\0';\n\ttokens = (format == SMK_CHANGE_FMT ? 4 : 3);\n\twhile (cnt < count) {\n\t\tif (format == SMK_FIXED24_FMT) {\n\t\t\trc = smk_parse_rule(data, &rule, 1);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tcnt = count;\n\t\t} else {\n\t\t\trc = smk_parse_long_rule(data + cnt, &rule, 1, tokens);\n\t\t\tif (rc < 0)\n\t\t\t\tgoto out;\n\t\t\tif (rc == 0) {\n\t\t\t\trc = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcnt += rc;\n\t\t}\n\n\t\tif (rule_list == NULL)\n\t\t\trc = smk_set_access(&rule, &rule.smk_subject->smk_rules,\n\t\t\t\t&rule.smk_subject->smk_rules_lock, 1);\n\t\telse\n\t\t\trc = smk_set_access(&rule, rule_list, rule_lock, 0);\n\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\n\trc = cnt;\nout:\n\tkfree(data);\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_parse_long_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "417-449",
    "snippet": "static ssize_t smk_parse_long_rule(char *data, struct smack_parsed_rule *rule,\n\t\t\t\tint import, int tokens)\n{\n\tssize_t cnt = 0;\n\tchar *tok[4];\n\tint rc;\n\tint i;\n\n\t/*\n\t * Parsing the rule in-place, filling all white-spaces with '\\0'\n\t */\n\tfor (i = 0; i < tokens; ++i) {\n\t\twhile (isspace(data[cnt]))\n\t\t\tdata[cnt++] = '\\0';\n\n\t\tif (data[cnt] == '\\0')\n\t\t\t/* Unexpected end of data */\n\t\t\treturn -EINVAL;\n\n\t\ttok[i] = data + cnt;\n\n\t\twhile (data[cnt] && !isspace(data[cnt]))\n\t\t\t++cnt;\n\t}\n\twhile (isspace(data[cnt]))\n\t\tdata[cnt++] = '\\0';\n\n\twhile (i < 4)\n\t\ttok[i++] = NULL;\n\n\trc = smk_fill_rule(tok[0], tok[1], tok[2], tok[3], rule, import, 0);\n\treturn rc == 0 ? cnt : rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_fill_rule",
          "args": [
            "tok[0]",
            "tok[1]",
            "tok[2]",
            "tok[3]",
            "rule",
            "import",
            "0"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "smk_fill_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "344-387",
          "snippet": "static int smk_fill_rule(const char *subject, const char *object,\n\t\t\t\tconst char *access1, const char *access2,\n\t\t\t\tstruct smack_parsed_rule *rule, int import,\n\t\t\t\tint len)\n{\n\tconst char *cp;\n\tstruct smack_known *skp;\n\n\tif (import) {\n\t\trule->smk_subject = smk_import_entry(subject, len);\n\t\tif (IS_ERR(rule->smk_subject))\n\t\t\treturn PTR_ERR(rule->smk_subject);\n\n\t\trule->smk_object = smk_import_entry(object, len);\n\t\tif (IS_ERR(rule->smk_object))\n\t\t\treturn PTR_ERR(rule->smk_object);\n\t} else {\n\t\tcp = smk_parse_smack(subject, len);\n\t\tif (IS_ERR(cp))\n\t\t\treturn PTR_ERR(cp);\n\t\tskp = smk_find_entry(cp);\n\t\tkfree(cp);\n\t\tif (skp == NULL)\n\t\t\treturn -ENOENT;\n\t\trule->smk_subject = skp;\n\n\t\tcp = smk_parse_smack(object, len);\n\t\tif (IS_ERR(cp))\n\t\t\treturn PTR_ERR(cp);\n\t\tskp = smk_find_entry(cp);\n\t\tkfree(cp);\n\t\tif (skp == NULL)\n\t\t\treturn -ENOENT;\n\t\trule->smk_object = skp;\n\t}\n\n\trule->smk_access1 = smk_perm_from_str(access1);\n\tif (access2)\n\t\trule->smk_access2 = smk_perm_from_str(access2);\n\telse\n\t\trule->smk_access2 = ~rule->smk_access1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_fill_rule(const char *subject, const char *object,\n\t\t\t\tconst char *access1, const char *access2,\n\t\t\t\tstruct smack_parsed_rule *rule, int import,\n\t\t\t\tint len)\n{\n\tconst char *cp;\n\tstruct smack_known *skp;\n\n\tif (import) {\n\t\trule->smk_subject = smk_import_entry(subject, len);\n\t\tif (IS_ERR(rule->smk_subject))\n\t\t\treturn PTR_ERR(rule->smk_subject);\n\n\t\trule->smk_object = smk_import_entry(object, len);\n\t\tif (IS_ERR(rule->smk_object))\n\t\t\treturn PTR_ERR(rule->smk_object);\n\t} else {\n\t\tcp = smk_parse_smack(subject, len);\n\t\tif (IS_ERR(cp))\n\t\t\treturn PTR_ERR(cp);\n\t\tskp = smk_find_entry(cp);\n\t\tkfree(cp);\n\t\tif (skp == NULL)\n\t\t\treturn -ENOENT;\n\t\trule->smk_subject = skp;\n\n\t\tcp = smk_parse_smack(object, len);\n\t\tif (IS_ERR(cp))\n\t\t\treturn PTR_ERR(cp);\n\t\tskp = smk_find_entry(cp);\n\t\tkfree(cp);\n\t\tif (skp == NULL)\n\t\t\treturn -ENOENT;\n\t\trule->smk_object = skp;\n\t}\n\n\trule->smk_access1 = smk_perm_from_str(access1);\n\tif (access2)\n\t\trule->smk_access2 = smk_perm_from_str(access2);\n\telse\n\t\trule->smk_access2 = ~rule->smk_access1;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "data[cnt]"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "data[cnt]"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "data[cnt]"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic ssize_t smk_parse_long_rule(char *data, struct smack_parsed_rule *rule,\n\t\t\t\tint import, int tokens)\n{\n\tssize_t cnt = 0;\n\tchar *tok[4];\n\tint rc;\n\tint i;\n\n\t/*\n\t * Parsing the rule in-place, filling all white-spaces with '\\0'\n\t */\n\tfor (i = 0; i < tokens; ++i) {\n\t\twhile (isspace(data[cnt]))\n\t\t\tdata[cnt++] = '\\0';\n\n\t\tif (data[cnt] == '\\0')\n\t\t\t/* Unexpected end of data */\n\t\t\treturn -EINVAL;\n\n\t\ttok[i] = data + cnt;\n\n\t\twhile (data[cnt] && !isspace(data[cnt]))\n\t\t\t++cnt;\n\t}\n\twhile (isspace(data[cnt]))\n\t\tdata[cnt++] = '\\0';\n\n\twhile (i < 4)\n\t\ttok[i++] = NULL;\n\n\trc = smk_fill_rule(tok[0], tok[1], tok[2], tok[3], rule, import, 0);\n\treturn rc == 0 ? cnt : rc;\n}"
  },
  {
    "function_name": "smk_parse_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "397-406",
    "snippet": "static int smk_parse_rule(const char *data, struct smack_parsed_rule *rule,\n\t\t\t\tint import)\n{\n\tint rc;\n\n\trc = smk_fill_rule(data, data + SMK_LABELLEN,\n\t\t\t   data + SMK_LABELLEN + SMK_LABELLEN, NULL, rule,\n\t\t\t   import, SMK_LABELLEN);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_fill_rule",
          "args": [
            "data",
            "data + SMK_LABELLEN",
            "data + SMK_LABELLEN + SMK_LABELLEN",
            "NULL",
            "rule",
            "import",
            "SMK_LABELLEN"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "smk_fill_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "344-387",
          "snippet": "static int smk_fill_rule(const char *subject, const char *object,\n\t\t\t\tconst char *access1, const char *access2,\n\t\t\t\tstruct smack_parsed_rule *rule, int import,\n\t\t\t\tint len)\n{\n\tconst char *cp;\n\tstruct smack_known *skp;\n\n\tif (import) {\n\t\trule->smk_subject = smk_import_entry(subject, len);\n\t\tif (IS_ERR(rule->smk_subject))\n\t\t\treturn PTR_ERR(rule->smk_subject);\n\n\t\trule->smk_object = smk_import_entry(object, len);\n\t\tif (IS_ERR(rule->smk_object))\n\t\t\treturn PTR_ERR(rule->smk_object);\n\t} else {\n\t\tcp = smk_parse_smack(subject, len);\n\t\tif (IS_ERR(cp))\n\t\t\treturn PTR_ERR(cp);\n\t\tskp = smk_find_entry(cp);\n\t\tkfree(cp);\n\t\tif (skp == NULL)\n\t\t\treturn -ENOENT;\n\t\trule->smk_subject = skp;\n\n\t\tcp = smk_parse_smack(object, len);\n\t\tif (IS_ERR(cp))\n\t\t\treturn PTR_ERR(cp);\n\t\tskp = smk_find_entry(cp);\n\t\tkfree(cp);\n\t\tif (skp == NULL)\n\t\t\treturn -ENOENT;\n\t\trule->smk_object = skp;\n\t}\n\n\trule->smk_access1 = smk_perm_from_str(access1);\n\tif (access2)\n\t\trule->smk_access2 = smk_perm_from_str(access2);\n\telse\n\t\trule->smk_access2 = ~rule->smk_access1;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_fill_rule(const char *subject, const char *object,\n\t\t\t\tconst char *access1, const char *access2,\n\t\t\t\tstruct smack_parsed_rule *rule, int import,\n\t\t\t\tint len)\n{\n\tconst char *cp;\n\tstruct smack_known *skp;\n\n\tif (import) {\n\t\trule->smk_subject = smk_import_entry(subject, len);\n\t\tif (IS_ERR(rule->smk_subject))\n\t\t\treturn PTR_ERR(rule->smk_subject);\n\n\t\trule->smk_object = smk_import_entry(object, len);\n\t\tif (IS_ERR(rule->smk_object))\n\t\t\treturn PTR_ERR(rule->smk_object);\n\t} else {\n\t\tcp = smk_parse_smack(subject, len);\n\t\tif (IS_ERR(cp))\n\t\t\treturn PTR_ERR(cp);\n\t\tskp = smk_find_entry(cp);\n\t\tkfree(cp);\n\t\tif (skp == NULL)\n\t\t\treturn -ENOENT;\n\t\trule->smk_subject = skp;\n\n\t\tcp = smk_parse_smack(object, len);\n\t\tif (IS_ERR(cp))\n\t\t\treturn PTR_ERR(cp);\n\t\tskp = smk_find_entry(cp);\n\t\tkfree(cp);\n\t\tif (skp == NULL)\n\t\t\treturn -ENOENT;\n\t\trule->smk_object = skp;\n\t}\n\n\trule->smk_access1 = smk_perm_from_str(access1);\n\tif (access2)\n\t\trule->smk_access2 = smk_perm_from_str(access2);\n\telse\n\t\trule->smk_access2 = ~rule->smk_access1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_parse_rule(const char *data, struct smack_parsed_rule *rule,\n\t\t\t\tint import)\n{\n\tint rc;\n\n\trc = smk_fill_rule(data, data + SMK_LABELLEN,\n\t\t\t   data + SMK_LABELLEN + SMK_LABELLEN, NULL, rule,\n\t\t\t   import, SMK_LABELLEN);\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_fill_rule",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "344-387",
    "snippet": "static int smk_fill_rule(const char *subject, const char *object,\n\t\t\t\tconst char *access1, const char *access2,\n\t\t\t\tstruct smack_parsed_rule *rule, int import,\n\t\t\t\tint len)\n{\n\tconst char *cp;\n\tstruct smack_known *skp;\n\n\tif (import) {\n\t\trule->smk_subject = smk_import_entry(subject, len);\n\t\tif (IS_ERR(rule->smk_subject))\n\t\t\treturn PTR_ERR(rule->smk_subject);\n\n\t\trule->smk_object = smk_import_entry(object, len);\n\t\tif (IS_ERR(rule->smk_object))\n\t\t\treturn PTR_ERR(rule->smk_object);\n\t} else {\n\t\tcp = smk_parse_smack(subject, len);\n\t\tif (IS_ERR(cp))\n\t\t\treturn PTR_ERR(cp);\n\t\tskp = smk_find_entry(cp);\n\t\tkfree(cp);\n\t\tif (skp == NULL)\n\t\t\treturn -ENOENT;\n\t\trule->smk_subject = skp;\n\n\t\tcp = smk_parse_smack(object, len);\n\t\tif (IS_ERR(cp))\n\t\t\treturn PTR_ERR(cp);\n\t\tskp = smk_find_entry(cp);\n\t\tkfree(cp);\n\t\tif (skp == NULL)\n\t\t\treturn -ENOENT;\n\t\trule->smk_object = skp;\n\t}\n\n\trule->smk_access1 = smk_perm_from_str(access1);\n\tif (access2)\n\t\trule->smk_access2 = smk_perm_from_str(access2);\n\telse\n\t\trule->smk_access2 = ~rule->smk_access1;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smk_perm_from_str",
          "args": [
            "access2"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "smk_perm_from_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
          "lines": "290-330",
          "snippet": "static int smk_perm_from_str(const char *string)\n{\n\tint perm = 0;\n\tconst char *cp;\n\n\tfor (cp = string; ; cp++)\n\t\tswitch (*cp) {\n\t\tcase '-':\n\t\t\tbreak;\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t\tperm |= MAY_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tperm |= MAY_WRITE;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tperm |= MAY_EXEC;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'A':\n\t\t\tperm |= MAY_APPEND;\n\t\t\tbreak;\n\t\tcase 't':\n\t\tcase 'T':\n\t\t\tperm |= MAY_TRANSMUTE;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\tcase 'L':\n\t\t\tperm |= MAY_LOCK;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\tcase 'B':\n\t\t\tperm |= MAY_BRINGUP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn perm;\n\t\t}\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <linux/ctype.h>",
            "#include <linux/seq_file.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_perm_from_str(const char *string)\n{\n\tint perm = 0;\n\tconst char *cp;\n\n\tfor (cp = string; ; cp++)\n\t\tswitch (*cp) {\n\t\tcase '-':\n\t\t\tbreak;\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t\tperm |= MAY_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tperm |= MAY_WRITE;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tperm |= MAY_EXEC;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'A':\n\t\t\tperm |= MAY_APPEND;\n\t\t\tbreak;\n\t\tcase 't':\n\t\tcase 'T':\n\t\t\tperm |= MAY_TRANSMUTE;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\tcase 'L':\n\t\t\tperm |= MAY_LOCK;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\tcase 'B':\n\t\t\tperm |= MAY_BRINGUP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn perm;\n\t\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cp"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_find_entry",
          "args": [
            "cp"
          ],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "smk_find_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "425-439",
          "snippet": "struct smack_known *smk_find_entry(const char *string)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\tstruct smack_known *skp;\n\n\thash = full_name_hash(NULL, string, strlen(string));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_for_each_entry_rcu(skp, head, smk_hashed)\n\t\tif (strcmp(skp->smk_known, string) == 0)\n\t\t\treturn skp;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct hlist_head smack_known_hash[SMACK_HASH_SLOTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstruct hlist_head smack_known_hash[SMACK_HASH_SLOTS];\n\nstruct smack_known *smk_find_entry(const char *string)\n{\n\tunsigned int hash;\n\tstruct hlist_head *head;\n\tstruct smack_known *skp;\n\n\thash = full_name_hash(NULL, string, strlen(string));\n\thead = &smack_known_hash[hash & (SMACK_HASH_SLOTS - 1)];\n\n\thlist_for_each_entry_rcu(skp, head, smk_hashed)\n\t\tif (strcmp(skp->smk_known, string) == 0)\n\t\t\treturn skp;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cp"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cp"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_parse_smack",
          "args": [
            "object",
            "len"
          ],
          "line": 370
        },
        "resolved": true,
        "details": {
          "function_name": "smk_parse_smack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "448-479",
          "snippet": "char *smk_parse_smack(const char *string, int len)\n{\n\tchar *smack;\n\tint i;\n\n\tif (len <= 0)\n\t\tlen = strlen(string) + 1;\n\n\t/*\n\t * Reserve a leading '-' as an indicator that\n\t * this isn't a label, but an option to interfaces\n\t * including /smack/cipso and /smack/cipso2\n\t */\n\tif (string[0] == '-')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (string[i] > '~' || string[i] <= ' ' || string[i] == '/' ||\n\t\t    string[i] == '\"' || string[i] == '\\\\' || string[i] == '\\'')\n\t\t\tbreak;\n\n\tif (i == 0 || i >= SMK_LONGLABEL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsmack = kzalloc(i + 1, GFP_KERNEL);\n\tif (smack == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(smack, string, i);\n\n\treturn smack;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nchar *smk_parse_smack(const char *string, int len)\n{\n\tchar *smack;\n\tint i;\n\n\tif (len <= 0)\n\t\tlen = strlen(string) + 1;\n\n\t/*\n\t * Reserve a leading '-' as an indicator that\n\t * this isn't a label, but an option to interfaces\n\t * including /smack/cipso and /smack/cipso2\n\t */\n\tif (string[0] == '-')\n\t\treturn ERR_PTR(-EINVAL);\n\n\tfor (i = 0; i < len; i++)\n\t\tif (string[i] > '~' || string[i] <= ' ' || string[i] == '/' ||\n\t\t    string[i] == '\"' || string[i] == '\\\\' || string[i] == '\\'')\n\t\t\tbreak;\n\n\tif (i == 0 || i >= SMK_LONGLABEL)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tsmack = kzalloc(i + 1, GFP_KERNEL);\n\tif (smack == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrncpy(smack, string, i);\n\n\treturn smack;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cp"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "cp"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "cp"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rule->smk_object"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rule->smk_object"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_import_entry",
          "args": [
            "object",
            "len"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "smk_import_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_access.c",
          "lines": "526-587",
          "snippet": "struct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 smack_next_secid = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n\nstatic u32 smack_next_secid = 10;\n\nstruct smack_known *smk_import_entry(const char *string, int len)\n{\n\tstruct smack_known *skp;\n\tchar *smack;\n\tint slen;\n\tint rc;\n\n\tsmack = smk_parse_smack(string, len);\n\tif (IS_ERR(smack))\n\t\treturn ERR_CAST(smack);\n\n\tmutex_lock(&smack_known_lock);\n\n\tskp = smk_find_entry(smack);\n\tif (skp != NULL)\n\t\tgoto freeout;\n\n\tskp = kzalloc(sizeof(*skp), GFP_KERNEL);\n\tif (skp == NULL) {\n\t\tskp = ERR_PTR(-ENOMEM);\n\t\tgoto freeout;\n\t}\n\n\tskp->smk_known = smack;\n\tskp->smk_secid = smack_next_secid++;\n\tskp->smk_netlabel.domain = skp->smk_known;\n\tskp->smk_netlabel.flags =\n\t\tNETLBL_SECATTR_DOMAIN | NETLBL_SECATTR_MLS_LVL;\n\t/*\n\t * If direct labeling works use it.\n\t * Otherwise use mapped labeling.\n\t */\n\tslen = strlen(smack);\n\tif (slen < SMK_CIPSOLEN)\n\t\trc = smk_netlbl_mls(smack_cipso_direct, skp->smk_known,\n\t\t\t       &skp->smk_netlabel, slen);\n\telse\n\t\trc = smk_netlbl_mls(smack_cipso_mapped, (char *)&skp->smk_secid,\n\t\t\t       &skp->smk_netlabel, sizeof(skp->smk_secid));\n\n\tif (rc >= 0) {\n\t\tINIT_LIST_HEAD(&skp->smk_rules);\n\t\tmutex_init(&skp->smk_rules_lock);\n\t\t/*\n\t\t * Make sure that the entry is actually\n\t\t * filled before putting it on the list.\n\t\t */\n\t\tsmk_insert_entry(skp);\n\t\tgoto unlockout;\n\t}\n\t/*\n\t * smk_netlbl_mls failed.\n\t */\n\tkfree(skp);\n\tskp = ERR_PTR(rc);\nfreeout:\n\tkfree(smack);\nunlockout:\n\tmutex_unlock(&smack_known_lock);\n\n\treturn skp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "rule->smk_subject"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "rule->smk_subject"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_fill_rule(const char *subject, const char *object,\n\t\t\t\tconst char *access1, const char *access2,\n\t\t\t\tstruct smack_parsed_rule *rule, int import,\n\t\t\t\tint len)\n{\n\tconst char *cp;\n\tstruct smack_known *skp;\n\n\tif (import) {\n\t\trule->smk_subject = smk_import_entry(subject, len);\n\t\tif (IS_ERR(rule->smk_subject))\n\t\t\treturn PTR_ERR(rule->smk_subject);\n\n\t\trule->smk_object = smk_import_entry(object, len);\n\t\tif (IS_ERR(rule->smk_object))\n\t\t\treturn PTR_ERR(rule->smk_object);\n\t} else {\n\t\tcp = smk_parse_smack(subject, len);\n\t\tif (IS_ERR(cp))\n\t\t\treturn PTR_ERR(cp);\n\t\tskp = smk_find_entry(cp);\n\t\tkfree(cp);\n\t\tif (skp == NULL)\n\t\t\treturn -ENOENT;\n\t\trule->smk_subject = skp;\n\n\t\tcp = smk_parse_smack(object, len);\n\t\tif (IS_ERR(cp))\n\t\t\treturn PTR_ERR(cp);\n\t\tskp = smk_find_entry(cp);\n\t\tkfree(cp);\n\t\tif (skp == NULL)\n\t\t\treturn -ENOENT;\n\t\trule->smk_object = skp;\n\t}\n\n\trule->smk_access1 = smk_perm_from_str(access1);\n\tif (access2)\n\t\trule->smk_access2 = smk_perm_from_str(access2);\n\telse\n\t\trule->smk_access2 = ~rule->smk_access1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "smk_perm_from_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "290-330",
    "snippet": "static int smk_perm_from_str(const char *string)\n{\n\tint perm = 0;\n\tconst char *cp;\n\n\tfor (cp = string; ; cp++)\n\t\tswitch (*cp) {\n\t\tcase '-':\n\t\t\tbreak;\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t\tperm |= MAY_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tperm |= MAY_WRITE;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tperm |= MAY_EXEC;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'A':\n\t\t\tperm |= MAY_APPEND;\n\t\t\tbreak;\n\t\tcase 't':\n\t\tcase 'T':\n\t\t\tperm |= MAY_TRANSMUTE;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\tcase 'L':\n\t\t\tperm |= MAY_LOCK;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\tcase 'B':\n\t\t\tperm |= MAY_BRINGUP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn perm;\n\t\t}\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic int smk_perm_from_str(const char *string)\n{\n\tint perm = 0;\n\tconst char *cp;\n\n\tfor (cp = string; ; cp++)\n\t\tswitch (*cp) {\n\t\tcase '-':\n\t\t\tbreak;\n\t\tcase 'r':\n\t\tcase 'R':\n\t\t\tperm |= MAY_READ;\n\t\t\tbreak;\n\t\tcase 'w':\n\t\tcase 'W':\n\t\t\tperm |= MAY_WRITE;\n\t\t\tbreak;\n\t\tcase 'x':\n\t\tcase 'X':\n\t\t\tperm |= MAY_EXEC;\n\t\t\tbreak;\n\t\tcase 'a':\n\t\tcase 'A':\n\t\t\tperm |= MAY_APPEND;\n\t\t\tbreak;\n\t\tcase 't':\n\t\tcase 'T':\n\t\t\tperm |= MAY_TRANSMUTE;\n\t\t\tbreak;\n\t\tcase 'l':\n\t\tcase 'L':\n\t\t\tperm |= MAY_LOCK;\n\t\t\tbreak;\n\t\tcase 'b':\n\t\tcase 'B':\n\t\t\tperm |= MAY_BRINGUP;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn perm;\n\t\t}\n}"
  },
  {
    "function_name": "smk_set_access",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "224-282",
    "snippet": "static int smk_set_access(struct smack_parsed_rule *srp,\n\t\t\t\tstruct list_head *rule_list,\n\t\t\t\tstruct mutex *rule_lock, int global)\n{\n\tstruct smack_rule *sp;\n\tstruct smack_master_list *smlp;\n\tint found = 0;\n\tint rc = 0;\n\n\tmutex_lock(rule_lock);\n\n\t/*\n\t * Because the object label is less likely to match\n\t * than the subject label check it first\n\t */\n\tlist_for_each_entry_rcu(sp, rule_list, list) {\n\t\tif (sp->smk_object == srp->smk_object &&\n\t\t    sp->smk_subject == srp->smk_subject) {\n\t\t\tfound = 1;\n\t\t\tsp->smk_access |= srp->smk_access1;\n\t\t\tsp->smk_access &= ~srp->smk_access2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found == 0) {\n\t\tsp = kzalloc(sizeof(*sp), GFP_KERNEL);\n\t\tif (sp == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsp->smk_subject = srp->smk_subject;\n\t\tsp->smk_object = srp->smk_object;\n\t\tsp->smk_access = srp->smk_access1 & ~srp->smk_access2;\n\n\t\tlist_add_rcu(&sp->list, rule_list);\n\t\t/*\n\t\t * If this is a global as opposed to self and a new rule\n\t\t * it needs to get added for reporting.\n\t\t */\n\t\tif (global) {\n\t\t\tmutex_unlock(rule_lock);\n\t\t\tsmlp = kzalloc(sizeof(*smlp), GFP_KERNEL);\n\t\t\tif (smlp != NULL) {\n\t\t\t\tsmlp->smk_rule = sp;\n\t\t\t\tmutex_lock(&smack_master_list_lock);\n\t\t\t\tlist_add_rcu(&smlp->list, &smack_rule_list);\n\t\t\t\tmutex_unlock(&smack_master_list_lock);\n\t\t\t} else\n\t\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(rule_lock);\n\treturn rc;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(smack_master_list_lock);",
      "static LIST_HEAD(smack_rule_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "rule_lock"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&smack_master_list_lock"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&smlp->list",
            "&smack_rule_list"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&smack_master_list_lock"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*smlp)",
            "GFP_KERNEL"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "rule_lock"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&sp->list",
            "rule_list"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sp)",
            "GFP_KERNEL"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "sp",
            "rule_list",
            "list"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "rule_lock"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(smack_master_list_lock);\nstatic LIST_HEAD(smack_rule_list);\n\nstatic int smk_set_access(struct smack_parsed_rule *srp,\n\t\t\t\tstruct list_head *rule_list,\n\t\t\t\tstruct mutex *rule_lock, int global)\n{\n\tstruct smack_rule *sp;\n\tstruct smack_master_list *smlp;\n\tint found = 0;\n\tint rc = 0;\n\n\tmutex_lock(rule_lock);\n\n\t/*\n\t * Because the object label is less likely to match\n\t * than the subject label check it first\n\t */\n\tlist_for_each_entry_rcu(sp, rule_list, list) {\n\t\tif (sp->smk_object == srp->smk_object &&\n\t\t    sp->smk_subject == srp->smk_subject) {\n\t\t\tfound = 1;\n\t\t\tsp->smk_access |= srp->smk_access1;\n\t\t\tsp->smk_access &= ~srp->smk_access2;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (found == 0) {\n\t\tsp = kzalloc(sizeof(*sp), GFP_KERNEL);\n\t\tif (sp == NULL) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsp->smk_subject = srp->smk_subject;\n\t\tsp->smk_object = srp->smk_object;\n\t\tsp->smk_access = srp->smk_access1 & ~srp->smk_access2;\n\n\t\tlist_add_rcu(&sp->list, rule_list);\n\t\t/*\n\t\t * If this is a global as opposed to self and a new rule\n\t\t * it needs to get added for reporting.\n\t\t */\n\t\tif (global) {\n\t\t\tmutex_unlock(rule_lock);\n\t\t\tsmlp = kzalloc(sizeof(*smlp), GFP_KERNEL);\n\t\t\tif (smlp != NULL) {\n\t\t\t\tsmlp->smk_rule = sp;\n\t\t\t\tmutex_lock(&smack_master_list_lock);\n\t\t\t\tlist_add_rcu(&smlp->list, &smack_rule_list);\n\t\t\t\tmutex_unlock(&smack_master_list_lock);\n\t\t\t} else\n\t\t\t\trc = -ENOMEM;\n\t\t\treturn rc;\n\t\t}\n\t}\n\nout:\n\tmutex_unlock(rule_lock);\n\treturn rc;\n}"
  },
  {
    "function_name": "smk_netlabel_audit_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "194-201",
    "snippet": "static void smk_netlabel_audit_set(struct netlbl_audit *nap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tnap->loginuid = audit_get_loginuid(current);\n\tnap->sessionid = audit_get_sessionid(current);\n\tnap->secid = skp->smk_secid;\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smk_of_current",
          "args": [],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "smk_of_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack.h",
          "lines": "405-408",
          "snippet": "static inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}",
          "includes": [
            "#include <linux/lsm_audit.h>",
            "#include <linux/rculist.h>",
            "#include <linux/list.h>",
            "#include <net/netlabel.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lsm_audit.h>\n#include <linux/rculist.h>\n#include <linux/list.h>\n#include <net/netlabel.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/lsm_hooks.h>\n#include <linux/spinlock.h>\n#include <linux/capability.h>\n\nstatic inline struct smack_known *smk_of_current(void)\n{\n\treturn smk_of_task(current_security());\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic void smk_netlabel_audit_set(struct netlbl_audit *nap)\n{\n\tstruct smack_known *skp = smk_of_current();\n\n\tnap->loginuid = audit_get_loginuid(current);\n\tnap->sessionid = audit_get_sessionid(current);\n\tnap->secid = skp->smk_secid;\n}"
  },
  {
    "function_name": "smack_catset_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smackfs.c",
    "lines": "182-188",
    "snippet": "static inline void smack_catset_bit(unsigned int cat, char *catsetp)\n{\n\tif (cat == 0 || cat > (SMK_CIPSOLEN * 8))\n\t\treturn;\n\n\tcatsetp[(cat - 1) / 8] |= 0x80 >> ((cat - 1) % 8);\n}",
    "includes": [
      "#include \"smack.h\"",
      "#include <linux/magic.h>",
      "#include <linux/audit.h>",
      "#include <linux/ctype.h>",
      "#include <linux/seq_file.h>",
      "#include <net/cipso_ipv4.h>",
      "#include <net/net_namespace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"smack.h\"\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <linux/ctype.h>\n#include <linux/seq_file.h>\n#include <net/cipso_ipv4.h>\n#include <net/net_namespace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/kernel.h>\n\nstatic inline void smack_catset_bit(unsigned int cat, char *catsetp)\n{\n\tif (cat == 0 || cat > (SMK_CIPSOLEN * 8))\n\t\treturn;\n\n\tcatsetp[(cat - 1) / 8] |= 0x80 >> ((cat - 1) % 8);\n}"
  }
]