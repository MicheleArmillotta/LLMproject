[
  {
    "function_name": "keyctl_restrict_keyring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "1597-1636",
    "snippet": "long keyctl_restrict_keyring(key_serial_t id, const char __user *_type,\n\t\t\t     const char __user *_restriction)\n{\n\tkey_ref_t key_ref;\n\tbool link_reject = !_type;\n\tchar type[32];\n\tchar *restriction = NULL;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref))\n\t\treturn PTR_ERR(key_ref);\n\n\tif (_type) {\n\t\tret = key_get_type_from_user(type, _type, sizeof(type));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (_restriction) {\n\t\tif (!_type) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestriction = strndup_user(_restriction, PAGE_SIZE);\n\t\tif (IS_ERR(restriction)) {\n\t\t\tret = PTR_ERR(restriction);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = keyring_restrict(key_ref, link_reject ? NULL : type, restriction);\n\tkfree(restriction);\n\nerror:\n\tkey_ref_put(key_ref);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "key_ref"
          ],
          "line": 1633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "restriction"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_restrict",
          "args": [
            "key_ref",
            "link_reject ? NULL : type",
            "restriction"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_restrict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "991-1049",
          "snippet": "int keyring_restrict(key_ref_t keyring_ref, const char *type,\n\t\t     const char *restriction)\n{\n\tstruct key *keyring;\n\tstruct key_type *restrict_type = NULL;\n\tstruct key_restriction *restrict_link;\n\tint ret = 0;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tif (!type) {\n\t\trestrict_link = keyring_restriction_alloc(restrict_link_reject);\n\t} else {\n\t\trestrict_type = key_type_lookup(type);\n\n\t\tif (IS_ERR(restrict_type))\n\t\t\treturn PTR_ERR(restrict_type);\n\n\t\tif (!restrict_type->lookup_restriction) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestrict_link = restrict_type->lookup_restriction(restriction);\n\t}\n\n\tif (IS_ERR(restrict_link)) {\n\t\tret = PTR_ERR(restrict_link);\n\t\tgoto error;\n\t}\n\n\tdown_write(&keyring->sem);\n\tdown_write(&keyring_serialise_restrict_sem);\n\n\tif (keyring->restrict_link)\n\t\tret = -EEXIST;\n\telse if (keyring_detect_restriction_cycle(keyring, restrict_link))\n\t\tret = -EDEADLK;\n\telse\n\t\tkeyring->restrict_link = restrict_link;\n\n\tup_write(&keyring_serialise_restrict_sem);\n\tup_write(&keyring->sem);\n\n\tif (ret < 0) {\n\t\tkey_put(restrict_link->key);\n\t\tkfree(restrict_link);\n\t}\n\nerror:\n\tif (restrict_type)\n\t\tkey_type_put(restrict_type);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};",
            "static DECLARE_RWSEM(keyring_serialise_restrict_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nstatic DECLARE_RWSEM(keyring_serialise_restrict_sem);\n\nint keyring_restrict(key_ref_t keyring_ref, const char *type,\n\t\t     const char *restriction)\n{\n\tstruct key *keyring;\n\tstruct key_type *restrict_type = NULL;\n\tstruct key_restriction *restrict_link;\n\tint ret = 0;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tif (!type) {\n\t\trestrict_link = keyring_restriction_alloc(restrict_link_reject);\n\t} else {\n\t\trestrict_type = key_type_lookup(type);\n\n\t\tif (IS_ERR(restrict_type))\n\t\t\treturn PTR_ERR(restrict_type);\n\n\t\tif (!restrict_type->lookup_restriction) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestrict_link = restrict_type->lookup_restriction(restriction);\n\t}\n\n\tif (IS_ERR(restrict_link)) {\n\t\tret = PTR_ERR(restrict_link);\n\t\tgoto error;\n\t}\n\n\tdown_write(&keyring->sem);\n\tdown_write(&keyring_serialise_restrict_sem);\n\n\tif (keyring->restrict_link)\n\t\tret = -EEXIST;\n\telse if (keyring_detect_restriction_cycle(keyring, restrict_link))\n\t\tret = -EDEADLK;\n\telse\n\t\tkeyring->restrict_link = restrict_link;\n\n\tup_write(&keyring_serialise_restrict_sem);\n\tup_write(&keyring->sem);\n\n\tif (ret < 0) {\n\t\tkey_put(restrict_link->key);\n\t\tkfree(restrict_link);\n\t}\n\nerror:\n\tif (restrict_type)\n\t\tkey_type_put(restrict_type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "restriction"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "restriction"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strndup_user",
          "args": [
            "_restriction",
            "PAGE_SIZE"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get_type_from_user",
          "args": [
            "type",
            "_type",
            "sizeof(type)"
          ],
          "line": 1611
        },
        "resolved": true,
        "details": {
          "function_name": "key_get_type_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
          "lines": "33-48",
          "snippet": "static int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 1608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "id",
            "0",
            "KEY_NEED_SETATTR"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_restrict_keyring(key_serial_t id, const char __user *_type,\n\t\t\t     const char __user *_restriction)\n{\n\tkey_ref_t key_ref;\n\tbool link_reject = !_type;\n\tchar type[32];\n\tchar *restriction = NULL;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref))\n\t\treturn PTR_ERR(key_ref);\n\n\tif (_type) {\n\t\tret = key_get_type_from_user(type, _type, sizeof(type));\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (_restriction) {\n\t\tif (!_type) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestriction = strndup_user(_restriction, PAGE_SIZE);\n\t\tif (IS_ERR(restriction)) {\n\t\t\tret = PTR_ERR(restriction);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tret = keyring_restrict(key_ref, link_reject ? NULL : type, restriction);\n\tkfree(restriction);\n\nerror:\n\tkey_ref_put(key_ref);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_session_to_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "1494-1583",
    "snippet": "long keyctl_session_to_parent(void)\n{\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct callback_head *newwork, *oldwork;\n\tkey_ref_t keyring_r;\n\tstruct cred *cred;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_NEED_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\tret = -ENOMEM;\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tnewwork = &cred->rcu;\n\n\tcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tinit_task_work(newwork, key_change_session_keyring);\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tret = -EPERM;\n\toldwork = NULL;\n\tparent = me->real_parent;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto unlock;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto unlock;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->session_keyring == pcred->session_keyring) {\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (!uid_eq(pcred->uid,\t mycred->euid) ||\n\t    !uid_eq(pcred->euid, mycred->euid) ||\n\t    !uid_eq(pcred->suid, mycred->euid) ||\n\t    !gid_eq(pcred->gid,\t mycred->egid) ||\n\t    !gid_eq(pcred->egid, mycred->egid) ||\n\t    !gid_eq(pcred->sgid, mycred->egid))\n\t\tgoto unlock;\n\n\t/* the keyrings must have the same UID */\n\tif ((pcred->session_keyring &&\n\t     !uid_eq(pcred->session_keyring->uid, mycred->euid)) ||\n\t    !uid_eq(mycred->session_keyring->uid, mycred->euid))\n\t\tgoto unlock;\n\n\t/* cancel an already pending keyring replacement */\n\toldwork = task_work_cancel(parent, key_change_session_keyring);\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tret = task_work_add(parent, newwork, true);\n\tif (!ret)\n\t\tnewwork = NULL;\nunlock:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldwork)\n\t\tput_cred(container_of(oldwork, struct cred, rcu));\n\tif (newwork)\n\t\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "keyring_r"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "cred"
          ],
          "line": 1577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "container_of(oldwork, struct cred, rcu)"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "oldwork",
            "structcred",
            "rcu"
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_unlock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_work_add",
          "args": [
            "parent",
            "newwork",
            "true"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_work_cancel",
          "args": [
            "parent",
            "key_change_session_keyring"
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "mycred->session_keyring->uid",
            "mycred->euid"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "pcred->session_keyring->uid",
            "mycred->euid"
          ],
          "line": 1559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "pcred->sgid",
            "mycred->egid"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "pcred->egid",
            "mycred->egid"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "pcred->gid",
            "mycred->egid"
          ],
          "line": 1552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "pcred->suid",
            "mycred->euid"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "pcred->euid",
            "mycred->euid"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "pcred->uid",
            "mycred->euid"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "parent"
          ],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "parent"
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock_irq",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_task_work",
          "args": [
            "newwork",
            "key_change_session_keyring"
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "keyring_r"
          ],
          "line": 1517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cred_alloc_blank",
          "args": [],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "keyring_r"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "keyring_r"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "KEY_SPEC_SESSION_KEYRING",
            "0",
            "KEY_NEED_LINK"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_session_to_parent(void)\n{\n\tstruct task_struct *me, *parent;\n\tconst struct cred *mycred, *pcred;\n\tstruct callback_head *newwork, *oldwork;\n\tkey_ref_t keyring_r;\n\tstruct cred *cred;\n\tint ret;\n\n\tkeyring_r = lookup_user_key(KEY_SPEC_SESSION_KEYRING, 0, KEY_NEED_LINK);\n\tif (IS_ERR(keyring_r))\n\t\treturn PTR_ERR(keyring_r);\n\n\tret = -ENOMEM;\n\n\t/* our parent is going to need a new cred struct, a new tgcred struct\n\t * and new security data, so we allocate them here to prevent ENOMEM in\n\t * our parent */\n\tcred = cred_alloc_blank();\n\tif (!cred)\n\t\tgoto error_keyring;\n\tnewwork = &cred->rcu;\n\n\tcred->session_keyring = key_ref_to_ptr(keyring_r);\n\tkeyring_r = NULL;\n\tinit_task_work(newwork, key_change_session_keyring);\n\n\tme = current;\n\trcu_read_lock();\n\twrite_lock_irq(&tasklist_lock);\n\n\tret = -EPERM;\n\toldwork = NULL;\n\tparent = me->real_parent;\n\n\t/* the parent mustn't be init and mustn't be a kernel thread */\n\tif (parent->pid <= 1 || !parent->mm)\n\t\tgoto unlock;\n\n\t/* the parent must be single threaded */\n\tif (!thread_group_empty(parent))\n\t\tgoto unlock;\n\n\t/* the parent and the child must have different session keyrings or\n\t * there's no point */\n\tmycred = current_cred();\n\tpcred = __task_cred(parent);\n\tif (mycred == pcred ||\n\t    mycred->session_keyring == pcred->session_keyring) {\n\t\tret = 0;\n\t\tgoto unlock;\n\t}\n\n\t/* the parent must have the same effective ownership and mustn't be\n\t * SUID/SGID */\n\tif (!uid_eq(pcred->uid,\t mycred->euid) ||\n\t    !uid_eq(pcred->euid, mycred->euid) ||\n\t    !uid_eq(pcred->suid, mycred->euid) ||\n\t    !gid_eq(pcred->gid,\t mycred->egid) ||\n\t    !gid_eq(pcred->egid, mycred->egid) ||\n\t    !gid_eq(pcred->sgid, mycred->egid))\n\t\tgoto unlock;\n\n\t/* the keyrings must have the same UID */\n\tif ((pcred->session_keyring &&\n\t     !uid_eq(pcred->session_keyring->uid, mycred->euid)) ||\n\t    !uid_eq(mycred->session_keyring->uid, mycred->euid))\n\t\tgoto unlock;\n\n\t/* cancel an already pending keyring replacement */\n\toldwork = task_work_cancel(parent, key_change_session_keyring);\n\n\t/* the replacement session keyring is applied just prior to userspace\n\t * restarting */\n\tret = task_work_add(parent, newwork, true);\n\tif (!ret)\n\t\tnewwork = NULL;\nunlock:\n\twrite_unlock_irq(&tasklist_lock);\n\trcu_read_unlock();\n\tif (oldwork)\n\t\tput_cred(container_of(oldwork, struct cred, rcu));\n\tif (newwork)\n\t\tput_cred(cred);\n\treturn ret;\n\nerror_keyring:\n\tkey_ref_put(keyring_r);\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_get_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "1430-1480",
    "snippet": "long keyctl_get_security(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *context;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) != -EACCES)\n\t\t\treturn PTR_ERR(key_ref);\n\n\t\t/* viewing a key under construction is also permitted if we\n\t\t * have the authorisation token handy */\n\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\tif (IS_ERR(instkey))\n\t\t\treturn PTR_ERR(instkey);\n\t\tkey_put(instkey);\n\n\t\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, 0);\n\t\tif (IS_ERR(key_ref))\n\t\t\treturn PTR_ERR(key_ref);\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = security_key_getsecurity(key, &context);\n\tif (ret == 0) {\n\t\t/* if no information was returned, give userspace an empty\n\t\t * string */\n\t\tret = 1;\n\t\tif (buffer && buflen > 0 &&\n\t\t    copy_to_user(buffer, \"\", 1) != 0)\n\t\t\tret = -EFAULT;\n\t} else if (ret > 0) {\n\t\t/* return as much data as there's room for */\n\t\tif (buffer && buflen > 0) {\n\t\t\tif (buflen > ret)\n\t\t\t\tbuflen = ret;\n\n\t\t\tif (copy_to_user(buffer, context, buflen) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(context);\n\t}\n\n\tkey_ref_put(key_ref);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "key_ref"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "context"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "context",
            "buflen"
          ],
          "line": 1471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "\"\"",
            "1"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_key_getsecurity",
          "args": [
            "key",
            "&context"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "security_key_getsecurity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "1675-1679",
          "snippet": "int security_key_getsecurity(struct key *key, char **_buffer)\n{\n\t*_buffer = NULL;\n\treturn call_int_hook(key_getsecurity, 0, key, _buffer);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nint security_key_getsecurity(struct key *key, char **_buffer)\n{\n\t*_buffer = NULL;\n\treturn call_int_hook(key_getsecurity, 0, key, _buffer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 1456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 1452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "keyid",
            "KEY_LOOKUP_PARTIAL",
            "0"
          ],
          "line": 1451
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "instkey"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "instkey"
          ],
          "line": 1448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "instkey"
          ],
          "line": 1447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get_instantiation_authkey",
          "args": [
            "keyid"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "key_get_instantiation_authkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "234-268",
          "snippet": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void request_key_auth_revoke(struct key *);",
            "static void request_key_auth_destroy(struct key *);",
            "struct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 1441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_get_security(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *context;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\tif (PTR_ERR(key_ref) != -EACCES)\n\t\t\treturn PTR_ERR(key_ref);\n\n\t\t/* viewing a key under construction is also permitted if we\n\t\t * have the authorisation token handy */\n\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\tif (IS_ERR(instkey))\n\t\t\treturn PTR_ERR(instkey);\n\t\tkey_put(instkey);\n\n\t\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, 0);\n\t\tif (IS_ERR(key_ref))\n\t\t\treturn PTR_ERR(key_ref);\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = security_key_getsecurity(key, &context);\n\tif (ret == 0) {\n\t\t/* if no information was returned, give userspace an empty\n\t\t * string */\n\t\tret = 1;\n\t\tif (buffer && buflen > 0 &&\n\t\t    copy_to_user(buffer, \"\", 1) != 0)\n\t\t\tret = -EFAULT;\n\t} else if (ret > 0) {\n\t\t/* return as much data as there's room for */\n\t\tif (buffer && buflen > 0) {\n\t\t\tif (buflen > ret)\n\t\t\t\tbuflen = ret;\n\n\t\t\tif (copy_to_user(buffer, context, buflen) != 0)\n\t\t\t\tret = -EFAULT;\n\t\t}\n\n\t\tkfree(context);\n\t}\n\n\tkey_ref_put(key_ref);\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_assume_authority",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "1385-1418",
    "snippet": "long keyctl_assume_authority(key_serial_t id)\n{\n\tstruct key *authkey;\n\tlong ret;\n\n\t/* special key IDs aren't permitted */\n\tret = -EINVAL;\n\tif (id < 0)\n\t\tgoto error;\n\n\t/* we divest ourselves of authority if given an ID of 0 */\n\tif (id == 0) {\n\t\tret = keyctl_change_reqkey_auth(NULL);\n\t\tgoto error;\n\t}\n\n\t/* attempt to assume the authority temporarily granted to us whilst we\n\t * instantiate the specified key\n\t * - the authorisation key must be in the current task's keyrings\n\t *   somewhere\n\t */\n\tauthkey = key_get_instantiation_authkey(id);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error;\n\t}\n\n\tret = keyctl_change_reqkey_auth(authkey);\n\tif (ret == 0)\n\t\tret = authkey->serial;\n\tkey_put(authkey);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "authkey"
          ],
          "line": 1415
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyctl_change_reqkey_auth",
          "args": [
            "authkey"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "keyctl_change_reqkey_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
          "lines": "1017-1029",
          "snippet": "static int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "authkey"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "authkey"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get_instantiation_authkey",
          "args": [
            "id"
          ],
          "line": 1406
        },
        "resolved": true,
        "details": {
          "function_name": "key_get_instantiation_authkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "234-268",
          "snippet": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void request_key_auth_revoke(struct key *);",
            "static void request_key_auth_destroy(struct key *);",
            "struct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_assume_authority(key_serial_t id)\n{\n\tstruct key *authkey;\n\tlong ret;\n\n\t/* special key IDs aren't permitted */\n\tret = -EINVAL;\n\tif (id < 0)\n\t\tgoto error;\n\n\t/* we divest ourselves of authority if given an ID of 0 */\n\tif (id == 0) {\n\t\tret = keyctl_change_reqkey_auth(NULL);\n\t\tgoto error;\n\t}\n\n\t/* attempt to assume the authority temporarily granted to us whilst we\n\t * instantiate the specified key\n\t * - the authorisation key must be in the current task's keyrings\n\t *   somewhere\n\t */\n\tauthkey = key_get_instantiation_authkey(id);\n\tif (IS_ERR(authkey)) {\n\t\tret = PTR_ERR(authkey);\n\t\tgoto error;\n\t}\n\n\tret = keyctl_change_reqkey_auth(authkey);\n\tif (ret == 0)\n\t\tret = authkey->serial;\n\tkey_put(authkey);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_set_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "1328-1366",
    "snippet": "long keyctl_set_timeout(key_serial_t id, unsigned timeout)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\t/* setting the timeout on a key under construction is permitted\n\t\t * if we have the authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(id);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(id,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_set_timeout(key, timeout);\n\tkey_put(key);\n\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_set_timeout",
          "args": [
            "key",
            "timeout"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "key_set_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "709-723",
          "snippet": "void key_set_timeout(struct key *key, unsigned timeout)\n{\n\ttime64_t expiry = 0;\n\n\t/* make the changes with the locks held to prevent races */\n\tdown_write(&key->sem);\n\n\tif (timeout > 0)\n\t\texpiry = ktime_get_real_seconds() + timeout;\n\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\tup_write(&key->sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_set_timeout(struct key *key, unsigned timeout)\n{\n\ttime64_t expiry = 0;\n\n\t/* make the changes with the locks held to prevent races */\n\tdown_write(&key->sem);\n\n\tif (timeout > 0)\n\t\texpiry = ktime_get_real_seconds() + timeout;\n\n\tkey->expiry = expiry;\n\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\tup_write(&key->sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_KEEP",
            "&key->flags"
          ],
          "line": 1358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 1356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 1351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "id",
            "KEY_LOOKUP_PARTIAL",
            "0"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "instkey"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get_instantiation_authkey",
          "args": [
            "id"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "key_get_instantiation_authkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "234-268",
          "snippet": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void request_key_auth_revoke(struct key *);",
            "static void request_key_auth_destroy(struct key *);",
            "struct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_set_timeout(key_serial_t id, unsigned timeout)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\t/* setting the timeout on a key under construction is permitted\n\t\t * if we have the authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(id);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(id,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_set_timeout(key, timeout);\n\tkey_put(key);\n\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_set_reqkey_keyring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "1264-1312",
    "snippet": "long keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\n\told_setting = current_cred_xxx(jit_keyring);\n\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "new"
          ],
          "line": 1310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "install_process_keyring_to_cred",
          "args": [
            "new"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "install_process_keyring_to_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "185-201",
          "snippet": "int install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint install_process_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->process_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_pid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->process_keyring = keyring;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "install_thread_keyring_to_cred",
          "args": [
            "new"
          ],
          "line": 1280
        },
        "resolved": true,
        "details": {
          "function_name": "install_thread_keyring_to_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "138-154",
          "snippet": "int install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->thread_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint install_thread_keyring_to_cred(struct cred *new)\n{\n\tstruct key *keyring;\n\n\tif (new->thread_keyring)\n\t\treturn 0;\n\n\tkeyring = keyring_alloc(\"_tid\", new->uid, new->gid, new,\n\t\t\t\tKEY_POS_ALL | KEY_USR_VIEW,\n\t\t\t\tKEY_ALLOC_QUOTA_OVERRUN,\n\t\t\t\tNULL, NULL);\n\tif (IS_ERR(keyring))\n\t\treturn PTR_ERR(keyring);\n\n\tnew->thread_keyring = keyring;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 1274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred_xxx",
          "args": [
            "jit_keyring"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_set_reqkey_keyring(int reqkey_defl)\n{\n\tstruct cred *new;\n\tint ret, old_setting;\n\n\told_setting = current_cred_xxx(jit_keyring);\n\n\tif (reqkey_defl == KEY_REQKEY_DEFL_NO_CHANGE)\n\t\treturn old_setting;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tswitch (reqkey_defl) {\n\tcase KEY_REQKEY_DEFL_THREAD_KEYRING:\n\t\tret = install_thread_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_PROCESS_KEYRING:\n\t\tret = install_process_keyring_to_cred(new);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_DEFAULT:\n\tcase KEY_REQKEY_DEFL_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_KEYRING:\n\tcase KEY_REQKEY_DEFL_USER_SESSION_KEYRING:\n\tcase KEY_REQKEY_DEFL_REQUESTOR_KEYRING:\n\t\tgoto set;\n\n\tcase KEY_REQKEY_DEFL_NO_CHANGE:\n\tcase KEY_REQKEY_DEFL_GROUP_KEYRING:\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto error;\n\t}\n\nset:\n\tnew->jit_keyring = reqkey_defl;\n\tcommit_creds(new);\n\treturn old_setting;\nerror:\n\tabort_creds(new);\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_reject_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "1206-1255",
    "snippet": "long keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n\t\t       key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter(\"%d,%u,%u,%d\", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n\t\t\t\t  dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyctl_change_reqkey_auth",
          "args": [
            "NULL"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "keyctl_change_reqkey_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
          "lines": "1017-1029",
          "snippet": "static int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "dest_keyring"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_reject_and_link",
          "args": [
            "rka->target_key",
            "timeout",
            "error",
            "dest_keyring",
            "instkey"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "key_reject_and_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "566-622",
          "snippet": "int key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret, awaken, link_ret = 0;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\t/* mark the key as being negatively instantiated */\n\t\tatomic_inc(&key->user->nikeys);\n\t\tmark_key_instantiated(key, -error);\n\t\tkey->expiry = ktime_get_real_seconds() + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\n\t\tret = 0;\n\n\t\t/* and link it into the destination keyring */\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\n\t\t/* disable the authorisation key */\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\tif (keyring && link_ret == 0)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret == 0 ? link_ret : ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint key_reject_and_link(struct key *key,\n\t\t\tunsigned timeout,\n\t\t\tunsigned error,\n\t\t\tstruct key *keyring,\n\t\t\tstruct key *authkey)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret, awaken, link_ret = 0;\n\n\tkey_check(key);\n\tkey_check(keyring);\n\n\tawaken = 0;\n\tret = -EBUSY;\n\n\tif (keyring) {\n\t\tif (keyring->restrict_link)\n\t\t\treturn -EPERM;\n\n\t\tlink_ret = __key_link_begin(keyring, &key->index_key, &edit);\n\t}\n\n\tmutex_lock(&key_construction_mutex);\n\n\t/* can't instantiate twice */\n\tif (key->state == KEY_IS_UNINSTANTIATED) {\n\t\t/* mark the key as being negatively instantiated */\n\t\tatomic_inc(&key->user->nikeys);\n\t\tmark_key_instantiated(key, -error);\n\t\tkey->expiry = ktime_get_real_seconds() + timeout;\n\t\tkey_schedule_gc(key->expiry + key_gc_delay);\n\n\t\tif (test_and_clear_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags))\n\t\t\tawaken = 1;\n\n\t\tret = 0;\n\n\t\t/* and link it into the destination keyring */\n\t\tif (keyring && link_ret == 0)\n\t\t\t__key_link(key, &edit);\n\n\t\t/* disable the authorisation key */\n\t\tif (authkey)\n\t\t\tkey_revoke(authkey);\n\t}\n\n\tmutex_unlock(&key_construction_mutex);\n\n\tif (keyring && link_ret == 0)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\n\t/* wake up anyone waiting for a key to be constructed */\n\tif (awaken)\n\t\twake_up_bit(&key->flags, KEY_FLAG_USER_CONSTRUCT);\n\n\treturn ret == 0 ? link_ret : ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_instantiation_keyring",
          "args": [
            "ringid",
            "rka",
            "&dest_keyring"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "get_instantiation_keyring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
          "lines": "980-1012",
          "snippet": "static long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"%d,%u,%u,%d\"",
            "id",
            "timeout",
            "error",
            "ringid"
          ],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n\t\t       key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter(\"%d,%u,%u,%d\", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n\t\t\t\t  dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_negate_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "1186-1189",
    "snippet": "long keyctl_negate_key(key_serial_t id, unsigned timeout, key_serial_t ringid)\n{\n\treturn keyctl_reject_key(id, timeout, ENOKEY, ringid);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyctl_reject_key",
          "args": [
            "id",
            "timeout",
            "ENOKEY",
            "ringid"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "keyctl_reject_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
          "lines": "1206-1255",
          "snippet": "long keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n\t\t       key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter(\"%d,%u,%u,%d\", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n\t\t\t\t  dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_reject_key(key_serial_t id, unsigned timeout, unsigned error,\n\t\t       key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tlong ret;\n\n\tkenter(\"%d,%u,%u,%d\", id, timeout, error, ringid);\n\n\t/* must be a valid error code and mustn't be a kernel special */\n\tif (error <= 0 ||\n\t    error >= MAX_ERRNO ||\n\t    error == ERESTARTSYS ||\n\t    error == ERESTARTNOINTR ||\n\t    error == ERESTARTNOHAND ||\n\t    error == ERESTART_RESTARTBLOCK)\n\t\treturn -EINVAL;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* find the destination keyring if present (which must also be\n\t * writable) */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_reject_and_link(rka->target_key, timeout, error,\n\t\t\t\t  dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror:\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_negate_key(key_serial_t id, unsigned timeout, key_serial_t ringid)\n{\n\treturn keyctl_reject_key(id, timeout, ENOKEY, ringid);\n}"
  },
  {
    "function_name": "keyctl_instantiate_key_iov",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "1150-1169",
    "snippet": "long keyctl_instantiate_key_iov(key_serial_t id,\n\t\t\t\tconst struct iovec __user *_payload_iov,\n\t\t\t\tunsigned ioc,\n\t\t\t\tkey_serial_t ringid)\n{\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tstruct iov_iter from;\n\tlong ret;\n\n\tif (!_payload_iov)\n\t\tioc = 0;\n\n\tret = import_iovec(WRITE, _payload_iov, ioc,\n\t\t\t\t    ARRAY_SIZE(iovstack), &iov, &from);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = keyctl_instantiate_key_common(id, &from, ringid);\n\tkfree(iov);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "iov"
          ],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyctl_instantiate_key_common",
          "args": [
            "id",
            "&from",
            "ringid"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "keyctl_instantiate_key_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
          "lines": "1040-1109",
          "snippet": "long keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t/* find the destination keyring amongst those belonging to the\n\t * requesting task */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\nerror:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t/* find the destination keyring amongst those belonging to the\n\t * requesting task */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\nerror:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "import_iovec",
          "args": [
            "WRITE",
            "_payload_iov",
            "ioc",
            "ARRAY_SIZE(iovstack)",
            "&iov",
            "&from"
          ],
          "line": 1162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "iovstack"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_instantiate_key_iov(key_serial_t id,\n\t\t\t\tconst struct iovec __user *_payload_iov,\n\t\t\t\tunsigned ioc,\n\t\t\t\tkey_serial_t ringid)\n{\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tstruct iov_iter from;\n\tlong ret;\n\n\tif (!_payload_iov)\n\t\tioc = 0;\n\n\tret = import_iovec(WRITE, _payload_iov, ioc,\n\t\t\t\t    ARRAY_SIZE(iovstack), &iov, &from);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = keyctl_instantiate_key_common(id, &from, ringid);\n\tkfree(iov);\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_instantiate_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "1120-1139",
    "snippet": "long keyctl_instantiate_key(key_serial_t id,\n\t\t\t    const void __user *_payload,\n\t\t\t    size_t plen,\n\t\t\t    key_serial_t ringid)\n{\n\tif (_payload && plen) {\n\t\tstruct iovec iov;\n\t\tstruct iov_iter from;\n\t\tint ret;\n\n\t\tret = import_single_range(WRITE, (void __user *)_payload, plen,\n\t\t\t\t\t  &iov, &from);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\treturn keyctl_instantiate_key_common(id, &from, ringid);\n\t}\n\n\treturn keyctl_instantiate_key_common(id, NULL, ringid);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyctl_instantiate_key_common",
          "args": [
            "id",
            "NULL",
            "ringid"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "keyctl_instantiate_key_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
          "lines": "1040-1109",
          "snippet": "long keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t/* find the destination keyring amongst those belonging to the\n\t * requesting task */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\nerror:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t/* find the destination keyring amongst those belonging to the\n\t * requesting task */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\nerror:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "import_single_range",
          "args": [
            "WRITE",
            "(void __user *)_payload",
            "plen",
            "&iov",
            "&from"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_instantiate_key(key_serial_t id,\n\t\t\t    const void __user *_payload,\n\t\t\t    size_t plen,\n\t\t\t    key_serial_t ringid)\n{\n\tif (_payload && plen) {\n\t\tstruct iovec iov;\n\t\tstruct iov_iter from;\n\t\tint ret;\n\n\t\tret = import_single_range(WRITE, (void __user *)_payload, plen,\n\t\t\t\t\t  &iov, &from);\n\t\tif (unlikely(ret))\n\t\t\treturn ret;\n\n\t\treturn keyctl_instantiate_key_common(id, &from, ringid);\n\t}\n\n\treturn keyctl_instantiate_key_common(id, NULL, ringid);\n}"
  },
  {
    "function_name": "keyctl_instantiate_key_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "1040-1109",
    "snippet": "long keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t/* find the destination keyring amongst those belonging to the\n\t * requesting task */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "payload"
          ],
          "line": 1105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memzero_explicit",
          "args": [
            "payload",
            "plen"
          ],
          "line": 1104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyctl_change_reqkey_auth",
          "args": [
            "NULL"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "keyctl_change_reqkey_auth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
          "lines": "1017-1029",
          "snippet": "static int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "dest_keyring"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_instantiate_and_link",
          "args": [
            "rka->target_key",
            "payload",
            "plen",
            "dest_keyring",
            "instkey"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "key_instantiate_and_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "495-541",
          "snippet": "int key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tif (keyring->restrict_link && keyring->restrict_link->check) {\n\t\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\t\tret = keyres->check(keyring, key->type, &prep.payload,\n\t\t\t\t\t    keyres->key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\nerror_link_end:\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tif (keyring->restrict_link && keyring->restrict_link->check) {\n\t\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\t\tret = keyres->check(keyring, key->type, &prep.payload,\n\t\t\t\t\t    keyres->key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\nerror_link_end:\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_instantiation_keyring",
          "args": [
            "ringid",
            "rka",
            "&dest_keyring"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "get_instantiation_keyring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
          "lines": "980-1012",
          "snippet": "static long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_iter_full",
          "args": [
            "payload",
            "plen",
            "from"
          ],
          "line": 1081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kvmalloc",
          "args": [
            "plen",
            "GFP_KERNEL"
          ],
          "line": 1076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"%d,,%zu,%d\"",
            "id",
            "plen",
            "ringid"
          ],
          "line": 1051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_iter_count",
          "args": [
            "from"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 1044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_instantiate_key_common(key_serial_t id,\n\t\t\t\t   struct iov_iter *from,\n\t\t\t\t   key_serial_t ringid)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct request_key_auth *rka;\n\tstruct key *instkey, *dest_keyring;\n\tsize_t plen = from ? iov_iter_count(from) : 0;\n\tvoid *payload;\n\tlong ret;\n\n\tkenter(\"%d,,%zu,%d\", id, plen, ringid);\n\n\tif (!plen)\n\t\tfrom = NULL;\n\n\tret = -EINVAL;\n\tif (plen > 1024 * 1024 - 1)\n\t\tgoto error;\n\n\t/* the appropriate instantiation authorisation key must have been\n\t * assumed before calling this */\n\tret = -EPERM;\n\tinstkey = cred->request_key_auth;\n\tif (!instkey)\n\t\tgoto error;\n\n\trka = instkey->payload.data[0];\n\tif (rka->target_key->serial != id)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\n\tif (from) {\n\t\tret = -ENOMEM;\n\t\tpayload = kvmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (!copy_from_iter_full(payload, plen, from))\n\t\t\tgoto error2;\n\t}\n\n\t/* find the destination keyring amongst those belonging to the\n\t * requesting task */\n\tret = get_instantiation_keyring(ringid, rka, &dest_keyring);\n\tif (ret < 0)\n\t\tgoto error2;\n\n\t/* instantiate the key and link it into a keyring */\n\tret = key_instantiate_and_link(rka->target_key, payload, plen,\n\t\t\t\t       dest_keyring, instkey);\n\n\tkey_put(dest_keyring);\n\n\t/* discard the assumed authority if it's just been disabled by\n\t * instantiation of the key */\n\tif (ret == 0)\n\t\tkeyctl_change_reqkey_auth(NULL);\n\nerror2:\n\tif (payload) {\n\t\tmemzero_explicit(payload, plen);\n\t\tkvfree(payload);\n\t}\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_change_reqkey_auth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "1017-1029",
    "snippet": "static int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "new"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "key"
          ],
          "line": 1026
        },
        "resolved": true,
        "details": {
          "function_name": "key_get_instantiation_authkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "234-268",
          "snippet": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void request_key_auth_revoke(struct key *);",
            "static void request_key_auth_destroy(struct key *);",
            "struct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "new->request_key_auth"
          ],
          "line": 1025
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int keyctl_change_reqkey_auth(struct key *key)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tkey_put(new->request_key_auth);\n\tnew->request_key_auth = key_get(key);\n\n\treturn commit_creds(new);\n}"
  },
  {
    "function_name": "get_instantiation_keyring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "980-1012",
    "snippet": "static long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "rka->dest_keyring"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "key_get_instantiation_authkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "234-268",
          "snippet": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void request_key_auth_revoke(struct key *);",
            "static void request_key_auth_destroy(struct key *);",
            "struct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "dkref"
          ],
          "line": 997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dkref"
          ],
          "line": 996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dkref"
          ],
          "line": 995
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "ringid",
            "KEY_LOOKUP_CREATE",
            "KEY_NEED_WRITE"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic long get_instantiation_keyring(key_serial_t ringid,\n\t\t\t\t      struct request_key_auth *rka,\n\t\t\t\t      struct key **_dest_keyring)\n{\n\tkey_ref_t dkref;\n\n\t*_dest_keyring = NULL;\n\n\t/* just return a NULL pointer if we weren't asked to make a link */\n\tif (ringid == 0)\n\t\treturn 0;\n\n\t/* if a specific keyring is nominated by ID, then use that */\n\tif (ringid > 0) {\n\t\tdkref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\t\tif (IS_ERR(dkref))\n\t\t\treturn PTR_ERR(dkref);\n\t\t*_dest_keyring = key_ref_to_ptr(dkref);\n\t\treturn 0;\n\t}\n\n\tif (ringid == KEY_SPEC_REQKEY_AUTH_KEY)\n\t\treturn -EINVAL;\n\n\t/* otherwise specify the destination keyring recorded in the\n\t * authorisation key (any KEY_SPEC_*_KEYRING) */\n\tif (ringid >= KEY_SPEC_REQUESTOR_KEYRING) {\n\t\t*_dest_keyring = key_get(rka->dest_keyring);\n\t\treturn 0;\n\t}\n\n\treturn -ENOKEY;\n}"
  },
  {
    "function_name": "keyctl_setperm_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "941-974",
    "snippet": "long keyctl_setperm_key(key_serial_t id, key_perm_t perm)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chmod races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\t/* if we're not the sysadmin, we can only change a key that we own */\n\tif (capable(CAP_SYS_ADMIN) || uid_eq(key->uid, current_fsuid())) {\n\t\tkey->perm = perm;\n\t\tret = 0;\n\t}\n\n\tup_write(&key->sem);\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&key->sem"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "key->uid",
            "current_fsuid()"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&key->sem"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "id",
            "KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL",
            "KEY_NEED_SETATTR"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_setperm_key(key_serial_t id, key_perm_t perm)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (perm & ~(KEY_POS_ALL | KEY_USR_ALL | KEY_GRP_ALL | KEY_OTH_ALL))\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chmod races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\t/* if we're not the sysadmin, we can only change a key that we own */\n\tif (capable(CAP_SYS_ADMIN) || uid_eq(key->uid, current_fsuid())) {\n\t\tkey->perm = perm;\n\t\tret = 0;\n\t}\n\n\tup_write(&key->sem);\n\tkey_put(key);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_chown_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "824-932",
    "snippet": "long keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)\n{\n\tstruct key_user *newowner, *zapowner = NULL;\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\tret = -EINVAL;\n\tif ((user != (uid_t) -1) && !uid_valid(uid))\n\t\tgoto error;\n\tif ((group != (gid_t) -1) && !gid_valid(gid))\n\t\tgoto error;\n\n\tret = 0;\n\tif (user == (uid_t) -1 && group == (gid_t) -1)\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chown races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/* only the sysadmin can chown a key to some other UID */\n\t\tif (user != (uid_t) -1 && !uid_eq(key->uid, uid))\n\t\t\tgoto error_put;\n\n\t\t/* only the sysadmin can set the key's GID to a group other\n\t\t * than one of those that the current process subscribes to */\n\t\tif (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))\n\t\t\tgoto error_put;\n\t}\n\n\t/* change the UID */\n\tif (user != (uid_t) -1 && !uid_eq(uid, key->uid)) {\n\t\tret = -ENOMEM;\n\t\tnewowner = key_user_lookup(uid);\n\t\tif (!newowner)\n\t\t\tgoto error_put;\n\n\t\t/* transfer the quota burden to the new user */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\t\tspin_lock(&newowner->lock);\n\t\t\tif (newowner->qnkeys + 1 >= maxkeys ||\n\t\t\t    newowner->qnbytes + key->quotalen >= maxbytes ||\n\t\t\t    newowner->qnbytes + key->quotalen <\n\t\t\t    newowner->qnbytes)\n\t\t\t\tgoto quota_overrun;\n\n\t\t\tnewowner->qnkeys++;\n\t\t\tnewowner->qnbytes += key->quotalen;\n\t\t\tspin_unlock(&newowner->lock);\n\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tatomic_inc(&newowner->nkeys);\n\n\t\tif (key->state != KEY_IS_UNINSTANTIATED) {\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\t\tatomic_inc(&newowner->nikeys);\n\t\t}\n\n\t\tzapowner = key->user;\n\t\tkey->user = newowner;\n\t\tkey->uid = uid;\n\t}\n\n\t/* change the GID */\n\tif (group != (gid_t) -1)\n\t\tkey->gid = gid;\n\n\tret = 0;\n\nerror_put:\n\tup_write(&key->sem);\n\tkey_put(key);\n\tif (zapowner)\n\t\tkey_user_put(zapowner);\nerror:\n\treturn ret;\n\nquota_overrun:\n\tspin_unlock(&newowner->lock);\n\tzapowner = newowner;\n\tret = -EDQUOT;\n\tgoto error_put;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&newowner->lock"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_user_put",
          "args": [
            "zapowner"
          ],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "key_user_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "123-131",
          "snippet": "void key_user_put(struct key_user *user)\n{\n\tif (refcount_dec_and_lock(&user->usage, &key_user_lock)) {\n\t\trb_erase(&user->node, &key_user_tree);\n\t\tspin_unlock(&key_user_lock);\n\n\t\tkfree(user);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rb_root\tkey_user_tree;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct rb_root\tkey_user_tree;\n\nvoid key_user_put(struct key_user *user)\n{\n\tif (refcount_dec_and_lock(&user->usage, &key_user_lock)) {\n\t\trb_erase(&user->node, &key_user_tree);\n\t\tspin_unlock(&key_user_lock);\n\n\t\tkfree(user);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&key->sem"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&newowner->nikeys"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&key->user->nikeys"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&newowner->nkeys"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&key->user->nkeys"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&key->user->lock"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&key->user->lock"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&newowner->lock"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&newowner->lock"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "uid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "uid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_IN_QUOTA",
            "&key->flags"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_user_lookup",
          "args": [
            "uid"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "key_user_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "54-118",
          "snippet": "struct key_user *key_user_lookup(kuid_t uid)\n{\n\tstruct key_user *candidate = NULL, *user;\n\tstruct rb_node *parent, **p;\n\ntry_again:\n\tparent = NULL;\n\tp = &key_user_tree.rb_node;\n\tspin_lock(&key_user_lock);\n\n\t/* search the tree for a user record with a matching UID */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tuser = rb_entry(parent, struct key_user, node);\n\n\t\tif (uid_lt(uid, user->uid))\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (uid_gt(uid, user->uid))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\n\t/* if we get here, we failed to find a match in the tree */\n\tif (!candidate) {\n\t\t/* allocate a candidate user record if we don't already have\n\t\t * one */\n\t\tspin_unlock(&key_user_lock);\n\n\t\tuser = NULL;\n\t\tcandidate = kmalloc(sizeof(struct key_user), GFP_KERNEL);\n\t\tif (unlikely(!candidate))\n\t\t\tgoto out;\n\n\t\t/* the allocation may have scheduled, so we need to repeat the\n\t\t * search lest someone else added the record whilst we were\n\t\t * asleep */\n\t\tgoto try_again;\n\t}\n\n\t/* if we get here, then the user record still hadn't appeared on the\n\t * second pass - so we use the candidate record */\n\trefcount_set(&candidate->usage, 1);\n\tatomic_set(&candidate->nkeys, 0);\n\tatomic_set(&candidate->nikeys, 0);\n\tcandidate->uid = uid;\n\tcandidate->qnkeys = 0;\n\tcandidate->qnbytes = 0;\n\tspin_lock_init(&candidate->lock);\n\tmutex_init(&candidate->cons_lock);\n\n\trb_link_node(&candidate->node, parent, p);\n\trb_insert_color(&candidate->node, &key_user_tree);\n\tspin_unlock(&key_user_lock);\n\tuser = candidate;\n\tgoto out;\n\n\t/* okay - we found a user record for this UID */\nfound:\n\trefcount_inc(&user->usage);\n\tspin_unlock(&key_user_lock);\n\tkfree(candidate);\nout:\n\treturn user;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct rb_root\tkey_user_tree;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct rb_root\tkey_user_tree;\n\nstruct key_user *key_user_lookup(kuid_t uid)\n{\n\tstruct key_user *candidate = NULL, *user;\n\tstruct rb_node *parent, **p;\n\ntry_again:\n\tparent = NULL;\n\tp = &key_user_tree.rb_node;\n\tspin_lock(&key_user_lock);\n\n\t/* search the tree for a user record with a matching UID */\n\twhile (*p) {\n\t\tparent = *p;\n\t\tuser = rb_entry(parent, struct key_user, node);\n\n\t\tif (uid_lt(uid, user->uid))\n\t\t\tp = &(*p)->rb_left;\n\t\telse if (uid_gt(uid, user->uid))\n\t\t\tp = &(*p)->rb_right;\n\t\telse\n\t\t\tgoto found;\n\t}\n\n\t/* if we get here, we failed to find a match in the tree */\n\tif (!candidate) {\n\t\t/* allocate a candidate user record if we don't already have\n\t\t * one */\n\t\tspin_unlock(&key_user_lock);\n\n\t\tuser = NULL;\n\t\tcandidate = kmalloc(sizeof(struct key_user), GFP_KERNEL);\n\t\tif (unlikely(!candidate))\n\t\t\tgoto out;\n\n\t\t/* the allocation may have scheduled, so we need to repeat the\n\t\t * search lest someone else added the record whilst we were\n\t\t * asleep */\n\t\tgoto try_again;\n\t}\n\n\t/* if we get here, then the user record still hadn't appeared on the\n\t * second pass - so we use the candidate record */\n\trefcount_set(&candidate->usage, 1);\n\tatomic_set(&candidate->nkeys, 0);\n\tatomic_set(&candidate->nikeys, 0);\n\tcandidate->uid = uid;\n\tcandidate->qnkeys = 0;\n\tcandidate->qnbytes = 0;\n\tspin_lock_init(&candidate->lock);\n\tmutex_init(&candidate->cons_lock);\n\n\trb_link_node(&candidate->node, parent, p);\n\trb_insert_color(&candidate->node, &key_user_tree);\n\tspin_unlock(&key_user_lock);\n\tuser = candidate;\n\tgoto out;\n\n\t/* okay - we found a user record for this UID */\nfound:\n\trefcount_inc(&user->usage);\n\tspin_unlock(&key_user_lock);\n\tkfree(candidate);\nout:\n\treturn user;\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "uid",
            "key->uid"
          ],
          "line": 870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_group_p",
          "args": [
            "gid"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "gid",
            "key->gid"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "key->uid",
            "uid"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 858
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&key->sem"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "id",
            "KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL",
            "KEY_NEED_SETATTR"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kgid",
          "args": [
            "current_user_ns()",
            "group"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "user"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_chown_key(key_serial_t id, uid_t user, gid_t group)\n{\n\tstruct key_user *newowner, *zapowner = NULL;\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\tkuid_t uid;\n\tkgid_t gid;\n\n\tuid = make_kuid(current_user_ns(), user);\n\tgid = make_kgid(current_user_ns(), group);\n\tret = -EINVAL;\n\tif ((user != (uid_t) -1) && !uid_valid(uid))\n\t\tgoto error;\n\tif ((group != (gid_t) -1) && !gid_valid(gid))\n\t\tgoto error;\n\n\tret = 0;\n\tif (user == (uid_t) -1 && group == (gid_t) -1)\n\t\tgoto error;\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE | KEY_LOOKUP_PARTIAL,\n\t\t\t\t  KEY_NEED_SETATTR);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* make the changes with the locks held to prevent chown/chown races */\n\tret = -EACCES;\n\tdown_write(&key->sem);\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\t/* only the sysadmin can chown a key to some other UID */\n\t\tif (user != (uid_t) -1 && !uid_eq(key->uid, uid))\n\t\t\tgoto error_put;\n\n\t\t/* only the sysadmin can set the key's GID to a group other\n\t\t * than one of those that the current process subscribes to */\n\t\tif (group != (gid_t) -1 && !gid_eq(gid, key->gid) && !in_group_p(gid))\n\t\t\tgoto error_put;\n\t}\n\n\t/* change the UID */\n\tif (user != (uid_t) -1 && !uid_eq(uid, key->uid)) {\n\t\tret = -ENOMEM;\n\t\tnewowner = key_user_lookup(uid);\n\t\tif (!newowner)\n\t\t\tgoto error_put;\n\n\t\t/* transfer the quota burden to the new user */\n\t\tif (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\t\tspin_lock(&newowner->lock);\n\t\t\tif (newowner->qnkeys + 1 >= maxkeys ||\n\t\t\t    newowner->qnbytes + key->quotalen >= maxbytes ||\n\t\t\t    newowner->qnbytes + key->quotalen <\n\t\t\t    newowner->qnbytes)\n\t\t\t\tgoto quota_overrun;\n\n\t\t\tnewowner->qnkeys++;\n\t\t\tnewowner->qnbytes += key->quotalen;\n\t\t\tspin_unlock(&newowner->lock);\n\n\t\t\tspin_lock(&key->user->lock);\n\t\t\tkey->user->qnkeys--;\n\t\t\tkey->user->qnbytes -= key->quotalen;\n\t\t\tspin_unlock(&key->user->lock);\n\t\t}\n\n\t\tatomic_dec(&key->user->nkeys);\n\t\tatomic_inc(&newowner->nkeys);\n\n\t\tif (key->state != KEY_IS_UNINSTANTIATED) {\n\t\t\tatomic_dec(&key->user->nikeys);\n\t\t\tatomic_inc(&newowner->nikeys);\n\t\t}\n\n\t\tzapowner = key->user;\n\t\tkey->user = newowner;\n\t\tkey->uid = uid;\n\t}\n\n\t/* change the GID */\n\tif (group != (gid_t) -1)\n\t\tkey->gid = gid;\n\n\tret = 0;\n\nerror_put:\n\tup_write(&key->sem);\n\tkey_put(key);\n\tif (zapowner)\n\t\tkey_user_put(zapowner);\nerror:\n\treturn ret;\n\nquota_overrun:\n\tspin_unlock(&newowner->lock);\n\tzapowner = newowner;\n\tret = -EDQUOT;\n\tgoto error_put;\n}"
  },
  {
    "function_name": "keyctl_read_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "754-807",
    "snippet": "long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\tgoto error2; /* Negatively instantiated */\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&key->sem"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key->type->read",
          "args": [
            "key",
            "buffer",
            "buflen"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_validate",
          "args": [
            "key"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "key_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/permission.c",
          "lines": "89-109",
          "snippet": "int key_validate(const struct key *key)\n{\n\tunsigned long flags = READ_ONCE(key->flags);\n\ttime64_t expiry = READ_ONCE(key->expiry);\n\n\tif (flags & (1 << KEY_FLAG_INVALIDATED))\n\t\treturn -ENOKEY;\n\n\t/* check it's still accessible */\n\tif (flags & ((1 << KEY_FLAG_REVOKED) |\n\t\t     (1 << KEY_FLAG_DEAD)))\n\t\treturn -EKEYREVOKED;\n\n\t/* check it hasn't expired */\n\tif (expiry) {\n\t\tif (ktime_get_real_seconds() >= expiry)\n\t\t\treturn -EKEYEXPIRED;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/security.h>\n#include <linux/module.h>\n\nint key_validate(const struct key *key)\n{\n\tunsigned long flags = READ_ONCE(key->flags);\n\ttime64_t expiry = READ_ONCE(key->expiry);\n\n\tif (flags & (1 << KEY_FLAG_INVALIDATED))\n\t\treturn -ENOKEY;\n\n\t/* check it's still accessible */\n\tif (flags & ((1 << KEY_FLAG_REVOKED) |\n\t\t     (1 << KEY_FLAG_DEAD)))\n\t\treturn -EKEYREVOKED;\n\n\t/* check it hasn't expired */\n\tif (expiry) {\n\t\tif (ktime_get_real_seconds() >= expiry)\n\t\t\treturn -EKEYEXPIRED;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&key->sem"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_key_possessed",
          "args": [
            "key_ref"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_permission",
          "args": [
            "key_ref",
            "KEY_NEED_READ"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "key_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/internal.h",
          "lines": "186-189",
          "snippet": "static inline int key_permission(const key_ref_t key_ref, unsigned perm)\n{\n\treturn key_task_permission(key_ref, current_cred(), perm);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/refcount.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/task_work.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/refcount.h>\n#include <linux/keyctl.h>\n#include <linux/task_work.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/wait_bit.h>\n#include <linux/sched.h>\n\nstatic inline int key_permission(const key_ref_t key_ref, unsigned perm)\n{\n\treturn key_task_permission(key_ref, current_cred(), perm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_read_state",
          "args": [
            "key"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "keyid",
            "0",
            "0"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong ret;\n\n\t/* find the key first */\n\tkey_ref = lookup_user_key(keyid, 0, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tret = key_read_state(key);\n\tif (ret < 0)\n\t\tgoto error2; /* Negatively instantiated */\n\n\t/* see if we can read it directly */\n\tret = key_permission(key_ref, KEY_NEED_READ);\n\tif (ret == 0)\n\t\tgoto can_read_key;\n\tif (ret != -EACCES)\n\t\tgoto error2;\n\n\t/* we can't; see if it's searchable from this process's keyrings\n\t * - we automatically take account of the fact that it may be\n\t *   dangling off an instantiation key\n\t */\n\tif (!is_key_possessed(key_ref)) {\n\t\tret = -EACCES;\n\t\tgoto error2;\n\t}\n\n\t/* the key is probably readable - now try to read it */\ncan_read_key:\n\tret = -EOPNOTSUPP;\n\tif (key->type->read) {\n\t\t/* Read the data with the semaphore held (since we might sleep)\n\t\t * to protect against the key being updated or revoked.\n\t\t */\n\t\tdown_read(&key->sem);\n\t\tret = key_validate(key);\n\t\tif (ret == 0)\n\t\t\tret = key->type->read(key, buffer, buflen);\n\t\tup_read(&key->sem);\n\t}\n\nerror2:\n\tkey_put(key);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_keyring_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "660-742",
    "snippet": "long keyctl_keyring_search(key_serial_t ringid,\n\t\t\t   const char __user *_type,\n\t\t\t   const char __user *_description,\n\t\t\t   key_serial_t destringid)\n{\n\tstruct key_type *ktype;\n\tkey_ref_t keyring_ref, key_ref, dest_ref;\n\tchar type[32], *description;\n\tlong ret;\n\n\t/* pull the type and description into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* get the keyring at which to begin the search */\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error2;\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey_ref = keyring_search(keyring_ref, ktype, description);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* treat lack or presence of a negative key the same */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOKEY;\n\t\tgoto error5;\n\t}\n\n\t/* link the resulting key to the destination keyring if we can */\n\tif (dest_ref) {\n\t\tret = key_permission(key_ref, KEY_NEED_LINK);\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\n\t\tret = key_link(key_ref_to_ptr(dest_ref), key_ref_to_ptr(key_ref));\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\nerror6:\n\tkey_ref_put(key_ref);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkey_ref_put(keyring_ref);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KEY_MAX_DESC_SIZE 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "description"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "keyring_ref"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "dest_ref"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_type_put",
          "args": [
            "ktype"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "key_type_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "729-732",
          "snippet": "void key_type_put(struct key_type *ktype)\n{\n\tup_read(&key_types_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(key_types_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(key_types_sem);\n\nvoid key_type_put(struct key_type *ktype)\n{\n\tup_read(&key_types_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "key_ref"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_link",
          "args": [
            "key_ref_to_ptr(dest_ref)",
            "key_ref_to_ptr(key_ref)"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "key_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1363-1386",
          "snippet": "int key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\t\tret = __key_link_check_restriction(keyring, key);\n\t\tif (ret == 0)\n\t\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nint key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\t\tret = __key_link_check_restriction(keyring, key);\n\t\tif (ret == 0)\n\t\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "dest_ref"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_permission",
          "args": [
            "key_ref",
            "KEY_NEED_LINK"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "key_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/internal.h",
          "lines": "186-189",
          "snippet": "static inline int key_permission(const key_ref_t key_ref, unsigned perm)\n{\n\treturn key_task_permission(key_ref, current_cred(), perm);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/refcount.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/task_work.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/refcount.h>\n#include <linux/keyctl.h>\n#include <linux/task_work.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/wait_bit.h>\n#include <linux/sched.h>\n\nstatic inline int key_permission(const key_ref_t key_ref, unsigned perm)\n{\n\treturn key_task_permission(key_ref, current_cred(), perm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_search",
          "args": [
            "keyring_ref",
            "ktype",
            "description"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "917-944",
          "snippet": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nkey_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ktype"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ktype"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_type_lookup",
          "args": [
            "type"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "key_type_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "689-707",
          "snippet": "struct key_type *key_type_lookup(const char *type)\n{\n\tstruct key_type *ktype;\n\n\tdown_read(&key_types_sem);\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tlist_for_each_entry(ktype, &key_types_list, link) {\n\t\tif (strcmp(ktype->name, type) == 0)\n\t\t\tgoto found_kernel_type;\n\t}\n\n\tup_read(&key_types_sem);\n\tktype = ERR_PTR(-ENOKEY);\n\nfound_kernel_type:\n\treturn ktype;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(key_types_list);",
            "static DECLARE_RWSEM(key_types_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(key_types_list);\nstatic DECLARE_RWSEM(key_types_sem);\n\nstruct key_type *key_type_lookup(const char *type)\n{\n\tstruct key_type *ktype;\n\n\tdown_read(&key_types_sem);\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tlist_for_each_entry(ktype, &key_types_list, link) {\n\t\tif (strcmp(ktype->name, type) == 0)\n\t\t\tgoto found_kernel_type;\n\t}\n\n\tup_read(&key_types_sem);\n\tktype = ERR_PTR(-ENOKEY);\n\nfound_kernel_type:\n\treturn ktype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "dest_ref"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dest_ref"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "destringid",
            "KEY_LOOKUP_CREATE",
            "KEY_NEED_WRITE"
          ],
          "line": 691
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "keyring_ref"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "keyring_ref"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "description"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "description"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strndup_user",
          "args": [
            "_description",
            "KEY_MAX_DESC_SIZE"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get_type_from_user",
          "args": [
            "type",
            "_type",
            "sizeof(type)"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "key_get_type_from_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
          "lines": "33-48",
          "snippet": "static int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/uio.h>",
            "#include <linux/security.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEY_MAX_DESC_SIZE 4096\n\nlong keyctl_keyring_search(key_serial_t ringid,\n\t\t\t   const char __user *_type,\n\t\t\t   const char __user *_description,\n\t\t\t   key_serial_t destringid)\n{\n\tstruct key_type *ktype;\n\tkey_ref_t keyring_ref, key_ref, dest_ref;\n\tchar type[32], *description;\n\tlong ret;\n\n\t/* pull the type and description into kernel space */\n\tret = key_get_type_from_user(type, _type, sizeof(type));\n\tif (ret < 0)\n\t\tgoto error;\n\n\tdescription = strndup_user(_description, KEY_MAX_DESC_SIZE);\n\tif (IS_ERR(description)) {\n\t\tret = PTR_ERR(description);\n\t\tgoto error;\n\t}\n\n\t/* get the keyring at which to begin the search */\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error2;\n\t}\n\n\t/* get the destination keyring if specified */\n\tdest_ref = NULL;\n\tif (destringid) {\n\t\tdest_ref = lookup_user_key(destringid, KEY_LOOKUP_CREATE,\n\t\t\t\t\t   KEY_NEED_WRITE);\n\t\tif (IS_ERR(dest_ref)) {\n\t\t\tret = PTR_ERR(dest_ref);\n\t\t\tgoto error3;\n\t\t}\n\t}\n\n\t/* find the key type */\n\tktype = key_type_lookup(type);\n\tif (IS_ERR(ktype)) {\n\t\tret = PTR_ERR(ktype);\n\t\tgoto error4;\n\t}\n\n\t/* do the search */\n\tkey_ref = keyring_search(keyring_ref, ktype, description);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* treat lack or presence of a negative key the same */\n\t\tif (ret == -EAGAIN)\n\t\t\tret = -ENOKEY;\n\t\tgoto error5;\n\t}\n\n\t/* link the resulting key to the destination keyring if we can */\n\tif (dest_ref) {\n\t\tret = key_permission(key_ref, KEY_NEED_LINK);\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\n\t\tret = key_link(key_ref_to_ptr(dest_ref), key_ref_to_ptr(key_ref));\n\t\tif (ret < 0)\n\t\t\tgoto error6;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\nerror6:\n\tkey_ref_put(key_ref);\nerror5:\n\tkey_type_put(ktype);\nerror4:\n\tkey_ref_put(dest_ref);\nerror3:\n\tkey_ref_put(keyring_ref);\nerror2:\n\tkfree(description);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_describe_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "588-648",
    "snippet": "long keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\t/* viewing a key under construction is permitted if we have the\n\t\t * authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\n\t/* calculate how much information we're going to return */\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\n\t/* consider returning the data */\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "key_ref"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "infobuf"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer + infolen",
            "key->description",
            "desclen + 1"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "infobuf",
            "infolen"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "infobuf"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s;%d;%d;%08x;\"",
            "key->type->name",
            "from_kuid_munged(current_user_ns(), key->uid)",
            "from_kgid_munged(current_user_ns(), key->gid)",
            "key->perm"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "current_user_ns()",
            "key->gid"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "key->uid"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key->description"
          ],
          "line": 620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "keyid",
            "KEY_LOOKUP_PARTIAL",
            "0"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "instkey"
          ],
          "line": 605
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "instkey"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get_instantiation_authkey",
          "args": [
            "keyid"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "key_get_instantiation_authkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "234-268",
          "snippet": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void request_key_auth_revoke(struct key *);",
            "static void request_key_auth_destroy(struct key *);",
            "struct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_describe_key(key_serial_t keyid,\n\t\t\t char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tstruct key *key, *instkey;\n\tkey_ref_t key_ref;\n\tchar *infobuf;\n\tlong ret;\n\tint desclen, infolen;\n\n\tkey_ref = lookup_user_key(keyid, KEY_LOOKUP_PARTIAL, KEY_NEED_VIEW);\n\tif (IS_ERR(key_ref)) {\n\t\t/* viewing a key under construction is permitted if we have the\n\t\t * authorisation token handy */\n\t\tif (PTR_ERR(key_ref) == -EACCES) {\n\t\t\tinstkey = key_get_instantiation_authkey(keyid);\n\t\t\tif (!IS_ERR(instkey)) {\n\t\t\t\tkey_put(instkey);\n\t\t\t\tkey_ref = lookup_user_key(keyid,\n\t\t\t\t\t\t\t  KEY_LOOKUP_PARTIAL,\n\t\t\t\t\t\t\t  0);\n\t\t\t\tif (!IS_ERR(key_ref))\n\t\t\t\t\tgoto okay;\n\t\t\t}\n\t\t}\n\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\nokay:\n\tkey = key_ref_to_ptr(key_ref);\n\tdesclen = strlen(key->description);\n\n\t/* calculate how much information we're going to return */\n\tret = -ENOMEM;\n\tinfobuf = kasprintf(GFP_KERNEL,\n\t\t\t    \"%s;%d;%d;%08x;\",\n\t\t\t    key->type->name,\n\t\t\t    from_kuid_munged(current_user_ns(), key->uid),\n\t\t\t    from_kgid_munged(current_user_ns(), key->gid),\n\t\t\t    key->perm);\n\tif (!infobuf)\n\t\tgoto error2;\n\tinfolen = strlen(infobuf);\n\tret = infolen + desclen + 1;\n\n\t/* consider returning the data */\n\tif (buffer && buflen >= ret) {\n\t\tif (copy_to_user(buffer, infobuf, infolen) != 0 ||\n\t\t    copy_to_user(buffer + infolen, key->description,\n\t\t\t\t desclen + 1) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\tkfree(infobuf);\nerror2:\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_keyring_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "542-573",
    "snippet": "long keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tstruct key *keyring, *key;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_FOR_UNLINK, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags) &&\n\t    test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = key_unlink(keyring, key);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "keyring_ref"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "key_ref"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_unlink",
          "args": [
            "keyring",
            "key"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "key_unlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1406-1436",
          "snippet": "int key_unlink(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  &key->index_key);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error;\n\t}\n\tret = -ENOENT;\n\tif (edit == NULL)\n\t\tgoto error;\n\n\tassoc_array_apply_edit(edit);\n\tkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\n\tret = 0;\n\nerror:\n\tup_write(&keyring->sem);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};",
            "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nint key_unlink(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  &key->index_key);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error;\n\t}\n\tret = -ENOENT;\n\tif (edit == NULL)\n\t\tgoto error;\n\n\tassoc_array_apply_edit(edit);\n\tkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\n\tret = 0;\n\nerror:\n\tup_write(&keyring->sem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_KEEP",
            "&key->flags"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_KEEP",
            "&keyring->flags"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "keyring_ref"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "id",
            "KEY_LOOKUP_FOR_UNLINK",
            "0"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "keyring_ref"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "keyring_ref"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_keyring_unlink(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tstruct key *keyring, *key;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_FOR_UNLINK, 0);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey = key_ref_to_ptr(key_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags) &&\n\t    test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = key_unlink(keyring, key);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_keyring_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "505-529",
    "snippet": "long keyctl_keyring_link(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_NEED_LINK);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_link(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "keyring_ref"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "key_ref"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_link",
          "args": [
            "key_ref_to_ptr(keyring_ref)",
            "key_ref_to_ptr(key_ref)"
          ],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "key_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1363-1386",
          "snippet": "int key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\t\tret = __key_link_check_restriction(keyring, key);\n\t\tif (ret == 0)\n\t\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nint key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\t\tret = __key_link_check_restriction(keyring, key);\n\t\tif (ret == 0)\n\t\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "keyring_ref"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "id",
            "KEY_LOOKUP_CREATE",
            "KEY_NEED_LINK"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "keyring_ref"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "keyring_ref"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_keyring_link(key_serial_t id, key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref, key_ref;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\t\tgoto error;\n\t}\n\n\tkey_ref = lookup_user_key(id, KEY_LOOKUP_CREATE, KEY_NEED_LINK);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\tret = key_link(key_ref_to_ptr(keyring_ref), key_ref_to_ptr(key_ref));\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_keyring_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "458-492",
    "snippet": "long keyctl_keyring_clear(key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref;\n\tstruct key *keyring;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\n\t\t/* Root is permitted to invalidate certain special keyrings */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkeyring_ref = lookup_user_key(ringid, 0, 0);\n\t\t\tif (IS_ERR(keyring_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_CLEAR,\n\t\t\t\t     &key_ref_to_ptr(keyring_ref)->flags))\n\t\t\t\tgoto clear;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\nclear:\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = keyring_clear(keyring);\nerror_put:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "keyring_ref"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_clear",
          "args": [
            "keyring"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "keyctl_keyring_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
          "lines": "458-492",
          "snippet": "long keyctl_keyring_clear(key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref;\n\tstruct key *keyring;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\n\t\t/* Root is permitted to invalidate certain special keyrings */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkeyring_ref = lookup_user_key(ringid, 0, 0);\n\t\t\tif (IS_ERR(keyring_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_CLEAR,\n\t\t\t\t     &key_ref_to_ptr(keyring_ref)->flags))\n\t\t\t\tgoto clear;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\nclear:\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = keyring_clear(keyring);\nerror_put:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_KEEP",
            "&keyring->flags"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "keyring_ref"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_ROOT_CAN_CLEAR",
            "&key_ref_to_ptr(keyring_ref)->flags"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "keyring_ref"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "keyring_ref"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "ringid",
            "0",
            "0"
          ],
          "line": 470
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "keyring_ref"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "keyring_ref"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_keyring_clear(key_serial_t ringid)\n{\n\tkey_ref_t keyring_ref;\n\tstruct key *keyring;\n\tlong ret;\n\n\tkeyring_ref = lookup_user_key(ringid, KEY_LOOKUP_CREATE, KEY_NEED_WRITE);\n\tif (IS_ERR(keyring_ref)) {\n\t\tret = PTR_ERR(keyring_ref);\n\n\t\t/* Root is permitted to invalidate certain special keyrings */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkeyring_ref = lookup_user_key(ringid, 0, 0);\n\t\t\tif (IS_ERR(keyring_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_CLEAR,\n\t\t\t\t     &key_ref_to_ptr(keyring_ref)->flags))\n\t\t\t\tgoto clear;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\nclear:\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tif (test_bit(KEY_FLAG_KEEP, &keyring->flags))\n\t\tret = -EPERM;\n\telse\n\t\tret = keyring_clear(keyring);\nerror_put:\n\tkey_ref_put(keyring_ref);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_invalidate_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "411-449",
    "snippet": "long keyctl_invalidate_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkenter(\"%d\", id);\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* Root is permitted to invalidate certain special keys */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkey_ref = lookup_user_key(id, 0, 0);\n\t\t\tif (IS_ERR(key_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_INVAL,\n\t\t\t\t     &key_ref_to_ptr(key_ref)->flags))\n\t\t\t\tgoto invalidate;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\ninvalidate:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_invalidate(key);\nerror_put:\n\tkey_ref_put(key_ref);\nerror:\n\tkleave(\" = %ld\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = %ld\"",
            "ret"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "key_ref"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_invalidate",
          "args": [
            "key"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "key_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "1058-1070",
          "snippet": "void key_invalidate(struct key *key)\n{\n\tkenter(\"%d\", key_serial(key));\n\n\tkey_check(key);\n\n\tif (!test_bit(KEY_FLAG_INVALIDATED, &key->flags)) {\n\t\tdown_write_nested(&key->sem, 1);\n\t\tif (!test_and_set_bit(KEY_FLAG_INVALIDATED, &key->flags))\n\t\t\tkey_schedule_gc_links();\n\t\tup_write(&key->sem);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_invalidate(struct key *key)\n{\n\tkenter(\"%d\", key_serial(key));\n\n\tkey_check(key);\n\n\tif (!test_bit(KEY_FLAG_INVALIDATED, &key->flags)) {\n\t\tdown_write_nested(&key->sem, 1);\n\t\tif (!test_and_set_bit(KEY_FLAG_INVALIDATED, &key->flags))\n\t\t\tkey_schedule_gc_links();\n\t\tup_write(&key->sem);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_KEEP",
            "&key->flags"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_ROOT_CAN_INVAL",
            "&key_ref_to_ptr(key_ref)->flags"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "id",
            "0",
            "0"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"%d\"",
            "id"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_invalidate_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkenter(\"%d\", id);\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\n\t\t/* Root is permitted to invalidate certain special keys */\n\t\tif (capable(CAP_SYS_ADMIN)) {\n\t\t\tkey_ref = lookup_user_key(id, 0, 0);\n\t\t\tif (IS_ERR(key_ref))\n\t\t\t\tgoto error;\n\t\t\tif (test_bit(KEY_FLAG_ROOT_CAN_INVAL,\n\t\t\t\t     &key_ref_to_ptr(key_ref)->flags))\n\t\t\t\tgoto invalidate;\n\t\t\tgoto error_put;\n\t\t}\n\n\t\tgoto error;\n\t}\n\ninvalidate:\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_invalidate(key);\nerror_put:\n\tkey_ref_put(key_ref);\nerror:\n\tkleave(\" = %ld\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_revoke_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "370-398",
    "snippet": "long keyctl_revoke_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tif (ret != -EACCES)\n\t\t\tgoto error;\n\t\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\t\tif (IS_ERR(key_ref)) {\n\t\t\tret = PTR_ERR(key_ref);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_revoke(key);\n\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "key_ref"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_revoke",
          "args": [
            "key"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "key_revoke",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "1024-1048",
          "snippet": "void key_revoke(struct key *key)\n{\n\ttime64_t time;\n\n\tkey_check(key);\n\n\t/* make sure no one's trying to change or use the key when we mark it\n\t * - we tell lockdep that we might nest because we might be revoking an\n\t *   authorisation key whilst holding the sem on a key we've just\n\t *   instantiated\n\t */\n\tdown_write_nested(&key->sem, 1);\n\tif (!test_and_set_bit(KEY_FLAG_REVOKED, &key->flags) &&\n\t    key->type->revoke)\n\t\tkey->type->revoke(key);\n\n\t/* set the death time to no more than the expiry time */\n\ttime = ktime_get_real_seconds();\n\tif (key->revoked_at == 0 || key->revoked_at > time) {\n\t\tkey->revoked_at = time;\n\t\tkey_schedule_gc(key->revoked_at + key_gc_delay);\n\t}\n\n\tup_write(&key->sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_revoke(struct key *key)\n{\n\ttime64_t time;\n\n\tkey_check(key);\n\n\t/* make sure no one's trying to change or use the key when we mark it\n\t * - we tell lockdep that we might nest because we might be revoking an\n\t *   authorisation key whilst holding the sem on a key we've just\n\t *   instantiated\n\t */\n\tdown_write_nested(&key->sem, 1);\n\tif (!test_and_set_bit(KEY_FLAG_REVOKED, &key->flags) &&\n\t    key->type->revoke)\n\t\tkey->type->revoke(key);\n\n\t/* set the death time to no more than the expiry time */\n\ttime = ktime_get_real_seconds();\n\tif (key->revoked_at == 0 || key->revoked_at > time) {\n\t\tkey->revoked_at = time;\n\t\tkey_schedule_gc(key->revoked_at + key_gc_delay);\n\t}\n\n\tup_write(&key->sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_KEEP",
            "&key->flags"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "id",
            "0",
            "KEY_NEED_SETATTR"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_revoke_key(key_serial_t id)\n{\n\tkey_ref_t key_ref;\n\tstruct key *key;\n\tlong ret;\n\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tif (ret != -EACCES)\n\t\t\tgoto error;\n\t\tkey_ref = lookup_user_key(id, 0, KEY_NEED_SETATTR);\n\t\tif (IS_ERR(key_ref)) {\n\t\t\tret = PTR_ERR(key_ref);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\tret = 0;\n\tif (test_bit(KEY_FLAG_KEEP, &key->flags))\n\t\tret = -EPERM;\n\telse\n\t\tkey_revoke(key);\n\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_update_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "316-356",
    "snippet": "long keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkzfree(payload);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "payload"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "key_ref"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_update",
          "args": [
            "key_ref",
            "payload",
            "plen"
          ],
          "line": 349
        },
        "resolved": true,
        "details": {
          "function_name": "key_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "971-1012",
          "snippet": "int key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tkey_check(key);\n\n\t/* the key must be writable */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attempt to update it if supported */\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\t/* Updating a negative key positively instantiates it */\n\t\tmark_key_instantiated(key, 0);\n\n\tup_write(&key->sem);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint key_update(key_ref_t key_ref, const void *payload, size_t plen)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct key *key = key_ref_to_ptr(key_ref);\n\tint ret;\n\n\tkey_check(key);\n\n\t/* the key must be writable */\n\tret = key_permission(key_ref, KEY_NEED_WRITE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* attempt to update it if supported */\n\tif (!key->type->update)\n\t\treturn -EOPNOTSUPP;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tdown_write(&key->sem);\n\n\tret = key->type->update(key, &prep);\n\tif (ret == 0)\n\t\t/* Updating a negative key positively instantiates it */\n\t\tmark_key_instantiated(key, 0);\n\n\tup_write(&key->sem);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "id",
            "0",
            "KEY_NEED_WRITE"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "payload",
            "_payload",
            "plen"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "plen",
            "GFP_KERNEL"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_update_key(key_serial_t id,\n\t\t       const void __user *_payload,\n\t\t       size_t plen)\n{\n\tkey_ref_t key_ref;\n\tvoid *payload;\n\tlong ret;\n\n\tret = -EINVAL;\n\tif (plen > PAGE_SIZE)\n\t\tgoto error;\n\n\t/* pull the payload in if one was supplied */\n\tpayload = NULL;\n\tif (plen) {\n\t\tret = -ENOMEM;\n\t\tpayload = kmalloc(plen, GFP_KERNEL);\n\t\tif (!payload)\n\t\t\tgoto error;\n\n\t\tret = -EFAULT;\n\t\tif (copy_from_user(payload, _payload, plen) != 0)\n\t\t\tgoto error2;\n\t}\n\n\t/* find the target key (which must be writable) */\n\tkey_ref = lookup_user_key(id, 0, KEY_NEED_WRITE);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error2;\n\t}\n\n\t/* update the key */\n\tret = key_update(key_ref, payload, plen);\n\n\tkey_ref_put(key_ref);\nerror2:\n\tkzfree(payload);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_join_session_keyring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "279-304",
    "snippet": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KEY_MAX_DESC_SIZE 4096"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "name"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join_session_keyring",
          "args": [
            "name"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "keyctl_join_session_keyring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
          "lines": "279-304",
          "snippet": "long keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "name"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "name"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strndup_user",
          "args": [
            "_name",
            "KEY_MAX_DESC_SIZE"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEY_MAX_DESC_SIZE 4096\n\nlong keyctl_join_session_keyring(const char __user *_name)\n{\n\tchar *name;\n\tlong ret;\n\n\t/* fetch the name from userspace */\n\tname = NULL;\n\tif (_name) {\n\t\tname = strndup_user(_name, KEY_MAX_DESC_SIZE);\n\t\tif (IS_ERR(name)) {\n\t\t\tret = PTR_ERR(name);\n\t\t\tgoto error;\n\t\t}\n\n\t\tret = -EPERM;\n\t\tif (name[0] == '.')\n\t\t\tgoto error_name;\n\t}\n\n\t/* join the session */\n\tret = join_session_keyring(name);\nerror_name:\n\tkfree(name);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_get_keyring_ID",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "249-266",
    "snippet": "long keyctl_get_keyring_ID(key_serial_t id, int create)\n{\n\tkey_ref_t key_ref;\n\tunsigned long lflags;\n\tlong ret;\n\n\tlflags = create ? KEY_LOOKUP_CREATE : 0;\n\tkey_ref = lookup_user_key(id, lflags, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "key_ref"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key_ref"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "id",
            "lflags",
            "KEY_NEED_SEARCH"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nlong keyctl_get_keyring_ID(key_serial_t id, int create)\n{\n\tkey_ref_t key_ref;\n\tunsigned long lflags;\n\tlong ret;\n\n\tlflags = create ? KEY_LOOKUP_CREATE : 0;\n\tkey_ref = lookup_user_key(id, lflags, KEY_NEED_SEARCH);\n\tif (IS_ERR(key_ref)) {\n\t\tret = PTR_ERR(key_ref);\n\t\tgoto error;\n\t}\n\n\tret = key_ref_to_ptr(key_ref)->serial;\n\tkey_ref_put(key_ref);\nerror:\n\treturn ret;\n}"
  },
  {
    "function_name": "key_get_type_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyctl.c",
    "lines": "33-48",
    "snippet": "static int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/uio.h>",
      "#include <linux/security.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/cred.h>",
      "#include <linux/capability.h>",
      "#include <linux/fs.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "type",
            "_type",
            "len"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/uio.h>\n#include <linux/security.h>\n#include <linux/vmalloc.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/syscalls.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int key_get_type_from_user(char *type,\n\t\t\t\t  const char __user *_type,\n\t\t\t\t  unsigned len)\n{\n\tint ret;\n\n\tret = strncpy_from_user(type, _type, len);\n\tif (ret < 0)\n\t\treturn ret;\n\tif (ret == 0 || ret >= len)\n\t\treturn -EINVAL;\n\tif (type[0] == '.')\n\t\treturn -EPERM;\n\ttype[len - 1] = '\\0';\n\treturn 0;\n}"
  }
]