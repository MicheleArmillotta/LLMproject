[
  {
    "function_name": "keyctl_dh_compute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
    "lines": "422-435",
    "snippet": "long keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t       char __user *buffer, size_t buflen,\n\t\t       struct keyctl_kdf_params __user *kdf)\n{\n\tstruct keyctl_kdf_params kdfcopy;\n\n\tif (!kdf)\n\t\treturn __keyctl_dh_compute(params, buffer, buflen, NULL);\n\n\tif (copy_from_user(&kdfcopy, kdf, sizeof(kdfcopy)) != 0)\n\t\treturn -EFAULT;\n\n\treturn __keyctl_dh_compute(params, buffer, buflen, &kdfcopy);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/user-type.h>",
      "#include <crypto/dh.h>",
      "#include <crypto/kpp.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__keyctl_dh_compute",
          "args": [
            "params",
            "buffer",
            "buflen",
            "&kdfcopy"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "__keyctl_dh_compute",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
          "lines": "239-420",
          "snippet": "long __keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t char __user *buffer, size_t buflen,\n\t\t\t struct keyctl_kdf_params *kdfcopy)\n{\n\tlong ret;\n\tssize_t dlen;\n\tint secretlen;\n\tint outlen;\n\tstruct keyctl_dh_params pcopy;\n\tstruct dh dh_inputs;\n\tstruct scatterlist outsg;\n\tstruct dh_completion compl;\n\tstruct crypto_kpp *tfm;\n\tstruct kpp_request *req;\n\tuint8_t *secret;\n\tuint8_t *outbuf;\n\tstruct kdf_sdesc *sdesc = NULL;\n\n\tif (!params || (!buffer && buflen)) {\n\t\tret = -EINVAL;\n\t\tgoto out1;\n\t}\n\tif (copy_from_user(&pcopy, params, sizeof(pcopy)) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out1;\n\t}\n\n\tif (kdfcopy) {\n\t\tchar *hashname;\n\n\t\tif (memchr_inv(kdfcopy->__spare, 0, sizeof(kdfcopy->__spare))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out1;\n\t\t}\n\n\t\tif (buflen > KEYCTL_KDF_MAX_OUTPUT_LEN ||\n\t\t    kdfcopy->otherinfolen > KEYCTL_KDF_MAX_OI_LEN) {\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto out1;\n\t\t}\n\n\t\t/* get KDF name string */\n\t\thashname = strndup_user(kdfcopy->hashname, CRYPTO_MAX_ALG_NAME);\n\t\tif (IS_ERR(hashname)) {\n\t\t\tret = PTR_ERR(hashname);\n\t\t\tgoto out1;\n\t\t}\n\n\t\t/* allocate KDF from the kernel crypto API */\n\t\tret = kdf_alloc(&sdesc, hashname);\n\t\tkfree(hashname);\n\t\tif (ret)\n\t\t\tgoto out1;\n\t}\n\n\tmemset(&dh_inputs, 0, sizeof(dh_inputs));\n\n\tdlen = dh_data_from_key(pcopy.prime, &dh_inputs.p);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out1;\n\t}\n\tdh_inputs.p_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.base, &dh_inputs.g);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.g_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.private, &dh_inputs.key);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.key_size = dlen;\n\n\tsecretlen = crypto_dh_key_len(&dh_inputs);\n\tsecret = kmalloc(secretlen, GFP_KERNEL);\n\tif (!secret) {\n\t\tret = -ENOMEM;\n\t\tgoto out2;\n\t}\n\tret = crypto_dh_encode_key(secret, secretlen, &dh_inputs);\n\tif (ret)\n\t\tgoto out3;\n\n\ttfm = crypto_alloc_kpp(\"dh\", CRYPTO_ALG_TYPE_KPP, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out3;\n\t}\n\n\tret = crypto_kpp_set_secret(tfm, secret, secretlen);\n\tif (ret)\n\t\tgoto out4;\n\n\toutlen = crypto_kpp_maxsize(tfm);\n\n\tif (!kdfcopy) {\n\t\t/*\n\t\t * When not using a KDF, buflen 0 is used to read the\n\t\t * required buffer length\n\t\t */\n\t\tif (buflen == 0) {\n\t\t\tret = outlen;\n\t\t\tgoto out4;\n\t\t} else if (outlen > buflen) {\n\t\t\tret = -EOVERFLOW;\n\t\t\tgoto out4;\n\t\t}\n\t}\n\n\toutbuf = kzalloc(kdfcopy ? (outlen + kdfcopy->otherinfolen) : outlen,\n\t\t\t GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out4;\n\t}\n\n\tsg_init_one(&outsg, outbuf, outlen);\n\n\treq = kpp_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto out5;\n\t}\n\n\tkpp_request_set_input(req, NULL, 0);\n\tkpp_request_set_output(req, &outsg, outlen);\n\tinit_completion(&compl.completion);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t dh_crypto_done, &compl);\n\n\t/*\n\t * For DH, generate_public_key and generate_shared_secret are\n\t * the same calculation\n\t */\n\tret = crypto_kpp_generate_public_key(req);\n\tif (ret == -EINPROGRESS) {\n\t\twait_for_completion(&compl.completion);\n\t\tret = compl.err;\n\t\tif (ret)\n\t\t\tgoto out6;\n\t}\n\n\tif (kdfcopy) {\n\t\t/*\n\t\t * Concatenate SP800-56A otherinfo past DH shared secret -- the\n\t\t * input to the KDF is (DH shared secret || otherinfo)\n\t\t */\n\t\tif (copy_from_user(outbuf + req->dst_len, kdfcopy->otherinfo,\n\t\t\t\t   kdfcopy->otherinfolen) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out6;\n\t\t}\n\n\t\tret = keyctl_dh_compute_kdf(sdesc, buffer, buflen, outbuf,\n\t\t\t\t\t    req->dst_len + kdfcopy->otherinfolen,\n\t\t\t\t\t    outlen - req->dst_len);\n\t} else if (copy_to_user(buffer, outbuf, req->dst_len) == 0) {\n\t\tret = req->dst_len;\n\t} else {\n\t\tret = -EFAULT;\n\t}\n\nout6:\n\tkpp_request_free(req);\nout5:\n\tkzfree(outbuf);\nout4:\n\tcrypto_free_kpp(tfm);\nout3:\n\tkzfree(secret);\nout2:\n\tdh_free_data(&dh_inputs);\nout1:\n\tkdf_dealloc(sdesc);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/user-type.h>",
            "#include <crypto/dh.h>",
            "#include <crypto/kpp.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nlong __keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t char __user *buffer, size_t buflen,\n\t\t\t struct keyctl_kdf_params *kdfcopy)\n{\n\tlong ret;\n\tssize_t dlen;\n\tint secretlen;\n\tint outlen;\n\tstruct keyctl_dh_params pcopy;\n\tstruct dh dh_inputs;\n\tstruct scatterlist outsg;\n\tstruct dh_completion compl;\n\tstruct crypto_kpp *tfm;\n\tstruct kpp_request *req;\n\tuint8_t *secret;\n\tuint8_t *outbuf;\n\tstruct kdf_sdesc *sdesc = NULL;\n\n\tif (!params || (!buffer && buflen)) {\n\t\tret = -EINVAL;\n\t\tgoto out1;\n\t}\n\tif (copy_from_user(&pcopy, params, sizeof(pcopy)) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out1;\n\t}\n\n\tif (kdfcopy) {\n\t\tchar *hashname;\n\n\t\tif (memchr_inv(kdfcopy->__spare, 0, sizeof(kdfcopy->__spare))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out1;\n\t\t}\n\n\t\tif (buflen > KEYCTL_KDF_MAX_OUTPUT_LEN ||\n\t\t    kdfcopy->otherinfolen > KEYCTL_KDF_MAX_OI_LEN) {\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto out1;\n\t\t}\n\n\t\t/* get KDF name string */\n\t\thashname = strndup_user(kdfcopy->hashname, CRYPTO_MAX_ALG_NAME);\n\t\tif (IS_ERR(hashname)) {\n\t\t\tret = PTR_ERR(hashname);\n\t\t\tgoto out1;\n\t\t}\n\n\t\t/* allocate KDF from the kernel crypto API */\n\t\tret = kdf_alloc(&sdesc, hashname);\n\t\tkfree(hashname);\n\t\tif (ret)\n\t\t\tgoto out1;\n\t}\n\n\tmemset(&dh_inputs, 0, sizeof(dh_inputs));\n\n\tdlen = dh_data_from_key(pcopy.prime, &dh_inputs.p);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out1;\n\t}\n\tdh_inputs.p_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.base, &dh_inputs.g);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.g_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.private, &dh_inputs.key);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.key_size = dlen;\n\n\tsecretlen = crypto_dh_key_len(&dh_inputs);\n\tsecret = kmalloc(secretlen, GFP_KERNEL);\n\tif (!secret) {\n\t\tret = -ENOMEM;\n\t\tgoto out2;\n\t}\n\tret = crypto_dh_encode_key(secret, secretlen, &dh_inputs);\n\tif (ret)\n\t\tgoto out3;\n\n\ttfm = crypto_alloc_kpp(\"dh\", CRYPTO_ALG_TYPE_KPP, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out3;\n\t}\n\n\tret = crypto_kpp_set_secret(tfm, secret, secretlen);\n\tif (ret)\n\t\tgoto out4;\n\n\toutlen = crypto_kpp_maxsize(tfm);\n\n\tif (!kdfcopy) {\n\t\t/*\n\t\t * When not using a KDF, buflen 0 is used to read the\n\t\t * required buffer length\n\t\t */\n\t\tif (buflen == 0) {\n\t\t\tret = outlen;\n\t\t\tgoto out4;\n\t\t} else if (outlen > buflen) {\n\t\t\tret = -EOVERFLOW;\n\t\t\tgoto out4;\n\t\t}\n\t}\n\n\toutbuf = kzalloc(kdfcopy ? (outlen + kdfcopy->otherinfolen) : outlen,\n\t\t\t GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out4;\n\t}\n\n\tsg_init_one(&outsg, outbuf, outlen);\n\n\treq = kpp_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto out5;\n\t}\n\n\tkpp_request_set_input(req, NULL, 0);\n\tkpp_request_set_output(req, &outsg, outlen);\n\tinit_completion(&compl.completion);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t dh_crypto_done, &compl);\n\n\t/*\n\t * For DH, generate_public_key and generate_shared_secret are\n\t * the same calculation\n\t */\n\tret = crypto_kpp_generate_public_key(req);\n\tif (ret == -EINPROGRESS) {\n\t\twait_for_completion(&compl.completion);\n\t\tret = compl.err;\n\t\tif (ret)\n\t\t\tgoto out6;\n\t}\n\n\tif (kdfcopy) {\n\t\t/*\n\t\t * Concatenate SP800-56A otherinfo past DH shared secret -- the\n\t\t * input to the KDF is (DH shared secret || otherinfo)\n\t\t */\n\t\tif (copy_from_user(outbuf + req->dst_len, kdfcopy->otherinfo,\n\t\t\t\t   kdfcopy->otherinfolen) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out6;\n\t\t}\n\n\t\tret = keyctl_dh_compute_kdf(sdesc, buffer, buflen, outbuf,\n\t\t\t\t\t    req->dst_len + kdfcopy->otherinfolen,\n\t\t\t\t\t    outlen - req->dst_len);\n\t} else if (copy_to_user(buffer, outbuf, req->dst_len) == 0) {\n\t\tret = req->dst_len;\n\t} else {\n\t\tret = -EFAULT;\n\t}\n\nout6:\n\tkpp_request_free(req);\nout5:\n\tkzfree(outbuf);\nout4:\n\tcrypto_free_kpp(tfm);\nout3:\n\tkzfree(secret);\nout2:\n\tdh_free_data(&dh_inputs);\nout1:\n\tkdf_dealloc(sdesc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&kdfcopy",
            "kdf",
            "sizeof(kdfcopy)"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nlong keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t       char __user *buffer, size_t buflen,\n\t\t       struct keyctl_kdf_params __user *kdf)\n{\n\tstruct keyctl_kdf_params kdfcopy;\n\n\tif (!kdf)\n\t\treturn __keyctl_dh_compute(params, buffer, buflen, NULL);\n\n\tif (copy_from_user(&kdfcopy, kdf, sizeof(kdfcopy)) != 0)\n\t\treturn -EFAULT;\n\n\treturn __keyctl_dh_compute(params, buffer, buflen, &kdfcopy);\n}"
  },
  {
    "function_name": "__keyctl_dh_compute",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
    "lines": "239-420",
    "snippet": "long __keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t char __user *buffer, size_t buflen,\n\t\t\t struct keyctl_kdf_params *kdfcopy)\n{\n\tlong ret;\n\tssize_t dlen;\n\tint secretlen;\n\tint outlen;\n\tstruct keyctl_dh_params pcopy;\n\tstruct dh dh_inputs;\n\tstruct scatterlist outsg;\n\tstruct dh_completion compl;\n\tstruct crypto_kpp *tfm;\n\tstruct kpp_request *req;\n\tuint8_t *secret;\n\tuint8_t *outbuf;\n\tstruct kdf_sdesc *sdesc = NULL;\n\n\tif (!params || (!buffer && buflen)) {\n\t\tret = -EINVAL;\n\t\tgoto out1;\n\t}\n\tif (copy_from_user(&pcopy, params, sizeof(pcopy)) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out1;\n\t}\n\n\tif (kdfcopy) {\n\t\tchar *hashname;\n\n\t\tif (memchr_inv(kdfcopy->__spare, 0, sizeof(kdfcopy->__spare))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out1;\n\t\t}\n\n\t\tif (buflen > KEYCTL_KDF_MAX_OUTPUT_LEN ||\n\t\t    kdfcopy->otherinfolen > KEYCTL_KDF_MAX_OI_LEN) {\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto out1;\n\t\t}\n\n\t\t/* get KDF name string */\n\t\thashname = strndup_user(kdfcopy->hashname, CRYPTO_MAX_ALG_NAME);\n\t\tif (IS_ERR(hashname)) {\n\t\t\tret = PTR_ERR(hashname);\n\t\t\tgoto out1;\n\t\t}\n\n\t\t/* allocate KDF from the kernel crypto API */\n\t\tret = kdf_alloc(&sdesc, hashname);\n\t\tkfree(hashname);\n\t\tif (ret)\n\t\t\tgoto out1;\n\t}\n\n\tmemset(&dh_inputs, 0, sizeof(dh_inputs));\n\n\tdlen = dh_data_from_key(pcopy.prime, &dh_inputs.p);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out1;\n\t}\n\tdh_inputs.p_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.base, &dh_inputs.g);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.g_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.private, &dh_inputs.key);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.key_size = dlen;\n\n\tsecretlen = crypto_dh_key_len(&dh_inputs);\n\tsecret = kmalloc(secretlen, GFP_KERNEL);\n\tif (!secret) {\n\t\tret = -ENOMEM;\n\t\tgoto out2;\n\t}\n\tret = crypto_dh_encode_key(secret, secretlen, &dh_inputs);\n\tif (ret)\n\t\tgoto out3;\n\n\ttfm = crypto_alloc_kpp(\"dh\", CRYPTO_ALG_TYPE_KPP, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out3;\n\t}\n\n\tret = crypto_kpp_set_secret(tfm, secret, secretlen);\n\tif (ret)\n\t\tgoto out4;\n\n\toutlen = crypto_kpp_maxsize(tfm);\n\n\tif (!kdfcopy) {\n\t\t/*\n\t\t * When not using a KDF, buflen 0 is used to read the\n\t\t * required buffer length\n\t\t */\n\t\tif (buflen == 0) {\n\t\t\tret = outlen;\n\t\t\tgoto out4;\n\t\t} else if (outlen > buflen) {\n\t\t\tret = -EOVERFLOW;\n\t\t\tgoto out4;\n\t\t}\n\t}\n\n\toutbuf = kzalloc(kdfcopy ? (outlen + kdfcopy->otherinfolen) : outlen,\n\t\t\t GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out4;\n\t}\n\n\tsg_init_one(&outsg, outbuf, outlen);\n\n\treq = kpp_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto out5;\n\t}\n\n\tkpp_request_set_input(req, NULL, 0);\n\tkpp_request_set_output(req, &outsg, outlen);\n\tinit_completion(&compl.completion);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t dh_crypto_done, &compl);\n\n\t/*\n\t * For DH, generate_public_key and generate_shared_secret are\n\t * the same calculation\n\t */\n\tret = crypto_kpp_generate_public_key(req);\n\tif (ret == -EINPROGRESS) {\n\t\twait_for_completion(&compl.completion);\n\t\tret = compl.err;\n\t\tif (ret)\n\t\t\tgoto out6;\n\t}\n\n\tif (kdfcopy) {\n\t\t/*\n\t\t * Concatenate SP800-56A otherinfo past DH shared secret -- the\n\t\t * input to the KDF is (DH shared secret || otherinfo)\n\t\t */\n\t\tif (copy_from_user(outbuf + req->dst_len, kdfcopy->otherinfo,\n\t\t\t\t   kdfcopy->otherinfolen) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out6;\n\t\t}\n\n\t\tret = keyctl_dh_compute_kdf(sdesc, buffer, buflen, outbuf,\n\t\t\t\t\t    req->dst_len + kdfcopy->otherinfolen,\n\t\t\t\t\t    outlen - req->dst_len);\n\t} else if (copy_to_user(buffer, outbuf, req->dst_len) == 0) {\n\t\tret = req->dst_len;\n\t} else {\n\t\tret = -EFAULT;\n\t}\n\nout6:\n\tkpp_request_free(req);\nout5:\n\tkzfree(outbuf);\nout4:\n\tcrypto_free_kpp(tfm);\nout3:\n\tkzfree(secret);\nout2:\n\tdh_free_data(&dh_inputs);\nout1:\n\tkdf_dealloc(sdesc);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/user-type.h>",
      "#include <crypto/dh.h>",
      "#include <crypto/kpp.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdf_dealloc",
          "args": [
            "sdesc"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "kdf_dealloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
          "lines": "126-135",
          "snippet": "static void kdf_dealloc(struct kdf_sdesc *sdesc)\n{\n\tif (!sdesc)\n\t\treturn;\n\n\tif (sdesc->shash.tfm)\n\t\tcrypto_free_shash(sdesc->shash.tfm);\n\n\tkzfree(sdesc);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/user-type.h>",
            "#include <crypto/dh.h>",
            "#include <crypto/kpp.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic void kdf_dealloc(struct kdf_sdesc *sdesc)\n{\n\tif (!sdesc)\n\t\treturn;\n\n\tif (sdesc->shash.tfm)\n\t\tcrypto_free_shash(sdesc->shash.tfm);\n\n\tkzfree(sdesc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dh_free_data",
          "args": [
            "&dh_inputs"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "dh_free_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
          "lines": "63-68",
          "snippet": "static void dh_free_data(struct dh *dh)\n{\n\tkzfree(dh->key);\n\tkzfree(dh->p);\n\tkzfree(dh->g);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/user-type.h>",
            "#include <crypto/dh.h>",
            "#include <crypto/kpp.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic void dh_free_data(struct dh *dh)\n{\n\tkzfree(dh->key);\n\tkzfree(dh->p);\n\tkzfree(dh->g);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "secret"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_kpp",
          "args": [
            "tfm"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "outbuf"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kpp_request_free",
          "args": [
            "req"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "outbuf",
            "req->dst_len"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyctl_dh_compute_kdf",
          "args": [
            "sdesc",
            "buffer",
            "buflen",
            "outbuf",
            "req->dst_len + kdfcopy->otherinfolen",
            "outlen - req->dst_len"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "keyctl_dh_compute_kdf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
          "lines": "213-237",
          "snippet": "static int keyctl_dh_compute_kdf(struct kdf_sdesc *sdesc,\n\t\t\t\t char __user *buffer, size_t buflen,\n\t\t\t\t uint8_t *kbuf, size_t kbuflen, size_t lzero)\n{\n\tuint8_t *outbuf = NULL;\n\tint ret;\n\n\toutbuf = kmalloc(buflen, GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = kdf_ctr(sdesc, kbuf, kbuflen, outbuf, buflen, lzero);\n\tif (ret)\n\t\tgoto err;\n\n\tret = buflen;\n\tif (copy_to_user(buffer, outbuf, buflen) != 0)\n\t\tret = -EFAULT;\n\nerr:\n\tkzfree(outbuf);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/user-type.h>",
            "#include <crypto/dh.h>",
            "#include <crypto/kpp.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic int keyctl_dh_compute_kdf(struct kdf_sdesc *sdesc,\n\t\t\t\t char __user *buffer, size_t buflen,\n\t\t\t\t uint8_t *kbuf, size_t kbuflen, size_t lzero)\n{\n\tuint8_t *outbuf = NULL;\n\tint ret;\n\n\toutbuf = kmalloc(buflen, GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = kdf_ctr(sdesc, kbuf, kbuflen, outbuf, buflen, lzero);\n\tif (ret)\n\t\tgoto err;\n\n\tret = buflen;\n\tif (copy_to_user(buffer, outbuf, buflen) != 0)\n\t\tret = -EFAULT;\n\nerr:\n\tkzfree(outbuf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "outbuf + req->dst_len",
            "kdfcopy->otherinfo",
            "kdfcopy->otherinfolen"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&compl.completion"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_kpp_generate_public_key",
          "args": [
            "req"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kpp_request_set_callback",
          "args": [
            "req",
            "CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t CRYPTO_TFM_REQ_MAY_SLEEP",
            "dh_crypto_done",
            "&compl"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&compl.completion"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kpp_request_set_output",
          "args": [
            "req",
            "&outsg",
            "outlen"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kpp_request_set_input",
          "args": [
            "req",
            "NULL",
            "0"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kpp_request_alloc",
          "args": [
            "tfm",
            "GFP_KERNEL"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_one",
          "args": [
            "&outsg",
            "outbuf",
            "outlen"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "kdfcopy ? (outlen + kdfcopy->otherinfolen) : outlen",
            "GFP_KERNEL"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_kpp_maxsize",
          "args": [
            "tfm"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_kpp_set_secret",
          "args": [
            "tfm",
            "secret",
            "secretlen"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_kpp",
          "args": [
            "\"dh\"",
            "CRYPTO_ALG_TYPE_KPP",
            "0"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_dh_encode_key",
          "args": [
            "secret",
            "secretlen",
            "&dh_inputs"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "secretlen",
            "GFP_KERNEL"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_dh_key_len",
          "args": [
            "&dh_inputs"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dh_data_from_key",
          "args": [
            "pcopy.private",
            "&dh_inputs.key"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "dh_data_from_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
          "lines": "21-61",
          "snippet": "static ssize_t dh_data_from_key(key_serial_t keyid, void **data)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong status;\n\tssize_t ret;\n\n\tkey_ref = lookup_user_key(keyid, 0, KEY_NEED_READ);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tret = -EOPNOTSUPP;\n\tif (key->type == &key_type_user) {\n\t\tdown_read(&key->sem);\n\t\tstatus = key_validate(key);\n\t\tif (status == 0) {\n\t\t\tconst struct user_key_payload *payload;\n\t\t\tuint8_t *duplicate;\n\n\t\t\tpayload = user_key_payload_locked(key);\n\n\t\t\tduplicate = kmemdup(payload->data, payload->datalen,\n\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (duplicate) {\n\t\t\t\t*data = duplicate;\n\t\t\t\tret = payload->datalen;\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tup_read(&key->sem);\n\t}\n\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/user-type.h>",
            "#include <crypto/dh.h>",
            "#include <crypto/kpp.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic ssize_t dh_data_from_key(key_serial_t keyid, void **data)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong status;\n\tssize_t ret;\n\n\tkey_ref = lookup_user_key(keyid, 0, KEY_NEED_READ);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tret = -EOPNOTSUPP;\n\tif (key->type == &key_type_user) {\n\t\tdown_read(&key->sem);\n\t\tstatus = key_validate(key);\n\t\tif (status == 0) {\n\t\t\tconst struct user_key_payload *payload;\n\t\t\tuint8_t *duplicate;\n\n\t\t\tpayload = user_key_payload_locked(key);\n\n\t\t\tduplicate = kmemdup(payload->data, payload->datalen,\n\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (duplicate) {\n\t\t\t\t*data = duplicate;\n\t\t\t\tret = payload->datalen;\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tup_read(&key->sem);\n\t}\n\n\tkey_put(key);\nerror:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&dh_inputs",
            "0",
            "sizeof(dh_inputs)"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hashname"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdf_alloc",
          "args": [
            "&sdesc",
            "hashname"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "kdf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
          "lines": "91-124",
          "snippet": "static int kdf_alloc(struct kdf_sdesc **sdesc_ret, char *hashname)\n{\n\tstruct crypto_shash *tfm;\n\tstruct kdf_sdesc *sdesc;\n\tint size;\n\tint err;\n\n\t/* allocate synchronous hash */\n\ttfm = crypto_alloc_shash(hashname, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tpr_info(\"could not allocate digest TFM handle %s\\n\", hashname);\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = -EINVAL;\n\tif (crypto_shash_digestsize(tfm) == 0)\n\t\tgoto out_free_tfm;\n\n\terr = -ENOMEM;\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(tfm);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\tgoto out_free_tfm;\n\tsdesc->shash.tfm = tfm;\n\tsdesc->shash.flags = 0x0;\n\n\t*sdesc_ret = sdesc;\n\n\treturn 0;\n\nout_free_tfm:\n\tcrypto_free_shash(tfm);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/user-type.h>",
            "#include <crypto/dh.h>",
            "#include <crypto/kpp.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic int kdf_alloc(struct kdf_sdesc **sdesc_ret, char *hashname)\n{\n\tstruct crypto_shash *tfm;\n\tstruct kdf_sdesc *sdesc;\n\tint size;\n\tint err;\n\n\t/* allocate synchronous hash */\n\ttfm = crypto_alloc_shash(hashname, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tpr_info(\"could not allocate digest TFM handle %s\\n\", hashname);\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = -EINVAL;\n\tif (crypto_shash_digestsize(tfm) == 0)\n\t\tgoto out_free_tfm;\n\n\terr = -ENOMEM;\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(tfm);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\tgoto out_free_tfm;\n\tsdesc->shash.tfm = tfm;\n\tsdesc->shash.flags = 0x0;\n\n\t*sdesc_ret = sdesc;\n\n\treturn 0;\n\nout_free_tfm:\n\tcrypto_free_shash(tfm);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hashname"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hashname"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strndup_user",
          "args": [
            "kdfcopy->hashname",
            "CRYPTO_MAX_ALG_NAME"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr_inv",
          "args": [
            "kdfcopy->__spare",
            "0",
            "sizeof(kdfcopy->__spare)"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&pcopy",
            "params",
            "sizeof(pcopy)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nlong __keyctl_dh_compute(struct keyctl_dh_params __user *params,\n\t\t\t char __user *buffer, size_t buflen,\n\t\t\t struct keyctl_kdf_params *kdfcopy)\n{\n\tlong ret;\n\tssize_t dlen;\n\tint secretlen;\n\tint outlen;\n\tstruct keyctl_dh_params pcopy;\n\tstruct dh dh_inputs;\n\tstruct scatterlist outsg;\n\tstruct dh_completion compl;\n\tstruct crypto_kpp *tfm;\n\tstruct kpp_request *req;\n\tuint8_t *secret;\n\tuint8_t *outbuf;\n\tstruct kdf_sdesc *sdesc = NULL;\n\n\tif (!params || (!buffer && buflen)) {\n\t\tret = -EINVAL;\n\t\tgoto out1;\n\t}\n\tif (copy_from_user(&pcopy, params, sizeof(pcopy)) != 0) {\n\t\tret = -EFAULT;\n\t\tgoto out1;\n\t}\n\n\tif (kdfcopy) {\n\t\tchar *hashname;\n\n\t\tif (memchr_inv(kdfcopy->__spare, 0, sizeof(kdfcopy->__spare))) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out1;\n\t\t}\n\n\t\tif (buflen > KEYCTL_KDF_MAX_OUTPUT_LEN ||\n\t\t    kdfcopy->otherinfolen > KEYCTL_KDF_MAX_OI_LEN) {\n\t\t\tret = -EMSGSIZE;\n\t\t\tgoto out1;\n\t\t}\n\n\t\t/* get KDF name string */\n\t\thashname = strndup_user(kdfcopy->hashname, CRYPTO_MAX_ALG_NAME);\n\t\tif (IS_ERR(hashname)) {\n\t\t\tret = PTR_ERR(hashname);\n\t\t\tgoto out1;\n\t\t}\n\n\t\t/* allocate KDF from the kernel crypto API */\n\t\tret = kdf_alloc(&sdesc, hashname);\n\t\tkfree(hashname);\n\t\tif (ret)\n\t\t\tgoto out1;\n\t}\n\n\tmemset(&dh_inputs, 0, sizeof(dh_inputs));\n\n\tdlen = dh_data_from_key(pcopy.prime, &dh_inputs.p);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out1;\n\t}\n\tdh_inputs.p_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.base, &dh_inputs.g);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.g_size = dlen;\n\n\tdlen = dh_data_from_key(pcopy.private, &dh_inputs.key);\n\tif (dlen < 0) {\n\t\tret = dlen;\n\t\tgoto out2;\n\t}\n\tdh_inputs.key_size = dlen;\n\n\tsecretlen = crypto_dh_key_len(&dh_inputs);\n\tsecret = kmalloc(secretlen, GFP_KERNEL);\n\tif (!secret) {\n\t\tret = -ENOMEM;\n\t\tgoto out2;\n\t}\n\tret = crypto_dh_encode_key(secret, secretlen, &dh_inputs);\n\tif (ret)\n\t\tgoto out3;\n\n\ttfm = crypto_alloc_kpp(\"dh\", CRYPTO_ALG_TYPE_KPP, 0);\n\tif (IS_ERR(tfm)) {\n\t\tret = PTR_ERR(tfm);\n\t\tgoto out3;\n\t}\n\n\tret = crypto_kpp_set_secret(tfm, secret, secretlen);\n\tif (ret)\n\t\tgoto out4;\n\n\toutlen = crypto_kpp_maxsize(tfm);\n\n\tif (!kdfcopy) {\n\t\t/*\n\t\t * When not using a KDF, buflen 0 is used to read the\n\t\t * required buffer length\n\t\t */\n\t\tif (buflen == 0) {\n\t\t\tret = outlen;\n\t\t\tgoto out4;\n\t\t} else if (outlen > buflen) {\n\t\t\tret = -EOVERFLOW;\n\t\t\tgoto out4;\n\t\t}\n\t}\n\n\toutbuf = kzalloc(kdfcopy ? (outlen + kdfcopy->otherinfolen) : outlen,\n\t\t\t GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto out4;\n\t}\n\n\tsg_init_one(&outsg, outbuf, outlen);\n\n\treq = kpp_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tret = -ENOMEM;\n\t\tgoto out5;\n\t}\n\n\tkpp_request_set_input(req, NULL, 0);\n\tkpp_request_set_output(req, &outsg, outlen);\n\tinit_completion(&compl.completion);\n\tkpp_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t dh_crypto_done, &compl);\n\n\t/*\n\t * For DH, generate_public_key and generate_shared_secret are\n\t * the same calculation\n\t */\n\tret = crypto_kpp_generate_public_key(req);\n\tif (ret == -EINPROGRESS) {\n\t\twait_for_completion(&compl.completion);\n\t\tret = compl.err;\n\t\tif (ret)\n\t\t\tgoto out6;\n\t}\n\n\tif (kdfcopy) {\n\t\t/*\n\t\t * Concatenate SP800-56A otherinfo past DH shared secret -- the\n\t\t * input to the KDF is (DH shared secret || otherinfo)\n\t\t */\n\t\tif (copy_from_user(outbuf + req->dst_len, kdfcopy->otherinfo,\n\t\t\t\t   kdfcopy->otherinfolen) != 0) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out6;\n\t\t}\n\n\t\tret = keyctl_dh_compute_kdf(sdesc, buffer, buflen, outbuf,\n\t\t\t\t\t    req->dst_len + kdfcopy->otherinfolen,\n\t\t\t\t\t    outlen - req->dst_len);\n\t} else if (copy_to_user(buffer, outbuf, req->dst_len) == 0) {\n\t\tret = req->dst_len;\n\t} else {\n\t\tret = -EFAULT;\n\t}\n\nout6:\n\tkpp_request_free(req);\nout5:\n\tkzfree(outbuf);\nout4:\n\tcrypto_free_kpp(tfm);\nout3:\n\tkzfree(secret);\nout2:\n\tdh_free_data(&dh_inputs);\nout1:\n\tkdf_dealloc(sdesc);\n\treturn ret;\n}"
  },
  {
    "function_name": "keyctl_dh_compute_kdf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
    "lines": "213-237",
    "snippet": "static int keyctl_dh_compute_kdf(struct kdf_sdesc *sdesc,\n\t\t\t\t char __user *buffer, size_t buflen,\n\t\t\t\t uint8_t *kbuf, size_t kbuflen, size_t lzero)\n{\n\tuint8_t *outbuf = NULL;\n\tint ret;\n\n\toutbuf = kmalloc(buflen, GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = kdf_ctr(sdesc, kbuf, kbuflen, outbuf, buflen, lzero);\n\tif (ret)\n\t\tgoto err;\n\n\tret = buflen;\n\tif (copy_to_user(buffer, outbuf, buflen) != 0)\n\t\tret = -EFAULT;\n\nerr:\n\tkzfree(outbuf);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/user-type.h>",
      "#include <crypto/dh.h>",
      "#include <crypto/kpp.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "outbuf"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "outbuf",
            "buflen"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdf_ctr",
          "args": [
            "sdesc",
            "kbuf",
            "kbuflen",
            "outbuf",
            "buflen",
            "lzero"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "kdf_ctr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
          "lines": "146-211",
          "snippet": "static int kdf_ctr(struct kdf_sdesc *sdesc, const u8 *src, unsigned int slen,\n\t\t   u8 *dst, unsigned int dlen, unsigned int zlen)\n{\n\tstruct shash_desc *desc = &sdesc->shash;\n\tunsigned int h = crypto_shash_digestsize(desc->tfm);\n\tint err = 0;\n\tu8 *dst_orig = dst;\n\t__be32 counter = cpu_to_be32(1);\n\n\twhile (dlen) {\n\t\terr = crypto_shash_init(desc);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\terr = crypto_shash_update(desc, (u8 *)&counter, sizeof(__be32));\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tif (zlen && h) {\n\t\t\tu8 tmpbuffer[h];\n\t\t\tsize_t chunk = min_t(size_t, zlen, h);\n\t\t\tmemset(tmpbuffer, 0, chunk);\n\n\t\t\tdo {\n\t\t\t\terr = crypto_shash_update(desc, tmpbuffer,\n\t\t\t\t\t\t\t  chunk);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tzlen -= chunk;\n\t\t\t\tchunk = min_t(size_t, zlen, h);\n\t\t\t} while (zlen);\n\t\t}\n\n\t\tif (src && slen) {\n\t\t\terr = crypto_shash_update(desc, src, slen);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tif (dlen < h) {\n\t\t\tu8 tmpbuffer[h];\n\n\t\t\terr = crypto_shash_final(desc, tmpbuffer);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\tmemcpy(dst, tmpbuffer, dlen);\n\t\t\tmemzero_explicit(tmpbuffer, h);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\terr = crypto_shash_final(desc, dst);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tdlen -= h;\n\t\t\tdst += h;\n\t\t\tcounter = cpu_to_be32(be32_to_cpu(counter) + 1);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tmemzero_explicit(dst_orig, dlen);\n\treturn err;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <keys/user-type.h>",
            "#include <crypto/dh.h>",
            "#include <crypto/kpp.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic int kdf_ctr(struct kdf_sdesc *sdesc, const u8 *src, unsigned int slen,\n\t\t   u8 *dst, unsigned int dlen, unsigned int zlen)\n{\n\tstruct shash_desc *desc = &sdesc->shash;\n\tunsigned int h = crypto_shash_digestsize(desc->tfm);\n\tint err = 0;\n\tu8 *dst_orig = dst;\n\t__be32 counter = cpu_to_be32(1);\n\n\twhile (dlen) {\n\t\terr = crypto_shash_init(desc);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\terr = crypto_shash_update(desc, (u8 *)&counter, sizeof(__be32));\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tif (zlen && h) {\n\t\t\tu8 tmpbuffer[h];\n\t\t\tsize_t chunk = min_t(size_t, zlen, h);\n\t\t\tmemset(tmpbuffer, 0, chunk);\n\n\t\t\tdo {\n\t\t\t\terr = crypto_shash_update(desc, tmpbuffer,\n\t\t\t\t\t\t\t  chunk);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tzlen -= chunk;\n\t\t\t\tchunk = min_t(size_t, zlen, h);\n\t\t\t} while (zlen);\n\t\t}\n\n\t\tif (src && slen) {\n\t\t\terr = crypto_shash_update(desc, src, slen);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tif (dlen < h) {\n\t\t\tu8 tmpbuffer[h];\n\n\t\t\terr = crypto_shash_final(desc, tmpbuffer);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\tmemcpy(dst, tmpbuffer, dlen);\n\t\t\tmemzero_explicit(tmpbuffer, h);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\terr = crypto_shash_final(desc, dst);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tdlen -= h;\n\t\t\tdst += h;\n\t\t\tcounter = cpu_to_be32(be32_to_cpu(counter) + 1);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tmemzero_explicit(dst_orig, dlen);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "buflen",
            "GFP_KERNEL"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic int keyctl_dh_compute_kdf(struct kdf_sdesc *sdesc,\n\t\t\t\t char __user *buffer, size_t buflen,\n\t\t\t\t uint8_t *kbuf, size_t kbuflen, size_t lzero)\n{\n\tuint8_t *outbuf = NULL;\n\tint ret;\n\n\toutbuf = kmalloc(buflen, GFP_KERNEL);\n\tif (!outbuf) {\n\t\tret = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tret = kdf_ctr(sdesc, kbuf, kbuflen, outbuf, buflen, lzero);\n\tif (ret)\n\t\tgoto err;\n\n\tret = buflen;\n\tif (copy_to_user(buffer, outbuf, buflen) != 0)\n\t\tret = -EFAULT;\n\nerr:\n\tkzfree(outbuf);\n\treturn ret;\n}"
  },
  {
    "function_name": "kdf_ctr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
    "lines": "146-211",
    "snippet": "static int kdf_ctr(struct kdf_sdesc *sdesc, const u8 *src, unsigned int slen,\n\t\t   u8 *dst, unsigned int dlen, unsigned int zlen)\n{\n\tstruct shash_desc *desc = &sdesc->shash;\n\tunsigned int h = crypto_shash_digestsize(desc->tfm);\n\tint err = 0;\n\tu8 *dst_orig = dst;\n\t__be32 counter = cpu_to_be32(1);\n\n\twhile (dlen) {\n\t\terr = crypto_shash_init(desc);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\terr = crypto_shash_update(desc, (u8 *)&counter, sizeof(__be32));\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tif (zlen && h) {\n\t\t\tu8 tmpbuffer[h];\n\t\t\tsize_t chunk = min_t(size_t, zlen, h);\n\t\t\tmemset(tmpbuffer, 0, chunk);\n\n\t\t\tdo {\n\t\t\t\terr = crypto_shash_update(desc, tmpbuffer,\n\t\t\t\t\t\t\t  chunk);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tzlen -= chunk;\n\t\t\t\tchunk = min_t(size_t, zlen, h);\n\t\t\t} while (zlen);\n\t\t}\n\n\t\tif (src && slen) {\n\t\t\terr = crypto_shash_update(desc, src, slen);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tif (dlen < h) {\n\t\t\tu8 tmpbuffer[h];\n\n\t\t\terr = crypto_shash_final(desc, tmpbuffer);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\tmemcpy(dst, tmpbuffer, dlen);\n\t\t\tmemzero_explicit(tmpbuffer, h);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\terr = crypto_shash_final(desc, dst);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tdlen -= h;\n\t\t\tdst += h;\n\t\t\tcounter = cpu_to_be32(be32_to_cpu(counter) + 1);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tmemzero_explicit(dst_orig, dlen);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/user-type.h>",
      "#include <crypto/dh.h>",
      "#include <crypto/kpp.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memzero_explicit",
          "args": [
            "dst_orig",
            "dlen"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "be32_to_cpu(counter) + 1"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "counter"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "desc",
            "dst"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memzero_explicit",
          "args": [
            "tmpbuffer",
            "h"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst",
            "tmpbuffer",
            "dlen"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "desc",
            "tmpbuffer"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "desc",
            "src",
            "slen"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "zlen",
            "h"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "desc",
            "tmpbuffer",
            "chunk"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "tmpbuffer",
            "0",
            "chunk"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "size_t",
            "zlen",
            "h"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "desc",
            "(u8 *)&counter",
            "sizeof(__be32)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "desc"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_be32",
          "args": [
            "1"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_digestsize",
          "args": [
            "desc->tfm"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic int kdf_ctr(struct kdf_sdesc *sdesc, const u8 *src, unsigned int slen,\n\t\t   u8 *dst, unsigned int dlen, unsigned int zlen)\n{\n\tstruct shash_desc *desc = &sdesc->shash;\n\tunsigned int h = crypto_shash_digestsize(desc->tfm);\n\tint err = 0;\n\tu8 *dst_orig = dst;\n\t__be32 counter = cpu_to_be32(1);\n\n\twhile (dlen) {\n\t\terr = crypto_shash_init(desc);\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\terr = crypto_shash_update(desc, (u8 *)&counter, sizeof(__be32));\n\t\tif (err)\n\t\t\tgoto err;\n\n\t\tif (zlen && h) {\n\t\t\tu8 tmpbuffer[h];\n\t\t\tsize_t chunk = min_t(size_t, zlen, h);\n\t\t\tmemset(tmpbuffer, 0, chunk);\n\n\t\t\tdo {\n\t\t\t\terr = crypto_shash_update(desc, tmpbuffer,\n\t\t\t\t\t\t\t  chunk);\n\t\t\t\tif (err)\n\t\t\t\t\tgoto err;\n\n\t\t\t\tzlen -= chunk;\n\t\t\t\tchunk = min_t(size_t, zlen, h);\n\t\t\t} while (zlen);\n\t\t}\n\n\t\tif (src && slen) {\n\t\t\terr = crypto_shash_update(desc, src, slen);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t}\n\n\t\tif (dlen < h) {\n\t\t\tu8 tmpbuffer[h];\n\n\t\t\terr = crypto_shash_final(desc, tmpbuffer);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\t\t\tmemcpy(dst, tmpbuffer, dlen);\n\t\t\tmemzero_explicit(tmpbuffer, h);\n\t\t\treturn 0;\n\t\t} else {\n\t\t\terr = crypto_shash_final(desc, dst);\n\t\t\tif (err)\n\t\t\t\tgoto err;\n\n\t\t\tdlen -= h;\n\t\t\tdst += h;\n\t\t\tcounter = cpu_to_be32(be32_to_cpu(counter) + 1);\n\t\t}\n\t}\n\n\treturn 0;\n\nerr:\n\tmemzero_explicit(dst_orig, dlen);\n\treturn err;\n}"
  },
  {
    "function_name": "kdf_dealloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
    "lines": "126-135",
    "snippet": "static void kdf_dealloc(struct kdf_sdesc *sdesc)\n{\n\tif (!sdesc)\n\t\treturn;\n\n\tif (sdesc->shash.tfm)\n\t\tcrypto_free_shash(sdesc->shash.tfm);\n\n\tkzfree(sdesc);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/user-type.h>",
      "#include <crypto/dh.h>",
      "#include <crypto/kpp.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "sdesc"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "sdesc->shash.tfm"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic void kdf_dealloc(struct kdf_sdesc *sdesc)\n{\n\tif (!sdesc)\n\t\treturn;\n\n\tif (sdesc->shash.tfm)\n\t\tcrypto_free_shash(sdesc->shash.tfm);\n\n\tkzfree(sdesc);\n}"
  },
  {
    "function_name": "kdf_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
    "lines": "91-124",
    "snippet": "static int kdf_alloc(struct kdf_sdesc **sdesc_ret, char *hashname)\n{\n\tstruct crypto_shash *tfm;\n\tstruct kdf_sdesc *sdesc;\n\tint size;\n\tint err;\n\n\t/* allocate synchronous hash */\n\ttfm = crypto_alloc_shash(hashname, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tpr_info(\"could not allocate digest TFM handle %s\\n\", hashname);\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = -EINVAL;\n\tif (crypto_shash_digestsize(tfm) == 0)\n\t\tgoto out_free_tfm;\n\n\terr = -ENOMEM;\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(tfm);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\tgoto out_free_tfm;\n\tsdesc->shash.tfm = tfm;\n\tsdesc->shash.flags = 0x0;\n\n\t*sdesc_ret = sdesc;\n\n\treturn 0;\n\nout_free_tfm:\n\tcrypto_free_shash(tfm);\n\treturn err;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/user-type.h>",
      "#include <crypto/dh.h>",
      "#include <crypto/kpp.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "tfm"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_descsize",
          "args": [
            "tfm"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_digestsize",
          "args": [
            "tfm"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"could not allocate digest TFM handle %s\\n\"",
            "hashname"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "hashname",
            "0",
            "0"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic int kdf_alloc(struct kdf_sdesc **sdesc_ret, char *hashname)\n{\n\tstruct crypto_shash *tfm;\n\tstruct kdf_sdesc *sdesc;\n\tint size;\n\tint err;\n\n\t/* allocate synchronous hash */\n\ttfm = crypto_alloc_shash(hashname, 0, 0);\n\tif (IS_ERR(tfm)) {\n\t\tpr_info(\"could not allocate digest TFM handle %s\\n\", hashname);\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = -EINVAL;\n\tif (crypto_shash_digestsize(tfm) == 0)\n\t\tgoto out_free_tfm;\n\n\terr = -ENOMEM;\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(tfm);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\tgoto out_free_tfm;\n\tsdesc->shash.tfm = tfm;\n\tsdesc->shash.flags = 0x0;\n\n\t*sdesc_ret = sdesc;\n\n\treturn 0;\n\nout_free_tfm:\n\tcrypto_free_shash(tfm);\n\treturn err;\n}"
  },
  {
    "function_name": "dh_crypto_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
    "lines": "75-84",
    "snippet": "static void dh_crypto_done(struct crypto_async_request *req, int err)\n{\n\tstruct dh_completion *compl = req->data;\n\n\tif (err == -EINPROGRESS)\n\t\treturn;\n\n\tcompl->err = err;\n\tcomplete(&compl->completion);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/user-type.h>",
      "#include <crypto/dh.h>",
      "#include <crypto/kpp.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&compl->completion"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic void dh_crypto_done(struct crypto_async_request *req, int err)\n{\n\tstruct dh_completion *compl = req->data;\n\n\tif (err == -EINPROGRESS)\n\t\treturn;\n\n\tcompl->err = err;\n\tcomplete(&compl->completion);\n}"
  },
  {
    "function_name": "dh_free_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
    "lines": "63-68",
    "snippet": "static void dh_free_data(struct dh *dh)\n{\n\tkzfree(dh->key);\n\tkzfree(dh->p);\n\tkzfree(dh->g);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/user-type.h>",
      "#include <crypto/dh.h>",
      "#include <crypto/kpp.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "dh->g"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "dh->p"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "dh->key"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic void dh_free_data(struct dh *dh)\n{\n\tkzfree(dh->key);\n\tkzfree(dh->p);\n\tkzfree(dh->g);\n}"
  },
  {
    "function_name": "dh_data_from_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/dh.c",
    "lines": "21-61",
    "snippet": "static ssize_t dh_data_from_key(key_serial_t keyid, void **data)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong status;\n\tssize_t ret;\n\n\tkey_ref = lookup_user_key(keyid, 0, KEY_NEED_READ);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tret = -EOPNOTSUPP;\n\tif (key->type == &key_type_user) {\n\t\tdown_read(&key->sem);\n\t\tstatus = key_validate(key);\n\t\tif (status == 0) {\n\t\t\tconst struct user_key_payload *payload;\n\t\t\tuint8_t *duplicate;\n\n\t\t\tpayload = user_key_payload_locked(key);\n\n\t\t\tduplicate = kmemdup(payload->data, payload->datalen,\n\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (duplicate) {\n\t\t\t\t*data = duplicate;\n\t\t\t\tret = payload->datalen;\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tup_read(&key->sem);\n\t}\n\n\tkey_put(key);\nerror:\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <keys/user-type.h>",
      "#include <crypto/dh.h>",
      "#include <crypto/kpp.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&key->sem"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "payload->data",
            "payload->datalen",
            "GFP_KERNEL"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_key_payload_locked",
          "args": [
            "key"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_validate",
          "args": [
            "key"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "key_validate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/permission.c",
          "lines": "89-109",
          "snippet": "int key_validate(const struct key *key)\n{\n\tunsigned long flags = READ_ONCE(key->flags);\n\ttime64_t expiry = READ_ONCE(key->expiry);\n\n\tif (flags & (1 << KEY_FLAG_INVALIDATED))\n\t\treturn -ENOKEY;\n\n\t/* check it's still accessible */\n\tif (flags & ((1 << KEY_FLAG_REVOKED) |\n\t\t     (1 << KEY_FLAG_DEAD)))\n\t\treturn -EKEYREVOKED;\n\n\t/* check it hasn't expired */\n\tif (expiry) {\n\t\tif (ktime_get_real_seconds() >= expiry)\n\t\t\treturn -EKEYEXPIRED;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/security.h>\n#include <linux/module.h>\n\nint key_validate(const struct key *key)\n{\n\tunsigned long flags = READ_ONCE(key->flags);\n\ttime64_t expiry = READ_ONCE(key->expiry);\n\n\tif (flags & (1 << KEY_FLAG_INVALIDATED))\n\t\treturn -ENOKEY;\n\n\t/* check it's still accessible */\n\tif (flags & ((1 << KEY_FLAG_REVOKED) |\n\t\t     (1 << KEY_FLAG_DEAD)))\n\t\treturn -EKEYREVOKED;\n\n\t/* check it hasn't expired */\n\tif (expiry) {\n\t\tif (ktime_get_real_seconds() >= expiry)\n\t\t\treturn -EKEYEXPIRED;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&key->sem"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key_ref"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key_ref"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_user_key",
          "args": [
            "keyid",
            "0",
            "KEY_NEED_READ"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "533-757",
          "snippet": "key_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t lookup_user_key(key_serial_t id, unsigned long lflags,\n\t\t\t  key_perm_t perm)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\tstruct request_key_auth *rka;\n\tstruct key *key;\n\tkey_ref_t key_ref, skey_ref;\n\tint ret;\n\ntry_again:\n\tctx.cred = get_current_cred();\n\tkey_ref = ERR_PTR(-ENOKEY);\n\n\tswitch (id) {\n\tcase KEY_SPEC_THREAD_KEYRING:\n\t\tif (!ctx.cred->thread_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_thread_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->thread_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_PROCESS_KEYRING:\n\t\tif (!ctx.cred->process_keyring) {\n\t\t\tif (!(lflags & KEY_LOOKUP_CREATE))\n\t\t\t\tgoto error;\n\n\t\t\tret = install_process_keyring();\n\t\t\tif (ret < 0) {\n\t\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\tkey = ctx.cred->process_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_SESSION_KEYRING:\n\t\tif (!ctx.cred->session_keyring) {\n\t\t\t/* always install a session keyring upon access if one\n\t\t\t * doesn't exist yet */\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tif (lflags & KEY_LOOKUP_CREATE)\n\t\t\t\tret = join_session_keyring(NULL);\n\t\t\telse\n\t\t\t\tret = install_session_keyring(\n\t\t\t\t\tctx.cred->user->session_keyring);\n\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t} else if (ctx.cred->session_keyring ==\n\t\t\t   ctx.cred->user->session_keyring &&\n\t\t\t   lflags & KEY_LOOKUP_CREATE) {\n\t\t\tret = join_session_keyring(NULL);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t\tgoto reget_creds;\n\t\t}\n\n\t\trcu_read_lock();\n\t\tkey = rcu_dereference(ctx.cred->session_keyring);\n\t\t__key_get(key);\n\t\trcu_read_unlock();\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_KEYRING:\n\t\tif (!ctx.cred->user->uid_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->uid_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_USER_SESSION_KEYRING:\n\t\tif (!ctx.cred->user->session_keyring) {\n\t\t\tret = install_user_keyrings();\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error;\n\t\t}\n\n\t\tkey = ctx.cred->user->session_keyring;\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_GROUP_KEYRING:\n\t\t/* group keyrings are not yet supported */\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tgoto error;\n\n\tcase KEY_SPEC_REQKEY_AUTH_KEY:\n\t\tkey = ctx.cred->request_key_auth;\n\t\tif (!key)\n\t\t\tgoto error;\n\n\t\t__key_get(key);\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tcase KEY_SPEC_REQUESTOR_KEYRING:\n\t\tif (!ctx.cred->request_key_auth)\n\t\t\tgoto error;\n\n\t\tdown_read(&ctx.cred->request_key_auth->sem);\n\t\tif (test_bit(KEY_FLAG_REVOKED,\n\t\t\t     &ctx.cred->request_key_auth->flags)) {\n\t\t\tkey_ref = ERR_PTR(-EKEYREVOKED);\n\t\t\tkey = NULL;\n\t\t} else {\n\t\t\trka = ctx.cred->request_key_auth->payload.data[0];\n\t\t\tkey = rka->dest_keyring;\n\t\t\t__key_get(key);\n\t\t}\n\t\tup_read(&ctx.cred->request_key_auth->sem);\n\t\tif (!key)\n\t\t\tgoto error;\n\t\tkey_ref = make_key_ref(key, 1);\n\t\tbreak;\n\n\tdefault:\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (id < 1)\n\t\t\tgoto error;\n\n\t\tkey = key_lookup(id);\n\t\tif (IS_ERR(key)) {\n\t\t\tkey_ref = ERR_CAST(key);\n\t\t\tgoto error;\n\t\t}\n\n\t\tkey_ref = make_key_ref(key, 0);\n\n\t\t/* check to see if we possess the key */\n\t\tctx.index_key.type\t\t= key->type;\n\t\tctx.index_key.description\t= key->description;\n\t\tctx.index_key.desc_len\t\t= strlen(key->description);\n\t\tctx.match_data.raw_data\t\t= key;\n\t\tkdebug(\"check possessed\");\n\t\tskey_ref = search_process_keyrings(&ctx);\n\t\tkdebug(\"possessed=%p\", skey_ref);\n\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_put(key);\n\t\t\tkey_ref = skey_ref;\n\t\t}\n\n\t\tbreak;\n\t}\n\n\t/* unlink does not use the nominated key in any way, so can skip all\n\t * the permission checks as it is only concerned with the keyring */\n\tif (lflags & KEY_LOOKUP_FOR_UNLINK) {\n\t\tret = 0;\n\t\tgoto error;\n\t}\n\n\tif (!(lflags & KEY_LOOKUP_PARTIAL)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tswitch (ret) {\n\t\tcase -ERESTARTSYS:\n\t\t\tgoto invalid_key;\n\t\tdefault:\n\t\t\tif (perm)\n\t\t\t\tgoto invalid_key;\n\t\tcase 0:\n\t\t\tbreak;\n\t\t}\n\t} else if (perm) {\n\t\tret = key_validate(key);\n\t\tif (ret < 0)\n\t\t\tgoto invalid_key;\n\t}\n\n\tret = -EIO;\n\tif (!(lflags & KEY_LOOKUP_PARTIAL) &&\n\t    key_read_state(key) == KEY_IS_UNINSTANTIATED)\n\t\tgoto invalid_key;\n\n\t/* check the permissions */\n\tret = key_task_permission(key_ref, ctx.cred, perm);\n\tif (ret < 0)\n\t\tgoto invalid_key;\n\n\tkey->last_used_at = ktime_get_real_seconds();\n\nerror:\n\tput_cred(ctx.cred);\n\treturn key_ref;\n\ninvalid_key:\n\tkey_ref_put(key_ref);\n\tkey_ref = ERR_PTR(ret);\n\tgoto error;\n\n\t/* if we attempted to install a keyring, then it may have caused new\n\t * creds to be installed */\nreget_creds:\n\tput_cred(ctx.cred);\n\tgoto try_again;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <keys/user-type.h>\n#include <crypto/dh.h>\n#include <crypto/kpp.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/scatterlist.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\nstatic ssize_t dh_data_from_key(key_serial_t keyid, void **data)\n{\n\tstruct key *key;\n\tkey_ref_t key_ref;\n\tlong status;\n\tssize_t ret;\n\n\tkey_ref = lookup_user_key(keyid, 0, KEY_NEED_READ);\n\tif (IS_ERR(key_ref)) {\n\t\tret = -ENOKEY;\n\t\tgoto error;\n\t}\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\tret = -EOPNOTSUPP;\n\tif (key->type == &key_type_user) {\n\t\tdown_read(&key->sem);\n\t\tstatus = key_validate(key);\n\t\tif (status == 0) {\n\t\t\tconst struct user_key_payload *payload;\n\t\t\tuint8_t *duplicate;\n\n\t\t\tpayload = user_key_payload_locked(key);\n\n\t\t\tduplicate = kmemdup(payload->data, payload->datalen,\n\t\t\t\t\t    GFP_KERNEL);\n\t\t\tif (duplicate) {\n\t\t\t\t*data = duplicate;\n\t\t\t\tret = payload->datalen;\n\t\t\t} else {\n\t\t\t\tret = -ENOMEM;\n\t\t\t}\n\t\t}\n\t\tup_read(&key->sem);\n\t}\n\n\tkey_put(key);\nerror:\n\treturn ret;\n}"
  }
]