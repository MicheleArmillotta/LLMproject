[
  {
    "function_name": "securityfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
    "lines": "325-343",
    "snippet": "static int __init securityfs_init(void)\n{\n\tint retval;\n\n\tretval = sysfs_create_mount_point(kernel_kobj, \"security\");\n\tif (retval)\n\t\treturn retval;\n\n\tretval = register_filesystem(&fs_type);\n\tif (retval) {\n\t\tsysfs_remove_mount_point(kernel_kobj, \"security\");\n\t\treturn retval;\n\t}\n#ifdef CONFIG_SECURITY\n\tlsm_dentry = securityfs_create_file(\"lsm\", 0444, NULL, NULL,\n\t\t\t\t\t\t&lsm_ops);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"securityfs\",\n\t.mount =\tget_sb,\n\t.kill_sb =\tkill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "securityfs_create_file",
          "args": [
            "\"lsm\"",
            "0444",
            "NULL",
            "NULL",
            "&lsm_ops"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "194-199",
          "snippet": "struct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_remove_mount_point",
          "args": [
            "kernel_kobj",
            "\"security\""
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_filesystem",
          "args": [
            "&fs_type"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysfs_create_mount_point",
          "args": [
            "kernel_kobj",
            "\"security\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct file_system_type fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"securityfs\",\n\t.mount =\tget_sb,\n\t.kill_sb =\tkill_litter_super,\n};\n\nstatic int __init securityfs_init(void)\n{\n\tint retval;\n\n\tretval = sysfs_create_mount_point(kernel_kobj, \"security\");\n\tif (retval)\n\t\treturn retval;\n\n\tretval = register_filesystem(&fs_type);\n\tif (retval) {\n\t\tsysfs_remove_mount_point(kernel_kobj, \"security\");\n\t\treturn retval;\n\t}\n#ifdef CONFIG_SECURITY\n\tlsm_dentry = securityfs_create_file(\"lsm\", 0444, NULL, NULL,\n\t\t\t\t\t\t&lsm_ops);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "lsm_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
    "lines": "312-317",
    "snippet": "static ssize_t lsm_read(struct file *filp, char __user *buf, size_t count,\n\t\t\tloff_t *ppos)\n{\n\treturn simple_read_from_buffer(buf, count, ppos, lsm_names,\n\t\tstrlen(lsm_names));\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "lsm_names",
            "strlen(lsm_names)"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "lsm_names"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic ssize_t lsm_read(struct file *filp, char __user *buf, size_t count,\n\t\t\tloff_t *ppos)\n{\n\treturn simple_read_from_buffer(buf, count, ppos, lsm_names,\n\t\tstrlen(lsm_names));\n}"
  },
  {
    "function_name": "securityfs_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
    "lines": "289-307",
    "snippet": "void securityfs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *mount;",
      "static int mount_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&mount",
            "&mount_count"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "dir"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_unlink",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_rmdir",
          "args": [
            "dir",
            "dentry"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_is_dir",
          "args": [
            "dentry"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_positive",
          "args": [
            "dentry"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "dir"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "dentry->d_parent"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *mount;\nstatic int mount_count;\n\nvoid securityfs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n}"
  },
  {
    "function_name": "securityfs_create_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
    "lines": "254-273",
    "snippet": "struct dentry *securityfs_create_symlink(const char *name,\n\t\t\t\t\t struct dentry *parent,\n\t\t\t\t\t const char *target,\n\t\t\t\t\t const struct inode_operations *iops)\n{\n\tstruct dentry *dent;\n\tchar *link = NULL;\n\n\tif (target) {\n\t\tlink = kstrdup(target, GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tdent = securityfs_create_dentry(name, S_IFLNK | 0444, parent,\n\t\t\t\t\tlink, NULL, iops);\n\tif (IS_ERR(dent))\n\t\tkfree(link);\n\n\treturn dent;\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "link"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dent"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "securityfs_create_dentry",
          "args": [
            "name",
            "S_IFLNK | 0444",
            "parent",
            "link",
            "NULL",
            "iops"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "101-167",
          "snippet": "static struct dentry *securityfs_create_dentry(const char *name, umode_t mode,\n\t\t\t\t\tstruct dentry *parent, void *data,\n\t\t\t\t\tconst struct file_operations *fops,\n\t\t\t\t\tconst struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir, *inode;\n\tint error;\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\tpr_debug(\"securityfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&fs_type, &mount, &mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tif (!parent)\n\t\tparent = mount->mnt_root;\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto out1;\n\t}\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\terror = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = data;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\tinode_unlock(dir);\n\treturn dentry;\n\nout1:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nout:\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *mount;",
            "static int mount_count;",
            "static struct file_system_type fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"securityfs\",\n\t.mount =\tget_sb,\n\t.kill_sb =\tkill_litter_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *mount;\nstatic int mount_count;\nstatic struct file_system_type fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"securityfs\",\n\t.mount =\tget_sb,\n\t.kill_sb =\tkill_litter_super,\n};\n\nstatic struct dentry *securityfs_create_dentry(const char *name, umode_t mode,\n\t\t\t\t\tstruct dentry *parent, void *data,\n\t\t\t\t\tconst struct file_operations *fops,\n\t\t\t\t\tconst struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir, *inode;\n\tint error;\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\tpr_debug(\"securityfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&fs_type, &mount, &mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tif (!parent)\n\t\tparent = mount->mnt_root;\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto out1;\n\t}\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\terror = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = data;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\tinode_unlock(dir);\n\treturn dentry;\n\nout1:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nout:\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n\treturn dentry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "target",
            "GFP_KERNEL"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_symlink(const char *name,\n\t\t\t\t\t struct dentry *parent,\n\t\t\t\t\t const char *target,\n\t\t\t\t\t const struct inode_operations *iops)\n{\n\tstruct dentry *dent;\n\tchar *link = NULL;\n\n\tif (target) {\n\t\tlink = kstrdup(target, GFP_KERNEL);\n\t\tif (!link)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\tdent = securityfs_create_dentry(name, S_IFLNK | 0444, parent,\n\t\t\t\t\tlink, NULL, iops);\n\tif (IS_ERR(dent))\n\t\tkfree(link);\n\n\treturn dent;\n}"
  },
  {
    "function_name": "securityfs_create_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
    "lines": "222-225",
    "snippet": "struct dentry *securityfs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn securityfs_create_file(name, S_IFDIR | 0755, parent, NULL, NULL);\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "securityfs_create_file",
          "args": [
            "name",
            "S_IFDIR | 0755",
            "parent",
            "NULL",
            "NULL"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "194-199",
          "snippet": "struct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn securityfs_create_file(name, S_IFDIR | 0755, parent, NULL, NULL);\n}"
  },
  {
    "function_name": "securityfs_create_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
    "lines": "194-199",
    "snippet": "struct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "securityfs_create_dentry",
          "args": [
            "name",
            "mode",
            "parent",
            "data",
            "fops",
            "NULL"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "101-167",
          "snippet": "static struct dentry *securityfs_create_dentry(const char *name, umode_t mode,\n\t\t\t\t\tstruct dentry *parent, void *data,\n\t\t\t\t\tconst struct file_operations *fops,\n\t\t\t\t\tconst struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir, *inode;\n\tint error;\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\tpr_debug(\"securityfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&fs_type, &mount, &mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tif (!parent)\n\t\tparent = mount->mnt_root;\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto out1;\n\t}\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\terror = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = data;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\tinode_unlock(dir);\n\treturn dentry;\n\nout1:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nout:\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n\treturn dentry;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *mount;",
            "static int mount_count;",
            "static struct file_system_type fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"securityfs\",\n\t.mount =\tget_sb,\n\t.kill_sb =\tkill_litter_super,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *mount;\nstatic int mount_count;\nstatic struct file_system_type fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"securityfs\",\n\t.mount =\tget_sb,\n\t.kill_sb =\tkill_litter_super,\n};\n\nstatic struct dentry *securityfs_create_dentry(const char *name, umode_t mode,\n\t\t\t\t\tstruct dentry *parent, void *data,\n\t\t\t\t\tconst struct file_operations *fops,\n\t\t\t\t\tconst struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir, *inode;\n\tint error;\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\tpr_debug(\"securityfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&fs_type, &mount, &mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tif (!parent)\n\t\tparent = mount->mnt_root;\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto out1;\n\t}\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\terror = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = data;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\tinode_unlock(dir);\n\treturn dentry;\n\nout1:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nout:\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n\treturn dentry;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}"
  },
  {
    "function_name": "securityfs_create_dentry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
    "lines": "101-167",
    "snippet": "static struct dentry *securityfs_create_dentry(const char *name, umode_t mode,\n\t\t\t\t\tstruct dentry *parent, void *data,\n\t\t\t\t\tconst struct file_operations *fops,\n\t\t\t\t\tconst struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir, *inode;\n\tint error;\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\tpr_debug(\"securityfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&fs_type, &mount, &mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tif (!parent)\n\t\tparent = mount->mnt_root;\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto out1;\n\t}\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\terror = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = data;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\tinode_unlock(dir);\n\treturn dentry;\n\nout1:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nout:\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n\treturn dentry;\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct vfsmount *mount;",
      "static int mount_count;",
      "static struct file_system_type fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"securityfs\",\n\t.mount =\tget_sb,\n\t.kill_sb =\tkill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_release_fs",
          "args": [
            "&mount",
            "&mount_count"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "dir"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dput",
          "args": [
            "dentry"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_unlock",
          "args": [
            "dir"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dget",
          "args": [
            "dentry"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_instantiate",
          "args": [
            "dentry",
            "inode"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "security_d_instantiate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "1249-1254",
          "snippet": "void security_d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tif (unlikely(inode && IS_PRIVATE(inode)))\n\t\treturn;\n\tcall_void_hook(d_instantiate, dentry, inode);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nvoid security_d_instantiate(struct dentry *dentry, struct inode *inode)\n{\n\tif (unlikely(inode && IS_PRIVATE(inode)))\n\t\treturn;\n\tcall_void_hook(d_instantiate, dentry, inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "dir"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_nlink",
          "args": [
            "inode"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_time",
          "args": [
            "inode"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_next_ino",
          "args": [],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "new_inode",
          "args": [
            "dir->i_sb"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "new_inode_smack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/smack/smack_lsm.c",
          "lines": "295-308",
          "snippet": "static struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}",
          "includes": [
            "#include \"smack.h\"",
            "#include <linux/parser.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/shm.h>",
            "#include <linux/msg.h>",
            "#include <linux/personality.h>",
            "#include <linux/dcache.h>",
            "#include <linux/magic.h>",
            "#include <linux/audit.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/cipso_ipv4.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/dccp.h>",
            "#include <linux/udp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <asm/ioctls.h>",
            "#include <linux/kd.h>",
            "#include <linux/stat.h>",
            "#include <linux/mount.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/xattr.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *smack_inode_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smack.h\"\n#include <linux/parser.h>\n#include <linux/binfmts.h>\n#include <linux/shm.h>\n#include <linux/msg.h>\n#include <linux/personality.h>\n#include <linux/dcache.h>\n#include <linux/magic.h>\n#include <linux/audit.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/cipso_ipv4.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/dccp.h>\n#include <linux/udp.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <asm/ioctls.h>\n#include <linux/kd.h>\n#include <linux/stat.h>\n#include <linux/mount.h>\n#include <linux/pagemap.h>\n#include <linux/xattr.h>\n\nstatic struct kmem_cache *smack_inode_cache;\n\nstatic struct inode_smack *new_inode_smack(struct smack_known *skp)\n{\n\tstruct inode_smack *isp;\n\n\tisp = kmem_cache_zalloc(smack_inode_cache, GFP_NOFS);\n\tif (isp == NULL)\n\t\treturn NULL;\n\n\tisp->smk_inode = skp;\n\tisp->smk_flags = 0;\n\tmutex_init(&isp->smk_lock);\n\n\treturn isp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_really_is_positive",
          "args": [
            "dentry"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "dentry"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_one_len",
          "args": [
            "name",
            "parent",
            "strlen(name)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inode_lock",
          "args": [
            "dir"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_inode",
          "args": [
            "parent"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_pin_fs",
          "args": [
            "&fs_type",
            "&mount",
            "&mount_count"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"securityfs: creating file '%s'\\n\"",
            "name"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *mount;\nstatic int mount_count;\nstatic struct file_system_type fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"securityfs\",\n\t.mount =\tget_sb,\n\t.kill_sb =\tkill_litter_super,\n};\n\nstatic struct dentry *securityfs_create_dentry(const char *name, umode_t mode,\n\t\t\t\t\tstruct dentry *parent, void *data,\n\t\t\t\t\tconst struct file_operations *fops,\n\t\t\t\t\tconst struct inode_operations *iops)\n{\n\tstruct dentry *dentry;\n\tstruct inode *dir, *inode;\n\tint error;\n\n\tif (!(mode & S_IFMT))\n\t\tmode = (mode & S_IALLUGO) | S_IFREG;\n\n\tpr_debug(\"securityfs: creating file '%s'\\n\",name);\n\n\terror = simple_pin_fs(&fs_type, &mount, &mount_count);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\tif (!parent)\n\t\tparent = mount->mnt_root;\n\n\tdir = d_inode(parent);\n\n\tinode_lock(dir);\n\tdentry = lookup_one_len(name, parent, strlen(name));\n\tif (IS_ERR(dentry))\n\t\tgoto out;\n\n\tif (d_really_is_positive(dentry)) {\n\t\terror = -EEXIST;\n\t\tgoto out1;\n\t}\n\n\tinode = new_inode(dir->i_sb);\n\tif (!inode) {\n\t\terror = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = mode;\n\tinode->i_atime = inode->i_mtime = inode->i_ctime = current_time(inode);\n\tinode->i_private = data;\n\tif (S_ISDIR(mode)) {\n\t\tinode->i_op = &simple_dir_inode_operations;\n\t\tinode->i_fop = &simple_dir_operations;\n\t\tinc_nlink(inode);\n\t\tinc_nlink(dir);\n\t} else if (S_ISLNK(mode)) {\n\t\tinode->i_op = iops ? iops : &simple_symlink_inode_operations;\n\t\tinode->i_link = data;\n\t} else {\n\t\tinode->i_fop = fops;\n\t}\n\td_instantiate(dentry, inode);\n\tdget(dentry);\n\tinode_unlock(dir);\n\treturn dentry;\n\nout1:\n\tdput(dentry);\n\tdentry = ERR_PTR(error);\nout:\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n\treturn dentry;\n}"
  },
  {
    "function_name": "get_sb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
    "lines": "56-61",
    "snippet": "static struct dentry *get_sb(struct file_system_type *fs_type,\n\t\t  int flags, const char *dev_name,\n\t\t  void *data)\n{\n\treturn mount_single(fs_type, flags, data, fill_super);\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct file_system_type fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"securityfs\",\n\t.mount =\tget_sb,\n\t.kill_sb =\tkill_litter_super,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mount_single",
          "args": [
            "fs_type",
            "flags",
            "data",
            "fill_super"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct file_system_type fs_type = {\n\t.owner =\tTHIS_MODULE,\n\t.name =\t\t\"securityfs\",\n\t.mount =\tget_sb,\n\t.kill_sb =\tkill_litter_super,\n};\n\nstatic struct dentry *get_sb(struct file_system_type *fs_type,\n\t\t  int flags, const char *dev_name,\n\t\t  void *data)\n{\n\treturn mount_single(fs_type, flags, data, fill_super);\n}"
  },
  {
    "function_name": "fill_super",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
    "lines": "42-54",
    "snippet": "static int fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstatic const struct tree_descr files[] = {{\"\"}};\n\tint error;\n\n\terror = simple_fill_super(sb, SECURITYFS_MAGIC, files);\n\tif (error)\n\t\treturn error;\n\n\tsb->s_op = &securityfs_super_operations;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct super_operations securityfs_super_operations = {\n\t.statfs\t\t= simple_statfs,\n\t.evict_inode\t= securityfs_evict_inode,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_fill_super",
          "args": [
            "sb",
            "SECURITYFS_MAGIC",
            "files"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic const struct super_operations securityfs_super_operations = {\n\t.statfs\t\t= simple_statfs,\n\t.evict_inode\t= securityfs_evict_inode,\n};\n\nstatic int fill_super(struct super_block *sb, void *data, int silent)\n{\n\tstatic const struct tree_descr files[] = {{\"\"}};\n\tint error;\n\n\terror = simple_fill_super(sb, SECURITYFS_MAGIC, files);\n\tif (error)\n\t\treturn error;\n\n\tsb->s_op = &securityfs_super_operations;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "securityfs_evict_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
    "lines": "29-35",
    "snippet": "static void securityfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_link);\n}",
    "includes": [
      "#include <linux/magic.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/security.h>",
      "#include <linux/namei.h>",
      "#include <linux/init.h>",
      "#include <linux/pagemap.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "inode->i_link"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "inode->i_mode"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_inode",
          "args": [
            "inode"
          ],
          "line": 32
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "truncate_inode_pages_final",
          "args": [
            "&inode->i_data"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void securityfs_evict_inode(struct inode *inode)\n{\n\ttruncate_inode_pages_final(&inode->i_data);\n\tclear_inode(inode);\n\tif (S_ISLNK(inode->i_mode))\n\t\tkfree(inode->i_link);\n}"
  }
]