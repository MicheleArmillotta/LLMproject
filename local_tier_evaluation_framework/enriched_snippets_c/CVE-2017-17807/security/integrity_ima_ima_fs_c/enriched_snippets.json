[
  {
    "function_name": "ima_fs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "449-497",
    "snippet": "int __init ima_fs_init(void)\n{\n\tima_dir = securityfs_create_dir(\"ima\", NULL);\n\tif (IS_ERR(ima_dir))\n\t\treturn -1;\n\n\tbinary_runtime_measurements =\n\t    securityfs_create_file(\"binary_runtime_measurements\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_measurements_ops);\n\tif (IS_ERR(binary_runtime_measurements))\n\t\tgoto out;\n\n\tascii_runtime_measurements =\n\t    securityfs_create_file(\"ascii_runtime_measurements\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_ascii_measurements_ops);\n\tif (IS_ERR(ascii_runtime_measurements))\n\t\tgoto out;\n\n\truntime_measurements_count =\n\t    securityfs_create_file(\"runtime_measurements_count\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_measurements_count_ops);\n\tif (IS_ERR(runtime_measurements_count))\n\t\tgoto out;\n\n\tviolations =\n\t    securityfs_create_file(\"violations\", S_IRUSR | S_IRGRP,\n\t\t\t\t   ima_dir, NULL, &ima_htable_violations_ops);\n\tif (IS_ERR(violations))\n\t\tgoto out;\n\n\tima_policy = securityfs_create_file(\"policy\", POLICY_FILE_FLAGS,\n\t\t\t\t\t    ima_dir, NULL,\n\t\t\t\t\t    &ima_measure_policy_ops);\n\tif (IS_ERR(ima_policy))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tsecurityfs_remove(violations);\n\tsecurityfs_remove(runtime_measurements_count);\n\tsecurityfs_remove(ascii_runtime_measurements);\n\tsecurityfs_remove(binary_runtime_measurements);\n\tsecurityfs_remove(ima_dir);\n\tsecurityfs_remove(ima_policy);\n\treturn -1;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations ima_htable_violations_ops = {\n\t.read = ima_show_htable_violations,\n\t.llseek = generic_file_llseek,\n};",
      "static const struct file_operations ima_measurements_count_ops = {\n\t.read = ima_show_measurements_count,\n\t.llseek = generic_file_llseek,\n};",
      "static const struct file_operations ima_measurements_ops = {\n\t.open = ima_measurements_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};",
      "static const struct file_operations ima_ascii_measurements_ops = {\n\t.open = ima_ascii_measurements_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};",
      "static struct dentry *ima_dir;",
      "static struct dentry *binary_runtime_measurements;",
      "static struct dentry *ascii_runtime_measurements;",
      "static struct dentry *runtime_measurements_count;",
      "static struct dentry *violations;",
      "static struct dentry *ima_policy;",
      "static const struct file_operations ima_measure_policy_ops = {\n\t.open = ima_open_policy,\n\t.write = ima_write_policy,\n\t.read = seq_read,\n\t.release = ima_release_policy,\n\t.llseek = generic_file_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "securityfs_remove",
          "args": [
            "ima_policy"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "289-307",
          "snippet": "void securityfs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *mount;",
            "static int mount_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *mount;\nstatic int mount_count;\n\nvoid securityfs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ima_policy"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "securityfs_create_file",
          "args": [
            "\"policy\"",
            "POLICY_FILE_FLAGS",
            "ima_dir",
            "NULL",
            "&ima_measure_policy_ops"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "194-199",
          "snippet": "struct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "violations"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "runtime_measurements_count"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ascii_runtime_measurements"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "binary_runtime_measurements"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ima_dir"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "securityfs_create_dir",
          "args": [
            "\"ima\"",
            "NULL"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "222-225",
          "snippet": "struct dentry *securityfs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn securityfs_create_file(name, S_IFDIR | 0755, parent, NULL, NULL);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn securityfs_create_file(name, S_IFDIR | 0755, parent, NULL, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic const struct file_operations ima_htable_violations_ops = {\n\t.read = ima_show_htable_violations,\n\t.llseek = generic_file_llseek,\n};\nstatic const struct file_operations ima_measurements_count_ops = {\n\t.read = ima_show_measurements_count,\n\t.llseek = generic_file_llseek,\n};\nstatic const struct file_operations ima_measurements_ops = {\n\t.open = ima_measurements_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\nstatic const struct file_operations ima_ascii_measurements_ops = {\n\t.open = ima_ascii_measurements_open,\n\t.read = seq_read,\n\t.llseek = seq_lseek,\n\t.release = seq_release,\n};\nstatic struct dentry *ima_dir;\nstatic struct dentry *binary_runtime_measurements;\nstatic struct dentry *ascii_runtime_measurements;\nstatic struct dentry *runtime_measurements_count;\nstatic struct dentry *violations;\nstatic struct dentry *ima_policy;\nstatic const struct file_operations ima_measure_policy_ops = {\n\t.open = ima_open_policy,\n\t.write = ima_write_policy,\n\t.read = seq_read,\n\t.release = ima_release_policy,\n\t.llseek = generic_file_llseek,\n};\n\nint __init ima_fs_init(void)\n{\n\tima_dir = securityfs_create_dir(\"ima\", NULL);\n\tif (IS_ERR(ima_dir))\n\t\treturn -1;\n\n\tbinary_runtime_measurements =\n\t    securityfs_create_file(\"binary_runtime_measurements\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_measurements_ops);\n\tif (IS_ERR(binary_runtime_measurements))\n\t\tgoto out;\n\n\tascii_runtime_measurements =\n\t    securityfs_create_file(\"ascii_runtime_measurements\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_ascii_measurements_ops);\n\tif (IS_ERR(ascii_runtime_measurements))\n\t\tgoto out;\n\n\truntime_measurements_count =\n\t    securityfs_create_file(\"runtime_measurements_count\",\n\t\t\t\t   S_IRUSR | S_IRGRP, ima_dir, NULL,\n\t\t\t\t   &ima_measurements_count_ops);\n\tif (IS_ERR(runtime_measurements_count))\n\t\tgoto out;\n\n\tviolations =\n\t    securityfs_create_file(\"violations\", S_IRUSR | S_IRGRP,\n\t\t\t\t   ima_dir, NULL, &ima_htable_violations_ops);\n\tif (IS_ERR(violations))\n\t\tgoto out;\n\n\tima_policy = securityfs_create_file(\"policy\", POLICY_FILE_FLAGS,\n\t\t\t\t\t    ima_dir, NULL,\n\t\t\t\t\t    &ima_measure_policy_ops);\n\tif (IS_ERR(ima_policy))\n\t\tgoto out;\n\n\treturn 0;\nout:\n\tsecurityfs_remove(violations);\n\tsecurityfs_remove(runtime_measurements_count);\n\tsecurityfs_remove(ascii_runtime_measurements);\n\tsecurityfs_remove(binary_runtime_measurements);\n\tsecurityfs_remove(ima_dir);\n\tsecurityfs_remove(ima_policy);\n\treturn -1;\n}"
  },
  {
    "function_name": "ima_release_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "408-439",
    "snippet": "static int ima_release_policy(struct inode *inode, struct file *file)\n{\n\tconst char *cause = valid_policy ? \"completed\" : \"failed\";\n\n\tif ((file->f_flags & O_ACCMODE) == O_RDONLY)\n\t\treturn seq_release(inode, file);\n\n\tif (valid_policy && ima_check_policy() < 0) {\n\t\tcause = \"failed\";\n\t\tvalid_policy = 0;\n\t}\n\n\tpr_info(\"IMA: policy update %s\\n\", cause);\n\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL, NULL,\n\t\t\t    \"policy_update\", cause, !valid_policy, 0);\n\n\tif (!valid_policy) {\n\t\tima_delete_rules();\n\t\tvalid_policy = 1;\n\t\tclear_bit(IMA_FS_BUSY, &ima_fs_flags);\n\t\treturn 0;\n\t}\n\n\tima_update_policy();\n#if !defined(CONFIG_IMA_WRITE_POLICY) && !defined(CONFIG_IMA_READ_POLICY)\n\tsecurityfs_remove(ima_policy);\n\tima_policy = NULL;\n#elif defined(CONFIG_IMA_WRITE_POLICY)\n\tclear_bit(IMA_FS_BUSY, &ima_fs_flags);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int valid_policy = 1;",
      "static struct dentry *ima_policy;",
      "static unsigned long ima_fs_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "IMA_FS_BUSY",
            "&ima_fs_flags"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "securityfs_remove",
          "args": [
            "ima_policy"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "289-307",
          "snippet": "void securityfs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct vfsmount *mount;",
            "static int mount_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct vfsmount *mount;\nstatic int mount_count;\n\nvoid securityfs_remove(struct dentry *dentry)\n{\n\tstruct inode *dir;\n\n\tif (!dentry || IS_ERR(dentry))\n\t\treturn;\n\n\tdir = d_inode(dentry->d_parent);\n\tinode_lock(dir);\n\tif (simple_positive(dentry)) {\n\t\tif (d_is_dir(dentry))\n\t\t\tsimple_rmdir(dir, dentry);\n\t\telse\n\t\t\tsimple_unlink(dir, dentry);\n\t\tdput(dentry);\n\t}\n\tinode_unlock(dir);\n\tsimple_release_fs(&mount, &mount_count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_update_policy",
          "args": [],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "ima_update_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "494-518",
          "snippet": "void ima_update_policy(void)\n{\n\tstruct list_head *first, *last, *policy;\n\n\t/* append current policy with the new rules */\n\tfirst = (&ima_temp_rules)->next;\n\tlast = (&ima_temp_rules)->prev;\n\tpolicy = &ima_policy_rules;\n\n\tsynchronize_rcu();\n\n\tlast->next = policy;\n\trcu_assign_pointer(list_next_rcu(policy->prev), first);\n\tfirst->prev = policy->prev;\n\tpolicy->prev = last;\n\n\t/* prepare for the next policy rules addition */\n\tINIT_LIST_HEAD(&ima_temp_rules);\n\n\tif (ima_rules != policy) {\n\t\tima_policy_flag = 0;\n\t\tima_rules = policy;\n\t}\n\tima_update_policy_flag();\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int ima_policy_flag;",
            "static LIST_HEAD(ima_policy_rules);",
            "static LIST_HEAD(ima_temp_rules);",
            "static struct list_head *ima_rules;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nint ima_policy_flag;\nstatic LIST_HEAD(ima_policy_rules);\nstatic LIST_HEAD(ima_temp_rules);\nstatic struct list_head *ima_rules;\n\nvoid ima_update_policy(void)\n{\n\tstruct list_head *first, *last, *policy;\n\n\t/* append current policy with the new rules */\n\tfirst = (&ima_temp_rules)->next;\n\tlast = (&ima_temp_rules)->prev;\n\tpolicy = &ima_policy_rules;\n\n\tsynchronize_rcu();\n\n\tlast->next = policy;\n\trcu_assign_pointer(list_next_rcu(policy->prev), first);\n\tfirst->prev = policy->prev;\n\tpolicy->prev = last;\n\n\t/* prepare for the next policy rules addition */\n\tINIT_LIST_HEAD(&ima_temp_rules);\n\n\tif (ima_rules != policy) {\n\t\tima_policy_flag = 0;\n\t\tima_rules = policy;\n\t}\n\tima_update_policy_flag();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "IMA_FS_BUSY",
            "&ima_fs_flags"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_delete_rules",
          "args": [],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ima_delete_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "946-959",
          "snippet": "void ima_delete_rules(void)\n{\n\tstruct ima_rule_entry *entry, *tmp;\n\tint i;\n\n\ttemp_ima_appraise = 0;\n\tlist_for_each_entry_safe(entry, tmp, &ima_temp_rules, list) {\n\t\tfor (i = 0; i < MAX_LSM_RULES; i++)\n\t\t\tkfree(entry->lsm[i].args_p);\n\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define MAX_LSM_RULES 6"
          ],
          "globals_used": [
            "static int temp_ima_appraise;",
            "static LIST_HEAD(ima_temp_rules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define MAX_LSM_RULES 6\n\nstatic int temp_ima_appraise;\nstatic LIST_HEAD(ima_temp_rules);\n\nvoid ima_delete_rules(void)\n{\n\tstruct ima_rule_entry *entry, *tmp;\n\tint i;\n\n\ttemp_ima_appraise = 0;\n\tlist_for_each_entry_safe(entry, tmp, &ima_temp_rules, list) {\n\t\tfor (i = 0; i < MAX_LSM_RULES; i++)\n\t\t\tkfree(entry->lsm[i].args_p);\n\n\t\tlist_del(&entry->list);\n\t\tkfree(entry);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_STATUS",
            "NULL",
            "NULL",
            "\"policy_update\"",
            "cause",
            "!valid_policy",
            "0"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"IMA: policy update %s\\n\"",
            "cause"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_check_policy",
          "args": [],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "ima_check_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "476-481",
          "snippet": "int ima_check_policy(void)\n{\n\tif (list_empty(&ima_temp_rules))\n\t\treturn -EINVAL;\n\treturn 0;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ima_temp_rules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(ima_temp_rules);\n\nint ima_check_policy(void)\n{\n\tif (list_empty(&ima_temp_rules))\n\t\treturn -EINVAL;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_release",
          "args": [
            "inode",
            "file"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic int valid_policy = 1;\nstatic struct dentry *ima_policy;\nstatic unsigned long ima_fs_flags;\n\nstatic int ima_release_policy(struct inode *inode, struct file *file)\n{\n\tconst char *cause = valid_policy ? \"completed\" : \"failed\";\n\n\tif ((file->f_flags & O_ACCMODE) == O_RDONLY)\n\t\treturn seq_release(inode, file);\n\n\tif (valid_policy && ima_check_policy() < 0) {\n\t\tcause = \"failed\";\n\t\tvalid_policy = 0;\n\t}\n\n\tpr_info(\"IMA: policy update %s\\n\", cause);\n\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL, NULL,\n\t\t\t    \"policy_update\", cause, !valid_policy, 0);\n\n\tif (!valid_policy) {\n\t\tima_delete_rules();\n\t\tvalid_policy = 1;\n\t\tclear_bit(IMA_FS_BUSY, &ima_fs_flags);\n\t\treturn 0;\n\t}\n\n\tima_update_policy();\n#if !defined(CONFIG_IMA_WRITE_POLICY) && !defined(CONFIG_IMA_READ_POLICY)\n\tsecurityfs_remove(ima_policy);\n\tima_policy = NULL;\n#elif defined(CONFIG_IMA_WRITE_POLICY)\n\tclear_bit(IMA_FS_BUSY, &ima_fs_flags);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "ima_open_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "383-399",
    "snippet": "static int ima_open_policy(struct inode *inode, struct file *filp)\n{\n\tif (!(filp->f_flags & O_WRONLY)) {\n#ifndef\tCONFIG_IMA_READ_POLICY\n\t\treturn -EACCES;\n#else\n\t\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\t\treturn -EACCES;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn seq_open(filp, &ima_policy_seqops);\n#endif\n\t}\n\tif (test_and_set_bit(IMA_FS_BUSY, &ima_fs_flags))\n\t\treturn -EBUSY;\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ima_fs_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "IMA_FS_BUSY",
            "&ima_fs_flags"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "filp",
            "&ima_policy_seqops"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic unsigned long ima_fs_flags;\n\nstatic int ima_open_policy(struct inode *inode, struct file *filp)\n{\n\tif (!(filp->f_flags & O_WRONLY)) {\n#ifndef\tCONFIG_IMA_READ_POLICY\n\t\treturn -EACCES;\n#else\n\t\tif ((filp->f_flags & O_ACCMODE) != O_RDONLY)\n\t\t\treturn -EACCES;\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn seq_open(filp, &ima_policy_seqops);\n#endif\n\t}\n\tif (test_and_set_bit(IMA_FS_BUSY, &ima_fs_flags))\n\t\treturn -EBUSY;\n\treturn 0;\n}"
  },
  {
    "function_name": "ima_write_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "312-356",
    "snippet": "static ssize_t ima_write_policy(struct file *file, const char __user *buf,\n\t\t\t\tsize_t datalen, loff_t *ppos)\n{\n\tchar *data;\n\tssize_t result;\n\n\tif (datalen >= PAGE_SIZE)\n\t\tdatalen = PAGE_SIZE - 1;\n\n\t/* No partial writes. */\n\tresult = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tdata = memdup_user_nul(buf, datalen);\n\tif (IS_ERR(data)) {\n\t\tresult = PTR_ERR(data);\n\t\tgoto out;\n\t}\n\n\tresult = mutex_lock_interruptible(&ima_write_mutex);\n\tif (result < 0)\n\t\tgoto out_free;\n\n\tif (data[0] == '/') {\n\t\tresult = ima_read_policy(data);\n\t} else if (ima_appraise & IMA_APPRAISE_POLICY) {\n\t\tpr_err(\"IMA: signed policy file (specified as an absolute pathname) required\\n\");\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL, NULL,\n\t\t\t\t    \"policy_update\", \"signed policy required\",\n\t\t\t\t    1, 0);\n\t\tif (ima_appraise & IMA_APPRAISE_ENFORCE)\n\t\t\tresult = -EACCES;\n\t} else {\n\t\tresult = ima_parse_add_rule(data);\n\t}\n\tmutex_unlock(&ima_write_mutex);\nout_free:\n\tkfree(data);\nout:\n\tif (result < 0)\n\t\tvalid_policy = 0;\n\n\treturn result;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(ima_write_mutex);",
      "static int valid_policy = 1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&ima_write_mutex"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_parse_add_rule",
          "args": [
            "data"
          ],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "ima_parse_add_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "902-938",
          "snippet": "ssize_t ima_parse_add_rule(char *rule)\n{\n\tstatic const char op[] = \"update_policy\";\n\tchar *p;\n\tstruct ima_rule_entry *entry;\n\tssize_t result, len;\n\tint audit_info = 0;\n\n\tp = strsep(&rule, \"\\n\");\n\tlen = strlen(p) + 1;\n\tp += strspn(p, \" \\t\");\n\n\tif (*p == '#' || *p == '\\0')\n\t\treturn len;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"-ENOMEM\", -ENOMEM, audit_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&entry->list);\n\n\tresult = ima_parse_rule(p, entry);\n\tif (result) {\n\t\tkfree(entry);\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"invalid-policy\", result,\n\t\t\t\t    audit_info);\n\t\treturn result;\n\t}\n\n\tlist_add_tail(&entry->list, &ima_temp_rules);\n\n\treturn len;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ima_temp_rules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(ima_temp_rules);\n\nssize_t ima_parse_add_rule(char *rule)\n{\n\tstatic const char op[] = \"update_policy\";\n\tchar *p;\n\tstruct ima_rule_entry *entry;\n\tssize_t result, len;\n\tint audit_info = 0;\n\n\tp = strsep(&rule, \"\\n\");\n\tlen = strlen(p) + 1;\n\tp += strspn(p, \" \\t\");\n\n\tif (*p == '#' || *p == '\\0')\n\t\treturn len;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"-ENOMEM\", -ENOMEM, audit_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&entry->list);\n\n\tresult = ima_parse_rule(p, entry);\n\tif (result) {\n\t\tkfree(entry);\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"invalid-policy\", result,\n\t\t\t\t    audit_info);\n\t\treturn result;\n\t}\n\n\tlist_add_tail(&entry->list, &ima_temp_rules);\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_STATUS",
            "NULL",
            "NULL",
            "\"policy_update\"",
            "\"signed policy required\"",
            "1",
            "0"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"IMA: signed policy file (specified as an absolute pathname) required\\n\""
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_read_policy",
          "args": [
            "data"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "ima_read_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
          "lines": "275-310",
          "snippet": "static ssize_t ima_read_policy(char *path)\n{\n\tvoid *data;\n\tchar *datap;\n\tloff_t size;\n\tint rc, pathlen = strlen(path);\n\n\tchar *p;\n\n\t/* remove \\n */\n\tdatap = path;\n\tstrsep(&datap, \"\\n\");\n\n\trc = kernel_read_file_from_path(path, &data, &size, 0, READING_POLICY);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to open file: %s (%d)\", path, rc);\n\t\treturn rc;\n\t}\n\n\tdatap = data;\n\twhile (size > 0 && (p = strsep(&datap, \"\\n\"))) {\n\t\tpr_debug(\"rule: %s\\n\", p);\n\t\trc = ima_parse_add_rule(p);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\tsize -= rc;\n\t}\n\n\tvfree(data);\n\tif (rc < 0)\n\t\treturn rc;\n\telse if (size)\n\t\treturn -EINVAL;\n\telse\n\t\treturn pathlen;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/parser.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rculist.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic ssize_t ima_read_policy(char *path)\n{\n\tvoid *data;\n\tchar *datap;\n\tloff_t size;\n\tint rc, pathlen = strlen(path);\n\n\tchar *p;\n\n\t/* remove \\n */\n\tdatap = path;\n\tstrsep(&datap, \"\\n\");\n\n\trc = kernel_read_file_from_path(path, &data, &size, 0, READING_POLICY);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to open file: %s (%d)\", path, rc);\n\t\treturn rc;\n\t}\n\n\tdatap = data;\n\twhile (size > 0 && (p = strsep(&datap, \"\\n\"))) {\n\t\tpr_debug(\"rule: %s\\n\", p);\n\t\trc = ima_parse_add_rule(p);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\tsize -= rc;\n\t}\n\n\tvfree(data);\n\tif (rc < 0)\n\t\treturn rc;\n\telse if (size)\n\t\treturn -EINVAL;\n\telse\n\t\treturn pathlen;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&ima_write_mutex"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "datalen"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic DEFINE_MUTEX(ima_write_mutex);\nstatic int valid_policy = 1;\n\nstatic ssize_t ima_write_policy(struct file *file, const char __user *buf,\n\t\t\t\tsize_t datalen, loff_t *ppos)\n{\n\tchar *data;\n\tssize_t result;\n\n\tif (datalen >= PAGE_SIZE)\n\t\tdatalen = PAGE_SIZE - 1;\n\n\t/* No partial writes. */\n\tresult = -EINVAL;\n\tif (*ppos != 0)\n\t\tgoto out;\n\n\tdata = memdup_user_nul(buf, datalen);\n\tif (IS_ERR(data)) {\n\t\tresult = PTR_ERR(data);\n\t\tgoto out;\n\t}\n\n\tresult = mutex_lock_interruptible(&ima_write_mutex);\n\tif (result < 0)\n\t\tgoto out_free;\n\n\tif (data[0] == '/') {\n\t\tresult = ima_read_policy(data);\n\t} else if (ima_appraise & IMA_APPRAISE_POLICY) {\n\t\tpr_err(\"IMA: signed policy file (specified as an absolute pathname) required\\n\");\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL, NULL,\n\t\t\t\t    \"policy_update\", \"signed policy required\",\n\t\t\t\t    1, 0);\n\t\tif (ima_appraise & IMA_APPRAISE_ENFORCE)\n\t\t\tresult = -EACCES;\n\t} else {\n\t\tresult = ima_parse_add_rule(data);\n\t}\n\tmutex_unlock(&ima_write_mutex);\nout_free:\n\tkfree(data);\nout:\n\tif (result < 0)\n\t\tvalid_policy = 0;\n\n\treturn result;\n}"
  },
  {
    "function_name": "ima_read_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "275-310",
    "snippet": "static ssize_t ima_read_policy(char *path)\n{\n\tvoid *data;\n\tchar *datap;\n\tloff_t size;\n\tint rc, pathlen = strlen(path);\n\n\tchar *p;\n\n\t/* remove \\n */\n\tdatap = path;\n\tstrsep(&datap, \"\\n\");\n\n\trc = kernel_read_file_from_path(path, &data, &size, 0, READING_POLICY);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to open file: %s (%d)\", path, rc);\n\t\treturn rc;\n\t}\n\n\tdatap = data;\n\twhile (size > 0 && (p = strsep(&datap, \"\\n\"))) {\n\t\tpr_debug(\"rule: %s\\n\", p);\n\t\trc = ima_parse_add_rule(p);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\tsize -= rc;\n\t}\n\n\tvfree(data);\n\tif (rc < 0)\n\t\treturn rc;\n\telse if (size)\n\t\treturn -EINVAL;\n\telse\n\t\treturn pathlen;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "data"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_parse_add_rule",
          "args": [
            "p"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "ima_parse_add_rule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "902-938",
          "snippet": "ssize_t ima_parse_add_rule(char *rule)\n{\n\tstatic const char op[] = \"update_policy\";\n\tchar *p;\n\tstruct ima_rule_entry *entry;\n\tssize_t result, len;\n\tint audit_info = 0;\n\n\tp = strsep(&rule, \"\\n\");\n\tlen = strlen(p) + 1;\n\tp += strspn(p, \" \\t\");\n\n\tif (*p == '#' || *p == '\\0')\n\t\treturn len;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"-ENOMEM\", -ENOMEM, audit_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&entry->list);\n\n\tresult = ima_parse_rule(p, entry);\n\tif (result) {\n\t\tkfree(entry);\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"invalid-policy\", result,\n\t\t\t\t    audit_info);\n\t\treturn result;\n\t}\n\n\tlist_add_tail(&entry->list, &ima_temp_rules);\n\n\treturn len;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ima_temp_rules);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(ima_temp_rules);\n\nssize_t ima_parse_add_rule(char *rule)\n{\n\tstatic const char op[] = \"update_policy\";\n\tchar *p;\n\tstruct ima_rule_entry *entry;\n\tssize_t result, len;\n\tint audit_info = 0;\n\n\tp = strsep(&rule, \"\\n\");\n\tlen = strlen(p) + 1;\n\tp += strspn(p, \" \\t\");\n\n\tif (*p == '#' || *p == '\\0')\n\t\treturn len;\n\n\tentry = kzalloc(sizeof(*entry), GFP_KERNEL);\n\tif (!entry) {\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"-ENOMEM\", -ENOMEM, audit_info);\n\t\treturn -ENOMEM;\n\t}\n\n\tINIT_LIST_HEAD(&entry->list);\n\n\tresult = ima_parse_rule(p, entry);\n\tif (result) {\n\t\tkfree(entry);\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_STATUS, NULL,\n\t\t\t\t    NULL, op, \"invalid-policy\", result,\n\t\t\t\t    audit_info);\n\t\treturn result;\n\t}\n\n\tlist_add_tail(&entry->list, &ima_temp_rules);\n\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"rule: %s\\n\"",
            "p"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&datap",
            "\"\\n\""
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to open file: %s (%d)\"",
            "path",
            "rc"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read_file_from_path",
          "args": [
            "path",
            "&data",
            "&size",
            "0",
            "READING_POLICY"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&datap",
            "\"\\n\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "path"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic ssize_t ima_read_policy(char *path)\n{\n\tvoid *data;\n\tchar *datap;\n\tloff_t size;\n\tint rc, pathlen = strlen(path);\n\n\tchar *p;\n\n\t/* remove \\n */\n\tdatap = path;\n\tstrsep(&datap, \"\\n\");\n\n\trc = kernel_read_file_from_path(path, &data, &size, 0, READING_POLICY);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to open file: %s (%d)\", path, rc);\n\t\treturn rc;\n\t}\n\n\tdatap = data;\n\twhile (size > 0 && (p = strsep(&datap, \"\\n\"))) {\n\t\tpr_debug(\"rule: %s\\n\", p);\n\t\trc = ima_parse_add_rule(p);\n\t\tif (rc < 0)\n\t\t\tbreak;\n\t\tsize -= rc;\n\t}\n\n\tvfree(data);\n\tif (rc < 0)\n\t\treturn rc;\n\telse if (size)\n\t\treturn -EINVAL;\n\telse\n\t\treturn pathlen;\n}"
  },
  {
    "function_name": "ima_ascii_measurements_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "263-266",
    "snippet": "static int ima_ascii_measurements_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &ima_ascii_measurements_seqops);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations ima_ascii_measurements_seqops = {\n\t.start = ima_measurements_start,\n\t.next = ima_measurements_next,\n\t.stop = ima_measurements_stop,\n\t.show = ima_ascii_measurements_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&ima_ascii_measurements_seqops"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic const struct seq_operations ima_ascii_measurements_seqops = {\n\t.start = ima_measurements_start,\n\t.next = ima_measurements_next,\n\t.stop = ima_measurements_stop,\n\t.show = ima_ascii_measurements_show\n};\n\nstatic int ima_ascii_measurements_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &ima_ascii_measurements_seqops);\n}"
  },
  {
    "function_name": "ima_ascii_measurements_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "218-254",
    "snippet": "static int ima_ascii_measurements_show(struct seq_file *m, void *v)\n{\n\t/* the list never shrinks, so we don't need a lock here */\n\tstruct ima_queue_entry *qe = v;\n\tstruct ima_template_entry *e;\n\tchar *template_name;\n\tint i;\n\n\t/* get entry */\n\te = qe->entry;\n\tif (e == NULL)\n\t\treturn -1;\n\n\ttemplate_name = (e->template_desc->name[0] != '\\0') ?\n\t    e->template_desc->name : e->template_desc->fmt;\n\n\t/* 1st: PCR used (config option) */\n\tseq_printf(m, \"%2d \", e->pcr);\n\n\t/* 2nd: SHA1 template hash */\n\tima_print_digest(m, e->digest, TPM_DIGEST_SIZE);\n\n\t/* 3th:  template name */\n\tseq_printf(m, \" %s\", template_name);\n\n\t/* 4th:  template specific data */\n\tfor (i = 0; i < e->template_desc->num_fields; i++) {\n\t\tseq_puts(m, \" \");\n\t\tif (e->template_data[i].len == 0)\n\t\t\tcontinue;\n\n\t\te->template_desc->fields[i]->field_show(m, IMA_SHOW_ASCII,\n\t\t\t\t\t\t\t&e->template_data[i]);\n\t}\n\tseq_puts(m, \"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "e->template_desc->fields[i]->field_show",
          "args": [
            "m",
            "IMA_SHOW_ASCII",
            "&e->template_data[i]"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" \""
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" %s\"",
            "template_name"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_print_digest",
          "args": [
            "m",
            "e->digest",
            "TPM_DIGEST_SIZE"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "ima_print_digest",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
          "lines": "209-215",
          "snippet": "void ima_print_digest(struct seq_file *m, u8 *digest, u32 size)\n{\n\tu32 i;\n\n\tfor (i = 0; i < size; i++)\n\t\tseq_printf(m, \"%02x\", *(digest + i));\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/parser.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rculist.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nvoid ima_print_digest(struct seq_file *m, u8 *digest, u32 size)\n{\n\tu32 i;\n\n\tfor (i = 0; i < size; i++)\n\t\tseq_printf(m, \"%02x\", *(digest + i));\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%2d \"",
            "e->pcr"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic int ima_ascii_measurements_show(struct seq_file *m, void *v)\n{\n\t/* the list never shrinks, so we don't need a lock here */\n\tstruct ima_queue_entry *qe = v;\n\tstruct ima_template_entry *e;\n\tchar *template_name;\n\tint i;\n\n\t/* get entry */\n\te = qe->entry;\n\tif (e == NULL)\n\t\treturn -1;\n\n\ttemplate_name = (e->template_desc->name[0] != '\\0') ?\n\t    e->template_desc->name : e->template_desc->fmt;\n\n\t/* 1st: PCR used (config option) */\n\tseq_printf(m, \"%2d \", e->pcr);\n\n\t/* 2nd: SHA1 template hash */\n\tima_print_digest(m, e->digest, TPM_DIGEST_SIZE);\n\n\t/* 3th:  template name */\n\tseq_printf(m, \" %s\", template_name);\n\n\t/* 4th:  template specific data */\n\tfor (i = 0; i < e->template_desc->num_fields; i++) {\n\t\tseq_puts(m, \" \");\n\t\tif (e->template_data[i].len == 0)\n\t\t\tcontinue;\n\n\t\te->template_desc->fields[i]->field_show(m, IMA_SHOW_ASCII,\n\t\t\t\t\t\t\t&e->template_data[i]);\n\t}\n\tseq_puts(m, \"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "ima_print_digest",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "209-215",
    "snippet": "void ima_print_digest(struct seq_file *m, u8 *digest, u32 size)\n{\n\tu32 i;\n\n\tfor (i = 0; i < size; i++)\n\t\tseq_printf(m, \"%02x\", *(digest + i));\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%02x\"",
            "*(digest + i)"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nvoid ima_print_digest(struct seq_file *m, u8 *digest, u32 size)\n{\n\tu32 i;\n\n\tfor (i = 0; i < size; i++)\n\t\tseq_printf(m, \"%02x\", *(digest + i));\n}"
  },
  {
    "function_name": "ima_measurements_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "197-200",
    "snippet": "static int ima_measurements_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &ima_measurments_seqops);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations ima_measurments_seqops = {\n\t.start = ima_measurements_start,\n\t.next = ima_measurements_next,\n\t.stop = ima_measurements_stop,\n\t.show = ima_measurements_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&ima_measurments_seqops"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic const struct seq_operations ima_measurments_seqops = {\n\t.start = ima_measurements_start,\n\t.next = ima_measurements_next,\n\t.stop = ima_measurements_stop,\n\t.show = ima_measurements_show\n};\n\nstatic int ima_measurements_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &ima_measurments_seqops);\n}"
  },
  {
    "function_name": "ima_measurements_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "129-188",
    "snippet": "int ima_measurements_show(struct seq_file *m, void *v)\n{\n\t/* the list never shrinks, so we don't need a lock here */\n\tstruct ima_queue_entry *qe = v;\n\tstruct ima_template_entry *e;\n\tchar *template_name;\n\tu32 pcr, namelen, template_data_len; /* temporary fields */\n\tbool is_ima_template = false;\n\tint i;\n\n\t/* get entry */\n\te = qe->entry;\n\tif (e == NULL)\n\t\treturn -1;\n\n\ttemplate_name = (e->template_desc->name[0] != '\\0') ?\n\t    e->template_desc->name : e->template_desc->fmt;\n\n\t/*\n\t * 1st: PCRIndex\n\t * PCR used defaults to the same (config option) in\n\t * little-endian format, unless set in policy\n\t */\n\tpcr = !ima_canonical_fmt ? e->pcr : cpu_to_le32(e->pcr);\n\tima_putc(m, &pcr, sizeof(e->pcr));\n\n\t/* 2nd: template digest */\n\tima_putc(m, e->digest, TPM_DIGEST_SIZE);\n\n\t/* 3rd: template name size */\n\tnamelen = !ima_canonical_fmt ? strlen(template_name) :\n\t\tcpu_to_le32(strlen(template_name));\n\tima_putc(m, &namelen, sizeof(namelen));\n\n\t/* 4th:  template name */\n\tima_putc(m, template_name, strlen(template_name));\n\n\t/* 5th:  template length (except for 'ima' template) */\n\tif (strcmp(template_name, IMA_TEMPLATE_IMA_NAME) == 0)\n\t\tis_ima_template = true;\n\n\tif (!is_ima_template) {\n\t\ttemplate_data_len = !ima_canonical_fmt ? e->template_data_len :\n\t\t\tcpu_to_le32(e->template_data_len);\n\t\tima_putc(m, &template_data_len, sizeof(e->template_data_len));\n\t}\n\n\t/* 6th:  template specific data */\n\tfor (i = 0; i < e->template_desc->num_fields; i++) {\n\t\tenum ima_show_type show = IMA_SHOW_BINARY;\n\t\tstruct ima_template_field *field = e->template_desc->fields[i];\n\n\t\tif (is_ima_template && strcmp(field->field_id, \"d\") == 0)\n\t\t\tshow = IMA_SHOW_BINARY_NO_FIELD_LEN;\n\t\tif (is_ima_template && strcmp(field->field_id, \"n\") == 0)\n\t\t\tshow = IMA_SHOW_BINARY_OLD_STRING_FMT;\n\t\tfield->field_show(m, show, &e->template_data[i]);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool ima_canonical_fmt;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "field->field_show",
          "args": [
            "m",
            "show",
            "&e->template_data[i]"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->field_id",
            "\"n\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->field_id",
            "\"d\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_putc",
          "args": [
            "m",
            "&template_data_len",
            "sizeof(e->template_data_len)"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "ima_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
          "lines": "115-119",
          "snippet": "void ima_putc(struct seq_file *m, void *data, int datalen)\n{\n\twhile (datalen--)\n\t\tseq_putc(m, *(char *)data++);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/parser.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rculist.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nvoid ima_putc(struct seq_file *m, void *data, int datalen)\n{\n\twhile (datalen--)\n\t\tseq_putc(m, *(char *)data++);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "e->template_data_len"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "template_name",
            "IMA_TEMPLATE_IMA_NAME"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "template_name"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "strlen(template_name)"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "template_name"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "template_name"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "e->pcr"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nbool ima_canonical_fmt;\n\nint ima_measurements_show(struct seq_file *m, void *v)\n{\n\t/* the list never shrinks, so we don't need a lock here */\n\tstruct ima_queue_entry *qe = v;\n\tstruct ima_template_entry *e;\n\tchar *template_name;\n\tu32 pcr, namelen, template_data_len; /* temporary fields */\n\tbool is_ima_template = false;\n\tint i;\n\n\t/* get entry */\n\te = qe->entry;\n\tif (e == NULL)\n\t\treturn -1;\n\n\ttemplate_name = (e->template_desc->name[0] != '\\0') ?\n\t    e->template_desc->name : e->template_desc->fmt;\n\n\t/*\n\t * 1st: PCRIndex\n\t * PCR used defaults to the same (config option) in\n\t * little-endian format, unless set in policy\n\t */\n\tpcr = !ima_canonical_fmt ? e->pcr : cpu_to_le32(e->pcr);\n\tima_putc(m, &pcr, sizeof(e->pcr));\n\n\t/* 2nd: template digest */\n\tima_putc(m, e->digest, TPM_DIGEST_SIZE);\n\n\t/* 3rd: template name size */\n\tnamelen = !ima_canonical_fmt ? strlen(template_name) :\n\t\tcpu_to_le32(strlen(template_name));\n\tima_putc(m, &namelen, sizeof(namelen));\n\n\t/* 4th:  template name */\n\tima_putc(m, template_name, strlen(template_name));\n\n\t/* 5th:  template length (except for 'ima' template) */\n\tif (strcmp(template_name, IMA_TEMPLATE_IMA_NAME) == 0)\n\t\tis_ima_template = true;\n\n\tif (!is_ima_template) {\n\t\ttemplate_data_len = !ima_canonical_fmt ? e->template_data_len :\n\t\t\tcpu_to_le32(e->template_data_len);\n\t\tima_putc(m, &template_data_len, sizeof(e->template_data_len));\n\t}\n\n\t/* 6th:  template specific data */\n\tfor (i = 0; i < e->template_desc->num_fields; i++) {\n\t\tenum ima_show_type show = IMA_SHOW_BINARY;\n\t\tstruct ima_template_field *field = e->template_desc->fields[i];\n\n\t\tif (is_ima_template && strcmp(field->field_id, \"d\") == 0)\n\t\t\tshow = IMA_SHOW_BINARY_NO_FIELD_LEN;\n\t\tif (is_ima_template && strcmp(field->field_id, \"n\") == 0)\n\t\t\tshow = IMA_SHOW_BINARY_OLD_STRING_FMT;\n\t\tfield->field_show(m, show, &e->template_data[i]);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ima_putc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "115-119",
    "snippet": "void ima_putc(struct seq_file *m, void *data, int datalen)\n{\n\twhile (datalen--)\n\t\tseq_putc(m, *(char *)data++);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "*(char *)data++"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nvoid ima_putc(struct seq_file *m, void *data, int datalen)\n{\n\twhile (datalen--)\n\t\tseq_putc(m, *(char *)data++);\n}"
  },
  {
    "function_name": "ima_measurements_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "111-113",
    "snippet": "static void ima_measurements_stop(struct seq_file *m, void *v)\n{\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic void ima_measurements_stop(struct seq_file *m, void *v)\n{\n}"
  },
  {
    "function_name": "ima_measurements_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "96-109",
    "snippet": "static void *ima_measurements_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ima_queue_entry *qe = v;\n\n\t/* lock protects when reading beyond last element\n\t * against concurrent list-extension\n\t */\n\trcu_read_lock();\n\tqe = list_entry_rcu(qe->later.next, struct ima_queue_entry, later);\n\trcu_read_unlock();\n\t(*pos)++;\n\n\treturn (&qe->later == &ima_measurements) ? NULL : qe;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry_rcu",
          "args": [
            "qe->later.next",
            "structima_queue_entry",
            "later"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic void *ima_measurements_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\tstruct ima_queue_entry *qe = v;\n\n\t/* lock protects when reading beyond last element\n\t * against concurrent list-extension\n\t */\n\trcu_read_lock();\n\tqe = list_entry_rcu(qe->later.next, struct ima_queue_entry, later);\n\trcu_read_unlock();\n\t(*pos)++;\n\n\treturn (&qe->later == &ima_measurements) ? NULL : qe;\n}"
  },
  {
    "function_name": "ima_measurements_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "79-94",
    "snippet": "static void *ima_measurements_start(struct seq_file *m, loff_t *pos)\n{\n\tloff_t l = *pos;\n\tstruct ima_queue_entry *qe;\n\n\t/* we need a lock since pos could point beyond last element */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(qe, &ima_measurements, later) {\n\t\tif (!l--) {\n\t\t\trcu_read_unlock();\n\t\t\treturn qe;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "qe",
            "&ima_measurements",
            "later"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic void *ima_measurements_start(struct seq_file *m, loff_t *pos)\n{\n\tloff_t l = *pos;\n\tstruct ima_queue_entry *qe;\n\n\t/* we need a lock since pos could point beyond last element */\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(qe, &ima_measurements, later) {\n\t\tif (!l--) {\n\t\t\trcu_read_unlock();\n\t\t\treturn qe;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn NULL;\n}"
  },
  {
    "function_name": "ima_show_measurements_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "65-71",
    "snippet": "static ssize_t ima_show_measurements_count(struct file *filp,\n\t\t\t\t\t   char __user *buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\treturn ima_show_htable_value(buf, count, ppos, &ima_htable.len);\n\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_show_htable_value",
          "args": [
            "buf",
            "count",
            "ppos",
            "&ima_htable.len"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "ima_show_htable_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
          "lines": "43-51",
          "snippet": "static ssize_t ima_show_htable_value(char __user *buf, size_t count,\n\t\t\t\t     loff_t *ppos, atomic_long_t *val)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t len;\n\n\tlen = scnprintf(tmpbuf, TMPBUFLEN, \"%li\\n\", atomic_long_read(val));\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, len);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/parser.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rculist.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>"
          ],
          "macros_used": [
            "#define TMPBUFLEN 12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\n#define TMPBUFLEN 12\n\nstatic ssize_t ima_show_htable_value(char __user *buf, size_t count,\n\t\t\t\t     loff_t *ppos, atomic_long_t *val)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t len;\n\n\tlen = scnprintf(tmpbuf, TMPBUFLEN, \"%li\\n\", atomic_long_read(val));\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic ssize_t ima_show_measurements_count(struct file *filp,\n\t\t\t\t\t   char __user *buf,\n\t\t\t\t\t   size_t count, loff_t *ppos)\n{\n\treturn ima_show_htable_value(buf, count, ppos, &ima_htable.len);\n\n}"
  },
  {
    "function_name": "ima_show_htable_violations",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "53-58",
    "snippet": "static ssize_t ima_show_htable_violations(struct file *filp,\n\t\t\t\t\t  char __user *buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn ima_show_htable_value(buf, count, ppos, &ima_htable.violations);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *violations;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_show_htable_value",
          "args": [
            "buf",
            "count",
            "ppos",
            "&ima_htable.violations"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "ima_show_htable_value",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
          "lines": "43-51",
          "snippet": "static ssize_t ima_show_htable_value(char __user *buf, size_t count,\n\t\t\t\t     loff_t *ppos, atomic_long_t *val)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t len;\n\n\tlen = scnprintf(tmpbuf, TMPBUFLEN, \"%li\\n\", atomic_long_read(val));\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, len);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/parser.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rculist.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>"
          ],
          "macros_used": [
            "#define TMPBUFLEN 12"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\n#define TMPBUFLEN 12\n\nstatic ssize_t ima_show_htable_value(char __user *buf, size_t count,\n\t\t\t\t     loff_t *ppos, atomic_long_t *val)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t len;\n\n\tlen = scnprintf(tmpbuf, TMPBUFLEN, \"%li\\n\", atomic_long_read(val));\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, len);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nstatic struct dentry *violations;\n\nstatic ssize_t ima_show_htable_violations(struct file *filp,\n\t\t\t\t\t  char __user *buf,\n\t\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn ima_show_htable_value(buf, count, ppos, &ima_htable.violations);\n}"
  },
  {
    "function_name": "ima_show_htable_value",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "43-51",
    "snippet": "static ssize_t ima_show_htable_value(char __user *buf, size_t count,\n\t\t\t\t     loff_t *ppos, atomic_long_t *val)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t len;\n\n\tlen = scnprintf(tmpbuf, TMPBUFLEN, \"%li\\n\", atomic_long_read(val));\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, len);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [
      "#define TMPBUFLEN 12"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "tmpbuf",
            "len"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scnprintf",
          "args": [
            "tmpbuf",
            "TMPBUFLEN",
            "\"%li\\n\"",
            "atomic_long_read(val)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "val"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\n#define TMPBUFLEN 12\n\nstatic ssize_t ima_show_htable_value(char __user *buf, size_t count,\n\t\t\t\t     loff_t *ppos, atomic_long_t *val)\n{\n\tchar tmpbuf[TMPBUFLEN];\n\tssize_t len;\n\n\tlen = scnprintf(tmpbuf, TMPBUFLEN, \"%li\\n\", atomic_long_read(val));\n\treturn simple_read_from_buffer(buf, count, ppos, tmpbuf, len);\n}"
  },
  {
    "function_name": "default_canonical_fmt_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
    "lines": "32-38",
    "snippet": "static int __init default_canonical_fmt_setup(char *str)\n{\n#ifdef __BIG_ENDIAN\n\tima_canonical_fmt = true;\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/vmalloc.h>",
      "#include <linux/parser.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/rculist.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/module.h>",
      "#include <linux/slab.h>",
      "#include <linux/fcntl.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "bool ima_canonical_fmt;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nbool ima_canonical_fmt;\n\nstatic int __init default_canonical_fmt_setup(char *str)\n{\n#ifdef __BIG_ENDIAN\n\tima_canonical_fmt = true;\n#endif\n\treturn 1;\n}"
  }
]