[
  {
    "function_name": "aa_setprocattr_changehat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/procattr.c",
    "lines": "106-142",
    "snippet": "int aa_setprocattr_changehat(char *args, size_t size, int flags)\n{\n\tchar *hat;\n\tu64 token;\n\tconst char *hats[16];\t\t/* current hard limit on # of names */\n\tint count = 0;\n\n\that = split_token_from_name(OP_CHANGE_HAT, args, &token);\n\tif (IS_ERR(hat))\n\t\treturn PTR_ERR(hat);\n\n\tif (!hat && !token) {\n\t\tAA_ERROR(\"change_hat: Invalid input, NULL hat and NULL magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hat) {\n\t\t/* set up hat name vector, args guaranteed null terminated\n\t\t * at args[size] by setprocattr.\n\t\t *\n\t\t * If there are multiple hat names in the buffer each is\n\t\t * separated by a \\0.  Ie. userspace writes them pre tokenized\n\t\t */\n\t\tchar *end = args + size;\n\t\tfor (count = 0; (hat < end) && count < 16; ++count) {\n\t\t\tchar *next = hat + strlen(hat) + 1;\n\t\t\thats[count] = hat;\n\t\t\tAA_DEBUG(\"%s: (pid %d) Magic 0x%llx count %d hat '%s'\\n\"\n\t\t\t\t , __func__, current->pid, token, count, hat);\n\t\t\that = next;\n\t\t}\n\t} else\n\t\tAA_DEBUG(\"%s: (pid %d) Magic 0x%llx count %d Hat '%s'\\n\",\n\t\t\t __func__, current->pid, token, count, \"<NULL>\");\n\n\treturn aa_change_hat(hats, count, token, flags);\n}",
    "includes": [
      "#include \"include/procattr.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_change_hat",
          "args": [
            "hats",
            "count",
            "token",
            "flags"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "aa_change_hat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/domain.c",
          "lines": "1048-1135",
          "snippet": "int aa_change_hat(const char *hats[], int count, u64 token, int flags)\n{\n\tconst struct cred *cred;\n\tstruct aa_task_ctx *ctx;\n\tstruct aa_label *label, *previous, *new = NULL, *target = NULL;\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tconst char *info = NULL;\n\tint error = 0;\n\n\t/*\n\t * Fail explicitly requested domain transitions if no_new_privs.\n\t * There is no exception for unconfined as change_hat is not\n\t * available.\n\t */\n\tif (task_no_new_privs(current)) {\n\t\t/* not an apparmor denial per se, so don't log it */\n\t\tAA_DEBUG(\"no_new_privs - change_hat denied\");\n\t\treturn -EPERM;\n\t}\n\n\t/* released below */\n\tcred = get_current_cred();\n\tctx = cred_ctx(cred);\n\tlabel = aa_get_newest_cred_label(cred);\n\tprevious = aa_get_newest_label(ctx->previous);\n\n\tif (unconfined(label)) {\n\t\tinfo = \"unconfined can not change_hat\";\n\t\terror = -EPERM;\n\t\tgoto fail;\n\t}\n\n\tif (count) {\n\t\tnew = change_hat(label, hats, count, flags);\n\t\tAA_BUG(!new);\n\t\tif (IS_ERR(new)) {\n\t\t\terror = PTR_ERR(new);\n\t\t\tnew = NULL;\n\t\t\t/* already audited */\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = may_change_ptraced_domain(new, &info);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tif (flags & AA_CHANGE_TEST)\n\t\t\tgoto out;\n\n\t\ttarget = new;\n\t\terror = aa_set_current_hat(new, token);\n\t\tif (error == -EACCES)\n\t\t\t/* kill task in case of brute force attacks */\n\t\t\tgoto kill;\n\t} else if (previous && !(flags & AA_CHANGE_TEST)) {\n\t\t/* Return to saved label.  Kill task if restore fails\n\t\t * to avoid brute force attacks\n\t\t */\n\t\ttarget = previous;\n\t\terror = aa_restore_previous_label(token);\n\t\tif (error) {\n\t\t\tif (error == -EACCES)\n\t\t\t\tgoto kill;\n\t\t\tgoto fail;\n\t\t}\n\t} /* else ignore @flags && restores when there is no saved profile */\n\nout:\n\taa_put_label(new);\n\taa_put_label(previous);\n\taa_put_label(label);\n\tput_cred(cred);\n\n\treturn error;\n\nkill:\n\tinfo = \"failed token match\";\n\tperms.kill = AA_MAY_CHANGEHAT;\n\nfail:\n\tfn_for_each_in_ns(label, profile,\n\t\taa_audit_file(profile, &perms, OP_CHANGE_HAT,\n\t\t\t      AA_MAY_CHANGEHAT, NULL, NULL, target,\n\t\t\t      GLOBAL_ROOT_UID, info, error));\n\n\tgoto out;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/personality.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/mount.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/audit.h\"\n#include <linux/personality.h>\n#include <linux/tracehook.h>\n#include <linux/syscalls.h>\n#include <linux/mount.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/errno.h>\n\nint aa_change_hat(const char *hats[], int count, u64 token, int flags)\n{\n\tconst struct cred *cred;\n\tstruct aa_task_ctx *ctx;\n\tstruct aa_label *label, *previous, *new = NULL, *target = NULL;\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tconst char *info = NULL;\n\tint error = 0;\n\n\t/*\n\t * Fail explicitly requested domain transitions if no_new_privs.\n\t * There is no exception for unconfined as change_hat is not\n\t * available.\n\t */\n\tif (task_no_new_privs(current)) {\n\t\t/* not an apparmor denial per se, so don't log it */\n\t\tAA_DEBUG(\"no_new_privs - change_hat denied\");\n\t\treturn -EPERM;\n\t}\n\n\t/* released below */\n\tcred = get_current_cred();\n\tctx = cred_ctx(cred);\n\tlabel = aa_get_newest_cred_label(cred);\n\tprevious = aa_get_newest_label(ctx->previous);\n\n\tif (unconfined(label)) {\n\t\tinfo = \"unconfined can not change_hat\";\n\t\terror = -EPERM;\n\t\tgoto fail;\n\t}\n\n\tif (count) {\n\t\tnew = change_hat(label, hats, count, flags);\n\t\tAA_BUG(!new);\n\t\tif (IS_ERR(new)) {\n\t\t\terror = PTR_ERR(new);\n\t\t\tnew = NULL;\n\t\t\t/* already audited */\n\t\t\tgoto out;\n\t\t}\n\n\t\terror = may_change_ptraced_domain(new, &info);\n\t\tif (error)\n\t\t\tgoto fail;\n\n\t\tif (flags & AA_CHANGE_TEST)\n\t\t\tgoto out;\n\n\t\ttarget = new;\n\t\terror = aa_set_current_hat(new, token);\n\t\tif (error == -EACCES)\n\t\t\t/* kill task in case of brute force attacks */\n\t\t\tgoto kill;\n\t} else if (previous && !(flags & AA_CHANGE_TEST)) {\n\t\t/* Return to saved label.  Kill task if restore fails\n\t\t * to avoid brute force attacks\n\t\t */\n\t\ttarget = previous;\n\t\terror = aa_restore_previous_label(token);\n\t\tif (error) {\n\t\t\tif (error == -EACCES)\n\t\t\t\tgoto kill;\n\t\t\tgoto fail;\n\t\t}\n\t} /* else ignore @flags && restores when there is no saved profile */\n\nout:\n\taa_put_label(new);\n\taa_put_label(previous);\n\taa_put_label(label);\n\tput_cred(cred);\n\n\treturn error;\n\nkill:\n\tinfo = \"failed token match\";\n\tperms.kill = AA_MAY_CHANGEHAT;\n\nfail:\n\tfn_for_each_in_ns(label, profile,\n\t\taa_audit_file(profile, &perms, OP_CHANGE_HAT,\n\t\t\t      AA_MAY_CHANGEHAT, NULL, NULL, target,\n\t\t\t      GLOBAL_ROOT_UID, info, error));\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_DEBUG",
          "args": [
            "\"%s: (pid %d) Magic 0x%llx count %d Hat '%s'\\n\"",
            "__func__",
            "current->pid",
            "token",
            "count",
            "\"<NULL>\""
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_DEBUG",
          "args": [
            "\"%s: (pid %d) Magic 0x%llx count %d hat '%s'\\n\"",
            "__func__",
            "current->pid",
            "token",
            "count",
            "hat"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hat"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_ERROR",
          "args": [
            "\"change_hat: Invalid input, NULL hat and NULL magic\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hat"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hat"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "split_token_from_name",
          "args": [
            "OP_CHANGE_HAT",
            "args",
            "&token"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "split_token_from_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/procattr.c",
          "lines": "82-96",
          "snippet": "static char *split_token_from_name(const char *op, char *args, u64 *token)\n{\n\tchar *name;\n\n\t*token = simple_strtoull(args, &name, 16);\n\tif ((name == args) || *name != '^') {\n\t\tAA_ERROR(\"%s: Invalid input '%s'\", op, args);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tname++;\t\t\t/* skip ^ */\n\tif (!*name)\n\t\tname = NULL;\n\treturn name;\n}",
          "includes": [
            "#include \"include/procattr.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/procattr.h\"\n#include \"include/domain.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n\nstatic char *split_token_from_name(const char *op, char *args, u64 *token)\n{\n\tchar *name;\n\n\t*token = simple_strtoull(args, &name, 16);\n\tif ((name == args) || *name != '^') {\n\t\tAA_ERROR(\"%s: Invalid input '%s'\", op, args);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tname++;\t\t\t/* skip ^ */\n\tif (!*name)\n\t\tname = NULL;\n\treturn name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/procattr.h\"\n#include \"include/domain.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n\nint aa_setprocattr_changehat(char *args, size_t size, int flags)\n{\n\tchar *hat;\n\tu64 token;\n\tconst char *hats[16];\t\t/* current hard limit on # of names */\n\tint count = 0;\n\n\that = split_token_from_name(OP_CHANGE_HAT, args, &token);\n\tif (IS_ERR(hat))\n\t\treturn PTR_ERR(hat);\n\n\tif (!hat && !token) {\n\t\tAA_ERROR(\"change_hat: Invalid input, NULL hat and NULL magic\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (hat) {\n\t\t/* set up hat name vector, args guaranteed null terminated\n\t\t * at args[size] by setprocattr.\n\t\t *\n\t\t * If there are multiple hat names in the buffer each is\n\t\t * separated by a \\0.  Ie. userspace writes them pre tokenized\n\t\t */\n\t\tchar *end = args + size;\n\t\tfor (count = 0; (hat < end) && count < 16; ++count) {\n\t\t\tchar *next = hat + strlen(hat) + 1;\n\t\t\thats[count] = hat;\n\t\t\tAA_DEBUG(\"%s: (pid %d) Magic 0x%llx count %d hat '%s'\\n\"\n\t\t\t\t , __func__, current->pid, token, count, hat);\n\t\t\that = next;\n\t\t}\n\t} else\n\t\tAA_DEBUG(\"%s: (pid %d) Magic 0x%llx count %d Hat '%s'\\n\",\n\t\t\t __func__, current->pid, token, count, \"<NULL>\");\n\n\treturn aa_change_hat(hats, count, token, flags);\n}"
  },
  {
    "function_name": "split_token_from_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/procattr.c",
    "lines": "82-96",
    "snippet": "static char *split_token_from_name(const char *op, char *args, u64 *token)\n{\n\tchar *name;\n\n\t*token = simple_strtoull(args, &name, 16);\n\tif ((name == args) || *name != '^') {\n\t\tAA_ERROR(\"%s: Invalid input '%s'\", op, args);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tname++;\t\t\t/* skip ^ */\n\tif (!*name)\n\t\tname = NULL;\n\treturn name;\n}",
    "includes": [
      "#include \"include/procattr.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_ERROR",
          "args": [
            "\"%s: Invalid input '%s'\"",
            "op",
            "args"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoull",
          "args": [
            "args",
            "&name",
            "16"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/procattr.h\"\n#include \"include/domain.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n\nstatic char *split_token_from_name(const char *op, char *args, u64 *token)\n{\n\tchar *name;\n\n\t*token = simple_strtoull(args, &name, 16);\n\tif ((name == args) || *name != '^') {\n\t\tAA_ERROR(\"%s: Invalid input '%s'\", op, args);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tname++;\t\t\t/* skip ^ */\n\tif (!*name)\n\t\tname = NULL;\n\treturn name;\n}"
  },
  {
    "function_name": "aa_getprocattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/procattr.c",
    "lines": "37-72",
    "snippet": "int aa_getprocattr(struct aa_label *label, char **string)\n{\n\tstruct aa_ns *ns = labels_ns(label);\n\tstruct aa_ns *current_ns = aa_get_current_ns();\n\tint len;\n\n\tif (!aa_ns_visible(current_ns, ns, true)) {\n\t\taa_put_ns(current_ns);\n\t\treturn -EACCES;\n\t}\n\n\tlen = aa_label_snxprint(NULL, 0, current_ns, label,\n\t\t\t\tFLAG_SHOW_MODE | FLAG_VIEW_SUBNS |\n\t\t\t\tFLAG_HIDDEN_UNCONFINED);\n\tAA_BUG(len < 0);\n\n\t*string = kmalloc(len + 2, GFP_KERNEL);\n\tif (!*string) {\n\t\taa_put_ns(current_ns);\n\t\treturn -ENOMEM;\n\t}\n\n\tlen = aa_label_snxprint(*string, len + 2, current_ns, label,\n\t\t\t\tFLAG_SHOW_MODE | FLAG_VIEW_SUBNS |\n\t\t\t\tFLAG_HIDDEN_UNCONFINED);\n\tif (len < 0) {\n\t\taa_put_ns(current_ns);\n\t\treturn len;\n\t}\n\n\t(*string)[len] = '\\n';\n\t(*string)[len + 1] = 0;\n\n\taa_put_ns(current_ns);\n\treturn len + 1;\n}",
    "includes": [
      "#include \"include/procattr.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/policy_ns.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/context.h\"",
      "#include \"include/apparmor.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_ns",
          "args": [
            "current_ns"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy_ns.h",
          "lines": "130-134",
          "snippet": "static inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}",
          "includes": [
            "#include \"policy.h\"",
            "#include \"label.h\"",
            "#include \"apparmorfs.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/kref.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy.h\"\n#include \"label.h\"\n#include \"apparmorfs.h\"\n#include \"apparmor.h\"\n#include <linux/kref.h>\n\nstatic inline void aa_put_ns(struct aa_ns *ns)\n{\n\tif (ns)\n\t\taa_put_profile(ns->unconfined);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_snxprint",
          "args": [
            "*string",
            "len + 2",
            "current_ns",
            "label",
            "FLAG_SHOW_MODE | FLAG_VIEW_SUBNS |\n\t\t\t\tFLAG_HIDDEN_UNCONFINED"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_snxprint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1598-1648",
          "snippet": "int aa_label_snxprint(char *str, size_t size, struct aa_ns *ns,\n\t\t      struct aa_label *label, int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ns *prev_ns = NULL;\n\tstruct label_it i;\n\tint count = 0, total = 0;\n\tsize_t len;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!label);\n\n\tif (flags & FLAG_ABS_ROOT) {\n\t\tns = root_ns;\n\t\tlen = snprintf(str, size, \"=\");\n\t\tupdate_for_len(total, len, size, str);\n\t} else if (!ns) {\n\t\tns = labels_ns(label);\n\t}\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (count > 0) {\n\t\t\t\tlen = snprintf(str, size, \"//&\");\n\t\t\t\tupdate_for_len(total, len, size, str);\n\t\t\t}\n\t\t\tlen = aa_profile_snxprint(str, size, ns, profile,\n\t\t\t\t\t\t  flags & FLAG_VIEW_SUBNS,\n\t\t\t\t\t\t  &prev_ns);\n\t\t\tupdate_for_len(total, len, size, str);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count == 0) {\n\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\treturn snprintf(str, size, \"%s\", aa_hidden_ns_name);\n\t}\n\n\t/* count == 1 && ... is for backwards compat where the mode\n\t * is not displayed for 'unconfined' in the current ns\n\t */\n\tif (display_mode(ns, label, flags)) {\n\t\tlen = snprintf(str, size, \" (%s)\",\n\t\t\t       label_modename(ns, label, flags));\n\t\tupdate_for_len(total, len, size, str);\n\t}\n\n\treturn total;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nint aa_label_snxprint(char *str, size_t size, struct aa_ns *ns,\n\t\t      struct aa_label *label, int flags)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_ns *prev_ns = NULL;\n\tstruct label_it i;\n\tint count = 0, total = 0;\n\tsize_t len;\n\n\tAA_BUG(!str && size != 0);\n\tAA_BUG(!label);\n\n\tif (flags & FLAG_ABS_ROOT) {\n\t\tns = root_ns;\n\t\tlen = snprintf(str, size, \"=\");\n\t\tupdate_for_len(total, len, size, str);\n\t} else if (!ns) {\n\t\tns = labels_ns(label);\n\t}\n\n\tlabel_for_each(i, label, profile) {\n\t\tif (aa_ns_visible(ns, profile->ns, flags & FLAG_VIEW_SUBNS)) {\n\t\t\tif (count > 0) {\n\t\t\t\tlen = snprintf(str, size, \"//&\");\n\t\t\t\tupdate_for_len(total, len, size, str);\n\t\t\t}\n\t\t\tlen = aa_profile_snxprint(str, size, ns, profile,\n\t\t\t\t\t\t  flags & FLAG_VIEW_SUBNS,\n\t\t\t\t\t\t  &prev_ns);\n\t\t\tupdate_for_len(total, len, size, str);\n\t\t\tcount++;\n\t\t}\n\t}\n\n\tif (count == 0) {\n\t\tif (flags & FLAG_HIDDEN_UNCONFINED)\n\t\t\treturn snprintf(str, size, \"%s\", \"unconfined\");\n\t\treturn snprintf(str, size, \"%s\", aa_hidden_ns_name);\n\t}\n\n\t/* count == 1 && ... is for backwards compat where the mode\n\t * is not displayed for 'unconfined' in the current ns\n\t */\n\tif (display_mode(ns, label, flags)) {\n\t\tlen = snprintf(str, size, \" (%s)\",\n\t\t\t       label_modename(ns, label, flags));\n\t\tupdate_for_len(total, len, size, str);\n\t}\n\n\treturn total;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 2",
            "GFP_KERNEL"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "len < 0"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_ns_visible",
          "args": [
            "current_ns",
            "ns",
            "true"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "aa_ns_visible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy_ns.c",
          "lines": "41-55",
          "snippet": "bool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/list.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/list.h>\n\nbool aa_ns_visible(struct aa_ns *curr, struct aa_ns *view, bool subns)\n{\n\tif (curr == view)\n\t\treturn true;\n\n\tif (!subns)\n\t\treturn false;\n\n\tfor ( ; view; view = view->parent) {\n\t\tif (view->parent == curr)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_current_ns",
          "args": [],
          "line": 40
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_current_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "204-214",
          "snippet": "static inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_ns *aa_get_current_ns(void)\n{\n\tstruct aa_label *label;\n\tstruct aa_ns *ns;\n\n\tlabel  = __begin_current_label_crit_section();\n\tns = aa_get_ns(labels_ns(label));\n\t__end_current_label_crit_section(label);\n\n\treturn ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "label"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/procattr.h\"\n#include \"include/domain.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n\nint aa_getprocattr(struct aa_label *label, char **string)\n{\n\tstruct aa_ns *ns = labels_ns(label);\n\tstruct aa_ns *current_ns = aa_get_current_ns();\n\tint len;\n\n\tif (!aa_ns_visible(current_ns, ns, true)) {\n\t\taa_put_ns(current_ns);\n\t\treturn -EACCES;\n\t}\n\n\tlen = aa_label_snxprint(NULL, 0, current_ns, label,\n\t\t\t\tFLAG_SHOW_MODE | FLAG_VIEW_SUBNS |\n\t\t\t\tFLAG_HIDDEN_UNCONFINED);\n\tAA_BUG(len < 0);\n\n\t*string = kmalloc(len + 2, GFP_KERNEL);\n\tif (!*string) {\n\t\taa_put_ns(current_ns);\n\t\treturn -ENOMEM;\n\t}\n\n\tlen = aa_label_snxprint(*string, len + 2, current_ns, label,\n\t\t\t\tFLAG_SHOW_MODE | FLAG_VIEW_SUBNS |\n\t\t\t\tFLAG_HIDDEN_UNCONFINED);\n\tif (len < 0) {\n\t\taa_put_ns(current_ns);\n\t\treturn len;\n\t}\n\n\t(*string)[len] = '\\n';\n\t(*string)[len + 1] = 0;\n\n\taa_put_ns(current_ns);\n\treturn len + 1;\n}"
  }
]