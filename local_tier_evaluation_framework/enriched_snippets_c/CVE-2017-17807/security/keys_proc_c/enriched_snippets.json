[
  {
    "function_name": "proc_key_users_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "334-354",
    "snippet": "static int proc_key_users_show(struct seq_file *m, void *v)\n{\n\tstruct rb_node *_p = v;\n\tstruct key_user *user = rb_entry(_p, struct key_user, node);\n\tunsigned maxkeys = uid_eq(user->uid, GLOBAL_ROOT_UID) ?\n\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\tunsigned maxbytes = uid_eq(user->uid, GLOBAL_ROOT_UID) ?\n\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\tseq_printf(m, \"%5u: %5d %d/%d %d/%d %d/%d\\n\",\n\t\t   from_kuid_munged(seq_user_ns(m), user->uid),\n\t\t   refcount_read(&user->usage),\n\t\t   atomic_read(&user->nkeys),\n\t\t   atomic_read(&user->nikeys),\n\t\t   user->qnkeys,\n\t\t   maxkeys,\n\t\t   user->qnbytes,\n\t\t   maxbytes);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void proc_keys_stop(struct seq_file *p, void *v);",
      "static int proc_keys_show(struct seq_file *m, void *v);",
      "static void proc_key_users_stop(struct seq_file *p, void *v);",
      "static int proc_key_users_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%5u: %5d %d/%d %d/%d %d/%d\\n\"",
            "from_kuid_munged(seq_user_ns(m), user->uid)",
            "refcount_read(&user->usage)",
            "atomic_read(&user->nkeys)",
            "atomic_read(&user->nikeys)",
            "user->qnkeys",
            "maxkeys",
            "user->qnbytes",
            "maxbytes"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&user->nikeys"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&user->nkeys"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&user->usage"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "seq_user_ns(m)",
            "user->uid"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "m"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "user->uid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "user->uid",
            "GLOBAL_ROOT_UID"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "_p",
            "structkey_user",
            "node"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void proc_keys_stop(struct seq_file *p, void *v);\nstatic int proc_keys_show(struct seq_file *m, void *v);\nstatic void proc_key_users_stop(struct seq_file *p, void *v);\nstatic int proc_key_users_show(struct seq_file *m, void *v);\n\nstatic int proc_key_users_show(struct seq_file *m, void *v)\n{\n\tstruct rb_node *_p = v;\n\tstruct key_user *user = rb_entry(_p, struct key_user, node);\n\tunsigned maxkeys = uid_eq(user->uid, GLOBAL_ROOT_UID) ?\n\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\tunsigned maxbytes = uid_eq(user->uid, GLOBAL_ROOT_UID) ?\n\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\tseq_printf(m, \"%5u: %5d %d/%d %d/%d %d/%d\\n\",\n\t\t   from_kuid_munged(seq_user_ns(m), user->uid),\n\t\t   refcount_read(&user->usage),\n\t\t   atomic_read(&user->nkeys),\n\t\t   atomic_read(&user->nikeys),\n\t\t   user->qnkeys,\n\t\t   maxkeys,\n\t\t   user->qnbytes,\n\t\t   maxbytes);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_key_users_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "328-332",
    "snippet": "static void proc_key_users_stop(struct seq_file *p, void *v)\n\t__releases(key_user_lock)\n{\n\tspin_unlock(&key_user_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void proc_keys_stop(struct seq_file *p, void *v);",
      "static int proc_keys_show(struct seq_file *m, void *v);",
      "static void proc_key_users_stop(struct seq_file *p, void *v);",
      "static int proc_key_users_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&key_user_lock"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "key_user_lock"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void proc_keys_stop(struct seq_file *p, void *v);\nstatic int proc_keys_show(struct seq_file *m, void *v);\nstatic void proc_key_users_stop(struct seq_file *p, void *v);\nstatic int proc_key_users_show(struct seq_file *m, void *v);\n\nstatic void proc_key_users_stop(struct seq_file *p, void *v)\n\t__releases(key_user_lock)\n{\n\tspin_unlock(&key_user_lock);\n}"
  },
  {
    "function_name": "proc_key_users_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "322-326",
    "snippet": "static void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos)\n{\n\t(*_pos)++;\n\treturn key_user_next(seq_user_ns(p), (struct rb_node *)v);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *proc_keys_start(struct seq_file *p, loff_t *_pos);",
      "static void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos);",
      "static void proc_keys_stop(struct seq_file *p, void *v);",
      "static int proc_keys_show(struct seq_file *m, void *v);",
      "static void *proc_key_users_start(struct seq_file *p, loff_t *_pos);",
      "static void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos);",
      "static void proc_key_users_stop(struct seq_file *p, void *v);",
      "static int proc_key_users_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_user_next",
          "args": [
            "seq_user_ns(p)",
            "(struct rb_node *)v"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "key_user_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
          "lines": "285-288",
          "snippet": "static struct rb_node *key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\treturn __key_user_next(user_ns, rb_next(n));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/errno.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct rb_node *key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\treturn __key_user_next(user_ns, rb_next(n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "p"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void *proc_keys_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos);\nstatic void proc_keys_stop(struct seq_file *p, void *v);\nstatic int proc_keys_show(struct seq_file *m, void *v);\nstatic void *proc_key_users_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos);\nstatic void proc_key_users_stop(struct seq_file *p, void *v);\nstatic int proc_key_users_show(struct seq_file *m, void *v);\n\nstatic void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos)\n{\n\t(*_pos)++;\n\treturn key_user_next(seq_user_ns(p), (struct rb_node *)v);\n}"
  },
  {
    "function_name": "proc_key_users_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "305-320",
    "snippet": "static void *proc_key_users_start(struct seq_file *p, loff_t *_pos)\n\t__acquires(key_user_lock)\n{\n\tstruct rb_node *_p;\n\tloff_t pos = *_pos;\n\n\tspin_lock(&key_user_lock);\n\n\t_p = key_user_first(seq_user_ns(p), &key_user_tree);\n\twhile (pos > 0 && _p) {\n\t\tpos--;\n\t\t_p = key_user_next(seq_user_ns(p), _p);\n\t}\n\n\treturn _p;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *proc_keys_start(struct seq_file *p, loff_t *_pos);",
      "static void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos);",
      "static void *proc_key_users_start(struct seq_file *p, loff_t *_pos);",
      "static void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_user_next",
          "args": [
            "seq_user_ns(p)",
            "_p"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "key_user_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
          "lines": "285-288",
          "snippet": "static struct rb_node *key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\treturn __key_user_next(user_ns, rb_next(n));\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/errno.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct rb_node *key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\treturn __key_user_next(user_ns, rb_next(n));\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "p"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_user_first",
          "args": [
            "seq_user_ns(p)",
            "&key_user_tree"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "key_user_first",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
          "lines": "290-294",
          "snippet": "static struct rb_node *key_user_first(struct user_namespace *user_ns, struct rb_root *r)\n{\n\tstruct rb_node *n = rb_first(r);\n\treturn __key_user_next(user_ns, n);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/errno.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct rb_node *key_user_first(struct user_namespace *user_ns, struct rb_root *r)\n{\n\tstruct rb_node *n = rb_first(r);\n\treturn __key_user_next(user_ns, n);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "p"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&key_user_lock"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "key_user_lock"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void *proc_keys_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos);\nstatic void *proc_key_users_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos);\n\nstatic void *proc_key_users_start(struct seq_file *p, loff_t *_pos)\n\t__acquires(key_user_lock)\n{\n\tstruct rb_node *_p;\n\tloff_t pos = *_pos;\n\n\tspin_lock(&key_user_lock);\n\n\t_p = key_user_first(seq_user_ns(p), &key_user_tree);\n\twhile (pos > 0 && _p) {\n\t\tpos--;\n\t\t_p = key_user_next(seq_user_ns(p), _p);\n\t}\n\n\treturn _p;\n}"
  },
  {
    "function_name": "proc_key_users_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "300-303",
    "snippet": "static int proc_key_users_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_key_users_ops);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int proc_keys_open(struct inode *inode, struct file *file);",
      "static int proc_key_users_open(struct inode *inode, struct file *file);",
      "static const struct seq_operations proc_key_users_ops = {\n\t.start\t= proc_key_users_start,\n\t.next\t= proc_key_users_next,\n\t.stop\t= proc_key_users_stop,\n\t.show\t= proc_key_users_show,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&proc_key_users_ops"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int proc_keys_open(struct inode *inode, struct file *file);\nstatic int proc_key_users_open(struct inode *inode, struct file *file);\nstatic const struct seq_operations proc_key_users_ops = {\n\t.start\t= proc_key_users_start,\n\t.next\t= proc_key_users_next,\n\t.stop\t= proc_key_users_stop,\n\t.show\t= proc_key_users_show,\n};\n\nstatic int proc_key_users_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_key_users_ops);\n}"
  },
  {
    "function_name": "key_user_first",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "290-294",
    "snippet": "static struct rb_node *key_user_first(struct user_namespace *user_ns, struct rb_root *r)\n{\n\tstruct rb_node *n = rb_first(r);\n\treturn __key_user_next(user_ns, n);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__key_user_next",
          "args": [
            "user_ns",
            "n"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "__key_user_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
          "lines": "274-283",
          "snippet": "static struct rb_node *__key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\twhile (n) {\n\t\tstruct key_user *user = rb_entry(n, struct key_user, node);\n\t\tif (kuid_has_mapping(user_ns, user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/errno.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct rb_node *__key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\twhile (n) {\n\t\tstruct key_user *user = rb_entry(n, struct key_user, node);\n\t\tif (kuid_has_mapping(user_ns, user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_first",
          "args": [
            "r"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct rb_node *key_user_first(struct user_namespace *user_ns, struct rb_root *r)\n{\n\tstruct rb_node *n = rb_first(r);\n\treturn __key_user_next(user_ns, n);\n}"
  },
  {
    "function_name": "key_user_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "285-288",
    "snippet": "static struct rb_node *key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\treturn __key_user_next(user_ns, rb_next(n));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__key_user_next",
          "args": [
            "user_ns",
            "rb_next(n)"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "__key_user_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
          "lines": "274-283",
          "snippet": "static struct rb_node *__key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\twhile (n) {\n\t\tstruct key_user *user = rb_entry(n, struct key_user, node);\n\t\tif (kuid_has_mapping(user_ns, user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/errno.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct rb_node *__key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\twhile (n) {\n\t\tstruct key_user *user = rb_entry(n, struct key_user, node);\n\t\tif (kuid_has_mapping(user_ns, user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct rb_node *key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\treturn __key_user_next(user_ns, rb_next(n));\n}"
  },
  {
    "function_name": "__key_user_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "274-283",
    "snippet": "static struct rb_node *__key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\twhile (n) {\n\t\tstruct key_user *user = rb_entry(n, struct key_user, node);\n\t\tif (kuid_has_mapping(user_ns, user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "user_ns",
            "user->uid"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structkey_user",
            "node"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct rb_node *__key_user_next(struct user_namespace *user_ns, struct rb_node *n)\n{\n\twhile (n) {\n\t\tstruct key_user *user = rb_entry(n, struct key_user, node);\n\t\tif (kuid_has_mapping(user_ns, user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}"
  },
  {
    "function_name": "proc_keys_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "177-272",
    "snippet": "static int proc_keys_show(struct seq_file *m, void *v)\n{\n\tstruct rb_node *_p = v;\n\tstruct key *key = rb_entry(_p, struct key, serial_node);\n\tunsigned long flags;\n\tkey_ref_t key_ref, skey_ref;\n\ttime64_t now, expiry;\n\tchar xbuf[16];\n\tshort state;\n\tu64 timo;\n\tint rc;\n\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= key->type,\n\t\t.index_key.description\t= key->description,\n\t\t.cred\t\t\t= m->file->f_cred,\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.raw_data\t= key,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\n\tkey_ref = make_key_ref(key, 0);\n\n\t/* determine if the key is possessed by this process (a test we can\n\t * skip if the key does not indicate the possessor can view it\n\t */\n\tif (key->perm & KEY_POS_VIEW) {\n\t\tskey_ref = search_my_process_keyrings(&ctx);\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_ref_put(skey_ref);\n\t\t\tkey_ref = make_key_ref(key, 1);\n\t\t}\n\t}\n\n\t/* check whether the current task is allowed to view the key */\n\trc = key_task_permission(key_ref, ctx.cred, KEY_NEED_VIEW);\n\tif (rc < 0)\n\t\treturn 0;\n\n\tnow = ktime_get_real_seconds();\n\n\trcu_read_lock();\n\n\t/* come up with a suitable timeout value */\n\texpiry = READ_ONCE(key->expiry);\n\tif (expiry == 0) {\n\t\tmemcpy(xbuf, \"perm\", 5);\n\t} else if (now >= expiry) {\n\t\tmemcpy(xbuf, \"expd\", 5);\n\t} else {\n\t\ttimo = expiry - now;\n\n\t\tif (timo < 60)\n\t\t\tsprintf(xbuf, \"%llus\", timo);\n\t\telse if (timo < 60*60)\n\t\t\tsprintf(xbuf, \"%llum\", div_u64(timo, 60));\n\t\telse if (timo < 60*60*24)\n\t\t\tsprintf(xbuf, \"%lluh\", div_u64(timo, 60 * 60));\n\t\telse if (timo < 60*60*24*7)\n\t\t\tsprintf(xbuf, \"%llud\", div_u64(timo, 60 * 60 * 24));\n\t\telse\n\t\t\tsprintf(xbuf, \"%lluw\", div_u64(timo, 60 * 60 * 24 * 7));\n\t}\n\n\tstate = key_read_state(key);\n\n#define showflag(FLAGS, LETTER, FLAG) \\\n\t((FLAGS & (1 << FLAG)) ? LETTER : '-')\n\n\tflags = READ_ONCE(key->flags);\n\tseq_printf(m, \"%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s \",\n\t\t   key->serial,\n\t\t   state != KEY_IS_UNINSTANTIATED ? 'I' : '-',\n\t\t   showflag(flags, 'R', KEY_FLAG_REVOKED),\n\t\t   showflag(flags, 'D', KEY_FLAG_DEAD),\n\t\t   showflag(flags, 'Q', KEY_FLAG_IN_QUOTA),\n\t\t   showflag(flags, 'U', KEY_FLAG_USER_CONSTRUCT),\n\t\t   state < 0 ? 'N' : '-',\n\t\t   showflag(flags, 'i', KEY_FLAG_INVALIDATED),\n\t\t   refcount_read(&key->usage),\n\t\t   xbuf,\n\t\t   key->perm,\n\t\t   from_kuid_munged(seq_user_ns(m), key->uid),\n\t\t   from_kgid_munged(seq_user_ns(m), key->gid),\n\t\t   key->type->name);\n\n#undef showflag\n\n\tif (key->type->describe)\n\t\tkey->type->describe(key, m);\n\tseq_putc(m, '\\n');\n\n\trcu_read_unlock();\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int proc_keys_open(struct inode *inode, struct file *file);",
      "static void proc_keys_stop(struct seq_file *p, void *v);",
      "static int proc_keys_show(struct seq_file *m, void *v);",
      "static int proc_key_users_open(struct inode *inode, struct file *file);",
      "static void proc_key_users_stop(struct seq_file *p, void *v);",
      "static int proc_key_users_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key->type->describe",
          "args": [
            "key",
            "m"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s \"",
            "key->serial",
            "state != KEY_IS_UNINSTANTIATED ? 'I' : '-'",
            "showflag(flags, 'R', KEY_FLAG_REVOKED)",
            "showflag(flags, 'D', KEY_FLAG_DEAD)",
            "showflag(flags, 'Q', KEY_FLAG_IN_QUOTA)",
            "showflag(flags, 'U', KEY_FLAG_USER_CONSTRUCT)",
            "state < 0 ? 'N' : '-'",
            "showflag(flags, 'i', KEY_FLAG_INVALIDATED)",
            "refcount_read(&key->usage)",
            "xbuf",
            "key->perm",
            "from_kuid_munged(seq_user_ns(m), key->uid)",
            "from_kgid_munged(seq_user_ns(m), key->gid)",
            "key->type->name"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "seq_user_ns(m)",
            "key->gid"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "m"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "seq_user_ns(m)",
            "key->uid"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "m"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&key->usage"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "showflag",
          "args": [
            "flags",
            "'i'",
            "KEY_FLAG_INVALIDATED"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "showflag",
          "args": [
            "flags",
            "'U'",
            "KEY_FLAG_USER_CONSTRUCT"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "showflag",
          "args": [
            "flags",
            "'Q'",
            "KEY_FLAG_IN_QUOTA"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "showflag",
          "args": [
            "flags",
            "'D'",
            "KEY_FLAG_DEAD"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "showflag",
          "args": [
            "flags",
            "'R'",
            "KEY_FLAG_REVOKED"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "key->flags"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_read_state",
          "args": [
            "key"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "xbuf",
            "\"%lluw\"",
            "div_u64(timo, 60 * 60 * 24 * 7)"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "timo",
            "60 * 60 * 24 * 7"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "xbuf",
            "\"%llud\"",
            "div_u64(timo, 60 * 60 * 24)"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "timo",
            "60 * 60 * 24"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "xbuf",
            "\"%lluh\"",
            "div_u64(timo, 60 * 60)"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "timo",
            "60 * 60"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "xbuf",
            "\"%llum\"",
            "div_u64(timo, 60)"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "timo",
            "60"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "xbuf",
            "\"%llus\"",
            "timo"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "xbuf",
            "\"expd\"",
            "5"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "xbuf",
            "\"perm\"",
            "5"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "key->expiry"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_task_permission",
          "args": [
            "key_ref",
            "ctx.cred",
            "KEY_NEED_VIEW"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "key_task_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/permission.c",
          "lines": "30-78",
          "snippet": "int key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tunsigned perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm;\n\tint ret;\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* use the second 8-bits of permissions for keys the caller owns */\n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t/* use the third 8-bits of permissions for keys the caller has a group\n\t * membership in common with */\n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t/* otherwise use the least-significant 8-bits */\n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t/* use the top 8-bits of permissions for keys the caller possesses\n\t * - possessor permissions are additive with other permissions\n\t */\n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tkperm = kperm & perm & KEY_NEED_ALL;\n\n\tif (kperm != perm)\n\t\treturn -EACCES;\n\n\t/* let LSM be the final arbiter */\n\treturn security_key_permission(key_ref, cred, perm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/security.h>\n#include <linux/module.h>\n\nint key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tunsigned perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm;\n\tint ret;\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* use the second 8-bits of permissions for keys the caller owns */\n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t/* use the third 8-bits of permissions for keys the caller has a group\n\t * membership in common with */\n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t/* otherwise use the least-significant 8-bits */\n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t/* use the top 8-bits of permissions for keys the caller possesses\n\t * - possessor permissions are additive with other permissions\n\t */\n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tkperm = kperm & perm & KEY_NEED_ALL;\n\n\tif (kperm != perm)\n\t\treturn -EACCES;\n\n\t/* let LSM be the final arbiter */\n\treturn security_key_permission(key_ref, cred, perm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "key",
            "1"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "skey_ref"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "skey_ref"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_my_process_keyrings",
          "args": [
            "&ctx"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "search_my_process_keyrings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/process_keys.c",
          "lines": "339-441",
          "snippet": "key_ref_t search_my_process_keyrings(struct keyring_search_context *ctx)\n{\n\tkey_ref_t key_ref, ret, err;\n\n\t/* we want to return -EAGAIN or -ENOKEY if any of the keyrings were\n\t * searchable, but we failed to find a key or we found a negative key;\n\t * otherwise we want to return a sample error (probably -EACCES) if\n\t * none of the keyrings were searchable\n\t *\n\t * in terms of priority: success > -ENOKEY > -EAGAIN > other error\n\t */\n\tkey_ref = NULL;\n\tret = NULL;\n\terr = ERR_PTR(-EAGAIN);\n\n\t/* search the thread keyring first */\n\tif (ctx->cred->thread_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->thread_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the process keyring second */\n\tif (ctx->cred->process_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->process_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the session keyring */\n\tif (ctx->cred->session_keyring) {\n\t\trcu_read_lock();\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(rcu_dereference(ctx->cred->session_keyring), 1),\n\t\t\tctx);\n\t\trcu_read_unlock();\n\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* or search the user-session keyring */\n\telse if (ctx->cred->user->session_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->user->session_keyring, 1),\n\t\t\tctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tkey_ref = ret ? ret : err;\n\nfound:\n\treturn key_ref;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/mutex.h>",
            "#include <linux/err.h>",
            "#include <linux/fs.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/security.h>\n#include <linux/mutex.h>\n#include <linux/err.h>\n#include <linux/fs.h>\n#include <linux/keyctl.h>\n#include <linux/sched/user.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t search_my_process_keyrings(struct keyring_search_context *ctx)\n{\n\tkey_ref_t key_ref, ret, err;\n\n\t/* we want to return -EAGAIN or -ENOKEY if any of the keyrings were\n\t * searchable, but we failed to find a key or we found a negative key;\n\t * otherwise we want to return a sample error (probably -EACCES) if\n\t * none of the keyrings were searchable\n\t *\n\t * in terms of priority: success > -ENOKEY > -EAGAIN > other error\n\t */\n\tkey_ref = NULL;\n\tret = NULL;\n\terr = ERR_PTR(-EAGAIN);\n\n\t/* search the thread keyring first */\n\tif (ctx->cred->thread_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->thread_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the process keyring second */\n\tif (ctx->cred->process_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->process_keyring, 1), ctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* search the session keyring */\n\tif (ctx->cred->session_keyring) {\n\t\trcu_read_lock();\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(rcu_dereference(ctx->cred->session_keyring), 1),\n\t\t\tctx);\n\t\trcu_read_unlock();\n\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\t/* or search the user-session keyring */\n\telse if (ctx->cred->user->session_keyring) {\n\t\tkey_ref = keyring_search_aux(\n\t\t\tmake_key_ref(ctx->cred->user->session_keyring, 1),\n\t\t\tctx);\n\t\tif (!IS_ERR(key_ref))\n\t\t\tgoto found;\n\n\t\tswitch (PTR_ERR(key_ref)) {\n\t\tcase -EAGAIN: /* no key */\n\t\t\tif (ret)\n\t\t\t\tbreak;\n\t\tcase -ENOKEY: /* negative key */\n\t\t\tret = key_ref;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = key_ref;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* no key - decide on the error we're going to go for */\n\tkey_ref = ret ? ret : err;\n\nfound:\n\treturn key_ref;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "key",
            "0"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "_p",
            "structkey",
            "serial_node"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int proc_keys_open(struct inode *inode, struct file *file);\nstatic void proc_keys_stop(struct seq_file *p, void *v);\nstatic int proc_keys_show(struct seq_file *m, void *v);\nstatic int proc_key_users_open(struct inode *inode, struct file *file);\nstatic void proc_key_users_stop(struct seq_file *p, void *v);\nstatic int proc_key_users_show(struct seq_file *m, void *v);\n\nstatic int proc_keys_show(struct seq_file *m, void *v)\n{\n\tstruct rb_node *_p = v;\n\tstruct key *key = rb_entry(_p, struct key, serial_node);\n\tunsigned long flags;\n\tkey_ref_t key_ref, skey_ref;\n\ttime64_t now, expiry;\n\tchar xbuf[16];\n\tshort state;\n\tu64 timo;\n\tint rc;\n\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= key->type,\n\t\t.index_key.description\t= key->description,\n\t\t.cred\t\t\t= m->file->f_cred,\n\t\t.match_data.cmp\t\t= lookup_user_key_possessed,\n\t\t.match_data.raw_data\t= key,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_NO_STATE_CHECK,\n\t};\n\n\tkey_ref = make_key_ref(key, 0);\n\n\t/* determine if the key is possessed by this process (a test we can\n\t * skip if the key does not indicate the possessor can view it\n\t */\n\tif (key->perm & KEY_POS_VIEW) {\n\t\tskey_ref = search_my_process_keyrings(&ctx);\n\t\tif (!IS_ERR(skey_ref)) {\n\t\t\tkey_ref_put(skey_ref);\n\t\t\tkey_ref = make_key_ref(key, 1);\n\t\t}\n\t}\n\n\t/* check whether the current task is allowed to view the key */\n\trc = key_task_permission(key_ref, ctx.cred, KEY_NEED_VIEW);\n\tif (rc < 0)\n\t\treturn 0;\n\n\tnow = ktime_get_real_seconds();\n\n\trcu_read_lock();\n\n\t/* come up with a suitable timeout value */\n\texpiry = READ_ONCE(key->expiry);\n\tif (expiry == 0) {\n\t\tmemcpy(xbuf, \"perm\", 5);\n\t} else if (now >= expiry) {\n\t\tmemcpy(xbuf, \"expd\", 5);\n\t} else {\n\t\ttimo = expiry - now;\n\n\t\tif (timo < 60)\n\t\t\tsprintf(xbuf, \"%llus\", timo);\n\t\telse if (timo < 60*60)\n\t\t\tsprintf(xbuf, \"%llum\", div_u64(timo, 60));\n\t\telse if (timo < 60*60*24)\n\t\t\tsprintf(xbuf, \"%lluh\", div_u64(timo, 60 * 60));\n\t\telse if (timo < 60*60*24*7)\n\t\t\tsprintf(xbuf, \"%llud\", div_u64(timo, 60 * 60 * 24));\n\t\telse\n\t\t\tsprintf(xbuf, \"%lluw\", div_u64(timo, 60 * 60 * 24 * 7));\n\t}\n\n\tstate = key_read_state(key);\n\n#define showflag(FLAGS, LETTER, FLAG) \\\n\t((FLAGS & (1 << FLAG)) ? LETTER : '-')\n\n\tflags = READ_ONCE(key->flags);\n\tseq_printf(m, \"%08x %c%c%c%c%c%c%c %5d %4s %08x %5d %5d %-9.9s \",\n\t\t   key->serial,\n\t\t   state != KEY_IS_UNINSTANTIATED ? 'I' : '-',\n\t\t   showflag(flags, 'R', KEY_FLAG_REVOKED),\n\t\t   showflag(flags, 'D', KEY_FLAG_DEAD),\n\t\t   showflag(flags, 'Q', KEY_FLAG_IN_QUOTA),\n\t\t   showflag(flags, 'U', KEY_FLAG_USER_CONSTRUCT),\n\t\t   state < 0 ? 'N' : '-',\n\t\t   showflag(flags, 'i', KEY_FLAG_INVALIDATED),\n\t\t   refcount_read(&key->usage),\n\t\t   xbuf,\n\t\t   key->perm,\n\t\t   from_kuid_munged(seq_user_ns(m), key->uid),\n\t\t   from_kgid_munged(seq_user_ns(m), key->gid),\n\t\t   key->type->name);\n\n#undef showflag\n\n\tif (key->type->describe)\n\t\tkey->type->describe(key, m);\n\tseq_putc(m, '\\n');\n\n\trcu_read_unlock();\n\treturn 0;\n}"
  },
  {
    "function_name": "proc_keys_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "171-175",
    "snippet": "static void proc_keys_stop(struct seq_file *p, void *v)\n\t__releases(key_serial_lock)\n{\n\tspin_unlock(&key_serial_lock);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void proc_keys_stop(struct seq_file *p, void *v);",
      "static int proc_keys_show(struct seq_file *m, void *v);",
      "static void proc_key_users_stop(struct seq_file *p, void *v);",
      "static int proc_key_users_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&key_serial_lock"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "key_serial_lock"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void proc_keys_stop(struct seq_file *p, void *v);\nstatic int proc_keys_show(struct seq_file *m, void *v);\nstatic void proc_key_users_stop(struct seq_file *p, void *v);\nstatic int proc_key_users_show(struct seq_file *m, void *v);\n\nstatic void proc_keys_stop(struct seq_file *p, void *v)\n\t__releases(key_serial_lock)\n{\n\tspin_unlock(&key_serial_lock);\n}"
  },
  {
    "function_name": "proc_keys_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "161-169",
    "snippet": "static void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos)\n{\n\tstruct rb_node *n;\n\n\tn = key_serial_next(p, v);\n\tif (n)\n\t\t*_pos = key_node_serial(n);\n\treturn n;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *proc_keys_start(struct seq_file *p, loff_t *_pos);",
      "static void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos);",
      "static void proc_keys_stop(struct seq_file *p, void *v);",
      "static int proc_keys_show(struct seq_file *m, void *v);",
      "static void *proc_key_users_start(struct seq_file *p, loff_t *_pos);",
      "static void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos);",
      "static void proc_key_users_stop(struct seq_file *p, void *v);",
      "static int proc_key_users_show(struct seq_file *m, void *v);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_node_serial",
          "args": [
            "n"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "key_node_serial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
          "lines": "155-159",
          "snippet": "static inline key_serial_t key_node_serial(struct rb_node *n)\n{\n\tstruct key *key = rb_entry(n, struct key, serial_node);\n\treturn key->serial;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/errno.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline key_serial_t key_node_serial(struct rb_node *n)\n{\n\tstruct key *key = rb_entry(n, struct key, serial_node);\n\treturn key->serial;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_serial_next",
          "args": [
            "p",
            "v"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "key_serial_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
          "lines": "85-97",
          "snippet": "static struct rb_node *key_serial_next(struct seq_file *p, struct rb_node *n)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\n\tn = rb_next(n);\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (kuid_has_mapping(user_ns, key->user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/errno.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct rb_node *key_serial_next(struct seq_file *p, struct rb_node *n)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\n\tn = rb_next(n);\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (kuid_has_mapping(user_ns, key->user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void *proc_keys_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos);\nstatic void proc_keys_stop(struct seq_file *p, void *v);\nstatic int proc_keys_show(struct seq_file *m, void *v);\nstatic void *proc_key_users_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos);\nstatic void proc_key_users_stop(struct seq_file *p, void *v);\nstatic int proc_key_users_show(struct seq_file *m, void *v);\n\nstatic void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos)\n{\n\tstruct rb_node *n;\n\n\tn = key_serial_next(p, v);\n\tif (n)\n\t\t*_pos = key_node_serial(n);\n\treturn n;\n}"
  },
  {
    "function_name": "key_node_serial",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "155-159",
    "snippet": "static inline key_serial_t key_node_serial(struct rb_node *n)\n{\n\tstruct key *key = rb_entry(n, struct key, serial_node);\n\treturn key->serial;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structkey",
            "serial_node"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic inline key_serial_t key_node_serial(struct rb_node *n)\n{\n\tstruct key *key = rb_entry(n, struct key, serial_node);\n\treturn key->serial;\n}"
  },
  {
    "function_name": "proc_keys_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "138-153",
    "snippet": "static void *proc_keys_start(struct seq_file *p, loff_t *_pos)\n\t__acquires(key_serial_lock)\n{\n\tkey_serial_t pos = *_pos;\n\tstruct key *key;\n\n\tspin_lock(&key_serial_lock);\n\n\tif (*_pos > INT_MAX)\n\t\treturn NULL;\n\tkey = find_ge_key(p, pos);\n\tif (!key)\n\t\treturn NULL;\n\t*_pos = key->serial;\n\treturn &key->serial_node;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void *proc_keys_start(struct seq_file *p, loff_t *_pos);",
      "static void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos);",
      "static void *proc_key_users_start(struct seq_file *p, loff_t *_pos);",
      "static void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_ge_key",
          "args": [
            "p",
            "pos"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "find_ge_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
          "lines": "104-136",
          "snippet": "static struct key *find_ge_key(struct seq_file *p, key_serial_t id)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\tstruct rb_node *n = key_serial_tree.rb_node;\n\tstruct key *minkey = NULL;\n\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (id < key->serial) {\n\t\t\tif (!minkey || minkey->serial > key->serial)\n\t\t\t\tminkey = key;\n\t\t\tn = n->rb_left;\n\t\t} else if (id > key->serial) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tminkey = key;\n\t\t\tbreak;\n\t\t}\n\t\tkey = NULL;\n\t}\n\n\tif (!minkey)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tif (kuid_has_mapping(user_ns, minkey->user->uid))\n\t\t\treturn minkey;\n\t\tn = rb_next(&minkey->serial_node);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tminkey = rb_entry(n, struct key, serial_node);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <asm/errno.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct key *find_ge_key(struct seq_file *p, key_serial_t id)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\tstruct rb_node *n = key_serial_tree.rb_node;\n\tstruct key *minkey = NULL;\n\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (id < key->serial) {\n\t\t\tif (!minkey || minkey->serial > key->serial)\n\t\t\t\tminkey = key;\n\t\t\tn = n->rb_left;\n\t\t} else if (id > key->serial) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tminkey = key;\n\t\t\tbreak;\n\t\t}\n\t\tkey = NULL;\n\t}\n\n\tif (!minkey)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tif (kuid_has_mapping(user_ns, minkey->user->uid))\n\t\t\treturn minkey;\n\t\tn = rb_next(&minkey->serial_node);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tminkey = rb_entry(n, struct key, serial_node);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&key_serial_lock"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "key_serial_lock"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void *proc_keys_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_keys_next(struct seq_file *p, void *v, loff_t *_pos);\nstatic void *proc_key_users_start(struct seq_file *p, loff_t *_pos);\nstatic void *proc_key_users_next(struct seq_file *p, void *v, loff_t *_pos);\n\nstatic void *proc_keys_start(struct seq_file *p, loff_t *_pos)\n\t__acquires(key_serial_lock)\n{\n\tkey_serial_t pos = *_pos;\n\tstruct key *key;\n\n\tspin_lock(&key_serial_lock);\n\n\tif (*_pos > INT_MAX)\n\t\treturn NULL;\n\tkey = find_ge_key(p, pos);\n\tif (!key)\n\t\treturn NULL;\n\t*_pos = key->serial;\n\treturn &key->serial_node;\n}"
  },
  {
    "function_name": "find_ge_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "104-136",
    "snippet": "static struct key *find_ge_key(struct seq_file *p, key_serial_t id)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\tstruct rb_node *n = key_serial_tree.rb_node;\n\tstruct key *minkey = NULL;\n\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (id < key->serial) {\n\t\t\tif (!minkey || minkey->serial > key->serial)\n\t\t\t\tminkey = key;\n\t\t\tn = n->rb_left;\n\t\t} else if (id > key->serial) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tminkey = key;\n\t\t\tbreak;\n\t\t}\n\t\tkey = NULL;\n\t}\n\n\tif (!minkey)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tif (kuid_has_mapping(user_ns, minkey->user->uid))\n\t\t\treturn minkey;\n\t\tn = rb_next(&minkey->serial_node);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tminkey = rb_entry(n, struct key, serial_node);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structkey",
            "serial_node"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&minkey->serial_node"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "user_ns",
            "minkey->user->uid"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structkey",
            "serial_node"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "p"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct key *find_ge_key(struct seq_file *p, key_serial_t id)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\tstruct rb_node *n = key_serial_tree.rb_node;\n\tstruct key *minkey = NULL;\n\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (id < key->serial) {\n\t\t\tif (!minkey || minkey->serial > key->serial)\n\t\t\t\tminkey = key;\n\t\t\tn = n->rb_left;\n\t\t} else if (id > key->serial) {\n\t\t\tn = n->rb_right;\n\t\t} else {\n\t\t\tminkey = key;\n\t\t\tbreak;\n\t\t}\n\t\tkey = NULL;\n\t}\n\n\tif (!minkey)\n\t\treturn NULL;\n\n\tfor (;;) {\n\t\tif (kuid_has_mapping(user_ns, minkey->user->uid))\n\t\t\treturn minkey;\n\t\tn = rb_next(&minkey->serial_node);\n\t\tif (!n)\n\t\t\treturn NULL;\n\t\tminkey = rb_entry(n, struct key, serial_node);\n\t}\n}"
  },
  {
    "function_name": "proc_keys_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "99-102",
    "snippet": "static int proc_keys_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_keys_ops);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int proc_keys_open(struct inode *inode, struct file *file);",
      "static const struct seq_operations proc_keys_ops = {\n\t.start\t= proc_keys_start,\n\t.next\t= proc_keys_next,\n\t.stop\t= proc_keys_stop,\n\t.show\t= proc_keys_show,\n};",
      "static int proc_key_users_open(struct inode *inode, struct file *file);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&proc_keys_ops"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "aa_sfs_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/apparmorfs.c",
          "lines": "1010-1013",
          "snippet": "static int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}",
          "includes": [
            "#include \"include/policy_unpack.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/crypto.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmorfs.h\"",
            "#include \"include/apparmor.h\"",
            "#include <uapi/linux/magic.h>",
            "#include <uapi/linux/major.h>",
            "#include <linux/poll.h>",
            "#include <linux/fs.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/capability.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/security.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_unpack.h\"\n#include \"include/resource.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/policy_ns.h\"\n#include \"include/ipc.h\"\n#include \"include/crypto.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmorfs.h\"\n#include \"include/apparmor.h\"\n#include <uapi/linux/magic.h>\n#include <uapi/linux/major.h>\n#include <linux/poll.h>\n#include <linux/fs.h>\n#include <linux/rcupdate.h>\n#include <linux/capability.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/vmalloc.h>\n#include <linux/security.h>\n#include <linux/ctype.h>\n\nstatic int aa_sfs_seq_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, aa_sfs_seq_show, inode->i_private);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int proc_keys_open(struct inode *inode, struct file *file);\nstatic const struct seq_operations proc_keys_ops = {\n\t.start\t= proc_keys_start,\n\t.next\t= proc_keys_next,\n\t.stop\t= proc_keys_stop,\n\t.show\t= proc_keys_show,\n};\nstatic int proc_key_users_open(struct inode *inode, struct file *file);\n\nstatic int proc_keys_open(struct inode *inode, struct file *file)\n{\n\treturn seq_open(file, &proc_keys_ops);\n}"
  },
  {
    "function_name": "key_serial_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "85-97",
    "snippet": "static struct rb_node *key_serial_next(struct seq_file *p, struct rb_node *n)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\n\tn = rb_next(n);\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (kuid_has_mapping(user_ns, key->user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "user_ns",
            "key->user->uid"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "n",
            "structkey",
            "serial_node"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "n"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_user_ns",
          "args": [
            "p"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct rb_node *key_serial_next(struct seq_file *p, struct rb_node *n)\n{\n\tstruct user_namespace *user_ns = seq_user_ns(p);\n\n\tn = rb_next(n);\n\twhile (n) {\n\t\tstruct key *key = rb_entry(n, struct key, serial_node);\n\t\tif (kuid_has_mapping(user_ns, key->user->uid))\n\t\t\tbreak;\n\t\tn = rb_next(n);\n\t}\n\treturn n;\n}"
  },
  {
    "function_name": "key_proc_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/proc.c",
    "lines": "64-77",
    "snippet": "static int __init key_proc_init(void)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create(\"keys\", 0, NULL, &proc_keys_fops);\n\tif (!p)\n\t\tpanic(\"Cannot create /proc/keys\\n\");\n\n\tp = proc_create(\"key-users\", 0, NULL, &proc_key_users_fops);\n\tif (!p)\n\t\tpanic(\"Cannot create /proc/key-users\\n\");\n\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <asm/errno.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations proc_keys_fops = {\n\t.open\t\t= proc_keys_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};",
      "static const struct file_operations proc_key_users_fops = {\n\t.open\t\t= proc_key_users_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Cannot create /proc/key-users\\n\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"key-users\"",
            "0",
            "NULL",
            "&proc_key_users_fops"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"Cannot create /proc/keys\\n\""
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_create",
          "args": [
            "\"keys\"",
            "0",
            "NULL",
            "&proc_keys_fops"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <asm/errno.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic const struct file_operations proc_keys_fops = {\n\t.open\t\t= proc_keys_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\nstatic const struct file_operations proc_key_users_fops = {\n\t.open\t\t= proc_key_users_open,\n\t.read\t\t= seq_read,\n\t.llseek\t\t= seq_lseek,\n\t.release\t= seq_release,\n};\n\nstatic int __init key_proc_init(void)\n{\n\tstruct proc_dir_entry *p;\n\n\tp = proc_create(\"keys\", 0, NULL, &proc_keys_fops);\n\tif (!p)\n\t\tpanic(\"Cannot create /proc/keys\\n\");\n\n\tp = proc_create(\"key-users\", 0, NULL, &proc_key_users_fops);\n\tif (!p)\n\t\tpanic(\"Cannot create /proc/key-users\\n\");\n\n\treturn 0;\n}"
  }
]