[
  {
    "function_name": "sel_netnode_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
    "lines": "303-316",
    "snippet": "static __init int sel_netnode_init(void)\n{\n\tint iter;\n\n\tif (!selinux_enabled)\n\t\treturn 0;\n\n\tfor (iter = 0; iter < SEL_NETNODE_HASH_SIZE; iter++) {\n\t\tINIT_LIST_HEAD(&sel_netnode_hash[iter].list);\n\t\tsel_netnode_hash[iter].size = 0;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"netnode.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define SEL_NETNODE_HASH_SIZE       256"
    ],
    "globals_used": [
      "static struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sel_netnode_hash[iter].list"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_NETNODE_HASH_SIZE       256\n\nstatic struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];\n\nstatic __init int sel_netnode_init(void)\n{\n\tint iter;\n\n\tif (!selinux_enabled)\n\t\treturn 0;\n\n\tfor (iter = 0; iter < SEL_NETNODE_HASH_SIZE; iter++) {\n\t\tINIT_LIST_HEAD(&sel_netnode_hash[iter].list);\n\t\tsel_netnode_hash[iter].size = 0;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sel_netnode_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
    "lines": "286-301",
    "snippet": "void sel_netnode_flush(void)\n{\n\tunsigned int idx;\n\tstruct sel_netnode *node, *node_tmp;\n\n\tspin_lock_bh(&sel_netnode_lock);\n\tfor (idx = 0; idx < SEL_NETNODE_HASH_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(node, node_tmp,\n\t\t\t\t\t &sel_netnode_hash[idx].list, list) {\n\t\t\t\tlist_del_rcu(&node->list);\n\t\t\t\tkfree_rcu(node, rcu);\n\t\t}\n\t\tsel_netnode_hash[idx].size = 0;\n\t}\n\tspin_unlock_bh(&sel_netnode_lock);\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"netnode.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define SEL_NETNODE_HASH_SIZE       256"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(sel_netnode_lock);",
      "static struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&sel_netnode_lock"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "node",
            "rcu"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&node->list"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "node",
            "node_tmp",
            "&sel_netnode_hash[idx].list",
            "list"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&sel_netnode_lock"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_NETNODE_HASH_SIZE       256\n\nstatic DEFINE_SPINLOCK(sel_netnode_lock);\nstatic struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];\n\nvoid sel_netnode_flush(void)\n{\n\tunsigned int idx;\n\tstruct sel_netnode *node, *node_tmp;\n\n\tspin_lock_bh(&sel_netnode_lock);\n\tfor (idx = 0; idx < SEL_NETNODE_HASH_SIZE; idx++) {\n\t\tlist_for_each_entry_safe(node, node_tmp,\n\t\t\t\t\t &sel_netnode_hash[idx].list, list) {\n\t\t\t\tlist_del_rcu(&node->list);\n\t\t\t\tkfree_rcu(node, rcu);\n\t\t}\n\t\tsel_netnode_hash[idx].size = 0;\n\t}\n\tspin_unlock_bh(&sel_netnode_lock);\n}"
  },
  {
    "function_name": "sel_netnode_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
    "lines": "263-277",
    "snippet": "int sel_netnode_sid(void *addr, u16 family, u32 *sid)\n{\n\tstruct sel_netnode *node;\n\n\trcu_read_lock();\n\tnode = sel_netnode_find(addr, family);\n\tif (node != NULL) {\n\t\t*sid = node->nsec.sid;\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn sel_netnode_sid_slow(addr, family, sid);\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"netnode.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sel_netnode_sid_slow",
          "args": [
            "addr",
            "family",
            "sid"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netnode_sid_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
          "lines": "200-247",
          "snippet": "static int sel_netnode_sid_slow(void *addr, u16 family, u32 *sid)\n{\n\tint ret = -ENOMEM;\n\tstruct sel_netnode *node;\n\tstruct sel_netnode *new = NULL;\n\n\tspin_lock_bh(&sel_netnode_lock);\n\tnode = sel_netnode_find(addr, family);\n\tif (node != NULL) {\n\t\t*sid = node->nsec.sid;\n\t\tspin_unlock_bh(&sel_netnode_lock);\n\t\treturn 0;\n\t}\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (new == NULL)\n\t\tgoto out;\n\tswitch (family) {\n\tcase PF_INET:\n\t\tret = security_node_sid(PF_INET,\n\t\t\t\t\taddr, sizeof(struct in_addr), sid);\n\t\tnew->nsec.addr.ipv4 = *(__be32 *)addr;\n\t\tbreak;\n\tcase PF_INET6:\n\t\tret = security_node_sid(PF_INET6,\n\t\t\t\t\taddr, sizeof(struct in6_addr), sid);\n\t\tnew->nsec.addr.ipv6 = *(struct in6_addr *)addr;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tret = -EINVAL;\n\t}\n\tif (ret != 0)\n\t\tgoto out;\n\n\tnew->nsec.family = family;\n\tnew->nsec.sid = *sid;\n\tsel_netnode_insert(new);\n\nout:\n\tspin_unlock_bh(&sel_netnode_lock);\n\tif (unlikely(ret)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in sel_netnode_sid_slow(),\"\n\t\t       \" unable to determine network node label\\n\");\n\t\tkfree(new);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"netnode.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sel_netnode_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(sel_netnode_lock);\n\nstatic int sel_netnode_sid_slow(void *addr, u16 family, u32 *sid)\n{\n\tint ret = -ENOMEM;\n\tstruct sel_netnode *node;\n\tstruct sel_netnode *new = NULL;\n\n\tspin_lock_bh(&sel_netnode_lock);\n\tnode = sel_netnode_find(addr, family);\n\tif (node != NULL) {\n\t\t*sid = node->nsec.sid;\n\t\tspin_unlock_bh(&sel_netnode_lock);\n\t\treturn 0;\n\t}\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (new == NULL)\n\t\tgoto out;\n\tswitch (family) {\n\tcase PF_INET:\n\t\tret = security_node_sid(PF_INET,\n\t\t\t\t\taddr, sizeof(struct in_addr), sid);\n\t\tnew->nsec.addr.ipv4 = *(__be32 *)addr;\n\t\tbreak;\n\tcase PF_INET6:\n\t\tret = security_node_sid(PF_INET6,\n\t\t\t\t\taddr, sizeof(struct in6_addr), sid);\n\t\tnew->nsec.addr.ipv6 = *(struct in6_addr *)addr;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tret = -EINVAL;\n\t}\n\tif (ret != 0)\n\t\tgoto out;\n\n\tnew->nsec.family = family;\n\tnew->nsec.sid = *sid;\n\tsel_netnode_insert(new);\n\nout:\n\tspin_unlock_bh(&sel_netnode_lock);\n\tif (unlikely(ret)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in sel_netnode_sid_slow(),\"\n\t\t       \" unable to determine network node label\\n\");\n\t\tkfree(new);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_netnode_find",
          "args": [
            "addr",
            "family"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
          "lines": "114-146",
          "snippet": "static struct sel_netnode *sel_netnode_find(const void *addr, u16 family)\n{\n\tunsigned int idx;\n\tstruct sel_netnode *node;\n\n\tswitch (family) {\n\tcase PF_INET:\n\t\tidx = sel_netnode_hashfn_ipv4(*(__be32 *)addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tidx = sel_netnode_hashfn_ipv6(addr);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry_rcu(node, &sel_netnode_hash[idx].list, list)\n\t\tif (node->nsec.family == family)\n\t\t\tswitch (family) {\n\t\t\tcase PF_INET:\n\t\t\t\tif (node->nsec.addr.ipv4 == *(__be32 *)addr)\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\tcase PF_INET6:\n\t\t\t\tif (ipv6_addr_equal(&node->nsec.addr.ipv6,\n\t\t\t\t\t\t    addr))\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"netnode.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\nstatic struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];\n\nstatic struct sel_netnode *sel_netnode_find(const void *addr, u16 family)\n{\n\tunsigned int idx;\n\tstruct sel_netnode *node;\n\n\tswitch (family) {\n\tcase PF_INET:\n\t\tidx = sel_netnode_hashfn_ipv4(*(__be32 *)addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tidx = sel_netnode_hashfn_ipv6(addr);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry_rcu(node, &sel_netnode_hash[idx].list, list)\n\t\tif (node->nsec.family == family)\n\t\t\tswitch (family) {\n\t\t\tcase PF_INET:\n\t\t\t\tif (node->nsec.addr.ipv4 == *(__be32 *)addr)\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\tcase PF_INET6:\n\t\t\t\tif (ipv6_addr_equal(&node->nsec.addr.ipv6,\n\t\t\t\t\t\t    addr))\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\nint sel_netnode_sid(void *addr, u16 family, u32 *sid)\n{\n\tstruct sel_netnode *node;\n\n\trcu_read_lock();\n\tnode = sel_netnode_find(addr, family);\n\tif (node != NULL) {\n\t\t*sid = node->nsec.sid;\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn sel_netnode_sid_slow(addr, family, sid);\n}"
  },
  {
    "function_name": "sel_netnode_sid_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
    "lines": "200-247",
    "snippet": "static int sel_netnode_sid_slow(void *addr, u16 family, u32 *sid)\n{\n\tint ret = -ENOMEM;\n\tstruct sel_netnode *node;\n\tstruct sel_netnode *new = NULL;\n\n\tspin_lock_bh(&sel_netnode_lock);\n\tnode = sel_netnode_find(addr, family);\n\tif (node != NULL) {\n\t\t*sid = node->nsec.sid;\n\t\tspin_unlock_bh(&sel_netnode_lock);\n\t\treturn 0;\n\t}\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (new == NULL)\n\t\tgoto out;\n\tswitch (family) {\n\tcase PF_INET:\n\t\tret = security_node_sid(PF_INET,\n\t\t\t\t\taddr, sizeof(struct in_addr), sid);\n\t\tnew->nsec.addr.ipv4 = *(__be32 *)addr;\n\t\tbreak;\n\tcase PF_INET6:\n\t\tret = security_node_sid(PF_INET6,\n\t\t\t\t\taddr, sizeof(struct in6_addr), sid);\n\t\tnew->nsec.addr.ipv6 = *(struct in6_addr *)addr;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tret = -EINVAL;\n\t}\n\tif (ret != 0)\n\t\tgoto out;\n\n\tnew->nsec.family = family;\n\tnew->nsec.sid = *sid;\n\tsel_netnode_insert(new);\n\nout:\n\tspin_unlock_bh(&sel_netnode_lock);\n\tif (unlikely(ret)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in sel_netnode_sid_slow(),\"\n\t\t       \" unable to determine network node label\\n\");\n\t\tkfree(new);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"netnode.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sel_netnode_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t       \"SELinux: failure in sel_netnode_sid_slow(),\"\n\t\t       \" unable to determine network node label\\n\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&sel_netnode_lock"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_netnode_insert",
          "args": [
            "new"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netnode_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
          "lines": "156-185",
          "snippet": "static void sel_netnode_insert(struct sel_netnode *node)\n{\n\tunsigned int idx;\n\n\tswitch (node->nsec.family) {\n\tcase PF_INET:\n\t\tidx = sel_netnode_hashfn_ipv4(node->nsec.addr.ipv4);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tidx = sel_netnode_hashfn_ipv6(&node->nsec.addr.ipv6);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\t/* we need to impose a limit on the growth of the hash table so check\n\t * this bucket to make sure it is within the specified bounds */\n\tlist_add_rcu(&node->list, &sel_netnode_hash[idx].list);\n\tif (sel_netnode_hash[idx].size == SEL_NETNODE_HASH_BKT_LIMIT) {\n\t\tstruct sel_netnode *tail;\n\t\ttail = list_entry(\n\t\t\trcu_dereference_protected(sel_netnode_hash[idx].list.prev,\n\t\t\t\t\t\t  lockdep_is_held(&sel_netnode_lock)),\n\t\t\tstruct sel_netnode, list);\n\t\tlist_del_rcu(&tail->list);\n\t\tkfree_rcu(tail, rcu);\n\t} else\n\t\tsel_netnode_hash[idx].size++;\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"netnode.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define SEL_NETNODE_HASH_BKT_LIMIT   16"
          ],
          "globals_used": [
            "static DEFINE_SPINLOCK(sel_netnode_lock);",
            "static struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_NETNODE_HASH_BKT_LIMIT   16\n\nstatic DEFINE_SPINLOCK(sel_netnode_lock);\nstatic struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];\n\nstatic void sel_netnode_insert(struct sel_netnode *node)\n{\n\tunsigned int idx;\n\n\tswitch (node->nsec.family) {\n\tcase PF_INET:\n\t\tidx = sel_netnode_hashfn_ipv4(node->nsec.addr.ipv4);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tidx = sel_netnode_hashfn_ipv6(&node->nsec.addr.ipv6);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\t/* we need to impose a limit on the growth of the hash table so check\n\t * this bucket to make sure it is within the specified bounds */\n\tlist_add_rcu(&node->list, &sel_netnode_hash[idx].list);\n\tif (sel_netnode_hash[idx].size == SEL_NETNODE_HASH_BKT_LIMIT) {\n\t\tstruct sel_netnode *tail;\n\t\ttail = list_entry(\n\t\t\trcu_dereference_protected(sel_netnode_hash[idx].list.prev,\n\t\t\t\t\t\t  lockdep_is_held(&sel_netnode_lock)),\n\t\t\tstruct sel_netnode, list);\n\t\tlist_del_rcu(&tail->list);\n\t\tkfree_rcu(tail, rcu);\n\t} else\n\t\tsel_netnode_hash[idx].size++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_node_sid",
          "args": [
            "PF_INET6",
            "addr",
            "sizeof(struct in6_addr)",
            "sid"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "security_node_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2390-2455",
          "snippet": "int security_node_sid(u16 domain,\n\t\t      void *addrp,\n\t\t      u32 addrlen,\n\t\t      u32 *out_sid)\n{\n\tint rc;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tswitch (domain) {\n\tcase AF_INET: {\n\t\tu32 addr;\n\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u32))\n\t\t\tgoto out;\n\n\t\taddr = *((u32 *)addrp);\n\n\t\tc = policydb.ocontexts[OCON_NODE];\n\t\twhile (c) {\n\t\t\tif (c->u.node.addr == (addr & c->u.node.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase AF_INET6:\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u64) * 2)\n\t\t\tgoto out;\n\t\tc = policydb.ocontexts[OCON_NODE6];\n\t\twhile (c) {\n\t\t\tif (match_ipv6_addrmask(addrp, c->u.node6.addr,\n\t\t\t\t\t\tc->u.node6.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = 0;\n\t\t*out_sid = SECINITSID_NODE;\n\t\tgoto out;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else {\n\t\t*out_sid = SECINITSID_NODE;\n\t}\n\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nint security_node_sid(u16 domain,\n\t\t      void *addrp,\n\t\t      u32 addrlen,\n\t\t      u32 *out_sid)\n{\n\tint rc;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tswitch (domain) {\n\tcase AF_INET: {\n\t\tu32 addr;\n\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u32))\n\t\t\tgoto out;\n\n\t\taddr = *((u32 *)addrp);\n\n\t\tc = policydb.ocontexts[OCON_NODE];\n\t\twhile (c) {\n\t\t\tif (c->u.node.addr == (addr & c->u.node.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\t}\n\n\tcase AF_INET6:\n\t\trc = -EINVAL;\n\t\tif (addrlen != sizeof(u64) * 2)\n\t\t\tgoto out;\n\t\tc = policydb.ocontexts[OCON_NODE6];\n\t\twhile (c) {\n\t\t\tif (match_ipv6_addrmask(addrp, c->u.node6.addr,\n\t\t\t\t\t\tc->u.node6.mask))\n\t\t\t\tbreak;\n\t\t\tc = c->next;\n\t\t}\n\t\tbreak;\n\n\tdefault:\n\t\trc = 0;\n\t\t*out_sid = SECINITSID_NODE;\n\t\tgoto out;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[0],\n\t\t\t\t\t\t   &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*out_sid = c->sid[0];\n\t} else {\n\t\t*out_sid = SECINITSID_NODE;\n\t}\n\n\trc = 0;\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new)",
            "GFP_ATOMIC"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&sel_netnode_lock"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_netnode_find",
          "args": [
            "addr",
            "family"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netnode_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
          "lines": "114-146",
          "snippet": "static struct sel_netnode *sel_netnode_find(const void *addr, u16 family)\n{\n\tunsigned int idx;\n\tstruct sel_netnode *node;\n\n\tswitch (family) {\n\tcase PF_INET:\n\t\tidx = sel_netnode_hashfn_ipv4(*(__be32 *)addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tidx = sel_netnode_hashfn_ipv6(addr);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry_rcu(node, &sel_netnode_hash[idx].list, list)\n\t\tif (node->nsec.family == family)\n\t\t\tswitch (family) {\n\t\t\tcase PF_INET:\n\t\t\t\tif (node->nsec.addr.ipv4 == *(__be32 *)addr)\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\tcase PF_INET6:\n\t\t\t\tif (ipv6_addr_equal(&node->nsec.addr.ipv6,\n\t\t\t\t\t\t    addr))\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"netnode.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\nstatic struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];\n\nstatic struct sel_netnode *sel_netnode_find(const void *addr, u16 family)\n{\n\tunsigned int idx;\n\tstruct sel_netnode *node;\n\n\tswitch (family) {\n\tcase PF_INET:\n\t\tidx = sel_netnode_hashfn_ipv4(*(__be32 *)addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tidx = sel_netnode_hashfn_ipv6(addr);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry_rcu(node, &sel_netnode_hash[idx].list, list)\n\t\tif (node->nsec.family == family)\n\t\t\tswitch (family) {\n\t\t\tcase PF_INET:\n\t\t\t\tif (node->nsec.addr.ipv4 == *(__be32 *)addr)\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\tcase PF_INET6:\n\t\t\t\tif (ipv6_addr_equal(&node->nsec.addr.ipv6,\n\t\t\t\t\t\t    addr))\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&sel_netnode_lock"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\nstatic DEFINE_SPINLOCK(sel_netnode_lock);\n\nstatic int sel_netnode_sid_slow(void *addr, u16 family, u32 *sid)\n{\n\tint ret = -ENOMEM;\n\tstruct sel_netnode *node;\n\tstruct sel_netnode *new = NULL;\n\n\tspin_lock_bh(&sel_netnode_lock);\n\tnode = sel_netnode_find(addr, family);\n\tif (node != NULL) {\n\t\t*sid = node->nsec.sid;\n\t\tspin_unlock_bh(&sel_netnode_lock);\n\t\treturn 0;\n\t}\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (new == NULL)\n\t\tgoto out;\n\tswitch (family) {\n\tcase PF_INET:\n\t\tret = security_node_sid(PF_INET,\n\t\t\t\t\taddr, sizeof(struct in_addr), sid);\n\t\tnew->nsec.addr.ipv4 = *(__be32 *)addr;\n\t\tbreak;\n\tcase PF_INET6:\n\t\tret = security_node_sid(PF_INET6,\n\t\t\t\t\taddr, sizeof(struct in6_addr), sid);\n\t\tnew->nsec.addr.ipv6 = *(struct in6_addr *)addr;\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\tret = -EINVAL;\n\t}\n\tif (ret != 0)\n\t\tgoto out;\n\n\tnew->nsec.family = family;\n\tnew->nsec.sid = *sid;\n\tsel_netnode_insert(new);\n\nout:\n\tspin_unlock_bh(&sel_netnode_lock);\n\tif (unlikely(ret)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in sel_netnode_sid_slow(),\"\n\t\t       \" unable to determine network node label\\n\");\n\t\tkfree(new);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sel_netnode_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
    "lines": "156-185",
    "snippet": "static void sel_netnode_insert(struct sel_netnode *node)\n{\n\tunsigned int idx;\n\n\tswitch (node->nsec.family) {\n\tcase PF_INET:\n\t\tidx = sel_netnode_hashfn_ipv4(node->nsec.addr.ipv4);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tidx = sel_netnode_hashfn_ipv6(&node->nsec.addr.ipv6);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\t/* we need to impose a limit on the growth of the hash table so check\n\t * this bucket to make sure it is within the specified bounds */\n\tlist_add_rcu(&node->list, &sel_netnode_hash[idx].list);\n\tif (sel_netnode_hash[idx].size == SEL_NETNODE_HASH_BKT_LIMIT) {\n\t\tstruct sel_netnode *tail;\n\t\ttail = list_entry(\n\t\t\trcu_dereference_protected(sel_netnode_hash[idx].list.prev,\n\t\t\t\t\t\t  lockdep_is_held(&sel_netnode_lock)),\n\t\t\tstruct sel_netnode, list);\n\t\tlist_del_rcu(&tail->list);\n\t\tkfree_rcu(tail, rcu);\n\t} else\n\t\tsel_netnode_hash[idx].size++;\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"netnode.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define SEL_NETNODE_HASH_BKT_LIMIT   16"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(sel_netnode_lock);",
      "static struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "tail",
            "rcu"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&tail->list"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "rcu_dereference_protected(sel_netnode_hash[idx].list.prev,\n\t\t\t\t\t\t  lockdep_is_held(&sel_netnode_lock))",
            "structsel_netnode",
            "list"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "sel_netnode_hash[idx].list.prev",
            "lockdep_is_held(&sel_netnode_lock)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&sel_netnode_lock"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&node->list",
            "&sel_netnode_hash[idx].list"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_netnode_hashfn_ipv6",
          "args": [
            "&node->nsec.addr.ipv6"
          ],
          "line": 165
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netnode_hashfn_ipv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
          "lines": "96-102",
          "snippet": "static unsigned int sel_netnode_hashfn_ipv6(const struct in6_addr *addr)\n{\n\t/* just hash the least significant 32 bits to keep things fast (they\n\t * are the most likely to be different anyway), we can revisit this\n\t * later if needed */\n\treturn (addr->s6_addr32[3] & (SEL_NETNODE_HASH_SIZE - 1));\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"netnode.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define SEL_NETNODE_HASH_SIZE       256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_NETNODE_HASH_SIZE       256\n\nstatic unsigned int sel_netnode_hashfn_ipv6(const struct in6_addr *addr)\n{\n\t/* just hash the least significant 32 bits to keep things fast (they\n\t * are the most likely to be different anyway), we can revisit this\n\t * later if needed */\n\treturn (addr->s6_addr32[3] & (SEL_NETNODE_HASH_SIZE - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sel_netnode_hashfn_ipv4",
          "args": [
            "node->nsec.addr.ipv4"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netnode_hashfn_ipv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
          "lines": "80-85",
          "snippet": "static unsigned int sel_netnode_hashfn_ipv4(__be32 addr)\n{\n\t/* at some point we should determine if the mismatch in byte order\n\t * affects the hash function dramatically */\n\treturn (addr & (SEL_NETNODE_HASH_SIZE - 1));\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"netnode.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define SEL_NETNODE_HASH_SIZE       256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_NETNODE_HASH_SIZE       256\n\nstatic unsigned int sel_netnode_hashfn_ipv4(__be32 addr)\n{\n\t/* at some point we should determine if the mismatch in byte order\n\t * affects the hash function dramatically */\n\treturn (addr & (SEL_NETNODE_HASH_SIZE - 1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_NETNODE_HASH_BKT_LIMIT   16\n\nstatic DEFINE_SPINLOCK(sel_netnode_lock);\nstatic struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];\n\nstatic void sel_netnode_insert(struct sel_netnode *node)\n{\n\tunsigned int idx;\n\n\tswitch (node->nsec.family) {\n\tcase PF_INET:\n\t\tidx = sel_netnode_hashfn_ipv4(node->nsec.addr.ipv4);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tidx = sel_netnode_hashfn_ipv6(&node->nsec.addr.ipv6);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn;\n\t}\n\n\t/* we need to impose a limit on the growth of the hash table so check\n\t * this bucket to make sure it is within the specified bounds */\n\tlist_add_rcu(&node->list, &sel_netnode_hash[idx].list);\n\tif (sel_netnode_hash[idx].size == SEL_NETNODE_HASH_BKT_LIMIT) {\n\t\tstruct sel_netnode *tail;\n\t\ttail = list_entry(\n\t\t\trcu_dereference_protected(sel_netnode_hash[idx].list.prev,\n\t\t\t\t\t\t  lockdep_is_held(&sel_netnode_lock)),\n\t\t\tstruct sel_netnode, list);\n\t\tlist_del_rcu(&tail->list);\n\t\tkfree_rcu(tail, rcu);\n\t} else\n\t\tsel_netnode_hash[idx].size++;\n}"
  },
  {
    "function_name": "sel_netnode_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
    "lines": "114-146",
    "snippet": "static struct sel_netnode *sel_netnode_find(const void *addr, u16 family)\n{\n\tunsigned int idx;\n\tstruct sel_netnode *node;\n\n\tswitch (family) {\n\tcase PF_INET:\n\t\tidx = sel_netnode_hashfn_ipv4(*(__be32 *)addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tidx = sel_netnode_hashfn_ipv6(addr);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry_rcu(node, &sel_netnode_hash[idx].list, list)\n\t\tif (node->nsec.family == family)\n\t\t\tswitch (family) {\n\t\t\tcase PF_INET:\n\t\t\t\tif (node->nsec.addr.ipv4 == *(__be32 *)addr)\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\tcase PF_INET6:\n\t\t\t\tif (ipv6_addr_equal(&node->nsec.addr.ipv6,\n\t\t\t\t\t\t    addr))\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"netnode.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ipv6_addr_equal",
          "args": [
            "&node->nsec.addr.ipv6",
            "addr"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "node",
            "&sel_netnode_hash[idx].list",
            "list"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_netnode_hashfn_ipv6",
          "args": [
            "addr"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netnode_hashfn_ipv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
          "lines": "96-102",
          "snippet": "static unsigned int sel_netnode_hashfn_ipv6(const struct in6_addr *addr)\n{\n\t/* just hash the least significant 32 bits to keep things fast (they\n\t * are the most likely to be different anyway), we can revisit this\n\t * later if needed */\n\treturn (addr->s6_addr32[3] & (SEL_NETNODE_HASH_SIZE - 1));\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"netnode.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define SEL_NETNODE_HASH_SIZE       256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_NETNODE_HASH_SIZE       256\n\nstatic unsigned int sel_netnode_hashfn_ipv6(const struct in6_addr *addr)\n{\n\t/* just hash the least significant 32 bits to keep things fast (they\n\t * are the most likely to be different anyway), we can revisit this\n\t * later if needed */\n\treturn (addr->s6_addr32[3] & (SEL_NETNODE_HASH_SIZE - 1));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sel_netnode_hashfn_ipv4",
          "args": [
            "*(__be32 *)addr"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netnode_hashfn_ipv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
          "lines": "80-85",
          "snippet": "static unsigned int sel_netnode_hashfn_ipv4(__be32 addr)\n{\n\t/* at some point we should determine if the mismatch in byte order\n\t * affects the hash function dramatically */\n\treturn (addr & (SEL_NETNODE_HASH_SIZE - 1));\n}",
          "includes": [
            "#include \"objsec.h\"",
            "#include \"netnode.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define SEL_NETNODE_HASH_SIZE       256"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_NETNODE_HASH_SIZE       256\n\nstatic unsigned int sel_netnode_hashfn_ipv4(__be32 addr)\n{\n\t/* at some point we should determine if the mismatch in byte order\n\t * affects the hash function dramatically */\n\treturn (addr & (SEL_NETNODE_HASH_SIZE - 1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\nstatic struct sel_netnode_bkt sel_netnode_hash[SEL_NETNODE_HASH_SIZE];\n\nstatic struct sel_netnode *sel_netnode_find(const void *addr, u16 family)\n{\n\tunsigned int idx;\n\tstruct sel_netnode *node;\n\n\tswitch (family) {\n\tcase PF_INET:\n\t\tidx = sel_netnode_hashfn_ipv4(*(__be32 *)addr);\n\t\tbreak;\n\tcase PF_INET6:\n\t\tidx = sel_netnode_hashfn_ipv6(addr);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t\treturn NULL;\n\t}\n\n\tlist_for_each_entry_rcu(node, &sel_netnode_hash[idx].list, list)\n\t\tif (node->nsec.family == family)\n\t\t\tswitch (family) {\n\t\t\tcase PF_INET:\n\t\t\t\tif (node->nsec.addr.ipv4 == *(__be32 *)addr)\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\tcase PF_INET6:\n\t\t\t\tif (ipv6_addr_equal(&node->nsec.addr.ipv6,\n\t\t\t\t\t\t    addr))\n\t\t\t\t\treturn node;\n\t\t\t\tbreak;\n\t\t\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "sel_netnode_hashfn_ipv6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
    "lines": "96-102",
    "snippet": "static unsigned int sel_netnode_hashfn_ipv6(const struct in6_addr *addr)\n{\n\t/* just hash the least significant 32 bits to keep things fast (they\n\t * are the most likely to be different anyway), we can revisit this\n\t * later if needed */\n\treturn (addr->s6_addr32[3] & (SEL_NETNODE_HASH_SIZE - 1));\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"netnode.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define SEL_NETNODE_HASH_SIZE       256"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_NETNODE_HASH_SIZE       256\n\nstatic unsigned int sel_netnode_hashfn_ipv6(const struct in6_addr *addr)\n{\n\t/* just hash the least significant 32 bits to keep things fast (they\n\t * are the most likely to be different anyway), we can revisit this\n\t * later if needed */\n\treturn (addr->s6_addr32[3] & (SEL_NETNODE_HASH_SIZE - 1));\n}"
  },
  {
    "function_name": "sel_netnode_hashfn_ipv4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netnode.c",
    "lines": "80-85",
    "snippet": "static unsigned int sel_netnode_hashfn_ipv4(__be32 addr)\n{\n\t/* at some point we should determine if the mismatch in byte order\n\t * affects the hash function dramatically */\n\treturn (addr & (SEL_NETNODE_HASH_SIZE - 1));\n}",
    "includes": [
      "#include \"objsec.h\"",
      "#include \"netnode.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/in6.h>",
      "#include <linux/in.h>",
      "#include <linux/spinlock.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/types.h>"
    ],
    "macros_used": [
      "#define SEL_NETNODE_HASH_SIZE       256"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"objsec.h\"\n#include \"netnode.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/rcupdate.h>\n#include <linux/types.h>\n\n#define SEL_NETNODE_HASH_SIZE       256\n\nstatic unsigned int sel_netnode_hashfn_ipv4(__be32 addr)\n{\n\t/* at some point we should determine if the mismatch in byte order\n\t * affects the hash function dramatically */\n\treturn (addr & (SEL_NETNODE_HASH_SIZE - 1));\n}"
  }
]