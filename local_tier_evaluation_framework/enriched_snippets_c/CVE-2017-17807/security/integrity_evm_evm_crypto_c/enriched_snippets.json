[
  {
    "function_name": "evm_init_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
    "lines": "291-311",
    "snippet": "int evm_init_key(void)\n{\n\tstruct key *evm_key;\n\tstruct encrypted_key_payload *ekp;\n\tint rc;\n\n\tevm_key = request_key(&key_type_encrypted, EVMKEY, NULL);\n\tif (IS_ERR(evm_key))\n\t\treturn -ENOENT;\n\n\tdown_read(&evm_key->sem);\n\tekp = evm_key->payload.data[0];\n\n\trc = evm_set_key(ekp->decrypted_data, ekp->decrypted_datalen);\n\n\t/* burn the original key contents */\n\tmemset(ekp->decrypted_data, 0, ekp->decrypted_datalen);\n\tup_read(&evm_key->sem);\n\tkey_put(evm_key);\n\treturn rc;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/hash.h>",
      "#include <keys/encrypted-type.h>",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define EVMKEY \"evm-key\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "evm_key"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&evm_key->sem"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "ekp->decrypted_data",
            "0",
            "ekp->decrypted_datalen"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evm_set_key",
          "args": [
            "ekp->decrypted_data",
            "ekp->decrypted_datalen"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "evm_set_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "52-71",
          "snippet": "int evm_set_key(void *key, size_t keylen)\n{\n\tint rc;\n\n\trc = -EBUSY;\n\tif (test_and_set_bit(EVM_SET_KEY_BUSY, &evm_set_key_flags))\n\t\tgoto busy;\n\trc = -EINVAL;\n\tif (keylen > MAX_KEY_SIZE)\n\t\tgoto inval;\n\tmemcpy(evmkey, key, keylen);\n\tevm_initialized |= EVM_INIT_HMAC;\n\tpr_info(\"key initialized\\n\");\n\treturn 0;\ninval:\n\tclear_bit(EVM_SET_KEY_BUSY, &evm_set_key_flags);\nbusy:\n\tpr_err(\"key initialization failed\\n\");\n\treturn rc;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define EVM_SET_KEY_BUSY 0",
            "#define MAX_KEY_SIZE 128"
          ],
          "globals_used": [
            "static unsigned char evmkey[MAX_KEY_SIZE];",
            "static unsigned long evm_set_key_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\n#define EVM_SET_KEY_BUSY 0\n#define MAX_KEY_SIZE 128\n\nstatic unsigned char evmkey[MAX_KEY_SIZE];\nstatic unsigned long evm_set_key_flags;\n\nint evm_set_key(void *key, size_t keylen)\n{\n\tint rc;\n\n\trc = -EBUSY;\n\tif (test_and_set_bit(EVM_SET_KEY_BUSY, &evm_set_key_flags))\n\t\tgoto busy;\n\trc = -EINVAL;\n\tif (keylen > MAX_KEY_SIZE)\n\t\tgoto inval;\n\tmemcpy(evmkey, key, keylen);\n\tevm_initialized |= EVM_INIT_HMAC;\n\tpr_info(\"key initialized\\n\");\n\treturn 0;\ninval:\n\tclear_bit(EVM_SET_KEY_BUSY, &evm_set_key_flags);\nbusy:\n\tpr_err(\"key initialization failed\\n\");\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&evm_key->sem"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "evm_key"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_key",
          "args": [
            "&key_type_encrypted",
            "EVMKEY",
            "NULL"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "request_key_auth_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "84-104",
          "snippet": "static long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void request_key_auth_revoke(struct key *);",
            "static void request_key_auth_destroy(struct key *);",
            "static long request_key_auth_read(const struct key *, char __user *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstatic long request_key_auth_read(const struct key *, char __user *, size_t);\n\nstatic long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\n#define EVMKEY \"evm-key\"\n\nint evm_init_key(void)\n{\n\tstruct key *evm_key;\n\tstruct encrypted_key_payload *ekp;\n\tint rc;\n\n\tevm_key = request_key(&key_type_encrypted, EVMKEY, NULL);\n\tif (IS_ERR(evm_key))\n\t\treturn -ENOENT;\n\n\tdown_read(&evm_key->sem);\n\tekp = evm_key->payload.data[0];\n\n\trc = evm_set_key(ekp->decrypted_data, ekp->decrypted_datalen);\n\n\t/* burn the original key contents */\n\tmemset(ekp->decrypted_data, 0, ekp->decrypted_datalen);\n\tup_read(&evm_key->sem);\n\tkey_put(evm_key);\n\treturn rc;\n}"
  },
  {
    "function_name": "evm_init_hmac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
    "lines": "271-286",
    "snippet": "int evm_init_hmac(struct inode *inode, const struct xattr *lsm_xattr,\n\t\t  char *hmac_val)\n{\n\tstruct shash_desc *desc;\n\n\tdesc = init_desc(EVM_XATTR_HMAC);\n\tif (IS_ERR(desc)) {\n\t\tpr_info(\"init_desc failed\\n\");\n\t\treturn PTR_ERR(desc);\n\t}\n\n\tcrypto_shash_update(desc, lsm_xattr->value, lsm_xattr->value_len);\n\thmac_add_misc(desc, inode, hmac_val);\n\tkfree(desc);\n\treturn 0;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/hash.h>",
      "#include <keys/encrypted-type.h>",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "desc"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmac_add_misc",
          "args": [
            "desc",
            "inode",
            "hmac_val"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_add_misc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "140-170",
          "snippet": "static void hmac_add_misc(struct shash_desc *desc, struct inode *inode,\n\t\t\t  char *digest)\n{\n\tstruct h_misc {\n\t\tunsigned long ino;\n\t\t__u32 generation;\n\t\tuid_t uid;\n\t\tgid_t gid;\n\t\tumode_t mode;\n\t} hmac_misc;\n\n\tmemset(&hmac_misc, 0, sizeof(hmac_misc));\n\thmac_misc.ino = inode->i_ino;\n\thmac_misc.generation = inode->i_generation;\n\t/* The hmac uid and gid must be encoded in the initial user\n\t * namespace (not the filesystems user namespace) as encoding\n\t * them in the filesystems user namespace allows an attack\n\t * where first they are written in an unprivileged fuse mount\n\t * of a filesystem and then the system is tricked to mount the\n\t * filesystem for real on next boot and trust it because\n\t * everything is signed.\n\t */\n\thmac_misc.uid = from_kuid(&init_user_ns, inode->i_uid);\n\thmac_misc.gid = from_kgid(&init_user_ns, inode->i_gid);\n\thmac_misc.mode = inode->i_mode;\n\tcrypto_shash_update(desc, (const u8 *)&hmac_misc, sizeof(hmac_misc));\n\tif (evm_hmac_attrs & EVM_ATTR_FSUUID)\n\t\tcrypto_shash_update(desc, &inode->i_sb->s_uuid.b[0],\n\t\t\t\t    sizeof(inode->i_sb->s_uuid));\n\tcrypto_shash_final(desc, digest);\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic void hmac_add_misc(struct shash_desc *desc, struct inode *inode,\n\t\t\t  char *digest)\n{\n\tstruct h_misc {\n\t\tunsigned long ino;\n\t\t__u32 generation;\n\t\tuid_t uid;\n\t\tgid_t gid;\n\t\tumode_t mode;\n\t} hmac_misc;\n\n\tmemset(&hmac_misc, 0, sizeof(hmac_misc));\n\thmac_misc.ino = inode->i_ino;\n\thmac_misc.generation = inode->i_generation;\n\t/* The hmac uid and gid must be encoded in the initial user\n\t * namespace (not the filesystems user namespace) as encoding\n\t * them in the filesystems user namespace allows an attack\n\t * where first they are written in an unprivileged fuse mount\n\t * of a filesystem and then the system is tricked to mount the\n\t * filesystem for real on next boot and trust it because\n\t * everything is signed.\n\t */\n\thmac_misc.uid = from_kuid(&init_user_ns, inode->i_uid);\n\thmac_misc.gid = from_kgid(&init_user_ns, inode->i_gid);\n\thmac_misc.mode = inode->i_mode;\n\tcrypto_shash_update(desc, (const u8 *)&hmac_misc, sizeof(hmac_misc));\n\tif (evm_hmac_attrs & EVM_ATTR_FSUUID)\n\t\tcrypto_shash_update(desc, &inode->i_sb->s_uuid.b[0],\n\t\t\t\t    sizeof(inode->i_sb->s_uuid));\n\tcrypto_shash_final(desc, digest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "desc",
            "lsm_xattr->value",
            "lsm_xattr->value_len"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "desc"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"init_desc failed\\n\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "desc"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_desc",
          "args": [
            "EVM_XATTR_HMAC"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "init_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "74-132",
          "snippet": "static struct shash_desc *init_desc(char type)\n{\n\tlong rc;\n\tchar *algo;\n\tstruct crypto_shash **tfm;\n\tstruct shash_desc *desc;\n\n\tif (type == EVM_XATTR_HMAC) {\n\t\tif (!(evm_initialized & EVM_INIT_HMAC)) {\n\t\t\tpr_err_once(\"HMAC key is not set\\n\");\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\t}\n\t\ttfm = &hmac_tfm;\n\t\talgo = evm_hmac;\n\t} else {\n\t\ttfm = &hash_tfm;\n\t\talgo = evm_hash;\n\t}\n\n\tif (*tfm == NULL) {\n\t\tmutex_lock(&mutex);\n\t\tif (*tfm)\n\t\t\tgoto out;\n\t\t*tfm = crypto_alloc_shash(algo, 0, CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(*tfm)) {\n\t\t\trc = PTR_ERR(*tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %ld)\\n\", algo, rc);\n\t\t\t*tfm = NULL;\n\t\t\tmutex_unlock(&mutex);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (type == EVM_XATTR_HMAC) {\n\t\t\trc = crypto_shash_setkey(*tfm, evmkey, evmkey_len);\n\t\t\tif (rc) {\n\t\t\t\tcrypto_free_shash(*tfm);\n\t\t\t\t*tfm = NULL;\n\t\t\t\tmutex_unlock(&mutex);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\nout:\n\t\tmutex_unlock(&mutex);\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(*tfm),\n\t\t\tGFP_KERNEL);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc->tfm = *tfm;\n\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\trc = crypto_shash_init(desc);\n\tif (rc) {\n\t\tkfree(desc);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn desc;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char evmkey[MAX_KEY_SIZE];",
            "static int evmkey_len = MAX_KEY_SIZE;",
            "struct crypto_shash *hmac_tfm;",
            "struct crypto_shash *hash_tfm;",
            "static DEFINE_MUTEX(mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic unsigned char evmkey[MAX_KEY_SIZE];\nstatic int evmkey_len = MAX_KEY_SIZE;\nstruct crypto_shash *hmac_tfm;\nstruct crypto_shash *hash_tfm;\nstatic DEFINE_MUTEX(mutex);\n\nstatic struct shash_desc *init_desc(char type)\n{\n\tlong rc;\n\tchar *algo;\n\tstruct crypto_shash **tfm;\n\tstruct shash_desc *desc;\n\n\tif (type == EVM_XATTR_HMAC) {\n\t\tif (!(evm_initialized & EVM_INIT_HMAC)) {\n\t\t\tpr_err_once(\"HMAC key is not set\\n\");\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\t}\n\t\ttfm = &hmac_tfm;\n\t\talgo = evm_hmac;\n\t} else {\n\t\ttfm = &hash_tfm;\n\t\talgo = evm_hash;\n\t}\n\n\tif (*tfm == NULL) {\n\t\tmutex_lock(&mutex);\n\t\tif (*tfm)\n\t\t\tgoto out;\n\t\t*tfm = crypto_alloc_shash(algo, 0, CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(*tfm)) {\n\t\t\trc = PTR_ERR(*tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %ld)\\n\", algo, rc);\n\t\t\t*tfm = NULL;\n\t\t\tmutex_unlock(&mutex);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (type == EVM_XATTR_HMAC) {\n\t\t\trc = crypto_shash_setkey(*tfm, evmkey, evmkey_len);\n\t\t\tif (rc) {\n\t\t\t\tcrypto_free_shash(*tfm);\n\t\t\t\t*tfm = NULL;\n\t\t\t\tmutex_unlock(&mutex);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\nout:\n\t\tmutex_unlock(&mutex);\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(*tfm),\n\t\t\tGFP_KERNEL);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc->tfm = *tfm;\n\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\trc = crypto_shash_init(desc);\n\tif (rc) {\n\t\tkfree(desc);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn desc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_init_hmac(struct inode *inode, const struct xattr *lsm_xattr,\n\t\t  char *hmac_val)\n{\n\tstruct shash_desc *desc;\n\n\tdesc = init_desc(EVM_XATTR_HMAC);\n\tif (IS_ERR(desc)) {\n\t\tpr_info(\"init_desc failed\\n\");\n\t\treturn PTR_ERR(desc);\n\t}\n\n\tcrypto_shash_update(desc, lsm_xattr->value, lsm_xattr->value_len);\n\thmac_add_misc(desc, inode, hmac_val);\n\tkfree(desc);\n\treturn 0;\n}"
  },
  {
    "function_name": "evm_update_evmxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
    "lines": "251-269",
    "snippet": "int evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && (inode->i_opflags & IOP_XATTR)) {\n\t\trc = __vfs_removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/hash.h>",
      "#include <keys/encrypted-type.h>",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vfs_removexattr",
          "args": [
            "dentry",
            "XATTR_NAME_EVM"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__vfs_setxattr_noperm",
          "args": [
            "dentry",
            "XATTR_NAME_EVM",
            "&xattr_data",
            "sizeof(xattr_data)",
            "0"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evm_calc_hmac",
          "args": [
            "dentry",
            "xattr_name",
            "xattr_value",
            "xattr_value_len",
            "xattr_data.digest"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "evm_calc_hmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "230-236",
          "snippet": "int evm_calc_hmac(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  char *digest)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\treq_xattr_value_len, EVM_XATTR_HMAC, digest);\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_calc_hmac(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  char *digest)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\treq_xattr_value_len, EVM_XATTR_HMAC, digest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_update_evmxattr(struct dentry *dentry, const char *xattr_name,\n\t\t\tconst char *xattr_value, size_t xattr_value_len)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct evm_ima_xattr_data xattr_data;\n\tint rc = 0;\n\n\trc = evm_calc_hmac(dentry, xattr_name, xattr_value,\n\t\t\t   xattr_value_len, xattr_data.digest);\n\tif (rc == 0) {\n\t\txattr_data.type = EVM_XATTR_HMAC;\n\t\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_EVM,\n\t\t\t\t\t   &xattr_data,\n\t\t\t\t\t   sizeof(xattr_data), 0);\n\t} else if (rc == -ENODATA && (inode->i_opflags & IOP_XATTR)) {\n\t\trc = __vfs_removexattr(dentry, XATTR_NAME_EVM);\n\t}\n\treturn rc;\n}"
  },
  {
    "function_name": "evm_calc_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
    "lines": "238-244",
    "snippet": "int evm_calc_hash(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  char *digest)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\treq_xattr_value_len, IMA_XATTR_DIGEST, digest);\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/hash.h>",
      "#include <keys/encrypted-type.h>",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evm_calc_hmac_or_hash",
          "args": [
            "dentry",
            "req_xattr_name",
            "req_xattr_value",
            "req_xattr_value_len",
            "IMA_XATTR_DIGEST",
            "digest"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "evm_calc_hmac_or_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "179-228",
          "snippet": "static int evm_calc_hmac_or_hash(struct dentry *dentry,\n\t\t\t\tconst char *req_xattr_name,\n\t\t\t\tconst char *req_xattr_value,\n\t\t\t\tsize_t req_xattr_value_len,\n\t\t\t\tchar type, char *digest)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct shash_desc *desc;\n\tchar **xattrname;\n\tsize_t xattr_size = 0;\n\tchar *xattr_value = NULL;\n\tint error;\n\tint size;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tdesc = init_desc(type);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\terror = -ENODATA;\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((req_xattr_name && req_xattr_value)\n\t\t    && !strcmp(*xattrname, req_xattr_name)) {\n\t\t\terror = 0;\n\t\t\tcrypto_shash_update(desc, (const u8 *)req_xattr_value,\n\t\t\t\t\t     req_xattr_value_len);\n\t\t\tcontinue;\n\t\t}\n\t\tsize = vfs_getxattr_alloc(dentry, *xattrname,\n\t\t\t\t\t  &xattr_value, xattr_size, GFP_NOFS);\n\t\tif (size == -ENOMEM) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (size < 0)\n\t\t\tcontinue;\n\n\t\terror = 0;\n\t\txattr_size = size;\n\t\tcrypto_shash_update(desc, (const u8 *)xattr_value, xattr_size);\n\t}\n\thmac_add_misc(desc, inode, digest);\n\nout:\n\tkfree(xattr_value);\n\tkfree(desc);\n\treturn error;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int evm_calc_hmac_or_hash(struct dentry *dentry,\n\t\t\t\tconst char *req_xattr_name,\n\t\t\t\tconst char *req_xattr_value,\n\t\t\t\tsize_t req_xattr_value_len,\n\t\t\t\tchar type, char *digest)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct shash_desc *desc;\n\tchar **xattrname;\n\tsize_t xattr_size = 0;\n\tchar *xattr_value = NULL;\n\tint error;\n\tint size;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tdesc = init_desc(type);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\terror = -ENODATA;\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((req_xattr_name && req_xattr_value)\n\t\t    && !strcmp(*xattrname, req_xattr_name)) {\n\t\t\terror = 0;\n\t\t\tcrypto_shash_update(desc, (const u8 *)req_xattr_value,\n\t\t\t\t\t     req_xattr_value_len);\n\t\t\tcontinue;\n\t\t}\n\t\tsize = vfs_getxattr_alloc(dentry, *xattrname,\n\t\t\t\t\t  &xattr_value, xattr_size, GFP_NOFS);\n\t\tif (size == -ENOMEM) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (size < 0)\n\t\t\tcontinue;\n\n\t\terror = 0;\n\t\txattr_size = size;\n\t\tcrypto_shash_update(desc, (const u8 *)xattr_value, xattr_size);\n\t}\n\thmac_add_misc(desc, inode, digest);\n\nout:\n\tkfree(xattr_value);\n\tkfree(desc);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_calc_hash(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  char *digest)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\treq_xattr_value_len, IMA_XATTR_DIGEST, digest);\n}"
  },
  {
    "function_name": "evm_calc_hmac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
    "lines": "230-236",
    "snippet": "int evm_calc_hmac(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  char *digest)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\treq_xattr_value_len, EVM_XATTR_HMAC, digest);\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/hash.h>",
      "#include <keys/encrypted-type.h>",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evm_calc_hmac_or_hash",
          "args": [
            "dentry",
            "req_xattr_name",
            "req_xattr_value",
            "req_xattr_value_len",
            "EVM_XATTR_HMAC",
            "digest"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "evm_calc_hmac_or_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "179-228",
          "snippet": "static int evm_calc_hmac_or_hash(struct dentry *dentry,\n\t\t\t\tconst char *req_xattr_name,\n\t\t\t\tconst char *req_xattr_value,\n\t\t\t\tsize_t req_xattr_value_len,\n\t\t\t\tchar type, char *digest)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct shash_desc *desc;\n\tchar **xattrname;\n\tsize_t xattr_size = 0;\n\tchar *xattr_value = NULL;\n\tint error;\n\tint size;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tdesc = init_desc(type);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\terror = -ENODATA;\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((req_xattr_name && req_xattr_value)\n\t\t    && !strcmp(*xattrname, req_xattr_name)) {\n\t\t\terror = 0;\n\t\t\tcrypto_shash_update(desc, (const u8 *)req_xattr_value,\n\t\t\t\t\t     req_xattr_value_len);\n\t\t\tcontinue;\n\t\t}\n\t\tsize = vfs_getxattr_alloc(dentry, *xattrname,\n\t\t\t\t\t  &xattr_value, xattr_size, GFP_NOFS);\n\t\tif (size == -ENOMEM) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (size < 0)\n\t\t\tcontinue;\n\n\t\terror = 0;\n\t\txattr_size = size;\n\t\tcrypto_shash_update(desc, (const u8 *)xattr_value, xattr_size);\n\t}\n\thmac_add_misc(desc, inode, digest);\n\nout:\n\tkfree(xattr_value);\n\tkfree(desc);\n\treturn error;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int evm_calc_hmac_or_hash(struct dentry *dentry,\n\t\t\t\tconst char *req_xattr_name,\n\t\t\t\tconst char *req_xattr_value,\n\t\t\t\tsize_t req_xattr_value_len,\n\t\t\t\tchar type, char *digest)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct shash_desc *desc;\n\tchar **xattrname;\n\tsize_t xattr_size = 0;\n\tchar *xattr_value = NULL;\n\tint error;\n\tint size;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tdesc = init_desc(type);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\terror = -ENODATA;\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((req_xattr_name && req_xattr_value)\n\t\t    && !strcmp(*xattrname, req_xattr_name)) {\n\t\t\terror = 0;\n\t\t\tcrypto_shash_update(desc, (const u8 *)req_xattr_value,\n\t\t\t\t\t     req_xattr_value_len);\n\t\t\tcontinue;\n\t\t}\n\t\tsize = vfs_getxattr_alloc(dentry, *xattrname,\n\t\t\t\t\t  &xattr_value, xattr_size, GFP_NOFS);\n\t\tif (size == -ENOMEM) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (size < 0)\n\t\t\tcontinue;\n\n\t\terror = 0;\n\t\txattr_size = size;\n\t\tcrypto_shash_update(desc, (const u8 *)xattr_value, xattr_size);\n\t}\n\thmac_add_misc(desc, inode, digest);\n\nout:\n\tkfree(xattr_value);\n\tkfree(desc);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_calc_hmac(struct dentry *dentry, const char *req_xattr_name,\n\t\t  const char *req_xattr_value, size_t req_xattr_value_len,\n\t\t  char *digest)\n{\n\treturn evm_calc_hmac_or_hash(dentry, req_xattr_name, req_xattr_value,\n\t\t\t\treq_xattr_value_len, EVM_XATTR_HMAC, digest);\n}"
  },
  {
    "function_name": "evm_calc_hmac_or_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
    "lines": "179-228",
    "snippet": "static int evm_calc_hmac_or_hash(struct dentry *dentry,\n\t\t\t\tconst char *req_xattr_name,\n\t\t\t\tconst char *req_xattr_value,\n\t\t\t\tsize_t req_xattr_value_len,\n\t\t\t\tchar type, char *digest)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct shash_desc *desc;\n\tchar **xattrname;\n\tsize_t xattr_size = 0;\n\tchar *xattr_value = NULL;\n\tint error;\n\tint size;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tdesc = init_desc(type);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\terror = -ENODATA;\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((req_xattr_name && req_xattr_value)\n\t\t    && !strcmp(*xattrname, req_xattr_name)) {\n\t\t\terror = 0;\n\t\t\tcrypto_shash_update(desc, (const u8 *)req_xattr_value,\n\t\t\t\t\t     req_xattr_value_len);\n\t\t\tcontinue;\n\t\t}\n\t\tsize = vfs_getxattr_alloc(dentry, *xattrname,\n\t\t\t\t\t  &xattr_value, xattr_size, GFP_NOFS);\n\t\tif (size == -ENOMEM) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (size < 0)\n\t\t\tcontinue;\n\n\t\terror = 0;\n\t\txattr_size = size;\n\t\tcrypto_shash_update(desc, (const u8 *)xattr_value, xattr_size);\n\t}\n\thmac_add_misc(desc, inode, digest);\n\nout:\n\tkfree(xattr_value);\n\tkfree(desc);\n\treturn error;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/hash.h>",
      "#include <keys/encrypted-type.h>",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "desc"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "xattr_value"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hmac_add_misc",
          "args": [
            "desc",
            "inode",
            "digest"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "hmac_add_misc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "140-170",
          "snippet": "static void hmac_add_misc(struct shash_desc *desc, struct inode *inode,\n\t\t\t  char *digest)\n{\n\tstruct h_misc {\n\t\tunsigned long ino;\n\t\t__u32 generation;\n\t\tuid_t uid;\n\t\tgid_t gid;\n\t\tumode_t mode;\n\t} hmac_misc;\n\n\tmemset(&hmac_misc, 0, sizeof(hmac_misc));\n\thmac_misc.ino = inode->i_ino;\n\thmac_misc.generation = inode->i_generation;\n\t/* The hmac uid and gid must be encoded in the initial user\n\t * namespace (not the filesystems user namespace) as encoding\n\t * them in the filesystems user namespace allows an attack\n\t * where first they are written in an unprivileged fuse mount\n\t * of a filesystem and then the system is tricked to mount the\n\t * filesystem for real on next boot and trust it because\n\t * everything is signed.\n\t */\n\thmac_misc.uid = from_kuid(&init_user_ns, inode->i_uid);\n\thmac_misc.gid = from_kgid(&init_user_ns, inode->i_gid);\n\thmac_misc.mode = inode->i_mode;\n\tcrypto_shash_update(desc, (const u8 *)&hmac_misc, sizeof(hmac_misc));\n\tif (evm_hmac_attrs & EVM_ATTR_FSUUID)\n\t\tcrypto_shash_update(desc, &inode->i_sb->s_uuid.b[0],\n\t\t\t\t    sizeof(inode->i_sb->s_uuid));\n\tcrypto_shash_final(desc, digest);\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic void hmac_add_misc(struct shash_desc *desc, struct inode *inode,\n\t\t\t  char *digest)\n{\n\tstruct h_misc {\n\t\tunsigned long ino;\n\t\t__u32 generation;\n\t\tuid_t uid;\n\t\tgid_t gid;\n\t\tumode_t mode;\n\t} hmac_misc;\n\n\tmemset(&hmac_misc, 0, sizeof(hmac_misc));\n\thmac_misc.ino = inode->i_ino;\n\thmac_misc.generation = inode->i_generation;\n\t/* The hmac uid and gid must be encoded in the initial user\n\t * namespace (not the filesystems user namespace) as encoding\n\t * them in the filesystems user namespace allows an attack\n\t * where first they are written in an unprivileged fuse mount\n\t * of a filesystem and then the system is tricked to mount the\n\t * filesystem for real on next boot and trust it because\n\t * everything is signed.\n\t */\n\thmac_misc.uid = from_kuid(&init_user_ns, inode->i_uid);\n\thmac_misc.gid = from_kgid(&init_user_ns, inode->i_gid);\n\thmac_misc.mode = inode->i_mode;\n\tcrypto_shash_update(desc, (const u8 *)&hmac_misc, sizeof(hmac_misc));\n\tif (evm_hmac_attrs & EVM_ATTR_FSUUID)\n\t\tcrypto_shash_update(desc, &inode->i_sb->s_uuid.b[0],\n\t\t\t\t    sizeof(inode->i_sb->s_uuid));\n\tcrypto_shash_final(desc, digest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "desc",
            "(const u8 *)xattr_value",
            "xattr_size"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vfs_getxattr_alloc",
          "args": [
            "dentry",
            "*xattrname",
            "&xattr_value",
            "xattr_size",
            "GFP_NOFS"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "desc",
            "(const u8 *)req_xattr_value",
            "req_xattr_value_len"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "*xattrname",
            "req_xattr_name"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "desc"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "desc"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_desc",
          "args": [
            "type"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "init_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "74-132",
          "snippet": "static struct shash_desc *init_desc(char type)\n{\n\tlong rc;\n\tchar *algo;\n\tstruct crypto_shash **tfm;\n\tstruct shash_desc *desc;\n\n\tif (type == EVM_XATTR_HMAC) {\n\t\tif (!(evm_initialized & EVM_INIT_HMAC)) {\n\t\t\tpr_err_once(\"HMAC key is not set\\n\");\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\t}\n\t\ttfm = &hmac_tfm;\n\t\talgo = evm_hmac;\n\t} else {\n\t\ttfm = &hash_tfm;\n\t\talgo = evm_hash;\n\t}\n\n\tif (*tfm == NULL) {\n\t\tmutex_lock(&mutex);\n\t\tif (*tfm)\n\t\t\tgoto out;\n\t\t*tfm = crypto_alloc_shash(algo, 0, CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(*tfm)) {\n\t\t\trc = PTR_ERR(*tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %ld)\\n\", algo, rc);\n\t\t\t*tfm = NULL;\n\t\t\tmutex_unlock(&mutex);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (type == EVM_XATTR_HMAC) {\n\t\t\trc = crypto_shash_setkey(*tfm, evmkey, evmkey_len);\n\t\t\tif (rc) {\n\t\t\t\tcrypto_free_shash(*tfm);\n\t\t\t\t*tfm = NULL;\n\t\t\t\tmutex_unlock(&mutex);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\nout:\n\t\tmutex_unlock(&mutex);\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(*tfm),\n\t\t\tGFP_KERNEL);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc->tfm = *tfm;\n\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\trc = crypto_shash_init(desc);\n\tif (rc) {\n\t\tkfree(desc);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn desc;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned char evmkey[MAX_KEY_SIZE];",
            "static int evmkey_len = MAX_KEY_SIZE;",
            "struct crypto_shash *hmac_tfm;",
            "struct crypto_shash *hash_tfm;",
            "static DEFINE_MUTEX(mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic unsigned char evmkey[MAX_KEY_SIZE];\nstatic int evmkey_len = MAX_KEY_SIZE;\nstruct crypto_shash *hmac_tfm;\nstruct crypto_shash *hash_tfm;\nstatic DEFINE_MUTEX(mutex);\n\nstatic struct shash_desc *init_desc(char type)\n{\n\tlong rc;\n\tchar *algo;\n\tstruct crypto_shash **tfm;\n\tstruct shash_desc *desc;\n\n\tif (type == EVM_XATTR_HMAC) {\n\t\tif (!(evm_initialized & EVM_INIT_HMAC)) {\n\t\t\tpr_err_once(\"HMAC key is not set\\n\");\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\t}\n\t\ttfm = &hmac_tfm;\n\t\talgo = evm_hmac;\n\t} else {\n\t\ttfm = &hash_tfm;\n\t\talgo = evm_hash;\n\t}\n\n\tif (*tfm == NULL) {\n\t\tmutex_lock(&mutex);\n\t\tif (*tfm)\n\t\t\tgoto out;\n\t\t*tfm = crypto_alloc_shash(algo, 0, CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(*tfm)) {\n\t\t\trc = PTR_ERR(*tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %ld)\\n\", algo, rc);\n\t\t\t*tfm = NULL;\n\t\t\tmutex_unlock(&mutex);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (type == EVM_XATTR_HMAC) {\n\t\t\trc = crypto_shash_setkey(*tfm, evmkey, evmkey_len);\n\t\t\tif (rc) {\n\t\t\t\tcrypto_free_shash(*tfm);\n\t\t\t\t*tfm = NULL;\n\t\t\t\tmutex_unlock(&mutex);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\nout:\n\t\tmutex_unlock(&mutex);\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(*tfm),\n\t\t\tGFP_KERNEL);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc->tfm = *tfm;\n\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\trc = crypto_shash_init(desc);\n\tif (rc) {\n\t\tkfree(desc);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic int evm_calc_hmac_or_hash(struct dentry *dentry,\n\t\t\t\tconst char *req_xattr_name,\n\t\t\t\tconst char *req_xattr_value,\n\t\t\t\tsize_t req_xattr_value_len,\n\t\t\t\tchar type, char *digest)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct shash_desc *desc;\n\tchar **xattrname;\n\tsize_t xattr_size = 0;\n\tchar *xattr_value = NULL;\n\tint error;\n\tint size;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn -EOPNOTSUPP;\n\n\tdesc = init_desc(type);\n\tif (IS_ERR(desc))\n\t\treturn PTR_ERR(desc);\n\n\terror = -ENODATA;\n\tfor (xattrname = evm_config_xattrnames; *xattrname != NULL; xattrname++) {\n\t\tif ((req_xattr_name && req_xattr_value)\n\t\t    && !strcmp(*xattrname, req_xattr_name)) {\n\t\t\terror = 0;\n\t\t\tcrypto_shash_update(desc, (const u8 *)req_xattr_value,\n\t\t\t\t\t     req_xattr_value_len);\n\t\t\tcontinue;\n\t\t}\n\t\tsize = vfs_getxattr_alloc(dentry, *xattrname,\n\t\t\t\t\t  &xattr_value, xattr_size, GFP_NOFS);\n\t\tif (size == -ENOMEM) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tif (size < 0)\n\t\t\tcontinue;\n\n\t\terror = 0;\n\t\txattr_size = size;\n\t\tcrypto_shash_update(desc, (const u8 *)xattr_value, xattr_size);\n\t}\n\thmac_add_misc(desc, inode, digest);\n\nout:\n\tkfree(xattr_value);\n\tkfree(desc);\n\treturn error;\n}"
  },
  {
    "function_name": "hmac_add_misc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
    "lines": "140-170",
    "snippet": "static void hmac_add_misc(struct shash_desc *desc, struct inode *inode,\n\t\t\t  char *digest)\n{\n\tstruct h_misc {\n\t\tunsigned long ino;\n\t\t__u32 generation;\n\t\tuid_t uid;\n\t\tgid_t gid;\n\t\tumode_t mode;\n\t} hmac_misc;\n\n\tmemset(&hmac_misc, 0, sizeof(hmac_misc));\n\thmac_misc.ino = inode->i_ino;\n\thmac_misc.generation = inode->i_generation;\n\t/* The hmac uid and gid must be encoded in the initial user\n\t * namespace (not the filesystems user namespace) as encoding\n\t * them in the filesystems user namespace allows an attack\n\t * where first they are written in an unprivileged fuse mount\n\t * of a filesystem and then the system is tricked to mount the\n\t * filesystem for real on next boot and trust it because\n\t * everything is signed.\n\t */\n\thmac_misc.uid = from_kuid(&init_user_ns, inode->i_uid);\n\thmac_misc.gid = from_kgid(&init_user_ns, inode->i_gid);\n\thmac_misc.mode = inode->i_mode;\n\tcrypto_shash_update(desc, (const u8 *)&hmac_misc, sizeof(hmac_misc));\n\tif (evm_hmac_attrs & EVM_ATTR_FSUUID)\n\t\tcrypto_shash_update(desc, &inode->i_sb->s_uuid.b[0],\n\t\t\t\t    sizeof(inode->i_sb->s_uuid));\n\tcrypto_shash_final(desc, digest);\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/hash.h>",
      "#include <keys/encrypted-type.h>",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "desc",
            "digest"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "desc",
            "&inode->i_sb->s_uuid.b[0]",
            "sizeof(inode->i_sb->s_uuid)"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "desc",
            "(const u8 *)&hmac_misc",
            "sizeof(hmac_misc)"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "inode->i_gid"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "inode->i_uid"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&hmac_misc",
            "0",
            "sizeof(hmac_misc)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic void hmac_add_misc(struct shash_desc *desc, struct inode *inode,\n\t\t\t  char *digest)\n{\n\tstruct h_misc {\n\t\tunsigned long ino;\n\t\t__u32 generation;\n\t\tuid_t uid;\n\t\tgid_t gid;\n\t\tumode_t mode;\n\t} hmac_misc;\n\n\tmemset(&hmac_misc, 0, sizeof(hmac_misc));\n\thmac_misc.ino = inode->i_ino;\n\thmac_misc.generation = inode->i_generation;\n\t/* The hmac uid and gid must be encoded in the initial user\n\t * namespace (not the filesystems user namespace) as encoding\n\t * them in the filesystems user namespace allows an attack\n\t * where first they are written in an unprivileged fuse mount\n\t * of a filesystem and then the system is tricked to mount the\n\t * filesystem for real on next boot and trust it because\n\t * everything is signed.\n\t */\n\thmac_misc.uid = from_kuid(&init_user_ns, inode->i_uid);\n\thmac_misc.gid = from_kgid(&init_user_ns, inode->i_gid);\n\thmac_misc.mode = inode->i_mode;\n\tcrypto_shash_update(desc, (const u8 *)&hmac_misc, sizeof(hmac_misc));\n\tif (evm_hmac_attrs & EVM_ATTR_FSUUID)\n\t\tcrypto_shash_update(desc, &inode->i_sb->s_uuid.b[0],\n\t\t\t\t    sizeof(inode->i_sb->s_uuid));\n\tcrypto_shash_final(desc, digest);\n}"
  },
  {
    "function_name": "init_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
    "lines": "74-132",
    "snippet": "static struct shash_desc *init_desc(char type)\n{\n\tlong rc;\n\tchar *algo;\n\tstruct crypto_shash **tfm;\n\tstruct shash_desc *desc;\n\n\tif (type == EVM_XATTR_HMAC) {\n\t\tif (!(evm_initialized & EVM_INIT_HMAC)) {\n\t\t\tpr_err_once(\"HMAC key is not set\\n\");\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\t}\n\t\ttfm = &hmac_tfm;\n\t\talgo = evm_hmac;\n\t} else {\n\t\ttfm = &hash_tfm;\n\t\talgo = evm_hash;\n\t}\n\n\tif (*tfm == NULL) {\n\t\tmutex_lock(&mutex);\n\t\tif (*tfm)\n\t\t\tgoto out;\n\t\t*tfm = crypto_alloc_shash(algo, 0, CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(*tfm)) {\n\t\t\trc = PTR_ERR(*tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %ld)\\n\", algo, rc);\n\t\t\t*tfm = NULL;\n\t\t\tmutex_unlock(&mutex);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (type == EVM_XATTR_HMAC) {\n\t\t\trc = crypto_shash_setkey(*tfm, evmkey, evmkey_len);\n\t\t\tif (rc) {\n\t\t\t\tcrypto_free_shash(*tfm);\n\t\t\t\t*tfm = NULL;\n\t\t\t\tmutex_unlock(&mutex);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\nout:\n\t\tmutex_unlock(&mutex);\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(*tfm),\n\t\t\tGFP_KERNEL);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc->tfm = *tfm;\n\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\trc = crypto_shash_init(desc);\n\tif (rc) {\n\t\tkfree(desc);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn desc;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/hash.h>",
      "#include <keys/encrypted-type.h>",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned char evmkey[MAX_KEY_SIZE];",
      "static int evmkey_len = MAX_KEY_SIZE;",
      "struct crypto_shash *hmac_tfm;",
      "struct crypto_shash *hash_tfm;",
      "static DEFINE_MUTEX(mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "desc"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "desc"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*desc) + crypto_shash_descsize(*tfm)",
            "GFP_KERNEL"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_descsize",
          "args": [
            "*tfm"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mutex"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mutex"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "*tfm"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_setkey",
          "args": [
            "*tfm",
            "evmkey",
            "evmkey_len"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "rc"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&mutex"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Can not allocate %s (reason: %ld)\\n\"",
            "algo",
            "rc"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "*tfm"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "*tfm"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "algo",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&mutex"
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOKEY"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err_once",
          "args": [
            "\"HMAC key is not set\\n\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nstatic unsigned char evmkey[MAX_KEY_SIZE];\nstatic int evmkey_len = MAX_KEY_SIZE;\nstruct crypto_shash *hmac_tfm;\nstruct crypto_shash *hash_tfm;\nstatic DEFINE_MUTEX(mutex);\n\nstatic struct shash_desc *init_desc(char type)\n{\n\tlong rc;\n\tchar *algo;\n\tstruct crypto_shash **tfm;\n\tstruct shash_desc *desc;\n\n\tif (type == EVM_XATTR_HMAC) {\n\t\tif (!(evm_initialized & EVM_INIT_HMAC)) {\n\t\t\tpr_err_once(\"HMAC key is not set\\n\");\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\t}\n\t\ttfm = &hmac_tfm;\n\t\talgo = evm_hmac;\n\t} else {\n\t\ttfm = &hash_tfm;\n\t\talgo = evm_hash;\n\t}\n\n\tif (*tfm == NULL) {\n\t\tmutex_lock(&mutex);\n\t\tif (*tfm)\n\t\t\tgoto out;\n\t\t*tfm = crypto_alloc_shash(algo, 0, CRYPTO_ALG_ASYNC);\n\t\tif (IS_ERR(*tfm)) {\n\t\t\trc = PTR_ERR(*tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %ld)\\n\", algo, rc);\n\t\t\t*tfm = NULL;\n\t\t\tmutex_unlock(&mutex);\n\t\t\treturn ERR_PTR(rc);\n\t\t}\n\t\tif (type == EVM_XATTR_HMAC) {\n\t\t\trc = crypto_shash_setkey(*tfm, evmkey, evmkey_len);\n\t\t\tif (rc) {\n\t\t\t\tcrypto_free_shash(*tfm);\n\t\t\t\t*tfm = NULL;\n\t\t\t\tmutex_unlock(&mutex);\n\t\t\t\treturn ERR_PTR(rc);\n\t\t\t}\n\t\t}\nout:\n\t\tmutex_unlock(&mutex);\n\t}\n\n\tdesc = kmalloc(sizeof(*desc) + crypto_shash_descsize(*tfm),\n\t\t\tGFP_KERNEL);\n\tif (!desc)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tdesc->tfm = *tfm;\n\tdesc->flags = CRYPTO_TFM_REQ_MAY_SLEEP;\n\n\trc = crypto_shash_init(desc);\n\tif (rc) {\n\t\tkfree(desc);\n\t\treturn ERR_PTR(rc);\n\t}\n\treturn desc;\n}"
  },
  {
    "function_name": "evm_set_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
    "lines": "52-71",
    "snippet": "int evm_set_key(void *key, size_t keylen)\n{\n\tint rc;\n\n\trc = -EBUSY;\n\tif (test_and_set_bit(EVM_SET_KEY_BUSY, &evm_set_key_flags))\n\t\tgoto busy;\n\trc = -EINVAL;\n\tif (keylen > MAX_KEY_SIZE)\n\t\tgoto inval;\n\tmemcpy(evmkey, key, keylen);\n\tevm_initialized |= EVM_INIT_HMAC;\n\tpr_info(\"key initialized\\n\");\n\treturn 0;\ninval:\n\tclear_bit(EVM_SET_KEY_BUSY, &evm_set_key_flags);\nbusy:\n\tpr_err(\"key initialization failed\\n\");\n\treturn rc;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <crypto/hash.h>",
      "#include <keys/encrypted-type.h>",
      "#include <linux/evm.h>",
      "#include <linux/xattr.h>",
      "#include <linux/crypto.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define EVM_SET_KEY_BUSY 0",
      "#define MAX_KEY_SIZE 128"
    ],
    "globals_used": [
      "static unsigned char evmkey[MAX_KEY_SIZE];",
      "static unsigned long evm_set_key_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"key initialization failed\\n\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "EVM_SET_KEY_BUSY",
            "&evm_set_key_flags"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"key initialized\\n\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "evmkey",
            "key",
            "keylen"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "EVM_SET_KEY_BUSY",
            "&evm_set_key_flags"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\n#define EVM_SET_KEY_BUSY 0\n#define MAX_KEY_SIZE 128\n\nstatic unsigned char evmkey[MAX_KEY_SIZE];\nstatic unsigned long evm_set_key_flags;\n\nint evm_set_key(void *key, size_t keylen)\n{\n\tint rc;\n\n\trc = -EBUSY;\n\tif (test_and_set_bit(EVM_SET_KEY_BUSY, &evm_set_key_flags))\n\t\tgoto busy;\n\trc = -EINVAL;\n\tif (keylen > MAX_KEY_SIZE)\n\t\tgoto inval;\n\tmemcpy(evmkey, key, keylen);\n\tevm_initialized |= EVM_INIT_HMAC;\n\tpr_info(\"key initialized\\n\");\n\treturn 0;\ninval:\n\tclear_bit(EVM_SET_KEY_BUSY, &evm_set_key_flags);\nbusy:\n\tpr_err(\"key initialization failed\\n\");\n\treturn rc;\n}"
  }
]