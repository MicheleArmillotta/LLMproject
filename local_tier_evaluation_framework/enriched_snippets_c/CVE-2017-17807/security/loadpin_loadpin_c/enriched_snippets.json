[
  {
    "function_name": "loadpin_add_hooks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/loadpin/loadpin.c",
    "lines": "182-186",
    "snippet": "void __init loadpin_add_hooks(void)\n{\n\tpr_info(\"ready to pin (currently %sabled)\", enabled ? \"en\" : \"dis\");\n\tsecurity_add_hooks(loadpin_hooks, ARRAY_SIZE(loadpin_hooks), \"loadpin\");\n}",
    "includes": [
      "#include <linux/string_helpers.h>",
      "#include <linux/sched.h>\t/* current */",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int enabled = IS_ENABLED(CONFIG_SECURITY_LOADPIN_ENABLED);",
      "static struct security_hook_list loadpin_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(sb_free_security, loadpin_sb_free_security),\n\tLSM_HOOK_INIT(kernel_read_file, loadpin_read_file),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_add_hooks",
          "args": [
            "loadpin_hooks",
            "ARRAY_SIZE(loadpin_hooks)",
            "\"loadpin\""
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "security_add_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "159-170",
          "snippet": "void __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t\tchar *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\tlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *lsm_names;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nchar *lsm_names;\n\nvoid __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t\tchar *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\tlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "loadpin_hooks"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"ready to pin (currently %sabled)\"",
            "enabled ? \"en\" : \"dis\""
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/string_helpers.h>\n#include <linux/sched.h>\t/* current */\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/lsm_hooks.h>\n#include <linux/fs_struct.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int enabled = IS_ENABLED(CONFIG_SECURITY_LOADPIN_ENABLED);\nstatic struct security_hook_list loadpin_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(sb_free_security, loadpin_sb_free_security),\n\tLSM_HOOK_INIT(kernel_read_file, loadpin_read_file),\n};\n\nvoid __init loadpin_add_hooks(void)\n{\n\tpr_info(\"ready to pin (currently %sabled)\", enabled ? \"en\" : \"dis\");\n\tsecurity_add_hooks(loadpin_hooks, ARRAY_SIZE(loadpin_hooks), \"loadpin\");\n}"
  },
  {
    "function_name": "loadpin_read_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/loadpin/loadpin.c",
    "lines": "125-175",
    "snippet": "static int loadpin_read_file(struct file *file, enum kernel_read_file_id id)\n{\n\tstruct super_block *load_root;\n\tconst char *origin = kernel_read_file_id_str(id);\n\n\t/* This handles the older init_module API that has a NULL file. */\n\tif (!file) {\n\t\tif (!enabled) {\n\t\t\treport_load(origin, NULL, \"old-api-pinning-ignored\");\n\t\t\treturn 0;\n\t\t}\n\n\t\treport_load(origin, NULL, \"old-api-denied\");\n\t\treturn -EPERM;\n\t}\n\n\tload_root = file->f_path.mnt->mnt_sb;\n\n\t/* First loaded module/firmware defines the root for all others. */\n\tspin_lock(&pinned_root_spinlock);\n\t/*\n\t * pinned_root is only NULL at startup. Otherwise, it is either\n\t * a valid reference, or an ERR_PTR.\n\t */\n\tif (!pinned_root) {\n\t\tpinned_root = load_root;\n\t\t/*\n\t\t * Unlock now since it's only pinned_root we care about.\n\t\t * In the worst case, we will (correctly) report pinning\n\t\t * failures before we have announced that pinning is\n\t\t * enabled. This would be purely cosmetic.\n\t\t */\n\t\tspin_unlock(&pinned_root_spinlock);\n\t\tcheck_pinning_enforcement(pinned_root);\n\t\treport_load(origin, file, \"pinned\");\n\t} else {\n\t\tspin_unlock(&pinned_root_spinlock);\n\t}\n\n\tif (IS_ERR_OR_NULL(pinned_root) || load_root != pinned_root) {\n\t\tif (unlikely(!enabled)) {\n\t\t\treport_load(origin, file, \"pinning-ignored\");\n\t\t\treturn 0;\n\t\t}\n\n\t\treport_load(origin, file, \"denied\");\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/string_helpers.h>",
      "#include <linux/sched.h>\t/* current */",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int enabled = IS_ENABLED(CONFIG_SECURITY_LOADPIN_ENABLED);",
      "static struct super_block *pinned_root;",
      "static DEFINE_SPINLOCK(pinned_root_spinlock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "report_load",
          "args": [
            "origin",
            "file",
            "\"denied\""
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "report_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/loadpin/loadpin.c",
          "lines": "29-46",
          "snippet": "static void report_load(const char *origin, struct file *file, char *operation)\n{\n\tchar *cmdline, *pathname;\n\n\tpathname = kstrdup_quotable_file(file, GFP_KERNEL);\n\tcmdline = kstrdup_quotable_cmdline(current, GFP_KERNEL);\n\n\tpr_notice(\"%s %s obj=%s%s%s pid=%d cmdline=%s%s%s\\n\",\n\t\t  origin, operation,\n\t\t  (pathname && pathname[0] != '<') ? \"\\\"\" : \"\",\n\t\t  pathname,\n\t\t  (pathname && pathname[0] != '<') ? \"\\\"\" : \"\",\n\t\t  task_pid_nr(current),\n\t\t  cmdline ? \"\\\"\" : \"\", cmdline, cmdline ? \"\\\"\" : \"\");\n\n\tkfree(cmdline);\n\tkfree(pathname);\n}",
          "includes": [
            "#include <linux/string_helpers.h>",
            "#include <linux/sched.h>\t/* current */",
            "#include <linux/path.h>",
            "#include <linux/mount.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string_helpers.h>\n#include <linux/sched.h>\t/* current */\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/lsm_hooks.h>\n#include <linux/fs_struct.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void report_load(const char *origin, struct file *file, char *operation)\n{\n\tchar *cmdline, *pathname;\n\n\tpathname = kstrdup_quotable_file(file, GFP_KERNEL);\n\tcmdline = kstrdup_quotable_cmdline(current, GFP_KERNEL);\n\n\tpr_notice(\"%s %s obj=%s%s%s pid=%d cmdline=%s%s%s\\n\",\n\t\t  origin, operation,\n\t\t  (pathname && pathname[0] != '<') ? \"\\\"\" : \"\",\n\t\t  pathname,\n\t\t  (pathname && pathname[0] != '<') ? \"\\\"\" : \"\",\n\t\t  task_pid_nr(current),\n\t\t  cmdline ? \"\\\"\" : \"\", cmdline, cmdline ? \"\\\"\" : \"\");\n\n\tkfree(cmdline);\n\tkfree(pathname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!enabled"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "pinned_root"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pinned_root_spinlock"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_pinning_enforcement",
          "args": [
            "pinned_root"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "check_pinning_enforcement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/loadpin/loadpin.c",
          "lines": "106-109",
          "snippet": "static void check_pinning_enforcement(struct super_block *mnt_sb)\n{\n\tpr_info(\"load pinning engaged.\\n\");\n}",
          "includes": [
            "#include <linux/string_helpers.h>",
            "#include <linux/sched.h>\t/* current */",
            "#include <linux/path.h>",
            "#include <linux/mount.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/string_helpers.h>\n#include <linux/sched.h>\t/* current */\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/lsm_hooks.h>\n#include <linux/fs_struct.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void check_pinning_enforcement(struct super_block *mnt_sb)\n{\n\tpr_info(\"load pinning engaged.\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&pinned_root_spinlock"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&pinned_root_spinlock"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read_file_id_str",
          "args": [
            "id"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/string_helpers.h>\n#include <linux/sched.h>\t/* current */\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/lsm_hooks.h>\n#include <linux/fs_struct.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic int enabled = IS_ENABLED(CONFIG_SECURITY_LOADPIN_ENABLED);\nstatic struct super_block *pinned_root;\nstatic DEFINE_SPINLOCK(pinned_root_spinlock);\n\nstatic int loadpin_read_file(struct file *file, enum kernel_read_file_id id)\n{\n\tstruct super_block *load_root;\n\tconst char *origin = kernel_read_file_id_str(id);\n\n\t/* This handles the older init_module API that has a NULL file. */\n\tif (!file) {\n\t\tif (!enabled) {\n\t\t\treport_load(origin, NULL, \"old-api-pinning-ignored\");\n\t\t\treturn 0;\n\t\t}\n\n\t\treport_load(origin, NULL, \"old-api-denied\");\n\t\treturn -EPERM;\n\t}\n\n\tload_root = file->f_path.mnt->mnt_sb;\n\n\t/* First loaded module/firmware defines the root for all others. */\n\tspin_lock(&pinned_root_spinlock);\n\t/*\n\t * pinned_root is only NULL at startup. Otherwise, it is either\n\t * a valid reference, or an ERR_PTR.\n\t */\n\tif (!pinned_root) {\n\t\tpinned_root = load_root;\n\t\t/*\n\t\t * Unlock now since it's only pinned_root we care about.\n\t\t * In the worst case, we will (correctly) report pinning\n\t\t * failures before we have announced that pinning is\n\t\t * enabled. This would be purely cosmetic.\n\t\t */\n\t\tspin_unlock(&pinned_root_spinlock);\n\t\tcheck_pinning_enforcement(pinned_root);\n\t\treport_load(origin, file, \"pinned\");\n\t} else {\n\t\tspin_unlock(&pinned_root_spinlock);\n\t}\n\n\tif (IS_ERR_OR_NULL(pinned_root) || load_root != pinned_root) {\n\t\tif (unlikely(!enabled)) {\n\t\t\treport_load(origin, file, \"pinning-ignored\");\n\t\t\treturn 0;\n\t\t}\n\n\t\treport_load(origin, file, \"denied\");\n\t\treturn -EPERM;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "loadpin_sb_free_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/loadpin/loadpin.c",
    "lines": "112-123",
    "snippet": "static void loadpin_sb_free_security(struct super_block *mnt_sb)\n{\n\t/*\n\t * When unmounting the filesystem we were using for load\n\t * pinning, we acknowledge the superblock release, but make sure\n\t * no other modules or firmware can be loaded.\n\t */\n\tif (!IS_ERR_OR_NULL(pinned_root) && mnt_sb == pinned_root) {\n\t\tpinned_root = ERR_PTR(-EIO);\n\t\tpr_info(\"umount pinned fs: refusing further loads\\n\");\n\t}\n}",
    "includes": [
      "#include <linux/string_helpers.h>",
      "#include <linux/sched.h>\t/* current */",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct super_block *pinned_root;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"umount pinned fs: refusing further loads\\n\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EIO"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "pinned_root"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/string_helpers.h>\n#include <linux/sched.h>\t/* current */\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/lsm_hooks.h>\n#include <linux/fs_struct.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic struct super_block *pinned_root;\n\nstatic void loadpin_sb_free_security(struct super_block *mnt_sb)\n{\n\t/*\n\t * When unmounting the filesystem we were using for load\n\t * pinning, we acknowledge the superblock release, but make sure\n\t * no other modules or firmware can be loaded.\n\t */\n\tif (!IS_ERR_OR_NULL(pinned_root) && mnt_sb == pinned_root) {\n\t\tpinned_root = ERR_PTR(-EIO);\n\t\tpr_info(\"umount pinned fs: refusing further loads\\n\");\n\t}\n}"
  },
  {
    "function_name": "check_pinning_enforcement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/loadpin/loadpin.c",
    "lines": "106-109",
    "snippet": "static void check_pinning_enforcement(struct super_block *mnt_sb)\n{\n\tpr_info(\"load pinning engaged.\\n\");\n}",
    "includes": [
      "#include <linux/string_helpers.h>",
      "#include <linux/sched.h>\t/* current */",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"load pinning engaged.\\n\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/string_helpers.h>\n#include <linux/sched.h>\t/* current */\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/lsm_hooks.h>\n#include <linux/fs_struct.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void check_pinning_enforcement(struct super_block *mnt_sb)\n{\n\tpr_info(\"load pinning engaged.\\n\");\n}"
  },
  {
    "function_name": "check_pinning_enforcement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/loadpin/loadpin.c",
    "lines": "79-104",
    "snippet": "static void check_pinning_enforcement(struct super_block *mnt_sb)\n{\n\tbool ro = false;\n\n\t/*\n\t * If load pinning is not enforced via a read-only block\n\t * device, allow sysctl to change modes for testing.\n\t */\n\tif (mnt_sb->s_bdev) {\n\t\tro = bdev_read_only(mnt_sb->s_bdev);\n\t\tpr_info(\"dev(%u,%u): %s\\n\",\n\t\t\tMAJOR(mnt_sb->s_bdev->bd_dev),\n\t\t\tMINOR(mnt_sb->s_bdev->bd_dev),\n\t\t\tro ? \"read-only\" : \"writable\");\n\t} else\n\t\tpr_info(\"mnt_sb lacks block device, treating as: writable\\n\");\n\n\tif (!ro) {\n\t\tif (!register_sysctl_paths(loadpin_sysctl_path,\n\t\t\t\t\t   loadpin_sysctl_table))\n\t\t\tpr_notice(\"sysctl registration failed!\\n\");\n\t\telse\n\t\t\tpr_info(\"load pinning can be disabled.\\n\");\n\t} else\n\t\tpr_info(\"load pinning engaged.\\n\");\n}",
    "includes": [
      "#include <linux/string_helpers.h>",
      "#include <linux/sched.h>\t/* current */",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"load pinning engaged.\\n\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"load pinning can be disabled.\\n\""
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"sysctl registration failed!\\n\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_sysctl_paths",
          "args": [
            "loadpin_sysctl_path",
            "loadpin_sysctl_table"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"mnt_sb lacks block device, treating as: writable\\n\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"dev(%u,%u): %s\\n\"",
            "MAJOR(mnt_sb->s_bdev->bd_dev)",
            "MINOR(mnt_sb->s_bdev->bd_dev)",
            "ro ? \"read-only\" : \"writable\""
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "mnt_sb->s_bdev->bd_dev"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "mnt_sb->s_bdev->bd_dev"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bdev_read_only",
          "args": [
            "mnt_sb->s_bdev"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/string_helpers.h>\n#include <linux/sched.h>\t/* current */\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/lsm_hooks.h>\n#include <linux/fs_struct.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void check_pinning_enforcement(struct super_block *mnt_sb)\n{\n\tbool ro = false;\n\n\t/*\n\t * If load pinning is not enforced via a read-only block\n\t * device, allow sysctl to change modes for testing.\n\t */\n\tif (mnt_sb->s_bdev) {\n\t\tro = bdev_read_only(mnt_sb->s_bdev);\n\t\tpr_info(\"dev(%u,%u): %s\\n\",\n\t\t\tMAJOR(mnt_sb->s_bdev->bd_dev),\n\t\t\tMINOR(mnt_sb->s_bdev->bd_dev),\n\t\t\tro ? \"read-only\" : \"writable\");\n\t} else\n\t\tpr_info(\"mnt_sb lacks block device, treating as: writable\\n\");\n\n\tif (!ro) {\n\t\tif (!register_sysctl_paths(loadpin_sysctl_path,\n\t\t\t\t\t   loadpin_sysctl_table))\n\t\t\tpr_notice(\"sysctl registration failed!\\n\");\n\t\telse\n\t\t\tpr_info(\"load pinning can be disabled.\\n\");\n\t} else\n\t\tpr_info(\"load pinning engaged.\\n\");\n}"
  },
  {
    "function_name": "report_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/loadpin/loadpin.c",
    "lines": "29-46",
    "snippet": "static void report_load(const char *origin, struct file *file, char *operation)\n{\n\tchar *cmdline, *pathname;\n\n\tpathname = kstrdup_quotable_file(file, GFP_KERNEL);\n\tcmdline = kstrdup_quotable_cmdline(current, GFP_KERNEL);\n\n\tpr_notice(\"%s %s obj=%s%s%s pid=%d cmdline=%s%s%s\\n\",\n\t\t  origin, operation,\n\t\t  (pathname && pathname[0] != '<') ? \"\\\"\" : \"\",\n\t\t  pathname,\n\t\t  (pathname && pathname[0] != '<') ? \"\\\"\" : \"\",\n\t\t  task_pid_nr(current),\n\t\t  cmdline ? \"\\\"\" : \"\", cmdline, cmdline ? \"\\\"\" : \"\");\n\n\tkfree(cmdline);\n\tkfree(pathname);\n}",
    "includes": [
      "#include <linux/string_helpers.h>",
      "#include <linux/sched.h>\t/* current */",
      "#include <linux/path.h>",
      "#include <linux/mount.h>",
      "#include <linux/lsm_hooks.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/fs.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pathname"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cmdline"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"%s %s obj=%s%s%s pid=%d cmdline=%s%s%s\\n\"",
            "origin",
            "operation",
            "(pathname && pathname[0] != '<') ? \"\\\"\" : \"\"",
            "pathname",
            "(pathname && pathname[0] != '<') ? \"\\\"\" : \"\"",
            "task_pid_nr(current)",
            "cmdline ? \"\\\"\" : \"\"",
            "cmdline",
            "cmdline ? \"\\\"\" : \"\""
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup_quotable_cmdline",
          "args": [
            "current",
            "GFP_KERNEL"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup_quotable_file",
          "args": [
            "file",
            "GFP_KERNEL"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/string_helpers.h>\n#include <linux/sched.h>\t/* current */\n#include <linux/path.h>\n#include <linux/mount.h>\n#include <linux/lsm_hooks.h>\n#include <linux/fs_struct.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstatic void report_load(const char *origin, struct file *file, char *operation)\n{\n\tchar *cmdline, *pathname;\n\n\tpathname = kstrdup_quotable_file(file, GFP_KERNEL);\n\tcmdline = kstrdup_quotable_cmdline(current, GFP_KERNEL);\n\n\tpr_notice(\"%s %s obj=%s%s%s pid=%d cmdline=%s%s%s\\n\",\n\t\t  origin, operation,\n\t\t  (pathname && pathname[0] != '<') ? \"\\\"\" : \"\",\n\t\t  pathname,\n\t\t  (pathname && pathname[0] != '<') ? \"\\\"\" : \"\",\n\t\t  task_pid_nr(current),\n\t\t  cmdline ? \"\\\"\" : \"\", cmdline, cmdline ? \"\\\"\" : \"\");\n\n\tkfree(cmdline);\n\tkfree(pathname);\n}"
  }
]