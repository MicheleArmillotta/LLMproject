[
  {
    "function_name": "__aa_transition_rlimits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/resource.c",
    "lines": "145-191",
    "snippet": "void __aa_transition_rlimits(struct aa_label *old_l, struct aa_label *new_l)\n{\n\tunsigned int mask = 0;\n\tstruct rlimit *rlim, *initrlim;\n\tstruct aa_profile *old, *new;\n\tstruct label_it i;\n\n\told = labels_profile(old_l);\n\tnew = labels_profile(new_l);\n\n\t/* for any rlimits the profile controlled, reset the soft limit\n\t * to the lesser of the tasks hard limit and the init tasks soft limit\n\t */\n\tlabel_for_each_confined(i, old_l, old) {\n\t\tif (old->rlimits.mask) {\n\t\t\tint j;\n\n\t\t\tfor (j = 0, mask = 1; j < RLIM_NLIMITS; j++,\n\t\t\t\t     mask <<= 1) {\n\t\t\t\tif (old->rlimits.mask & mask) {\n\t\t\t\t\trlim = current->signal->rlim + j;\n\t\t\t\t\tinitrlim = init_task.signal->rlim + j;\n\t\t\t\t\trlim->rlim_cur = min(rlim->rlim_max,\n\t\t\t\t\t\t\t    initrlim->rlim_cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set any new hard limits as dictated by the new profile */\n\tlabel_for_each_confined(i, new_l, new) {\n\t\tint j;\n\n\t\tif (!new->rlimits.mask)\n\t\t\tcontinue;\n\t\tfor (j = 0, mask = 1; j < RLIM_NLIMITS; j++, mask <<= 1) {\n\t\t\tif (!(new->rlimits.mask & mask))\n\t\t\t\tcontinue;\n\n\t\t\trlim = current->signal->rlim + j;\n\t\t\trlim->rlim_max = min(rlim->rlim_max,\n\t\t\t\t\t     new->rlimits.limits[j].rlim_max);\n\t\t\t/* soft limit should not exceed hard limit */\n\t\t\trlim->rlim_cur = min(rlim->rlim_cur, rlim->rlim_max);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"rlim_names.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "rlim->rlim_cur",
            "rlim->rlim_max"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "set_majmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "259-265",
          "snippet": "static void set_majmin(char *str, unsigned m)\n{\n\tif (m == ~0)\n\t\tstrcpy(str, \"*\");\n\telse\n\t\tsprintf(str, \"%u\", m);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic void set_majmin(char *str, unsigned m)\n{\n\tif (m == ~0)\n\t\tstrcpy(str, \"*\");\n\telse\n\t\tsprintf(str, \"%u\", m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "label_for_each_confined",
          "args": [
            "i",
            "new_l",
            "new"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "label_for_each_confined",
          "args": [
            "i",
            "old_l",
            "old"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_profile",
          "args": [
            "new_l"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_profile",
          "args": [
            "old_l"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rlim_names.h\"\n#include \"include/policy.h\"\n#include \"include/resource.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include <linux/security.h>\n#include <linux/audit.h>\n\nvoid __aa_transition_rlimits(struct aa_label *old_l, struct aa_label *new_l)\n{\n\tunsigned int mask = 0;\n\tstruct rlimit *rlim, *initrlim;\n\tstruct aa_profile *old, *new;\n\tstruct label_it i;\n\n\told = labels_profile(old_l);\n\tnew = labels_profile(new_l);\n\n\t/* for any rlimits the profile controlled, reset the soft limit\n\t * to the lesser of the tasks hard limit and the init tasks soft limit\n\t */\n\tlabel_for_each_confined(i, old_l, old) {\n\t\tif (old->rlimits.mask) {\n\t\t\tint j;\n\n\t\t\tfor (j = 0, mask = 1; j < RLIM_NLIMITS; j++,\n\t\t\t\t     mask <<= 1) {\n\t\t\t\tif (old->rlimits.mask & mask) {\n\t\t\t\t\trlim = current->signal->rlim + j;\n\t\t\t\t\tinitrlim = init_task.signal->rlim + j;\n\t\t\t\t\trlim->rlim_cur = min(rlim->rlim_max,\n\t\t\t\t\t\t\t    initrlim->rlim_cur);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/* set any new hard limits as dictated by the new profile */\n\tlabel_for_each_confined(i, new_l, new) {\n\t\tint j;\n\n\t\tif (!new->rlimits.mask)\n\t\t\tcontinue;\n\t\tfor (j = 0, mask = 1; j < RLIM_NLIMITS; j++, mask <<= 1) {\n\t\t\tif (!(new->rlimits.mask & mask))\n\t\t\t\tcontinue;\n\n\t\t\trlim = current->signal->rlim + j;\n\t\t\trlim->rlim_max = min(rlim->rlim_max,\n\t\t\t\t\t     new->rlimits.limits[j].rlim_max);\n\t\t\t/* soft limit should not exceed hard limit */\n\t\t\trlim->rlim_cur = min(rlim->rlim_cur, rlim->rlim_max);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "aa_task_setrlimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/resource.c",
    "lines": "108-138",
    "snippet": "int aa_task_setrlimit(struct aa_label *label, struct task_struct *task,\n\t\t      unsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *peer;\n\tint error = 0;\n\n\trcu_read_lock();\n\tpeer = aa_get_newest_cred_label(__task_cred(task));\n\trcu_read_unlock();\n\n\t/* TODO: extend resource control to handle other (non current)\n\t * profiles.  AppArmor rules currently have the implicit assumption\n\t * that the task is setting the resource of a task confined with\n\t * the same profile or that the task setting the resource of another\n\t * task has CAP_SYS_RESOURCE.\n\t */\n\n\tif (label != peer &&\n\t    !aa_capable(label, CAP_SYS_RESOURCE, SECURITY_CAP_NOAUDIT))\n\t\terror = fn_for_each(label, profile,\n\t\t\t\taudit_resource(profile, resource,\n\t\t\t\t\t       new_rlim->rlim_max, peer,\n\t\t\t\t\t       \"cap_sys_resource\", -EACCES));\n\telse\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\t\tprofile_setrlimit(profile, resource, new_rlim));\n\taa_put_label(peer);\n\n\treturn error;\n}",
    "includes": [
      "#include \"rlim_names.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "peer"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn_for_each_confined",
          "args": [
            "label",
            "profile",
            "profile_setrlimit(profile, resource, new_rlim)"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_setrlimit",
          "args": [
            "profile",
            "resource",
            "new_rlim"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "profile_setrlimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/resource.c",
          "lines": "85-95",
          "snippet": "static int profile_setrlimit(struct aa_profile *profile, unsigned int resource,\n\t\t\t     struct rlimit *new_rlim)\n{\n\tint e = 0;\n\n\tif (profile->rlimits.mask & (1 << resource) && new_rlim->rlim_max >\n\t    profile->rlimits.limits[resource].rlim_max)\n\t\te = -EACCES;\n\treturn audit_resource(profile, resource, new_rlim->rlim_max, NULL, NULL,\n\t\t\t      e);\n}",
          "includes": [
            "#include \"rlim_names.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rlim_names.h\"\n#include \"include/policy.h\"\n#include \"include/resource.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include <linux/security.h>\n#include <linux/audit.h>\n\nstatic int profile_setrlimit(struct aa_profile *profile, unsigned int resource,\n\t\t\t     struct rlimit *new_rlim)\n{\n\tint e = 0;\n\n\tif (profile->rlimits.mask & (1 << resource) && new_rlim->rlim_max >\n\t    profile->rlimits.limits[resource].rlim_max)\n\t\te = -EACCES;\n\treturn audit_resource(profile, resource, new_rlim->rlim_max, NULL, NULL,\n\t\t\t      e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn_for_each",
          "args": [
            "label",
            "profile",
            "audit_resource(profile, resource,\n\t\t\t\t\t       new_rlim->rlim_max, peer,\n\t\t\t\t\t       \"cap_sys_resource\", -EACCES)"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_resource",
          "args": [
            "profile",
            "resource",
            "new_rlim->rlim_max",
            "peer",
            "\"cap_sys_resource\"",
            "-EACCES"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "audit_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/resource.c",
          "lines": "56-69",
          "snippet": "static int audit_resource(struct aa_profile *profile, unsigned int resource,\n\t\t\t  unsigned long value, struct aa_label *peer,\n\t\t\t  const char *info, int error)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SETRLIMIT);\n\n\taad(&sa)->rlim.rlim = resource;\n\taad(&sa)->rlim.max = value;\n\taad(&sa)->peer = peer;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_AUTO, profile, &sa, audit_cb);\n}",
          "includes": [
            "#include \"rlim_names.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rlim_names.h\"\n#include \"include/policy.h\"\n#include \"include/resource.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include <linux/security.h>\n#include <linux/audit.h>\n\nstatic int audit_resource(struct aa_profile *profile, unsigned int resource,\n\t\t\t  unsigned long value, struct aa_label *peer,\n\t\t\t  const char *info, int error)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SETRLIMIT);\n\n\taad(&sa)->rlim.rlim = resource;\n\taad(&sa)->rlim.max = value;\n\taad(&sa)->peer = peer;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_AUTO, profile, &sa, audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_capable",
          "args": [
            "label",
            "CAP_SYS_RESOURCE",
            "SECURITY_CAP_NOAUDIT"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "aa_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/capability.c",
          "lines": "151-162",
          "snippet": "int aa_capable(struct aa_label *label, int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_CAP, OP_CAPABLE);\n\n\tsa.u.cap = cap;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_capable(profile, cap, audit, &sa));\n\n\treturn error;\n}",
          "includes": [
            "#include \"capability_names.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/security.h>",
            "#include <linux/gfp.h>",
            "#include <linux/errno.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"capability_names.h\"\n#include \"include/audit.h\"\n#include \"include/policy.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/security.h>\n#include <linux/gfp.h>\n#include <linux/errno.h>\n#include <linux/capability.h>\n\nint aa_capable(struct aa_label *label, int cap, int audit)\n{\n\tstruct aa_profile *profile;\n\tint error = 0;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_CAP, OP_CAPABLE);\n\n\tsa.u.cap = cap;\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_capable(profile, cap, audit, &sa));\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_get_newest_cred_label",
          "args": [
            "__task_cred(task)"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_cred_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "80-83",
          "snippet": "static inline struct aa_label *aa_get_newest_cred_label(const struct cred *cred)\n{\n\treturn aa_get_newest_label(aa_cred_raw_label(cred));\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *aa_get_newest_cred_label(const struct cred *cred)\n{\n\treturn aa_get_newest_label(aa_cred_raw_label(cred));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "task"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rlim_names.h\"\n#include \"include/policy.h\"\n#include \"include/resource.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include <linux/security.h>\n#include <linux/audit.h>\n\nint aa_task_setrlimit(struct aa_label *label, struct task_struct *task,\n\t\t      unsigned int resource, struct rlimit *new_rlim)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *peer;\n\tint error = 0;\n\n\trcu_read_lock();\n\tpeer = aa_get_newest_cred_label(__task_cred(task));\n\trcu_read_unlock();\n\n\t/* TODO: extend resource control to handle other (non current)\n\t * profiles.  AppArmor rules currently have the implicit assumption\n\t * that the task is setting the resource of a task confined with\n\t * the same profile or that the task setting the resource of another\n\t * task has CAP_SYS_RESOURCE.\n\t */\n\n\tif (label != peer &&\n\t    !aa_capable(label, CAP_SYS_RESOURCE, SECURITY_CAP_NOAUDIT))\n\t\terror = fn_for_each(label, profile,\n\t\t\t\taudit_resource(profile, resource,\n\t\t\t\t\t       new_rlim->rlim_max, peer,\n\t\t\t\t\t       \"cap_sys_resource\", -EACCES));\n\telse\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\t\tprofile_setrlimit(profile, resource, new_rlim));\n\taa_put_label(peer);\n\n\treturn error;\n}"
  },
  {
    "function_name": "profile_setrlimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/resource.c",
    "lines": "85-95",
    "snippet": "static int profile_setrlimit(struct aa_profile *profile, unsigned int resource,\n\t\t\t     struct rlimit *new_rlim)\n{\n\tint e = 0;\n\n\tif (profile->rlimits.mask & (1 << resource) && new_rlim->rlim_max >\n\t    profile->rlimits.limits[resource].rlim_max)\n\t\te = -EACCES;\n\treturn audit_resource(profile, resource, new_rlim->rlim_max, NULL, NULL,\n\t\t\t      e);\n}",
    "includes": [
      "#include \"rlim_names.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_resource",
          "args": [
            "profile",
            "resource",
            "new_rlim->rlim_max",
            "NULL",
            "NULL",
            "e"
          ],
          "line": 93
        },
        "resolved": true,
        "details": {
          "function_name": "audit_resource",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/resource.c",
          "lines": "56-69",
          "snippet": "static int audit_resource(struct aa_profile *profile, unsigned int resource,\n\t\t\t  unsigned long value, struct aa_label *peer,\n\t\t\t  const char *info, int error)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SETRLIMIT);\n\n\taad(&sa)->rlim.rlim = resource;\n\taad(&sa)->rlim.max = value;\n\taad(&sa)->peer = peer;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_AUTO, profile, &sa, audit_cb);\n}",
          "includes": [
            "#include \"rlim_names.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/resource.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rlim_names.h\"\n#include \"include/policy.h\"\n#include \"include/resource.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include <linux/security.h>\n#include <linux/audit.h>\n\nstatic int audit_resource(struct aa_profile *profile, unsigned int resource,\n\t\t\t  unsigned long value, struct aa_label *peer,\n\t\t\t  const char *info, int error)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SETRLIMIT);\n\n\taad(&sa)->rlim.rlim = resource;\n\taad(&sa)->rlim.max = value;\n\taad(&sa)->peer = peer;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_AUTO, profile, &sa, audit_cb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"rlim_names.h\"\n#include \"include/policy.h\"\n#include \"include/resource.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include <linux/security.h>\n#include <linux/audit.h>\n\nstatic int profile_setrlimit(struct aa_profile *profile, unsigned int resource,\n\t\t\t     struct rlimit *new_rlim)\n{\n\tint e = 0;\n\n\tif (profile->rlimits.mask & (1 << resource) && new_rlim->rlim_max >\n\t    profile->rlimits.limits[resource].rlim_max)\n\t\te = -EACCES;\n\treturn audit_resource(profile, resource, new_rlim->rlim_max, NULL, NULL,\n\t\t\t      e);\n}"
  },
  {
    "function_name": "aa_map_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/resource.c",
    "lines": "80-83",
    "snippet": "int aa_map_resource(int resource)\n{\n\treturn rlim_map[resource];\n}",
    "includes": [
      "#include \"rlim_names.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"rlim_names.h\"\n#include \"include/policy.h\"\n#include \"include/resource.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include <linux/security.h>\n#include <linux/audit.h>\n\nint aa_map_resource(int resource)\n{\n\treturn rlim_map[resource];\n}"
  },
  {
    "function_name": "audit_resource",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/resource.c",
    "lines": "56-69",
    "snippet": "static int audit_resource(struct aa_profile *profile, unsigned int resource,\n\t\t\t  unsigned long value, struct aa_label *peer,\n\t\t\t  const char *info, int error)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SETRLIMIT);\n\n\taad(&sa)->rlim.rlim = resource;\n\taad(&sa)->rlim.max = value;\n\taad(&sa)->peer = peer;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_AUTO, profile, &sa, audit_cb);\n}",
    "includes": [
      "#include \"rlim_names.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_audit",
          "args": [
            "AUDIT_APPARMOR_AUTO",
            "profile",
            "&sa",
            "audit_cb"
          ],
          "line": 68
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/audit.c",
          "lines": "129-165",
          "snippet": "int aa_audit(int type, struct aa_profile *profile, struct common_audit_data *sa,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!aad(sa)->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET))\n\t\treturn aad(sa)->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\taad(sa)->label = &profile->label;\n\n\taa_audit_msg(type, sa, cb);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tsa->type == LSM_AUDIT_DATA_TASK && sa->u.tsk ?\n\t\t\t\t    sa->u.tsk : current);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(aad(sa)->error);\n\n\treturn aad(sa)->error;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/socket.h>\n#include <linux/audit.h>\n\nint aa_audit(int type, struct aa_profile *profile, struct common_audit_data *sa,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!aad(sa)->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET))\n\t\treturn aad(sa)->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\taad(sa)->label = &profile->label;\n\n\taa_audit_msg(type, sa, cb);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tsa->type == LSM_AUDIT_DATA_TASK && sa->u.tsk ?\n\t\t\t\t    sa->u.tsk : current);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(aad(sa)->error);\n\n\treturn aad(sa)->error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_AUDIT_DATA",
          "args": [
            "sa",
            "LSM_AUDIT_DATA_NONE",
            "OP_SETRLIMIT"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rlim_names.h\"\n#include \"include/policy.h\"\n#include \"include/resource.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include <linux/security.h>\n#include <linux/audit.h>\n\nstatic int audit_resource(struct aa_profile *profile, unsigned int resource,\n\t\t\t  unsigned long value, struct aa_label *peer,\n\t\t\t  const char *info, int error)\n{\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, OP_SETRLIMIT);\n\n\taad(&sa)->rlim.rlim = resource;\n\taad(&sa)->rlim.max = value;\n\taad(&sa)->peer = peer;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(AUDIT_APPARMOR_AUTO, profile, &sa, audit_cb);\n}"
  },
  {
    "function_name": "audit_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/resource.c",
    "lines": "34-45",
    "snippet": "static void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\taudit_log_format(ab, \" rlimit=%s value=%lu\",\n\t\t\t rlim_names[aad(sa)->rlim.rlim], aad(sa)->rlim.max);\n\tif (aad(sa)->peer) {\n\t\taudit_log_format(ab, \" peer=\");\n\t\taa_label_xaudit(ab, labels_ns(aad(sa)->label), aad(sa)->peer,\n\t\t\t\tFLAGS_NONE, GFP_ATOMIC);\n\t}\n}",
    "includes": [
      "#include \"rlim_names.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/resource.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include <linux/security.h>",
      "#include <linux/audit.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_label_xaudit",
          "args": [
            "ab",
            "labels_ns(aad(sa)->label)",
            "aad(sa)->peer",
            "FLAGS_NONE",
            "GFP_ATOMIC"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1710-1738",
          "snippet": "void aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "aad(sa)->label"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" peer=\""
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" rlimit=%s value=%lu\"",
            "rlim_names[aad(sa)->rlim.rlim]",
            "aad(sa)->rlim.max"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"rlim_names.h\"\n#include \"include/policy.h\"\n#include \"include/resource.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include <linux/security.h>\n#include <linux/audit.h>\n\nstatic void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\taudit_log_format(ab, \" rlimit=%s value=%lu\",\n\t\t\t rlim_names[aad(sa)->rlim.rlim], aad(sa)->rlim.max);\n\tif (aad(sa)->peer) {\n\t\taudit_log_format(ab, \" peer=\");\n\t\taa_label_xaudit(ab, labels_ns(aad(sa)->label), aad(sa)->peer,\n\t\t\t\tFLAGS_NONE, GFP_ATOMIC);\n\t}\n}"
  }
]