[
  {
    "function_name": "mls_import_netlbl_cat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "648-668",
    "snippet": "int mls_import_netlbl_cat(struct context *context,\n\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\trc = ebitmap_netlbl_import(&context->range.level[0].cat,\n\t\t\t\t   secattr->attr.mls.cat);\n\tif (rc)\n\t\tgoto import_netlbl_cat_failure;\n\tmemcpy(&context->range.level[1].cat, &context->range.level[0].cat,\n\t       sizeof(context->range.level[0].cat));\n\n\treturn 0;\n\nimport_netlbl_cat_failure:\n\tebitmap_destroy(&context->range.level[0].cat);\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "&context->range.level[0].cat"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&context->range.level[1].cat",
            "&context->range.level[0].cat",
            "sizeof(context->range.level[0].cat)"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_netlbl_import",
          "args": [
            "&context->range.level[0].cat",
            "secattr->attr.mls.cat"
          ],
          "line": 656
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_netlbl_import",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "143-193",
          "snippet": "int ebitmap_netlbl_import(struct ebitmap *ebmap,\n\t\t\t  struct netlbl_lsm_catmap *catmap)\n{\n\tint rc;\n\tstruct ebitmap_node *e_iter = NULL;\n\tstruct ebitmap_node *e_prev = NULL;\n\tu32 offset = 0, idx;\n\tunsigned long bitmap;\n\n\tfor (;;) {\n\t\trc = netlbl_catmap_getlong(catmap, &offset, &bitmap);\n\t\tif (rc < 0)\n\t\t\tgoto netlbl_import_failure;\n\t\tif (offset == (u32)-1)\n\t\t\treturn 0;\n\n\t\t/* don't waste ebitmap space if the netlabel bitmap is empty */\n\t\tif (bitmap == 0) {\n\t\t\toffset += EBITMAP_UNIT_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (e_iter == NULL ||\n\t\t    offset >= e_iter->startbit + EBITMAP_SIZE) {\n\t\t\te_prev = e_iter;\n\t\t\te_iter = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\t\tif (e_iter == NULL)\n\t\t\t\tgoto netlbl_import_failure;\n\t\t\te_iter->startbit = offset - (offset % EBITMAP_SIZE);\n\t\t\tif (e_prev == NULL)\n\t\t\t\tebmap->node = e_iter;\n\t\t\telse\n\t\t\t\te_prev->next = e_iter;\n\t\t\tebmap->highbit = e_iter->startbit + EBITMAP_SIZE;\n\t\t}\n\n\t\t/* offset will always be aligned to an unsigned long */\n\t\tidx = EBITMAP_NODE_INDEX(e_iter, offset);\n\t\te_iter->maps[idx] = bitmap;\n\n\t\t/* next */\n\t\toffset += EBITMAP_UNIT_SIZE;\n\t}\n\n\t/* NOTE: we should never reach this return */\n\treturn 0;\n\nnetlbl_import_failure:\n\tebitmap_destroy(ebmap);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_netlbl_import(struct ebitmap *ebmap,\n\t\t\t  struct netlbl_lsm_catmap *catmap)\n{\n\tint rc;\n\tstruct ebitmap_node *e_iter = NULL;\n\tstruct ebitmap_node *e_prev = NULL;\n\tu32 offset = 0, idx;\n\tunsigned long bitmap;\n\n\tfor (;;) {\n\t\trc = netlbl_catmap_getlong(catmap, &offset, &bitmap);\n\t\tif (rc < 0)\n\t\t\tgoto netlbl_import_failure;\n\t\tif (offset == (u32)-1)\n\t\t\treturn 0;\n\n\t\t/* don't waste ebitmap space if the netlabel bitmap is empty */\n\t\tif (bitmap == 0) {\n\t\t\toffset += EBITMAP_UNIT_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (e_iter == NULL ||\n\t\t    offset >= e_iter->startbit + EBITMAP_SIZE) {\n\t\t\te_prev = e_iter;\n\t\t\te_iter = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\t\tif (e_iter == NULL)\n\t\t\t\tgoto netlbl_import_failure;\n\t\t\te_iter->startbit = offset - (offset % EBITMAP_SIZE);\n\t\t\tif (e_prev == NULL)\n\t\t\t\tebmap->node = e_iter;\n\t\t\telse\n\t\t\t\te_prev->next = e_iter;\n\t\t\tebmap->highbit = e_iter->startbit + EBITMAP_SIZE;\n\t\t}\n\n\t\t/* offset will always be aligned to an unsigned long */\n\t\tidx = EBITMAP_NODE_INDEX(e_iter, offset);\n\t\te_iter->maps[idx] = bitmap;\n\n\t\t/* next */\n\t\toffset += EBITMAP_UNIT_SIZE;\n\t}\n\n\t/* NOTE: we should never reach this return */\n\treturn 0;\n\nnetlbl_import_failure:\n\tebitmap_destroy(ebmap);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_import_netlbl_cat(struct context *context,\n\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\trc = ebitmap_netlbl_import(&context->range.level[0].cat,\n\t\t\t\t   secattr->attr.mls.cat);\n\tif (rc)\n\t\tgoto import_netlbl_cat_failure;\n\tmemcpy(&context->range.level[1].cat, &context->range.level[0].cat,\n\t       sizeof(context->range.level[0].cat));\n\n\treturn 0;\n\nimport_netlbl_cat_failure:\n\tebitmap_destroy(&context->range.level[0].cat);\n\treturn rc;\n}"
  },
  {
    "function_name": "mls_export_netlbl_cat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "620-634",
    "snippet": "int mls_export_netlbl_cat(struct context *context,\n\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\trc = ebitmap_netlbl_export(&context->range.level[0].cat,\n\t\t\t\t   &secattr->attr.mls.cat);\n\tif (rc == 0 && secattr->attr.mls.cat != NULL)\n\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\n\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_netlbl_export",
          "args": [
            "&context->range.level[0].cat",
            "&secattr->attr.mls.cat"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_netlbl_export",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "91-131",
          "snippet": "int ebitmap_netlbl_export(struct ebitmap *ebmap,\n\t\t\t  struct netlbl_lsm_catmap **catmap)\n{\n\tstruct ebitmap_node *e_iter = ebmap->node;\n\tunsigned long e_map;\n\tu32 offset;\n\tunsigned int iter;\n\tint rc;\n\n\tif (e_iter == NULL) {\n\t\t*catmap = NULL;\n\t\treturn 0;\n\t}\n\n\tif (*catmap != NULL)\n\t\tnetlbl_catmap_free(*catmap);\n\t*catmap = NULL;\n\n\twhile (e_iter) {\n\t\toffset = e_iter->startbit;\n\t\tfor (iter = 0; iter < EBITMAP_UNIT_NUMS; iter++) {\n\t\t\te_map = e_iter->maps[iter];\n\t\t\tif (e_map != 0) {\n\t\t\t\trc = netlbl_catmap_setlong(catmap,\n\t\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t\t   e_map,\n\t\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto netlbl_export_failure;\n\t\t\t}\n\t\t\toffset += EBITMAP_UNIT_SIZE;\n\t\t}\n\t\te_iter = e_iter->next;\n\t}\n\n\treturn 0;\n\nnetlbl_export_failure:\n\tnetlbl_catmap_free(*catmap);\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_netlbl_export(struct ebitmap *ebmap,\n\t\t\t  struct netlbl_lsm_catmap **catmap)\n{\n\tstruct ebitmap_node *e_iter = ebmap->node;\n\tunsigned long e_map;\n\tu32 offset;\n\tunsigned int iter;\n\tint rc;\n\n\tif (e_iter == NULL) {\n\t\t*catmap = NULL;\n\t\treturn 0;\n\t}\n\n\tif (*catmap != NULL)\n\t\tnetlbl_catmap_free(*catmap);\n\t*catmap = NULL;\n\n\twhile (e_iter) {\n\t\toffset = e_iter->startbit;\n\t\tfor (iter = 0; iter < EBITMAP_UNIT_NUMS; iter++) {\n\t\t\te_map = e_iter->maps[iter];\n\t\t\tif (e_map != 0) {\n\t\t\t\trc = netlbl_catmap_setlong(catmap,\n\t\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t\t   e_map,\n\t\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto netlbl_export_failure;\n\t\t\t}\n\t\t\toffset += EBITMAP_UNIT_SIZE;\n\t\t}\n\t\te_iter = e_iter->next;\n\t}\n\n\treturn 0;\n\nnetlbl_export_failure:\n\tnetlbl_catmap_free(*catmap);\n\treturn -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_export_netlbl_cat(struct context *context,\n\t\t\t  struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\trc = ebitmap_netlbl_export(&context->range.level[0].cat,\n\t\t\t\t   &secattr->attr.mls.cat);\n\tif (rc == 0 && secattr->attr.mls.cat != NULL)\n\t\tsecattr->flags |= NETLBL_SECATTR_MLS_CAT;\n\n\treturn rc;\n}"
  },
  {
    "function_name": "mls_import_netlbl_lvl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "600-608",
    "snippet": "void mls_import_netlbl_lvl(struct context *context,\n\t\t\t   struct netlbl_lsm_secattr *secattr)\n{\n\tif (!policydb.mls_enabled)\n\t\treturn;\n\n\tcontext->range.level[0].sens = secattr->attr.mls.lvl + 1;\n\tcontext->range.level[1].sens = context->range.level[0].sens;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid mls_import_netlbl_lvl(struct context *context,\n\t\t\t   struct netlbl_lsm_secattr *secattr)\n{\n\tif (!policydb.mls_enabled)\n\t\treturn;\n\n\tcontext->range.level[0].sens = secattr->attr.mls.lvl + 1;\n\tcontext->range.level[1].sens = context->range.level[0].sens;\n}"
  },
  {
    "function_name": "mls_export_netlbl_lvl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "580-588",
    "snippet": "void mls_export_netlbl_lvl(struct context *context,\n\t\t\t   struct netlbl_lsm_secattr *secattr)\n{\n\tif (!policydb.mls_enabled)\n\t\treturn;\n\n\tsecattr->attr.mls.lvl = context->range.level[0].sens - 1;\n\tsecattr->flags |= NETLBL_SECATTR_MLS_LVL;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid mls_export_netlbl_lvl(struct context *context,\n\t\t\t   struct netlbl_lsm_secattr *secattr)\n{\n\tif (!policydb.mls_enabled)\n\t\treturn;\n\n\tsecattr->attr.mls.lvl = context->range.level[0].sens - 1;\n\tsecattr->flags |= NETLBL_SECATTR_MLS_LVL;\n}"
  },
  {
    "function_name": "mls_compute_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "506-567",
    "snippet": "int mls_compute_sid(struct context *scontext,\n\t\t    struct context *tcontext,\n\t\t    u16 tclass,\n\t\t    u32 specified,\n\t\t    struct context *newcontext,\n\t\t    bool sock)\n{\n\tstruct range_trans rtr;\n\tstruct mls_range *r;\n\tstruct class_datum *cladatum;\n\tint default_range = 0;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\t\t/* Look for a range transition rule. */\n\t\trtr.source_type = scontext->type;\n\t\trtr.target_type = tcontext->type;\n\t\trtr.target_class = tclass;\n\t\tr = hashtab_search(policydb.range_tr, &rtr);\n\t\tif (r)\n\t\t\treturn mls_range_set(newcontext, r);\n\n\t\tif (tclass && tclass <= policydb.p_classes.nprim) {\n\t\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\t\t\tif (cladatum)\n\t\t\t\tdefault_range = cladatum->default_range;\n\t\t}\n\n\t\tswitch (default_range) {\n\t\tcase DEFAULT_SOURCE_LOW:\n\t\t\treturn mls_context_cpy_low(newcontext, scontext);\n\t\tcase DEFAULT_SOURCE_HIGH:\n\t\t\treturn mls_context_cpy_high(newcontext, scontext);\n\t\tcase DEFAULT_SOURCE_LOW_HIGH:\n\t\t\treturn mls_context_cpy(newcontext, scontext);\n\t\tcase DEFAULT_TARGET_LOW:\n\t\t\treturn mls_context_cpy_low(newcontext, tcontext);\n\t\tcase DEFAULT_TARGET_HIGH:\n\t\t\treturn mls_context_cpy_high(newcontext, tcontext);\n\t\tcase DEFAULT_TARGET_LOW_HIGH:\n\t\t\treturn mls_context_cpy(newcontext, tcontext);\n\t\t}\n\n\t\t/* Fallthrough */\n\tcase AVTAB_CHANGE:\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\t/* Use the process MLS attributes. */\n\t\t\treturn mls_context_cpy(newcontext, scontext);\n\t\telse\n\t\t\t/* Use the process effective MLS attributes. */\n\t\t\treturn mls_context_cpy_low(newcontext, scontext);\n\tcase AVTAB_MEMBER:\n\t\t/* Use the process effective MLS attributes. */\n\t\treturn mls_context_cpy_low(newcontext, scontext);\n\n\t/* fall through */\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mls_context_cpy_low",
          "args": [
            "newcontext",
            "scontext"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "mls_context_cpy_low",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "61-76",
          "snippet": "static inline int mls_context_cpy_low(struct context *dst, struct context *src)\n{\n\tint rc;\n\n\tdst->range.level[0].sens = src->range.level[0].sens;\n\trc = ebitmap_cpy(&dst->range.level[0].cat, &src->range.level[0].cat);\n\tif (rc)\n\t\tgoto out;\n\n\tdst->range.level[1].sens = src->range.level[0].sens;\n\trc = ebitmap_cpy(&dst->range.level[1].cat, &src->range.level[0].cat);\n\tif (rc)\n\t\tebitmap_destroy(&dst->range.level[0].cat);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline int mls_context_cpy_low(struct context *dst, struct context *src)\n{\n\tint rc;\n\n\tdst->range.level[0].sens = src->range.level[0].sens;\n\trc = ebitmap_cpy(&dst->range.level[0].cat, &src->range.level[0].cat);\n\tif (rc)\n\t\tgoto out;\n\n\tdst->range.level[1].sens = src->range.level[0].sens;\n\trc = ebitmap_cpy(&dst->range.level[1].cat, &src->range.level[0].cat);\n\tif (rc)\n\t\tebitmap_destroy(&dst->range.level[0].cat);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_context_cpy",
          "args": [
            "newcontext",
            "scontext"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "mls_context_cpy_high",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "81-96",
          "snippet": "static inline int mls_context_cpy_high(struct context *dst, struct context *src)\n{\n\tint rc;\n\n\tdst->range.level[0].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[0].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tgoto out;\n\n\tdst->range.level[1].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[1].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tebitmap_destroy(&dst->range.level[0].cat);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline int mls_context_cpy_high(struct context *dst, struct context *src)\n{\n\tint rc;\n\n\tdst->range.level[0].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[0].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tgoto out;\n\n\tdst->range.level[1].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[1].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tebitmap_destroy(&dst->range.level[0].cat);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_range_set",
          "args": [
            "newcontext",
            "r"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "mls_range_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "403-418",
          "snippet": "int mls_range_set(struct context *context,\n\t\t\t\tstruct mls_range *range)\n{\n\tint l, rc = 0;\n\n\t/* Copy the MLS range into the  context */\n\tfor (l = 0; l < 2; l++) {\n\t\tcontext->range.level[l].sens = range->level[l].sens;\n\t\trc = ebitmap_cpy(&context->range.level[l].cat,\n\t\t\t\t &range->level[l].cat);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_range_set(struct context *context,\n\t\t\t\tstruct mls_range *range)\n{\n\tint l, rc = 0;\n\n\t/* Copy the MLS range into the  context */\n\tfor (l = 0; l < 2; l++) {\n\t\tcontext->range.level[l].sens = range->level[l].sens;\n\t\trc = ebitmap_cpy(&context->range.level[l].cat,\n\t\t\t\t &range->level[l].cat);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "policydb.range_tr",
            "&rtr"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_compute_sid(struct context *scontext,\n\t\t    struct context *tcontext,\n\t\t    u16 tclass,\n\t\t    u32 specified,\n\t\t    struct context *newcontext,\n\t\t    bool sock)\n{\n\tstruct range_trans rtr;\n\tstruct mls_range *r;\n\tstruct class_datum *cladatum;\n\tint default_range = 0;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tswitch (specified) {\n\tcase AVTAB_TRANSITION:\n\t\t/* Look for a range transition rule. */\n\t\trtr.source_type = scontext->type;\n\t\trtr.target_type = tcontext->type;\n\t\trtr.target_class = tclass;\n\t\tr = hashtab_search(policydb.range_tr, &rtr);\n\t\tif (r)\n\t\t\treturn mls_range_set(newcontext, r);\n\n\t\tif (tclass && tclass <= policydb.p_classes.nprim) {\n\t\t\tcladatum = policydb.class_val_to_struct[tclass - 1];\n\t\t\tif (cladatum)\n\t\t\t\tdefault_range = cladatum->default_range;\n\t\t}\n\n\t\tswitch (default_range) {\n\t\tcase DEFAULT_SOURCE_LOW:\n\t\t\treturn mls_context_cpy_low(newcontext, scontext);\n\t\tcase DEFAULT_SOURCE_HIGH:\n\t\t\treturn mls_context_cpy_high(newcontext, scontext);\n\t\tcase DEFAULT_SOURCE_LOW_HIGH:\n\t\t\treturn mls_context_cpy(newcontext, scontext);\n\t\tcase DEFAULT_TARGET_LOW:\n\t\t\treturn mls_context_cpy_low(newcontext, tcontext);\n\t\tcase DEFAULT_TARGET_HIGH:\n\t\t\treturn mls_context_cpy_high(newcontext, tcontext);\n\t\tcase DEFAULT_TARGET_LOW_HIGH:\n\t\t\treturn mls_context_cpy(newcontext, tcontext);\n\t\t}\n\n\t\t/* Fallthrough */\n\tcase AVTAB_CHANGE:\n\t\tif ((tclass == policydb.process_class) || (sock == true))\n\t\t\t/* Use the process MLS attributes. */\n\t\t\treturn mls_context_cpy(newcontext, scontext);\n\t\telse\n\t\t\t/* Use the process effective MLS attributes. */\n\t\t\treturn mls_context_cpy_low(newcontext, scontext);\n\tcase AVTAB_MEMBER:\n\t\t/* Use the process effective MLS attributes. */\n\t\treturn mls_context_cpy_low(newcontext, scontext);\n\n\t/* fall through */\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "mls_convert_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "463-504",
    "snippet": "int mls_convert_context(struct policydb *oldp,\n\t\t\tstruct policydb *newp,\n\t\t\tstruct context *c)\n{\n\tstruct level_datum *levdatum;\n\tstruct cat_datum *catdatum;\n\tstruct ebitmap bitmap;\n\tstruct ebitmap_node *node;\n\tint l, i;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tfor (l = 0; l < 2; l++) {\n\t\tlevdatum = hashtab_search(newp->p_levels.table,\n\t\t\t\t\t  sym_name(oldp, SYM_LEVELS,\n\t\t\t\t\t\t   c->range.level[l].sens - 1));\n\n\t\tif (!levdatum)\n\t\t\treturn -EINVAL;\n\t\tc->range.level[l].sens = levdatum->level->sens;\n\n\t\tebitmap_init(&bitmap);\n\t\tebitmap_for_each_positive_bit(&c->range.level[l].cat, node, i) {\n\t\t\tint rc;\n\n\t\t\tcatdatum = hashtab_search(newp->p_cats.table,\n\t\t\t\t\t\t  sym_name(oldp, SYM_CATS, i));\n\t\t\tif (!catdatum)\n\t\t\t\treturn -EINVAL;\n\t\t\trc = ebitmap_set_bit(&bitmap, catdatum->value - 1, 1);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tcond_resched();\n\t\t}\n\t\tebitmap_destroy(&c->range.level[l].cat);\n\t\tc->range.level[l].cat = bitmap;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "&c->range.level[l].cat"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_set_bit",
          "args": [
            "&bitmap",
            "catdatum->value - 1",
            "1"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "259-325",
          "snippet": "int ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* drop this node from the bitmap */\n\t\t\t\tif (!n->next) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this was the highest map\n\t\t\t\t\t * within the bitmap\n\t\t\t\t\t */\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t/* this node will be the highest map within the bitmap */\n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* drop this node from the bitmap */\n\t\t\t\tif (!n->next) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this was the highest map\n\t\t\t\t\t * within the bitmap\n\t\t\t\t\t */\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t/* this node will be the highest map within the bitmap */\n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "newp->p_cats.table",
            "sym_name(oldp, SYM_CATS, i)"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "oldp",
            "SYM_CATS",
            "i"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "&c->range.level[l].cat",
            "node",
            "i"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_init",
          "args": [
            "&bitmap"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.h",
          "lines": "60-63",
          "snippet": "static inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}",
          "includes": [
            "#include <net/netlabel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/netlabel.h>\n\nstatic inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_convert_context(struct policydb *oldp,\n\t\t\tstruct policydb *newp,\n\t\t\tstruct context *c)\n{\n\tstruct level_datum *levdatum;\n\tstruct cat_datum *catdatum;\n\tstruct ebitmap bitmap;\n\tstruct ebitmap_node *node;\n\tint l, i;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tfor (l = 0; l < 2; l++) {\n\t\tlevdatum = hashtab_search(newp->p_levels.table,\n\t\t\t\t\t  sym_name(oldp, SYM_LEVELS,\n\t\t\t\t\t\t   c->range.level[l].sens - 1));\n\n\t\tif (!levdatum)\n\t\t\treturn -EINVAL;\n\t\tc->range.level[l].sens = levdatum->level->sens;\n\n\t\tebitmap_init(&bitmap);\n\t\tebitmap_for_each_positive_bit(&c->range.level[l].cat, node, i) {\n\t\t\tint rc;\n\n\t\t\tcatdatum = hashtab_search(newp->p_cats.table,\n\t\t\t\t\t\t  sym_name(oldp, SYM_CATS, i));\n\t\t\tif (!catdatum)\n\t\t\t\treturn -EINVAL;\n\t\t\trc = ebitmap_set_bit(&bitmap, catdatum->value - 1, 1);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tcond_resched();\n\t\t}\n\t\tebitmap_destroy(&c->range.level[l].cat);\n\t\tc->range.level[l].cat = bitmap;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mls_setup_user_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "420-456",
    "snippet": "int mls_setup_user_range(struct context *fromcon, struct user_datum *user,\n\t\t\t struct context *usercon)\n{\n\tif (policydb.mls_enabled) {\n\t\tstruct mls_level *fromcon_sen = &(fromcon->range.level[0]);\n\t\tstruct mls_level *fromcon_clr = &(fromcon->range.level[1]);\n\t\tstruct mls_level *user_low = &(user->range.level[0]);\n\t\tstruct mls_level *user_clr = &(user->range.level[1]);\n\t\tstruct mls_level *user_def = &(user->dfltlevel);\n\t\tstruct mls_level *usercon_sen = &(usercon->range.level[0]);\n\t\tstruct mls_level *usercon_clr = &(usercon->range.level[1]);\n\n\t\t/* Honor the user's default level if we can */\n\t\tif (mls_level_between(user_def, fromcon_sen, fromcon_clr))\n\t\t\t*usercon_sen = *user_def;\n\t\telse if (mls_level_between(fromcon_sen, user_def, user_clr))\n\t\t\t*usercon_sen = *fromcon_sen;\n\t\telse if (mls_level_between(fromcon_clr, user_low, user_def))\n\t\t\t*usercon_sen = *user_low;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\t/* Lower the clearance of available contexts\n\t\t   if the clearance of \"fromcon\" is lower than\n\t\t   that of the user's default clearance (but\n\t\t   only if the \"fromcon\" clearance dominates\n\t\t   the user's computed sensitivity level) */\n\t\tif (mls_level_dom(user_clr, fromcon_clr))\n\t\t\t*usercon_clr = *fromcon_clr;\n\t\telse if (mls_level_dom(fromcon_clr, user_clr))\n\t\t\t*usercon_clr = *user_clr;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mls_level_dom",
          "args": [
            "fromcon_clr",
            "user_clr"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "mls_level_dom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls_types.h",
          "lines": "36-40",
          "snippet": "static inline int mls_level_dom(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens >= l2->sens) &&\n\t\tebitmap_contains(&l1->cat, &l2->cat, 0));\n}",
          "includes": [
            "#include \"ebitmap.h\"",
            "#include \"security.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebitmap.h\"\n#include \"security.h\"\n\nstatic inline int mls_level_dom(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens >= l2->sens) &&\n\t\tebitmap_contains(&l1->cat, &l2->cat, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_level_between",
          "args": [
            "fromcon_clr",
            "user_low",
            "user_def"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mls_level_between",
          "args": [
            "fromcon_sen",
            "user_def",
            "user_clr"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mls_level_between",
          "args": [
            "user_def",
            "fromcon_sen",
            "fromcon_clr"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_setup_user_range(struct context *fromcon, struct user_datum *user,\n\t\t\t struct context *usercon)\n{\n\tif (policydb.mls_enabled) {\n\t\tstruct mls_level *fromcon_sen = &(fromcon->range.level[0]);\n\t\tstruct mls_level *fromcon_clr = &(fromcon->range.level[1]);\n\t\tstruct mls_level *user_low = &(user->range.level[0]);\n\t\tstruct mls_level *user_clr = &(user->range.level[1]);\n\t\tstruct mls_level *user_def = &(user->dfltlevel);\n\t\tstruct mls_level *usercon_sen = &(usercon->range.level[0]);\n\t\tstruct mls_level *usercon_clr = &(usercon->range.level[1]);\n\n\t\t/* Honor the user's default level if we can */\n\t\tif (mls_level_between(user_def, fromcon_sen, fromcon_clr))\n\t\t\t*usercon_sen = *user_def;\n\t\telse if (mls_level_between(fromcon_sen, user_def, user_clr))\n\t\t\t*usercon_sen = *fromcon_sen;\n\t\telse if (mls_level_between(fromcon_clr, user_low, user_def))\n\t\t\t*usercon_sen = *user_low;\n\t\telse\n\t\t\treturn -EINVAL;\n\n\t\t/* Lower the clearance of available contexts\n\t\t   if the clearance of \"fromcon\" is lower than\n\t\t   that of the user's default clearance (but\n\t\t   only if the \"fromcon\" clearance dominates\n\t\t   the user's computed sensitivity level) */\n\t\tif (mls_level_dom(user_clr, fromcon_clr))\n\t\t\t*usercon_clr = *fromcon_clr;\n\t\telse if (mls_level_dom(fromcon_clr, user_clr))\n\t\t\t*usercon_clr = *user_clr;\n\t\telse\n\t\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "mls_range_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "403-418",
    "snippet": "int mls_range_set(struct context *context,\n\t\t\t\tstruct mls_range *range)\n{\n\tint l, rc = 0;\n\n\t/* Copy the MLS range into the  context */\n\tfor (l = 0; l < 2; l++) {\n\t\tcontext->range.level[l].sens = range->level[l].sens;\n\t\trc = ebitmap_cpy(&context->range.level[l].cat,\n\t\t\t\t &range->level[l].cat);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_cpy",
          "args": [
            "&context->range.level[l].cat",
            "&range->level[l].cat"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "52-78",
          "snippet": "int ebitmap_cpy(struct ebitmap *dst, struct ebitmap *src)\n{\n\tstruct ebitmap_node *n, *new, *prev;\n\n\tebitmap_init(dst);\n\tn = src->node;\n\tprev = NULL;\n\twhile (n) {\n\t\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\tebitmap_destroy(dst);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnew->startbit = n->startbit;\n\t\tmemcpy(new->maps, n->maps, EBITMAP_SIZE / 8);\n\t\tnew->next = NULL;\n\t\tif (prev)\n\t\t\tprev->next = new;\n\t\telse\n\t\t\tdst->node = new;\n\t\tprev = new;\n\t\tn = n->next;\n\t}\n\n\tdst->highbit = src->highbit;\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_cpy(struct ebitmap *dst, struct ebitmap *src)\n{\n\tstruct ebitmap_node *n, *new, *prev;\n\n\tebitmap_init(dst);\n\tn = src->node;\n\tprev = NULL;\n\twhile (n) {\n\t\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\tebitmap_destroy(dst);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnew->startbit = n->startbit;\n\t\tmemcpy(new->maps, n->maps, EBITMAP_SIZE / 8);\n\t\tnew->next = NULL;\n\t\tif (prev)\n\t\t\tprev->next = new;\n\t\telse\n\t\t\tdst->node = new;\n\t\tprev = new;\n\t\tn = n->next;\n\t}\n\n\tdst->highbit = src->highbit;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_range_set(struct context *context,\n\t\t\t\tstruct mls_range *range)\n{\n\tint l, rc = 0;\n\n\t/* Copy the MLS range into the  context */\n\tfor (l = 0; l < 2; l++) {\n\t\tcontext->range.level[l].sens = range->level[l].sens;\n\t\trc = ebitmap_cpy(&context->range.level[l].cat,\n\t\t\t\t &range->level[l].cat);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "mls_from_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "378-398",
    "snippet": "int mls_from_string(char *str, struct context *context, gfp_t gfp_mask)\n{\n\tchar *tmpstr, *freestr;\n\tint rc;\n\n\tif (!policydb.mls_enabled)\n\t\treturn -EINVAL;\n\n\t/* we need freestr because mls_context_to_sid will change\n\t   the value of tmpstr */\n\ttmpstr = freestr = kstrdup(str, gfp_mask);\n\tif (!tmpstr) {\n\t\trc = -ENOMEM;\n\t} else {\n\t\trc = mls_context_to_sid(&policydb, ':', &tmpstr, context,\n\t\t\t\t\tNULL, SECSID_NULL);\n\t\tkfree(freestr);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "freestr"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mls_context_to_sid",
          "args": [
            "&policydb",
            "':'",
            "&tmpstr",
            "context",
            "NULL",
            "SECSID_NULL"
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "mls_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "235-370",
          "snippet": "int mls_context_to_sid(struct policydb *pol,\n\t\t       char oldc,\n\t\t       char **scontext,\n\t\t       struct context *context,\n\t\t       struct sidtab *s,\n\t\t       u32 def_sid)\n{\n\n\tchar delim;\n\tchar *scontextp, *p, *rngptr;\n\tstruct level_datum *levdatum;\n\tstruct cat_datum *catdatum, *rngdatum;\n\tint l, rc = -EINVAL;\n\n\tif (!pol->mls_enabled) {\n\t\tif (def_sid != SECSID_NULL && oldc)\n\t\t\t*scontext += strlen(*scontext) + 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * No MLS component to the security context, try and map to\n\t * default if provided.\n\t */\n\tif (!oldc) {\n\t\tstruct context *defcon;\n\n\t\tif (def_sid == SECSID_NULL)\n\t\t\tgoto out;\n\n\t\tdefcon = sidtab_search(s, def_sid);\n\t\tif (!defcon)\n\t\t\tgoto out;\n\n\t\trc = mls_context_cpy(context, defcon);\n\t\tgoto out;\n\t}\n\n\t/* Extract low sensitivity. */\n\tscontextp = p = *scontext;\n\twhile (*p && *p != ':' && *p != '-')\n\t\tp++;\n\n\tdelim = *p;\n\tif (delim != '\\0')\n\t\t*p++ = '\\0';\n\n\tfor (l = 0; l < 2; l++) {\n\t\tlevdatum = hashtab_search(pol->p_levels.table, scontextp);\n\t\tif (!levdatum) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcontext->range.level[l].sens = levdatum->level->sens;\n\n\t\tif (delim == ':') {\n\t\t\t/* Extract category set. */\n\t\t\twhile (1) {\n\t\t\t\tscontextp = p;\n\t\t\t\twhile (*p && *p != ',' && *p != '-')\n\t\t\t\t\tp++;\n\t\t\t\tdelim = *p;\n\t\t\t\tif (delim != '\\0')\n\t\t\t\t\t*p++ = '\\0';\n\n\t\t\t\t/* Separate into range if exists */\n\t\t\t\trngptr = strchr(scontextp, '.');\n\t\t\t\tif (rngptr != NULL) {\n\t\t\t\t\t/* Remove '.' */\n\t\t\t\t\t*rngptr++ = '\\0';\n\t\t\t\t}\n\n\t\t\t\tcatdatum = hashtab_search(pol->p_cats.table,\n\t\t\t\t\t\t\t  scontextp);\n\t\t\t\tif (!catdatum) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat,\n\t\t\t\t\t\t     catdatum->value - 1, 1);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/* If range, set all categories in range */\n\t\t\t\tif (rngptr) {\n\t\t\t\t\tint i;\n\n\t\t\t\t\trngdatum = hashtab_search(pol->p_cats.table, rngptr);\n\t\t\t\t\tif (!rngdatum) {\n\t\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (catdatum->value >= rngdatum->value) {\n\t\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = catdatum->value; i < rngdatum->value; i++) {\n\t\t\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat, i, 1);\n\t\t\t\t\t\tif (rc)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (delim != ',')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (delim == '-') {\n\t\t\t/* Extract high sensitivity. */\n\t\t\tscontextp = p;\n\t\t\twhile (*p && *p != ':')\n\t\t\t\tp++;\n\n\t\t\tdelim = *p;\n\t\t\tif (delim != '\\0')\n\t\t\t\t*p++ = '\\0';\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (l == 0) {\n\t\tcontext->range.level[1].sens = context->range.level[0].sens;\n\t\trc = ebitmap_cpy(&context->range.level[1].cat,\n\t\t\t\t &context->range.level[0].cat);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\t*scontext = ++p;\n\trc = 0;\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_context_to_sid(struct policydb *pol,\n\t\t       char oldc,\n\t\t       char **scontext,\n\t\t       struct context *context,\n\t\t       struct sidtab *s,\n\t\t       u32 def_sid)\n{\n\n\tchar delim;\n\tchar *scontextp, *p, *rngptr;\n\tstruct level_datum *levdatum;\n\tstruct cat_datum *catdatum, *rngdatum;\n\tint l, rc = -EINVAL;\n\n\tif (!pol->mls_enabled) {\n\t\tif (def_sid != SECSID_NULL && oldc)\n\t\t\t*scontext += strlen(*scontext) + 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * No MLS component to the security context, try and map to\n\t * default if provided.\n\t */\n\tif (!oldc) {\n\t\tstruct context *defcon;\n\n\t\tif (def_sid == SECSID_NULL)\n\t\t\tgoto out;\n\n\t\tdefcon = sidtab_search(s, def_sid);\n\t\tif (!defcon)\n\t\t\tgoto out;\n\n\t\trc = mls_context_cpy(context, defcon);\n\t\tgoto out;\n\t}\n\n\t/* Extract low sensitivity. */\n\tscontextp = p = *scontext;\n\twhile (*p && *p != ':' && *p != '-')\n\t\tp++;\n\n\tdelim = *p;\n\tif (delim != '\\0')\n\t\t*p++ = '\\0';\n\n\tfor (l = 0; l < 2; l++) {\n\t\tlevdatum = hashtab_search(pol->p_levels.table, scontextp);\n\t\tif (!levdatum) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcontext->range.level[l].sens = levdatum->level->sens;\n\n\t\tif (delim == ':') {\n\t\t\t/* Extract category set. */\n\t\t\twhile (1) {\n\t\t\t\tscontextp = p;\n\t\t\t\twhile (*p && *p != ',' && *p != '-')\n\t\t\t\t\tp++;\n\t\t\t\tdelim = *p;\n\t\t\t\tif (delim != '\\0')\n\t\t\t\t\t*p++ = '\\0';\n\n\t\t\t\t/* Separate into range if exists */\n\t\t\t\trngptr = strchr(scontextp, '.');\n\t\t\t\tif (rngptr != NULL) {\n\t\t\t\t\t/* Remove '.' */\n\t\t\t\t\t*rngptr++ = '\\0';\n\t\t\t\t}\n\n\t\t\t\tcatdatum = hashtab_search(pol->p_cats.table,\n\t\t\t\t\t\t\t  scontextp);\n\t\t\t\tif (!catdatum) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat,\n\t\t\t\t\t\t     catdatum->value - 1, 1);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/* If range, set all categories in range */\n\t\t\t\tif (rngptr) {\n\t\t\t\t\tint i;\n\n\t\t\t\t\trngdatum = hashtab_search(pol->p_cats.table, rngptr);\n\t\t\t\t\tif (!rngdatum) {\n\t\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (catdatum->value >= rngdatum->value) {\n\t\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = catdatum->value; i < rngdatum->value; i++) {\n\t\t\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat, i, 1);\n\t\t\t\t\t\tif (rc)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (delim != ',')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (delim == '-') {\n\t\t\t/* Extract high sensitivity. */\n\t\t\tscontextp = p;\n\t\t\twhile (*p && *p != ':')\n\t\t\t\tp++;\n\n\t\t\tdelim = *p;\n\t\t\tif (delim != '\\0')\n\t\t\t\t*p++ = '\\0';\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (l == 0) {\n\t\tcontext->range.level[1].sens = context->range.level[0].sens;\n\t\trc = ebitmap_cpy(&context->range.level[1].cat,\n\t\t\t\t &context->range.level[0].cat);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\t*scontext = ++p;\n\trc = 0;\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "gfp_mask"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_from_string(char *str, struct context *context, gfp_t gfp_mask)\n{\n\tchar *tmpstr, *freestr;\n\tint rc;\n\n\tif (!policydb.mls_enabled)\n\t\treturn -EINVAL;\n\n\t/* we need freestr because mls_context_to_sid will change\n\t   the value of tmpstr */\n\ttmpstr = freestr = kstrdup(str, gfp_mask);\n\tif (!tmpstr) {\n\t\trc = -ENOMEM;\n\t} else {\n\t\trc = mls_context_to_sid(&policydb, ':', &tmpstr, context,\n\t\t\t\t\tNULL, SECSID_NULL);\n\t\tkfree(freestr);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "mls_context_to_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "235-370",
    "snippet": "int mls_context_to_sid(struct policydb *pol,\n\t\t       char oldc,\n\t\t       char **scontext,\n\t\t       struct context *context,\n\t\t       struct sidtab *s,\n\t\t       u32 def_sid)\n{\n\n\tchar delim;\n\tchar *scontextp, *p, *rngptr;\n\tstruct level_datum *levdatum;\n\tstruct cat_datum *catdatum, *rngdatum;\n\tint l, rc = -EINVAL;\n\n\tif (!pol->mls_enabled) {\n\t\tif (def_sid != SECSID_NULL && oldc)\n\t\t\t*scontext += strlen(*scontext) + 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * No MLS component to the security context, try and map to\n\t * default if provided.\n\t */\n\tif (!oldc) {\n\t\tstruct context *defcon;\n\n\t\tif (def_sid == SECSID_NULL)\n\t\t\tgoto out;\n\n\t\tdefcon = sidtab_search(s, def_sid);\n\t\tif (!defcon)\n\t\t\tgoto out;\n\n\t\trc = mls_context_cpy(context, defcon);\n\t\tgoto out;\n\t}\n\n\t/* Extract low sensitivity. */\n\tscontextp = p = *scontext;\n\twhile (*p && *p != ':' && *p != '-')\n\t\tp++;\n\n\tdelim = *p;\n\tif (delim != '\\0')\n\t\t*p++ = '\\0';\n\n\tfor (l = 0; l < 2; l++) {\n\t\tlevdatum = hashtab_search(pol->p_levels.table, scontextp);\n\t\tif (!levdatum) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcontext->range.level[l].sens = levdatum->level->sens;\n\n\t\tif (delim == ':') {\n\t\t\t/* Extract category set. */\n\t\t\twhile (1) {\n\t\t\t\tscontextp = p;\n\t\t\t\twhile (*p && *p != ',' && *p != '-')\n\t\t\t\t\tp++;\n\t\t\t\tdelim = *p;\n\t\t\t\tif (delim != '\\0')\n\t\t\t\t\t*p++ = '\\0';\n\n\t\t\t\t/* Separate into range if exists */\n\t\t\t\trngptr = strchr(scontextp, '.');\n\t\t\t\tif (rngptr != NULL) {\n\t\t\t\t\t/* Remove '.' */\n\t\t\t\t\t*rngptr++ = '\\0';\n\t\t\t\t}\n\n\t\t\t\tcatdatum = hashtab_search(pol->p_cats.table,\n\t\t\t\t\t\t\t  scontextp);\n\t\t\t\tif (!catdatum) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat,\n\t\t\t\t\t\t     catdatum->value - 1, 1);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/* If range, set all categories in range */\n\t\t\t\tif (rngptr) {\n\t\t\t\t\tint i;\n\n\t\t\t\t\trngdatum = hashtab_search(pol->p_cats.table, rngptr);\n\t\t\t\t\tif (!rngdatum) {\n\t\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (catdatum->value >= rngdatum->value) {\n\t\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = catdatum->value; i < rngdatum->value; i++) {\n\t\t\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat, i, 1);\n\t\t\t\t\t\tif (rc)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (delim != ',')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (delim == '-') {\n\t\t\t/* Extract high sensitivity. */\n\t\t\tscontextp = p;\n\t\t\twhile (*p && *p != ':')\n\t\t\t\tp++;\n\n\t\t\tdelim = *p;\n\t\t\tif (delim != '\\0')\n\t\t\t\t*p++ = '\\0';\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (l == 0) {\n\t\tcontext->range.level[1].sens = context->range.level[0].sens;\n\t\trc = ebitmap_cpy(&context->range.level[1].cat,\n\t\t\t\t &context->range.level[0].cat);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\t*scontext = ++p;\n\trc = 0;\nout:\n\treturn rc;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_cpy",
          "args": [
            "&context->range.level[1].cat",
            "&context->range.level[0].cat"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "52-78",
          "snippet": "int ebitmap_cpy(struct ebitmap *dst, struct ebitmap *src)\n{\n\tstruct ebitmap_node *n, *new, *prev;\n\n\tebitmap_init(dst);\n\tn = src->node;\n\tprev = NULL;\n\twhile (n) {\n\t\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\tebitmap_destroy(dst);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnew->startbit = n->startbit;\n\t\tmemcpy(new->maps, n->maps, EBITMAP_SIZE / 8);\n\t\tnew->next = NULL;\n\t\tif (prev)\n\t\t\tprev->next = new;\n\t\telse\n\t\t\tdst->node = new;\n\t\tprev = new;\n\t\tn = n->next;\n\t}\n\n\tdst->highbit = src->highbit;\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_cpy(struct ebitmap *dst, struct ebitmap *src)\n{\n\tstruct ebitmap_node *n, *new, *prev;\n\n\tebitmap_init(dst);\n\tn = src->node;\n\tprev = NULL;\n\twhile (n) {\n\t\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\tebitmap_destroy(dst);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnew->startbit = n->startbit;\n\t\tmemcpy(new->maps, n->maps, EBITMAP_SIZE / 8);\n\t\tnew->next = NULL;\n\t\tif (prev)\n\t\t\tprev->next = new;\n\t\telse\n\t\t\tdst->node = new;\n\t\tprev = new;\n\t\tn = n->next;\n\t}\n\n\tdst->highbit = src->highbit;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ebitmap_set_bit",
          "args": [
            "&context->range.level[l].cat",
            "i",
            "1"
          ],
          "line": 336
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "259-325",
          "snippet": "int ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* drop this node from the bitmap */\n\t\t\t\tif (!n->next) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this was the highest map\n\t\t\t\t\t * within the bitmap\n\t\t\t\t\t */\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t/* this node will be the highest map within the bitmap */\n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* drop this node from the bitmap */\n\t\t\t\tif (!n->next) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this was the highest map\n\t\t\t\t\t * within the bitmap\n\t\t\t\t\t */\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t/* this node will be the highest map within the bitmap */\n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "pol->p_cats.table",
            "rngptr"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "scontextp",
            "'.'"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mls_context_cpy",
          "args": [
            "context",
            "defcon"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "mls_context_cpy_high",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/context.h",
          "lines": "81-96",
          "snippet": "static inline int mls_context_cpy_high(struct context *dst, struct context *src)\n{\n\tint rc;\n\n\tdst->range.level[0].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[0].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tgoto out;\n\n\tdst->range.level[1].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[1].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tebitmap_destroy(&dst->range.level[0].cat);\nout:\n\treturn rc;\n}",
          "includes": [
            "#include \"security.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"security.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n\nstatic inline int mls_context_cpy_high(struct context *dst, struct context *src)\n{\n\tint rc;\n\n\tdst->range.level[0].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[0].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tgoto out;\n\n\tdst->range.level[1].sens = src->range.level[1].sens;\n\trc = ebitmap_cpy(&dst->range.level[1].cat, &src->range.level[1].cat);\n\tif (rc)\n\t\tebitmap_destroy(&dst->range.level[0].cat);\nout:\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sidtab_search",
          "args": [
            "s",
            "def_sid"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "sidtab_search_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/sidtab.c",
          "lines": "174-189",
          "snippet": "static inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sidtab.h\"",
            "#include \"security.h\"",
            "#include \"flask.h\"",
            "#include <linux/errno.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sidtab.h\"\n#include \"security.h\"\n#include \"flask.h\"\n#include <linux/errno.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline u32 sidtab_search_cache(struct sidtab *s, struct context *context)\n{\n\tint i;\n\tstruct sidtab_node *node;\n\n\tfor (i = 0; i < SIDTAB_CACHE_LEN; i++) {\n\t\tnode = s->cache[i];\n\t\tif (unlikely(!node))\n\t\t\treturn 0;\n\t\tif (context_cmp(&node->context, context)) {\n\t\t\tsidtab_update_cache(s, node, i);\n\t\t\treturn node->sid;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*scontext"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_context_to_sid(struct policydb *pol,\n\t\t       char oldc,\n\t\t       char **scontext,\n\t\t       struct context *context,\n\t\t       struct sidtab *s,\n\t\t       u32 def_sid)\n{\n\n\tchar delim;\n\tchar *scontextp, *p, *rngptr;\n\tstruct level_datum *levdatum;\n\tstruct cat_datum *catdatum, *rngdatum;\n\tint l, rc = -EINVAL;\n\n\tif (!pol->mls_enabled) {\n\t\tif (def_sid != SECSID_NULL && oldc)\n\t\t\t*scontext += strlen(*scontext) + 1;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * No MLS component to the security context, try and map to\n\t * default if provided.\n\t */\n\tif (!oldc) {\n\t\tstruct context *defcon;\n\n\t\tif (def_sid == SECSID_NULL)\n\t\t\tgoto out;\n\n\t\tdefcon = sidtab_search(s, def_sid);\n\t\tif (!defcon)\n\t\t\tgoto out;\n\n\t\trc = mls_context_cpy(context, defcon);\n\t\tgoto out;\n\t}\n\n\t/* Extract low sensitivity. */\n\tscontextp = p = *scontext;\n\twhile (*p && *p != ':' && *p != '-')\n\t\tp++;\n\n\tdelim = *p;\n\tif (delim != '\\0')\n\t\t*p++ = '\\0';\n\n\tfor (l = 0; l < 2; l++) {\n\t\tlevdatum = hashtab_search(pol->p_levels.table, scontextp);\n\t\tif (!levdatum) {\n\t\t\trc = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tcontext->range.level[l].sens = levdatum->level->sens;\n\n\t\tif (delim == ':') {\n\t\t\t/* Extract category set. */\n\t\t\twhile (1) {\n\t\t\t\tscontextp = p;\n\t\t\t\twhile (*p && *p != ',' && *p != '-')\n\t\t\t\t\tp++;\n\t\t\t\tdelim = *p;\n\t\t\t\tif (delim != '\\0')\n\t\t\t\t\t*p++ = '\\0';\n\n\t\t\t\t/* Separate into range if exists */\n\t\t\t\trngptr = strchr(scontextp, '.');\n\t\t\t\tif (rngptr != NULL) {\n\t\t\t\t\t/* Remove '.' */\n\t\t\t\t\t*rngptr++ = '\\0';\n\t\t\t\t}\n\n\t\t\t\tcatdatum = hashtab_search(pol->p_cats.table,\n\t\t\t\t\t\t\t  scontextp);\n\t\t\t\tif (!catdatum) {\n\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\n\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat,\n\t\t\t\t\t\t     catdatum->value - 1, 1);\n\t\t\t\tif (rc)\n\t\t\t\t\tgoto out;\n\n\t\t\t\t/* If range, set all categories in range */\n\t\t\t\tif (rngptr) {\n\t\t\t\t\tint i;\n\n\t\t\t\t\trngdatum = hashtab_search(pol->p_cats.table, rngptr);\n\t\t\t\t\tif (!rngdatum) {\n\t\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (catdatum->value >= rngdatum->value) {\n\t\t\t\t\t\trc = -EINVAL;\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (i = catdatum->value; i < rngdatum->value; i++) {\n\t\t\t\t\t\trc = ebitmap_set_bit(&context->range.level[l].cat, i, 1);\n\t\t\t\t\t\tif (rc)\n\t\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (delim != ',')\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (delim == '-') {\n\t\t\t/* Extract high sensitivity. */\n\t\t\tscontextp = p;\n\t\t\twhile (*p && *p != ':')\n\t\t\t\tp++;\n\n\t\t\tdelim = *p;\n\t\t\tif (delim != '\\0')\n\t\t\t\t*p++ = '\\0';\n\t\t} else\n\t\t\tbreak;\n\t}\n\n\tif (l == 0) {\n\t\tcontext->range.level[1].sens = context->range.level[0].sens;\n\t\trc = ebitmap_cpy(&context->range.level[1].cat,\n\t\t\t\t &context->range.level[0].cat);\n\t\tif (rc)\n\t\t\tgoto out;\n\t}\n\t*scontext = ++p;\n\trc = 0;\nout:\n\treturn rc;\n}"
  },
  {
    "function_name": "mls_context_isvalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "192-215",
    "snippet": "int mls_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct user_datum *usrdatum;\n\n\tif (!p->mls_enabled)\n\t\treturn 1;\n\n\tif (!mls_range_isvalid(p, &c->range))\n\t\treturn 0;\n\n\tif (c->role == OBJECT_R_VAL)\n\t\treturn 1;\n\n\t/*\n\t * User must be authorized for the MLS range.\n\t */\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\tusrdatum = p->user_val_to_struct[c->user - 1];\n\tif (!mls_range_contains(usrdatum->range, c->range))\n\t\treturn 0; /* user may not be associated with range */\n\n\treturn 1;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mls_range_contains",
          "args": [
            "usrdatum->range",
            "c->range"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mls_range_isvalid",
          "args": [
            "p",
            "&c->range"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "mls_range_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "181-186",
          "snippet": "int mls_range_isvalid(struct policydb *p, struct mls_range *r)\n{\n\treturn (mls_level_isvalid(p, &r->level[0]) &&\n\t\tmls_level_isvalid(p, &r->level[1]) &&\n\t\tmls_level_dom(&r->level[1], &r->level[0]));\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_range_isvalid(struct policydb *p, struct mls_range *r)\n{\n\treturn (mls_level_isvalid(p, &r->level[0]) &&\n\t\tmls_level_isvalid(p, &r->level[1]) &&\n\t\tmls_level_dom(&r->level[1], &r->level[0]));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_context_isvalid(struct policydb *p, struct context *c)\n{\n\tstruct user_datum *usrdatum;\n\n\tif (!p->mls_enabled)\n\t\treturn 1;\n\n\tif (!mls_range_isvalid(p, &c->range))\n\t\treturn 0;\n\n\tif (c->role == OBJECT_R_VAL)\n\t\treturn 1;\n\n\t/*\n\t * User must be authorized for the MLS range.\n\t */\n\tif (!c->user || c->user > p->p_users.nprim)\n\t\treturn 0;\n\tusrdatum = p->user_val_to_struct[c->user - 1];\n\tif (!mls_range_contains(usrdatum->range, c->range))\n\t\treturn 0; /* user may not be associated with range */\n\n\treturn 1;\n}"
  },
  {
    "function_name": "mls_range_isvalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "181-186",
    "snippet": "int mls_range_isvalid(struct policydb *p, struct mls_range *r)\n{\n\treturn (mls_level_isvalid(p, &r->level[0]) &&\n\t\tmls_level_isvalid(p, &r->level[1]) &&\n\t\tmls_level_dom(&r->level[1], &r->level[0]));\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mls_level_dom",
          "args": [
            "&r->level[1]",
            "&r->level[0]"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "mls_level_dom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls_types.h",
          "lines": "36-40",
          "snippet": "static inline int mls_level_dom(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens >= l2->sens) &&\n\t\tebitmap_contains(&l1->cat, &l2->cat, 0));\n}",
          "includes": [
            "#include \"ebitmap.h\"",
            "#include \"security.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebitmap.h\"\n#include \"security.h\"\n\nstatic inline int mls_level_dom(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens >= l2->sens) &&\n\t\tebitmap_contains(&l1->cat, &l2->cat, 0));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mls_level_isvalid",
          "args": [
            "p",
            "&r->level[1]"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "mls_level_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
          "lines": "161-179",
          "snippet": "int mls_level_isvalid(struct policydb *p, struct mls_level *l)\n{\n\tstruct level_datum *levdatum;\n\n\tif (!l->sens || l->sens > p->p_levels.nprim)\n\t\treturn 0;\n\tlevdatum = hashtab_search(p->p_levels.table,\n\t\t\t\t  sym_name(p, SYM_LEVELS, l->sens - 1));\n\tif (!levdatum)\n\t\treturn 0;\n\n\t/*\n\t * Return 1 iff all the bits set in l->cat are also be set in\n\t * levdatum->level->cat and no bit in l->cat is larger than\n\t * p->p_cats.nprim.\n\t */\n\treturn ebitmap_contains(&levdatum->level->cat, &l->cat,\n\t\t\t\tp->p_cats.nprim);\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"policydb.h\"",
            "#include \"mls.h\"",
            "#include \"sidtab.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_level_isvalid(struct policydb *p, struct mls_level *l)\n{\n\tstruct level_datum *levdatum;\n\n\tif (!l->sens || l->sens > p->p_levels.nprim)\n\t\treturn 0;\n\tlevdatum = hashtab_search(p->p_levels.table,\n\t\t\t\t  sym_name(p, SYM_LEVELS, l->sens - 1));\n\tif (!levdatum)\n\t\treturn 0;\n\n\t/*\n\t * Return 1 iff all the bits set in l->cat are also be set in\n\t * levdatum->level->cat and no bit in l->cat is larger than\n\t * p->p_cats.nprim.\n\t */\n\treturn ebitmap_contains(&levdatum->level->cat, &l->cat,\n\t\t\t\tp->p_cats.nprim);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_range_isvalid(struct policydb *p, struct mls_range *r)\n{\n\treturn (mls_level_isvalid(p, &r->level[0]) &&\n\t\tmls_level_isvalid(p, &r->level[1]) &&\n\t\tmls_level_dom(&r->level[1], &r->level[0]));\n}"
  },
  {
    "function_name": "mls_level_isvalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "161-179",
    "snippet": "int mls_level_isvalid(struct policydb *p, struct mls_level *l)\n{\n\tstruct level_datum *levdatum;\n\n\tif (!l->sens || l->sens > p->p_levels.nprim)\n\t\treturn 0;\n\tlevdatum = hashtab_search(p->p_levels.table,\n\t\t\t\t  sym_name(p, SYM_LEVELS, l->sens - 1));\n\tif (!levdatum)\n\t\treturn 0;\n\n\t/*\n\t * Return 1 iff all the bits set in l->cat are also be set in\n\t * levdatum->level->cat and no bit in l->cat is larger than\n\t * p->p_cats.nprim.\n\t */\n\treturn ebitmap_contains(&levdatum->level->cat, &l->cat,\n\t\t\t\tp->p_cats.nprim);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_contains",
          "args": [
            "&levdatum->level->cat",
            "&l->cat",
            "p->p_cats.nprim"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_contains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "201-240",
          "snippet": "int ebitmap_contains(struct ebitmap *e1, struct ebitmap *e2, u32 last_e2bit)\n{\n\tstruct ebitmap_node *n1, *n2;\n\tint i;\n\n\tif (e1->highbit < e2->highbit)\n\t\treturn 0;\n\n\tn1 = e1->node;\n\tn2 = e2->node;\n\n\twhile (n1 && n2 && (n1->startbit <= n2->startbit)) {\n\t\tif (n1->startbit < n2->startbit) {\n\t\t\tn1 = n1->next;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = EBITMAP_UNIT_NUMS - 1; (i >= 0) && !n2->maps[i]; )\n\t\t\ti--;\t/* Skip trailing NULL map entries */\n\t\tif (last_e2bit && (i >= 0)) {\n\t\t\tu32 lastsetbit = n2->startbit + i * EBITMAP_UNIT_SIZE +\n\t\t\t\t\t __fls(n2->maps[i]);\n\t\t\tif (lastsetbit > last_e2bit)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\twhile (i >= 0) {\n\t\t\tif ((n1->maps[i] & n2->maps[i]) != n2->maps[i])\n\t\t\t\treturn 0;\n\t\t\ti--;\n\t\t}\n\n\t\tn1 = n1->next;\n\t\tn2 = n2->next;\n\t}\n\n\tif (n2)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_contains(struct ebitmap *e1, struct ebitmap *e2, u32 last_e2bit)\n{\n\tstruct ebitmap_node *n1, *n2;\n\tint i;\n\n\tif (e1->highbit < e2->highbit)\n\t\treturn 0;\n\n\tn1 = e1->node;\n\tn2 = e2->node;\n\n\twhile (n1 && n2 && (n1->startbit <= n2->startbit)) {\n\t\tif (n1->startbit < n2->startbit) {\n\t\t\tn1 = n1->next;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = EBITMAP_UNIT_NUMS - 1; (i >= 0) && !n2->maps[i]; )\n\t\t\ti--;\t/* Skip trailing NULL map entries */\n\t\tif (last_e2bit && (i >= 0)) {\n\t\t\tu32 lastsetbit = n2->startbit + i * EBITMAP_UNIT_SIZE +\n\t\t\t\t\t __fls(n2->maps[i]);\n\t\t\tif (lastsetbit > last_e2bit)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\twhile (i >= 0) {\n\t\t\tif ((n1->maps[i] & n2->maps[i]) != n2->maps[i])\n\t\t\t\treturn 0;\n\t\t\ti--;\n\t\t}\n\n\t\tn1 = n1->next;\n\t\tn2 = n2->next;\n\t}\n\n\tif (n2)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hashtab_search",
          "args": [
            "p->p_levels.table",
            "sym_name(p, SYM_LEVELS, l->sens - 1)"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "hashtab_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/hashtab.c",
          "lines": "80-97",
          "snippet": "void *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}",
          "includes": [
            "#include \"hashtab.h\"",
            "#include <linux/sched.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"hashtab.h\"\n#include <linux/sched.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid *hashtab_search(struct hashtab *h, const void *key)\n{\n\tu32 hvalue;\n\tstruct hashtab_node *cur;\n\n\tif (!h)\n\t\treturn NULL;\n\n\thvalue = h->hash_value(h, key);\n\tcur = h->htable[hvalue];\n\twhile (cur && h->keycmp(h, key, cur->key) > 0)\n\t\tcur = cur->next;\n\n\tif (!cur || (h->keycmp(h, key, cur->key) != 0))\n\t\treturn NULL;\n\n\treturn cur->datum;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "p",
            "SYM_LEVELS",
            "l->sens - 1"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_level_isvalid(struct policydb *p, struct mls_level *l)\n{\n\tstruct level_datum *levdatum;\n\n\tif (!l->sens || l->sens > p->p_levels.nprim)\n\t\treturn 0;\n\tlevdatum = hashtab_search(p->p_levels.table,\n\t\t\t\t  sym_name(p, SYM_LEVELS, l->sens - 1));\n\tif (!levdatum)\n\t\treturn 0;\n\n\t/*\n\t * Return 1 iff all the bits set in l->cat are also be set in\n\t * levdatum->level->cat and no bit in l->cat is larger than\n\t * p->p_cats.nprim.\n\t */\n\treturn ebitmap_contains(&levdatum->level->cat, &l->cat,\n\t\t\t\tp->p_cats.nprim);\n}"
  },
  {
    "function_name": "mls_sid_to_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "89-159",
    "snippet": "void mls_sid_to_context(struct context *context,\n\t\t\tchar **scontext)\n{\n\tchar *scontextp, *nm;\n\tint i, l, head, prev;\n\tstruct ebitmap *e;\n\tstruct ebitmap_node *node;\n\n\tif (!policydb.mls_enabled)\n\t\treturn;\n\n\tscontextp = *scontext;\n\n\t*scontextp = ':';\n\tscontextp++;\n\n\tfor (l = 0; l < 2; l++) {\n\t\tstrcpy(scontextp, sym_name(&policydb, SYM_LEVELS,\n\t\t\t\t\t   context->range.level[l].sens - 1));\n\t\tscontextp += strlen(scontextp);\n\n\t\t/* categories */\n\t\thead = -2;\n\t\tprev = -2;\n\t\te = &context->range.level[l].cat;\n\t\tebitmap_for_each_positive_bit(e, node, i) {\n\t\t\tif (i - prev > 1) {\n\t\t\t\t/* one or more negative bits are skipped */\n\t\t\t\tif (prev != head) {\n\t\t\t\t\tif (prev - head > 1)\n\t\t\t\t\t\t*scontextp++ = '.';\n\t\t\t\t\telse\n\t\t\t\t\t\t*scontextp++ = ',';\n\t\t\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\t\t\tstrcpy(scontextp, nm);\n\t\t\t\t\tscontextp += strlen(nm);\n\t\t\t\t}\n\t\t\t\tif (prev < 0)\n\t\t\t\t\t*scontextp++ = ':';\n\t\t\t\telse\n\t\t\t\t\t*scontextp++ = ',';\n\t\t\t\tnm = sym_name(&policydb, SYM_CATS, i);\n\t\t\t\tstrcpy(scontextp, nm);\n\t\t\t\tscontextp += strlen(nm);\n\t\t\t\thead = i;\n\t\t\t}\n\t\t\tprev = i;\n\t\t}\n\n\t\tif (prev != head) {\n\t\t\tif (prev - head > 1)\n\t\t\t\t*scontextp++ = '.';\n\t\t\telse\n\t\t\t\t*scontextp++ = ',';\n\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\tstrcpy(scontextp, nm);\n\t\t\tscontextp += strlen(nm);\n\t\t}\n\n\t\tif (l == 0) {\n\t\t\tif (mls_level_eq(&context->range.level[0],\n\t\t\t\t\t &context->range.level[1]))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\t*scontextp++ = '-';\n\t\t}\n\t}\n\n\t*scontext = scontextp;\n\treturn;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mls_level_eq",
          "args": [
            "&context->range.level[0]",
            "&context->range.level[1]"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "mls_level_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls_types.h",
          "lines": "30-34",
          "snippet": "static inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens == l2->sens) &&\n\t\tebitmap_cmp(&l1->cat, &l2->cat));\n}",
          "includes": [
            "#include \"ebitmap.h\"",
            "#include \"security.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebitmap.h\"\n#include \"security.h\"\n\nstatic inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens == l2->sens) &&\n\t\tebitmap_cmp(&l1->cat, &l2->cat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nm"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "scontextp",
            "nm"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "&policydb",
            "SYM_CATS",
            "prev"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nm"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "scontextp",
            "nm"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nm"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "scontextp",
            "nm"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "e",
            "node",
            "i"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "scontextp"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "scontextp",
            "sym_name(&policydb, SYM_LEVELS,\n\t\t\t\t\t   context->range.level[l].sens - 1)"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid mls_sid_to_context(struct context *context,\n\t\t\tchar **scontext)\n{\n\tchar *scontextp, *nm;\n\tint i, l, head, prev;\n\tstruct ebitmap *e;\n\tstruct ebitmap_node *node;\n\n\tif (!policydb.mls_enabled)\n\t\treturn;\n\n\tscontextp = *scontext;\n\n\t*scontextp = ':';\n\tscontextp++;\n\n\tfor (l = 0; l < 2; l++) {\n\t\tstrcpy(scontextp, sym_name(&policydb, SYM_LEVELS,\n\t\t\t\t\t   context->range.level[l].sens - 1));\n\t\tscontextp += strlen(scontextp);\n\n\t\t/* categories */\n\t\thead = -2;\n\t\tprev = -2;\n\t\te = &context->range.level[l].cat;\n\t\tebitmap_for_each_positive_bit(e, node, i) {\n\t\t\tif (i - prev > 1) {\n\t\t\t\t/* one or more negative bits are skipped */\n\t\t\t\tif (prev != head) {\n\t\t\t\t\tif (prev - head > 1)\n\t\t\t\t\t\t*scontextp++ = '.';\n\t\t\t\t\telse\n\t\t\t\t\t\t*scontextp++ = ',';\n\t\t\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\t\t\tstrcpy(scontextp, nm);\n\t\t\t\t\tscontextp += strlen(nm);\n\t\t\t\t}\n\t\t\t\tif (prev < 0)\n\t\t\t\t\t*scontextp++ = ':';\n\t\t\t\telse\n\t\t\t\t\t*scontextp++ = ',';\n\t\t\t\tnm = sym_name(&policydb, SYM_CATS, i);\n\t\t\t\tstrcpy(scontextp, nm);\n\t\t\t\tscontextp += strlen(nm);\n\t\t\t\thead = i;\n\t\t\t}\n\t\t\tprev = i;\n\t\t}\n\n\t\tif (prev != head) {\n\t\t\tif (prev - head > 1)\n\t\t\t\t*scontextp++ = '.';\n\t\t\telse\n\t\t\t\t*scontextp++ = ',';\n\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\tstrcpy(scontextp, nm);\n\t\t\tscontextp += strlen(nm);\n\t\t}\n\n\t\tif (l == 0) {\n\t\t\tif (mls_level_eq(&context->range.level[0],\n\t\t\t\t\t &context->range.level[1]))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\t*scontextp++ = '-';\n\t\t}\n\t}\n\n\t*scontext = scontextp;\n\treturn;\n}"
  },
  {
    "function_name": "mls_compute_context_len",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls.c",
    "lines": "36-82",
    "snippet": "int mls_compute_context_len(struct context *context)\n{\n\tint i, l, len, head, prev;\n\tchar *nm;\n\tstruct ebitmap *e;\n\tstruct ebitmap_node *node;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tlen = 1; /* for the beginning \":\" */\n\tfor (l = 0; l < 2; l++) {\n\t\tint index_sens = context->range.level[l].sens;\n\t\tlen += strlen(sym_name(&policydb, SYM_LEVELS, index_sens - 1));\n\n\t\t/* categories */\n\t\thead = -2;\n\t\tprev = -2;\n\t\te = &context->range.level[l].cat;\n\t\tebitmap_for_each_positive_bit(e, node, i) {\n\t\t\tif (i - prev > 1) {\n\t\t\t\t/* one or more negative bits are skipped */\n\t\t\t\tif (head != prev) {\n\t\t\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\t\t\tlen += strlen(nm) + 1;\n\t\t\t\t}\n\t\t\t\tnm = sym_name(&policydb, SYM_CATS, i);\n\t\t\t\tlen += strlen(nm) + 1;\n\t\t\t\thead = i;\n\t\t\t}\n\t\t\tprev = i;\n\t\t}\n\t\tif (prev != head) {\n\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\tlen += strlen(nm) + 1;\n\t\t}\n\t\tif (l == 0) {\n\t\t\tif (mls_level_eq(&context->range.level[0],\n\t\t\t\t\t &context->range.level[1]))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tlen++;\n\t\t}\n\t}\n\n\treturn len;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"policydb.h\"",
      "#include \"mls.h\"",
      "#include \"sidtab.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/string.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mls_level_eq",
          "args": [
            "&context->range.level[0]",
            "&context->range.level[1]"
          ],
          "line": 73
        },
        "resolved": true,
        "details": {
          "function_name": "mls_level_eq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls_types.h",
          "lines": "30-34",
          "snippet": "static inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens == l2->sens) &&\n\t\tebitmap_cmp(&l1->cat, &l2->cat));\n}",
          "includes": [
            "#include \"ebitmap.h\"",
            "#include \"security.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ebitmap.h\"\n#include \"security.h\"\n\nstatic inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens == l2->sens) &&\n\t\tebitmap_cmp(&l1->cat, &l2->cat));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nm"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sym_name",
          "args": [
            "&policydb",
            "SYM_CATS",
            "prev"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "sym_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "370-375",
          "snippet": "static inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline char *sym_name(struct policydb *p, unsigned int sym_num, unsigned int element_nr)\n{\n\tstruct flex_array *fa = p->sym_val_to_name[sym_num];\n\n\treturn flex_array_get_ptr(fa, element_nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nm"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "nm"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "e",
            "node",
            "i"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sym_name(&policydb, SYM_LEVELS, index_sens - 1)"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"policydb.h\"\n#include \"mls.h\"\n#include \"sidtab.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint mls_compute_context_len(struct context *context)\n{\n\tint i, l, len, head, prev;\n\tchar *nm;\n\tstruct ebitmap *e;\n\tstruct ebitmap_node *node;\n\n\tif (!policydb.mls_enabled)\n\t\treturn 0;\n\n\tlen = 1; /* for the beginning \":\" */\n\tfor (l = 0; l < 2; l++) {\n\t\tint index_sens = context->range.level[l].sens;\n\t\tlen += strlen(sym_name(&policydb, SYM_LEVELS, index_sens - 1));\n\n\t\t/* categories */\n\t\thead = -2;\n\t\tprev = -2;\n\t\te = &context->range.level[l].cat;\n\t\tebitmap_for_each_positive_bit(e, node, i) {\n\t\t\tif (i - prev > 1) {\n\t\t\t\t/* one or more negative bits are skipped */\n\t\t\t\tif (head != prev) {\n\t\t\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\t\t\tlen += strlen(nm) + 1;\n\t\t\t\t}\n\t\t\t\tnm = sym_name(&policydb, SYM_CATS, i);\n\t\t\t\tlen += strlen(nm) + 1;\n\t\t\t\thead = i;\n\t\t\t}\n\t\t\tprev = i;\n\t\t}\n\t\tif (prev != head) {\n\t\t\tnm = sym_name(&policydb, SYM_CATS, prev);\n\t\t\tlen += strlen(nm) + 1;\n\t\t}\n\t\tif (l == 0) {\n\t\t\tif (mls_level_eq(&context->range.level[0],\n\t\t\t\t\t &context->range.level[1]))\n\t\t\t\tbreak;\n\t\t\telse\n\t\t\t\tlen++;\n\t\t}\n\t}\n\n\treturn len;\n}"
  }
]