[
  {
    "function_name": "ima_calc_boot_aggregate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "667-682",
    "snippet": "int __init ima_calc_boot_aggregate(struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\thash->length = crypto_shash_digestsize(tfm);\n\trc = ima_calc_boot_aggregate_tfm(hash->digest, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_free_tfm",
          "args": [
            "tfm"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "98-102",
          "snippet": "static void ima_free_tfm(struct crypto_shash *tfm)\n{\n\tif (tfm != ima_shash_tfm)\n\t\tcrypto_free_shash(tfm);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *ima_shash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_shash *ima_shash_tfm;\n\nstatic void ima_free_tfm(struct crypto_shash *tfm)\n{\n\tif (tfm != ima_shash_tfm)\n\t\tcrypto_free_shash(tfm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_calc_boot_aggregate_tfm",
          "args": [
            "hash->digest",
            "tfm"
          ],
          "line": 677
        },
        "resolved": true,
        "details": {
          "function_name": "ima_calc_boot_aggregate_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "642-665",
          "snippet": "static int __init ima_calc_boot_aggregate_tfm(char *digest,\n\t\t\t\t\t      struct crypto_shash *tfm)\n{\n\tu8 pcr_i[TPM_DIGEST_SIZE];\n\tint rc, i;\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/* cumulative sha1 over tpm registers 0-7 */\n\tfor (i = TPM_PCR0; i < TPM_PCR8; i++) {\n\t\tima_pcrread(i, pcr_i);\n\t\t/* now accumulate with current aggregate */\n\t\trc = crypto_shash_update(shash, pcr_i, TPM_DIGEST_SIZE);\n\t}\n\tif (!rc)\n\t\tcrypto_shash_final(shash, digest);\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int __init ima_calc_boot_aggregate_tfm(char *digest,\n\t\t\t\t\t      struct crypto_shash *tfm)\n{\n\tu8 pcr_i[TPM_DIGEST_SIZE];\n\tint rc, i;\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/* cumulative sha1 over tpm registers 0-7 */\n\tfor (i = TPM_PCR0; i < TPM_PCR8; i++) {\n\t\tima_pcrread(i, pcr_i);\n\t\t/* now accumulate with current aggregate */\n\t\trc = crypto_shash_update(shash, pcr_i, TPM_DIGEST_SIZE);\n\t}\n\tif (!rc)\n\t\tcrypto_shash_final(shash, digest);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_shash_digestsize",
          "args": [
            "tfm"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_alloc_tfm",
          "args": [
            "hash->algo"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "ima_alloc_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "79-96",
          "snippet": "static struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\n{\n\tstruct crypto_shash *tfm = ima_shash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo) {\n\t\ttfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *ima_shash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_shash *ima_shash_tfm;\n\nstatic struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\n{\n\tstruct crypto_shash *tfm = ima_shash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo) {\n\t\ttfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nint __init ima_calc_boot_aggregate(struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\thash->length = crypto_shash_digestsize(tfm);\n\trc = ima_calc_boot_aggregate_tfm(hash->digest, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ima_calc_boot_aggregate_tfm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "642-665",
    "snippet": "static int __init ima_calc_boot_aggregate_tfm(char *digest,\n\t\t\t\t\t      struct crypto_shash *tfm)\n{\n\tu8 pcr_i[TPM_DIGEST_SIZE];\n\tint rc, i;\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/* cumulative sha1 over tpm registers 0-7 */\n\tfor (i = TPM_PCR0; i < TPM_PCR8; i++) {\n\t\tima_pcrread(i, pcr_i);\n\t\t/* now accumulate with current aggregate */\n\t\trc = crypto_shash_update(shash, pcr_i, TPM_DIGEST_SIZE);\n\t}\n\tif (!rc)\n\t\tcrypto_shash_final(shash, digest);\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "shash",
            "digest"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "shash",
            "pcr_i",
            "TPM_DIGEST_SIZE"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_pcrread",
          "args": [
            "i",
            "pcr_i"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "ima_pcrread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "630-637",
          "snippet": "static void __init ima_pcrread(int idx, u8 *pcr)\n{\n\tif (!ima_used_chip)\n\t\treturn;\n\n\tif (tpm_pcr_read(TPM_ANY_NUM, idx, pcr) != 0)\n\t\tpr_err(\"Error Communicating to TPM chip\\n\");\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic void __init ima_pcrread(int idx, u8 *pcr)\n{\n\tif (!ima_used_chip)\n\t\treturn;\n\n\tif (tpm_pcr_read(TPM_ANY_NUM, idx, pcr) != 0)\n\t\tpr_err(\"Error Communicating to TPM chip\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "shash"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHASH_DESC_ON_STACK",
          "args": [
            "shash",
            "tfm"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int __init ima_calc_boot_aggregate_tfm(char *digest,\n\t\t\t\t\t      struct crypto_shash *tfm)\n{\n\tu8 pcr_i[TPM_DIGEST_SIZE];\n\tint rc, i;\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\t/* cumulative sha1 over tpm registers 0-7 */\n\tfor (i = TPM_PCR0; i < TPM_PCR8; i++) {\n\t\tima_pcrread(i, pcr_i);\n\t\t/* now accumulate with current aggregate */\n\t\trc = crypto_shash_update(shash, pcr_i, TPM_DIGEST_SIZE);\n\t}\n\tif (!rc)\n\t\tcrypto_shash_final(shash, digest);\n\treturn rc;\n}"
  },
  {
    "function_name": "ima_pcrread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "630-637",
    "snippet": "static void __init ima_pcrread(int idx, u8 *pcr)\n{\n\tif (!ima_used_chip)\n\t\treturn;\n\n\tif (tpm_pcr_read(TPM_ANY_NUM, idx, pcr) != 0)\n\t\tpr_err(\"Error Communicating to TPM chip\\n\");\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error Communicating to TPM chip\\n\""
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_pcr_read",
          "args": [
            "TPM_ANY_NUM",
            "idx",
            "pcr"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic void __init ima_pcrread(int idx, u8 *pcr)\n{\n\tif (!ima_used_chip)\n\t\treturn;\n\n\tif (tpm_pcr_read(TPM_ANY_NUM, idx, pcr) != 0)\n\t\tpr_err(\"Error Communicating to TPM chip\\n\");\n}"
  },
  {
    "function_name": "ima_calc_buffer_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "616-628",
    "snippet": "int ima_calc_buffer_hash(const void *buf, loff_t len,\n\t\t\t struct ima_digest_data *hash)\n{\n\tint rc;\n\n\tif (ima_ahash_minsize && len >= ima_ahash_minsize) {\n\t\trc = calc_buffer_ahash(buf, len, hash);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\treturn calc_buffer_shash(buf, len, hash);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ima_ahash_minsize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_buffer_shash",
          "args": [
            "buf",
            "len",
            "hash"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "calc_buffer_shash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "600-614",
          "snippet": "static int calc_buffer_shash(const void *buf, loff_t len,\n\t\t\t     struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = calc_buffer_shash_tfm(buf, len, hash, tfm);\n\n\tima_free_tfm(tfm);\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int calc_buffer_shash(const void *buf, loff_t len,\n\t\t\t     struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = calc_buffer_shash_tfm(buf, len, hash, tfm);\n\n\tima_free_tfm(tfm);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_buffer_ahash",
          "args": [
            "buf",
            "len",
            "hash"
          ],
          "line": 622
        },
        "resolved": true,
        "details": {
          "function_name": "calc_buffer_ahash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "552-567",
          "snippet": "static int calc_buffer_ahash(const void *buf, loff_t len,\n\t\t\t     struct ima_digest_data *hash)\n{\n\tstruct crypto_ahash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_atfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = calc_buffer_ahash_atfm(buf, len, hash, tfm);\n\n\tima_free_atfm(tfm);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int calc_buffer_ahash(const void *buf, loff_t len,\n\t\t\t     struct ima_digest_data *hash)\n{\n\tstruct crypto_ahash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_atfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = calc_buffer_ahash_atfm(buf, len, hash, tfm);\n\n\tima_free_atfm(tfm);\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic unsigned long ima_ahash_minsize;\n\nint ima_calc_buffer_hash(const void *buf, loff_t len,\n\t\t\t struct ima_digest_data *hash)\n{\n\tint rc;\n\n\tif (ima_ahash_minsize && len >= ima_ahash_minsize) {\n\t\trc = calc_buffer_ahash(buf, len, hash);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\treturn calc_buffer_shash(buf, len, hash);\n}"
  },
  {
    "function_name": "calc_buffer_shash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "600-614",
    "snippet": "static int calc_buffer_shash(const void *buf, loff_t len,\n\t\t\t     struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = calc_buffer_shash_tfm(buf, len, hash, tfm);\n\n\tima_free_tfm(tfm);\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_free_tfm",
          "args": [
            "tfm"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "98-102",
          "snippet": "static void ima_free_tfm(struct crypto_shash *tfm)\n{\n\tif (tfm != ima_shash_tfm)\n\t\tcrypto_free_shash(tfm);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *ima_shash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_shash *ima_shash_tfm;\n\nstatic void ima_free_tfm(struct crypto_shash *tfm)\n{\n\tif (tfm != ima_shash_tfm)\n\t\tcrypto_free_shash(tfm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_buffer_shash_tfm",
          "args": [
            "buf",
            "len",
            "hash",
            "tfm"
          ],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "calc_buffer_shash_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "569-598",
          "snippet": "static int calc_buffer_shash_tfm(const void *buf, loff_t size,\n\t\t\t\tstruct ima_digest_data *hash,\n\t\t\t\tstruct crypto_shash *tfm)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tunsigned int len;\n\tint rc;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\twhile (size) {\n\t\tlen = size < PAGE_SIZE ? size : PAGE_SIZE;\n\t\trc = crypto_shash_update(shash, buf, len);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tbuf += len;\n\t\tsize -= len;\n\t}\n\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int calc_buffer_shash_tfm(const void *buf, loff_t size,\n\t\t\t\tstruct ima_digest_data *hash,\n\t\t\t\tstruct crypto_shash *tfm)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tunsigned int len;\n\tint rc;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\twhile (size) {\n\t\tlen = size < PAGE_SIZE ? size : PAGE_SIZE;\n\t\trc = crypto_shash_update(shash, buf, len);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tbuf += len;\n\t\tsize -= len;\n\t}\n\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_alloc_tfm",
          "args": [
            "hash->algo"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "ima_alloc_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "79-96",
          "snippet": "static struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\n{\n\tstruct crypto_shash *tfm = ima_shash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo) {\n\t\ttfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *ima_shash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_shash *ima_shash_tfm;\n\nstatic struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\n{\n\tstruct crypto_shash *tfm = ima_shash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo) {\n\t\ttfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int calc_buffer_shash(const void *buf, loff_t len,\n\t\t\t     struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = calc_buffer_shash_tfm(buf, len, hash, tfm);\n\n\tima_free_tfm(tfm);\n\treturn rc;\n}"
  },
  {
    "function_name": "calc_buffer_shash_tfm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "569-598",
    "snippet": "static int calc_buffer_shash_tfm(const void *buf, loff_t size,\n\t\t\t\tstruct ima_digest_data *hash,\n\t\t\t\tstruct crypto_shash *tfm)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tunsigned int len;\n\tint rc;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\twhile (size) {\n\t\tlen = size < PAGE_SIZE ? size : PAGE_SIZE;\n\t\trc = crypto_shash_update(shash, buf, len);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tbuf += len;\n\t\tsize -= len;\n\t}\n\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "shash",
            "hash->digest"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "shash",
            "buf",
            "len"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "shash"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_digestsize",
          "args": [
            "tfm"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHASH_DESC_ON_STACK",
          "args": [
            "shash",
            "tfm"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int calc_buffer_shash_tfm(const void *buf, loff_t size,\n\t\t\t\tstruct ima_digest_data *hash,\n\t\t\t\tstruct crypto_shash *tfm)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tunsigned int len;\n\tint rc;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\twhile (size) {\n\t\tlen = size < PAGE_SIZE ? size : PAGE_SIZE;\n\t\trc = crypto_shash_update(shash, buf, len);\n\t\tif (rc)\n\t\t\tbreak;\n\t\tbuf += len;\n\t\tsize -= len;\n\t}\n\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\treturn rc;\n}"
  },
  {
    "function_name": "calc_buffer_ahash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "552-567",
    "snippet": "static int calc_buffer_ahash(const void *buf, loff_t len,\n\t\t\t     struct ima_digest_data *hash)\n{\n\tstruct crypto_ahash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_atfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = calc_buffer_ahash_atfm(buf, len, hash, tfm);\n\n\tima_free_atfm(tfm);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_free_atfm",
          "args": [
            "tfm"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_atfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "188-192",
          "snippet": "static void ima_free_atfm(struct crypto_ahash *tfm)\n{\n\tif (tfm != ima_ahash_tfm)\n\t\tcrypto_free_ahash(tfm);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_ahash *ima_ahash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_ahash *ima_ahash_tfm;\n\nstatic void ima_free_atfm(struct crypto_ahash *tfm)\n{\n\tif (tfm != ima_ahash_tfm)\n\t\tcrypto_free_ahash(tfm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_buffer_ahash_atfm",
          "args": [
            "buf",
            "len",
            "hash",
            "tfm"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "calc_buffer_ahash_atfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "512-550",
          "snippet": "static int calc_buffer_ahash_atfm(const void *buf, loff_t len,\n\t\t\t\t  struct ima_digest_data *hash,\n\t\t\t\t  struct crypto_ahash *tfm)\n{\n\tstruct ahash_request *req;\n\tstruct scatterlist sg;\n\tstruct crypto_wait wait;\n\tint rc, ahash_rc = 0;\n\n\thash->length = crypto_ahash_digestsize(tfm);\n\n\treq = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t   CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   crypto_req_done, &wait);\n\n\trc = ahash_wait(crypto_ahash_init(req), &wait);\n\tif (rc)\n\t\tgoto out;\n\n\tsg_init_one(&sg, buf, len);\n\tahash_request_set_crypt(req, &sg, NULL, len);\n\n\tahash_rc = crypto_ahash_update(req);\n\n\t/* wait for the update request to complete */\n\trc = ahash_wait(ahash_rc, &wait);\n\tif (!rc) {\n\t\tahash_request_set_crypt(req, NULL, hash->digest, 0);\n\t\trc = ahash_wait(crypto_ahash_final(req), &wait);\n\t}\nout:\n\tahash_request_free(req);\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int calc_buffer_ahash_atfm(const void *buf, loff_t len,\n\t\t\t\t  struct ima_digest_data *hash,\n\t\t\t\t  struct crypto_ahash *tfm)\n{\n\tstruct ahash_request *req;\n\tstruct scatterlist sg;\n\tstruct crypto_wait wait;\n\tint rc, ahash_rc = 0;\n\n\thash->length = crypto_ahash_digestsize(tfm);\n\n\treq = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t   CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   crypto_req_done, &wait);\n\n\trc = ahash_wait(crypto_ahash_init(req), &wait);\n\tif (rc)\n\t\tgoto out;\n\n\tsg_init_one(&sg, buf, len);\n\tahash_request_set_crypt(req, &sg, NULL, len);\n\n\tahash_rc = crypto_ahash_update(req);\n\n\t/* wait for the update request to complete */\n\trc = ahash_wait(ahash_rc, &wait);\n\tif (!rc) {\n\t\tahash_request_set_crypt(req, NULL, hash->digest, 0);\n\t\trc = ahash_wait(crypto_ahash_final(req), &wait);\n\t}\nout:\n\tahash_request_free(req);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_alloc_atfm",
          "args": [
            "hash->algo"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "ima_alloc_atfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "166-186",
          "snippet": "static struct crypto_ahash *ima_alloc_atfm(enum hash_algo algo)\n{\n\tstruct crypto_ahash *tfm = ima_ahash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo || !tfm) {\n\t\ttfm = crypto_alloc_ahash(hash_algo_name[algo], 0, 0);\n\t\tif (!IS_ERR(tfm)) {\n\t\t\tif (algo == ima_hash_algo)\n\t\t\t\tima_ahash_tfm = tfm;\n\t\t} else {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_ahash *ima_ahash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_ahash *ima_ahash_tfm;\n\nstatic struct crypto_ahash *ima_alloc_atfm(enum hash_algo algo)\n{\n\tstruct crypto_ahash *tfm = ima_ahash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo || !tfm) {\n\t\ttfm = crypto_alloc_ahash(hash_algo_name[algo], 0, 0);\n\t\tif (!IS_ERR(tfm)) {\n\t\t\tif (algo == ima_hash_algo)\n\t\t\t\tima_ahash_tfm = tfm;\n\t\t} else {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int calc_buffer_ahash(const void *buf, loff_t len,\n\t\t\t     struct ima_digest_data *hash)\n{\n\tstruct crypto_ahash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_atfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = calc_buffer_ahash_atfm(buf, len, hash, tfm);\n\n\tima_free_atfm(tfm);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "calc_buffer_ahash_atfm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "512-550",
    "snippet": "static int calc_buffer_ahash_atfm(const void *buf, loff_t len,\n\t\t\t\t  struct ima_digest_data *hash,\n\t\t\t\t  struct crypto_ahash *tfm)\n{\n\tstruct ahash_request *req;\n\tstruct scatterlist sg;\n\tstruct crypto_wait wait;\n\tint rc, ahash_rc = 0;\n\n\thash->length = crypto_ahash_digestsize(tfm);\n\n\treq = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t   CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   crypto_req_done, &wait);\n\n\trc = ahash_wait(crypto_ahash_init(req), &wait);\n\tif (rc)\n\t\tgoto out;\n\n\tsg_init_one(&sg, buf, len);\n\tahash_request_set_crypt(req, &sg, NULL, len);\n\n\tahash_rc = crypto_ahash_update(req);\n\n\t/* wait for the update request to complete */\n\trc = ahash_wait(ahash_rc, &wait);\n\tif (!rc) {\n\t\tahash_request_set_crypt(req, NULL, hash->digest, 0);\n\t\trc = ahash_wait(crypto_ahash_final(req), &wait);\n\t}\nout:\n\tahash_request_free(req);\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahash_request_free",
          "args": [
            "req"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahash_wait",
          "args": [
            "crypto_ahash_final(req)",
            "&wait"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "ahash_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "194-203",
          "snippet": "static inline int ahash_wait(int err, struct crypto_wait *wait)\n{\n\n\terr = crypto_wait_req(err, wait);\n\n\tif (err)\n\t\tpr_crit_ratelimited(\"ahash calculation failed: err: %d\\n\", err);\n\n\treturn err;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic inline int ahash_wait(int err, struct crypto_wait *wait)\n{\n\n\terr = crypto_wait_req(err, wait);\n\n\tif (err)\n\t\tpr_crit_ratelimited(\"ahash calculation failed: err: %d\\n\", err);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_ahash_final",
          "args": [
            "req"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahash_request_set_crypt",
          "args": [
            "req",
            "NULL",
            "hash->digest",
            "0"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_ahash_update",
          "args": [
            "req"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahash_request_set_crypt",
          "args": [
            "req",
            "&sg",
            "NULL",
            "len"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_one",
          "args": [
            "&sg",
            "buf",
            "len"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_ahash_init",
          "args": [
            "req"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahash_request_set_callback",
          "args": [
            "req",
            "CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t   CRYPTO_TFM_REQ_MAY_SLEEP",
            "crypto_req_done",
            "&wait"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_init_wait",
          "args": [
            "&wait"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahash_request_alloc",
          "args": [
            "tfm",
            "GFP_KERNEL"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_ahash_digestsize",
          "args": [
            "tfm"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int calc_buffer_ahash_atfm(const void *buf, loff_t len,\n\t\t\t\t  struct ima_digest_data *hash,\n\t\t\t\t  struct crypto_ahash *tfm)\n{\n\tstruct ahash_request *req;\n\tstruct scatterlist sg;\n\tstruct crypto_wait wait;\n\tint rc, ahash_rc = 0;\n\n\thash->length = crypto_ahash_digestsize(tfm);\n\n\treq = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t   CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   crypto_req_done, &wait);\n\n\trc = ahash_wait(crypto_ahash_init(req), &wait);\n\tif (rc)\n\t\tgoto out;\n\n\tsg_init_one(&sg, buf, len);\n\tahash_request_set_crypt(req, &sg, NULL, len);\n\n\tahash_rc = crypto_ahash_update(req);\n\n\t/* wait for the update request to complete */\n\trc = ahash_wait(ahash_rc, &wait);\n\tif (!rc) {\n\t\tahash_request_set_crypt(req, NULL, hash->digest, 0);\n\t\trc = ahash_wait(crypto_ahash_final(req), &wait);\n\t}\nout:\n\tahash_request_free(req);\n\treturn rc;\n}"
  },
  {
    "function_name": "ima_calc_field_array_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "493-510",
    "snippet": "int ima_calc_field_array_hash(struct ima_field_data *field_data,\n\t\t\t      struct ima_template_desc *desc, int num_fields,\n\t\t\t      struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_field_array_hash_tfm(field_data, desc, num_fields,\n\t\t\t\t\t   hash, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_free_tfm",
          "args": [
            "tfm"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "98-102",
          "snippet": "static void ima_free_tfm(struct crypto_shash *tfm)\n{\n\tif (tfm != ima_shash_tfm)\n\t\tcrypto_free_shash(tfm);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *ima_shash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_shash *ima_shash_tfm;\n\nstatic void ima_free_tfm(struct crypto_shash *tfm)\n{\n\tif (tfm != ima_shash_tfm)\n\t\tcrypto_free_shash(tfm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_calc_field_array_hash_tfm",
          "args": [
            "field_data",
            "desc",
            "num_fields",
            "hash",
            "tfm"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "ima_calc_field_array_hash_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "446-491",
          "snippet": "static int ima_calc_field_array_hash_tfm(struct ima_field_data *field_data,\n\t\t\t\t\t struct ima_template_desc *td,\n\t\t\t\t\t int num_fields,\n\t\t\t\t\t struct ima_digest_data *hash,\n\t\t\t\t\t struct crypto_shash *tfm)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tint rc, i;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tfor (i = 0; i < num_fields; i++) {\n\t\tu8 buffer[IMA_EVENT_NAME_LEN_MAX + 1] = { 0 };\n\t\tu8 *data_to_hash = field_data[i].data;\n\t\tu32 datalen = field_data[i].len;\n\t\tu32 datalen_to_hash =\n\t\t    !ima_canonical_fmt ? datalen : cpu_to_le32(datalen);\n\n\t\tif (strcmp(td->name, IMA_TEMPLATE_IMA_NAME) != 0) {\n\t\t\trc = crypto_shash_update(shash,\n\t\t\t\t\t\t(const u8 *) &datalen_to_hash,\n\t\t\t\t\t\tsizeof(datalen_to_hash));\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t} else if (strcmp(td->fields[i]->field_id, \"n\") == 0) {\n\t\t\tmemcpy(buffer, data_to_hash, datalen);\n\t\t\tdata_to_hash = buffer;\n\t\t\tdatalen = IMA_EVENT_NAME_LEN_MAX + 1;\n\t\t}\n\t\trc = crypto_shash_update(shash, data_to_hash, datalen);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_calc_field_array_hash_tfm(struct ima_field_data *field_data,\n\t\t\t\t\t struct ima_template_desc *td,\n\t\t\t\t\t int num_fields,\n\t\t\t\t\t struct ima_digest_data *hash,\n\t\t\t\t\t struct crypto_shash *tfm)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tint rc, i;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tfor (i = 0; i < num_fields; i++) {\n\t\tu8 buffer[IMA_EVENT_NAME_LEN_MAX + 1] = { 0 };\n\t\tu8 *data_to_hash = field_data[i].data;\n\t\tu32 datalen = field_data[i].len;\n\t\tu32 datalen_to_hash =\n\t\t    !ima_canonical_fmt ? datalen : cpu_to_le32(datalen);\n\n\t\tif (strcmp(td->name, IMA_TEMPLATE_IMA_NAME) != 0) {\n\t\t\trc = crypto_shash_update(shash,\n\t\t\t\t\t\t(const u8 *) &datalen_to_hash,\n\t\t\t\t\t\tsizeof(datalen_to_hash));\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t} else if (strcmp(td->fields[i]->field_id, \"n\") == 0) {\n\t\t\tmemcpy(buffer, data_to_hash, datalen);\n\t\t\tdata_to_hash = buffer;\n\t\t\tdatalen = IMA_EVENT_NAME_LEN_MAX + 1;\n\t\t}\n\t\trc = crypto_shash_update(shash, data_to_hash, datalen);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_alloc_tfm",
          "args": [
            "hash->algo"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "ima_alloc_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "79-96",
          "snippet": "static struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\n{\n\tstruct crypto_shash *tfm = ima_shash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo) {\n\t\ttfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *ima_shash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_shash *ima_shash_tfm;\n\nstatic struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\n{\n\tstruct crypto_shash *tfm = ima_shash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo) {\n\t\ttfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nint ima_calc_field_array_hash(struct ima_field_data *field_data,\n\t\t\t      struct ima_template_desc *desc, int num_fields,\n\t\t\t      struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_field_array_hash_tfm(field_data, desc, num_fields,\n\t\t\t\t\t   hash, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ima_calc_field_array_hash_tfm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "446-491",
    "snippet": "static int ima_calc_field_array_hash_tfm(struct ima_field_data *field_data,\n\t\t\t\t\t struct ima_template_desc *td,\n\t\t\t\t\t int num_fields,\n\t\t\t\t\t struct ima_digest_data *hash,\n\t\t\t\t\t struct crypto_shash *tfm)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tint rc, i;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tfor (i = 0; i < num_fields; i++) {\n\t\tu8 buffer[IMA_EVENT_NAME_LEN_MAX + 1] = { 0 };\n\t\tu8 *data_to_hash = field_data[i].data;\n\t\tu32 datalen = field_data[i].len;\n\t\tu32 datalen_to_hash =\n\t\t    !ima_canonical_fmt ? datalen : cpu_to_le32(datalen);\n\n\t\tif (strcmp(td->name, IMA_TEMPLATE_IMA_NAME) != 0) {\n\t\t\trc = crypto_shash_update(shash,\n\t\t\t\t\t\t(const u8 *) &datalen_to_hash,\n\t\t\t\t\t\tsizeof(datalen_to_hash));\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t} else if (strcmp(td->fields[i]->field_id, \"n\") == 0) {\n\t\t\tmemcpy(buffer, data_to_hash, datalen);\n\t\t\tdata_to_hash = buffer;\n\t\t\tdatalen = IMA_EVENT_NAME_LEN_MAX + 1;\n\t\t}\n\t\trc = crypto_shash_update(shash, data_to_hash, datalen);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "shash",
            "hash->digest"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "shash",
            "data_to_hash",
            "datalen"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buffer",
            "data_to_hash",
            "datalen"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "td->fields[i]->field_id",
            "\"n\""
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "shash",
            "(const u8 *) &datalen_to_hash",
            "sizeof(datalen_to_hash)"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "td->name",
            "IMA_TEMPLATE_IMA_NAME"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "datalen"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "shash"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_digestsize",
          "args": [
            "tfm"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHASH_DESC_ON_STACK",
          "args": [
            "shash",
            "tfm"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_calc_field_array_hash_tfm(struct ima_field_data *field_data,\n\t\t\t\t\t struct ima_template_desc *td,\n\t\t\t\t\t int num_fields,\n\t\t\t\t\t struct ima_digest_data *hash,\n\t\t\t\t\t struct crypto_shash *tfm)\n{\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\tint rc, i;\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tfor (i = 0; i < num_fields; i++) {\n\t\tu8 buffer[IMA_EVENT_NAME_LEN_MAX + 1] = { 0 };\n\t\tu8 *data_to_hash = field_data[i].data;\n\t\tu32 datalen = field_data[i].len;\n\t\tu32 datalen_to_hash =\n\t\t    !ima_canonical_fmt ? datalen : cpu_to_le32(datalen);\n\n\t\tif (strcmp(td->name, IMA_TEMPLATE_IMA_NAME) != 0) {\n\t\t\trc = crypto_shash_update(shash,\n\t\t\t\t\t\t(const u8 *) &datalen_to_hash,\n\t\t\t\t\t\tsizeof(datalen_to_hash));\n\t\t\tif (rc)\n\t\t\t\tbreak;\n\t\t} else if (strcmp(td->fields[i]->field_id, \"n\") == 0) {\n\t\t\tmemcpy(buffer, data_to_hash, datalen);\n\t\t\tdata_to_hash = buffer;\n\t\t\tdatalen = IMA_EVENT_NAME_LEN_MAX + 1;\n\t\t}\n\t\trc = crypto_shash_update(shash, data_to_hash, datalen);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ima_calc_file_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "417-441",
    "snippet": "int ima_calc_file_hash(struct file *file, struct ima_digest_data *hash)\n{\n\tloff_t i_size;\n\tint rc;\n\n\t/*\n\t * For consistency, fail file's opened with the O_DIRECT flag on\n\t * filesystems mounted with/without DAX option.\n\t */\n\tif (file->f_flags & O_DIRECT) {\n\t\thash->length = hash_digest_size[ima_hash_algo];\n\t\thash->algo = ima_hash_algo;\n\t\treturn -EINVAL;\n\t}\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (ima_ahash_minsize && i_size >= ima_ahash_minsize) {\n\t\trc = ima_calc_file_ahash(file, hash);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\treturn ima_calc_file_shash(file, hash);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned long ima_ahash_minsize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_calc_file_shash",
          "args": [
            "file",
            "hash"
          ],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "ima_calc_file_shash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "388-402",
          "snippet": "static int ima_calc_file_shash(struct file *file, struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_file_hash_tfm(file, hash, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_calc_file_shash(struct file *file, struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_file_hash_tfm(file, hash, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_calc_file_ahash",
          "args": [
            "file",
            "hash"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "ima_calc_file_ahash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "315-329",
          "snippet": "static int ima_calc_file_ahash(struct file *file, struct ima_digest_data *hash)\n{\n\tstruct crypto_ahash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_atfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_file_hash_atfm(file, hash, tfm);\n\n\tima_free_atfm(tfm);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_calc_file_ahash(struct file *file, struct ima_digest_data *hash)\n{\n\tstruct crypto_ahash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_atfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_file_hash_atfm(file, hash, tfm);\n\n\tima_free_atfm(tfm);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "file_inode(file)"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic unsigned long ima_ahash_minsize;\n\nint ima_calc_file_hash(struct file *file, struct ima_digest_data *hash)\n{\n\tloff_t i_size;\n\tint rc;\n\n\t/*\n\t * For consistency, fail file's opened with the O_DIRECT flag on\n\t * filesystems mounted with/without DAX option.\n\t */\n\tif (file->f_flags & O_DIRECT) {\n\t\thash->length = hash_digest_size[ima_hash_algo];\n\t\thash->algo = ima_hash_algo;\n\t\treturn -EINVAL;\n\t}\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (ima_ahash_minsize && i_size >= ima_ahash_minsize) {\n\t\trc = ima_calc_file_ahash(file, hash);\n\t\tif (!rc)\n\t\t\treturn 0;\n\t}\n\n\treturn ima_calc_file_shash(file, hash);\n}"
  },
  {
    "function_name": "ima_calc_file_shash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "388-402",
    "snippet": "static int ima_calc_file_shash(struct file *file, struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_file_hash_tfm(file, hash, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_free_tfm",
          "args": [
            "tfm"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "98-102",
          "snippet": "static void ima_free_tfm(struct crypto_shash *tfm)\n{\n\tif (tfm != ima_shash_tfm)\n\t\tcrypto_free_shash(tfm);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *ima_shash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_shash *ima_shash_tfm;\n\nstatic void ima_free_tfm(struct crypto_shash *tfm)\n{\n\tif (tfm != ima_shash_tfm)\n\t\tcrypto_free_shash(tfm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_calc_file_hash_tfm",
          "args": [
            "file",
            "hash",
            "tfm"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "ima_calc_file_hash_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "331-386",
          "snippet": "static int ima_calc_file_hash_tfm(struct file *file,\n\t\t\t\t  struct ima_digest_data *hash,\n\t\t\t\t  struct crypto_shash *tfm)\n{\n\tloff_t i_size, offset = 0;\n\tchar *rbuf;\n\tint rc, read = 0;\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (i_size == 0)\n\t\tgoto out;\n\n\trbuf = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!rbuf)\n\t\treturn -ENOMEM;\n\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\tfile->f_mode |= FMODE_READ;\n\t\tread = 1;\n\t}\n\n\twhile (offset < i_size) {\n\t\tint rbuf_len;\n\n\t\trbuf_len = integrity_kernel_read(file, offset, rbuf, PAGE_SIZE);\n\t\tif (rbuf_len < 0) {\n\t\t\trc = rbuf_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (rbuf_len == 0)\n\t\t\tbreak;\n\t\toffset += rbuf_len;\n\n\t\trc = crypto_shash_update(shash, rbuf, rbuf_len);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\tif (read)\n\t\tfile->f_mode &= ~FMODE_READ;\n\tkfree(rbuf);\nout:\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_calc_file_hash_tfm(struct file *file,\n\t\t\t\t  struct ima_digest_data *hash,\n\t\t\t\t  struct crypto_shash *tfm)\n{\n\tloff_t i_size, offset = 0;\n\tchar *rbuf;\n\tint rc, read = 0;\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (i_size == 0)\n\t\tgoto out;\n\n\trbuf = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!rbuf)\n\t\treturn -ENOMEM;\n\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\tfile->f_mode |= FMODE_READ;\n\t\tread = 1;\n\t}\n\n\twhile (offset < i_size) {\n\t\tint rbuf_len;\n\n\t\trbuf_len = integrity_kernel_read(file, offset, rbuf, PAGE_SIZE);\n\t\tif (rbuf_len < 0) {\n\t\t\trc = rbuf_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (rbuf_len == 0)\n\t\t\tbreak;\n\t\toffset += rbuf_len;\n\n\t\trc = crypto_shash_update(shash, rbuf, rbuf_len);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\tif (read)\n\t\tfile->f_mode &= ~FMODE_READ;\n\tkfree(rbuf);\nout:\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_alloc_tfm",
          "args": [
            "hash->algo"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "ima_alloc_tfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "79-96",
          "snippet": "static struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\n{\n\tstruct crypto_shash *tfm = ima_shash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo) {\n\t\ttfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *ima_shash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_shash *ima_shash_tfm;\n\nstatic struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\n{\n\tstruct crypto_shash *tfm = ima_shash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo) {\n\t\ttfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_calc_file_shash(struct file *file, struct ima_digest_data *hash)\n{\n\tstruct crypto_shash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_tfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_file_hash_tfm(file, hash, tfm);\n\n\tima_free_tfm(tfm);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ima_calc_file_hash_tfm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "331-386",
    "snippet": "static int ima_calc_file_hash_tfm(struct file *file,\n\t\t\t\t  struct ima_digest_data *hash,\n\t\t\t\t  struct crypto_shash *tfm)\n{\n\tloff_t i_size, offset = 0;\n\tchar *rbuf;\n\tint rc, read = 0;\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (i_size == 0)\n\t\tgoto out;\n\n\trbuf = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!rbuf)\n\t\treturn -ENOMEM;\n\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\tfile->f_mode |= FMODE_READ;\n\t\tread = 1;\n\t}\n\n\twhile (offset < i_size) {\n\t\tint rbuf_len;\n\n\t\trbuf_len = integrity_kernel_read(file, offset, rbuf, PAGE_SIZE);\n\t\tif (rbuf_len < 0) {\n\t\t\trc = rbuf_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (rbuf_len == 0)\n\t\t\tbreak;\n\t\toffset += rbuf_len;\n\n\t\trc = crypto_shash_update(shash, rbuf, rbuf_len);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\tif (read)\n\t\tfile->f_mode &= ~FMODE_READ;\n\tkfree(rbuf);\nout:\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "shash",
            "hash->digest"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "rbuf"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "shash",
            "rbuf",
            "rbuf_len"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "integrity_kernel_read",
          "args": [
            "file",
            "offset",
            "rbuf",
            "PAGE_SIZE"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_kernel_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/iint.c",
          "lines": "184-200",
          "snippet": "int integrity_kernel_read(struct file *file, loff_t offset,\n\t\t\t  void *addr, unsigned long count)\n{\n\tmm_segment_t old_fs;\n\tchar __user *buf = (char __user *)addr;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tret = __vfs_read(file, buf, count, &offset);\n\tset_fs(old_fs);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint integrity_kernel_read(struct file *file, loff_t offset,\n\t\t\t  void *addr, unsigned long count)\n{\n\tmm_segment_t old_fs;\n\tchar __user *buf = (char __user *)addr;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tret = __vfs_read(file, buf, count, &offset);\n\tset_fs(old_fs);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "PAGE_SIZE",
            "GFP_KERNEL"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "file_inode(file)"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "shash"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_digestsize",
          "args": [
            "tfm"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHASH_DESC_ON_STACK",
          "args": [
            "shash",
            "tfm"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_calc_file_hash_tfm(struct file *file,\n\t\t\t\t  struct ima_digest_data *hash,\n\t\t\t\t  struct crypto_shash *tfm)\n{\n\tloff_t i_size, offset = 0;\n\tchar *rbuf;\n\tint rc, read = 0;\n\tSHASH_DESC_ON_STACK(shash, tfm);\n\n\tshash->tfm = tfm;\n\tshash->flags = 0;\n\n\thash->length = crypto_shash_digestsize(tfm);\n\n\trc = crypto_shash_init(shash);\n\tif (rc != 0)\n\t\treturn rc;\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (i_size == 0)\n\t\tgoto out;\n\n\trbuf = kzalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!rbuf)\n\t\treturn -ENOMEM;\n\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\tfile->f_mode |= FMODE_READ;\n\t\tread = 1;\n\t}\n\n\twhile (offset < i_size) {\n\t\tint rbuf_len;\n\n\t\trbuf_len = integrity_kernel_read(file, offset, rbuf, PAGE_SIZE);\n\t\tif (rbuf_len < 0) {\n\t\t\trc = rbuf_len;\n\t\t\tbreak;\n\t\t}\n\t\tif (rbuf_len == 0)\n\t\t\tbreak;\n\t\toffset += rbuf_len;\n\n\t\trc = crypto_shash_update(shash, rbuf, rbuf_len);\n\t\tif (rc)\n\t\t\tbreak;\n\t}\n\tif (read)\n\t\tfile->f_mode &= ~FMODE_READ;\n\tkfree(rbuf);\nout:\n\tif (!rc)\n\t\trc = crypto_shash_final(shash, hash->digest);\n\treturn rc;\n}"
  },
  {
    "function_name": "ima_calc_file_ahash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "315-329",
    "snippet": "static int ima_calc_file_ahash(struct file *file, struct ima_digest_data *hash)\n{\n\tstruct crypto_ahash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_atfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_file_hash_atfm(file, hash, tfm);\n\n\tima_free_atfm(tfm);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_free_atfm",
          "args": [
            "tfm"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_atfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "188-192",
          "snippet": "static void ima_free_atfm(struct crypto_ahash *tfm)\n{\n\tif (tfm != ima_ahash_tfm)\n\t\tcrypto_free_ahash(tfm);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_ahash *ima_ahash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_ahash *ima_ahash_tfm;\n\nstatic void ima_free_atfm(struct crypto_ahash *tfm)\n{\n\tif (tfm != ima_ahash_tfm)\n\t\tcrypto_free_ahash(tfm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_calc_file_hash_atfm",
          "args": [
            "file",
            "hash",
            "tfm"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "ima_calc_file_hash_atfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "205-313",
          "snippet": "static int ima_calc_file_hash_atfm(struct file *file,\n\t\t\t\t   struct ima_digest_data *hash,\n\t\t\t\t   struct crypto_ahash *tfm)\n{\n\tloff_t i_size, offset;\n\tchar *rbuf[2] = { NULL, };\n\tint rc, read = 0, rbuf_len, active = 0, ahash_rc = 0;\n\tstruct ahash_request *req;\n\tstruct scatterlist sg[1];\n\tstruct crypto_wait wait;\n\tsize_t rbuf_size[2];\n\n\thash->length = crypto_ahash_digestsize(tfm);\n\n\treq = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t   CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   crypto_req_done, &wait);\n\n\trc = ahash_wait(crypto_ahash_init(req), &wait);\n\tif (rc)\n\t\tgoto out1;\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (i_size == 0)\n\t\tgoto out2;\n\n\t/*\n\t * Try to allocate maximum size of memory.\n\t * Fail if even a single page cannot be allocated.\n\t */\n\trbuf[0] = ima_alloc_pages(i_size, &rbuf_size[0], 1);\n\tif (!rbuf[0]) {\n\t\trc = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t/* Only allocate one buffer if that is enough. */\n\tif (i_size > rbuf_size[0]) {\n\t\t/*\n\t\t * Try to allocate secondary buffer. If that fails fallback to\n\t\t * using single buffering. Use previous memory allocation size\n\t\t * as baseline for possible allocation size.\n\t\t */\n\t\trbuf[1] = ima_alloc_pages(i_size - rbuf_size[0],\n\t\t\t\t\t  &rbuf_size[1], 0);\n\t}\n\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\tfile->f_mode |= FMODE_READ;\n\t\tread = 1;\n\t}\n\n\tfor (offset = 0; offset < i_size; offset += rbuf_len) {\n\t\tif (!rbuf[1] && offset) {\n\t\t\t/* Not using two buffers, and it is not the first\n\t\t\t * read/request, wait for the completion of the\n\t\t\t * previous ahash_update() request.\n\t\t\t */\n\t\t\trc = ahash_wait(ahash_rc, &wait);\n\t\t\tif (rc)\n\t\t\t\tgoto out3;\n\t\t}\n\t\t/* read buffer */\n\t\trbuf_len = min_t(loff_t, i_size - offset, rbuf_size[active]);\n\t\trc = integrity_kernel_read(file, offset, rbuf[active],\n\t\t\t\t\t   rbuf_len);\n\t\tif (rc != rbuf_len)\n\t\t\tgoto out3;\n\n\t\tif (rbuf[1] && offset) {\n\t\t\t/* Using two buffers, and it is not the first\n\t\t\t * read/request, wait for the completion of the\n\t\t\t * previous ahash_update() request.\n\t\t\t */\n\t\t\trc = ahash_wait(ahash_rc, &wait);\n\t\t\tif (rc)\n\t\t\t\tgoto out3;\n\t\t}\n\n\t\tsg_init_one(&sg[0], rbuf[active], rbuf_len);\n\t\tahash_request_set_crypt(req, sg, NULL, rbuf_len);\n\n\t\tahash_rc = crypto_ahash_update(req);\n\n\t\tif (rbuf[1])\n\t\t\tactive = !active; /* swap buffers, if we use two */\n\t}\n\t/* wait for the last update request to complete */\n\trc = ahash_wait(ahash_rc, &wait);\nout3:\n\tif (read)\n\t\tfile->f_mode &= ~FMODE_READ;\n\tima_free_pages(rbuf[0], rbuf_size[0]);\n\tima_free_pages(rbuf[1], rbuf_size[1]);\nout2:\n\tif (!rc) {\n\t\tahash_request_set_crypt(req, NULL, hash->digest, 0);\n\t\trc = ahash_wait(crypto_ahash_final(req), &wait);\n\t}\nout1:\n\tahash_request_free(req);\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_calc_file_hash_atfm(struct file *file,\n\t\t\t\t   struct ima_digest_data *hash,\n\t\t\t\t   struct crypto_ahash *tfm)\n{\n\tloff_t i_size, offset;\n\tchar *rbuf[2] = { NULL, };\n\tint rc, read = 0, rbuf_len, active = 0, ahash_rc = 0;\n\tstruct ahash_request *req;\n\tstruct scatterlist sg[1];\n\tstruct crypto_wait wait;\n\tsize_t rbuf_size[2];\n\n\thash->length = crypto_ahash_digestsize(tfm);\n\n\treq = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t   CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   crypto_req_done, &wait);\n\n\trc = ahash_wait(crypto_ahash_init(req), &wait);\n\tif (rc)\n\t\tgoto out1;\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (i_size == 0)\n\t\tgoto out2;\n\n\t/*\n\t * Try to allocate maximum size of memory.\n\t * Fail if even a single page cannot be allocated.\n\t */\n\trbuf[0] = ima_alloc_pages(i_size, &rbuf_size[0], 1);\n\tif (!rbuf[0]) {\n\t\trc = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t/* Only allocate one buffer if that is enough. */\n\tif (i_size > rbuf_size[0]) {\n\t\t/*\n\t\t * Try to allocate secondary buffer. If that fails fallback to\n\t\t * using single buffering. Use previous memory allocation size\n\t\t * as baseline for possible allocation size.\n\t\t */\n\t\trbuf[1] = ima_alloc_pages(i_size - rbuf_size[0],\n\t\t\t\t\t  &rbuf_size[1], 0);\n\t}\n\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\tfile->f_mode |= FMODE_READ;\n\t\tread = 1;\n\t}\n\n\tfor (offset = 0; offset < i_size; offset += rbuf_len) {\n\t\tif (!rbuf[1] && offset) {\n\t\t\t/* Not using two buffers, and it is not the first\n\t\t\t * read/request, wait for the completion of the\n\t\t\t * previous ahash_update() request.\n\t\t\t */\n\t\t\trc = ahash_wait(ahash_rc, &wait);\n\t\t\tif (rc)\n\t\t\t\tgoto out3;\n\t\t}\n\t\t/* read buffer */\n\t\trbuf_len = min_t(loff_t, i_size - offset, rbuf_size[active]);\n\t\trc = integrity_kernel_read(file, offset, rbuf[active],\n\t\t\t\t\t   rbuf_len);\n\t\tif (rc != rbuf_len)\n\t\t\tgoto out3;\n\n\t\tif (rbuf[1] && offset) {\n\t\t\t/* Using two buffers, and it is not the first\n\t\t\t * read/request, wait for the completion of the\n\t\t\t * previous ahash_update() request.\n\t\t\t */\n\t\t\trc = ahash_wait(ahash_rc, &wait);\n\t\t\tif (rc)\n\t\t\t\tgoto out3;\n\t\t}\n\n\t\tsg_init_one(&sg[0], rbuf[active], rbuf_len);\n\t\tahash_request_set_crypt(req, sg, NULL, rbuf_len);\n\n\t\tahash_rc = crypto_ahash_update(req);\n\n\t\tif (rbuf[1])\n\t\t\tactive = !active; /* swap buffers, if we use two */\n\t}\n\t/* wait for the last update request to complete */\n\trc = ahash_wait(ahash_rc, &wait);\nout3:\n\tif (read)\n\t\tfile->f_mode &= ~FMODE_READ;\n\tima_free_pages(rbuf[0], rbuf_size[0]);\n\tima_free_pages(rbuf[1], rbuf_size[1]);\nout2:\n\tif (!rc) {\n\t\tahash_request_set_crypt(req, NULL, hash->digest, 0);\n\t\trc = ahash_wait(crypto_ahash_final(req), &wait);\n\t}\nout1:\n\tahash_request_free(req);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_alloc_atfm",
          "args": [
            "hash->algo"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "ima_alloc_atfm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "166-186",
          "snippet": "static struct crypto_ahash *ima_alloc_atfm(enum hash_algo algo)\n{\n\tstruct crypto_ahash *tfm = ima_ahash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo || !tfm) {\n\t\ttfm = crypto_alloc_ahash(hash_algo_name[algo], 0, 0);\n\t\tif (!IS_ERR(tfm)) {\n\t\t\tif (algo == ima_hash_algo)\n\t\t\t\tima_ahash_tfm = tfm;\n\t\t} else {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_ahash *ima_ahash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_ahash *ima_ahash_tfm;\n\nstatic struct crypto_ahash *ima_alloc_atfm(enum hash_algo algo)\n{\n\tstruct crypto_ahash *tfm = ima_ahash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo || !tfm) {\n\t\ttfm = crypto_alloc_ahash(hash_algo_name[algo], 0, 0);\n\t\tif (!IS_ERR(tfm)) {\n\t\t\tif (algo == ima_hash_algo)\n\t\t\t\tima_ahash_tfm = tfm;\n\t\t} else {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_calc_file_ahash(struct file *file, struct ima_digest_data *hash)\n{\n\tstruct crypto_ahash *tfm;\n\tint rc;\n\n\ttfm = ima_alloc_atfm(hash->algo);\n\tif (IS_ERR(tfm))\n\t\treturn PTR_ERR(tfm);\n\n\trc = ima_calc_file_hash_atfm(file, hash, tfm);\n\n\tima_free_atfm(tfm);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "ima_calc_file_hash_atfm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "205-313",
    "snippet": "static int ima_calc_file_hash_atfm(struct file *file,\n\t\t\t\t   struct ima_digest_data *hash,\n\t\t\t\t   struct crypto_ahash *tfm)\n{\n\tloff_t i_size, offset;\n\tchar *rbuf[2] = { NULL, };\n\tint rc, read = 0, rbuf_len, active = 0, ahash_rc = 0;\n\tstruct ahash_request *req;\n\tstruct scatterlist sg[1];\n\tstruct crypto_wait wait;\n\tsize_t rbuf_size[2];\n\n\thash->length = crypto_ahash_digestsize(tfm);\n\n\treq = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t   CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   crypto_req_done, &wait);\n\n\trc = ahash_wait(crypto_ahash_init(req), &wait);\n\tif (rc)\n\t\tgoto out1;\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (i_size == 0)\n\t\tgoto out2;\n\n\t/*\n\t * Try to allocate maximum size of memory.\n\t * Fail if even a single page cannot be allocated.\n\t */\n\trbuf[0] = ima_alloc_pages(i_size, &rbuf_size[0], 1);\n\tif (!rbuf[0]) {\n\t\trc = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t/* Only allocate one buffer if that is enough. */\n\tif (i_size > rbuf_size[0]) {\n\t\t/*\n\t\t * Try to allocate secondary buffer. If that fails fallback to\n\t\t * using single buffering. Use previous memory allocation size\n\t\t * as baseline for possible allocation size.\n\t\t */\n\t\trbuf[1] = ima_alloc_pages(i_size - rbuf_size[0],\n\t\t\t\t\t  &rbuf_size[1], 0);\n\t}\n\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\tfile->f_mode |= FMODE_READ;\n\t\tread = 1;\n\t}\n\n\tfor (offset = 0; offset < i_size; offset += rbuf_len) {\n\t\tif (!rbuf[1] && offset) {\n\t\t\t/* Not using two buffers, and it is not the first\n\t\t\t * read/request, wait for the completion of the\n\t\t\t * previous ahash_update() request.\n\t\t\t */\n\t\t\trc = ahash_wait(ahash_rc, &wait);\n\t\t\tif (rc)\n\t\t\t\tgoto out3;\n\t\t}\n\t\t/* read buffer */\n\t\trbuf_len = min_t(loff_t, i_size - offset, rbuf_size[active]);\n\t\trc = integrity_kernel_read(file, offset, rbuf[active],\n\t\t\t\t\t   rbuf_len);\n\t\tif (rc != rbuf_len)\n\t\t\tgoto out3;\n\n\t\tif (rbuf[1] && offset) {\n\t\t\t/* Using two buffers, and it is not the first\n\t\t\t * read/request, wait for the completion of the\n\t\t\t * previous ahash_update() request.\n\t\t\t */\n\t\t\trc = ahash_wait(ahash_rc, &wait);\n\t\t\tif (rc)\n\t\t\t\tgoto out3;\n\t\t}\n\n\t\tsg_init_one(&sg[0], rbuf[active], rbuf_len);\n\t\tahash_request_set_crypt(req, sg, NULL, rbuf_len);\n\n\t\tahash_rc = crypto_ahash_update(req);\n\n\t\tif (rbuf[1])\n\t\t\tactive = !active; /* swap buffers, if we use two */\n\t}\n\t/* wait for the last update request to complete */\n\trc = ahash_wait(ahash_rc, &wait);\nout3:\n\tif (read)\n\t\tfile->f_mode &= ~FMODE_READ;\n\tima_free_pages(rbuf[0], rbuf_size[0]);\n\tima_free_pages(rbuf[1], rbuf_size[1]);\nout2:\n\tif (!rc) {\n\t\tahash_request_set_crypt(req, NULL, hash->digest, 0);\n\t\trc = ahash_wait(crypto_ahash_final(req), &wait);\n\t}\nout1:\n\tahash_request_free(req);\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ahash_request_free",
          "args": [
            "req"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahash_wait",
          "args": [
            "crypto_ahash_final(req)",
            "&wait"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "ahash_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "194-203",
          "snippet": "static inline int ahash_wait(int err, struct crypto_wait *wait)\n{\n\n\terr = crypto_wait_req(err, wait);\n\n\tif (err)\n\t\tpr_crit_ratelimited(\"ahash calculation failed: err: %d\\n\", err);\n\n\treturn err;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic inline int ahash_wait(int err, struct crypto_wait *wait)\n{\n\n\terr = crypto_wait_req(err, wait);\n\n\tif (err)\n\t\tpr_crit_ratelimited(\"ahash calculation failed: err: %d\\n\", err);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_ahash_final",
          "args": [
            "req"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahash_request_set_crypt",
          "args": [
            "req",
            "NULL",
            "hash->digest",
            "0"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_free_pages",
          "args": [
            "rbuf[1]",
            "rbuf_size[1]"
          ],
          "line": 304
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "159-164",
          "snippet": "static void ima_free_pages(void *ptr, size_t size)\n{\n\tif (!ptr)\n\t\treturn;\n\tfree_pages((unsigned long)ptr, get_order(size));\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic void ima_free_pages(void *ptr, size_t size)\n{\n\tif (!ptr)\n\t\treturn;\n\tfree_pages((unsigned long)ptr, get_order(size));\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_ahash_update",
          "args": [
            "req"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahash_request_set_crypt",
          "args": [
            "req",
            "sg",
            "NULL",
            "rbuf_len"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_one",
          "args": [
            "&sg[0]",
            "rbuf[active]",
            "rbuf_len"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "integrity_kernel_read",
          "args": [
            "file",
            "offset",
            "rbuf[active]",
            "rbuf_len"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_kernel_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/iint.c",
          "lines": "184-200",
          "snippet": "int integrity_kernel_read(struct file *file, loff_t offset,\n\t\t\t  void *addr, unsigned long count)\n{\n\tmm_segment_t old_fs;\n\tchar __user *buf = (char __user *)addr;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tret = __vfs_read(file, buf, count, &offset);\n\tset_fs(old_fs);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint integrity_kernel_read(struct file *file, loff_t offset,\n\t\t\t  void *addr, unsigned long count)\n{\n\tmm_segment_t old_fs;\n\tchar __user *buf = (char __user *)addr;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tret = __vfs_read(file, buf, count, &offset);\n\tset_fs(old_fs);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "loff_t",
            "i_size - offset",
            "rbuf_size[active]"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_alloc_pages",
          "args": [
            "i_size - rbuf_size[0]",
            "&rbuf_size[1]",
            "0"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "ima_alloc_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "119-152",
          "snippet": "static void *ima_alloc_pages(loff_t max_size, size_t *allocated_size,\n\t\t\t     int last_warn)\n{\n\tvoid *ptr;\n\tint order = ima_maxorder;\n\tgfp_t gfp_mask = __GFP_RECLAIM | __GFP_NOWARN | __GFP_NORETRY;\n\n\tif (order)\n\t\torder = min(get_order(max_size), order);\n\n\tfor (; order; order--) {\n\t\tptr = (void *)__get_free_pages(gfp_mask, order);\n\t\tif (ptr) {\n\t\t\t*allocated_size = PAGE_SIZE << order;\n\t\t\treturn ptr;\n\t\t}\n\t}\n\n\t/* order is zero - one page */\n\n\tgfp_mask = GFP_KERNEL;\n\n\tif (!last_warn)\n\t\tgfp_mask |= __GFP_NOWARN;\n\n\tptr = (void *)__get_free_pages(gfp_mask, 0);\n\tif (ptr) {\n\t\t*allocated_size = PAGE_SIZE;\n\t\treturn ptr;\n\t}\n\n\t*allocated_size = 0;\n\treturn NULL;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <crypto/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/crypto.h>",
            "#include <linux/file.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ima_maxorder;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_maxorder;\n\nstatic void *ima_alloc_pages(loff_t max_size, size_t *allocated_size,\n\t\t\t     int last_warn)\n{\n\tvoid *ptr;\n\tint order = ima_maxorder;\n\tgfp_t gfp_mask = __GFP_RECLAIM | __GFP_NOWARN | __GFP_NORETRY;\n\n\tif (order)\n\t\torder = min(get_order(max_size), order);\n\n\tfor (; order; order--) {\n\t\tptr = (void *)__get_free_pages(gfp_mask, order);\n\t\tif (ptr) {\n\t\t\t*allocated_size = PAGE_SIZE << order;\n\t\t\treturn ptr;\n\t\t}\n\t}\n\n\t/* order is zero - one page */\n\n\tgfp_mask = GFP_KERNEL;\n\n\tif (!last_warn)\n\t\tgfp_mask |= __GFP_NOWARN;\n\n\tptr = (void *)__get_free_pages(gfp_mask, 0);\n\tif (ptr) {\n\t\t*allocated_size = PAGE_SIZE;\n\t\treturn ptr;\n\t}\n\n\t*allocated_size = 0;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "i_size_read",
          "args": [
            "file_inode(file)"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_ahash_init",
          "args": [
            "req"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahash_request_set_callback",
          "args": [
            "req",
            "CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t   CRYPTO_TFM_REQ_MAY_SLEEP",
            "crypto_req_done",
            "&wait"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_init_wait",
          "args": [
            "&wait"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ahash_request_alloc",
          "args": [
            "tfm",
            "GFP_KERNEL"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_ahash_digestsize",
          "args": [
            "tfm"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_calc_file_hash_atfm(struct file *file,\n\t\t\t\t   struct ima_digest_data *hash,\n\t\t\t\t   struct crypto_ahash *tfm)\n{\n\tloff_t i_size, offset;\n\tchar *rbuf[2] = { NULL, };\n\tint rc, read = 0, rbuf_len, active = 0, ahash_rc = 0;\n\tstruct ahash_request *req;\n\tstruct scatterlist sg[1];\n\tstruct crypto_wait wait;\n\tsize_t rbuf_size[2];\n\n\thash->length = crypto_ahash_digestsize(tfm);\n\n\treq = ahash_request_alloc(tfm, GFP_KERNEL);\n\tif (!req)\n\t\treturn -ENOMEM;\n\n\tcrypto_init_wait(&wait);\n\tahash_request_set_callback(req, CRYPTO_TFM_REQ_MAY_BACKLOG |\n\t\t\t\t   CRYPTO_TFM_REQ_MAY_SLEEP,\n\t\t\t\t   crypto_req_done, &wait);\n\n\trc = ahash_wait(crypto_ahash_init(req), &wait);\n\tif (rc)\n\t\tgoto out1;\n\n\ti_size = i_size_read(file_inode(file));\n\n\tif (i_size == 0)\n\t\tgoto out2;\n\n\t/*\n\t * Try to allocate maximum size of memory.\n\t * Fail if even a single page cannot be allocated.\n\t */\n\trbuf[0] = ima_alloc_pages(i_size, &rbuf_size[0], 1);\n\tif (!rbuf[0]) {\n\t\trc = -ENOMEM;\n\t\tgoto out1;\n\t}\n\n\t/* Only allocate one buffer if that is enough. */\n\tif (i_size > rbuf_size[0]) {\n\t\t/*\n\t\t * Try to allocate secondary buffer. If that fails fallback to\n\t\t * using single buffering. Use previous memory allocation size\n\t\t * as baseline for possible allocation size.\n\t\t */\n\t\trbuf[1] = ima_alloc_pages(i_size - rbuf_size[0],\n\t\t\t\t\t  &rbuf_size[1], 0);\n\t}\n\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\tfile->f_mode |= FMODE_READ;\n\t\tread = 1;\n\t}\n\n\tfor (offset = 0; offset < i_size; offset += rbuf_len) {\n\t\tif (!rbuf[1] && offset) {\n\t\t\t/* Not using two buffers, and it is not the first\n\t\t\t * read/request, wait for the completion of the\n\t\t\t * previous ahash_update() request.\n\t\t\t */\n\t\t\trc = ahash_wait(ahash_rc, &wait);\n\t\t\tif (rc)\n\t\t\t\tgoto out3;\n\t\t}\n\t\t/* read buffer */\n\t\trbuf_len = min_t(loff_t, i_size - offset, rbuf_size[active]);\n\t\trc = integrity_kernel_read(file, offset, rbuf[active],\n\t\t\t\t\t   rbuf_len);\n\t\tif (rc != rbuf_len)\n\t\t\tgoto out3;\n\n\t\tif (rbuf[1] && offset) {\n\t\t\t/* Using two buffers, and it is not the first\n\t\t\t * read/request, wait for the completion of the\n\t\t\t * previous ahash_update() request.\n\t\t\t */\n\t\t\trc = ahash_wait(ahash_rc, &wait);\n\t\t\tif (rc)\n\t\t\t\tgoto out3;\n\t\t}\n\n\t\tsg_init_one(&sg[0], rbuf[active], rbuf_len);\n\t\tahash_request_set_crypt(req, sg, NULL, rbuf_len);\n\n\t\tahash_rc = crypto_ahash_update(req);\n\n\t\tif (rbuf[1])\n\t\t\tactive = !active; /* swap buffers, if we use two */\n\t}\n\t/* wait for the last update request to complete */\n\trc = ahash_wait(ahash_rc, &wait);\nout3:\n\tif (read)\n\t\tfile->f_mode &= ~FMODE_READ;\n\tima_free_pages(rbuf[0], rbuf_size[0]);\n\tima_free_pages(rbuf[1], rbuf_size[1]);\nout2:\n\tif (!rc) {\n\t\tahash_request_set_crypt(req, NULL, hash->digest, 0);\n\t\trc = ahash_wait(crypto_ahash_final(req), &wait);\n\t}\nout1:\n\tahash_request_free(req);\n\treturn rc;\n}"
  },
  {
    "function_name": "ahash_wait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "194-203",
    "snippet": "static inline int ahash_wait(int err, struct crypto_wait *wait)\n{\n\n\terr = crypto_wait_req(err, wait);\n\n\tif (err)\n\t\tpr_crit_ratelimited(\"ahash calculation failed: err: %d\\n\", err);\n\n\treturn err;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_crit_ratelimited",
          "args": [
            "\"ahash calculation failed: err: %d\\n\"",
            "err"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_wait_req",
          "args": [
            "err",
            "wait"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic inline int ahash_wait(int err, struct crypto_wait *wait)\n{\n\n\terr = crypto_wait_req(err, wait);\n\n\tif (err)\n\t\tpr_crit_ratelimited(\"ahash calculation failed: err: %d\\n\", err);\n\n\treturn err;\n}"
  },
  {
    "function_name": "ima_free_atfm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "188-192",
    "snippet": "static void ima_free_atfm(struct crypto_ahash *tfm)\n{\n\tif (tfm != ima_ahash_tfm)\n\t\tcrypto_free_ahash(tfm);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct crypto_ahash *ima_ahash_tfm;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_ahash",
          "args": [
            "tfm"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_ahash *ima_ahash_tfm;\n\nstatic void ima_free_atfm(struct crypto_ahash *tfm)\n{\n\tif (tfm != ima_ahash_tfm)\n\t\tcrypto_free_ahash(tfm);\n}"
  },
  {
    "function_name": "ima_alloc_atfm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "166-186",
    "snippet": "static struct crypto_ahash *ima_alloc_atfm(enum hash_algo algo)\n{\n\tstruct crypto_ahash *tfm = ima_ahash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo || !tfm) {\n\t\ttfm = crypto_alloc_ahash(hash_algo_name[algo], 0, 0);\n\t\tif (!IS_ERR(tfm)) {\n\t\t\tif (algo == ima_hash_algo)\n\t\t\t\tima_ahash_tfm = tfm;\n\t\t} else {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct crypto_ahash *ima_ahash_tfm;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Can not allocate %s (reason: %d)\\n\"",
            "hash_algo_name[algo]",
            "rc"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_ahash",
          "args": [
            "hash_algo_name[algo]",
            "0",
            "0"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_ahash *ima_ahash_tfm;\n\nstatic struct crypto_ahash *ima_alloc_atfm(enum hash_algo algo)\n{\n\tstruct crypto_ahash *tfm = ima_ahash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo || !tfm) {\n\t\ttfm = crypto_alloc_ahash(hash_algo_name[algo], 0, 0);\n\t\tif (!IS_ERR(tfm)) {\n\t\t\tif (algo == ima_hash_algo)\n\t\t\t\tima_ahash_tfm = tfm;\n\t\t} else {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}"
  },
  {
    "function_name": "ima_free_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "159-164",
    "snippet": "static void ima_free_pages(void *ptr, size_t size)\n{\n\tif (!ptr)\n\t\treturn;\n\tfree_pages((unsigned long)ptr, get_order(size));\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_pages",
          "args": [
            "(unsigned long)ptr",
            "get_order(size)"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_pages",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
          "lines": "159-164",
          "snippet": "static void ima_free_pages(void *ptr, size_t size)\n{\n\tif (!ptr)\n\t\treturn;\n\tfree_pages((unsigned long)ptr, get_order(size));\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic void ima_free_pages(void *ptr, size_t size)\n{\n\tif (!ptr)\n\t\treturn;\n\tfree_pages((unsigned long)ptr, get_order(size));\n}"
  },
  {
    "function_name": "ima_alloc_pages",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "119-152",
    "snippet": "static void *ima_alloc_pages(loff_t max_size, size_t *allocated_size,\n\t\t\t     int last_warn)\n{\n\tvoid *ptr;\n\tint order = ima_maxorder;\n\tgfp_t gfp_mask = __GFP_RECLAIM | __GFP_NOWARN | __GFP_NORETRY;\n\n\tif (order)\n\t\torder = min(get_order(max_size), order);\n\n\tfor (; order; order--) {\n\t\tptr = (void *)__get_free_pages(gfp_mask, order);\n\t\tif (ptr) {\n\t\t\t*allocated_size = PAGE_SIZE << order;\n\t\t\treturn ptr;\n\t\t}\n\t}\n\n\t/* order is zero - one page */\n\n\tgfp_mask = GFP_KERNEL;\n\n\tif (!last_warn)\n\t\tgfp_mask |= __GFP_NOWARN;\n\n\tptr = (void *)__get_free_pages(gfp_mask, 0);\n\tif (ptr) {\n\t\t*allocated_size = PAGE_SIZE;\n\t\treturn ptr;\n\t}\n\n\t*allocated_size = 0;\n\treturn NULL;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ima_maxorder;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "gfp_mask",
            "0"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_free_pages",
          "args": [
            "gfp_mask",
            "order"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "get_order(max_size)",
            "order"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "set_majmin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/device_cgroup.c",
          "lines": "259-265",
          "snippet": "static void set_majmin(char *str, unsigned m)\n{\n\tif (m == ~0)\n\t\tstrcpy(str, \"*\");\n\telse\n\t\tsprintf(str, \"%u\", m);\n}",
          "includes": [
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/list.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/device_cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n#include <linux/list.h>\n#include <linux/ctype.h>\n#include <linux/cgroup.h>\n#include <linux/device_cgroup.h>\n\nstatic void set_majmin(char *str, unsigned m)\n{\n\tif (m == ~0)\n\t\tstrcpy(str, \"*\");\n\telse\n\t\tsprintf(str, \"%u\", m);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "max_size"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_maxorder;\n\nstatic void *ima_alloc_pages(loff_t max_size, size_t *allocated_size,\n\t\t\t     int last_warn)\n{\n\tvoid *ptr;\n\tint order = ima_maxorder;\n\tgfp_t gfp_mask = __GFP_RECLAIM | __GFP_NOWARN | __GFP_NORETRY;\n\n\tif (order)\n\t\torder = min(get_order(max_size), order);\n\n\tfor (; order; order--) {\n\t\tptr = (void *)__get_free_pages(gfp_mask, order);\n\t\tif (ptr) {\n\t\t\t*allocated_size = PAGE_SIZE << order;\n\t\t\treturn ptr;\n\t\t}\n\t}\n\n\t/* order is zero - one page */\n\n\tgfp_mask = GFP_KERNEL;\n\n\tif (!last_warn)\n\t\tgfp_mask |= __GFP_NOWARN;\n\n\tptr = (void *)__get_free_pages(gfp_mask, 0);\n\tif (ptr) {\n\t\t*allocated_size = PAGE_SIZE;\n\t\treturn ptr;\n\t}\n\n\t*allocated_size = 0;\n\treturn NULL;\n}"
  },
  {
    "function_name": "ima_free_tfm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "98-102",
    "snippet": "static void ima_free_tfm(struct crypto_shash *tfm)\n{\n\tif (tfm != ima_shash_tfm)\n\t\tcrypto_free_shash(tfm);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct crypto_shash *ima_shash_tfm;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "tfm"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_shash *ima_shash_tfm;\n\nstatic void ima_free_tfm(struct crypto_shash *tfm)\n{\n\tif (tfm != ima_shash_tfm)\n\t\tcrypto_free_shash(tfm);\n}"
  },
  {
    "function_name": "ima_alloc_tfm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "79-96",
    "snippet": "static struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\n{\n\tstruct crypto_shash *tfm = ima_shash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo) {\n\t\ttfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct crypto_shash *ima_shash_tfm;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Can not allocate %s (reason: %d)\\n\"",
            "hash_algo_name[algo]",
            "rc"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "hash_algo_name[algo]",
            "0",
            "0"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_shash *ima_shash_tfm;\n\nstatic struct crypto_shash *ima_alloc_tfm(enum hash_algo algo)\n{\n\tstruct crypto_shash *tfm = ima_shash_tfm;\n\tint rc;\n\n\tif (algo < 0 || algo >= HASH_ALGO__LAST)\n\t\talgo = ima_hash_algo;\n\n\tif (algo != ima_hash_algo) {\n\t\ttfm = crypto_alloc_shash(hash_algo_name[algo], 0, 0);\n\t\tif (IS_ERR(tfm)) {\n\t\t\trc = PTR_ERR(tfm);\n\t\t\tpr_err(\"Can not allocate %s (reason: %d)\\n\",\n\t\t\t       hash_algo_name[algo], rc);\n\t\t}\n\t}\n\treturn tfm;\n}"
  },
  {
    "function_name": "ima_init_crypto",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "65-77",
    "snippet": "int __init ima_init_crypto(void)\n{\n\tlong rc;\n\n\tima_shash_tfm = crypto_alloc_shash(hash_algo_name[ima_hash_algo], 0, 0);\n\tif (IS_ERR(ima_shash_tfm)) {\n\t\trc = PTR_ERR(ima_shash_tfm);\n\t\tpr_err(\"Can not allocate %s (reason: %ld)\\n\",\n\t\t       hash_algo_name[ima_hash_algo], rc);\n\t\treturn rc;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct crypto_shash *ima_shash_tfm;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Can not allocate %s (reason: %ld)\\n\"",
            "hash_algo_name[ima_hash_algo]",
            "rc"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ima_shash_tfm"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ima_shash_tfm"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "hash_algo_name[ima_hash_algo]",
            "0",
            "0"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic struct crypto_shash *ima_shash_tfm;\n\nint __init ima_init_crypto(void)\n{\n\tlong rc;\n\n\tima_shash_tfm = crypto_alloc_shash(hash_algo_name[ima_hash_algo], 0, 0);\n\tif (IS_ERR(ima_shash_tfm)) {\n\t\trc = PTR_ERR(ima_shash_tfm);\n\t\tpr_err(\"Can not allocate %s (reason: %ld)\\n\",\n\t\t       hash_algo_name[ima_hash_algo], rc);\n\t\treturn rc;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "param_set_bufsize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_crypto.c",
    "lines": "39-51",
    "snippet": "static int param_set_bufsize(const char *val, const struct kernel_param *kp)\n{\n\tunsigned long long size;\n\tint order;\n\n\tsize = memparse(val, NULL);\n\torder = get_order(size);\n\tif (order >= MAX_ORDER)\n\t\treturn -EINVAL;\n\tima_maxorder = order;\n\tima_bufsize = PAGE_SIZE << order;\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <crypto/hash.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/crypto.h>",
      "#include <linux/file.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int ima_maxorder;",
      "static unsigned int ima_bufsize = PAGE_SIZE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_order",
          "args": [
            "size"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memparse",
          "args": [
            "val",
            "NULL"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <crypto/hash.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/scatterlist.h>\n#include <linux/crypto.h>\n#include <linux/file.h>\n#include <linux/ratelimit.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n\nstatic int ima_maxorder;\nstatic unsigned int ima_bufsize = PAGE_SIZE;\n\nstatic int param_set_bufsize(const char *val, const struct kernel_param *kp)\n{\n\tunsigned long long size;\n\tint order;\n\n\tsize = memparse(val, NULL);\n\torder = get_order(size);\n\tif (order >= MAX_ORDER)\n\t\treturn -EINVAL;\n\tima_maxorder = order;\n\tima_bufsize = PAGE_SIZE << order;\n\treturn 0;\n}"
  }
]