[
  {
    "function_name": "sel_netif_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
    "lines": "276-289",
    "snippet": "static __init int sel_netif_init(void)\n{\n\tint i;\n\n\tif (!selinux_enabled)\n\t\treturn 0;\n\n\tfor (i = 0; i < SEL_NETIF_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&sel_netif_hash[i]);\n\n\tregister_netdevice_notifier(&sel_netif_netdev_notifier);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"netif.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define SEL_NETIF_HASH_SIZE\t64"
    ],
    "globals_used": [
      "static struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];",
      "static struct notifier_block sel_netif_netdev_notifier = {\n\t.notifier_call = sel_netif_netdev_notifier_handler,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_netdevice_notifier",
          "args": [
            "&sel_netif_netdev_notifier"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&sel_netif_hash[i]"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\n#define SEL_NETIF_HASH_SIZE\t64\n\nstatic struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];\nstatic struct notifier_block sel_netif_netdev_notifier = {\n\t.notifier_call = sel_netif_netdev_notifier_handler,\n};\n\nstatic __init int sel_netif_init(void)\n{\n\tint i;\n\n\tif (!selinux_enabled)\n\t\treturn 0;\n\n\tfor (i = 0; i < SEL_NETIF_HASH_SIZE; i++)\n\t\tINIT_LIST_HEAD(&sel_netif_hash[i]);\n\n\tregister_netdevice_notifier(&sel_netif_netdev_notifier);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sel_netif_netdev_notifier_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
    "lines": "261-270",
    "snippet": "static int sel_netif_netdev_notifier_handler(struct notifier_block *this,\n\t\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (event == NETDEV_DOWN)\n\t\tsel_netif_kill(dev_net(dev), dev->ifindex);\n\n\treturn NOTIFY_DONE;\n}",
    "includes": [
      "#include \"netif.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sel_netif_kill",
          "args": [
            "dev_net(dev)",
            "dev->ifindex"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netif_kill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
          "lines": "229-240",
          "snippet": "static void sel_netif_kill(const struct net *ns, int ifindex)\n{\n\tstruct sel_netif *netif;\n\n\trcu_read_lock();\n\tspin_lock_bh(&sel_netif_lock);\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (netif)\n\t\tsel_netif_destroy(netif);\n\tspin_unlock_bh(&sel_netif_lock);\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"netif.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sel_netif_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sel_netif_lock);\n\nstatic void sel_netif_kill(const struct net *ns, int ifindex)\n{\n\tstruct sel_netif *netif;\n\n\trcu_read_lock();\n\tspin_lock_bh(&sel_netif_lock);\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (netif)\n\t\tsel_netif_destroy(netif);\n\tspin_unlock_bh(&sel_netif_lock);\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "dev_net",
          "args": [
            "dev"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netdev_notifier_info_to_dev",
          "args": [
            "ptr"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic int sel_netif_netdev_notifier_handler(struct notifier_block *this,\n\t\t\t\t\t     unsigned long event, void *ptr)\n{\n\tstruct net_device *dev = netdev_notifier_info_to_dev(ptr);\n\n\tif (event == NETDEV_DOWN)\n\t\tsel_netif_kill(dev_net(dev), dev->ifindex);\n\n\treturn NOTIFY_DONE;\n}"
  },
  {
    "function_name": "sel_netif_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
    "lines": "249-259",
    "snippet": "void sel_netif_flush(void)\n{\n\tint idx;\n\tstruct sel_netif *netif;\n\n\tspin_lock_bh(&sel_netif_lock);\n\tfor (idx = 0; idx < SEL_NETIF_HASH_SIZE; idx++)\n\t\tlist_for_each_entry(netif, &sel_netif_hash[idx], list)\n\t\t\tsel_netif_destroy(netif);\n\tspin_unlock_bh(&sel_netif_lock);\n}",
    "includes": [
      "#include \"netif.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define SEL_NETIF_HASH_SIZE\t64"
    ],
    "globals_used": [
      "static DEFINE_SPINLOCK(sel_netif_lock);",
      "static struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&sel_netif_lock"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_netif_destroy",
          "args": [
            "netif"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netif_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
          "lines": "116-121",
          "snippet": "static void sel_netif_destroy(struct sel_netif *netif)\n{\n\tlist_del_rcu(&netif->list);\n\tsel_netif_total--;\n\tkfree_rcu(netif, rcu_head);\n}",
          "includes": [
            "#include \"netif.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 sel_netif_total;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic u32 sel_netif_total;\n\nstatic void sel_netif_destroy(struct sel_netif *netif)\n{\n\tlist_del_rcu(&netif->list);\n\tsel_netif_total--;\n\tkfree_rcu(netif, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "netif",
            "&sel_netif_hash[idx]",
            "list"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&sel_netif_lock"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\n#define SEL_NETIF_HASH_SIZE\t64\n\nstatic DEFINE_SPINLOCK(sel_netif_lock);\nstatic struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];\n\nvoid sel_netif_flush(void)\n{\n\tint idx;\n\tstruct sel_netif *netif;\n\n\tspin_lock_bh(&sel_netif_lock);\n\tfor (idx = 0; idx < SEL_NETIF_HASH_SIZE; idx++)\n\t\tlist_for_each_entry(netif, &sel_netif_hash[idx], list)\n\t\t\tsel_netif_destroy(netif);\n\tspin_unlock_bh(&sel_netif_lock);\n}"
  },
  {
    "function_name": "sel_netif_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
    "lines": "229-240",
    "snippet": "static void sel_netif_kill(const struct net *ns, int ifindex)\n{\n\tstruct sel_netif *netif;\n\n\trcu_read_lock();\n\tspin_lock_bh(&sel_netif_lock);\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (netif)\n\t\tsel_netif_destroy(netif);\n\tspin_unlock_bh(&sel_netif_lock);\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"netif.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sel_netif_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&sel_netif_lock"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_netif_destroy",
          "args": [
            "netif"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netif_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
          "lines": "116-121",
          "snippet": "static void sel_netif_destroy(struct sel_netif *netif)\n{\n\tlist_del_rcu(&netif->list);\n\tsel_netif_total--;\n\tkfree_rcu(netif, rcu_head);\n}",
          "includes": [
            "#include \"netif.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32 sel_netif_total;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic u32 sel_netif_total;\n\nstatic void sel_netif_destroy(struct sel_netif *netif)\n{\n\tlist_del_rcu(&netif->list);\n\tsel_netif_total--;\n\tkfree_rcu(netif, rcu_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sel_netif_find",
          "args": [
            "ns",
            "ifindex"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netif_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
          "lines": "71-83",
          "snippet": "static inline struct sel_netif *sel_netif_find(const struct net *ns,\n\t\t\t\t\t       int ifindex)\n{\n\tint idx = sel_netif_hashfn(ns, ifindex);\n\tstruct sel_netif *netif;\n\n\tlist_for_each_entry_rcu(netif, &sel_netif_hash[idx], list)\n\t\tif (net_eq(netif->nsec.ns, ns) &&\n\t\t    netif->nsec.ifindex == ifindex)\n\t\t\treturn netif;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"netif.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];\n\nstatic inline struct sel_netif *sel_netif_find(const struct net *ns,\n\t\t\t\t\t       int ifindex)\n{\n\tint idx = sel_netif_hashfn(ns, ifindex);\n\tstruct sel_netif *netif;\n\n\tlist_for_each_entry_rcu(netif, &sel_netif_hash[idx], list)\n\t\tif (net_eq(netif->nsec.ns, ns) &&\n\t\t    netif->nsec.ifindex == ifindex)\n\t\t\treturn netif;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&sel_netif_lock"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sel_netif_lock);\n\nstatic void sel_netif_kill(const struct net *ns, int ifindex)\n{\n\tstruct sel_netif *netif;\n\n\trcu_read_lock();\n\tspin_lock_bh(&sel_netif_lock);\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (netif)\n\t\tsel_netif_destroy(netif);\n\tspin_unlock_bh(&sel_netif_lock);\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "sel_netif_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
    "lines": "203-217",
    "snippet": "int sel_netif_sid(struct net *ns, int ifindex, u32 *sid)\n{\n\tstruct sel_netif *netif;\n\n\trcu_read_lock();\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (likely(netif != NULL)) {\n\t\t*sid = netif->nsec.sid;\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn sel_netif_sid_slow(ns, ifindex, sid);\n}",
    "includes": [
      "#include \"netif.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sel_netif_sid_slow",
          "args": [
            "ns",
            "ifindex",
            "sid"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netif_sid_slow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
          "lines": "136-187",
          "snippet": "static int sel_netif_sid_slow(struct net *ns, int ifindex, u32 *sid)\n{\n\tint ret;\n\tstruct sel_netif *netif;\n\tstruct sel_netif *new = NULL;\n\tstruct net_device *dev;\n\n\t/* NOTE: we always use init's network namespace since we don't\n\t * currently support containers */\n\n\tdev = dev_get_by_index(ns, ifindex);\n\tif (unlikely(dev == NULL)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in sel_netif_sid_slow(),\"\n\t\t       \" invalid network interface (%d)\\n\", ifindex);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock_bh(&sel_netif_lock);\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (netif != NULL) {\n\t\t*sid = netif->nsec.sid;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (new == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = security_netif_sid(dev->name, &new->nsec.sid);\n\tif (ret != 0)\n\t\tgoto out;\n\tnew->nsec.ns = ns;\n\tnew->nsec.ifindex = ifindex;\n\tret = sel_netif_insert(new);\n\tif (ret != 0)\n\t\tgoto out;\n\t*sid = new->nsec.sid;\n\nout:\n\tspin_unlock_bh(&sel_netif_lock);\n\tdev_put(dev);\n\tif (unlikely(ret)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in sel_netif_sid_slow(),\"\n\t\t       \" unable to determine network interface label (%d)\\n\",\n\t\t       ifindex);\n\t\tkfree(new);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"netif.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(sel_netif_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sel_netif_lock);\n\nstatic int sel_netif_sid_slow(struct net *ns, int ifindex, u32 *sid)\n{\n\tint ret;\n\tstruct sel_netif *netif;\n\tstruct sel_netif *new = NULL;\n\tstruct net_device *dev;\n\n\t/* NOTE: we always use init's network namespace since we don't\n\t * currently support containers */\n\n\tdev = dev_get_by_index(ns, ifindex);\n\tif (unlikely(dev == NULL)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in sel_netif_sid_slow(),\"\n\t\t       \" invalid network interface (%d)\\n\", ifindex);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock_bh(&sel_netif_lock);\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (netif != NULL) {\n\t\t*sid = netif->nsec.sid;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (new == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = security_netif_sid(dev->name, &new->nsec.sid);\n\tif (ret != 0)\n\t\tgoto out;\n\tnew->nsec.ns = ns;\n\tnew->nsec.ifindex = ifindex;\n\tret = sel_netif_insert(new);\n\tif (ret != 0)\n\t\tgoto out;\n\t*sid = new->nsec.sid;\n\nout:\n\tspin_unlock_bh(&sel_netif_lock);\n\tdev_put(dev);\n\tif (unlikely(ret)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in sel_netif_sid_slow(),\"\n\t\t       \" unable to determine network interface label (%d)\\n\",\n\t\t       ifindex);\n\t\tkfree(new);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "netif != NULL"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_netif_find",
          "args": [
            "ns",
            "ifindex"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netif_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
          "lines": "71-83",
          "snippet": "static inline struct sel_netif *sel_netif_find(const struct net *ns,\n\t\t\t\t\t       int ifindex)\n{\n\tint idx = sel_netif_hashfn(ns, ifindex);\n\tstruct sel_netif *netif;\n\n\tlist_for_each_entry_rcu(netif, &sel_netif_hash[idx], list)\n\t\tif (net_eq(netif->nsec.ns, ns) &&\n\t\t    netif->nsec.ifindex == ifindex)\n\t\t\treturn netif;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"netif.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];\n\nstatic inline struct sel_netif *sel_netif_find(const struct net *ns,\n\t\t\t\t\t       int ifindex)\n{\n\tint idx = sel_netif_hashfn(ns, ifindex);\n\tstruct sel_netif *netif;\n\n\tlist_for_each_entry_rcu(netif, &sel_netif_hash[idx], list)\n\t\tif (net_eq(netif->nsec.ns, ns) &&\n\t\t    netif->nsec.ifindex == ifindex)\n\t\t\treturn netif;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nint sel_netif_sid(struct net *ns, int ifindex, u32 *sid)\n{\n\tstruct sel_netif *netif;\n\n\trcu_read_lock();\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (likely(netif != NULL)) {\n\t\t*sid = netif->nsec.sid;\n\t\trcu_read_unlock();\n\t\treturn 0;\n\t}\n\trcu_read_unlock();\n\n\treturn sel_netif_sid_slow(ns, ifindex, sid);\n}"
  },
  {
    "function_name": "sel_netif_sid_slow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
    "lines": "136-187",
    "snippet": "static int sel_netif_sid_slow(struct net *ns, int ifindex, u32 *sid)\n{\n\tint ret;\n\tstruct sel_netif *netif;\n\tstruct sel_netif *new = NULL;\n\tstruct net_device *dev;\n\n\t/* NOTE: we always use init's network namespace since we don't\n\t * currently support containers */\n\n\tdev = dev_get_by_index(ns, ifindex);\n\tif (unlikely(dev == NULL)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in sel_netif_sid_slow(),\"\n\t\t       \" invalid network interface (%d)\\n\", ifindex);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock_bh(&sel_netif_lock);\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (netif != NULL) {\n\t\t*sid = netif->nsec.sid;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (new == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = security_netif_sid(dev->name, &new->nsec.sid);\n\tif (ret != 0)\n\t\tgoto out;\n\tnew->nsec.ns = ns;\n\tnew->nsec.ifindex = ifindex;\n\tret = sel_netif_insert(new);\n\tif (ret != 0)\n\t\tgoto out;\n\t*sid = new->nsec.sid;\n\nout:\n\tspin_unlock_bh(&sel_netif_lock);\n\tdev_put(dev);\n\tif (unlikely(ret)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in sel_netif_sid_slow(),\"\n\t\t       \" unable to determine network interface label (%d)\\n\",\n\t\t       ifindex);\n\t\tkfree(new);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"netif.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_SPINLOCK(sel_netif_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "new"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t       \"SELinux: failure in sel_netif_sid_slow(),\"\n\t\t       \" unable to determine network interface label (%d)\\n\"",
            "ifindex"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_put",
          "args": [
            "dev"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&sel_netif_lock"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_netif_insert",
          "args": [
            "new"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netif_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
          "lines": "94-106",
          "snippet": "static int sel_netif_insert(struct sel_netif *netif)\n{\n\tint idx;\n\n\tif (sel_netif_total >= SEL_NETIF_HASH_MAX)\n\t\treturn -ENOSPC;\n\n\tidx = sel_netif_hashfn(netif->nsec.ns, netif->nsec.ifindex);\n\tlist_add_rcu(&netif->list, &sel_netif_hash[idx]);\n\tsel_netif_total++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"netif.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define SEL_NETIF_HASH_MAX\t1024"
          ],
          "globals_used": [
            "static u32 sel_netif_total;",
            "static struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\n#define SEL_NETIF_HASH_MAX\t1024\n\nstatic u32 sel_netif_total;\nstatic struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];\n\nstatic int sel_netif_insert(struct sel_netif *netif)\n{\n\tint idx;\n\n\tif (sel_netif_total >= SEL_NETIF_HASH_MAX)\n\t\treturn -ENOSPC;\n\n\tidx = sel_netif_hashfn(netif->nsec.ns, netif->nsec.ifindex);\n\tlist_add_rcu(&netif->list, &sel_netif_hash[idx]);\n\tsel_netif_total++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_netif_sid",
          "args": [
            "dev->name",
            "&new->nsec.sid"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "security_netif_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "2334-2368",
          "snippet": "int security_netif_sid(char *name, u32 *if_sid)\n{\n\tint rc = 0;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_NETIF];\n\twhile (c) {\n\t\tif (strcmp(name, c->u.name) == 0)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0] || !c->sid[1]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t  &c->context[0],\n\t\t\t\t\t\t  &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[1],\n\t\t\t\t\t\t   &c->sid[1]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*if_sid = c->sid[0];\n\t} else\n\t\t*if_sid = SECINITSID_NETIF;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\n\nint security_netif_sid(char *name, u32 *if_sid)\n{\n\tint rc = 0;\n\tstruct ocontext *c;\n\n\tread_lock(&policy_rwlock);\n\n\tc = policydb.ocontexts[OCON_NETIF];\n\twhile (c) {\n\t\tif (strcmp(name, c->u.name) == 0)\n\t\t\tbreak;\n\t\tc = c->next;\n\t}\n\n\tif (c) {\n\t\tif (!c->sid[0] || !c->sid[1]) {\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t  &c->context[0],\n\t\t\t\t\t\t  &c->sid[0]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t\trc = sidtab_context_to_sid(&sidtab,\n\t\t\t\t\t\t   &c->context[1],\n\t\t\t\t\t\t   &c->sid[1]);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\t*if_sid = c->sid[0];\n\t} else\n\t\t*if_sid = SECINITSID_NETIF;\n\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*new)",
            "GFP_ATOMIC"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_netif_find",
          "args": [
            "ns",
            "ifindex"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netif_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
          "lines": "71-83",
          "snippet": "static inline struct sel_netif *sel_netif_find(const struct net *ns,\n\t\t\t\t\t       int ifindex)\n{\n\tint idx = sel_netif_hashfn(ns, ifindex);\n\tstruct sel_netif *netif;\n\n\tlist_for_each_entry_rcu(netif, &sel_netif_hash[idx], list)\n\t\tif (net_eq(netif->nsec.ns, ns) &&\n\t\t    netif->nsec.ifindex == ifindex)\n\t\t\treturn netif;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"netif.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];\n\nstatic inline struct sel_netif *sel_netif_find(const struct net *ns,\n\t\t\t\t\t       int ifindex)\n{\n\tint idx = sel_netif_hashfn(ns, ifindex);\n\tstruct sel_netif *netif;\n\n\tlist_for_each_entry_rcu(netif, &sel_netif_hash[idx], list)\n\t\tif (net_eq(netif->nsec.ns, ns) &&\n\t\t    netif->nsec.ifindex == ifindex)\n\t\t\treturn netif;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&sel_netif_lock"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dev == NULL"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dev_get_by_index",
          "args": [
            "ns",
            "ifindex"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(sel_netif_lock);\n\nstatic int sel_netif_sid_slow(struct net *ns, int ifindex, u32 *sid)\n{\n\tint ret;\n\tstruct sel_netif *netif;\n\tstruct sel_netif *new = NULL;\n\tstruct net_device *dev;\n\n\t/* NOTE: we always use init's network namespace since we don't\n\t * currently support containers */\n\n\tdev = dev_get_by_index(ns, ifindex);\n\tif (unlikely(dev == NULL)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in sel_netif_sid_slow(),\"\n\t\t       \" invalid network interface (%d)\\n\", ifindex);\n\t\treturn -ENOENT;\n\t}\n\n\tspin_lock_bh(&sel_netif_lock);\n\tnetif = sel_netif_find(ns, ifindex);\n\tif (netif != NULL) {\n\t\t*sid = netif->nsec.sid;\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\tnew = kzalloc(sizeof(*new), GFP_ATOMIC);\n\tif (new == NULL) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tret = security_netif_sid(dev->name, &new->nsec.sid);\n\tif (ret != 0)\n\t\tgoto out;\n\tnew->nsec.ns = ns;\n\tnew->nsec.ifindex = ifindex;\n\tret = sel_netif_insert(new);\n\tif (ret != 0)\n\t\tgoto out;\n\t*sid = new->nsec.sid;\n\nout:\n\tspin_unlock_bh(&sel_netif_lock);\n\tdev_put(dev);\n\tif (unlikely(ret)) {\n\t\tprintk(KERN_WARNING\n\t\t       \"SELinux: failure in sel_netif_sid_slow(),\"\n\t\t       \" unable to determine network interface label (%d)\\n\",\n\t\t       ifindex);\n\t\tkfree(new);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sel_netif_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
    "lines": "116-121",
    "snippet": "static void sel_netif_destroy(struct sel_netif *netif)\n{\n\tlist_del_rcu(&netif->list);\n\tsel_netif_total--;\n\tkfree_rcu(netif, rcu_head);\n}",
    "includes": [
      "#include \"netif.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u32 sel_netif_total;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree_rcu",
          "args": [
            "netif",
            "rcu_head"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&netif->list"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic u32 sel_netif_total;\n\nstatic void sel_netif_destroy(struct sel_netif *netif)\n{\n\tlist_del_rcu(&netif->list);\n\tsel_netif_total--;\n\tkfree_rcu(netif, rcu_head);\n}"
  },
  {
    "function_name": "sel_netif_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
    "lines": "94-106",
    "snippet": "static int sel_netif_insert(struct sel_netif *netif)\n{\n\tint idx;\n\n\tif (sel_netif_total >= SEL_NETIF_HASH_MAX)\n\t\treturn -ENOSPC;\n\n\tidx = sel_netif_hashfn(netif->nsec.ns, netif->nsec.ifindex);\n\tlist_add_rcu(&netif->list, &sel_netif_hash[idx]);\n\tsel_netif_total++;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"netif.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define SEL_NETIF_HASH_MAX\t1024"
    ],
    "globals_used": [
      "static u32 sel_netif_total;",
      "static struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "&netif->list",
            "&sel_netif_hash[idx]"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_netif_hashfn",
          "args": [
            "netif->nsec.ns",
            "netif->nsec.ifindex"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netif_hashfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
          "lines": "56-59",
          "snippet": "static inline u32 sel_netif_hashfn(const struct net *ns, int ifindex)\n{\n\treturn (((uintptr_t)ns + ifindex) & (SEL_NETIF_HASH_SIZE - 1));\n}",
          "includes": [
            "#include \"netif.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define SEL_NETIF_HASH_SIZE\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\n#define SEL_NETIF_HASH_SIZE\t64\n\nstatic inline u32 sel_netif_hashfn(const struct net *ns, int ifindex)\n{\n\treturn (((uintptr_t)ns + ifindex) & (SEL_NETIF_HASH_SIZE - 1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\n#define SEL_NETIF_HASH_MAX\t1024\n\nstatic u32 sel_netif_total;\nstatic struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];\n\nstatic int sel_netif_insert(struct sel_netif *netif)\n{\n\tint idx;\n\n\tif (sel_netif_total >= SEL_NETIF_HASH_MAX)\n\t\treturn -ENOSPC;\n\n\tidx = sel_netif_hashfn(netif->nsec.ns, netif->nsec.ifindex);\n\tlist_add_rcu(&netif->list, &sel_netif_hash[idx]);\n\tsel_netif_total++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sel_netif_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
    "lines": "71-83",
    "snippet": "static inline struct sel_netif *sel_netif_find(const struct net *ns,\n\t\t\t\t\t       int ifindex)\n{\n\tint idx = sel_netif_hashfn(ns, ifindex);\n\tstruct sel_netif *netif;\n\n\tlist_for_each_entry_rcu(netif, &sel_netif_hash[idx], list)\n\t\tif (net_eq(netif->nsec.ns, ns) &&\n\t\t    netif->nsec.ifindex == ifindex)\n\t\t\treturn netif;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"netif.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "net_eq",
          "args": [
            "netif->nsec.ns",
            "ns"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "netif",
            "&sel_netif_hash[idx]",
            "list"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sel_netif_hashfn",
          "args": [
            "ns",
            "ifindex"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "sel_netif_hashfn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
          "lines": "56-59",
          "snippet": "static inline u32 sel_netif_hashfn(const struct net *ns, int ifindex)\n{\n\treturn (((uintptr_t)ns + ifindex) & (SEL_NETIF_HASH_SIZE - 1));\n}",
          "includes": [
            "#include \"netif.h\"",
            "#include \"objsec.h\"",
            "#include \"security.h\"",
            "#include <net/net_namespace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/notifier.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define SEL_NETIF_HASH_SIZE\t64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\n#define SEL_NETIF_HASH_SIZE\t64\n\nstatic inline u32 sel_netif_hashfn(const struct net *ns, int ifindex)\n{\n\treturn (((uintptr_t)ns + ifindex) & (SEL_NETIF_HASH_SIZE - 1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\nstatic struct list_head sel_netif_hash[SEL_NETIF_HASH_SIZE];\n\nstatic inline struct sel_netif *sel_netif_find(const struct net *ns,\n\t\t\t\t\t       int ifindex)\n{\n\tint idx = sel_netif_hashfn(ns, ifindex);\n\tstruct sel_netif *netif;\n\n\tlist_for_each_entry_rcu(netif, &sel_netif_hash[idx], list)\n\t\tif (net_eq(netif->nsec.ns, ns) &&\n\t\t    netif->nsec.ifindex == ifindex)\n\t\t\treturn netif;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "sel_netif_hashfn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netif.c",
    "lines": "56-59",
    "snippet": "static inline u32 sel_netif_hashfn(const struct net *ns, int ifindex)\n{\n\treturn (((uintptr_t)ns + ifindex) & (SEL_NETIF_HASH_SIZE - 1));\n}",
    "includes": [
      "#include \"netif.h\"",
      "#include \"objsec.h\"",
      "#include \"security.h\"",
      "#include <net/net_namespace.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/netdevice.h>",
      "#include <linux/notifier.h>",
      "#include <linux/list.h>",
      "#include <linux/kernel.h>",
      "#include <linux/stddef.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define SEL_NETIF_HASH_SIZE\t64"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netif.h\"\n#include \"objsec.h\"\n#include \"security.h\"\n#include <net/net_namespace.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/notifier.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/init.h>\n\n#define SEL_NETIF_HASH_SIZE\t64\n\nstatic inline u32 sel_netif_hashfn(const struct net *ns, int ifindex)\n{\n\treturn (((uintptr_t)ns + ifindex) & (SEL_NETIF_HASH_SIZE - 1));\n}"
  }
]