[
  {
    "function_name": "ima_inode_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "417-427",
    "snippet": "int ima_inode_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\tint result;\n\n\tresult = ima_protect_xattr(dentry, xattr_name, NULL, 0);\n\tif (result == 1) {\n\t\tima_reset_appraise_flags(d_backing_inode(dentry), 0);\n\t\tresult = 0;\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_reset_appraise_flags",
          "args": [
            "d_backing_inode(dentry)",
            "0"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "ima_reset_appraise_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
          "lines": "381-397",
          "snippet": "static void ima_reset_appraise_flags(struct inode *inode, int digsig)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!(ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tiint = integrity_iint_find(inode);\n\tif (!iint)\n\t\treturn;\n\n\tiint->flags &= ~IMA_DONE_MASK;\n\tiint->measured_pcrs = 0;\n\tif (digsig)\n\t\tiint->flags |= IMA_DIGSIG;\n\treturn;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/magic.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void ima_reset_appraise_flags(struct inode *inode, int digsig)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!(ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tiint = integrity_iint_find(inode);\n\tif (!iint)\n\t\treturn;\n\n\tiint->flags &= ~IMA_DONE_MASK;\n\tiint->measured_pcrs = 0;\n\tif (digsig)\n\t\tiint->flags |= IMA_DIGSIG;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_protect_xattr",
          "args": [
            "dentry",
            "xattr_name",
            "NULL",
            "0"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "ima_protect_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
          "lines": "370-379",
          "snippet": "static int ima_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tif (strcmp(xattr_name, XATTR_NAME_IMA) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/magic.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int ima_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tif (strcmp(xattr_name, XATTR_NAME_IMA) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_inode_removexattr(struct dentry *dentry, const char *xattr_name)\n{\n\tint result;\n\n\tresult = ima_protect_xattr(dentry, xattr_name, NULL, 0);\n\tif (result == 1) {\n\t\tima_reset_appraise_flags(d_backing_inode(dentry), 0);\n\t\tresult = 0;\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "ima_inode_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "399-415",
    "snippet": "int ima_inode_setxattr(struct dentry *dentry, const char *xattr_name,\n\t\t       const void *xattr_value, size_t xattr_value_len)\n{\n\tconst struct evm_ima_xattr_data *xvalue = xattr_value;\n\tint result;\n\n\tresult = ima_protect_xattr(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len);\n\tif (result == 1) {\n\t\tif (!xattr_value_len || (xvalue->type >= IMA_XATTR_LAST))\n\t\t\treturn -EINVAL;\n\t\tima_reset_appraise_flags(d_backing_inode(dentry),\n\t\t\txvalue->type == EVM_IMA_XATTR_DIGSIG);\n\t\tresult = 0;\n\t}\n\treturn result;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_reset_appraise_flags",
          "args": [
            "d_backing_inode(dentry)",
            "xvalue->type == EVM_IMA_XATTR_DIGSIG"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "ima_reset_appraise_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
          "lines": "381-397",
          "snippet": "static void ima_reset_appraise_flags(struct inode *inode, int digsig)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!(ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tiint = integrity_iint_find(inode);\n\tif (!iint)\n\t\treturn;\n\n\tiint->flags &= ~IMA_DONE_MASK;\n\tiint->measured_pcrs = 0;\n\tif (digsig)\n\t\tiint->flags |= IMA_DIGSIG;\n\treturn;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/magic.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void ima_reset_appraise_flags(struct inode *inode, int digsig)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!(ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tiint = integrity_iint_find(inode);\n\tif (!iint)\n\t\treturn;\n\n\tiint->flags &= ~IMA_DONE_MASK;\n\tiint->measured_pcrs = 0;\n\tif (digsig)\n\t\tiint->flags |= IMA_DIGSIG;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_protect_xattr",
          "args": [
            "dentry",
            "xattr_name",
            "xattr_value",
            "xattr_value_len"
          ],
          "line": 405
        },
        "resolved": true,
        "details": {
          "function_name": "ima_protect_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
          "lines": "370-379",
          "snippet": "static int ima_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tif (strcmp(xattr_name, XATTR_NAME_IMA) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/magic.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int ima_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tif (strcmp(xattr_name, XATTR_NAME_IMA) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_inode_setxattr(struct dentry *dentry, const char *xattr_name,\n\t\t       const void *xattr_value, size_t xattr_value_len)\n{\n\tconst struct evm_ima_xattr_data *xvalue = xattr_value;\n\tint result;\n\n\tresult = ima_protect_xattr(dentry, xattr_name, xattr_value,\n\t\t\t\t   xattr_value_len);\n\tif (result == 1) {\n\t\tif (!xattr_value_len || (xvalue->type >= IMA_XATTR_LAST))\n\t\t\treturn -EINVAL;\n\t\tima_reset_appraise_flags(d_backing_inode(dentry),\n\t\t\txvalue->type == EVM_IMA_XATTR_DIGSIG);\n\t\tresult = 0;\n\t}\n\treturn result;\n}"
  },
  {
    "function_name": "ima_reset_appraise_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "381-397",
    "snippet": "static void ima_reset_appraise_flags(struct inode *inode, int digsig)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!(ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tiint = integrity_iint_find(inode);\n\tif (!iint)\n\t\treturn;\n\n\tiint->flags &= ~IMA_DONE_MASK;\n\tiint->measured_pcrs = 0;\n\tif (digsig)\n\t\tiint->flags |= IMA_DIGSIG;\n\treturn;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "integrity_iint_find",
          "args": [
            "inode"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_iint_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/iint.c",
          "lines": "57-69",
          "snippet": "struct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(integrity_iint_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(integrity_iint_lock);\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void ima_reset_appraise_flags(struct inode *inode, int digsig)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!(ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode))\n\t\treturn;\n\n\tiint = integrity_iint_find(inode);\n\tif (!iint)\n\t\treturn;\n\n\tiint->flags &= ~IMA_DONE_MASK;\n\tiint->measured_pcrs = 0;\n\tif (digsig)\n\t\tiint->flags |= IMA_DIGSIG;\n\treturn;\n}"
  },
  {
    "function_name": "ima_protect_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "370-379",
    "snippet": "static int ima_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tif (strcmp(xattr_name, XATTR_NAME_IMA) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "xattr_name",
            "XATTR_NAME_IMA"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int ima_protect_xattr(struct dentry *dentry, const char *xattr_name,\n\t\t\t     const void *xattr_value, size_t xattr_value_len)\n{\n\tif (strcmp(xattr_name, XATTR_NAME_IMA) == 0) {\n\t\tif (!capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ima_inode_post_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "342-363",
    "snippet": "void ima_inode_post_setattr(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct integrity_iint_cache *iint;\n\tint must_appraise;\n\n\tif (!(ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode)\n\t    || !(inode->i_opflags & IOP_XATTR))\n\t\treturn;\n\n\tmust_appraise = ima_must_appraise(inode, MAY_ACCESS, POST_SETATTR);\n\tiint = integrity_iint_find(inode);\n\tif (iint) {\n\t\tiint->flags &= ~(IMA_APPRAISE | IMA_APPRAISED |\n\t\t\t\t IMA_APPRAISE_SUBMASK | IMA_APPRAISED_SUBMASK |\n\t\t\t\t IMA_ACTION_RULE_FLAGS);\n\t\tif (must_appraise)\n\t\t\tiint->flags |= IMA_APPRAISE;\n\t}\n\tif (!must_appraise)\n\t\t__vfs_removexattr(dentry, XATTR_NAME_IMA);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vfs_removexattr",
          "args": [
            "dentry",
            "XATTR_NAME_IMA"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "integrity_iint_find",
          "args": [
            "inode"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_iint_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/iint.c",
          "lines": "57-69",
          "snippet": "struct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(integrity_iint_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nstatic DEFINE_RWLOCK(integrity_iint_lock);\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode)\n{\n\tstruct integrity_iint_cache *iint;\n\n\tif (!IS_IMA(inode))\n\t\treturn NULL;\n\n\tread_lock(&integrity_iint_lock);\n\tiint = __integrity_iint_find(inode);\n\tread_unlock(&integrity_iint_lock);\n\n\treturn iint;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_must_appraise",
          "args": [
            "inode",
            "MAY_ACCESS",
            "POST_SETATTR"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "ima_must_appraise",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
          "lines": "51-57",
          "snippet": "int ima_must_appraise(struct inode *inode, int mask, enum ima_hooks func)\n{\n\tif (!ima_appraise)\n\t\treturn 0;\n\n\treturn ima_match_policy(inode, func, mask, IMA_APPRAISE, NULL);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/magic.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_must_appraise(struct inode *inode, int mask, enum ima_hooks func)\n{\n\tif (!ima_appraise)\n\t\treturn 0;\n\n\treturn ima_match_policy(inode, func, mask, IMA_APPRAISE, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->i_mode"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nvoid ima_inode_post_setattr(struct dentry *dentry)\n{\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct integrity_iint_cache *iint;\n\tint must_appraise;\n\n\tif (!(ima_policy_flag & IMA_APPRAISE) || !S_ISREG(inode->i_mode)\n\t    || !(inode->i_opflags & IOP_XATTR))\n\t\treturn;\n\n\tmust_appraise = ima_must_appraise(inode, MAY_ACCESS, POST_SETATTR);\n\tiint = integrity_iint_find(inode);\n\tif (iint) {\n\t\tiint->flags &= ~(IMA_APPRAISE | IMA_APPRAISED |\n\t\t\t\t IMA_APPRAISE_SUBMASK | IMA_APPRAISED_SUBMASK |\n\t\t\t\t IMA_ACTION_RULE_FLAGS);\n\t\tif (must_appraise)\n\t\t\tiint->flags |= IMA_APPRAISE;\n\t}\n\tif (!must_appraise)\n\t\t__vfs_removexattr(dentry, XATTR_NAME_IMA);\n}"
  },
  {
    "function_name": "ima_update_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "314-331",
    "snippet": "void ima_update_xattr(struct integrity_iint_cache *iint, struct file *file)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tint rc = 0;\n\n\t/* do not collect and update hash for digital signatures */\n\tif (iint->flags & IMA_DIGSIG)\n\t\treturn;\n\n\tif (iint->ima_file_status != INTEGRITY_PASS)\n\t\treturn;\n\n\trc = ima_collect_measurement(iint, file, NULL, 0, ima_hash_algo);\n\tif (rc < 0)\n\t\treturn;\n\n\tima_fix_xattr(dentry, iint);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_fix_xattr",
          "args": [
            "dentry",
            "iint"
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "ima_fix_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
          "lines": "59-78",
          "snippet": "static int ima_fix_xattr(struct dentry *dentry,\n\t\t\t struct integrity_iint_cache *iint)\n{\n\tint rc, offset;\n\tu8 algo = iint->ima_hash->algo;\n\n\tif (algo <= HASH_ALGO_SHA1) {\n\t\toffset = 1;\n\t\tiint->ima_hash->xattr.sha1.type = IMA_XATTR_DIGEST;\n\t} else {\n\t\toffset = 0;\n\t\tiint->ima_hash->xattr.ng.type = IMA_XATTR_DIGEST_NG;\n\t\tiint->ima_hash->xattr.ng.algo = algo;\n\t}\n\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_IMA,\n\t\t\t\t   &iint->ima_hash->xattr.data[offset],\n\t\t\t\t   (sizeof(iint->ima_hash->xattr) - offset) +\n\t\t\t\t   iint->ima_hash->length, 0);\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/magic.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int ima_fix_xattr(struct dentry *dentry,\n\t\t\t struct integrity_iint_cache *iint)\n{\n\tint rc, offset;\n\tu8 algo = iint->ima_hash->algo;\n\n\tif (algo <= HASH_ALGO_SHA1) {\n\t\toffset = 1;\n\t\tiint->ima_hash->xattr.sha1.type = IMA_XATTR_DIGEST;\n\t} else {\n\t\toffset = 0;\n\t\tiint->ima_hash->xattr.ng.type = IMA_XATTR_DIGEST_NG;\n\t\tiint->ima_hash->xattr.ng.algo = algo;\n\t}\n\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_IMA,\n\t\t\t\t   &iint->ima_hash->xattr.data[offset],\n\t\t\t\t   (sizeof(iint->ima_hash->xattr) - offset) +\n\t\t\t\t   iint->ima_hash->length, 0);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_collect_measurement",
          "args": [
            "iint",
            "file",
            "NULL",
            "0",
            "ima_hash_algo"
          ],
          "line": 326
        },
        "resolved": true,
        "details": {
          "function_name": "ima_collect_measurement",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "194-256",
          "snippet": "int ima_collect_measurement(struct integrity_iint_cache *iint,\n\t\t\t    struct file *file, void *buf, loff_t size,\n\t\t\t    enum hash_algo algo)\n{\n\tconst char *audit_cause = \"failed\";\n\tstruct inode *inode = file_inode(file);\n\tconst char *filename = file->f_path.dentry->d_name.name;\n\tint result = 0;\n\tint length;\n\tvoid *tmpbuf;\n\tu64 i_version;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[IMA_MAX_DIGEST_SIZE];\n\t} hash;\n\n\tif (iint->flags & IMA_COLLECTED)\n\t\tgoto out;\n\n\t/*\n\t * Dectecting file change is based on i_version. On filesystems\n\t * which do not support i_version, support is limited to an initial\n\t * measurement/appraisal/audit.\n\t */\n\ti_version = file_inode(file)->i_version;\n\thash.hdr.algo = algo;\n\n\t/* Initialize hash digest to 0's in case of failure */\n\tmemset(&hash.digest, 0, sizeof(hash.digest));\n\n\tif (buf)\n\t\tresult = ima_calc_buffer_hash(buf, size, &hash.hdr);\n\telse\n\t\tresult = ima_calc_file_hash(file, &hash.hdr);\n\n\tif (result && result != -EBADF && result != -EINVAL)\n\t\tgoto out;\n\n\tlength = sizeof(hash.hdr) + hash.hdr.length;\n\ttmpbuf = krealloc(iint->ima_hash, length, GFP_NOFS);\n\tif (!tmpbuf) {\n\t\tresult = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tiint->ima_hash = tmpbuf;\n\tmemcpy(iint->ima_hash, &hash, length);\n\tiint->version = i_version;\n\n\t/* Possibly temporary failure due to type of read (eg. O_DIRECT) */\n\tif (!result)\n\t\tiint->flags |= IMA_COLLECTED;\nout:\n\tif (result) {\n\t\tif (file->f_flags & O_DIRECT)\n\t\t\taudit_cause = \"failed(directio)\";\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\n\t\t\t\t    filename, \"collect_data\", audit_cause,\n\t\t\t\t    result, 0);\n\t}\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nint ima_collect_measurement(struct integrity_iint_cache *iint,\n\t\t\t    struct file *file, void *buf, loff_t size,\n\t\t\t    enum hash_algo algo)\n{\n\tconst char *audit_cause = \"failed\";\n\tstruct inode *inode = file_inode(file);\n\tconst char *filename = file->f_path.dentry->d_name.name;\n\tint result = 0;\n\tint length;\n\tvoid *tmpbuf;\n\tu64 i_version;\n\tstruct {\n\t\tstruct ima_digest_data hdr;\n\t\tchar digest[IMA_MAX_DIGEST_SIZE];\n\t} hash;\n\n\tif (iint->flags & IMA_COLLECTED)\n\t\tgoto out;\n\n\t/*\n\t * Dectecting file change is based on i_version. On filesystems\n\t * which do not support i_version, support is limited to an initial\n\t * measurement/appraisal/audit.\n\t */\n\ti_version = file_inode(file)->i_version;\n\thash.hdr.algo = algo;\n\n\t/* Initialize hash digest to 0's in case of failure */\n\tmemset(&hash.digest, 0, sizeof(hash.digest));\n\n\tif (buf)\n\t\tresult = ima_calc_buffer_hash(buf, size, &hash.hdr);\n\telse\n\t\tresult = ima_calc_file_hash(file, &hash.hdr);\n\n\tif (result && result != -EBADF && result != -EINVAL)\n\t\tgoto out;\n\n\tlength = sizeof(hash.hdr) + hash.hdr.length;\n\ttmpbuf = krealloc(iint->ima_hash, length, GFP_NOFS);\n\tif (!tmpbuf) {\n\t\tresult = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tiint->ima_hash = tmpbuf;\n\tmemcpy(iint->ima_hash, &hash, length);\n\tiint->version = i_version;\n\n\t/* Possibly temporary failure due to type of read (eg. O_DIRECT) */\n\tif (!result)\n\t\tiint->flags |= IMA_COLLECTED;\nout:\n\tif (result) {\n\t\tif (file->f_flags & O_DIRECT)\n\t\t\taudit_cause = \"failed(directio)\";\n\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode,\n\t\t\t\t    filename, \"collect_data\", audit_cause,\n\t\t\t\t    result, 0);\n\t}\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_dentry",
          "args": [
            "file"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nvoid ima_update_xattr(struct integrity_iint_cache *iint, struct file *file)\n{\n\tstruct dentry *dentry = file_dentry(file);\n\tint rc = 0;\n\n\t/* do not collect and update hash for digital signatures */\n\tif (iint->flags & IMA_DIGSIG)\n\t\treturn;\n\n\tif (iint->ima_file_status != INTEGRITY_PASS)\n\t\treturn;\n\n\trc = ima_collect_measurement(iint, file, NULL, 0, ima_hash_algo);\n\tif (rc < 0)\n\t\treturn;\n\n\tima_fix_xattr(dentry, iint);\n}"
  },
  {
    "function_name": "ima_appraise_measurement",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "200-309",
    "snippet": "int ima_appraise_measurement(enum ima_hooks func,\n\t\t\t     struct integrity_iint_cache *iint,\n\t\t\t     struct file *file, const unsigned char *filename,\n\t\t\t     struct evm_ima_xattr_data *xattr_value,\n\t\t\t     int xattr_len, int opened)\n{\n\tstatic const char op[] = \"appraise_data\";\n\tchar *cause = \"unknown\";\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct inode *inode = d_backing_inode(dentry);\n\tenum integrity_status status = INTEGRITY_UNKNOWN;\n\tint rc = xattr_len, hash_start = 0;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn INTEGRITY_UNKNOWN;\n\n\tif (rc <= 0) {\n\t\tif (rc && rc != -ENODATA)\n\t\t\tgoto out;\n\n\t\tcause = iint->flags & IMA_DIGSIG_REQUIRED ?\n\t\t\t\t\"IMA-signature-required\" : \"missing-hash\";\n\t\tstatus = INTEGRITY_NOLABEL;\n\t\tif (opened & FILE_CREATED)\n\t\t\tiint->flags |= IMA_NEW_FILE;\n\t\tif ((iint->flags & IMA_NEW_FILE) &&\n\t\t    !(iint->flags & IMA_DIGSIG_REQUIRED))\n\t\t\tstatus = INTEGRITY_PASS;\n\t\tgoto out;\n\t}\n\n\tstatus = evm_verifyxattr(dentry, XATTR_NAME_IMA, xattr_value, rc, iint);\n\tif ((status != INTEGRITY_PASS) && (status != INTEGRITY_UNKNOWN)) {\n\t\tif ((status == INTEGRITY_NOLABEL)\n\t\t    || (status == INTEGRITY_NOXATTRS))\n\t\t\tcause = \"missing-HMAC\";\n\t\telse if (status == INTEGRITY_FAIL)\n\t\t\tcause = \"invalid-HMAC\";\n\t\tgoto out;\n\t}\n\tswitch (xattr_value->type) {\n\tcase IMA_XATTR_DIGEST_NG:\n\t\t/* first byte contains algorithm id */\n\t\thash_start = 1;\n\t\t/* fall through */\n\tcase IMA_XATTR_DIGEST:\n\t\tif (iint->flags & IMA_DIGSIG_REQUIRED) {\n\t\t\tcause = \"IMA-signature-required\";\n\t\t\tstatus = INTEGRITY_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tif (xattr_len - sizeof(xattr_value->type) - hash_start >=\n\t\t\t\tiint->ima_hash->length)\n\t\t\t/* xattr length may be longer. md5 hash in previous\n\t\t\t   version occupied 20 bytes in xattr, instead of 16\n\t\t\t */\n\t\t\trc = memcmp(&xattr_value->digest[hash_start],\n\t\t\t\t    iint->ima_hash->digest,\n\t\t\t\t    iint->ima_hash->length);\n\t\telse\n\t\t\trc = -EINVAL;\n\t\tif (rc) {\n\t\t\tcause = \"invalid-hash\";\n\t\t\tstatus = INTEGRITY_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tstatus = INTEGRITY_PASS;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\tiint->flags |= IMA_DIGSIG;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_IMA,\n\t\t\t\t\t     (const char *)xattr_value, rc,\n\t\t\t\t\t     iint->ima_hash->digest,\n\t\t\t\t\t     iint->ima_hash->length);\n\t\tif (rc == -EOPNOTSUPP) {\n\t\t\tstatus = INTEGRITY_UNKNOWN;\n\t\t} else if (rc) {\n\t\t\tcause = \"invalid-signature\";\n\t\t\tstatus = INTEGRITY_FAIL;\n\t\t} else {\n\t\t\tstatus = INTEGRITY_PASS;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = INTEGRITY_UNKNOWN;\n\t\tcause = \"unknown-ima-data\";\n\t\tbreak;\n\t}\n\nout:\n\tif (status != INTEGRITY_PASS) {\n\t\tif ((ima_appraise & IMA_APPRAISE_FIX) &&\n\t\t    (!xattr_value ||\n\t\t     xattr_value->type != EVM_IMA_XATTR_DIGSIG)) {\n\t\t\tif (!ima_fix_xattr(dentry, iint))\n\t\t\t\tstatus = INTEGRITY_PASS;\n\t\t} else if ((inode->i_size == 0) &&\n\t\t\t   (iint->flags & IMA_NEW_FILE) &&\n\t\t\t   (xattr_value &&\n\t\t\t    xattr_value->type == EVM_IMA_XATTR_DIGSIG)) {\n\t\t\tstatus = INTEGRITY_PASS;\n\t\t}\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode, filename,\n\t\t\t\t    op, cause, rc, 0);\n\t} else {\n\t\tima_cache_flags(iint, func);\n\t}\n\tima_set_cache_status(iint, func, status);\n\treturn status;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_set_cache_status",
          "args": [
            "iint",
            "func",
            "status"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "ima_set_cache_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
          "lines": "98-118",
          "snippet": "static void ima_set_cache_status(struct integrity_iint_cache *iint,\n\t\t\t\t enum ima_hooks func,\n\t\t\t\t enum integrity_status status)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\tiint->ima_mmap_status = status;\n\t\tbreak;\n\tcase BPRM_CHECK:\n\t\tiint->ima_bprm_status = status;\n\t\tbreak;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\tiint->ima_file_status = status;\n\t\tbreak;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\tiint->ima_read_status = status;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/magic.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void ima_set_cache_status(struct integrity_iint_cache *iint,\n\t\t\t\t enum ima_hooks func,\n\t\t\t\t enum integrity_status status)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\tiint->ima_mmap_status = status;\n\t\tbreak;\n\tcase BPRM_CHECK:\n\t\tiint->ima_bprm_status = status;\n\t\tbreak;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\tiint->ima_file_status = status;\n\t\tbreak;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\tiint->ima_read_status = status;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_cache_flags",
          "args": [
            "iint",
            "func"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "ima_cache_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
          "lines": "120-139",
          "snippet": "static void ima_cache_flags(struct integrity_iint_cache *iint,\n\t\t\t     enum ima_hooks func)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\tiint->flags |= (IMA_MMAP_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase BPRM_CHECK:\n\t\tiint->flags |= (IMA_BPRM_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\tiint->flags |= (IMA_FILE_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\tiint->flags |= (IMA_READ_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/magic.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void ima_cache_flags(struct integrity_iint_cache *iint,\n\t\t\t     enum ima_hooks func)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\tiint->flags |= (IMA_MMAP_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase BPRM_CHECK:\n\t\tiint->flags |= (IMA_BPRM_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\tiint->flags |= (IMA_FILE_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\tiint->flags |= (IMA_READ_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "integrity_audit_msg",
          "args": [
            "AUDIT_INTEGRITY_DATA",
            "inode",
            "filename",
            "op",
            "cause",
            "rc",
            "0"
          ],
          "line": 302
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_audit_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "183-188",
          "snippet": "static inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct integrity_iint_cache *integrity_iint_find(struct inode *inode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct integrity_iint_cache *integrity_iint_find(struct inode *inode);\n\nstatic inline void integrity_audit_msg(int audit_msgno, struct inode *inode,\n\t\t\t\t       const unsigned char *fname,\n\t\t\t\t       const char *op, const char *cause,\n\t\t\t\t       int result, int info)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_fix_xattr",
          "args": [
            "dentry",
            "iint"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ima_fix_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
          "lines": "59-78",
          "snippet": "static int ima_fix_xattr(struct dentry *dentry,\n\t\t\t struct integrity_iint_cache *iint)\n{\n\tint rc, offset;\n\tu8 algo = iint->ima_hash->algo;\n\n\tif (algo <= HASH_ALGO_SHA1) {\n\t\toffset = 1;\n\t\tiint->ima_hash->xattr.sha1.type = IMA_XATTR_DIGEST;\n\t} else {\n\t\toffset = 0;\n\t\tiint->ima_hash->xattr.ng.type = IMA_XATTR_DIGEST_NG;\n\t\tiint->ima_hash->xattr.ng.algo = algo;\n\t}\n\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_IMA,\n\t\t\t\t   &iint->ima_hash->xattr.data[offset],\n\t\t\t\t   (sizeof(iint->ima_hash->xattr) - offset) +\n\t\t\t\t   iint->ima_hash->length, 0);\n\treturn rc;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/magic.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int ima_fix_xattr(struct dentry *dentry,\n\t\t\t struct integrity_iint_cache *iint)\n{\n\tint rc, offset;\n\tu8 algo = iint->ima_hash->algo;\n\n\tif (algo <= HASH_ALGO_SHA1) {\n\t\toffset = 1;\n\t\tiint->ima_hash->xattr.sha1.type = IMA_XATTR_DIGEST;\n\t} else {\n\t\toffset = 0;\n\t\tiint->ima_hash->xattr.ng.type = IMA_XATTR_DIGEST_NG;\n\t\tiint->ima_hash->xattr.ng.algo = algo;\n\t}\n\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_IMA,\n\t\t\t\t   &iint->ima_hash->xattr.data[offset],\n\t\t\t\t   (sizeof(iint->ima_hash->xattr) - offset) +\n\t\t\t\t   iint->ima_hash->length, 0);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "integrity_digsig_verify",
          "args": [
            "INTEGRITY_KEYRING_IMA",
            "(const char *)xattr_value",
            "rc",
            "iint->ima_hash->digest",
            "iint->ima_hash->length"
          ],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_digsig_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "137-142",
          "snippet": "static inline int integrity_digsig_verify(const unsigned int id,\n\t\t\t\t\t  const char *sig, int siglen,\n\t\t\t\t\t  const char *digest, int digestlen)\n{\n\treturn -EOPNOTSUPP;\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct evm_ima_xattr_data {\n\tu8 type;\n\tu8 digest[SHA1_DIGEST_SIZE];\n} __packed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct evm_ima_xattr_data {\n\tu8 type;\n\tu8 digest[SHA1_DIGEST_SIZE];\n} __packed;\n\nstatic inline int integrity_digsig_verify(const unsigned int id,\n\t\t\t\t\t  const char *sig, int siglen,\n\t\t\t\t\t  const char *digest, int digestlen)\n{\n\treturn -EOPNOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&xattr_value->digest[hash_start]",
            "iint->ima_hash->digest",
            "iint->ima_hash->length"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "evm_verifyxattr",
          "args": [
            "dentry",
            "XATTR_NAME_IMA",
            "xattr_value",
            "rc",
            "iint"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "evm_verifyxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_main.c",
          "lines": "239-254",
          "snippet": "enum integrity_status evm_verifyxattr(struct dentry *dentry,\n\t\t\t\t      const char *xattr_name,\n\t\t\t\t      void *xattr_value, size_t xattr_value_len,\n\t\t\t\t      struct integrity_iint_cache *iint)\n{\n\tif (!evm_initialized || !evm_protected_xattr(xattr_name))\n\t\treturn INTEGRITY_UNKNOWN;\n\n\tif (!iint) {\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (!iint)\n\t\t\treturn INTEGRITY_UNKNOWN;\n\t}\n\treturn evm_verify_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t xattr_value_len, iint);\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/algapi.h>",
            "#include <crypto/hash.h>",
            "#include <linux/magic.h>",
            "#include <linux/evm.h>",
            "#include <linux/integrity.h>",
            "#include <linux/xattr.h>",
            "#include <linux/audit.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int evm_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/algapi.h>\n#include <crypto/hash.h>\n#include <linux/magic.h>\n#include <linux/evm.h>\n#include <linux/integrity.h>\n#include <linux/xattr.h>\n#include <linux/audit.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\nint evm_initialized;\n\nenum integrity_status evm_verifyxattr(struct dentry *dentry,\n\t\t\t\t      const char *xattr_name,\n\t\t\t\t      void *xattr_value, size_t xattr_value_len,\n\t\t\t\t      struct integrity_iint_cache *iint)\n{\n\tif (!evm_initialized || !evm_protected_xattr(xattr_name))\n\t\treturn INTEGRITY_UNKNOWN;\n\n\tif (!iint) {\n\t\tiint = integrity_iint_find(d_backing_inode(dentry));\n\t\tif (!iint)\n\t\t\treturn INTEGRITY_UNKNOWN;\n\t}\n\treturn evm_verify_hmac(dentry, xattr_name, xattr_value,\n\t\t\t\t xattr_value_len, iint);\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_dentry",
          "args": [
            "file"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_appraise_measurement(enum ima_hooks func,\n\t\t\t     struct integrity_iint_cache *iint,\n\t\t\t     struct file *file, const unsigned char *filename,\n\t\t\t     struct evm_ima_xattr_data *xattr_value,\n\t\t\t     int xattr_len, int opened)\n{\n\tstatic const char op[] = \"appraise_data\";\n\tchar *cause = \"unknown\";\n\tstruct dentry *dentry = file_dentry(file);\n\tstruct inode *inode = d_backing_inode(dentry);\n\tenum integrity_status status = INTEGRITY_UNKNOWN;\n\tint rc = xattr_len, hash_start = 0;\n\n\tif (!(inode->i_opflags & IOP_XATTR))\n\t\treturn INTEGRITY_UNKNOWN;\n\n\tif (rc <= 0) {\n\t\tif (rc && rc != -ENODATA)\n\t\t\tgoto out;\n\n\t\tcause = iint->flags & IMA_DIGSIG_REQUIRED ?\n\t\t\t\t\"IMA-signature-required\" : \"missing-hash\";\n\t\tstatus = INTEGRITY_NOLABEL;\n\t\tif (opened & FILE_CREATED)\n\t\t\tiint->flags |= IMA_NEW_FILE;\n\t\tif ((iint->flags & IMA_NEW_FILE) &&\n\t\t    !(iint->flags & IMA_DIGSIG_REQUIRED))\n\t\t\tstatus = INTEGRITY_PASS;\n\t\tgoto out;\n\t}\n\n\tstatus = evm_verifyxattr(dentry, XATTR_NAME_IMA, xattr_value, rc, iint);\n\tif ((status != INTEGRITY_PASS) && (status != INTEGRITY_UNKNOWN)) {\n\t\tif ((status == INTEGRITY_NOLABEL)\n\t\t    || (status == INTEGRITY_NOXATTRS))\n\t\t\tcause = \"missing-HMAC\";\n\t\telse if (status == INTEGRITY_FAIL)\n\t\t\tcause = \"invalid-HMAC\";\n\t\tgoto out;\n\t}\n\tswitch (xattr_value->type) {\n\tcase IMA_XATTR_DIGEST_NG:\n\t\t/* first byte contains algorithm id */\n\t\thash_start = 1;\n\t\t/* fall through */\n\tcase IMA_XATTR_DIGEST:\n\t\tif (iint->flags & IMA_DIGSIG_REQUIRED) {\n\t\t\tcause = \"IMA-signature-required\";\n\t\t\tstatus = INTEGRITY_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tif (xattr_len - sizeof(xattr_value->type) - hash_start >=\n\t\t\t\tiint->ima_hash->length)\n\t\t\t/* xattr length may be longer. md5 hash in previous\n\t\t\t   version occupied 20 bytes in xattr, instead of 16\n\t\t\t */\n\t\t\trc = memcmp(&xattr_value->digest[hash_start],\n\t\t\t\t    iint->ima_hash->digest,\n\t\t\t\t    iint->ima_hash->length);\n\t\telse\n\t\t\trc = -EINVAL;\n\t\tif (rc) {\n\t\t\tcause = \"invalid-hash\";\n\t\t\tstatus = INTEGRITY_FAIL;\n\t\t\tbreak;\n\t\t}\n\t\tstatus = INTEGRITY_PASS;\n\t\tbreak;\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\tiint->flags |= IMA_DIGSIG;\n\t\trc = integrity_digsig_verify(INTEGRITY_KEYRING_IMA,\n\t\t\t\t\t     (const char *)xattr_value, rc,\n\t\t\t\t\t     iint->ima_hash->digest,\n\t\t\t\t\t     iint->ima_hash->length);\n\t\tif (rc == -EOPNOTSUPP) {\n\t\t\tstatus = INTEGRITY_UNKNOWN;\n\t\t} else if (rc) {\n\t\t\tcause = \"invalid-signature\";\n\t\t\tstatus = INTEGRITY_FAIL;\n\t\t} else {\n\t\t\tstatus = INTEGRITY_PASS;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tstatus = INTEGRITY_UNKNOWN;\n\t\tcause = \"unknown-ima-data\";\n\t\tbreak;\n\t}\n\nout:\n\tif (status != INTEGRITY_PASS) {\n\t\tif ((ima_appraise & IMA_APPRAISE_FIX) &&\n\t\t    (!xattr_value ||\n\t\t     xattr_value->type != EVM_IMA_XATTR_DIGSIG)) {\n\t\t\tif (!ima_fix_xattr(dentry, iint))\n\t\t\t\tstatus = INTEGRITY_PASS;\n\t\t} else if ((inode->i_size == 0) &&\n\t\t\t   (iint->flags & IMA_NEW_FILE) &&\n\t\t\t   (xattr_value &&\n\t\t\t    xattr_value->type == EVM_IMA_XATTR_DIGSIG)) {\n\t\t\tstatus = INTEGRITY_PASS;\n\t\t}\n\t\tintegrity_audit_msg(AUDIT_INTEGRITY_DATA, inode, filename,\n\t\t\t\t    op, cause, rc, 0);\n\t} else {\n\t\tima_cache_flags(iint, func);\n\t}\n\tima_set_cache_status(iint, func, status);\n\treturn status;\n}"
  },
  {
    "function_name": "ima_read_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "180-190",
    "snippet": "int ima_read_xattr(struct dentry *dentry,\n\t\t   struct evm_ima_xattr_data **xattr_value)\n{\n\tssize_t ret;\n\n\tret = vfs_getxattr_alloc(dentry, XATTR_NAME_IMA, (char **)xattr_value,\n\t\t\t\t 0, GFP_NOFS);\n\tif (ret == -EOPNOTSUPP)\n\t\tret = 0;\n\treturn ret;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_getxattr_alloc",
          "args": [
            "dentry",
            "XATTR_NAME_IMA",
            "(char **)xattr_value",
            "0",
            "GFP_NOFS"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_read_xattr(struct dentry *dentry,\n\t\t   struct evm_ima_xattr_data **xattr_value)\n{\n\tssize_t ret;\n\n\tret = vfs_getxattr_alloc(dentry, XATTR_NAME_IMA, (char **)xattr_value,\n\t\t\t\t 0, GFP_NOFS);\n\tif (ret == -EOPNOTSUPP)\n\t\tret = 0;\n\treturn ret;\n}"
  },
  {
    "function_name": "ima_get_hash_algo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "141-178",
    "snippet": "enum hash_algo ima_get_hash_algo(struct evm_ima_xattr_data *xattr_value,\n\t\t\t\t int xattr_len)\n{\n\tstruct signature_v2_hdr *sig;\n\tenum hash_algo ret;\n\n\tif (!xattr_value || xattr_len < 2)\n\t\t/* return default hash algo */\n\t\treturn ima_hash_algo;\n\n\tswitch (xattr_value->type) {\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\tsig = (typeof(sig))xattr_value;\n\t\tif (sig->version != 2 || xattr_len <= sizeof(*sig))\n\t\t\treturn ima_hash_algo;\n\t\treturn sig->hash_algo;\n\t\tbreak;\n\tcase IMA_XATTR_DIGEST_NG:\n\t\tret = xattr_value->digest[0];\n\t\tif (ret < HASH_ALGO__LAST)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase IMA_XATTR_DIGEST:\n\t\t/* this is for backward compatibility */\n\t\tif (xattr_len == 21) {\n\t\t\tunsigned int zero = 0;\n\t\t\tif (!memcmp(&xattr_value->digest[16], &zero, 4))\n\t\t\t\treturn HASH_ALGO_MD5;\n\t\t\telse\n\t\t\t\treturn HASH_ALGO_SHA1;\n\t\t} else if (xattr_len == 17)\n\t\t\treturn HASH_ALGO_MD5;\n\t\tbreak;\n\t}\n\n\t/* return default hash algo */\n\treturn ima_hash_algo;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&xattr_value->digest[16]",
            "&zero",
            "4"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nenum hash_algo ima_get_hash_algo(struct evm_ima_xattr_data *xattr_value,\n\t\t\t\t int xattr_len)\n{\n\tstruct signature_v2_hdr *sig;\n\tenum hash_algo ret;\n\n\tif (!xattr_value || xattr_len < 2)\n\t\t/* return default hash algo */\n\t\treturn ima_hash_algo;\n\n\tswitch (xattr_value->type) {\n\tcase EVM_IMA_XATTR_DIGSIG:\n\t\tsig = (typeof(sig))xattr_value;\n\t\tif (sig->version != 2 || xattr_len <= sizeof(*sig))\n\t\t\treturn ima_hash_algo;\n\t\treturn sig->hash_algo;\n\t\tbreak;\n\tcase IMA_XATTR_DIGEST_NG:\n\t\tret = xattr_value->digest[0];\n\t\tif (ret < HASH_ALGO__LAST)\n\t\t\treturn ret;\n\t\tbreak;\n\tcase IMA_XATTR_DIGEST:\n\t\t/* this is for backward compatibility */\n\t\tif (xattr_len == 21) {\n\t\t\tunsigned int zero = 0;\n\t\t\tif (!memcmp(&xattr_value->digest[16], &zero, 4))\n\t\t\t\treturn HASH_ALGO_MD5;\n\t\t\telse\n\t\t\t\treturn HASH_ALGO_SHA1;\n\t\t} else if (xattr_len == 17)\n\t\t\treturn HASH_ALGO_MD5;\n\t\tbreak;\n\t}\n\n\t/* return default hash algo */\n\treturn ima_hash_algo;\n}"
  },
  {
    "function_name": "ima_cache_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "120-139",
    "snippet": "static void ima_cache_flags(struct integrity_iint_cache *iint,\n\t\t\t     enum ima_hooks func)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\tiint->flags |= (IMA_MMAP_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase BPRM_CHECK:\n\t\tiint->flags |= (IMA_BPRM_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\tiint->flags |= (IMA_FILE_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\tiint->flags |= (IMA_READ_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void ima_cache_flags(struct integrity_iint_cache *iint,\n\t\t\t     enum ima_hooks func)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\tiint->flags |= (IMA_MMAP_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase BPRM_CHECK:\n\t\tiint->flags |= (IMA_BPRM_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\tiint->flags |= (IMA_FILE_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\tiint->flags |= (IMA_READ_APPRAISED | IMA_APPRAISED);\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "ima_set_cache_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "98-118",
    "snippet": "static void ima_set_cache_status(struct integrity_iint_cache *iint,\n\t\t\t\t enum ima_hooks func,\n\t\t\t\t enum integrity_status status)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\tiint->ima_mmap_status = status;\n\t\tbreak;\n\tcase BPRM_CHECK:\n\t\tiint->ima_bprm_status = status;\n\t\tbreak;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\tiint->ima_file_status = status;\n\t\tbreak;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\tiint->ima_read_status = status;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic void ima_set_cache_status(struct integrity_iint_cache *iint,\n\t\t\t\t enum ima_hooks func,\n\t\t\t\t enum integrity_status status)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\tiint->ima_mmap_status = status;\n\t\tbreak;\n\tcase BPRM_CHECK:\n\t\tiint->ima_bprm_status = status;\n\t\tbreak;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\tiint->ima_file_status = status;\n\t\tbreak;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\tiint->ima_read_status = status;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "ima_get_cache_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "81-96",
    "snippet": "enum integrity_status ima_get_cache_status(struct integrity_iint_cache *iint,\n\t\t\t\t\t   enum ima_hooks func)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\treturn iint->ima_mmap_status;\n\tcase BPRM_CHECK:\n\t\treturn iint->ima_bprm_status;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\treturn iint->ima_file_status;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\treturn iint->ima_read_status;\n\t}\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nenum integrity_status ima_get_cache_status(struct integrity_iint_cache *iint,\n\t\t\t\t\t   enum ima_hooks func)\n{\n\tswitch (func) {\n\tcase MMAP_CHECK:\n\t\treturn iint->ima_mmap_status;\n\tcase BPRM_CHECK:\n\t\treturn iint->ima_bprm_status;\n\tcase FILE_CHECK:\n\tcase POST_SETATTR:\n\t\treturn iint->ima_file_status;\n\tcase MODULE_CHECK ... MAX_CHECK - 1:\n\tdefault:\n\t\treturn iint->ima_read_status;\n\t}\n}"
  },
  {
    "function_name": "ima_fix_xattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "59-78",
    "snippet": "static int ima_fix_xattr(struct dentry *dentry,\n\t\t\t struct integrity_iint_cache *iint)\n{\n\tint rc, offset;\n\tu8 algo = iint->ima_hash->algo;\n\n\tif (algo <= HASH_ALGO_SHA1) {\n\t\toffset = 1;\n\t\tiint->ima_hash->xattr.sha1.type = IMA_XATTR_DIGEST;\n\t} else {\n\t\toffset = 0;\n\t\tiint->ima_hash->xattr.ng.type = IMA_XATTR_DIGEST_NG;\n\t\tiint->ima_hash->xattr.ng.algo = algo;\n\t}\n\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_IMA,\n\t\t\t\t   &iint->ima_hash->xattr.data[offset],\n\t\t\t\t   (sizeof(iint->ima_hash->xattr) - offset) +\n\t\t\t\t   iint->ima_hash->length, 0);\n\treturn rc;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vfs_setxattr_noperm",
          "args": [
            "dentry",
            "XATTR_NAME_IMA",
            "&iint->ima_hash->xattr.data[offset]",
            "(sizeof(iint->ima_hash->xattr) - offset) +\n\t\t\t\t   iint->ima_hash->length",
            "0"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int ima_fix_xattr(struct dentry *dentry,\n\t\t\t struct integrity_iint_cache *iint)\n{\n\tint rc, offset;\n\tu8 algo = iint->ima_hash->algo;\n\n\tif (algo <= HASH_ALGO_SHA1) {\n\t\toffset = 1;\n\t\tiint->ima_hash->xattr.sha1.type = IMA_XATTR_DIGEST;\n\t} else {\n\t\toffset = 0;\n\t\tiint->ima_hash->xattr.ng.type = IMA_XATTR_DIGEST_NG;\n\t\tiint->ima_hash->xattr.ng.algo = algo;\n\t}\n\trc = __vfs_setxattr_noperm(dentry, XATTR_NAME_IMA,\n\t\t\t\t   &iint->ima_hash->xattr.data[offset],\n\t\t\t\t   (sizeof(iint->ima_hash->xattr) - offset) +\n\t\t\t\t   iint->ima_hash->length, 0);\n\treturn rc;\n}"
  },
  {
    "function_name": "ima_must_appraise",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "51-57",
    "snippet": "int ima_must_appraise(struct inode *inode, int mask, enum ima_hooks func)\n{\n\tif (!ima_appraise)\n\t\treturn 0;\n\n\treturn ima_match_policy(inode, func, mask, IMA_APPRAISE, NULL);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_match_policy",
          "args": [
            "inode",
            "func",
            "mask",
            "IMA_APPRAISE",
            "NULL"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "ima_match_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_policy.c",
          "lines": "365-400",
          "snippet": "int ima_match_policy(struct inode *inode, enum ima_hooks func, int mask,\n\t\t     int flags, int *pcr)\n{\n\tstruct ima_rule_entry *entry;\n\tint action = 0, actmask = flags | (flags << 1);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, ima_rules, list) {\n\n\t\tif (!(entry->action & actmask))\n\t\t\tcontinue;\n\n\t\tif (!ima_match_rules(entry, inode, func, mask))\n\t\t\tcontinue;\n\n\t\taction |= entry->flags & IMA_ACTION_FLAGS;\n\n\t\taction |= entry->action & IMA_DO_MASK;\n\t\tif (entry->action & IMA_APPRAISE)\n\t\t\taction |= get_subaction(entry, func);\n\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tactmask &= ~(entry->action | entry->action << 1);\n\t\telse\n\t\t\tactmask &= ~(entry->action | entry->action >> 1);\n\n\t\tif ((pcr) && (entry->flags & IMA_PCR))\n\t\t\t*pcr = entry->pcr;\n\n\t\tif (!actmask)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn action;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/genhd.h>",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/parser.h>",
            "#include <linux/magic.h>",
            "#include <linux/security.h>",
            "#include <linux/fs.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define IMA_PCR\t\t0x0100"
          ],
          "globals_used": [
            "static struct list_head *ima_rules;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/seq_file.h>\n#include <linux/genhd.h>\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/parser.h>\n#include <linux/magic.h>\n#include <linux/security.h>\n#include <linux/fs.h>\n#include <linux/list.h>\n#include <linux/module.h>\n\n#define IMA_PCR\t\t0x0100\n\nstatic struct list_head *ima_rules;\n\nint ima_match_policy(struct inode *inode, enum ima_hooks func, int mask,\n\t\t     int flags, int *pcr)\n{\n\tstruct ima_rule_entry *entry;\n\tint action = 0, actmask = flags | (flags << 1);\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(entry, ima_rules, list) {\n\n\t\tif (!(entry->action & actmask))\n\t\t\tcontinue;\n\n\t\tif (!ima_match_rules(entry, inode, func, mask))\n\t\t\tcontinue;\n\n\t\taction |= entry->flags & IMA_ACTION_FLAGS;\n\n\t\taction |= entry->action & IMA_DO_MASK;\n\t\tif (entry->action & IMA_APPRAISE)\n\t\t\taction |= get_subaction(entry, func);\n\n\t\tif (entry->action & IMA_DO_MASK)\n\t\t\tactmask &= ~(entry->action | entry->action << 1);\n\t\telse\n\t\t\tactmask &= ~(entry->action | entry->action >> 1);\n\n\t\tif ((pcr) && (entry->flags & IMA_PCR))\n\t\t\t*pcr = entry->pcr;\n\n\t\tif (!actmask)\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n\n\treturn action;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nint ima_must_appraise(struct inode *inode, int mask, enum ima_hooks func)\n{\n\tif (!ima_appraise)\n\t\treturn 0;\n\n\treturn ima_match_policy(inode, func, mask, IMA_APPRAISE, NULL);\n}"
  },
  {
    "function_name": "is_ima_appraise_enabled",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "41-44",
    "snippet": "bool is_ima_appraise_enabled(void)\n{\n\treturn ima_appraise & IMA_APPRAISE_ENFORCE;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nbool is_ima_appraise_enabled(void)\n{\n\treturn ima_appraise & IMA_APPRAISE_ENFORCE;\n}"
  },
  {
    "function_name": "default_appraise_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_appraise.c",
    "lines": "21-32",
    "snippet": "static int __init default_appraise_setup(char *str)\n{\n#ifdef CONFIG_IMA_APPRAISE_BOOTPARAM\n\tif (strncmp(str, \"off\", 3) == 0)\n\t\tima_appraise = 0;\n\telse if (strncmp(str, \"log\", 3) == 0)\n\t\tima_appraise = IMA_APPRAISE_LOG;\n\telse if (strncmp(str, \"fix\", 3) == 0)\n\t\tima_appraise = IMA_APPRAISE_FIX;\n#endif\n\treturn 1;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/evm.h>",
      "#include <linux/ima.h>",
      "#include <linux/magic.h>",
      "#include <linux/xattr.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"fix\"",
            "3"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"log\"",
            "3"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"off\"",
            "3"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/magic.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/module.h>\n\nstatic int __init default_appraise_setup(char *str)\n{\n#ifdef CONFIG_IMA_APPRAISE_BOOTPARAM\n\tif (strncmp(str, \"off\", 3) == 0)\n\t\tima_appraise = 0;\n\telse if (strncmp(str, \"log\", 3) == 0)\n\t\tima_appraise = IMA_APPRAISE_LOG;\n\telse if (strncmp(str, \"fix\", 3) == 0)\n\t\tima_appraise = IMA_APPRAISE_FIX;\n#endif\n\treturn 1;\n}"
  }
]