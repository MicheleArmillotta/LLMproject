[
  {
    "function_name": "tomoyo_initerface_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/securityfs_if.c",
    "lines": "235-266",
    "snippet": "static int __init tomoyo_initerface_init(void)\n{\n\tstruct dentry *tomoyo_dir;\n\n\t/* Don't create securityfs entries unless registered. */\n\tif (current_cred()->security != &tomoyo_kernel_domain)\n\t\treturn 0;\n\n\ttomoyo_dir = securityfs_create_dir(\"tomoyo\", NULL);\n\ttomoyo_create_entry(\"query\",            0600, tomoyo_dir,\n\t\t\t    TOMOYO_QUERY);\n\ttomoyo_create_entry(\"domain_policy\",    0600, tomoyo_dir,\n\t\t\t    TOMOYO_DOMAINPOLICY);\n\ttomoyo_create_entry(\"exception_policy\", 0600, tomoyo_dir,\n\t\t\t    TOMOYO_EXCEPTIONPOLICY);\n\ttomoyo_create_entry(\"audit\",            0400, tomoyo_dir,\n\t\t\t    TOMOYO_AUDIT);\n\ttomoyo_create_entry(\".process_status\",  0600, tomoyo_dir,\n\t\t\t    TOMOYO_PROCESS_STATUS);\n\ttomoyo_create_entry(\"stat\",             0644, tomoyo_dir,\n\t\t\t    TOMOYO_STAT);\n\ttomoyo_create_entry(\"profile\",          0600, tomoyo_dir,\n\t\t\t    TOMOYO_PROFILE);\n\ttomoyo_create_entry(\"manager\",          0600, tomoyo_dir,\n\t\t\t    TOMOYO_MANAGER);\n\ttomoyo_create_entry(\"version\",          0400, tomoyo_dir,\n\t\t\t    TOMOYO_VERSION);\n\tsecurityfs_create_file(\"self_domain\", 0666, tomoyo_dir, NULL,\n\t\t\t       &tomoyo_self_operations);\n\ttomoyo_load_builtin_policy();\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations tomoyo_self_operations = {\n\t.write = tomoyo_write_self,\n\t.read  = tomoyo_read_self,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_load_builtin_policy",
          "args": [],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_load_builtin_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2734-2790",
          "snippet": "void __init tomoyo_load_builtin_policy(void)\n{\n\t/*\n\t * This include file is manually created and contains built-in policy\n\t * named \"tomoyo_builtin_profile\", \"tomoyo_builtin_exception_policy\",\n\t * \"tomoyo_builtin_domain_policy\", \"tomoyo_builtin_manager\",\n\t * \"tomoyo_builtin_stat\" in the form of \"static char [] __initdata\".\n\t */\n#include \"builtin-policy.h\"\n\tu8 i;\n\tconst int idx = tomoyo_read_lock();\n\tfor (i = 0; i < 5; i++) {\n\t\tstruct tomoyo_io_buffer head = { };\n\t\tchar *start = \"\";\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tstart = tomoyo_builtin_profile;\n\t\t\thead.type = TOMOYO_PROFILE;\n\t\t\thead.write = tomoyo_write_profile;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstart = tomoyo_builtin_exception_policy;\n\t\t\thead.type = TOMOYO_EXCEPTIONPOLICY;\n\t\t\thead.write = tomoyo_write_exception;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = tomoyo_builtin_domain_policy;\n\t\t\thead.type = TOMOYO_DOMAINPOLICY;\n\t\t\thead.write = tomoyo_write_domain;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstart = tomoyo_builtin_manager;\n\t\t\thead.type = TOMOYO_MANAGER;\n\t\t\thead.write = tomoyo_write_manager;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tstart = tomoyo_builtin_stat;\n\t\t\thead.type = TOMOYO_STAT;\n\t\t\thead.write = tomoyo_write_stat;\n\t\t\tbreak;\n\t\t}\n\t\twhile (1) {\n\t\t\tchar *end = strchr(start, '\\n');\n\t\t\tif (!end)\n\t\t\t\tbreak;\n\t\t\t*end = '\\0';\n\t\t\ttomoyo_normalize_line(start);\n\t\t\thead.write_buf = start;\n\t\t\ttomoyo_parse_policy(&head, start);\n\t\t\tstart = end + 1;\n\t\t}\n\t}\n\ttomoyo_read_unlock(idx);\n#ifdef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER\n\ttomoyo_check_profile();\n#endif\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nvoid __init tomoyo_load_builtin_policy(void)\n{\n\t/*\n\t * This include file is manually created and contains built-in policy\n\t * named \"tomoyo_builtin_profile\", \"tomoyo_builtin_exception_policy\",\n\t * \"tomoyo_builtin_domain_policy\", \"tomoyo_builtin_manager\",\n\t * \"tomoyo_builtin_stat\" in the form of \"static char [] __initdata\".\n\t */\n#include \"builtin-policy.h\"\n\tu8 i;\n\tconst int idx = tomoyo_read_lock();\n\tfor (i = 0; i < 5; i++) {\n\t\tstruct tomoyo_io_buffer head = { };\n\t\tchar *start = \"\";\n\t\tswitch (i) {\n\t\tcase 0:\n\t\t\tstart = tomoyo_builtin_profile;\n\t\t\thead.type = TOMOYO_PROFILE;\n\t\t\thead.write = tomoyo_write_profile;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tstart = tomoyo_builtin_exception_policy;\n\t\t\thead.type = TOMOYO_EXCEPTIONPOLICY;\n\t\t\thead.write = tomoyo_write_exception;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tstart = tomoyo_builtin_domain_policy;\n\t\t\thead.type = TOMOYO_DOMAINPOLICY;\n\t\t\thead.write = tomoyo_write_domain;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tstart = tomoyo_builtin_manager;\n\t\t\thead.type = TOMOYO_MANAGER;\n\t\t\thead.write = tomoyo_write_manager;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tstart = tomoyo_builtin_stat;\n\t\t\thead.type = TOMOYO_STAT;\n\t\t\thead.write = tomoyo_write_stat;\n\t\t\tbreak;\n\t\t}\n\t\twhile (1) {\n\t\t\tchar *end = strchr(start, '\\n');\n\t\t\tif (!end)\n\t\t\t\tbreak;\n\t\t\t*end = '\\0';\n\t\t\ttomoyo_normalize_line(start);\n\t\t\thead.write_buf = start;\n\t\t\ttomoyo_parse_policy(&head, start);\n\t\t\tstart = end + 1;\n\t\t}\n\t}\n\ttomoyo_read_unlock(idx);\n#ifdef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER\n\ttomoyo_check_profile();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "securityfs_create_file",
          "args": [
            "\"self_domain\"",
            "0666",
            "tomoyo_dir",
            "NULL",
            "&tomoyo_self_operations"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "194-199",
          "snippet": "struct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_create_entry",
          "args": [
            "\"version\"",
            "0400",
            "tomoyo_dir",
            "TOMOYO_VERSION"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_create_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/securityfs_if.c",
          "lines": "223-228",
          "snippet": "static void __init tomoyo_create_entry(const char *name, const umode_t mode,\n\t\t\t\t       struct dentry *parent, const u8 key)\n{\n\tsecurityfs_create_file(name, mode, parent, ((u8 *) NULL) + key,\n\t\t\t       &tomoyo_operations);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/security.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct file_operations tomoyo_operations = {\n\t.open    = tomoyo_open,\n\t.release = tomoyo_release,\n\t.poll    = tomoyo_poll,\n\t.read    = tomoyo_read,\n\t.write   = tomoyo_write,\n\t.llseek  = noop_llseek,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/security.h>\n\nstatic const struct file_operations tomoyo_operations = {\n\t.open    = tomoyo_open,\n\t.release = tomoyo_release,\n\t.poll    = tomoyo_poll,\n\t.read    = tomoyo_read,\n\t.write   = tomoyo_write,\n\t.llseek  = noop_llseek,\n};\n\nstatic void __init tomoyo_create_entry(const char *name, const umode_t mode,\n\t\t\t\t       struct dentry *parent, const u8 key)\n{\n\tsecurityfs_create_file(name, mode, parent, ((u8 *) NULL) + key,\n\t\t\t       &tomoyo_operations);\n}"
        }
      },
      {
        "call_info": {
          "callee": "securityfs_create_dir",
          "args": [
            "\"tomoyo\"",
            "NULL"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "222-225",
          "snippet": "struct dentry *securityfs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn securityfs_create_file(name, S_IFDIR | 0755, parent, NULL, NULL);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_dir(const char *name, struct dentry *parent)\n{\n\treturn securityfs_create_file(name, S_IFDIR | 0755, parent, NULL, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/security.h>\n\nstatic const struct file_operations tomoyo_self_operations = {\n\t.write = tomoyo_write_self,\n\t.read  = tomoyo_read_self,\n};\n\nstatic int __init tomoyo_initerface_init(void)\n{\n\tstruct dentry *tomoyo_dir;\n\n\t/* Don't create securityfs entries unless registered. */\n\tif (current_cred()->security != &tomoyo_kernel_domain)\n\t\treturn 0;\n\n\ttomoyo_dir = securityfs_create_dir(\"tomoyo\", NULL);\n\ttomoyo_create_entry(\"query\",            0600, tomoyo_dir,\n\t\t\t    TOMOYO_QUERY);\n\ttomoyo_create_entry(\"domain_policy\",    0600, tomoyo_dir,\n\t\t\t    TOMOYO_DOMAINPOLICY);\n\ttomoyo_create_entry(\"exception_policy\", 0600, tomoyo_dir,\n\t\t\t    TOMOYO_EXCEPTIONPOLICY);\n\ttomoyo_create_entry(\"audit\",            0400, tomoyo_dir,\n\t\t\t    TOMOYO_AUDIT);\n\ttomoyo_create_entry(\".process_status\",  0600, tomoyo_dir,\n\t\t\t    TOMOYO_PROCESS_STATUS);\n\ttomoyo_create_entry(\"stat\",             0644, tomoyo_dir,\n\t\t\t    TOMOYO_STAT);\n\ttomoyo_create_entry(\"profile\",          0600, tomoyo_dir,\n\t\t\t    TOMOYO_PROFILE);\n\ttomoyo_create_entry(\"manager\",          0600, tomoyo_dir,\n\t\t\t    TOMOYO_MANAGER);\n\ttomoyo_create_entry(\"version\",          0400, tomoyo_dir,\n\t\t\t    TOMOYO_VERSION);\n\tsecurityfs_create_file(\"self_domain\", 0666, tomoyo_dir, NULL,\n\t\t\t       &tomoyo_self_operations);\n\ttomoyo_load_builtin_policy();\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_create_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/securityfs_if.c",
    "lines": "223-228",
    "snippet": "static void __init tomoyo_create_entry(const char *name, const umode_t mode,\n\t\t\t\t       struct dentry *parent, const u8 key)\n{\n\tsecurityfs_create_file(name, mode, parent, ((u8 *) NULL) + key,\n\t\t\t       &tomoyo_operations);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations tomoyo_operations = {\n\t.open    = tomoyo_open,\n\t.release = tomoyo_release,\n\t.poll    = tomoyo_poll,\n\t.read    = tomoyo_read,\n\t.write   = tomoyo_write,\n\t.llseek  = noop_llseek,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "securityfs_create_file",
          "args": [
            "name",
            "mode",
            "parent",
            "((u8 *) NULL) + key",
            "&tomoyo_operations"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "194-199",
          "snippet": "struct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/security.h>\n\nstatic const struct file_operations tomoyo_operations = {\n\t.open    = tomoyo_open,\n\t.release = tomoyo_release,\n\t.poll    = tomoyo_poll,\n\t.read    = tomoyo_read,\n\t.write   = tomoyo_write,\n\t.llseek  = noop_llseek,\n};\n\nstatic void __init tomoyo_create_entry(const char *name, const umode_t mode,\n\t\t\t\t       struct dentry *parent, const u8 key)\n{\n\tsecurityfs_create_file(name, mode, parent, ((u8 *) NULL) + key,\n\t\t\t       &tomoyo_operations);\n}"
  },
  {
    "function_name": "tomoyo_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/securityfs_if.c",
    "lines": "191-195",
    "snippet": "static ssize_t tomoyo_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn tomoyo_write_control(file->private_data, buf, count);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_write_control",
          "args": [
            "file->private_data",
            "buf",
            "count"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_write_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2584-2677",
          "snippet": "ssize_t tomoyo_write_control(struct tomoyo_io_buffer *head,\n\t\t\t     const char __user *buffer, const int buffer_len)\n{\n\tint error = buffer_len;\n\tsize_t avail_len = buffer_len;\n\tchar *cp0 = head->write_buf;\n\tint idx;\n\tif (!head->write)\n\t\treturn -ENOSYS;\n\tif (!access_ok(VERIFY_READ, buffer, buffer_len))\n\t\treturn -EFAULT;\n\tif (mutex_lock_interruptible(&head->io_sem))\n\t\treturn -EINTR;\n\thead->read_user_buf_avail = 0;\n\tidx = tomoyo_read_lock();\n\t/* Read a line and dispatch it to the policy handler. */\n\twhile (avail_len > 0) {\n\t\tchar c;\n\t\tif (head->w.avail >= head->writebuf_size - 1) {\n\t\t\tconst int len = head->writebuf_size * 2;\n\t\t\tchar *cp = kzalloc(len, GFP_NOFS);\n\t\t\tif (!cp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemmove(cp, cp0, head->w.avail);\n\t\t\tkfree(cp0);\n\t\t\thead->write_buf = cp;\n\t\t\tcp0 = cp;\n\t\t\thead->writebuf_size = len;\n\t\t}\n\t\tif (get_user(c, buffer)) {\n\t\t\terror = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer++;\n\t\tavail_len--;\n\t\tcp0[head->w.avail++] = c;\n\t\tif (c != '\\n')\n\t\t\tcontinue;\n\t\tcp0[head->w.avail - 1] = '\\0';\n\t\thead->w.avail = 0;\n\t\ttomoyo_normalize_line(cp0);\n\t\tif (!strcmp(cp0, \"reset\")) {\n\t\t\thead->w.ns = &tomoyo_kernel_namespace;\n\t\t\thead->w.domain = NULL;\n\t\t\tmemset(&head->r, 0, sizeof(head->r));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Don't allow updating policies by non manager programs. */\n\t\tswitch (head->type) {\n\t\tcase TOMOYO_PROCESS_STATUS:\n\t\t\t/* This does not write anything. */\n\t\t\tbreak;\n\t\tcase TOMOYO_DOMAINPOLICY:\n\t\t\tif (tomoyo_select_domain(head, cp0))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t\tif (!strcmp(cp0, \"select transition_only\")) {\n\t\t\t\thead->r.print_transition_related_only = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tif (!tomoyo_manager()) {\n\t\t\t\terror = -EPERM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tswitch (tomoyo_parse_policy(head, cp0)) {\n\t\tcase -EPERM:\n\t\t\terror = -EPERM;\n\t\t\tgoto out;\n\t\tcase 0:\n\t\t\tswitch (head->type) {\n\t\t\tcase TOMOYO_DOMAINPOLICY:\n\t\t\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t\tcase TOMOYO_STAT:\n\t\t\tcase TOMOYO_PROFILE:\n\t\t\tcase TOMOYO_MANAGER:\n\t\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\ttomoyo_read_unlock(idx);\n\tmutex_unlock(&head->io_sem);\n\treturn error;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nssize_t tomoyo_write_control(struct tomoyo_io_buffer *head,\n\t\t\t     const char __user *buffer, const int buffer_len)\n{\n\tint error = buffer_len;\n\tsize_t avail_len = buffer_len;\n\tchar *cp0 = head->write_buf;\n\tint idx;\n\tif (!head->write)\n\t\treturn -ENOSYS;\n\tif (!access_ok(VERIFY_READ, buffer, buffer_len))\n\t\treturn -EFAULT;\n\tif (mutex_lock_interruptible(&head->io_sem))\n\t\treturn -EINTR;\n\thead->read_user_buf_avail = 0;\n\tidx = tomoyo_read_lock();\n\t/* Read a line and dispatch it to the policy handler. */\n\twhile (avail_len > 0) {\n\t\tchar c;\n\t\tif (head->w.avail >= head->writebuf_size - 1) {\n\t\t\tconst int len = head->writebuf_size * 2;\n\t\t\tchar *cp = kzalloc(len, GFP_NOFS);\n\t\t\tif (!cp) {\n\t\t\t\terror = -ENOMEM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmemmove(cp, cp0, head->w.avail);\n\t\t\tkfree(cp0);\n\t\t\thead->write_buf = cp;\n\t\t\tcp0 = cp;\n\t\t\thead->writebuf_size = len;\n\t\t}\n\t\tif (get_user(c, buffer)) {\n\t\t\terror = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\tbuffer++;\n\t\tavail_len--;\n\t\tcp0[head->w.avail++] = c;\n\t\tif (c != '\\n')\n\t\t\tcontinue;\n\t\tcp0[head->w.avail - 1] = '\\0';\n\t\thead->w.avail = 0;\n\t\ttomoyo_normalize_line(cp0);\n\t\tif (!strcmp(cp0, \"reset\")) {\n\t\t\thead->w.ns = &tomoyo_kernel_namespace;\n\t\t\thead->w.domain = NULL;\n\t\t\tmemset(&head->r, 0, sizeof(head->r));\n\t\t\tcontinue;\n\t\t}\n\t\t/* Don't allow updating policies by non manager programs. */\n\t\tswitch (head->type) {\n\t\tcase TOMOYO_PROCESS_STATUS:\n\t\t\t/* This does not write anything. */\n\t\t\tbreak;\n\t\tcase TOMOYO_DOMAINPOLICY:\n\t\t\tif (tomoyo_select_domain(head, cp0))\n\t\t\t\tcontinue;\n\t\t\t/* fall through */\n\t\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t\tif (!strcmp(cp0, \"select transition_only\")) {\n\t\t\t\thead->r.print_transition_related_only = true;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* fall through */\n\t\tdefault:\n\t\t\tif (!tomoyo_manager()) {\n\t\t\t\terror = -EPERM;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tswitch (tomoyo_parse_policy(head, cp0)) {\n\t\tcase -EPERM:\n\t\t\terror = -EPERM;\n\t\t\tgoto out;\n\t\tcase 0:\n\t\t\tswitch (head->type) {\n\t\t\tcase TOMOYO_DOMAINPOLICY:\n\t\t\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t\tcase TOMOYO_STAT:\n\t\t\tcase TOMOYO_PROFILE:\n\t\t\tcase TOMOYO_MANAGER:\n\t\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\ttomoyo_read_unlock(idx);\n\tmutex_unlock(&head->io_sem);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/security.h>\n\nstatic ssize_t tomoyo_write(struct file *file, const char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\treturn tomoyo_write_control(file->private_data, buf, count);\n}"
  },
  {
    "function_name": "tomoyo_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/securityfs_if.c",
    "lines": "175-179",
    "snippet": "static ssize_t tomoyo_read(struct file *file, char __user *buf, size_t count,\n\t\t\t   loff_t *ppos)\n{\n\treturn tomoyo_read_control(file->private_data, buf, count);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_read_control",
          "args": [
            "file->private_data",
            "buf",
            "count"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2512-2536",
          "snippet": "ssize_t tomoyo_read_control(struct tomoyo_io_buffer *head, char __user *buffer,\n\t\t\t    const int buffer_len)\n{\n\tint len;\n\tint idx;\n\n\tif (!head->read)\n\t\treturn -ENOSYS;\n\tif (mutex_lock_interruptible(&head->io_sem))\n\t\treturn -EINTR;\n\thead->read_user_buf = buffer;\n\thead->read_user_buf_avail = buffer_len;\n\tidx = tomoyo_read_lock();\n\tif (tomoyo_flush(head))\n\t\t/* Call the policy handler. */\n\t\tdo {\n\t\t\ttomoyo_set_namespace_cursor(head);\n\t\t\thead->read(head);\n\t\t} while (tomoyo_flush(head) &&\n\t\t\t tomoyo_has_more_namespace(head));\n\ttomoyo_read_unlock(idx);\n\tlen = head->read_user_buf - buffer;\n\tmutex_unlock(&head->io_sem);\n\treturn len;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nssize_t tomoyo_read_control(struct tomoyo_io_buffer *head, char __user *buffer,\n\t\t\t    const int buffer_len)\n{\n\tint len;\n\tint idx;\n\n\tif (!head->read)\n\t\treturn -ENOSYS;\n\tif (mutex_lock_interruptible(&head->io_sem))\n\t\treturn -EINTR;\n\thead->read_user_buf = buffer;\n\thead->read_user_buf_avail = buffer_len;\n\tidx = tomoyo_read_lock();\n\tif (tomoyo_flush(head))\n\t\t/* Call the policy handler. */\n\t\tdo {\n\t\t\ttomoyo_set_namespace_cursor(head);\n\t\t\thead->read(head);\n\t\t} while (tomoyo_flush(head) &&\n\t\t\t tomoyo_has_more_namespace(head));\n\ttomoyo_read_unlock(idx);\n\tlen = head->read_user_buf - buffer;\n\tmutex_unlock(&head->io_sem);\n\treturn len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/security.h>\n\nstatic ssize_t tomoyo_read(struct file *file, char __user *buf, size_t count,\n\t\t\t   loff_t *ppos)\n{\n\treturn tomoyo_read_control(file->private_data, buf, count);\n}"
  },
  {
    "function_name": "tomoyo_poll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/securityfs_if.c",
    "lines": "160-163",
    "snippet": "static unsigned int tomoyo_poll(struct file *file, poll_table *wait)\n{\n\treturn tomoyo_poll_control(file, wait);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_poll_control",
          "args": [
            "file",
            "wait"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_poll_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2456-2462",
          "snippet": "unsigned int tomoyo_poll_control(struct file *file, poll_table *wait)\n{\n\tstruct tomoyo_io_buffer *head = file->private_data;\n\tif (head->poll)\n\t\treturn head->poll(file, wait) | POLLOUT | POLLWRNORM;\n\treturn POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nunsigned int tomoyo_poll_control(struct file *file, poll_table *wait)\n{\n\tstruct tomoyo_io_buffer *head = file->private_data;\n\tif (head->poll)\n\t\treturn head->poll(file, wait) | POLLOUT | POLLWRNORM;\n\treturn POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/security.h>\n\nstatic unsigned int tomoyo_poll(struct file *file, poll_table *wait)\n{\n\treturn tomoyo_poll_control(file, wait);\n}"
  },
  {
    "function_name": "tomoyo_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/securityfs_if.c",
    "lines": "145-149",
    "snippet": "static int tomoyo_release(struct inode *inode, struct file *file)\n{\n\ttomoyo_close_control(file->private_data);\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_close_control",
          "args": [
            "file->private_data"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_close_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2684-2694",
          "snippet": "void tomoyo_close_control(struct tomoyo_io_buffer *head)\n{\n\t/*\n\t * If the file is /sys/kernel/security/tomoyo/query , decrement the\n\t * observer counter.\n\t */\n\tif (head->type == TOMOYO_QUERY &&\n\t    atomic_dec_and_test(&tomoyo_query_observers))\n\t\twake_up_all(&tomoyo_answer_wait);\n\ttomoyo_notify_gc(head, false);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);",
            "static atomic_t tomoyo_query_observers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);\nstatic atomic_t tomoyo_query_observers = ATOMIC_INIT(0);\n\nvoid tomoyo_close_control(struct tomoyo_io_buffer *head)\n{\n\t/*\n\t * If the file is /sys/kernel/security/tomoyo/query , decrement the\n\t * observer counter.\n\t */\n\tif (head->type == TOMOYO_QUERY &&\n\t    atomic_dec_and_test(&tomoyo_query_observers))\n\t\twake_up_all(&tomoyo_answer_wait);\n\ttomoyo_notify_gc(head, false);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/security.h>\n\nstatic int tomoyo_release(struct inode *inode, struct file *file)\n{\n\ttomoyo_close_control(file->private_data);\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/securityfs_if.c",
    "lines": "132-137",
    "snippet": "static int tomoyo_open(struct inode *inode, struct file *file)\n{\n\tconst int key = ((u8 *) file_inode(file)->i_private)\n\t\t- ((u8 *) NULL);\n\treturn tomoyo_open_control(key, file);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_open_control",
          "args": [
            "key",
            "file"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_open_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2346-2445",
          "snippet": "int tomoyo_open_control(const u8 type, struct file *file)\n{\n\tstruct tomoyo_io_buffer *head = kzalloc(sizeof(*head), GFP_NOFS);\n\n\tif (!head)\n\t\treturn -ENOMEM;\n\tmutex_init(&head->io_sem);\n\thead->type = type;\n\tswitch (type) {\n\tcase TOMOYO_DOMAINPOLICY:\n\t\t/* /sys/kernel/security/tomoyo/domain_policy */\n\t\thead->write = tomoyo_write_domain;\n\t\thead->read = tomoyo_read_domain;\n\t\tbreak;\n\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t/* /sys/kernel/security/tomoyo/exception_policy */\n\t\thead->write = tomoyo_write_exception;\n\t\thead->read = tomoyo_read_exception;\n\t\tbreak;\n\tcase TOMOYO_AUDIT:\n\t\t/* /sys/kernel/security/tomoyo/audit */\n\t\thead->poll = tomoyo_poll_log;\n\t\thead->read = tomoyo_read_log;\n\t\tbreak;\n\tcase TOMOYO_PROCESS_STATUS:\n\t\t/* /sys/kernel/security/tomoyo/.process_status */\n\t\thead->write = tomoyo_write_pid;\n\t\thead->read = tomoyo_read_pid;\n\t\tbreak;\n\tcase TOMOYO_VERSION:\n\t\t/* /sys/kernel/security/tomoyo/version */\n\t\thead->read = tomoyo_read_version;\n\t\thead->readbuf_size = 128;\n\t\tbreak;\n\tcase TOMOYO_STAT:\n\t\t/* /sys/kernel/security/tomoyo/stat */\n\t\thead->write = tomoyo_write_stat;\n\t\thead->read = tomoyo_read_stat;\n\t\thead->readbuf_size = 1024;\n\t\tbreak;\n\tcase TOMOYO_PROFILE:\n\t\t/* /sys/kernel/security/tomoyo/profile */\n\t\thead->write = tomoyo_write_profile;\n\t\thead->read = tomoyo_read_profile;\n\t\tbreak;\n\tcase TOMOYO_QUERY: /* /sys/kernel/security/tomoyo/query */\n\t\thead->poll = tomoyo_poll_query;\n\t\thead->write = tomoyo_write_answer;\n\t\thead->read = tomoyo_read_query;\n\t\tbreak;\n\tcase TOMOYO_MANAGER:\n\t\t/* /sys/kernel/security/tomoyo/manager */\n\t\thead->write = tomoyo_write_manager;\n\t\thead->read = tomoyo_read_manager;\n\t\tbreak;\n\t}\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\t/*\n\t\t * No need to allocate read_buf since it is not opened\n\t\t * for reading.\n\t\t */\n\t\thead->read = NULL;\n\t\thead->poll = NULL;\n\t} else if (!head->poll) {\n\t\t/* Don't allocate read_buf for poll() access. */\n\t\tif (!head->readbuf_size)\n\t\t\thead->readbuf_size = 4096 * 2;\n\t\thead->read_buf = kzalloc(head->readbuf_size, GFP_NOFS);\n\t\tif (!head->read_buf) {\n\t\t\tkfree(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tif (!(file->f_mode & FMODE_WRITE)) {\n\t\t/*\n\t\t * No need to allocate write_buf since it is not opened\n\t\t * for writing.\n\t\t */\n\t\thead->write = NULL;\n\t} else if (head->write) {\n\t\thead->writebuf_size = 4096 * 2;\n\t\thead->write_buf = kzalloc(head->writebuf_size, GFP_NOFS);\n\t\tif (!head->write_buf) {\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\t/*\n\t * If the file is /sys/kernel/security/tomoyo/query , increment the\n\t * observer counter.\n\t * The obserber counter is used by tomoyo_supervisor() to see if\n\t * there is some process monitoring /sys/kernel/security/tomoyo/query.\n\t */\n\tif (type == TOMOYO_QUERY)\n\t\tatomic_inc(&tomoyo_query_observers);\n\tfile->private_data = head;\n\ttomoyo_notify_gc(head, true);\n\treturn 0;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static atomic_t tomoyo_query_observers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic atomic_t tomoyo_query_observers = ATOMIC_INIT(0);\n\nint tomoyo_open_control(const u8 type, struct file *file)\n{\n\tstruct tomoyo_io_buffer *head = kzalloc(sizeof(*head), GFP_NOFS);\n\n\tif (!head)\n\t\treturn -ENOMEM;\n\tmutex_init(&head->io_sem);\n\thead->type = type;\n\tswitch (type) {\n\tcase TOMOYO_DOMAINPOLICY:\n\t\t/* /sys/kernel/security/tomoyo/domain_policy */\n\t\thead->write = tomoyo_write_domain;\n\t\thead->read = tomoyo_read_domain;\n\t\tbreak;\n\tcase TOMOYO_EXCEPTIONPOLICY:\n\t\t/* /sys/kernel/security/tomoyo/exception_policy */\n\t\thead->write = tomoyo_write_exception;\n\t\thead->read = tomoyo_read_exception;\n\t\tbreak;\n\tcase TOMOYO_AUDIT:\n\t\t/* /sys/kernel/security/tomoyo/audit */\n\t\thead->poll = tomoyo_poll_log;\n\t\thead->read = tomoyo_read_log;\n\t\tbreak;\n\tcase TOMOYO_PROCESS_STATUS:\n\t\t/* /sys/kernel/security/tomoyo/.process_status */\n\t\thead->write = tomoyo_write_pid;\n\t\thead->read = tomoyo_read_pid;\n\t\tbreak;\n\tcase TOMOYO_VERSION:\n\t\t/* /sys/kernel/security/tomoyo/version */\n\t\thead->read = tomoyo_read_version;\n\t\thead->readbuf_size = 128;\n\t\tbreak;\n\tcase TOMOYO_STAT:\n\t\t/* /sys/kernel/security/tomoyo/stat */\n\t\thead->write = tomoyo_write_stat;\n\t\thead->read = tomoyo_read_stat;\n\t\thead->readbuf_size = 1024;\n\t\tbreak;\n\tcase TOMOYO_PROFILE:\n\t\t/* /sys/kernel/security/tomoyo/profile */\n\t\thead->write = tomoyo_write_profile;\n\t\thead->read = tomoyo_read_profile;\n\t\tbreak;\n\tcase TOMOYO_QUERY: /* /sys/kernel/security/tomoyo/query */\n\t\thead->poll = tomoyo_poll_query;\n\t\thead->write = tomoyo_write_answer;\n\t\thead->read = tomoyo_read_query;\n\t\tbreak;\n\tcase TOMOYO_MANAGER:\n\t\t/* /sys/kernel/security/tomoyo/manager */\n\t\thead->write = tomoyo_write_manager;\n\t\thead->read = tomoyo_read_manager;\n\t\tbreak;\n\t}\n\tif (!(file->f_mode & FMODE_READ)) {\n\t\t/*\n\t\t * No need to allocate read_buf since it is not opened\n\t\t * for reading.\n\t\t */\n\t\thead->read = NULL;\n\t\thead->poll = NULL;\n\t} else if (!head->poll) {\n\t\t/* Don't allocate read_buf for poll() access. */\n\t\tif (!head->readbuf_size)\n\t\t\thead->readbuf_size = 4096 * 2;\n\t\thead->read_buf = kzalloc(head->readbuf_size, GFP_NOFS);\n\t\tif (!head->read_buf) {\n\t\t\tkfree(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\tif (!(file->f_mode & FMODE_WRITE)) {\n\t\t/*\n\t\t * No need to allocate write_buf since it is not opened\n\t\t * for writing.\n\t\t */\n\t\thead->write = NULL;\n\t} else if (head->write) {\n\t\thead->writebuf_size = 4096 * 2;\n\t\thead->write_buf = kzalloc(head->writebuf_size, GFP_NOFS);\n\t\tif (!head->write_buf) {\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\t/*\n\t * If the file is /sys/kernel/security/tomoyo/query , increment the\n\t * observer counter.\n\t * The obserber counter is used by tomoyo_supervisor() to see if\n\t * there is some process monitoring /sys/kernel/security/tomoyo/query.\n\t */\n\tif (type == TOMOYO_QUERY)\n\t\tatomic_inc(&tomoyo_query_observers);\n\tfile->private_data = head;\n\ttomoyo_notify_gc(head, true);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/security.h>\n\nstatic int tomoyo_open(struct inode *inode, struct file *file)\n{\n\tconst int key = ((u8 *) file_inode(file)->i_private)\n\t\t- ((u8 *) NULL);\n\treturn tomoyo_open_control(key, file);\n}"
  },
  {
    "function_name": "tomoyo_read_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/securityfs_if.c",
    "lines": "101-116",
    "snippet": "static ssize_t tomoyo_read_self(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tconst char *domain = tomoyo_domain()->domainname->name;\n\tloff_t len = strlen(domain);\n\tloff_t pos = *ppos;\n\tif (pos >= len || !count)\n\t\treturn 0;\n\tlen -= pos;\n\tif (count < len)\n\t\tlen = count;\n\tif (copy_to_user(buf, domain + pos, len))\n\t\treturn -EFAULT;\n\t*ppos += len;\n\treturn len;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buf",
            "domain + pos",
            "len"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "domain"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_domain",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1204-1207",
          "snippet": "static inline struct tomoyo_domain_info *tomoyo_domain(void)\n{\n\treturn current_cred()->security;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline struct tomoyo_domain_info *tomoyo_domain(void)\n{\n\treturn current_cred()->security;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/security.h>\n\nstatic ssize_t tomoyo_read_self(struct file *file, char __user *buf,\n\t\t\t\tsize_t count, loff_t *ppos)\n{\n\tconst char *domain = tomoyo_domain()->domainname->name;\n\tloff_t len = strlen(domain);\n\tloff_t pos = *ppos;\n\tif (pos >= len || !count)\n\t\treturn 0;\n\tlen -= pos;\n\tif (count < len)\n\t\tlen = count;\n\tif (copy_to_user(buf, domain + pos, len))\n\t\treturn -EFAULT;\n\t*ppos += len;\n\treturn len;\n}"
  },
  {
    "function_name": "tomoyo_write_self",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/securityfs_if.c",
    "lines": "40-89",
    "snippet": "static ssize_t tomoyo_write_self(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *data;\n\tint error;\n\tif (!count || count >= TOMOYO_EXEC_TMPSIZE - 10)\n\t\treturn -ENOMEM;\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\ttomoyo_normalize_line(data);\n\tif (tomoyo_correct_domain(data)) {\n\t\tconst int idx = tomoyo_read_lock();\n\t\tstruct tomoyo_path_info name;\n\t\tstruct tomoyo_request_info r;\n\t\tname.name = data;\n\t\ttomoyo_fill_path_info(&name);\n\t\t/* Check \"task manual_domain_transition\" permission. */\n\t\ttomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_EXECUTE);\n\t\tr.param_type = TOMOYO_TYPE_MANUAL_TASK_ACL;\n\t\tr.param.task.domainname = &name;\n\t\ttomoyo_check_acl(&r, tomoyo_check_task_acl);\n\t\tif (!r.granted)\n\t\t\terror = -EPERM;\n\t\telse {\n\t\t\tstruct tomoyo_domain_info *new_domain =\n\t\t\t\ttomoyo_assign_domain(data, true);\n\t\t\tif (!new_domain) {\n\t\t\t\terror = -ENOENT;\n\t\t\t} else {\n\t\t\t\tstruct cred *cred = prepare_creds();\n\t\t\t\tif (!cred) {\n\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t} else {\n\t\t\t\t\tstruct tomoyo_domain_info *old_domain =\n\t\t\t\t\t\tcred->security;\n\t\t\t\t\tcred->security = new_domain;\n\t\t\t\t\tatomic_inc(&new_domain->users);\n\t\t\t\t\tatomic_dec(&old_domain->users);\n\t\t\t\t\tcommit_creds(cred);\n\t\t\t\t\terror = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttomoyo_read_unlock(idx);\n\t} else\n\t\terror = -EINVAL;\n\tkfree(data);\n\treturn error ? error : count;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_read_unlock",
          "args": [
            "idx"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "commit_creds",
          "args": [
            "cred"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&old_domain->users"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&new_domain->users"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_assign_domain",
          "args": [
            "data",
            "true"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_assign_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "507-582",
          "snippet": "struct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,\n\t\t\t\t\t\tconst bool transit)\n{\n\tstruct tomoyo_domain_info e = { };\n\tstruct tomoyo_domain_info *entry = tomoyo_find_domain(domainname);\n\tbool created = false;\n\tif (entry) {\n\t\tif (transit) {\n\t\t\t/*\n\t\t\t * Since namespace is created at runtime, profiles may\n\t\t\t * not be created by the moment the process transits to\n\t\t\t * that domain. Do not perform domain transition if\n\t\t\t * profile for that domain is not yet created.\n\t\t\t */\n\t\t\tif (tomoyo_policy_loaded &&\n\t\t\t    !entry->ns->profile_ptr[entry->profile])\n\t\t\t\treturn NULL;\n\t\t}\n\t\treturn entry;\n\t}\n\t/* Requested domain does not exist. */\n\t/* Don't create requested domain if domainname is invalid. */\n\tif (strlen(domainname) >= TOMOYO_EXEC_TMPSIZE - 10 ||\n\t    !tomoyo_correct_domain(domainname))\n\t\treturn NULL;\n\t/*\n\t * Since definition of profiles and acl_groups may differ across\n\t * namespaces, do not inherit \"use_profile\" and \"use_group\" settings\n\t * by automatically creating requested domain upon domain transition.\n\t */\n\tif (transit && tomoyo_namespace_jump(domainname))\n\t\treturn NULL;\n\te.ns = tomoyo_assign_namespace(domainname);\n\tif (!e.ns)\n\t\treturn NULL;\n\t/*\n\t * \"use_profile\" and \"use_group\" settings for automatically created\n\t * domains are inherited from current domain. These are 0 for manually\n\t * created domains.\n\t */\n\tif (transit) {\n\t\tconst struct tomoyo_domain_info *domain = tomoyo_domain();\n\t\te.profile = domain->profile;\n\t\te.group = domain->group;\n\t}\n\te.domainname = tomoyo_get_name(domainname);\n\tif (!e.domainname)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tentry = tomoyo_find_domain(domainname);\n\tif (!entry) {\n\t\tentry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->acl_info_list);\n\t\t\tlist_add_tail_rcu(&entry->list, &tomoyo_domain_list);\n\t\t\tcreated = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.domainname);\n\tif (entry && transit) {\n\t\tif (created) {\n\t\t\tstruct tomoyo_request_info r;\n\t\t\ttomoyo_init_request_info(&r, entry,\n\t\t\t\t\t\t TOMOYO_MAC_FILE_EXECUTE);\n\t\t\tr.granted = false;\n\t\t\ttomoyo_write_log(&r, \"use_profile %u\\n\",\n\t\t\t\t\t entry->profile);\n\t\t\ttomoyo_write_log(&r, \"use_group %u\\n\", entry->group);\n\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t}\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstruct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,\n\t\t\t\t\t\tconst bool transit)\n{\n\tstruct tomoyo_domain_info e = { };\n\tstruct tomoyo_domain_info *entry = tomoyo_find_domain(domainname);\n\tbool created = false;\n\tif (entry) {\n\t\tif (transit) {\n\t\t\t/*\n\t\t\t * Since namespace is created at runtime, profiles may\n\t\t\t * not be created by the moment the process transits to\n\t\t\t * that domain. Do not perform domain transition if\n\t\t\t * profile for that domain is not yet created.\n\t\t\t */\n\t\t\tif (tomoyo_policy_loaded &&\n\t\t\t    !entry->ns->profile_ptr[entry->profile])\n\t\t\t\treturn NULL;\n\t\t}\n\t\treturn entry;\n\t}\n\t/* Requested domain does not exist. */\n\t/* Don't create requested domain if domainname is invalid. */\n\tif (strlen(domainname) >= TOMOYO_EXEC_TMPSIZE - 10 ||\n\t    !tomoyo_correct_domain(domainname))\n\t\treturn NULL;\n\t/*\n\t * Since definition of profiles and acl_groups may differ across\n\t * namespaces, do not inherit \"use_profile\" and \"use_group\" settings\n\t * by automatically creating requested domain upon domain transition.\n\t */\n\tif (transit && tomoyo_namespace_jump(domainname))\n\t\treturn NULL;\n\te.ns = tomoyo_assign_namespace(domainname);\n\tif (!e.ns)\n\t\treturn NULL;\n\t/*\n\t * \"use_profile\" and \"use_group\" settings for automatically created\n\t * domains are inherited from current domain. These are 0 for manually\n\t * created domains.\n\t */\n\tif (transit) {\n\t\tconst struct tomoyo_domain_info *domain = tomoyo_domain();\n\t\te.profile = domain->profile;\n\t\te.group = domain->group;\n\t}\n\te.domainname = tomoyo_get_name(domainname);\n\tif (!e.domainname)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tentry = tomoyo_find_domain(domainname);\n\tif (!entry) {\n\t\tentry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->acl_info_list);\n\t\t\tlist_add_tail_rcu(&entry->list, &tomoyo_domain_list);\n\t\t\tcreated = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.domainname);\n\tif (entry && transit) {\n\t\tif (created) {\n\t\t\tstruct tomoyo_request_info r;\n\t\t\ttomoyo_init_request_info(&r, entry,\n\t\t\t\t\t\t TOMOYO_MAC_FILE_EXECUTE);\n\t\t\tr.granted = false;\n\t\t\ttomoyo_write_log(&r, \"use_profile %u\\n\",\n\t\t\t\t\t entry->profile);\n\t\t\ttomoyo_write_log(&r, \"use_group %u\\n\", entry->group);\n\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t}\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_check_acl",
          "args": [
            "&r",
            "tomoyo_check_task_acl"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "159-186",
          "snippet": "void tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tbool retried = false;\n\tconst struct list_head *list = &domain->acl_info_list;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tif (!retried) {\n\t\tretried = true;\n\t\tlist = &domain->ns->acl_group[domain->group];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nvoid tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tbool retried = false;\n\tconst struct list_head *list = &domain->acl_info_list;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tif (!retried) {\n\t\tretried = true;\n\t\tlist = &domain->ns->acl_group[domain->group];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_init_request_info",
          "args": [
            "&r",
            "NULL",
            "TOMOYO_MAC_FILE_EXECUTE"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_init_request_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "984-997",
          "snippet": "int tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nint tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_fill_path_info",
          "args": [
            "&name"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_fill_path_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "643-652",
          "snippet": "void tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_lock",
          "args": [],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1096-1099",
          "snippet": "static inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_domain",
          "args": [
            "data"
          ],
          "line": 51
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "527-544",
          "snippet": "bool tomoyo_correct_domain(const unsigned char *domainname)\n{\n\tif (!domainname || !tomoyo_domain_def(domainname))\n\t\treturn false;\n\tdomainname = strchr(domainname, ' ');\n\tif (!domainname++)\n\t\treturn true;\n\twhile (1) {\n\t\tconst unsigned char *cp = strchr(domainname, ' ');\n\t\tif (!cp)\n\t\t\tbreak;\n\t\tif (*domainname != '/' ||\n\t\t    !tomoyo_correct_word2(domainname, cp - domainname))\n\t\t\treturn false;\n\t\tdomainname = cp + 1;\n\t}\n\treturn tomoyo_correct_path(domainname);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_domain(const unsigned char *domainname)\n{\n\tif (!domainname || !tomoyo_domain_def(domainname))\n\t\treturn false;\n\tdomainname = strchr(domainname, ' ');\n\tif (!domainname++)\n\t\treturn true;\n\twhile (1) {\n\t\tconst unsigned char *cp = strchr(domainname, ' ');\n\t\tif (!cp)\n\t\t\tbreak;\n\t\tif (*domainname != '/' ||\n\t\t    !tomoyo_correct_word2(domainname, cp - domainname))\n\t\t\treturn false;\n\t\tdomainname = cp + 1;\n\t}\n\treturn tomoyo_correct_path(domainname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_normalize_line",
          "args": [
            "data"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_normalize_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "396-414",
          "snippet": "void tomoyo_normalize_line(unsigned char *buffer)\n{\n\tunsigned char *sp = buffer;\n\tunsigned char *dp = buffer;\n\tbool first = true;\n\n\twhile (tomoyo_invalid(*sp))\n\t\tsp++;\n\twhile (*sp) {\n\t\tif (!first)\n\t\t\t*dp++ = ' ';\n\t\tfirst = false;\n\t\twhile (tomoyo_valid(*sp))\n\t\t\t*dp++ = *sp++;\n\t\twhile (tomoyo_invalid(*sp))\n\t\t\tsp++;\n\t}\n\t*dp = '\\0';\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_normalize_line(unsigned char *buffer)\n{\n\tunsigned char *sp = buffer;\n\tunsigned char *dp = buffer;\n\tbool first = true;\n\n\twhile (tomoyo_invalid(*sp))\n\t\tsp++;\n\twhile (*sp) {\n\t\tif (!first)\n\t\t\t*dp++ = ' ';\n\t\tfirst = false;\n\t\twhile (tomoyo_valid(*sp))\n\t\t\t*dp++ = *sp++;\n\t\twhile (tomoyo_invalid(*sp))\n\t\t\tsp++;\n\t}\n\t*dp = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user_nul",
          "args": [
            "buf",
            "count"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/security.h>\n\nstatic ssize_t tomoyo_write_self(struct file *file, const char __user *buf,\n\t\t\t      size_t count, loff_t *ppos)\n{\n\tchar *data;\n\tint error;\n\tif (!count || count >= TOMOYO_EXEC_TMPSIZE - 10)\n\t\treturn -ENOMEM;\n\tdata = memdup_user_nul(buf, count);\n\tif (IS_ERR(data))\n\t\treturn PTR_ERR(data);\n\ttomoyo_normalize_line(data);\n\tif (tomoyo_correct_domain(data)) {\n\t\tconst int idx = tomoyo_read_lock();\n\t\tstruct tomoyo_path_info name;\n\t\tstruct tomoyo_request_info r;\n\t\tname.name = data;\n\t\ttomoyo_fill_path_info(&name);\n\t\t/* Check \"task manual_domain_transition\" permission. */\n\t\ttomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_EXECUTE);\n\t\tr.param_type = TOMOYO_TYPE_MANUAL_TASK_ACL;\n\t\tr.param.task.domainname = &name;\n\t\ttomoyo_check_acl(&r, tomoyo_check_task_acl);\n\t\tif (!r.granted)\n\t\t\terror = -EPERM;\n\t\telse {\n\t\t\tstruct tomoyo_domain_info *new_domain =\n\t\t\t\ttomoyo_assign_domain(data, true);\n\t\t\tif (!new_domain) {\n\t\t\t\terror = -ENOENT;\n\t\t\t} else {\n\t\t\t\tstruct cred *cred = prepare_creds();\n\t\t\t\tif (!cred) {\n\t\t\t\t\terror = -ENOMEM;\n\t\t\t\t} else {\n\t\t\t\t\tstruct tomoyo_domain_info *old_domain =\n\t\t\t\t\t\tcred->security;\n\t\t\t\t\tcred->security = new_domain;\n\t\t\t\t\tatomic_inc(&new_domain->users);\n\t\t\t\t\tatomic_dec(&old_domain->users);\n\t\t\t\t\tcommit_creds(cred);\n\t\t\t\t\terror = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttomoyo_read_unlock(idx);\n\t} else\n\t\terror = -EINVAL;\n\tkfree(data);\n\treturn error ? error : count;\n}"
  },
  {
    "function_name": "tomoyo_check_task_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/securityfs_if.c",
    "lines": "19-25",
    "snippet": "static bool tomoyo_check_task_acl(struct tomoyo_request_info *r,\n\t\t\t\t  const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_task_acl *acl = container_of(ptr, typeof(*acl),\n\t\t\t\t\t\t\t head);\n\treturn !tomoyo_pathcmp(r->param.task.domainname, acl->domainname);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/security.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_pathcmp",
          "args": [
            "r->param.task.domainname",
            "acl->domainname"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_pathcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1151-1155",
          "snippet": "static inline bool tomoyo_pathcmp(const struct tomoyo_path_info *a,\n\t\t\t\t  const struct tomoyo_path_info *b)\n{\n\treturn a->hash != b->hash || strcmp(a->name, b->name);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline bool tomoyo_pathcmp(const struct tomoyo_path_info *a,\n\t\t\t\t  const struct tomoyo_path_info *b)\n{\n\treturn a->hash != b->hash || strcmp(a->name, b->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ptr",
            "typeof(*acl)",
            "head"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*acl"
          ],
          "line": 22
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/security.h>\n\nstatic bool tomoyo_check_task_acl(struct tomoyo_request_info *r,\n\t\t\t\t  const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_task_acl *acl = container_of(ptr, typeof(*acl),\n\t\t\t\t\t\t\t head);\n\treturn !tomoyo_pathcmp(r->param.task.domainname, acl->domainname);\n}"
  }
]