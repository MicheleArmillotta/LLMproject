[
  {
    "function_name": "evm_init_secfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_secfs.c",
    "lines": "96-105",
    "snippet": "int __init evm_init_secfs(void)\n{\n\tint error = 0;\n\n\tevm_init_tpm = securityfs_create_file(\"evm\", S_IRUSR | S_IRGRP,\n\t\t\t\t\t      NULL, NULL, &evm_key_ops);\n\tif (!evm_init_tpm || IS_ERR(evm_init_tpm))\n\t\terror = -EFAULT;\n\treturn error;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct dentry *evm_init_tpm;",
      "static const struct file_operations evm_key_ops = {\n\t.read\t\t= evm_read_key,\n\t.write\t\t= evm_write_key,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "evm_init_tpm"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "securityfs_create_file",
          "args": [
            "\"evm\"",
            "S_IRUSR | S_IRGRP",
            "NULL",
            "NULL",
            "&evm_key_ops"
          ],
          "line": 100
        },
        "resolved": true,
        "details": {
          "function_name": "securityfs_create_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/inode.c",
          "lines": "194-199",
          "snippet": "struct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/security.h>",
            "#include <linux/namei.h>",
            "#include <linux/init.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include <linux/lsm_hooks.h>\n#include <linux/security.h>\n#include <linux/namei.h>\n#include <linux/init.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/module.h>\n\nstruct dentry *securityfs_create_file(const char *name, umode_t mode,\n\t\t\t\t      struct dentry *parent, void *data,\n\t\t\t\t      const struct file_operations *fops)\n{\n\treturn securityfs_create_dentry(name, mode, parent, data, fops, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic struct dentry *evm_init_tpm;\nstatic const struct file_operations evm_key_ops = {\n\t.read\t\t= evm_read_key,\n\t.write\t\t= evm_write_key,\n};\n\nint __init evm_init_secfs(void)\n{\n\tint error = 0;\n\n\tevm_init_tpm = securityfs_create_file(\"evm\", S_IRUSR | S_IRGRP,\n\t\t\t\t\t      NULL, NULL, &evm_key_ops);\n\tif (!evm_init_tpm || IS_ERR(evm_init_tpm))\n\t\terror = -EFAULT;\n\treturn error;\n}"
  },
  {
    "function_name": "evm_write_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_secfs.c",
    "lines": "61-89",
    "snippet": "static ssize_t evm_write_key(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tint i, ret;\n\n\tif (!capable(CAP_SYS_ADMIN) || (evm_initialized & EVM_SETUP))\n\t\treturn -EPERM;\n\n\tret = kstrtoint_from_user(buf, count, 0, &i);\n\n\tif (ret)\n\t\treturn ret;\n\n\t/* Reject invalid values */\n\tif (!i || (i & ~EVM_INIT_MASK) != 0)\n\t\treturn -EINVAL;\n\n\tif (i & EVM_INIT_HMAC) {\n\t\tret = evm_init_key();\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\t/* Forbid further writes after the symmetric key is loaded */\n\t\ti |= EVM_SETUP;\n\t}\n\n\tevm_initialized |= i;\n\n\treturn count;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "evm_init_key",
          "args": [],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "evm_init_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_crypto.c",
          "lines": "291-311",
          "snippet": "int evm_init_key(void)\n{\n\tstruct key *evm_key;\n\tstruct encrypted_key_payload *ekp;\n\tint rc;\n\n\tevm_key = request_key(&key_type_encrypted, EVMKEY, NULL);\n\tif (IS_ERR(evm_key))\n\t\treturn -ENOENT;\n\n\tdown_read(&evm_key->sem);\n\tekp = evm_key->payload.data[0];\n\n\trc = evm_set_key(ekp->decrypted_data, ekp->decrypted_datalen);\n\n\t/* burn the original key contents */\n\tmemset(ekp->decrypted_data, 0, ekp->decrypted_datalen);\n\tup_read(&evm_key->sem);\n\tkey_put(evm_key);\n\treturn rc;\n}",
          "includes": [
            "#include \"evm.h\"",
            "#include <crypto/hash.h>",
            "#include <keys/encrypted-type.h>",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/crypto.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define EVMKEY \"evm-key\""
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"evm.h\"\n#include <crypto/hash.h>\n#include <keys/encrypted-type.h>\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/crypto.h>\n#include <linux/module.h>\n\n#define EVMKEY \"evm-key\"\n\nint evm_init_key(void)\n{\n\tstruct key *evm_key;\n\tstruct encrypted_key_payload *ekp;\n\tint rc;\n\n\tevm_key = request_key(&key_type_encrypted, EVMKEY, NULL);\n\tif (IS_ERR(evm_key))\n\t\treturn -ENOENT;\n\n\tdown_read(&evm_key->sem);\n\tekp = evm_key->payload.data[0];\n\n\trc = evm_set_key(ekp->decrypted_data, ekp->decrypted_datalen);\n\n\t/* burn the original key contents */\n\tmemset(ekp->decrypted_data, 0, ekp->decrypted_datalen);\n\tup_read(&evm_key->sem);\n\tkey_put(evm_key);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrtoint_from_user",
          "args": [
            "buf",
            "count",
            "0",
            "&i"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic ssize_t evm_write_key(struct file *file, const char __user *buf,\n\t\t\t     size_t count, loff_t *ppos)\n{\n\tint i, ret;\n\n\tif (!capable(CAP_SYS_ADMIN) || (evm_initialized & EVM_SETUP))\n\t\treturn -EPERM;\n\n\tret = kstrtoint_from_user(buf, count, 0, &i);\n\n\tif (ret)\n\t\treturn ret;\n\n\t/* Reject invalid values */\n\tif (!i || (i & ~EVM_INIT_MASK) != 0)\n\t\treturn -EINVAL;\n\n\tif (i & EVM_INIT_HMAC) {\n\t\tret = evm_init_key();\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t\t/* Forbid further writes after the symmetric key is loaded */\n\t\ti |= EVM_SETUP;\n\t}\n\n\tevm_initialized |= i;\n\n\treturn count;\n}"
  },
  {
    "function_name": "evm_read_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/evm/evm_secfs.c",
    "lines": "34-47",
    "snippet": "static ssize_t evm_read_key(struct file *filp, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar temp[80];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\", (evm_initialized & ~EVM_SETUP));\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\n\treturn rc;\n}",
    "includes": [
      "#include \"evm.h\"",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_read_from_buffer",
          "args": [
            "buf",
            "count",
            "ppos",
            "temp",
            "strlen(temp)"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "temp"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "temp",
            "\"%d\"",
            "(evm_initialized & ~EVM_SETUP)"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"evm.h\"\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic ssize_t evm_read_key(struct file *filp, char __user *buf,\n\t\t\t    size_t count, loff_t *ppos)\n{\n\tchar temp[80];\n\tssize_t rc;\n\n\tif (*ppos != 0)\n\t\treturn 0;\n\n\tsprintf(temp, \"%d\", (evm_initialized & ~EVM_SETUP));\n\trc = simple_read_from_buffer(buf, count, ppos, temp, strlen(temp));\n\n\treturn rc;\n}"
  }
]