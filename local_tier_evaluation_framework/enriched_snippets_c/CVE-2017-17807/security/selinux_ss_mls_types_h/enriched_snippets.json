[
  {
    "function_name": "mls_level_dom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls_types.h",
    "lines": "36-40",
    "snippet": "static inline int mls_level_dom(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens >= l2->sens) &&\n\t\tebitmap_contains(&l1->cat, &l2->cat, 0));\n}",
    "includes": [
      "#include \"ebitmap.h\"",
      "#include \"security.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_contains",
          "args": [
            "&l1->cat",
            "&l2->cat",
            "0"
          ],
          "line": 39
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_contains",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "201-240",
          "snippet": "int ebitmap_contains(struct ebitmap *e1, struct ebitmap *e2, u32 last_e2bit)\n{\n\tstruct ebitmap_node *n1, *n2;\n\tint i;\n\n\tif (e1->highbit < e2->highbit)\n\t\treturn 0;\n\n\tn1 = e1->node;\n\tn2 = e2->node;\n\n\twhile (n1 && n2 && (n1->startbit <= n2->startbit)) {\n\t\tif (n1->startbit < n2->startbit) {\n\t\t\tn1 = n1->next;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = EBITMAP_UNIT_NUMS - 1; (i >= 0) && !n2->maps[i]; )\n\t\t\ti--;\t/* Skip trailing NULL map entries */\n\t\tif (last_e2bit && (i >= 0)) {\n\t\t\tu32 lastsetbit = n2->startbit + i * EBITMAP_UNIT_SIZE +\n\t\t\t\t\t __fls(n2->maps[i]);\n\t\t\tif (lastsetbit > last_e2bit)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\twhile (i >= 0) {\n\t\t\tif ((n1->maps[i] & n2->maps[i]) != n2->maps[i])\n\t\t\t\treturn 0;\n\t\t\ti--;\n\t\t}\n\n\t\tn1 = n1->next;\n\t\tn2 = n2->next;\n\t}\n\n\tif (n2)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_contains(struct ebitmap *e1, struct ebitmap *e2, u32 last_e2bit)\n{\n\tstruct ebitmap_node *n1, *n2;\n\tint i;\n\n\tif (e1->highbit < e2->highbit)\n\t\treturn 0;\n\n\tn1 = e1->node;\n\tn2 = e2->node;\n\n\twhile (n1 && n2 && (n1->startbit <= n2->startbit)) {\n\t\tif (n1->startbit < n2->startbit) {\n\t\t\tn1 = n1->next;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = EBITMAP_UNIT_NUMS - 1; (i >= 0) && !n2->maps[i]; )\n\t\t\ti--;\t/* Skip trailing NULL map entries */\n\t\tif (last_e2bit && (i >= 0)) {\n\t\t\tu32 lastsetbit = n2->startbit + i * EBITMAP_UNIT_SIZE +\n\t\t\t\t\t __fls(n2->maps[i]);\n\t\t\tif (lastsetbit > last_e2bit)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\twhile (i >= 0) {\n\t\t\tif ((n1->maps[i] & n2->maps[i]) != n2->maps[i])\n\t\t\t\treturn 0;\n\t\t\ti--;\n\t\t}\n\n\t\tn1 = n1->next;\n\t\tn2 = n2->next;\n\t}\n\n\tif (n2)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebitmap.h\"\n#include \"security.h\"\n\nstatic inline int mls_level_dom(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens >= l2->sens) &&\n\t\tebitmap_contains(&l1->cat, &l2->cat, 0));\n}"
  },
  {
    "function_name": "mls_level_eq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/mls_types.h",
    "lines": "30-34",
    "snippet": "static inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens == l2->sens) &&\n\t\tebitmap_cmp(&l1->cat, &l2->cat));\n}",
    "includes": [
      "#include \"ebitmap.h\"",
      "#include \"security.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_cmp",
          "args": [
            "&l1->cat",
            "&l2->cat"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_cmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "30-50",
          "snippet": "int ebitmap_cmp(struct ebitmap *e1, struct ebitmap *e2)\n{\n\tstruct ebitmap_node *n1, *n2;\n\n\tif (e1->highbit != e2->highbit)\n\t\treturn 0;\n\n\tn1 = e1->node;\n\tn2 = e2->node;\n\twhile (n1 && n2 &&\n\t       (n1->startbit == n2->startbit) &&\n\t       !memcmp(n1->maps, n2->maps, EBITMAP_SIZE / 8)) {\n\t\tn1 = n1->next;\n\t\tn2 = n2->next;\n\t}\n\n\tif (n1 || n2)\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_cmp(struct ebitmap *e1, struct ebitmap *e2)\n{\n\tstruct ebitmap_node *n1, *n2;\n\n\tif (e1->highbit != e2->highbit)\n\t\treturn 0;\n\n\tn1 = e1->node;\n\tn2 = e2->node;\n\twhile (n1 && n2 &&\n\t       (n1->startbit == n2->startbit) &&\n\t       !memcmp(n1->maps, n2->maps, EBITMAP_SIZE / 8)) {\n\t\tn1 = n1->next;\n\t\tn2 = n2->next;\n\t}\n\n\tif (n1 || n2)\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ebitmap.h\"\n#include \"security.h\"\n\nstatic inline int mls_level_eq(struct mls_level *l1, struct mls_level *l2)\n{\n\treturn ((l1->sens == l2->sens) &&\n\t\tebitmap_cmp(&l1->cat, &l2->cat));\n}"
  }
]