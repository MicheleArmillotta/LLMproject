[
  {
    "function_name": "keyring_restriction_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1560-1593",
    "snippet": "void keyring_restriction_gc(struct key *keyring, struct key_type *dead_type)\n{\n\tstruct key_restriction *keyres;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\t/*\n\t * keyring->restrict_link is only assigned at key allocation time\n\t * or with the key type locked, so the only values that could be\n\t * concurrently assigned to keyring->restrict_link are for key\n\t * types other than dead_type. Given this, it's ok to check\n\t * the key type before acquiring keyring->sem.\n\t */\n\tif (!dead_type || !keyring->restrict_link ||\n\t    keyring->restrict_link->keytype != dead_type) {\n\t\tkleave(\" [no restriction gc]\");\n\t\treturn;\n\t}\n\n\t/* Lock the keyring to ensure that a link is not in progress */\n\tdown_write(&keyring->sem);\n\n\tkeyres = keyring->restrict_link;\n\n\tkeyres->check = restrict_link_reject;\n\n\tkey_put(keyres->key);\n\tkeyres->key = NULL;\n\tkeyres->keytype = NULL;\n\n\tup_write(&keyring->sem);\n\n\tkleave(\" [restriction gc]\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" [restriction gc]\""
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "keyres->key"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" [no restriction gc]\""
          ],
          "line": 1575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"%x{%s}\"",
            "keyring->serial",
            "keyring->description ?: \"\""
          ],
          "line": 1564
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nvoid keyring_restriction_gc(struct key *keyring, struct key_type *dead_type)\n{\n\tstruct key_restriction *keyres;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\t/*\n\t * keyring->restrict_link is only assigned at key allocation time\n\t * or with the key type locked, so the only values that could be\n\t * concurrently assigned to keyring->restrict_link are for key\n\t * types other than dead_type. Given this, it's ok to check\n\t * the key type before acquiring keyring->sem.\n\t */\n\tif (!dead_type || !keyring->restrict_link ||\n\t    keyring->restrict_link->keytype != dead_type) {\n\t\tkleave(\" [no restriction gc]\");\n\t\treturn;\n\t}\n\n\t/* Lock the keyring to ensure that a link is not in progress */\n\tdown_write(&keyring->sem);\n\n\tkeyres = keyring->restrict_link;\n\n\tkeyres->check = restrict_link_reject;\n\n\tkey_put(keyres->key);\n\tkeyres->key = NULL;\n\tkeyres->keytype = NULL;\n\n\tup_write(&keyring->sem);\n\n\tkleave(\" [restriction gc]\");\n}"
  },
  {
    "function_name": "keyring_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1515-1543",
    "snippet": "void keyring_gc(struct key *keyring, time64_t limit)\n{\n\tint result;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto dont_gc;\n\n\t/* scan the keyring looking for dead keys */\n\trcu_read_lock();\n\tresult = assoc_array_iterate(&keyring->keys,\n\t\t\t\t     keyring_gc_check_iterator, &limit);\n\trcu_read_unlock();\n\tif (result == true)\n\t\tgoto do_gc;\n\ndont_gc:\n\tkleave(\" [no gc]\");\n\treturn;\n\ndo_gc:\n\tdown_write(&keyring->sem);\n\tassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\n\t\t       keyring_gc_select_iterator, &limit);\n\tup_write(&keyring->sem);\n\tkleave(\" [gc]\");\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" [gc]\""
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_gc",
          "args": [
            "&keyring->keys",
            "&keyring_assoc_array_ops",
            "keyring_gc_select_iterator",
            "&limit"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" [no gc]\""
          ],
          "line": 1534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_iterate",
          "args": [
            "&keyring->keys",
            "keyring_gc_check_iterator",
            "&limit"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"%x{%s}\"",
            "keyring->serial",
            "keyring->description ?: \"\""
          ],
          "line": 1519
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nvoid keyring_gc(struct key *keyring, time64_t limit)\n{\n\tint result;\n\n\tkenter(\"%x{%s}\", keyring->serial, keyring->description ?: \"\");\n\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto dont_gc;\n\n\t/* scan the keyring looking for dead keys */\n\trcu_read_lock();\n\tresult = assoc_array_iterate(&keyring->keys,\n\t\t\t\t     keyring_gc_check_iterator, &limit);\n\trcu_read_unlock();\n\tif (result == true)\n\t\tgoto do_gc;\n\ndont_gc:\n\tkleave(\" [no gc]\");\n\treturn;\n\ndo_gc:\n\tdown_write(&keyring->sem);\n\tassoc_array_gc(&keyring->keys, &keyring_assoc_array_ops,\n\t\t       keyring_gc_select_iterator, &limit);\n\tup_write(&keyring->sem);\n\tkleave(\" [gc]\");\n}"
  },
  {
    "function_name": "keyring_gc_check_iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1500-1507",
    "snippet": "static int keyring_gc_check_iterator(const void *object, void *iterator_data)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\ttime64_t *limit = iterator_data;\n\n\tkey_check(key);\n\treturn key_is_dead(key, *limit);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_is_dead",
          "args": [
            "key",
            "*limit"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "key_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/internal.h",
          "lines": "214-220",
          "snippet": "static inline bool key_is_dead(const struct key *key, time64_t limit)\n{\n\treturn\n\t\tkey->flags & ((1 << KEY_FLAG_DEAD) |\n\t\t\t      (1 << KEY_FLAG_INVALIDATED)) ||\n\t\t(key->expiry > 0 && key->expiry <= limit);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/refcount.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/task_work.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/refcount.h>\n#include <linux/keyctl.h>\n#include <linux/task_work.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/wait_bit.h>\n#include <linux/sched.h>\n\nstatic inline bool key_is_dead(const struct key *key, time64_t limit)\n{\n\treturn\n\t\tkey->flags & ((1 << KEY_FLAG_DEAD) |\n\t\t\t      (1 << KEY_FLAG_INVALIDATED)) ||\n\t\t(key->expiry > 0 && key->expiry <= limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_check",
          "args": [
            "key"
          ],
          "line": 1505
        },
        "resolved": true,
        "details": {
          "function_name": "key_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/internal.h",
          "lines": "307-311",
          "snippet": "static inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/refcount.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/task_work.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/refcount.h>\n#include <linux/keyctl.h>\n#include <linux/task_work.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/wait_bit.h>\n#include <linux/sched.h>\n\nstatic inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyring_ptr_to_key",
          "args": [
            "object"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_ptr_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "46-50",
          "snippet": "static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int keyring_gc_check_iterator(const void *object, void *iterator_data)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\ttime64_t *limit = iterator_data;\n\n\tkey_check(key);\n\treturn key_is_dead(key, *limit);\n}"
  },
  {
    "function_name": "keyring_gc_select_iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1489-1498",
    "snippet": "static bool keyring_gc_select_iterator(void *object, void *iterator_data)\n{\n\tstruct key *key = keyring_ptr_to_key(object);\n\ttime64_t *limit = iterator_data;\n\n\tif (key_is_dead(key, *limit))\n\t\treturn false;\n\tkey_get(key);\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "key"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "key_get_instantiation_authkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "234-268",
          "snippet": "struct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void request_key_auth_revoke(struct key *);",
            "static void request_key_auth_destroy(struct key *);",
            "struct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstruct key_type key_type_request_key_auth = {\n\t.name\t\t= \".request_key_auth\",\n\t.def_datalen\t= sizeof(struct request_key_auth),\n\t.preparse\t= request_key_auth_preparse,\n\t.free_preparse\t= request_key_auth_free_preparse,\n\t.instantiate\t= request_key_auth_instantiate,\n\t.describe\t= request_key_auth_describe,\n\t.revoke\t\t= request_key_auth_revoke,\n\t.destroy\t= request_key_auth_destroy,\n\t.read\t\t= request_key_auth_read,\n};\n\nstruct key *key_get_instantiation_authkey(key_serial_t target_id)\n{\n\tchar description[16];\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= &key_type_request_key_auth,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tstruct key *authkey;\n\tkey_ref_t authkey_ref;\n\n\tsprintf(description, \"%x\", target_id);\n\n\tauthkey_ref = search_process_keyrings(&ctx);\n\n\tif (IS_ERR(authkey_ref)) {\n\t\tauthkey = ERR_CAST(authkey_ref);\n\t\tif (authkey == ERR_PTR(-EAGAIN))\n\t\t\tauthkey = ERR_PTR(-ENOKEY);\n\t\tgoto error;\n\t}\n\n\tauthkey = key_ref_to_ptr(authkey_ref);\n\tif (test_bit(KEY_FLAG_REVOKED, &authkey->flags)) {\n\t\tkey_put(authkey);\n\t\tauthkey = ERR_PTR(-EKEYREVOKED);\n\t}\n\nerror:\n\treturn authkey;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_is_dead",
          "args": [
            "key",
            "*limit"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "key_is_dead",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/internal.h",
          "lines": "214-220",
          "snippet": "static inline bool key_is_dead(const struct key *key, time64_t limit)\n{\n\treturn\n\t\tkey->flags & ((1 << KEY_FLAG_DEAD) |\n\t\t\t      (1 << KEY_FLAG_INVALIDATED)) ||\n\t\t(key->expiry > 0 && key->expiry <= limit);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/refcount.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/task_work.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/refcount.h>\n#include <linux/keyctl.h>\n#include <linux/task_work.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/wait_bit.h>\n#include <linux/sched.h>\n\nstatic inline bool key_is_dead(const struct key *key, time64_t limit)\n{\n\treturn\n\t\tkey->flags & ((1 << KEY_FLAG_DEAD) |\n\t\t\t      (1 << KEY_FLAG_INVALIDATED)) ||\n\t\t(key->expiry > 0 && key->expiry <= limit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyring_ptr_to_key",
          "args": [
            "object"
          ],
          "line": 1491
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_ptr_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "46-50",
          "snippet": "static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool keyring_gc_select_iterator(void *object, void *iterator_data)\n{\n\tstruct key *key = keyring_ptr_to_key(object);\n\ttime64_t *limit = iterator_data;\n\n\tif (key_is_dead(key, *limit))\n\t\treturn false;\n\tkey_get(key);\n\treturn true;\n}"
  },
  {
    "function_name": "keyring_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1477-1487",
    "snippet": "static void keyring_revoke(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (!IS_ERR(edit)) {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_payload_reserve",
          "args": [
            "keyring",
            "0"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "key_payload_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "370-401",
          "snippet": "int key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int key_quota_root_maxbytes = 25000000;",
            "unsigned int key_quota_maxbytes = 20000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nunsigned int key_quota_root_maxbytes = 25000000;\nunsigned int key_quota_maxbytes = 20000;\n\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assoc_array_apply_edit",
          "args": [
            "edit"
          ],
          "line": 1484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "edit"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_clear",
          "args": [
            "&keyring->keys",
            "&keyring_assoc_array_ops"
          ],
          "line": 1481
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nstatic void keyring_revoke(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (!IS_ERR(edit)) {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t}\n}"
  },
  {
    "function_name": "keyring_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1447-1469",
    "snippet": "int keyring_clear(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t} else {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t\tret = 0;\n\t}\n\n\tup_write(&keyring->sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};",
      "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_payload_reserve",
          "args": [
            "keyring",
            "0"
          ],
          "line": 1463
        },
        "resolved": true,
        "details": {
          "function_name": "key_payload_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "370-401",
          "snippet": "int key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int key_quota_root_maxbytes = 25000000;",
            "unsigned int key_quota_maxbytes = 20000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nunsigned int key_quota_root_maxbytes = 25000000;\nunsigned int key_quota_maxbytes = 20000;\n\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assoc_array_apply_edit",
          "args": [
            "edit"
          ],
          "line": 1462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "edit"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "edit"
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_clear",
          "args": [
            "&keyring->keys",
            "&keyring_assoc_array_ops"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nint keyring_clear(struct key *keyring)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_clear(&keyring->keys, &keyring_assoc_array_ops);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t} else {\n\t\tif (edit)\n\t\t\tassoc_array_apply_edit(edit);\n\t\tkey_payload_reserve(keyring, 0);\n\t\tret = 0;\n\t}\n\n\tup_write(&keyring->sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "key_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1406-1436",
    "snippet": "int key_unlink(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  &key->index_key);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error;\n\t}\n\tret = -ENOENT;\n\tif (edit == NULL)\n\t\tgoto error;\n\n\tassoc_array_apply_edit(edit);\n\tkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\n\tret = 0;\n\nerror:\n\tup_write(&keyring->sem);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};",
      "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_payload_reserve",
          "args": [
            "keyring",
            "keyring->datalen - KEYQUOTA_LINK_BYTES"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "key_payload_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "370-401",
          "snippet": "int key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int key_quota_root_maxbytes = 25000000;",
            "unsigned int key_quota_maxbytes = 20000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nunsigned int key_quota_root_maxbytes = 25000000;\nunsigned int key_quota_maxbytes = 20000;\n\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assoc_array_apply_edit",
          "args": [
            "edit"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "edit"
          ],
          "line": 1422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "edit"
          ],
          "line": 1421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_delete",
          "args": [
            "&keyring->keys",
            "&keyring_assoc_array_ops",
            "&key->index_key"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_check",
          "args": [
            "key"
          ],
          "line": 1412
        },
        "resolved": true,
        "details": {
          "function_name": "key_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/internal.h",
          "lines": "307-311",
          "snippet": "static inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/refcount.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/task_work.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/refcount.h>\n#include <linux/keyctl.h>\n#include <linux/task_work.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/wait_bit.h>\n#include <linux/sched.h>\n\nstatic inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nint key_unlink(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tedit = assoc_array_delete(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  &key->index_key);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error;\n\t}\n\tret = -ENOENT;\n\tif (edit == NULL)\n\t\tgoto error;\n\n\tassoc_array_apply_edit(edit);\n\tkey_payload_reserve(keyring, keyring->datalen - KEYQUOTA_LINK_BYTES);\n\tret = 0;\n\nerror:\n\tup_write(&keyring->sem);\n\treturn ret;\n}"
  },
  {
    "function_name": "key_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1363-1386",
    "snippet": "int key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\t\tret = __key_link_check_restriction(keyring, key);\n\t\tif (ret == 0)\n\t\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = %d {%d,%d}\"",
            "ret",
            "keyring->serial",
            "refcount_read(&keyring->usage)"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&keyring->usage"
          ],
          "line": 1384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__key_link_end",
          "args": [
            "keyring",
            "&key->index_key",
            "edit"
          ],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "__key_link_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1310-1330",
          "snippet": "void __key_link_end(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key,\n\t\t    struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\n\tif (edit) {\n\t\tif (!edit->dead_leaf) {\n\t\t\tkey_payload_reserve(keyring,\n\t\t\t\tkeyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\t}\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};",
            "static DECLARE_RWSEM(keyring_serialise_link_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nstatic DECLARE_RWSEM(keyring_serialise_link_sem);\n\nvoid __key_link_end(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key,\n\t\t    struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\n\tif (edit) {\n\t\tif (!edit->dead_leaf) {\n\t\t\tkey_payload_reserve(keyring,\n\t\t\t\tkeyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\t}\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__key_link",
          "args": [
            "key",
            "&edit"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "__key_link_check_restriction",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1335-1341",
          "snippet": "static int __key_link_check_restriction(struct key *keyring, struct key *key)\n{\n\tif (!keyring->restrict_link || !keyring->restrict_link->check)\n\t\treturn 0;\n\treturn keyring->restrict_link->check(keyring, key->type, &key->payload,\n\t\t\t\t\t     keyring->restrict_link->key);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nstatic int __key_link_check_restriction(struct key *keyring, struct key *key)\n{\n\tif (!keyring->restrict_link || !keyring->restrict_link->check)\n\t\treturn 0;\n\treturn keyring->restrict_link->check(keyring, key->type, &key->payload,\n\t\t\t\t\t     keyring->restrict_link->key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__key_link_check_live_key",
          "args": [
            "keyring",
            "key"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "__key_link_check_live_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1280-1287",
          "snippet": "int __key_link_check_live_key(struct key *keyring, struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\t/* check that we aren't going to create a cycle by linking one\n\t\t * keyring to another */\n\t\treturn keyring_detect_cycle(keyring, key);\n\treturn 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nint __key_link_check_live_key(struct key *keyring, struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\t/* check that we aren't going to create a cycle by linking one\n\t\t * keyring to another */\n\t\treturn keyring_detect_cycle(keyring, key);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"begun {%d,%d}\"",
            "keyring->serial",
            "refcount_read(&keyring->usage)"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&keyring->usage"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__key_link_begin",
          "args": [
            "keyring",
            "&key->index_key",
            "&edit"
          ],
          "line": 1373
        },
        "resolved": true,
        "details": {
          "function_name": "__key_link_begin",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1209-1272",
          "snippet": "int __key_link_begin(struct key *keyring,\n\t\t     const struct keyring_index_key *index_key,\n\t\t     struct assoc_array_edit **_edit)\n\t__acquires(&keyring->sem)\n\t__acquires(&keyring_serialise_link_sem)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"%d,%s,%s,\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tBUG_ON(index_key->desc_len == 0);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error_krsem;\n\n\t/* serialise link/link calls to prevent parallel calls causing a cycle\n\t * when linking two keyring in opposite orders */\n\tif (index_key->type == &key_type_keyring)\n\t\tdown_write(&keyring_serialise_link_sem);\n\n\t/* Create an edit script that will insert/replace the key in the\n\t * keyring tree.\n\t */\n\tedit = assoc_array_insert(&keyring->keys,\n\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t  index_key,\n\t\t\t\t  NULL);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error_sem;\n\t}\n\n\t/* If we're not replacing a link in-place then we're going to need some\n\t * extra quota.\n\t */\n\tif (!edit->dead_leaf) {\n\t\tret = key_payload_reserve(keyring,\n\t\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto error_cancel;\n\t}\n\n\t*_edit = edit;\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_cancel:\n\tassoc_array_cancel_edit(edit);\nerror_sem:\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\nerror_krsem:\n\tup_write(&keyring->sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};",
            "static DECLARE_RWSEM(keyring_serialise_link_sem);",
            "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nstatic DECLARE_RWSEM(keyring_serialise_link_sem);\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nint __key_link_begin(struct key *keyring,\n\t\t     const struct keyring_index_key *index_key,\n\t\t     struct assoc_array_edit **_edit)\n\t__acquires(&keyring->sem)\n\t__acquires(&keyring_serialise_link_sem)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"%d,%s,%s,\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tBUG_ON(index_key->desc_len == 0);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error_krsem;\n\n\t/* serialise link/link calls to prevent parallel calls causing a cycle\n\t * when linking two keyring in opposite orders */\n\tif (index_key->type == &key_type_keyring)\n\t\tdown_write(&keyring_serialise_link_sem);\n\n\t/* Create an edit script that will insert/replace the key in the\n\t * keyring tree.\n\t */\n\tedit = assoc_array_insert(&keyring->keys,\n\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t  index_key,\n\t\t\t\t  NULL);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error_sem;\n\t}\n\n\t/* If we're not replacing a link in-place then we're going to need some\n\t * extra quota.\n\t */\n\tif (!edit->dead_leaf) {\n\t\tret = key_payload_reserve(keyring,\n\t\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto error_cancel;\n\t}\n\n\t*_edit = edit;\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_cancel:\n\tassoc_array_cancel_edit(edit);\nerror_sem:\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\nerror_krsem:\n\tup_write(&keyring->sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_check",
          "args": [
            "key"
          ],
          "line": 1371
        },
        "resolved": true,
        "details": {
          "function_name": "key_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/internal.h",
          "lines": "307-311",
          "snippet": "static inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/refcount.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/task_work.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/refcount.h>\n#include <linux/keyctl.h>\n#include <linux/task_work.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/wait_bit.h>\n#include <linux/sched.h>\n\nstatic inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"{%d,%d}\"",
            "keyring->serial",
            "refcount_read(&keyring->usage)"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_read",
          "args": [
            "&keyring->usage"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nint key_link(struct key *keyring, struct key *key)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"{%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\n\tkey_check(keyring);\n\tkey_check(key);\n\n\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\tif (ret == 0) {\n\t\tkdebug(\"begun {%d,%d}\", keyring->serial, refcount_read(&keyring->usage));\n\t\tret = __key_link_check_restriction(keyring, key);\n\t\tif (ret == 0)\n\t\t\tret = __key_link_check_live_key(keyring, key);\n\t\tif (ret == 0)\n\t\t\t__key_link(key, &edit);\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\t}\n\n\tkleave(\" = %d {%d,%d}\", ret, keyring->serial, refcount_read(&keyring->usage));\n\treturn ret;\n}"
  },
  {
    "function_name": "__key_link_check_restriction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1335-1341",
    "snippet": "static int __key_link_check_restriction(struct key *keyring, struct key *key)\n{\n\tif (!keyring->restrict_link || !keyring->restrict_link->check)\n\t\treturn 0;\n\treturn keyring->restrict_link->check(keyring, key->type, &key->payload,\n\t\t\t\t\t     keyring->restrict_link->key);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyring->restrict_link->check",
          "args": [
            "keyring",
            "key->type",
            "&key->payload",
            "keyring->restrict_link->key"
          ],
          "line": 1339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nstatic int __key_link_check_restriction(struct key *keyring, struct key *key)\n{\n\tif (!keyring->restrict_link || !keyring->restrict_link->check)\n\t\treturn 0;\n\treturn keyring->restrict_link->check(keyring, key->type, &key->payload,\n\t\t\t\t\t     keyring->restrict_link->key);\n}"
  },
  {
    "function_name": "__key_link_end",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1310-1330",
    "snippet": "void __key_link_end(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key,\n\t\t    struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\n\tif (edit) {\n\t\tif (!edit->dead_leaf) {\n\t\t\tkey_payload_reserve(keyring,\n\t\t\t\tkeyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\t}\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};",
      "static DECLARE_RWSEM(keyring_serialise_link_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_cancel_edit",
          "args": [
            "edit"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_payload_reserve",
          "args": [
            "keyring",
            "keyring->datalen - KEYQUOTA_LINK_BYTES"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "key_payload_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "370-401",
          "snippet": "int key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int key_quota_root_maxbytes = 25000000;",
            "unsigned int key_quota_maxbytes = 20000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nunsigned int key_quota_root_maxbytes = 25000000;\nunsigned int key_quota_maxbytes = 20000;\n\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&keyring_serialise_link_sem"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"%d,%s,\"",
            "keyring->serial",
            "index_key->type->name"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index_key->type == NULL"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&keyring_serialise_link_sem"
          ],
          "line": 1314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&keyring->sem"
          ],
          "line": 1313
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nstatic DECLARE_RWSEM(keyring_serialise_link_sem);\n\nvoid __key_link_end(struct key *keyring,\n\t\t    const struct keyring_index_key *index_key,\n\t\t    struct assoc_array_edit *edit)\n\t__releases(&keyring->sem)\n\t__releases(&keyring_serialise_link_sem)\n{\n\tBUG_ON(index_key->type == NULL);\n\tkenter(\"%d,%s,\", keyring->serial, index_key->type->name);\n\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\n\n\tif (edit) {\n\t\tif (!edit->dead_leaf) {\n\t\t\tkey_payload_reserve(keyring,\n\t\t\t\tkeyring->datalen - KEYQUOTA_LINK_BYTES);\n\t\t}\n\t\tassoc_array_cancel_edit(edit);\n\t}\n\tup_write(&keyring->sem);\n}"
  },
  {
    "function_name": "__key_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1297-1303",
    "snippet": "void __key_link(struct key *key, struct assoc_array_edit **_edit)\n{\n\t__key_get(key);\n\tassoc_array_insert_set_object(*_edit, keyring_key_to_ptr(key));\n\tassoc_array_apply_edit(*_edit);\n\t*_edit = NULL;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assoc_array_apply_edit",
          "args": [
            "*_edit"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_insert_set_object",
          "args": [
            "*_edit",
            "keyring_key_to_ptr(key)"
          ],
          "line": 1300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_key_to_ptr",
          "args": [
            "key"
          ],
          "line": 1300
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_key_to_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "51-56",
          "snippet": "static inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nstatic inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__key_get",
          "args": [
            "key"
          ],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid __key_link(struct key *key, struct assoc_array_edit **_edit)\n{\n\t__key_get(key);\n\tassoc_array_insert_set_object(*_edit, keyring_key_to_ptr(key));\n\tassoc_array_apply_edit(*_edit);\n\t*_edit = NULL;\n}"
  },
  {
    "function_name": "__key_link_check_live_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1280-1287",
    "snippet": "int __key_link_check_live_key(struct key *keyring, struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\t/* check that we aren't going to create a cycle by linking one\n\t\t * keyring to another */\n\t\treturn keyring_detect_cycle(keyring, key);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyring_detect_cycle",
          "args": [
            "keyring",
            "key"
          ],
          "line": 1285
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_detect_cycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "1187-1204",
          "snippet": "static int keyring_detect_cycle(struct key *A, struct key *B)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key\t\t= A->index_key,\n\t\t.match_data.raw_data\t= A,\n\t\t.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.iterator\t\t= keyring_detect_cycle_iterator,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_NO_UPDATE_TIME |\n\t\t\t\t\t   KEYRING_SEARCH_NO_CHECK_PERM |\n\t\t\t\t\t   KEYRING_SEARCH_DETECT_TOO_DEEP),\n\t};\n\n\trcu_read_lock();\n\tsearch_nested_keyrings(B, &ctx);\n\trcu_read_unlock();\n\treturn PTR_ERR(ctx.result) == -EAGAIN ? 0 : PTR_ERR(ctx.result);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int keyring_detect_cycle(struct key *A, struct key *B)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key\t\t= A->index_key,\n\t\t.match_data.raw_data\t= A,\n\t\t.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.iterator\t\t= keyring_detect_cycle_iterator,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_NO_UPDATE_TIME |\n\t\t\t\t\t   KEYRING_SEARCH_NO_CHECK_PERM |\n\t\t\t\t\t   KEYRING_SEARCH_DETECT_TOO_DEEP),\n\t};\n\n\trcu_read_lock();\n\tsearch_nested_keyrings(B, &ctx);\n\trcu_read_unlock();\n\treturn PTR_ERR(ctx.result) == -EAGAIN ? 0 : PTR_ERR(ctx.result);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nint __key_link_check_live_key(struct key *keyring, struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\t/* check that we aren't going to create a cycle by linking one\n\t\t * keyring to another */\n\t\treturn keyring_detect_cycle(keyring, key);\n\treturn 0;\n}"
  },
  {
    "function_name": "__key_link_begin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1209-1272",
    "snippet": "int __key_link_begin(struct key *keyring,\n\t\t     const struct keyring_index_key *index_key,\n\t\t     struct assoc_array_edit **_edit)\n\t__acquires(&keyring->sem)\n\t__acquires(&keyring_serialise_link_sem)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"%d,%s,%s,\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tBUG_ON(index_key->desc_len == 0);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error_krsem;\n\n\t/* serialise link/link calls to prevent parallel calls causing a cycle\n\t * when linking two keyring in opposite orders */\n\tif (index_key->type == &key_type_keyring)\n\t\tdown_write(&keyring_serialise_link_sem);\n\n\t/* Create an edit script that will insert/replace the key in the\n\t * keyring tree.\n\t */\n\tedit = assoc_array_insert(&keyring->keys,\n\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t  index_key,\n\t\t\t\t  NULL);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error_sem;\n\t}\n\n\t/* If we're not replacing a link in-place then we're going to need some\n\t * extra quota.\n\t */\n\tif (!edit->dead_leaf) {\n\t\tret = key_payload_reserve(keyring,\n\t\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto error_cancel;\n\t}\n\n\t*_edit = edit;\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_cancel:\n\tassoc_array_cancel_edit(edit);\nerror_sem:\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\nerror_krsem:\n\tup_write(&keyring->sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};",
      "static DECLARE_RWSEM(keyring_serialise_link_sem);",
      "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = %d\"",
            "ret"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&keyring_serialise_link_sem"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_cancel_edit",
          "args": [
            "edit"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = 0\""
          ],
          "line": 1260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_payload_reserve",
          "args": [
            "keyring",
            "keyring->datalen + KEYQUOTA_LINK_BYTES"
          ],
          "line": 1253
        },
        "resolved": true,
        "details": {
          "function_name": "key_payload_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "370-401",
          "snippet": "int key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int key_quota_root_maxbytes = 25000000;",
            "unsigned int key_quota_maxbytes = 20000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nunsigned int key_quota_root_maxbytes = 25000000;\nunsigned int key_quota_maxbytes = 20000;\n\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "edit"
          ],
          "line": 1245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "edit"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_insert",
          "args": [
            "&keyring->keys",
            "&keyring_assoc_array_ops",
            "index_key",
            "NULL"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&keyring_serialise_link_sem"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_REVOKED",
            "&keyring->flags"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "index_key->desc_len == 0"
          ],
          "line": 1221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"%d,%s,%s,\"",
            "keyring->serial",
            "index_key->type->name",
            "index_key->description"
          ],
          "line": 1218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&keyring_serialise_link_sem"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&keyring->sem"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nstatic DECLARE_RWSEM(keyring_serialise_link_sem);\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nint __key_link_begin(struct key *keyring,\n\t\t     const struct keyring_index_key *index_key,\n\t\t     struct assoc_array_edit **_edit)\n\t__acquires(&keyring->sem)\n\t__acquires(&keyring_serialise_link_sem)\n{\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tkenter(\"%d,%s,%s,\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tBUG_ON(index_key->desc_len == 0);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tdown_write(&keyring->sem);\n\n\tret = -EKEYREVOKED;\n\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\tgoto error_krsem;\n\n\t/* serialise link/link calls to prevent parallel calls causing a cycle\n\t * when linking two keyring in opposite orders */\n\tif (index_key->type == &key_type_keyring)\n\t\tdown_write(&keyring_serialise_link_sem);\n\n\t/* Create an edit script that will insert/replace the key in the\n\t * keyring tree.\n\t */\n\tedit = assoc_array_insert(&keyring->keys,\n\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t  index_key,\n\t\t\t\t  NULL);\n\tif (IS_ERR(edit)) {\n\t\tret = PTR_ERR(edit);\n\t\tgoto error_sem;\n\t}\n\n\t/* If we're not replacing a link in-place then we're going to need some\n\t * extra quota.\n\t */\n\tif (!edit->dead_leaf) {\n\t\tret = key_payload_reserve(keyring,\n\t\t\t\t\t  keyring->datalen + KEYQUOTA_LINK_BYTES);\n\t\tif (ret < 0)\n\t\t\tgoto error_cancel;\n\t}\n\n\t*_edit = edit;\n\tkleave(\" = 0\");\n\treturn 0;\n\nerror_cancel:\n\tassoc_array_cancel_edit(edit);\nerror_sem:\n\tif (index_key->type == &key_type_keyring)\n\t\tup_write(&keyring_serialise_link_sem);\nerror_krsem:\n\tup_write(&keyring->sem);\n\tkleave(\" = %d\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "keyring_detect_cycle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1187-1204",
    "snippet": "static int keyring_detect_cycle(struct key *A, struct key *B)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key\t\t= A->index_key,\n\t\t.match_data.raw_data\t= A,\n\t\t.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.iterator\t\t= keyring_detect_cycle_iterator,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_NO_UPDATE_TIME |\n\t\t\t\t\t   KEYRING_SEARCH_NO_CHECK_PERM |\n\t\t\t\t\t   KEYRING_SEARCH_DETECT_TOO_DEEP),\n\t};\n\n\trcu_read_lock();\n\tsearch_nested_keyrings(B, &ctx);\n\trcu_read_unlock();\n\treturn PTR_ERR(ctx.result) == -EAGAIN ? 0 : PTR_ERR(ctx.result);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ctx.result"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ctx.result"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_nested_keyrings",
          "args": [
            "B",
            "&ctx"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "search_nested_keyrings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "640-844",
          "snippet": "static bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);\n\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\n\t/* Check to see if this top-level keyring is what we are looking for\n\t * and whether it is valid or not.\n\t */\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\n\t/* Start processing a new keyring */\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t/* Search through the keys in this keyring before its searching its\n\t * subtrees.\n\t */\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t/* Then manually iterate through the keyrings nested in this one.\n\t *\n\t * Start from the root node of the index tree.  Because of the way the\n\t * hash function has been set up, keyrings cluster on the leftmost\n\t * branch of the root node (root slot 0) or in the root node itself.\n\t * Non-keyrings avoid the leftmost branch of the root entirely (root\n\t * slots 1-15).\n\t */\n\tptr = READ_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t/* If the root is a shortcut, either the keyring only contains\n\t\t * keyring pointers (everything clusters behind root slot 0) or\n\t\t * doesn't contain any keyring pointers.\n\t\t */\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t/* Descend to a more distal node in this keyring's content tree and go\n\t * through that.\n\t */\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\t/* Go through the slots in a node */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t/* Search a nested keyring */\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t/* We've dealt with all the slots in the current node, so now we need\n\t * to ascend to the parent and continue processing there.\n\t */\n\tptr = READ_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\n\t/* If we've ascended to the root (zero backpointer), we must have just\n\t * finished processing the leftmost branch rather than the root slots -\n\t * so there can't be any more keyrings for us to find.\n\t */\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t/* The keyring we're looking at was disqualified or didn't contain a\n\t * matching key.\n\t */\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t/* Resume the processing of a keyring higher up in the tree */\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t/* We found a viable match */\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now;\n\t\tkeyring->last_used_at = ctx->now;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)",
            "#define KEYRING_SEARCH_MAX_DEPTH 6"
          ],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n#define KEYRING_SEARCH_MAX_DEPTH 6\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nstatic bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);\n\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\n\t/* Check to see if this top-level keyring is what we are looking for\n\t * and whether it is valid or not.\n\t */\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\n\t/* Start processing a new keyring */\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t/* Search through the keys in this keyring before its searching its\n\t * subtrees.\n\t */\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t/* Then manually iterate through the keyrings nested in this one.\n\t *\n\t * Start from the root node of the index tree.  Because of the way the\n\t * hash function has been set up, keyrings cluster on the leftmost\n\t * branch of the root node (root slot 0) or in the root node itself.\n\t * Non-keyrings avoid the leftmost branch of the root entirely (root\n\t * slots 1-15).\n\t */\n\tptr = READ_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t/* If the root is a shortcut, either the keyring only contains\n\t\t * keyring pointers (everything clusters behind root slot 0) or\n\t\t * doesn't contain any keyring pointers.\n\t\t */\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t/* Descend to a more distal node in this keyring's content tree and go\n\t * through that.\n\t */\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\t/* Go through the slots in a node */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t/* Search a nested keyring */\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t/* We've dealt with all the slots in the current node, so now we need\n\t * to ascend to the parent and continue processing there.\n\t */\n\tptr = READ_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\n\t/* If we've ascended to the root (zero backpointer), we must have just\n\t * finished processing the leftmost branch rather than the root slots -\n\t * so there can't be any more keyrings for us to find.\n\t */\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t/* The keyring we're looking at was disqualified or didn't contain a\n\t * matching key.\n\t */\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t/* Resume the processing of a keyring higher up in the tree */\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t/* We found a viable match */\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now;\n\t\tkeyring->last_used_at = ctx->now;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int keyring_detect_cycle(struct key *A, struct key *B)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key\t\t= A->index_key,\n\t\t.match_data.raw_data\t= A,\n\t\t.match_data.lookup_type = KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.iterator\t\t= keyring_detect_cycle_iterator,\n\t\t.flags\t\t\t= (KEYRING_SEARCH_NO_STATE_CHECK |\n\t\t\t\t\t   KEYRING_SEARCH_NO_UPDATE_TIME |\n\t\t\t\t\t   KEYRING_SEARCH_NO_CHECK_PERM |\n\t\t\t\t\t   KEYRING_SEARCH_DETECT_TOO_DEEP),\n\t};\n\n\trcu_read_lock();\n\tsearch_nested_keyrings(B, &ctx);\n\trcu_read_unlock();\n\treturn PTR_ERR(ctx.result) == -EAGAIN ? 0 : PTR_ERR(ctx.result);\n}"
  },
  {
    "function_name": "keyring_detect_cycle_iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1163-1178",
    "snippet": "static int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* We might get a keyring with matching index-key that is nonetheless a\n\t * different keyring. */\n\tif (key != ctx->match_data.raw_data)\n\t\treturn 0;\n\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EDEADLK"
          ],
          "line": 1176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"{%d}\"",
            "key->serial"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_ptr_to_key",
          "args": [
            "object"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_ptr_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "46-50",
          "snippet": "static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nstatic int keyring_detect_cycle_iterator(const void *object,\n\t\t\t\t\t void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* We might get a keyring with matching index-key that is nonetheless a\n\t * different keyring. */\n\tif (key != ctx->match_data.raw_data)\n\t\treturn 0;\n\n\tctx->result = ERR_PTR(-EDEADLK);\n\treturn 1;\n}"
  },
  {
    "function_name": "find_keyring_by_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1109-1161",
    "snippet": "struct key *find_keyring_by_name(const char *name, bool uid_keyring)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\n\tif (keyring_name_hash[bucket].next) {\n\t\t/* search this hash bucket for a keyring with a matching name\n\t\t * that's readable and that hasn't been revoked */\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (uid_keyring) {\n\t\t\t\tif (!test_bit(KEY_FLAG_UID_KEYRING,\n\t\t\t\t\t      &keyring->flags))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) */\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = ktime_get_real_seconds();\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];",
      "static DEFINE_RWLOCK(keyring_name_lock);",
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&keyring_name_lock"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOKEY"
          ],
          "line": 1157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "refcount_inc_not_zero",
          "args": [
            "&keyring->usage"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_permission",
          "args": [
            "make_key_ref(keyring, 0)",
            "KEY_NEED_SEARCH"
          ],
          "line": 1142
        },
        "resolved": true,
        "details": {
          "function_name": "key_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/internal.h",
          "lines": "186-189",
          "snippet": "static inline int key_permission(const key_ref_t key_ref, unsigned perm)\n{\n\treturn key_task_permission(key_ref, current_cred(), perm);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/refcount.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/task_work.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/refcount.h>\n#include <linux/keyctl.h>\n#include <linux/task_work.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/wait_bit.h>\n#include <linux/sched.h>\n\nstatic inline int key_permission(const key_ref_t key_ref, unsigned perm)\n{\n\treturn key_task_permission(key_ref, current_cred(), perm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "keyring",
            "0"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_UID_KEYRING",
            "&keyring->flags"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "keyring->description",
            "name"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "KEY_FLAG_REVOKED",
            "&keyring->flags"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kuid_has_mapping",
          "args": [
            "current_user_ns()",
            "keyring->user->uid"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "keyring",
            "&keyring_name_hash[bucket]",
            "name_link"
          ],
          "line": 1124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&keyring_name_lock"
          ],
          "line": 1119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_hash",
          "args": [
            "name"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "61-69",
          "snippet": "static inline unsigned keyring_hash(const char *desc)\n{\n\tunsigned bucket = 0;\n\n\tfor (; *desc; desc++)\n\t\tbucket += (unsigned char)*desc;\n\n\treturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_NAME_HASH_SIZE\t(1 << 5)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_NAME_HASH_SIZE\t(1 << 5)\n\nstatic inline unsigned keyring_hash(const char *desc)\n{\n\tunsigned bucket = 0;\n\n\tfor (; *desc; desc++)\n\t\tbucket += (unsigned char)*desc;\n\n\treturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];\nstatic DEFINE_RWLOCK(keyring_name_lock);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nstruct key *find_keyring_by_name(const char *name, bool uid_keyring)\n{\n\tstruct key *keyring;\n\tint bucket;\n\n\tif (!name)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tbucket = keyring_hash(name);\n\n\tread_lock(&keyring_name_lock);\n\n\tif (keyring_name_hash[bucket].next) {\n\t\t/* search this hash bucket for a keyring with a matching name\n\t\t * that's readable and that hasn't been revoked */\n\t\tlist_for_each_entry(keyring,\n\t\t\t\t    &keyring_name_hash[bucket],\n\t\t\t\t    name_link\n\t\t\t\t    ) {\n\t\t\tif (!kuid_has_mapping(current_user_ns(), keyring->user->uid))\n\t\t\t\tcontinue;\n\n\t\t\tif (test_bit(KEY_FLAG_REVOKED, &keyring->flags))\n\t\t\t\tcontinue;\n\n\t\t\tif (strcmp(keyring->description, name) != 0)\n\t\t\t\tcontinue;\n\n\t\t\tif (uid_keyring) {\n\t\t\t\tif (!test_bit(KEY_FLAG_UID_KEYRING,\n\t\t\t\t\t      &keyring->flags))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif (key_permission(make_key_ref(keyring, 0),\n\t\t\t\t\t\t   KEY_NEED_SEARCH) < 0)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* we've got a match but we might end up racing with\n\t\t\t * key_cleanup() if the keyring is currently 'dead'\n\t\t\t * (ie. it has a zero usage count) */\n\t\t\tif (!refcount_inc_not_zero(&keyring->usage))\n\t\t\t\tcontinue;\n\t\t\tkeyring->last_used_at = ktime_get_real_seconds();\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tkeyring = ERR_PTR(-ENOKEY);\nout:\n\tread_unlock(&keyring_name_lock);\n\treturn keyring;\n}"
  },
  {
    "function_name": "find_key_to_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "1066-1096",
    "snippet": "key_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "key",
            "is_key_possessed(keyring_ref)"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_key_possessed",
          "args": [
            "keyring_ref"
          ],
          "line": 1095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = {%d}\"",
            "key->serial"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__key_get",
          "args": [
            "key"
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = NULL [x]\""
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_ptr_to_key",
          "args": [
            "object"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_ptr_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "46-50",
          "snippet": "static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = NULL\""
          ],
          "line": 1083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_find",
          "args": [
            "&keyring->keys",
            "&keyring_assoc_array_ops",
            "index_key"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"{%d},{%s,%s}\"",
            "keyring->serial",
            "index_key->type->name",
            "index_key->description"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "keyring_ref"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nkey_ref_t find_key_to_update(key_ref_t keyring_ref,\n\t\t\t     const struct keyring_index_key *index_key)\n{\n\tstruct key *keyring, *key;\n\tconst void *object;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial, index_key->type->name, index_key->description);\n\n\tobject = assoc_array_find(&keyring->keys, &keyring_assoc_array_ops,\n\t\t\t\t  index_key);\n\n\tif (object)\n\t\tgoto found;\n\n\tkleave(\" = NULL\");\n\treturn NULL;\n\nfound:\n\tkey = keyring_ptr_to_key(object);\n\tif (key->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t  (1 << KEY_FLAG_REVOKED))) {\n\t\tkleave(\" = NULL [x]\");\n\t\treturn NULL;\n\t}\n\t__key_get(key);\n\tkleave(\" = {%d}\", key->serial);\n\treturn make_key_ref(key, is_key_possessed(keyring_ref));\n}"
  },
  {
    "function_name": "keyring_restrict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "991-1049",
    "snippet": "int keyring_restrict(key_ref_t keyring_ref, const char *type,\n\t\t     const char *restriction)\n{\n\tstruct key *keyring;\n\tstruct key_type *restrict_type = NULL;\n\tstruct key_restriction *restrict_link;\n\tint ret = 0;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tif (!type) {\n\t\trestrict_link = keyring_restriction_alloc(restrict_link_reject);\n\t} else {\n\t\trestrict_type = key_type_lookup(type);\n\n\t\tif (IS_ERR(restrict_type))\n\t\t\treturn PTR_ERR(restrict_type);\n\n\t\tif (!restrict_type->lookup_restriction) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestrict_link = restrict_type->lookup_restriction(restriction);\n\t}\n\n\tif (IS_ERR(restrict_link)) {\n\t\tret = PTR_ERR(restrict_link);\n\t\tgoto error;\n\t}\n\n\tdown_write(&keyring->sem);\n\tdown_write(&keyring_serialise_restrict_sem);\n\n\tif (keyring->restrict_link)\n\t\tret = -EEXIST;\n\telse if (keyring_detect_restriction_cycle(keyring, restrict_link))\n\t\tret = -EDEADLK;\n\telse\n\t\tkeyring->restrict_link = restrict_link;\n\n\tup_write(&keyring_serialise_restrict_sem);\n\tup_write(&keyring->sem);\n\n\tif (ret < 0) {\n\t\tkey_put(restrict_link->key);\n\t\tkfree(restrict_link);\n\t}\n\nerror:\n\tif (restrict_type)\n\t\tkey_type_put(restrict_type);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};",
      "static DECLARE_RWSEM(keyring_serialise_restrict_sem);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_type_put",
          "args": [
            "restrict_type"
          ],
          "line": 1046
        },
        "resolved": true,
        "details": {
          "function_name": "key_type_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "729-732",
          "snippet": "void key_type_put(struct key_type *ktype)\n{\n\tup_read(&key_types_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(key_types_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(key_types_sem);\n\nvoid key_type_put(struct key_type *ktype)\n{\n\tup_read(&key_types_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "restrict_link"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "restrict_link->key"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&keyring_serialise_restrict_sem"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_detect_restriction_cycle",
          "args": [
            "keyring",
            "restrict_link"
          ],
          "line": 1031
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_detect_restriction_cycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "971-983",
          "snippet": "static bool keyring_detect_restriction_cycle(const struct key *dest_keyring,\n\t\t\t\t\t     struct key_restriction *keyres)\n{\n\twhile (keyres && keyres->key &&\n\t       keyres->key->type == &key_type_keyring) {\n\t\tif (keyres->key == dest_keyring)\n\t\t\treturn true;\n\n\t\tkeyres = keyres->key->restrict_link;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nstatic bool keyring_detect_restriction_cycle(const struct key *dest_keyring,\n\t\t\t\t\t     struct key_restriction *keyres)\n{\n\twhile (keyres && keyres->key &&\n\t       keyres->key->type == &key_type_keyring) {\n\t\tif (keyres->key == dest_keyring)\n\t\t\treturn true;\n\n\t\tkeyres = keyres->key->restrict_link;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&keyring_serialise_restrict_sem"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&keyring->sem"
          ],
          "line": 1026
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "restrict_link"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "restrict_link"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "restrict_type->lookup_restriction",
          "args": [
            "restriction"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "restrict_type"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "restrict_type"
          ],
          "line": 1010
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_type_lookup",
          "args": [
            "type"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "key_type_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "689-707",
          "snippet": "struct key_type *key_type_lookup(const char *type)\n{\n\tstruct key_type *ktype;\n\n\tdown_read(&key_types_sem);\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tlist_for_each_entry(ktype, &key_types_list, link) {\n\t\tif (strcmp(ktype->name, type) == 0)\n\t\t\tgoto found_kernel_type;\n\t}\n\n\tup_read(&key_types_sem);\n\tktype = ERR_PTR(-ENOKEY);\n\nfound_kernel_type:\n\treturn ktype;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(key_types_list);",
            "static DECLARE_RWSEM(key_types_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(key_types_list);\nstatic DECLARE_RWSEM(key_types_sem);\n\nstruct key_type *key_type_lookup(const char *type)\n{\n\tstruct key_type *ktype;\n\n\tdown_read(&key_types_sem);\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tlist_for_each_entry(ktype, &key_types_list, link) {\n\t\tif (strcmp(ktype->name, type) == 0)\n\t\t\tgoto found_kernel_type;\n\t}\n\n\tup_read(&key_types_sem);\n\tktype = ERR_PTR(-ENOKEY);\n\nfound_kernel_type:\n\treturn ktype;\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyring_restriction_alloc",
          "args": [
            "restrict_link_reject"
          ],
          "line": 1006
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_restriction_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "947-959",
          "snippet": "static struct key_restriction *keyring_restriction_alloc(\n\tkey_restrict_link_func_t check)\n{\n\tstruct key_restriction *keyres =\n\t\tkzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\n\tif (!keyres)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkeyres->check = check;\n\n\treturn keyres;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct key_restriction *keyring_restriction_alloc(\n\tkey_restrict_link_func_t check)\n{\n\tstruct key_restriction *keyres =\n\t\tkzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\n\tif (!keyres)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkeyres->check = check;\n\n\treturn keyres;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_check",
          "args": [
            "keyring"
          ],
          "line": 1000
        },
        "resolved": true,
        "details": {
          "function_name": "key_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/internal.h",
          "lines": "307-311",
          "snippet": "static inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/refcount.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/task_work.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/refcount.h>\n#include <linux/keyctl.h>\n#include <linux/task_work.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/wait_bit.h>\n#include <linux/sched.h>\n\nstatic inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "keyring_ref"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\nstatic DECLARE_RWSEM(keyring_serialise_restrict_sem);\n\nint keyring_restrict(key_ref_t keyring_ref, const char *type,\n\t\t     const char *restriction)\n{\n\tstruct key *keyring;\n\tstruct key_type *restrict_type = NULL;\n\tstruct key_restriction *restrict_link;\n\tint ret = 0;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn -ENOTDIR;\n\n\tif (!type) {\n\t\trestrict_link = keyring_restriction_alloc(restrict_link_reject);\n\t} else {\n\t\trestrict_type = key_type_lookup(type);\n\n\t\tif (IS_ERR(restrict_type))\n\t\t\treturn PTR_ERR(restrict_type);\n\n\t\tif (!restrict_type->lookup_restriction) {\n\t\t\tret = -ENOENT;\n\t\t\tgoto error;\n\t\t}\n\n\t\trestrict_link = restrict_type->lookup_restriction(restriction);\n\t}\n\n\tif (IS_ERR(restrict_link)) {\n\t\tret = PTR_ERR(restrict_link);\n\t\tgoto error;\n\t}\n\n\tdown_write(&keyring->sem);\n\tdown_write(&keyring_serialise_restrict_sem);\n\n\tif (keyring->restrict_link)\n\t\tret = -EEXIST;\n\telse if (keyring_detect_restriction_cycle(keyring, restrict_link))\n\t\tret = -EDEADLK;\n\telse\n\t\tkeyring->restrict_link = restrict_link;\n\n\tup_write(&keyring_serialise_restrict_sem);\n\tup_write(&keyring->sem);\n\n\tif (ret < 0) {\n\t\tkey_put(restrict_link->key);\n\t\tkfree(restrict_link);\n\t}\n\nerror:\n\tif (restrict_type)\n\t\tkey_type_put(restrict_type);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "keyring_detect_restriction_cycle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "971-983",
    "snippet": "static bool keyring_detect_restriction_cycle(const struct key *dest_keyring,\n\t\t\t\t\t     struct key_restriction *keyres)\n{\n\twhile (keyres && keyres->key &&\n\t       keyres->key->type == &key_type_keyring) {\n\t\tif (keyres->key == dest_keyring)\n\t\t\treturn true;\n\n\t\tkeyres = keyres->key->restrict_link;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nstatic bool keyring_detect_restriction_cycle(const struct key *dest_keyring,\n\t\t\t\t\t     struct key_restriction *keyres)\n{\n\twhile (keyres && keyres->key &&\n\t       keyres->key->type == &key_type_keyring) {\n\t\tif (keyres->key == dest_keyring)\n\t\t\treturn true;\n\n\t\tkeyres = keyres->key->restrict_link;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "keyring_restriction_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "947-959",
    "snippet": "static struct key_restriction *keyring_restriction_alloc(\n\tkey_restrict_link_func_t check)\n{\n\tstruct key_restriction *keyres =\n\t\tkzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\n\tif (!keyres)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkeyres->check = check;\n\n\treturn keyres;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 954
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct key_restriction)",
            "GFP_KERNEL"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct key_restriction *keyring_restriction_alloc(\n\tkey_restrict_link_func_t check)\n{\n\tstruct key_restriction *keyres =\n\t\tkzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\n\tif (!keyres)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tkeyres->check = check;\n\n\treturn keyres;\n}"
  },
  {
    "function_name": "keyring_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "917-944",
    "snippet": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "type->match_free",
          "args": [
            "&ctx.match_data"
          ],
          "line": 942
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_search_aux",
          "args": [
            "keyring",
            "&ctx"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_search_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "878-906",
          "snippet": "key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t     struct keyring_search_context *ctx)\n{\n\tstruct key *keyring;\n\tlong err;\n\n\tctx->iterator = keyring_search_iterator;\n\tctx->possessed = is_key_possessed(keyring_ref);\n\tctx->result = ERR_PTR(-EAGAIN);\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\n\t\terr = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\trcu_read_lock();\n\tctx->now = ktime_get_real_seconds();\n\tif (search_nested_keyrings(keyring, ctx))\n\t\t__key_get(key_ref_to_ptr(ctx->result));\n\trcu_read_unlock();\n\treturn ctx->result;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nkey_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t     struct keyring_search_context *ctx)\n{\n\tstruct key *keyring;\n\tlong err;\n\n\tctx->iterator = keyring_search_iterator;\n\tctx->possessed = is_key_possessed(keyring_ref);\n\tctx->result = ERR_PTR(-EAGAIN);\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\n\t\terr = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\trcu_read_lock();\n\tctx->now = ktime_get_real_seconds();\n\tif (search_nested_keyrings(keyring, ctx))\n\t\t__key_get(key_ref_to_ptr(ctx->result));\n\trcu_read_unlock();\n\treturn ctx->result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "type->match_preparse",
          "args": [
            "&ctx.match_data"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nkey_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}"
  },
  {
    "function_name": "keyring_search_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "878-906",
    "snippet": "key_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t     struct keyring_search_context *ctx)\n{\n\tstruct key *keyring;\n\tlong err;\n\n\tctx->iterator = keyring_search_iterator;\n\tctx->possessed = is_key_possessed(keyring_ref);\n\tctx->result = ERR_PTR(-EAGAIN);\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\n\t\terr = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\trcu_read_lock();\n\tctx->now = ktime_get_real_seconds();\n\tif (search_nested_keyrings(keyring, ctx))\n\t\t__key_get(key_ref_to_ptr(ctx->result));\n\trcu_read_unlock();\n\treturn ctx->result;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__key_get",
          "args": [
            "key_ref_to_ptr(ctx->result)"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "ctx->result"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_nested_keyrings",
          "args": [
            "keyring",
            "ctx"
          ],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "search_nested_keyrings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "640-844",
          "snippet": "static bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);\n\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\n\t/* Check to see if this top-level keyring is what we are looking for\n\t * and whether it is valid or not.\n\t */\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\n\t/* Start processing a new keyring */\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t/* Search through the keys in this keyring before its searching its\n\t * subtrees.\n\t */\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t/* Then manually iterate through the keyrings nested in this one.\n\t *\n\t * Start from the root node of the index tree.  Because of the way the\n\t * hash function has been set up, keyrings cluster on the leftmost\n\t * branch of the root node (root slot 0) or in the root node itself.\n\t * Non-keyrings avoid the leftmost branch of the root entirely (root\n\t * slots 1-15).\n\t */\n\tptr = READ_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t/* If the root is a shortcut, either the keyring only contains\n\t\t * keyring pointers (everything clusters behind root slot 0) or\n\t\t * doesn't contain any keyring pointers.\n\t\t */\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t/* Descend to a more distal node in this keyring's content tree and go\n\t * through that.\n\t */\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\t/* Go through the slots in a node */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t/* Search a nested keyring */\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t/* We've dealt with all the slots in the current node, so now we need\n\t * to ascend to the parent and continue processing there.\n\t */\n\tptr = READ_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\n\t/* If we've ascended to the root (zero backpointer), we must have just\n\t * finished processing the leftmost branch rather than the root slots -\n\t * so there can't be any more keyrings for us to find.\n\t */\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t/* The keyring we're looking at was disqualified or didn't contain a\n\t * matching key.\n\t */\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t/* Resume the processing of a keyring higher up in the tree */\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t/* We found a viable match */\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now;\n\t\tkeyring->last_used_at = ctx->now;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)",
            "#define KEYRING_SEARCH_MAX_DEPTH 6"
          ],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n#define KEYRING_SEARCH_MAX_DEPTH 6\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nstatic bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);\n\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\n\t/* Check to see if this top-level keyring is what we are looking for\n\t * and whether it is valid or not.\n\t */\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\n\t/* Start processing a new keyring */\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t/* Search through the keys in this keyring before its searching its\n\t * subtrees.\n\t */\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t/* Then manually iterate through the keyrings nested in this one.\n\t *\n\t * Start from the root node of the index tree.  Because of the way the\n\t * hash function has been set up, keyrings cluster on the leftmost\n\t * branch of the root node (root slot 0) or in the root node itself.\n\t * Non-keyrings avoid the leftmost branch of the root entirely (root\n\t * slots 1-15).\n\t */\n\tptr = READ_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t/* If the root is a shortcut, either the keyring only contains\n\t\t * keyring pointers (everything clusters behind root slot 0) or\n\t\t * doesn't contain any keyring pointers.\n\t\t */\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t/* Descend to a more distal node in this keyring's content tree and go\n\t * through that.\n\t */\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\t/* Go through the slots in a node */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t/* Search a nested keyring */\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t/* We've dealt with all the slots in the current node, so now we need\n\t * to ascend to the parent and continue processing there.\n\t */\n\tptr = READ_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\n\t/* If we've ascended to the root (zero backpointer), we must have just\n\t * finished processing the leftmost branch rather than the root slots -\n\t * so there can't be any more keyrings for us to find.\n\t */\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t/* The keyring we're looking at was disqualified or didn't contain a\n\t * matching key.\n\t */\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t/* Resume the processing of a keyring higher up in the tree */\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t/* We found a viable match */\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now;\n\t\tkeyring->last_used_at = ctx->now;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_real_seconds",
          "args": [],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_task_permission",
          "args": [
            "keyring_ref",
            "ctx->cred",
            "KEY_NEED_SEARCH"
          ],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "key_task_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/permission.c",
          "lines": "30-78",
          "snippet": "int key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tunsigned perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm;\n\tint ret;\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* use the second 8-bits of permissions for keys the caller owns */\n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t/* use the third 8-bits of permissions for keys the caller has a group\n\t * membership in common with */\n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t/* otherwise use the least-significant 8-bits */\n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t/* use the top 8-bits of permissions for keys the caller possesses\n\t * - possessor permissions are additive with other permissions\n\t */\n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tkperm = kperm & perm & KEY_NEED_ALL;\n\n\tif (kperm != perm)\n\t\treturn -EACCES;\n\n\t/* let LSM be the final arbiter */\n\treturn security_key_permission(key_ref, cred, perm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/security.h>\n#include <linux/module.h>\n\nint key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tunsigned perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm;\n\tint ret;\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* use the second 8-bits of permissions for keys the caller owns */\n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t/* use the third 8-bits of permissions for keys the caller has a group\n\t * membership in common with */\n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t/* otherwise use the least-significant 8-bits */\n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t/* use the top 8-bits of permissions for keys the caller possesses\n\t * - possessor permissions are additive with other permissions\n\t */\n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tkperm = kperm & perm & KEY_NEED_ALL;\n\n\tif (kperm != perm)\n\t\treturn -EACCES;\n\n\t/* let LSM be the final arbiter */\n\treturn security_key_permission(key_ref, cred, perm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOTDIR"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_check",
          "args": [
            "keyring"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "key_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/internal.h",
          "lines": "307-311",
          "snippet": "static inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/refcount.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/task_work.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/refcount.h>\n#include <linux/keyctl.h>\n#include <linux/task_work.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/wait_bit.h>\n#include <linux/sched.h>\n\nstatic inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "keyring_ref"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EAGAIN"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_key_possessed",
          "args": [
            "keyring_ref"
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nkey_ref_t keyring_search_aux(key_ref_t keyring_ref,\n\t\t\t     struct keyring_search_context *ctx)\n{\n\tstruct key *keyring;\n\tlong err;\n\n\tctx->iterator = keyring_search_iterator;\n\tctx->possessed = is_key_possessed(keyring_ref);\n\tctx->result = ERR_PTR(-EAGAIN);\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\tkey_check(keyring);\n\n\tif (keyring->type != &key_type_keyring)\n\t\treturn ERR_PTR(-ENOTDIR);\n\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM)) {\n\t\terr = key_task_permission(keyring_ref, ctx->cred, KEY_NEED_SEARCH);\n\t\tif (err < 0)\n\t\t\treturn ERR_PTR(err);\n\t}\n\n\trcu_read_lock();\n\tctx->now = ktime_get_real_seconds();\n\tif (search_nested_keyrings(keyring, ctx))\n\t\t__key_get(key_ref_to_ptr(ctx->result));\n\trcu_read_unlock();\n\treturn ctx->result;\n}"
  },
  {
    "function_name": "search_nested_keyrings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "640-844",
    "snippet": "static bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);\n\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\n\t/* Check to see if this top-level keyring is what we are looking for\n\t * and whether it is valid or not.\n\t */\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\n\t/* Start processing a new keyring */\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t/* Search through the keys in this keyring before its searching its\n\t * subtrees.\n\t */\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t/* Then manually iterate through the keyrings nested in this one.\n\t *\n\t * Start from the root node of the index tree.  Because of the way the\n\t * hash function has been set up, keyrings cluster on the leftmost\n\t * branch of the root node (root slot 0) or in the root node itself.\n\t * Non-keyrings avoid the leftmost branch of the root entirely (root\n\t * slots 1-15).\n\t */\n\tptr = READ_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t/* If the root is a shortcut, either the keyring only contains\n\t\t * keyring pointers (everything clusters behind root slot 0) or\n\t\t * doesn't contain any keyring pointers.\n\t\t */\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t/* Descend to a more distal node in this keyring's content tree and go\n\t * through that.\n\t */\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\t/* Go through the slots in a node */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t/* Search a nested keyring */\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t/* We've dealt with all the slots in the current node, so now we need\n\t * to ascend to the parent and continue processing there.\n\t */\n\tptr = READ_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\n\t/* If we've ascended to the root (zero backpointer), we must have just\n\t * finished processing the leftmost branch rather than the root slots -\n\t * so there can't be any more keyrings for us to find.\n\t */\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t/* The keyring we're looking at was disqualified or didn't contain a\n\t * matching key.\n\t */\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t/* Resume the processing of a keyring higher up in the tree */\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t/* We found a viable match */\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now;\n\t\tkeyring->last_used_at = ctx->now;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)",
      "#define KEYRING_SEARCH_MAX_DEPTH 6"
    ],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = true\""
          ],
          "line": 842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_check",
          "args": [
            "key"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "key_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/internal.h",
          "lines": "307-311",
          "snippet": "static inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}",
          "includes": [
            "#include <linux/compat.h>",
            "#include <linux/refcount.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/task_work.h>",
            "#include <linux/key-type.h>",
            "#include <linux/cred.h>",
            "#include <linux/wait_bit.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compat.h>\n#include <linux/refcount.h>\n#include <linux/keyctl.h>\n#include <linux/task_work.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/wait_bit.h>\n#include <linux/sched.h>\n\nstatic inline void key_check(const struct key *key)\n{\n\tif (key && (IS_ERR(key) || key->magic != KEY_DEBUG_MAGIC))\n\t\t__key_check(key);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "ctx->result"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"ascend to %d [%d]\"",
            "keyring->serial",
            "slot"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = false\""
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"not_this_keyring %d\"",
            "sp"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"ascend %d\"",
            "slot"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_read_barrier_depends",
          "args": [],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_to_node",
          "args": [
            "ptr"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "shortcut->back_pointer"
          ],
          "line": 796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_read_barrier_depends",
          "args": [],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_to_shortcut",
          "args": [
            "ptr"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_is_shortcut",
          "args": [
            "ptr"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "node->back_pointer"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_task_permission",
          "args": [
            "make_key_ref(key, ctx->possessed)",
            "ctx->cred",
            "KEY_NEED_SEARCH"
          ],
          "line": 772
        },
        "resolved": true,
        "details": {
          "function_name": "key_task_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/permission.c",
          "lines": "30-78",
          "snippet": "int key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tunsigned perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm;\n\tint ret;\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* use the second 8-bits of permissions for keys the caller owns */\n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t/* use the third 8-bits of permissions for keys the caller has a group\n\t * membership in common with */\n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t/* otherwise use the least-significant 8-bits */\n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t/* use the top 8-bits of permissions for keys the caller possesses\n\t * - possessor permissions are additive with other permissions\n\t */\n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tkperm = kperm & perm & KEY_NEED_ALL;\n\n\tif (kperm != perm)\n\t\treturn -EACCES;\n\n\t/* let LSM be the final arbiter */\n\treturn security_key_permission(key_ref, cred, perm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/security.h>\n#include <linux/module.h>\n\nint key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tunsigned perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm;\n\tint ret;\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* use the second 8-bits of permissions for keys the caller owns */\n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t/* use the third 8-bits of permissions for keys the caller has a group\n\t * membership in common with */\n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t/* otherwise use the least-significant 8-bits */\n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t/* use the top 8-bits of permissions for keys the caller possesses\n\t * - possessor permissions are additive with other permissions\n\t */\n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tkperm = kperm & perm & KEY_NEED_ALL;\n\n\tif (kperm != perm)\n\t\treturn -EACCES;\n\n\t/* let LSM be the final arbiter */\n\treturn security_key_permission(key_ref, cred, perm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "key",
            "ctx->possessed"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ELOOP"
          ],
          "line": 764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_ptr_to_key",
          "args": [
            "ptr"
          ],
          "line": 760
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_ptr_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "46-50",
          "snippet": "static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyring_ptr_is_keyring",
          "args": [
            "ptr"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_ptr_is_keyring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "42-45",
          "snippet": "static inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)\n{\n\treturn (unsigned long)x & KEYRING_PTR_SUBTYPE;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)\n{\n\treturn (unsigned long)x & KEYRING_PTR_SUBTYPE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_is_meta",
          "args": [
            "ptr"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "node->slots[slot]"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_read_barrier_depends",
          "args": [],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"begin_node\""
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_to_node",
          "args": [
            "ptr"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!assoc_array_ptr_is_node(ptr)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_is_node",
          "args": [
            "ptr"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "shortcut->next_node"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_read_barrier_depends",
          "args": [],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_to_shortcut",
          "args": [
            "ptr"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_is_shortcut",
          "args": [
            "ptr"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"descend\""
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_is_meta",
          "args": [
            "ptr"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_read_barrier_depends",
          "args": [],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_to_node",
          "args": [
            "ptr"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_to_node",
          "args": [
            "ptr"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "shortcut->next_node"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_read_barrier_depends",
          "args": [],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_to_shortcut",
          "args": [
            "ptr"
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_ptr_is_shortcut",
          "args": [
            "ptr"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "keyring->keys.root"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "search_keyring",
          "args": [
            "keyring",
            "ctx"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "search_keyring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "623-634",
          "snippet": "static int search_keyring(struct key *keyring, struct keyring_search_context *ctx)\n{\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_DIRECT) {\n\t\tconst void *object;\n\n\t\tobject = assoc_array_find(&keyring->keys,\n\t\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t\t  &ctx->index_key);\n\t\treturn object ? ctx->iterator(object, ctx) : 0;\n\t}\n\treturn assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nstatic int search_keyring(struct key *keyring, struct keyring_search_context *ctx)\n{\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_DIRECT) {\n\t\tconst void *object;\n\n\t\tobject = assoc_array_find(&keyring->keys,\n\t\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t\t  &ctx->index_key);\n\t\treturn object ? ctx->iterator(object, ctx) : 0;\n\t}\n\treturn assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"descend to %d\"",
            "keyring->serial"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctx->iterator",
          "args": [
            "keyring_key_to_ptr(keyring)",
            "ctx"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_key_to_ptr",
          "args": [
            "keyring"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_key_to_ptr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "51-56",
          "snippet": "static inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nstatic inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyring_compare_object",
          "args": [
            "keyring",
            "&ctx->index_key"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_compare_object",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "278-287",
          "snippet": "static bool keyring_compare_object(const void *object, const void *data)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\treturn key->index_key.type == index_key->type &&\n\t\tkey->index_key.desc_len == index_key->desc_len &&\n\t\tmemcmp(key->index_key.description, index_key->description,\n\t\t       index_key->desc_len) == 0;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool keyring_compare_object(const void *object, const void *data)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\treturn key->index_key.type == index_key->type &&\n\t\tkey->index_key.desc_len == index_key->desc_len &&\n\t\tmemcmp(key->index_key.description, index_key->description,\n\t\t       index_key->desc_len) == 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ctx->index_key.description"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"{%d},{%s,%s}\"",
            "keyring->serial",
            "ctx->index_key.type->name",
            "ctx->index_key.description"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n#define KEYRING_SEARCH_MAX_DEPTH 6\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nstatic bool search_nested_keyrings(struct key *keyring,\n\t\t\t\t   struct keyring_search_context *ctx)\n{\n\tstruct {\n\t\tstruct key *keyring;\n\t\tstruct assoc_array_node *node;\n\t\tint slot;\n\t} stack[KEYRING_SEARCH_MAX_DEPTH];\n\n\tstruct assoc_array_shortcut *shortcut;\n\tstruct assoc_array_node *node;\n\tstruct assoc_array_ptr *ptr;\n\tstruct key *key;\n\tint sp = 0, slot;\n\n\tkenter(\"{%d},{%s,%s}\",\n\t       keyring->serial,\n\t       ctx->index_key.type->name,\n\t       ctx->index_key.description);\n\n#define STATE_CHECKS (KEYRING_SEARCH_NO_STATE_CHECK | KEYRING_SEARCH_DO_STATE_CHECK)\n\tBUG_ON((ctx->flags & STATE_CHECKS) == 0 ||\n\t       (ctx->flags & STATE_CHECKS) == STATE_CHECKS);\n\n\tif (ctx->index_key.description)\n\t\tctx->index_key.desc_len = strlen(ctx->index_key.description);\n\n\t/* Check to see if this top-level keyring is what we are looking for\n\t * and whether it is valid or not.\n\t */\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_ITERATE ||\n\t    keyring_compare_object(keyring, &ctx->index_key)) {\n\t\tctx->skipped_ret = 2;\n\t\tswitch (ctx->iterator(keyring_key_to_ptr(keyring), ctx)) {\n\t\tcase 1:\n\t\t\tgoto found;\n\t\tcase 2:\n\t\t\treturn false;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tctx->skipped_ret = 0;\n\n\t/* Start processing a new keyring */\ndescend_to_keyring:\n\tkdebug(\"descend to %d\", keyring->serial);\n\tif (keyring->flags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED)))\n\t\tgoto not_this_keyring;\n\n\t/* Search through the keys in this keyring before its searching its\n\t * subtrees.\n\t */\n\tif (search_keyring(keyring, ctx))\n\t\tgoto found;\n\n\t/* Then manually iterate through the keyrings nested in this one.\n\t *\n\t * Start from the root node of the index tree.  Because of the way the\n\t * hash function has been set up, keyrings cluster on the leftmost\n\t * branch of the root node (root slot 0) or in the root node itself.\n\t * Non-keyrings avoid the leftmost branch of the root entirely (root\n\t * slots 1-15).\n\t */\n\tptr = READ_ONCE(keyring->keys.root);\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\t/* If the root is a shortcut, either the keyring only contains\n\t\t * keyring pointers (everything clusters behind root slot 0) or\n\t\t * doesn't contain any keyring pointers.\n\t\t */\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tif ((shortcut->index_key[0] & ASSOC_ARRAY_FAN_MASK) != 0)\n\t\t\tgoto not_this_keyring;\n\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tnode = assoc_array_ptr_to_node(ptr);\n\t\tgoto begin_node;\n\t}\n\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\n\tptr = node->slots[0];\n\tif (!assoc_array_ptr_is_meta(ptr))\n\t\tgoto begin_node;\n\ndescend_to_node:\n\t/* Descend to a more distal node in this keyring's content tree and go\n\t * through that.\n\t */\n\tkdebug(\"descend\");\n\tif (assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->next_node);\n\t\tBUG_ON(!assoc_array_ptr_is_node(ptr));\n\t}\n\tnode = assoc_array_ptr_to_node(ptr);\n\nbegin_node:\n\tkdebug(\"begin_node\");\n\tsmp_read_barrier_depends();\n\tslot = 0;\nascend_to_node:\n\t/* Go through the slots in a node */\n\tfor (; slot < ASSOC_ARRAY_FAN_OUT; slot++) {\n\t\tptr = READ_ONCE(node->slots[slot]);\n\n\t\tif (assoc_array_ptr_is_meta(ptr) && node->back_pointer)\n\t\t\tgoto descend_to_node;\n\n\t\tif (!keyring_ptr_is_keyring(ptr))\n\t\t\tcontinue;\n\n\t\tkey = keyring_ptr_to_key(ptr);\n\n\t\tif (sp >= KEYRING_SEARCH_MAX_DEPTH) {\n\t\t\tif (ctx->flags & KEYRING_SEARCH_DETECT_TOO_DEEP) {\n\t\t\t\tctx->result = ERR_PTR(-ELOOP);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tgoto not_this_keyring;\n\t\t}\n\n\t\t/* Search a nested keyring */\n\t\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0)\n\t\t\tcontinue;\n\n\t\t/* stack the current position */\n\t\tstack[sp].keyring = keyring;\n\t\tstack[sp].node = node;\n\t\tstack[sp].slot = slot;\n\t\tsp++;\n\n\t\t/* begin again with the new keyring */\n\t\tkeyring = key;\n\t\tgoto descend_to_keyring;\n\t}\n\n\t/* We've dealt with all the slots in the current node, so now we need\n\t * to ascend to the parent and continue processing there.\n\t */\n\tptr = READ_ONCE(node->back_pointer);\n\tslot = node->parent_slot;\n\n\tif (ptr && assoc_array_ptr_is_shortcut(ptr)) {\n\t\tshortcut = assoc_array_ptr_to_shortcut(ptr);\n\t\tsmp_read_barrier_depends();\n\t\tptr = READ_ONCE(shortcut->back_pointer);\n\t\tslot = shortcut->parent_slot;\n\t}\n\tif (!ptr)\n\t\tgoto not_this_keyring;\n\tnode = assoc_array_ptr_to_node(ptr);\n\tsmp_read_barrier_depends();\n\tslot++;\n\n\t/* If we've ascended to the root (zero backpointer), we must have just\n\t * finished processing the leftmost branch rather than the root slots -\n\t * so there can't be any more keyrings for us to find.\n\t */\n\tif (node->back_pointer) {\n\t\tkdebug(\"ascend %d\", slot);\n\t\tgoto ascend_to_node;\n\t}\n\n\t/* The keyring we're looking at was disqualified or didn't contain a\n\t * matching key.\n\t */\nnot_this_keyring:\n\tkdebug(\"not_this_keyring %d\", sp);\n\tif (sp <= 0) {\n\t\tkleave(\" = false\");\n\t\treturn false;\n\t}\n\n\t/* Resume the processing of a keyring higher up in the tree */\n\tsp--;\n\tkeyring = stack[sp].keyring;\n\tnode = stack[sp].node;\n\tslot = stack[sp].slot + 1;\n\tkdebug(\"ascend to %d [%d]\", keyring->serial, slot);\n\tgoto ascend_to_node;\n\n\t/* We found a viable match */\nfound:\n\tkey = key_ref_to_ptr(ctx->result);\n\tkey_check(key);\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_UPDATE_TIME)) {\n\t\tkey->last_used_at = ctx->now;\n\t\tkeyring->last_used_at = ctx->now;\n\t\twhile (sp > 0)\n\t\t\tstack[--sp].keyring->last_used_at = ctx->now;\n\t}\n\tkleave(\" = true\");\n\treturn true;\n}"
  },
  {
    "function_name": "search_keyring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "623-634",
    "snippet": "static int search_keyring(struct key *keyring, struct keyring_search_context *ctx)\n{\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_DIRECT) {\n\t\tconst void *object;\n\n\t\tobject = assoc_array_find(&keyring->keys,\n\t\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t\t  &ctx->index_key);\n\t\treturn object ? ctx->iterator(object, ctx) : 0;\n\t}\n\treturn assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assoc_array_iterate",
          "args": [
            "&keyring->keys",
            "ctx->iterator",
            "ctx"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctx->iterator",
          "args": [
            "object",
            "ctx"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_find",
          "args": [
            "&keyring->keys",
            "&keyring_assoc_array_ops",
            "&ctx->index_key"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nstatic int search_keyring(struct key *keyring, struct keyring_search_context *ctx)\n{\n\tif (ctx->match_data.lookup_type == KEYRING_SEARCH_LOOKUP_DIRECT) {\n\t\tconst void *object;\n\n\t\tobject = assoc_array_find(&keyring->keys,\n\t\t\t\t\t  &keyring_assoc_array_ops,\n\t\t\t\t\t  &ctx->index_key);\n\t\treturn object ? ctx->iterator(object, ctx) : 0;\n\t}\n\treturn assoc_array_iterate(&keyring->keys, ctx->iterator, ctx);\n}"
  },
  {
    "function_name": "keyring_search_iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "551-616",
    "snippet": "static int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = READ_ONCE(key->flags);\n\tshort state = READ_ONCE(key->state);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* ignore keys not of this type */\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\n\t/* skip invalidated, revoked and expired keys */\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\ttime64_t expiry = READ_ONCE(key->expiry);\n\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (expiry && ctx->now >= expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* keys that don't match */\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\n\t/* key must have search permissions */\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\t/* we set a different error code if we pass a negative key */\n\t\tif (state < 0) {\n\t\t\tctx->result = ERR_PTR(state);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* Found */\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = 1 [found]\""
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "key",
            "ctx->possessed"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = %d [neg]\"",
            "ctx->skipped_ret"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "state"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = %d [!perm]\"",
            "ctx->skipped_ret"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EACCES"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_task_permission",
          "args": [
            "make_key_ref(key, ctx->possessed)",
            "ctx->cred",
            "KEY_NEED_SEARCH"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "key_task_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/permission.c",
          "lines": "30-78",
          "snippet": "int key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tunsigned perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm;\n\tint ret;\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* use the second 8-bits of permissions for keys the caller owns */\n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t/* use the third 8-bits of permissions for keys the caller has a group\n\t * membership in common with */\n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t/* otherwise use the least-significant 8-bits */\n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t/* use the top 8-bits of permissions for keys the caller possesses\n\t * - possessor permissions are additive with other permissions\n\t */\n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tkperm = kperm & perm & KEY_NEED_ALL;\n\n\tif (kperm != perm)\n\t\treturn -EACCES;\n\n\t/* let LSM be the final arbiter */\n\treturn security_key_permission(key_ref, cred, perm);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/security.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/security.h>\n#include <linux/module.h>\n\nint key_task_permission(const key_ref_t key_ref, const struct cred *cred,\n\t\t\tunsigned perm)\n{\n\tstruct key *key;\n\tkey_perm_t kperm;\n\tint ret;\n\n\tkey = key_ref_to_ptr(key_ref);\n\n\t/* use the second 8-bits of permissions for keys the caller owns */\n\tif (uid_eq(key->uid, cred->fsuid)) {\n\t\tkperm = key->perm >> 16;\n\t\tgoto use_these_perms;\n\t}\n\n\t/* use the third 8-bits of permissions for keys the caller has a group\n\t * membership in common with */\n\tif (gid_valid(key->gid) && key->perm & KEY_GRP_ALL) {\n\t\tif (gid_eq(key->gid, cred->fsgid)) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\n\t\tret = groups_search(cred->group_info, key->gid);\n\t\tif (ret) {\n\t\t\tkperm = key->perm >> 8;\n\t\t\tgoto use_these_perms;\n\t\t}\n\t}\n\n\t/* otherwise use the least-significant 8-bits */\n\tkperm = key->perm;\n\nuse_these_perms:\n\n\t/* use the top 8-bits of permissions for keys the caller possesses\n\t * - possessor permissions are additive with other permissions\n\t */\n\tif (is_key_possessed(key_ref))\n\t\tkperm |= key->perm >> 24;\n\n\tkperm = kperm & perm & KEY_NEED_ALL;\n\n\tif (kperm != perm)\n\t\treturn -EACCES;\n\n\t/* let LSM be the final arbiter */\n\treturn security_key_permission(key_ref, cred, perm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "key",
            "ctx->possessed"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = 0 [!match]\""
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ctx->match_data.cmp",
          "args": [
            "key",
            "&ctx->match_data"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = %d [expire]\"",
            "ctx->skipped_ret"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EKEYEXPIRED"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = %d [invrev]\"",
            "ctx->skipped_ret"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EKEYREVOKED"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "key->expiry"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = 0 [!type]\""
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"{%d}\"",
            "key->serial"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "key->state"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "key->flags"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_ptr_to_key",
          "args": [
            "object"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_ptr_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "46-50",
          "snippet": "static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int keyring_search_iterator(const void *object, void *iterator_data)\n{\n\tstruct keyring_search_context *ctx = iterator_data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tunsigned long kflags = READ_ONCE(key->flags);\n\tshort state = READ_ONCE(key->state);\n\n\tkenter(\"{%d}\", key->serial);\n\n\t/* ignore keys not of this type */\n\tif (key->type != ctx->index_key.type) {\n\t\tkleave(\" = 0 [!type]\");\n\t\treturn 0;\n\t}\n\n\t/* skip invalidated, revoked and expired keys */\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\ttime64_t expiry = READ_ONCE(key->expiry);\n\n\t\tif (kflags & ((1 << KEY_FLAG_INVALIDATED) |\n\t\t\t      (1 << KEY_FLAG_REVOKED))) {\n\t\t\tctx->result = ERR_PTR(-EKEYREVOKED);\n\t\t\tkleave(\" = %d [invrev]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\n\t\tif (expiry && ctx->now >= expiry) {\n\t\t\tif (!(ctx->flags & KEYRING_SEARCH_SKIP_EXPIRED))\n\t\t\t\tctx->result = ERR_PTR(-EKEYEXPIRED);\n\t\t\tkleave(\" = %d [expire]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* keys that don't match */\n\tif (!ctx->match_data.cmp(key, &ctx->match_data)) {\n\t\tkleave(\" = 0 [!match]\");\n\t\treturn 0;\n\t}\n\n\t/* key must have search permissions */\n\tif (!(ctx->flags & KEYRING_SEARCH_NO_CHECK_PERM) &&\n\t    key_task_permission(make_key_ref(key, ctx->possessed),\n\t\t\t\tctx->cred, KEY_NEED_SEARCH) < 0) {\n\t\tctx->result = ERR_PTR(-EACCES);\n\t\tkleave(\" = %d [!perm]\", ctx->skipped_ret);\n\t\tgoto skipped;\n\t}\n\n\tif (ctx->flags & KEYRING_SEARCH_DO_STATE_CHECK) {\n\t\t/* we set a different error code if we pass a negative key */\n\t\tif (state < 0) {\n\t\t\tctx->result = ERR_PTR(state);\n\t\t\tkleave(\" = %d [neg]\", ctx->skipped_ret);\n\t\t\tgoto skipped;\n\t\t}\n\t}\n\n\t/* Found */\n\tctx->result = make_key_ref(key, ctx->possessed);\n\tkleave(\" = 1 [found]\");\n\treturn 1;\n\nskipped:\n\treturn ctx->skipped_ret;\n}"
  },
  {
    "function_name": "key_default_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "542-546",
    "snippet": "bool key_default_cmp(const struct key *key,\n\t\t     const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key->description",
            "match_data->raw_data"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nbool key_default_cmp(const struct key *key,\n\t\t     const struct key_match_data *match_data)\n{\n\treturn strcmp(key->description, match_data->raw_data) == 0;\n}"
  },
  {
    "function_name": "restrict_link_reject",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "531-537",
    "snippet": "int restrict_link_reject(struct key *keyring,\n\t\t\t const struct key_type *type,\n\t\t\t const union key_payload *payload,\n\t\t\t struct key *restriction_key)\n{\n\treturn -EPERM;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nint restrict_link_reject(struct key *keyring,\n\t\t\t const struct key_type *type,\n\t\t\t const union key_payload *payload,\n\t\t\t struct key *restriction_key)\n{\n\treturn -EPERM;\n}"
  },
  {
    "function_name": "keyring_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "494-514",
    "snippet": "struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "keyring"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_instantiate_and_link",
          "args": [
            "keyring",
            "NULL",
            "0",
            "dest",
            "NULL"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "key_instantiate_and_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "495-541",
          "snippet": "int key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tif (keyring->restrict_link && keyring->restrict_link->check) {\n\t\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\t\tret = keyres->check(keyring, key->type, &prep.payload,\n\t\t\t\t\t    keyres->key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\nerror_link_end:\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nint key_instantiate_and_link(struct key *key,\n\t\t\t     const void *data,\n\t\t\t     size_t datalen,\n\t\t\t     struct key *keyring,\n\t\t\t     struct key *authkey)\n{\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tint ret;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = data;\n\tprep.datalen = datalen;\n\tprep.quotalen = key->type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (key->type->preparse) {\n\t\tret = key->type->preparse(&prep);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\t}\n\n\tif (keyring) {\n\t\tret = __key_link_begin(keyring, &key->index_key, &edit);\n\t\tif (ret < 0)\n\t\t\tgoto error;\n\n\t\tif (keyring->restrict_link && keyring->restrict_link->check) {\n\t\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\t\tret = keyres->check(keyring, key->type, &prep.payload,\n\t\t\t\t\t    keyres->key);\n\t\t\tif (ret < 0)\n\t\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\tret = __key_instantiate_and_link(key, &prep, keyring, authkey, &edit);\n\nerror_link_end:\n\tif (keyring)\n\t\t__key_link_end(keyring, &key->index_key, edit);\n\nerror:\n\tif (key->type->preparse)\n\t\tkey->type->free_preparse(&prep);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "keyring"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_alloc",
          "args": [
            "&key_type_keyring",
            "description",
            "uid",
            "gid",
            "cred",
            "perm",
            "flags",
            "restrict_link"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "key_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "228-356",
          "snippet": "struct key *key_alloc(struct key_type *type, const char *desc,\n\t\t      kuid_t uid, kgid_t gid, const struct cred *cred,\n\t\t      key_perm_t perm, unsigned long flags,\n\t\t      struct key_restriction *restrict_link)\n{\n\tstruct key_user *user = NULL;\n\tstruct key *key;\n\tsize_t desclen, quotalen;\n\tint ret;\n\n\tkey = ERR_PTR(-EINVAL);\n\tif (!desc || !*desc)\n\t\tgoto error;\n\n\tif (type->vet_description) {\n\t\tret = type->vet_description(desc);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdesclen = strlen(desc);\n\tquotalen = desclen + 1 + type->def_datalen;\n\n\t/* get hold of the key tracking for this user */\n\tuser = key_user_lookup(uid);\n\tif (!user)\n\t\tgoto no_memory_1;\n\n\t/* check that the user's quota permits allocation of another key and\n\t * its description */\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&user->lock);\n\t\tif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\n\t\t\tif (user->qnkeys + 1 >= maxkeys ||\n\t\t\t    user->qnbytes + quotalen >= maxbytes ||\n\t\t\t    user->qnbytes + quotalen < user->qnbytes)\n\t\t\t\tgoto no_quota;\n\t\t}\n\n\t\tuser->qnkeys++;\n\t\tuser->qnbytes += quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\n\t/* allocate and initialise the key and its description */\n\tkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\n\tif (!key)\n\t\tgoto no_memory_2;\n\n\tkey->index_key.desc_len = desclen;\n\tkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\n\tif (!key->index_key.description)\n\t\tgoto no_memory_3;\n\n\trefcount_set(&key->usage, 1);\n\tinit_rwsem(&key->sem);\n\tlockdep_set_class(&key->sem, &type->lock_class);\n\tkey->index_key.type = type;\n\tkey->user = user;\n\tkey->quotalen = quotalen;\n\tkey->datalen = type->def_datalen;\n\tkey->uid = uid;\n\tkey->gid = gid;\n\tkey->perm = perm;\n\tkey->restrict_link = restrict_link;\n\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\n\t\tkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\n\tif (flags & KEY_ALLOC_BUILT_IN)\n\t\tkey->flags |= 1 << KEY_FLAG_BUILTIN;\n\tif (flags & KEY_ALLOC_UID_KEYRING)\n\t\tkey->flags |= 1 << KEY_FLAG_UID_KEYRING;\n\n#ifdef KEY_DEBUGGING\n\tkey->magic = KEY_DEBUG_MAGIC;\n#endif\n\n\t/* let the security module know about the key */\n\tret = security_key_alloc(key, cred, flags);\n\tif (ret < 0)\n\t\tgoto security_error;\n\n\t/* publish the key by giving it a serial number */\n\tatomic_inc(&user->nkeys);\n\tkey_alloc_serial(key);\n\nerror:\n\treturn key;\n\nsecurity_error:\n\tkfree(key->description);\n\tkmem_cache_free(key_jar, key);\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\n\tkey = ERR_PTR(ret);\n\tgoto error;\n\nno_memory_3:\n\tkmem_cache_free(key_jar, key);\nno_memory_2:\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\nno_memory_1:\n\tkey = ERR_PTR(-ENOMEM);\n\tgoto error;\n\nno_quota:\n\tspin_unlock(&user->lock);\n\tkey_user_put(user);\n\tkey = ERR_PTR(-EDQUOT);\n\tgoto error;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *key_jar;",
            "unsigned int key_quota_root_maxkeys = 1000000;",
            "unsigned int key_quota_root_maxbytes = 25000000;",
            "unsigned int key_quota_maxkeys = 200;",
            "unsigned int key_quota_maxbytes = 20000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct kmem_cache *key_jar;\nunsigned int key_quota_root_maxkeys = 1000000;\nunsigned int key_quota_root_maxbytes = 25000000;\nunsigned int key_quota_maxkeys = 200;\nunsigned int key_quota_maxbytes = 20000;\n\nstruct key *key_alloc(struct key_type *type, const char *desc,\n\t\t      kuid_t uid, kgid_t gid, const struct cred *cred,\n\t\t      key_perm_t perm, unsigned long flags,\n\t\t      struct key_restriction *restrict_link)\n{\n\tstruct key_user *user = NULL;\n\tstruct key *key;\n\tsize_t desclen, quotalen;\n\tint ret;\n\n\tkey = ERR_PTR(-EINVAL);\n\tif (!desc || !*desc)\n\t\tgoto error;\n\n\tif (type->vet_description) {\n\t\tret = type->vet_description(desc);\n\t\tif (ret < 0) {\n\t\t\tkey = ERR_PTR(ret);\n\t\t\tgoto error;\n\t\t}\n\t}\n\n\tdesclen = strlen(desc);\n\tquotalen = desclen + 1 + type->def_datalen;\n\n\t/* get hold of the key tracking for this user */\n\tuser = key_user_lookup(uid);\n\tif (!user)\n\t\tgoto no_memory_1;\n\n\t/* check that the user's quota permits allocation of another key and\n\t * its description */\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tunsigned maxkeys = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxkeys : key_quota_maxkeys;\n\t\tunsigned maxbytes = uid_eq(uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&user->lock);\n\t\tif (!(flags & KEY_ALLOC_QUOTA_OVERRUN)) {\n\t\t\tif (user->qnkeys + 1 >= maxkeys ||\n\t\t\t    user->qnbytes + quotalen >= maxbytes ||\n\t\t\t    user->qnbytes + quotalen < user->qnbytes)\n\t\t\t\tgoto no_quota;\n\t\t}\n\n\t\tuser->qnkeys++;\n\t\tuser->qnbytes += quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\n\t/* allocate and initialise the key and its description */\n\tkey = kmem_cache_zalloc(key_jar, GFP_KERNEL);\n\tif (!key)\n\t\tgoto no_memory_2;\n\n\tkey->index_key.desc_len = desclen;\n\tkey->index_key.description = kmemdup(desc, desclen + 1, GFP_KERNEL);\n\tif (!key->index_key.description)\n\t\tgoto no_memory_3;\n\n\trefcount_set(&key->usage, 1);\n\tinit_rwsem(&key->sem);\n\tlockdep_set_class(&key->sem, &type->lock_class);\n\tkey->index_key.type = type;\n\tkey->user = user;\n\tkey->quotalen = quotalen;\n\tkey->datalen = type->def_datalen;\n\tkey->uid = uid;\n\tkey->gid = gid;\n\tkey->perm = perm;\n\tkey->restrict_link = restrict_link;\n\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA))\n\t\tkey->flags |= 1 << KEY_FLAG_IN_QUOTA;\n\tif (flags & KEY_ALLOC_BUILT_IN)\n\t\tkey->flags |= 1 << KEY_FLAG_BUILTIN;\n\tif (flags & KEY_ALLOC_UID_KEYRING)\n\t\tkey->flags |= 1 << KEY_FLAG_UID_KEYRING;\n\n#ifdef KEY_DEBUGGING\n\tkey->magic = KEY_DEBUG_MAGIC;\n#endif\n\n\t/* let the security module know about the key */\n\tret = security_key_alloc(key, cred, flags);\n\tif (ret < 0)\n\t\tgoto security_error;\n\n\t/* publish the key by giving it a serial number */\n\tatomic_inc(&user->nkeys);\n\tkey_alloc_serial(key);\n\nerror:\n\treturn key;\n\nsecurity_error:\n\tkfree(key->description);\n\tkmem_cache_free(key_jar, key);\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\n\tkey = ERR_PTR(ret);\n\tgoto error;\n\nno_memory_3:\n\tkmem_cache_free(key_jar, key);\nno_memory_2:\n\tif (!(flags & KEY_ALLOC_NOT_IN_QUOTA)) {\n\t\tspin_lock(&user->lock);\n\t\tuser->qnkeys--;\n\t\tuser->qnbytes -= quotalen;\n\t\tspin_unlock(&user->lock);\n\t}\n\tkey_user_put(user);\nno_memory_1:\n\tkey = ERR_PTR(-ENOMEM);\n\tgoto error;\n\nno_quota:\n\tspin_unlock(&user->lock);\n\tkey_user_put(user);\n\tkey = ERR_PTR(-EDQUOT);\n\tgoto error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}"
  },
  {
    "function_name": "keyring_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "458-489",
    "snippet": "static long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen)\n{\n\tstruct keyring_read_iterator_context ctx;\n\tlong ret;\n\n\tkenter(\"{%d},,%zu\", key_serial(keyring), buflen);\n\n\tif (buflen & (sizeof(key_serial_t) - 1))\n\t\treturn -EINVAL;\n\n\t/* Copy as many key IDs as fit into the buffer */\n\tif (buffer && buflen) {\n\t\tctx.buffer = (key_serial_t __user *)buffer;\n\t\tctx.buflen = buflen;\n\t\tctx.count = 0;\n\t\tret = assoc_array_iterate(&keyring->keys,\n\t\t\t\t\t  keyring_read_iterator, &ctx);\n\t\tif (ret < 0) {\n\t\t\tkleave(\" = %ld [iterate]\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Return the size of the buffer needed */\n\tret = keyring->keys.nr_leaves_on_tree * sizeof(key_serial_t);\n\tif (ret <= buflen)\n\t\tkleave(\"= %ld [ok]\", ret);\n\telse\n\t\tkleave(\"= %ld [buffer too small]\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "static long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\"= %ld [buffer too small]\"",
            "ret"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\"= %ld [ok]\"",
            "ret"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kleave",
          "args": [
            "\" = %ld [iterate]\"",
            "ret"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assoc_array_iterate",
          "args": [
            "&keyring->keys",
            "keyring_read_iterator",
            "&ctx"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"{%d},,%zu\"",
            "key_serial(keyring)",
            "buflen"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "keyring"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen);\n\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen)\n{\n\tstruct keyring_read_iterator_context ctx;\n\tlong ret;\n\n\tkenter(\"{%d},,%zu\", key_serial(keyring), buflen);\n\n\tif (buflen & (sizeof(key_serial_t) - 1))\n\t\treturn -EINVAL;\n\n\t/* Copy as many key IDs as fit into the buffer */\n\tif (buffer && buflen) {\n\t\tctx.buffer = (key_serial_t __user *)buffer;\n\t\tctx.buflen = buflen;\n\t\tctx.count = 0;\n\t\tret = assoc_array_iterate(&keyring->keys,\n\t\t\t\t\t  keyring_read_iterator, &ctx);\n\t\tif (ret < 0) {\n\t\t\tkleave(\" = %ld [iterate]\", ret);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/* Return the size of the buffer needed */\n\tret = keyring->keys.nr_leaves_on_tree * sizeof(key_serial_t);\n\tif (ret <= buflen)\n\t\tkleave(\"= %ld [ok]\", ret);\n\telse\n\t\tkleave(\"= %ld [buffer too small]\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "keyring_read_iterator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "431-449",
    "snippet": "static int keyring_read_iterator(const void *object, void *data)\n{\n\tstruct keyring_read_iterator_context *ctx = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tint ret;\n\n\tkenter(\"{%s,%d},,{%zu/%zu}\",\n\t       key->type->name, key->serial, ctx->count, ctx->buflen);\n\n\tif (ctx->count >= ctx->buflen)\n\t\treturn 1;\n\n\tret = put_user(key->serial, ctx->buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\tctx->buffer++;\n\tctx->count += sizeof(key->serial);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "key->serial",
            "ctx->buffer"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kenter",
          "args": [
            "\"{%s,%d},,{%zu/%zu}\"",
            "key->type->name",
            "key->serial",
            "ctx->count",
            "ctx->buflen"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_ptr_to_key",
          "args": [
            "object"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_ptr_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "46-50",
          "snippet": "static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic long keyring_read(const struct key *keyring,\n\t\t\t char __user *buffer, size_t buflen);\n\nstatic int keyring_read_iterator(const void *object, void *data)\n{\n\tstruct keyring_read_iterator_context *ctx = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\tint ret;\n\n\tkenter(\"{%s,%d},,{%zu/%zu}\",\n\t       key->type->name, key->serial, ctx->count, ctx->buflen);\n\n\tif (ctx->count >= ctx->buflen)\n\t\treturn 1;\n\n\tret = put_user(key->serial, ctx->buffer);\n\tif (ret < 0)\n\t\treturn ret;\n\tctx->buffer++;\n\tctx->count += sizeof(key->serial);\n\treturn 0;\n}"
  },
  {
    "function_name": "keyring_describe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "410-423",
    "snippet": "static void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\n\tif (key_is_positive(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "static void keyring_describe(const struct key *keyring, struct seq_file *m);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\": empty\""
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\": %lu\"",
            "keyring->keys.nr_leaves_on_tree"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_is_positive",
          "args": [
            "keyring"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"[anon]\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "keyring->description"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m);\n\nstatic void keyring_describe(const struct key *keyring, struct seq_file *m)\n{\n\tif (keyring->description)\n\t\tseq_puts(m, keyring->description);\n\telse\n\t\tseq_puts(m, \"[anon]\");\n\n\tif (key_is_positive(keyring)) {\n\t\tif (keyring->keys.nr_leaves_on_tree != 0)\n\t\t\tseq_printf(m, \": %lu\", keyring->keys.nr_leaves_on_tree);\n\t\telse\n\t\t\tseq_puts(m, \": empty\");\n\t}\n}"
  },
  {
    "function_name": "keyring_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "385-405",
    "snippet": "static void keyring_destroy(struct key *keyring)\n{\n\tif (keyring->description) {\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (keyring->name_link.next != NULL &&\n\t\t    !list_empty(&keyring->name_link))\n\t\t\tlist_del(&keyring->name_link);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n\n\tif (keyring->restrict_link) {\n\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\tkey_put(keyres->key);\n\t\tkfree(keyres);\n\t}\n\n\tassoc_array_destroy(&keyring->keys, &keyring_assoc_array_ops);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_RWLOCK(keyring_name_lock);",
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);",
      "static const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "assoc_array_destroy",
          "args": [
            "&keyring->keys",
            "&keyring_assoc_array_ops"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "keyres"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "keyres->key"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&keyring_name_lock"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&keyring->name_link"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&keyring->name_link"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&keyring_name_lock"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DEFINE_RWLOCK(keyring_name_lock);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstatic const struct assoc_array_ops keyring_assoc_array_ops = {\n\t.get_key_chunk\t\t= keyring_get_key_chunk,\n\t.get_object_key_chunk\t= keyring_get_object_key_chunk,\n\t.compare_object\t\t= keyring_compare_object,\n\t.diff_objects\t\t= keyring_diff_objects,\n\t.free_object\t\t= keyring_free_object,\n};\n\nstatic void keyring_destroy(struct key *keyring)\n{\n\tif (keyring->description) {\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (keyring->name_link.next != NULL &&\n\t\t    !list_empty(&keyring->name_link))\n\t\t\tlist_del(&keyring->name_link);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n\n\tif (keyring->restrict_link) {\n\t\tstruct key_restriction *keyres = keyring->restrict_link;\n\n\t\tkey_put(keyres->key);\n\t\tkfree(keyres);\n\t}\n\n\tassoc_array_destroy(&keyring->keys, &keyring_assoc_array_ops);\n}"
  },
  {
    "function_name": "keyring_free_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "360-363",
    "snippet": "static void keyring_free_object(void *object)\n{\n\tkey_put(keyring_ptr_to_key(object));\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "keyring_ptr_to_key(object)"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyring_ptr_to_key",
          "args": [
            "object"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_ptr_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "46-50",
          "snippet": "static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_free_object(void *object)\n{\n\tkey_put(keyring_ptr_to_key(object));\n}"
  },
  {
    "function_name": "keyring_diff_objects",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "293-355",
    "snippet": "static int keyring_diff_objects(const void *object, const void *data)\n{\n\tconst struct key *key_a = keyring_ptr_to_key(object);\n\tconst struct keyring_index_key *a = &key_a->index_key;\n\tconst struct keyring_index_key *b = data;\n\tunsigned long seg_a, seg_b;\n\tint level, i;\n\n\tlevel = 0;\n\tseg_a = hash_key_type_and_desc(a);\n\tseg_b = hash_key_type_and_desc(b);\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The number of bits contributed by the hash is controlled by a\n\t * constant in the assoc_array headers.  Everything else thereafter we\n\t * can deal with as being machine word-size dependent.\n\t */\n\tlevel += ASSOC_ARRAY_KEY_CHUNK_SIZE / 8;\n\tseg_a = a->desc_len;\n\tseg_b = b->desc_len;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The next bit may not work on big endian */\n\tlevel++;\n\tseg_a = (unsigned long)a->type;\n\tseg_b = (unsigned long)b->type;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\tlevel += sizeof(unsigned long);\n\tif (a->desc_len == 0)\n\t\tgoto same;\n\n\ti = 0;\n\tif (((unsigned long)a->description | (unsigned long)b->description) &\n\t    (sizeof(unsigned long) - 1)) {\n\t\tdo {\n\t\t\tseg_a = *(unsigned long *)(a->description + i);\n\t\t\tseg_b = *(unsigned long *)(b->description + i);\n\t\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\t\tgoto differ_plus_i;\n\t\t\ti += sizeof(unsigned long);\n\t\t} while (i < (a->desc_len & (sizeof(unsigned long) - 1)));\n\t}\n\n\tfor (; i < a->desc_len; i++) {\n\t\tseg_a = *(unsigned char *)(a->description + i);\n\t\tseg_b = *(unsigned char *)(b->description + i);\n\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\tgoto differ_plus_i;\n\t}\n\nsame:\n\treturn -1;\n\ndiffer_plus_i:\n\tlevel += i;\ndiffer:\n\ti = level * 8 + __ffs(seg_a ^ seg_b);\n\treturn i;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ffs",
          "args": [
            "seg_a ^ seg_b"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_key_type_and_desc",
          "args": [
            "b"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "hash_key_type_and_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "171-213",
          "snippet": "static unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t/* Fold the hash down to 32 bits if need be. */\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t/* Squidge all the keyrings into a separate part of the tree to\n\t * ordinary keys by making sure the lowest level segment in the hash is\n\t * zero for keyrings and non-zero otherwise.\n\t */\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nstatic unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t/* Fold the hash down to 32 bits if need be. */\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t/* Squidge all the keyrings into a separate part of the tree to\n\t * ordinary keys by making sure the lowest level segment in the hash is\n\t * zero for keyrings and non-zero otherwise.\n\t */\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyring_ptr_to_key",
          "args": [
            "object"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_ptr_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "46-50",
          "snippet": "static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int keyring_diff_objects(const void *object, const void *data)\n{\n\tconst struct key *key_a = keyring_ptr_to_key(object);\n\tconst struct keyring_index_key *a = &key_a->index_key;\n\tconst struct keyring_index_key *b = data;\n\tunsigned long seg_a, seg_b;\n\tint level, i;\n\n\tlevel = 0;\n\tseg_a = hash_key_type_and_desc(a);\n\tseg_b = hash_key_type_and_desc(b);\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The number of bits contributed by the hash is controlled by a\n\t * constant in the assoc_array headers.  Everything else thereafter we\n\t * can deal with as being machine word-size dependent.\n\t */\n\tlevel += ASSOC_ARRAY_KEY_CHUNK_SIZE / 8;\n\tseg_a = a->desc_len;\n\tseg_b = b->desc_len;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\t/* The next bit may not work on big endian */\n\tlevel++;\n\tseg_a = (unsigned long)a->type;\n\tseg_b = (unsigned long)b->type;\n\tif ((seg_a ^ seg_b) != 0)\n\t\tgoto differ;\n\n\tlevel += sizeof(unsigned long);\n\tif (a->desc_len == 0)\n\t\tgoto same;\n\n\ti = 0;\n\tif (((unsigned long)a->description | (unsigned long)b->description) &\n\t    (sizeof(unsigned long) - 1)) {\n\t\tdo {\n\t\t\tseg_a = *(unsigned long *)(a->description + i);\n\t\t\tseg_b = *(unsigned long *)(b->description + i);\n\t\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\t\tgoto differ_plus_i;\n\t\t\ti += sizeof(unsigned long);\n\t\t} while (i < (a->desc_len & (sizeof(unsigned long) - 1)));\n\t}\n\n\tfor (; i < a->desc_len; i++) {\n\t\tseg_a = *(unsigned char *)(a->description + i);\n\t\tseg_b = *(unsigned char *)(b->description + i);\n\t\tif ((seg_a ^ seg_b) != 0)\n\t\t\tgoto differ_plus_i;\n\t}\n\nsame:\n\treturn -1;\n\ndiffer_plus_i:\n\tlevel += i;\ndiffer:\n\ti = level * 8 + __ffs(seg_a ^ seg_b);\n\treturn i;\n}"
  },
  {
    "function_name": "keyring_compare_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "278-287",
    "snippet": "static bool keyring_compare_object(const void *object, const void *data)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\treturn key->index_key.type == index_key->type &&\n\t\tkey->index_key.desc_len == index_key->desc_len &&\n\t\tmemcmp(key->index_key.description, index_key->description,\n\t\t       index_key->desc_len) == 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "key->index_key.description",
            "index_key->description",
            "index_key->desc_len"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_ptr_to_key",
          "args": [
            "object"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_ptr_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "46-50",
          "snippet": "static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic bool keyring_compare_object(const void *object, const void *data)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tconst struct key *key = keyring_ptr_to_key(object);\n\n\treturn key->index_key.type == index_key->type &&\n\t\tkey->index_key.desc_len == index_key->desc_len &&\n\t\tmemcmp(key->index_key.description, index_key->description,\n\t\t       index_key->desc_len) == 0;\n}"
  },
  {
    "function_name": "keyring_get_object_key_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "272-276",
    "snippet": "static unsigned long keyring_get_object_key_chunk(const void *object, int level)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\treturn keyring_get_key_chunk(&key->index_key, level);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyring_get_key_chunk",
          "args": [
            "&key->index_key",
            "level"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_get_key_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "230-270",
          "snippet": "static unsigned long keyring_get_key_chunk(const void *data, int level)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tunsigned long chunk = 0;\n\tlong offset = 0;\n\tint desc_len = index_key->desc_len, n = sizeof(chunk);\n\n\tlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\tswitch (level) {\n\tcase 0:\n\t\treturn hash_key_type_and_desc(index_key);\n\tcase 1:\n\t\treturn ((unsigned long)index_key->type << 8) | desc_len;\n\tcase 2:\n\t\tif (desc_len == 0)\n\t\t\treturn (u8)((unsigned long)index_key->type >>\n\t\t\t\t    (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\tn--;\n\t\toffset = 1;\n\tdefault:\n\t\toffset += sizeof(chunk) - 1;\n\t\toffset += (level - 3) * sizeof(chunk);\n\t\tif (offset >= desc_len)\n\t\t\treturn 0;\n\t\tdesc_len -= offset;\n\t\tif (desc_len > n)\n\t\t\tdesc_len = n;\n\t\toffset += desc_len;\n\t\tdo {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= ((u8*)index_key->description)[--offset];\n\t\t} while (--desc_len > 0);\n\n\t\tif (level == 2) {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= (u8)((unsigned long)index_key->type >>\n\t\t\t\t      (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\t}\n\t\treturn chunk;\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic unsigned long keyring_get_key_chunk(const void *data, int level)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tunsigned long chunk = 0;\n\tlong offset = 0;\n\tint desc_len = index_key->desc_len, n = sizeof(chunk);\n\n\tlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\tswitch (level) {\n\tcase 0:\n\t\treturn hash_key_type_and_desc(index_key);\n\tcase 1:\n\t\treturn ((unsigned long)index_key->type << 8) | desc_len;\n\tcase 2:\n\t\tif (desc_len == 0)\n\t\t\treturn (u8)((unsigned long)index_key->type >>\n\t\t\t\t    (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\tn--;\n\t\toffset = 1;\n\tdefault:\n\t\toffset += sizeof(chunk) - 1;\n\t\toffset += (level - 3) * sizeof(chunk);\n\t\tif (offset >= desc_len)\n\t\t\treturn 0;\n\t\tdesc_len -= offset;\n\t\tif (desc_len > n)\n\t\t\tdesc_len = n;\n\t\toffset += desc_len;\n\t\tdo {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= ((u8*)index_key->description)[--offset];\n\t\t} while (--desc_len > 0);\n\n\t\tif (level == 2) {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= (u8)((unsigned long)index_key->type >>\n\t\t\t\t      (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\t}\n\t\treturn chunk;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "keyring_ptr_to_key",
          "args": [
            "object"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_ptr_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "46-50",
          "snippet": "static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_PTR_SUBTYPE\t0x2UL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic unsigned long keyring_get_object_key_chunk(const void *object, int level)\n{\n\tconst struct key *key = keyring_ptr_to_key(object);\n\treturn keyring_get_key_chunk(&key->index_key, level);\n}"
  },
  {
    "function_name": "keyring_get_key_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "230-270",
    "snippet": "static unsigned long keyring_get_key_chunk(const void *data, int level)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tunsigned long chunk = 0;\n\tlong offset = 0;\n\tint desc_len = index_key->desc_len, n = sizeof(chunk);\n\n\tlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\tswitch (level) {\n\tcase 0:\n\t\treturn hash_key_type_and_desc(index_key);\n\tcase 1:\n\t\treturn ((unsigned long)index_key->type << 8) | desc_len;\n\tcase 2:\n\t\tif (desc_len == 0)\n\t\t\treturn (u8)((unsigned long)index_key->type >>\n\t\t\t\t    (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\tn--;\n\t\toffset = 1;\n\tdefault:\n\t\toffset += sizeof(chunk) - 1;\n\t\toffset += (level - 3) * sizeof(chunk);\n\t\tif (offset >= desc_len)\n\t\t\treturn 0;\n\t\tdesc_len -= offset;\n\t\tif (desc_len > n)\n\t\t\tdesc_len = n;\n\t\toffset += desc_len;\n\t\tdo {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= ((u8*)index_key->description)[--offset];\n\t\t} while (--desc_len > 0);\n\n\t\tif (level == 2) {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= (u8)((unsigned long)index_key->type >>\n\t\t\t\t      (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\t}\n\t\treturn chunk;\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "(unsigned long)index_key->type >>\n\t\t\t\t      (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8)"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "(unsigned long)index_key->type >>\n\t\t\t\t    (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8)"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hash_key_type_and_desc",
          "args": [
            "index_key"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "hash_key_type_and_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "171-213",
          "snippet": "static unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t/* Fold the hash down to 32 bits if need be. */\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t/* Squidge all the keyrings into a separate part of the tree to\n\t * ordinary keys by making sure the lowest level segment in the hash is\n\t * zero for keyrings and non-zero otherwise.\n\t */\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nstatic unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t/* Fold the hash down to 32 bits if need be. */\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t/* Squidge all the keyrings into a separate part of the tree to\n\t * ordinary keys by making sure the lowest level segment in the hash is\n\t * zero for keyrings and non-zero otherwise.\n\t */\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic unsigned long keyring_get_key_chunk(const void *data, int level)\n{\n\tconst struct keyring_index_key *index_key = data;\n\tunsigned long chunk = 0;\n\tlong offset = 0;\n\tint desc_len = index_key->desc_len, n = sizeof(chunk);\n\n\tlevel /= ASSOC_ARRAY_KEY_CHUNK_SIZE;\n\tswitch (level) {\n\tcase 0:\n\t\treturn hash_key_type_and_desc(index_key);\n\tcase 1:\n\t\treturn ((unsigned long)index_key->type << 8) | desc_len;\n\tcase 2:\n\t\tif (desc_len == 0)\n\t\t\treturn (u8)((unsigned long)index_key->type >>\n\t\t\t\t    (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\tn--;\n\t\toffset = 1;\n\tdefault:\n\t\toffset += sizeof(chunk) - 1;\n\t\toffset += (level - 3) * sizeof(chunk);\n\t\tif (offset >= desc_len)\n\t\t\treturn 0;\n\t\tdesc_len -= offset;\n\t\tif (desc_len > n)\n\t\t\tdesc_len = n;\n\t\toffset += desc_len;\n\t\tdo {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= ((u8*)index_key->description)[--offset];\n\t\t} while (--desc_len > 0);\n\n\t\tif (level == 2) {\n\t\t\tchunk <<= 8;\n\t\t\tchunk |= (u8)((unsigned long)index_key->type >>\n\t\t\t\t      (ASSOC_ARRAY_KEY_CHUNK_SIZE - 8));\n\t\t}\n\t\treturn chunk;\n\t}\n}"
  },
  {
    "function_name": "hash_key_type_and_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "171-213",
    "snippet": "static unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t/* Fold the hash down to 32 bits if need be. */\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t/* Squidge all the keyrings into a separate part of the tree to\n\t * ordinary keys by making sure the lowest level segment in the hash is\n\t * zero for keyrings and non-zero otherwise.\n\t */\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mult_64x32_and_fold",
          "args": [
            "acc",
            "9207"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "mult_64x32_and_fold",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "161-166",
          "snippet": "static u64 mult_64x32_and_fold(u64 x, u32 y)\n{\n\tu64 hi = (u64)(u32)(x >> 32) * y;\n\tu64 lo = (u64)(u32)(x) * y;\n\treturn lo + ((u64)(u32)hi << 32) + (u32)(hi >> 32);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic u64 mult_64x32_and_fold(u64 x, u32 y)\n{\n\tu64 hi = (u64)(u32)(x >> 32) * y;\n\tu64 lo = (u64)(u32)(x) * y;\n\treturn lo + ((u64)(u32)hi << 32) + (u32)(hi >> 32);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&piece",
            "description",
            "n"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nstatic unsigned long hash_key_type_and_desc(const struct keyring_index_key *index_key)\n{\n\tconst unsigned level_shift = ASSOC_ARRAY_LEVEL_STEP;\n\tconst unsigned long fan_mask = ASSOC_ARRAY_FAN_MASK;\n\tconst char *description = index_key->description;\n\tunsigned long hash, type;\n\tu32 piece;\n\tu64 acc;\n\tint n, desc_len = index_key->desc_len;\n\n\ttype = (unsigned long)index_key->type;\n\n\tacc = mult_64x32_and_fold(type, desc_len + 13);\n\tacc = mult_64x32_and_fold(acc, 9207);\n\tfor (;;) {\n\t\tn = desc_len;\n\t\tif (n <= 0)\n\t\t\tbreak;\n\t\tif (n > 4)\n\t\t\tn = 4;\n\t\tpiece = 0;\n\t\tmemcpy(&piece, description, n);\n\t\tdescription += n;\n\t\tdesc_len -= n;\n\t\tacc = mult_64x32_and_fold(acc, piece);\n\t\tacc = mult_64x32_and_fold(acc, 9207);\n\t}\n\n\t/* Fold the hash down to 32 bits if need be. */\n\thash = acc;\n\tif (ASSOC_ARRAY_KEY_CHUNK_SIZE == 32)\n\t\thash ^= acc >> 32;\n\n\t/* Squidge all the keyrings into a separate part of the tree to\n\t * ordinary keys by making sure the lowest level segment in the hash is\n\t * zero for keyrings and non-zero otherwise.\n\t */\n\tif (index_key->type != &key_type_keyring && (hash & fan_mask) == 0)\n\t\treturn hash | (hash >> (ASSOC_ARRAY_KEY_CHUNK_SIZE - level_shift)) | 1;\n\tif (index_key->type == &key_type_keyring && (hash & fan_mask) != 0)\n\t\treturn (hash + (hash << level_shift)) & ~fan_mask;\n\treturn hash;\n}"
  },
  {
    "function_name": "mult_64x32_and_fold",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "161-166",
    "snippet": "static u64 mult_64x32_and_fold(u64 x, u32 y)\n{\n\tu64 hi = (u64)(u32)(x >> 32) * y;\n\tu64 lo = (u64)(u32)(x) * y;\n\treturn lo + ((u64)(u32)hi << 32) + (u32)(hi >> 32);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "hi >> 32"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "x"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "u32"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "x >> 32"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "u32"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic u64 mult_64x32_and_fold(u64 x, u32 y)\n{\n\tu64 hi = (u64)(u32)(x >> 32) * y;\n\tu64 lo = (u64)(u32)(x) * y;\n\treturn lo + ((u64)(u32)hi << 32) + (u32)(hi >> 32);\n}"
  },
  {
    "function_name": "keyring_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "148-155",
    "snippet": "static int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tassoc_array_init(&keyring->keys);\n\t/* make the keyring available by name if it has one */\n\tkeyring_publish_name(keyring);\n\treturn 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int keyring_preparse(struct key_preparsed_payload *prep);",
      "static void keyring_free_preparse(struct key_preparsed_payload *prep);",
      "static int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);",
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "keyring_publish_name",
          "args": [
            "keyring"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_publish_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "109-126",
          "snippet": "static void keyring_publish_name(struct key *keyring)\n{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->name_link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];",
            "static DEFINE_RWLOCK(keyring_name_lock);",
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];\nstatic DEFINE_RWLOCK(keyring_name_lock);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nstatic void keyring_publish_name(struct key *keyring)\n{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->name_link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "assoc_array_init",
          "args": [
            "&keyring->keys"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int keyring_preparse(struct key_preparsed_payload *prep);\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep);\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tassoc_array_init(&keyring->keys);\n\t/* make the keyring available by name if it has one */\n\tkeyring_publish_name(keyring);\n\treturn 0;\n}"
  },
  {
    "function_name": "keyring_free_preparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "139-141",
    "snippet": "static void keyring_free_preparse(struct key_preparsed_payload *prep)\n{\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int keyring_preparse(struct key_preparsed_payload *prep);",
      "static void keyring_free_preparse(struct key_preparsed_payload *prep);",
      "static int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int keyring_preparse(struct key_preparsed_payload *prep);\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep);\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);\n\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep)\n{\n}"
  },
  {
    "function_name": "keyring_preparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "131-134",
    "snippet": "static int keyring_preparse(struct key_preparsed_payload *prep)\n{\n\treturn prep->datalen != 0 ? -EINVAL : 0;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int keyring_preparse(struct key_preparsed_payload *prep);",
      "static void keyring_free_preparse(struct key_preparsed_payload *prep);",
      "static int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic int keyring_preparse(struct key_preparsed_payload *prep);\nstatic void keyring_free_preparse(struct key_preparsed_payload *prep);\nstatic int keyring_instantiate(struct key *keyring,\n\t\t\t       struct key_preparsed_payload *prep);\n\nstatic int keyring_preparse(struct key_preparsed_payload *prep)\n{\n\treturn prep->datalen != 0 ? -EINVAL : 0;\n}"
  },
  {
    "function_name": "keyring_publish_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "109-126",
    "snippet": "static void keyring_publish_name(struct key *keyring)\n{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->name_link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];",
      "static DEFINE_RWLOCK(keyring_name_lock);",
      "static void keyring_revoke(struct key *keyring);",
      "static void keyring_destroy(struct key *keyring);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "write_unlock",
          "args": [
            "&keyring_name_lock"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&keyring->name_link",
            "&keyring_name_hash[bucket]"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&keyring_name_hash[bucket]"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write_lock",
          "args": [
            "&keyring_name_lock"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_hash",
          "args": [
            "keyring->description"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "61-69",
          "snippet": "static inline unsigned keyring_hash(const char *desc)\n{\n\tunsigned bucket = 0;\n\n\tfor (; *desc; desc++)\n\t\tbucket += (unsigned char)*desc;\n\n\treturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KEYRING_NAME_HASH_SIZE\t(1 << 5)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_NAME_HASH_SIZE\t(1 << 5)\n\nstatic inline unsigned keyring_hash(const char *desc)\n{\n\tunsigned bucket = 0;\n\n\tfor (; *desc; desc++)\n\t\tbucket += (unsigned char)*desc;\n\n\treturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic struct list_head\tkeyring_name_hash[KEYRING_NAME_HASH_SIZE];\nstatic DEFINE_RWLOCK(keyring_name_lock);\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nstatic void keyring_publish_name(struct key *keyring)\n{\n\tint bucket;\n\n\tif (keyring->description) {\n\t\tbucket = keyring_hash(keyring->description);\n\n\t\twrite_lock(&keyring_name_lock);\n\n\t\tif (!keyring_name_hash[bucket].next)\n\t\t\tINIT_LIST_HEAD(&keyring_name_hash[bucket]);\n\n\t\tlist_add_tail(&keyring->name_link,\n\t\t\t      &keyring_name_hash[bucket]);\n\n\t\twrite_unlock(&keyring_name_lock);\n\t}\n}"
  },
  {
    "function_name": "keyring_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "61-69",
    "snippet": "static inline unsigned keyring_hash(const char *desc)\n{\n\tunsigned bucket = 0;\n\n\tfor (; *desc; desc++)\n\t\tbucket += (unsigned char)*desc;\n\n\treturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KEYRING_NAME_HASH_SIZE\t(1 << 5)"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_NAME_HASH_SIZE\t(1 << 5)\n\nstatic inline unsigned keyring_hash(const char *desc)\n{\n\tunsigned bucket = 0;\n\n\tfor (; *desc; desc++)\n\t\tbucket += (unsigned char)*desc;\n\n\treturn bucket & (KEYRING_NAME_HASH_SIZE - 1);\n}"
  },
  {
    "function_name": "keyring_key_to_ptr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "51-56",
    "snippet": "static inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KEYRING_PTR_SUBTYPE\t0x2UL"
    ],
    "globals_used": [
      "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nstatic inline void *keyring_key_to_ptr(struct key *key)\n{\n\tif (key->type == &key_type_keyring)\n\t\treturn (void *)((unsigned long)key | KEYRING_PTR_SUBTYPE);\n\treturn key;\n}"
  },
  {
    "function_name": "keyring_ptr_to_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "46-50",
    "snippet": "static inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KEYRING_PTR_SUBTYPE\t0x2UL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assoc_array_ptr_to_leaf",
          "args": [
            "x"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline struct key *keyring_ptr_to_key(const struct assoc_array_ptr *x)\n{\n\tvoid *object = assoc_array_ptr_to_leaf(x);\n\treturn (struct key *)((unsigned long)object & ~KEYRING_PTR_SUBTYPE);\n}"
  },
  {
    "function_name": "keyring_ptr_is_keyring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
    "lines": "42-45",
    "snippet": "static inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)\n{\n\treturn (unsigned long)x & KEYRING_PTR_SUBTYPE;\n}",
    "includes": [
      "#include \"internal.h\"",
      "#include <linux/uaccess.h>",
      "#include <linux/assoc_array_priv.h>",
      "#include <keys/user-type.h>",
      "#include <keys/keyring-type.h>",
      "#include <linux/err.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/security.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define KEYRING_PTR_SUBTYPE\t0x2UL"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\n#define KEYRING_PTR_SUBTYPE\t0x2UL\n\nstatic inline bool keyring_ptr_is_keyring(const struct assoc_array_ptr *x)\n{\n\treturn (unsigned long)x & KEYRING_PTR_SUBTYPE;\n}"
  }
]