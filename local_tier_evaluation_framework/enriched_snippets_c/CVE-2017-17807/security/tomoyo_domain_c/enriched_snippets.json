[
  {
    "function_name": "tomoyo_dump_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "867-911",
    "snippet": "bool tomoyo_dump_page(struct linux_binprm *bprm, unsigned long pos,\n\t\t      struct tomoyo_page_dump *dump)\n{\n\tstruct page *page;\n\n\t/* dump->data is released by tomoyo_find_next_domain(). */\n\tif (!dump->data) {\n\t\tdump->data = kzalloc(PAGE_SIZE, GFP_NOFS);\n\t\tif (!dump->data)\n\t\t\treturn false;\n\t}\n\t/* Same with get_arg_page(bprm, pos, 0) in fs/exec.c */\n#ifdef CONFIG_MMU\n\t/*\n\t * This is called at execve() time in order to dig around\n\t * in the argv/environment of the new proceess\n\t * (represented by bprm).  'current' is the process doing\n\t * the execve().\n\t */\n\tif (get_user_pages_remote(current, bprm->mm, pos, 1,\n\t\t\t\tFOLL_FORCE, &page, NULL, NULL) <= 0)\n\t\treturn false;\n#else\n\tpage = bprm->page[pos / PAGE_SIZE];\n#endif\n\tif (page != dump->page) {\n\t\tconst unsigned int offset = pos % PAGE_SIZE;\n\t\t/*\n\t\t * Maybe kmap()/kunmap() should be used here.\n\t\t * But remove_arg_zero() uses kmap_atomic()/kunmap_atomic().\n\t\t * So do I.\n\t\t */\n\t\tchar *kaddr = kmap_atomic(page);\n\n\t\tdump->page = page;\n\t\tmemcpy(dump->data + offset, kaddr + offset,\n\t\t       PAGE_SIZE - offset);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Same with put_arg_page(page) in fs/exec.c */\n#ifdef CONFIG_MMU\n\tput_page(page);\n#endif\n\treturn true;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_page",
          "args": [
            "page"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kunmap_atomic",
          "args": [
            "kaddr"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dump->data + offset",
            "kaddr + offset",
            "PAGE_SIZE - offset"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmap_atomic",
          "args": [
            "page"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_pages_remote",
          "args": [
            "current",
            "bprm->mm",
            "pos",
            "1",
            "FOLL_FORCE",
            "&page",
            "NULL",
            "NULL"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "PAGE_SIZE",
            "GFP_NOFS"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nbool tomoyo_dump_page(struct linux_binprm *bprm, unsigned long pos,\n\t\t      struct tomoyo_page_dump *dump)\n{\n\tstruct page *page;\n\n\t/* dump->data is released by tomoyo_find_next_domain(). */\n\tif (!dump->data) {\n\t\tdump->data = kzalloc(PAGE_SIZE, GFP_NOFS);\n\t\tif (!dump->data)\n\t\t\treturn false;\n\t}\n\t/* Same with get_arg_page(bprm, pos, 0) in fs/exec.c */\n#ifdef CONFIG_MMU\n\t/*\n\t * This is called at execve() time in order to dig around\n\t * in the argv/environment of the new proceess\n\t * (represented by bprm).  'current' is the process doing\n\t * the execve().\n\t */\n\tif (get_user_pages_remote(current, bprm->mm, pos, 1,\n\t\t\t\tFOLL_FORCE, &page, NULL, NULL) <= 0)\n\t\treturn false;\n#else\n\tpage = bprm->page[pos / PAGE_SIZE];\n#endif\n\tif (page != dump->page) {\n\t\tconst unsigned int offset = pos % PAGE_SIZE;\n\t\t/*\n\t\t * Maybe kmap()/kunmap() should be used here.\n\t\t * But remove_arg_zero() uses kmap_atomic()/kunmap_atomic().\n\t\t * So do I.\n\t\t */\n\t\tchar *kaddr = kmap_atomic(page);\n\n\t\tdump->page = page;\n\t\tmemcpy(dump->data + offset, kaddr + offset,\n\t\t       PAGE_SIZE - offset);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Same with put_arg_page(page) in fs/exec.c */\n#ifdef CONFIG_MMU\n\tput_page(page);\n#endif\n\treturn true;\n}"
  },
  {
    "function_name": "tomoyo_find_next_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "679-856",
    "snippet": "int tomoyo_find_next_domain(struct linux_binprm *bprm)\n{\n\tstruct tomoyo_domain_info *old_domain = tomoyo_domain();\n\tstruct tomoyo_domain_info *domain = NULL;\n\tconst char *original_name = bprm->filename;\n\tint retval = -ENOMEM;\n\tbool reject_on_transition_failure = false;\n\tconst struct tomoyo_path_info *candidate;\n\tstruct tomoyo_path_info exename;\n\tstruct tomoyo_execve *ee = kzalloc(sizeof(*ee), GFP_NOFS);\n\n\tif (!ee)\n\t\treturn -ENOMEM;\n\tee->tmp = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);\n\tif (!ee->tmp) {\n\t\tkfree(ee);\n\t\treturn -ENOMEM;\n\t}\n\t/* ee->dump->data is allocated by tomoyo_dump_page(). */\n\ttomoyo_init_request_info(&ee->r, NULL, TOMOYO_MAC_FILE_EXECUTE);\n\tee->r.ee = ee;\n\tee->bprm = bprm;\n\tee->r.obj = &ee->obj;\n\tee->obj.path1 = bprm->file->f_path;\n\t/* Get symlink's pathname of program. */\n\tretval = -ENOENT;\n\texename.name = tomoyo_realpath_nofollow(original_name);\n\tif (!exename.name)\n\t\tgoto out;\n\ttomoyo_fill_path_info(&exename);\nretry:\n\t/* Check 'aggregator' directive. */\n\t{\n\t\tstruct tomoyo_aggregator *ptr;\n\t\tstruct list_head *list =\n\t\t\t&old_domain->ns->policy_list[TOMOYO_ID_AGGREGATOR];\n\t\t/* Check 'aggregator' directive. */\n\t\tcandidate = &exename;\n\t\tlist_for_each_entry_rcu(ptr, list, head.list) {\n\t\t\tif (ptr->head.is_deleted ||\n\t\t\t    !tomoyo_path_matches_pattern(&exename,\n\t\t\t\t\t\t\t ptr->original_name))\n\t\t\t\tcontinue;\n\t\t\tcandidate = ptr->aggregated_name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Check execute permission. */\n\tretval = tomoyo_execute_permission(&ee->r, candidate);\n\tif (retval == TOMOYO_RETRY_REQUEST)\n\t\tgoto retry;\n\tif (retval < 0)\n\t\tgoto out;\n\t/*\n\t * To be able to specify domainnames with wildcards, use the\n\t * pathname specified in the policy (which may contain\n\t * wildcard) rather than the pathname passed to execve()\n\t * (which never contains wildcard).\n\t */\n\tif (ee->r.param.path.matched_path)\n\t\tcandidate = ee->r.param.path.matched_path;\n\n\t/*\n\t * Check for domain transition preference if \"file execute\" matched.\n\t * If preference is given, make do_execve() fail if domain transition\n\t * has failed, for domain transition preference should be used with\n\t * destination domain defined.\n\t */\n\tif (ee->transition) {\n\t\tconst char *domainname = ee->transition->name;\n\t\treject_on_transition_failure = true;\n\t\tif (!strcmp(domainname, \"keep\"))\n\t\t\tgoto force_keep_domain;\n\t\tif (!strcmp(domainname, \"child\"))\n\t\t\tgoto force_child_domain;\n\t\tif (!strcmp(domainname, \"reset\"))\n\t\t\tgoto force_reset_domain;\n\t\tif (!strcmp(domainname, \"initialize\"))\n\t\t\tgoto force_initialize_domain;\n\t\tif (!strcmp(domainname, \"parent\")) {\n\t\t\tchar *cp;\n\t\t\tstrncpy(ee->tmp, old_domain->domainname->name,\n\t\t\t\tTOMOYO_EXEC_TMPSIZE - 1);\n\t\t\tcp = strrchr(ee->tmp, ' ');\n\t\t\tif (cp)\n\t\t\t\t*cp = '\\0';\n\t\t} else if (*domainname == '<')\n\t\t\tstrncpy(ee->tmp, domainname, TOMOYO_EXEC_TMPSIZE - 1);\n\t\telse\n\t\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t\t old_domain->domainname->name, domainname);\n\t\tgoto force_jump_domain;\n\t}\n\t/*\n\t * No domain transition preference specified.\n\t * Calculate domain to transit to.\n\t */\n\tswitch (tomoyo_transition_type(old_domain->ns, old_domain->domainname,\n\t\t\t\t       candidate)) {\n\tcase TOMOYO_TRANSITION_CONTROL_RESET:\nforce_reset_domain:\n\t\t/* Transit to the root of specified namespace. */\n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"<%s>\",\n\t\t\t candidate->name);\n\t\t/*\n\t\t * Make do_execve() fail if domain transition across namespaces\n\t\t * has failed.\n\t\t */\n\t\treject_on_transition_failure = true;\n\t\tbreak;\n\tcase TOMOYO_TRANSITION_CONTROL_INITIALIZE:\nforce_initialize_domain:\n\t\t/* Transit to the child of current namespace's root. */\n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t old_domain->ns->name, candidate->name);\n\t\tbreak;\n\tcase TOMOYO_TRANSITION_CONTROL_KEEP:\nforce_keep_domain:\n\t\t/* Keep current domain. */\n\t\tdomain = old_domain;\n\t\tbreak;\n\tdefault:\n\t\tif (old_domain == &tomoyo_kernel_domain &&\n\t\t    !tomoyo_policy_loaded) {\n\t\t\t/*\n\t\t\t * Needn't to transit from kernel domain before\n\t\t\t * starting /sbin/init. But transit from kernel domain\n\t\t\t * if executing initializers because they might start\n\t\t\t * before /sbin/init.\n\t\t\t */\n\t\t\tdomain = old_domain;\n\t\t\tbreak;\n\t\t}\nforce_child_domain:\n\t\t/* Normal domain transition. */\n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t old_domain->domainname->name, candidate->name);\n\t\tbreak;\n\t}\nforce_jump_domain:\n\tif (!domain)\n\t\tdomain = tomoyo_assign_domain(ee->tmp, true);\n\tif (domain)\n\t\tretval = 0;\n\telse if (reject_on_transition_failure) {\n\t\tprintk(KERN_WARNING \"ERROR: Domain '%s' not ready.\\n\",\n\t\t       ee->tmp);\n\t\tretval = -ENOMEM;\n\t} else if (ee->r.mode == TOMOYO_CONFIG_ENFORCING)\n\t\tretval = -ENOMEM;\n\telse {\n\t\tretval = 0;\n\t\tif (!old_domain->flags[TOMOYO_DIF_TRANSITION_FAILED]) {\n\t\t\told_domain->flags[TOMOYO_DIF_TRANSITION_FAILED] = true;\n\t\t\tee->r.granted = false;\n\t\t\ttomoyo_write_log(&ee->r, \"%s\", tomoyo_dif\n\t\t\t\t\t [TOMOYO_DIF_TRANSITION_FAILED]);\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"ERROR: Domain '%s' not defined.\\n\", ee->tmp);\n\t\t}\n\t}\n out:\n\tif (!domain)\n\t\tdomain = old_domain;\n\t/* Update reference count on \"struct tomoyo_domain_info\". */\n\tatomic_inc(&domain->users);\n\tbprm->cred->security = domain;\n\tkfree(exename.name);\n\tif (!retval) {\n\t\tee->r.domain = domain;\n\t\tretval = tomoyo_environ(ee);\n\t}\n\tkfree(ee->tmp);\n\tkfree(ee->dump.data);\n\tkfree(ee);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct tomoyo_domain_info tomoyo_kernel_domain;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ee"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ee->dump.data"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ee->tmp"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_environ",
          "args": [
            "ee"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_environ",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "591-668",
          "snippet": "static int tomoyo_environ(struct tomoyo_execve *ee)\n{\n\tstruct tomoyo_request_info *r = &ee->r;\n\tstruct linux_binprm *bprm = ee->bprm;\n\t/* env_page.data is allocated by tomoyo_dump_page(). */\n\tstruct tomoyo_page_dump env_page = { };\n\tchar *arg_ptr; /* Size is TOMOYO_EXEC_TMPSIZE bytes */\n\tint arg_len = 0;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tint error = -ENOMEM;\n\n\tee->r.type = TOMOYO_MAC_ENVIRON;\n\tee->r.profile = r->domain->profile;\n\tee->r.mode = tomoyo_get_mode(r->domain->ns, ee->r.profile,\n\t\t\t\t     TOMOYO_MAC_ENVIRON);\n\tif (!r->mode || !envp_count)\n\t\treturn 0;\n\targ_ptr = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);\n\tif (!arg_ptr)\n\t\tgoto out;\n\twhile (error == -ENOMEM) {\n\t\tif (!tomoyo_dump_page(bprm, pos, &env_page))\n\t\t\tgoto out;\n\t\tpos += PAGE_SIZE - offset;\n\t\t/* Read. */\n\t\twhile (argv_count && offset < PAGE_SIZE) {\n\t\t\tif (!env_page.data[offset++])\n\t\t\t\targv_count--;\n\t\t}\n\t\tif (argv_count) {\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\tconst unsigned char c = env_page.data[offset++];\n\n\t\t\tif (c && arg_len < TOMOYO_EXEC_TMPSIZE - 10) {\n\t\t\t\tif (c == '=') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\0';\n\t\t\t\t} else if (c == '\\\\') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t\targ_ptr[arg_len++] = c;\n\t\t\t\t} else {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = (c >> 6) + '0';\n\t\t\t\t\targ_ptr[arg_len++]\n\t\t\t\t\t\t= ((c >> 3) & 7) + '0';\n\t\t\t\t\targ_ptr[arg_len++] = (c & 7) + '0';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targ_ptr[arg_len] = '\\0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\tif (tomoyo_env_perm(r, arg_ptr)) {\n\t\t\t\terror = -EPERM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!--envp_count) {\n\t\t\t\terror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ_len = 0;\n\t\t}\n\t\toffset = 0;\n\t}\nout:\n\tif (r->mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\tkfree(env_page.data);\n\tkfree(arg_ptr);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic int tomoyo_environ(struct tomoyo_execve *ee)\n{\n\tstruct tomoyo_request_info *r = &ee->r;\n\tstruct linux_binprm *bprm = ee->bprm;\n\t/* env_page.data is allocated by tomoyo_dump_page(). */\n\tstruct tomoyo_page_dump env_page = { };\n\tchar *arg_ptr; /* Size is TOMOYO_EXEC_TMPSIZE bytes */\n\tint arg_len = 0;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tint error = -ENOMEM;\n\n\tee->r.type = TOMOYO_MAC_ENVIRON;\n\tee->r.profile = r->domain->profile;\n\tee->r.mode = tomoyo_get_mode(r->domain->ns, ee->r.profile,\n\t\t\t\t     TOMOYO_MAC_ENVIRON);\n\tif (!r->mode || !envp_count)\n\t\treturn 0;\n\targ_ptr = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);\n\tif (!arg_ptr)\n\t\tgoto out;\n\twhile (error == -ENOMEM) {\n\t\tif (!tomoyo_dump_page(bprm, pos, &env_page))\n\t\t\tgoto out;\n\t\tpos += PAGE_SIZE - offset;\n\t\t/* Read. */\n\t\twhile (argv_count && offset < PAGE_SIZE) {\n\t\t\tif (!env_page.data[offset++])\n\t\t\t\targv_count--;\n\t\t}\n\t\tif (argv_count) {\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\tconst unsigned char c = env_page.data[offset++];\n\n\t\t\tif (c && arg_len < TOMOYO_EXEC_TMPSIZE - 10) {\n\t\t\t\tif (c == '=') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\0';\n\t\t\t\t} else if (c == '\\\\') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t\targ_ptr[arg_len++] = c;\n\t\t\t\t} else {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = (c >> 6) + '0';\n\t\t\t\t\targ_ptr[arg_len++]\n\t\t\t\t\t\t= ((c >> 3) & 7) + '0';\n\t\t\t\t\targ_ptr[arg_len++] = (c & 7) + '0';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targ_ptr[arg_len] = '\\0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\tif (tomoyo_env_perm(r, arg_ptr)) {\n\t\t\t\terror = -EPERM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!--envp_count) {\n\t\t\t\terror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ_len = 0;\n\t\t}\n\t\toffset = 0;\n\t}\nout:\n\tif (r->mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\tkfree(env_page.data);\n\tkfree(arg_ptr);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "exename.name"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&domain->users"
          ],
          "line": 845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING\n\t\t\t       \"ERROR: Domain '%s' not defined.\\n\"",
            "ee->tmp"
          ],
          "line": 837
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_write_log",
          "args": [
            "&ee->r",
            "\"%s\"",
            "tomoyo_dif\n\t\t\t\t\t [TOMOYO_DIF_TRANSITION_FAILED]"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_write_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
          "lines": "412-422",
          "snippet": "void tomoyo_write_log(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint len;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_write_log(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint len;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_assign_domain",
          "args": [
            "ee->tmp",
            "true"
          ],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_assign_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "507-582",
          "snippet": "struct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,\n\t\t\t\t\t\tconst bool transit)\n{\n\tstruct tomoyo_domain_info e = { };\n\tstruct tomoyo_domain_info *entry = tomoyo_find_domain(domainname);\n\tbool created = false;\n\tif (entry) {\n\t\tif (transit) {\n\t\t\t/*\n\t\t\t * Since namespace is created at runtime, profiles may\n\t\t\t * not be created by the moment the process transits to\n\t\t\t * that domain. Do not perform domain transition if\n\t\t\t * profile for that domain is not yet created.\n\t\t\t */\n\t\t\tif (tomoyo_policy_loaded &&\n\t\t\t    !entry->ns->profile_ptr[entry->profile])\n\t\t\t\treturn NULL;\n\t\t}\n\t\treturn entry;\n\t}\n\t/* Requested domain does not exist. */\n\t/* Don't create requested domain if domainname is invalid. */\n\tif (strlen(domainname) >= TOMOYO_EXEC_TMPSIZE - 10 ||\n\t    !tomoyo_correct_domain(domainname))\n\t\treturn NULL;\n\t/*\n\t * Since definition of profiles and acl_groups may differ across\n\t * namespaces, do not inherit \"use_profile\" and \"use_group\" settings\n\t * by automatically creating requested domain upon domain transition.\n\t */\n\tif (transit && tomoyo_namespace_jump(domainname))\n\t\treturn NULL;\n\te.ns = tomoyo_assign_namespace(domainname);\n\tif (!e.ns)\n\t\treturn NULL;\n\t/*\n\t * \"use_profile\" and \"use_group\" settings for automatically created\n\t * domains are inherited from current domain. These are 0 for manually\n\t * created domains.\n\t */\n\tif (transit) {\n\t\tconst struct tomoyo_domain_info *domain = tomoyo_domain();\n\t\te.profile = domain->profile;\n\t\te.group = domain->group;\n\t}\n\te.domainname = tomoyo_get_name(domainname);\n\tif (!e.domainname)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tentry = tomoyo_find_domain(domainname);\n\tif (!entry) {\n\t\tentry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->acl_info_list);\n\t\t\tlist_add_tail_rcu(&entry->list, &tomoyo_domain_list);\n\t\t\tcreated = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.domainname);\n\tif (entry && transit) {\n\t\tif (created) {\n\t\t\tstruct tomoyo_request_info r;\n\t\t\ttomoyo_init_request_info(&r, entry,\n\t\t\t\t\t\t TOMOYO_MAC_FILE_EXECUTE);\n\t\t\tr.granted = false;\n\t\t\ttomoyo_write_log(&r, \"use_profile %u\\n\",\n\t\t\t\t\t entry->profile);\n\t\t\ttomoyo_write_log(&r, \"use_group %u\\n\", entry->group);\n\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t}\n\t}\n\treturn entry;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstruct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,\n\t\t\t\t\t\tconst bool transit)\n{\n\tstruct tomoyo_domain_info e = { };\n\tstruct tomoyo_domain_info *entry = tomoyo_find_domain(domainname);\n\tbool created = false;\n\tif (entry) {\n\t\tif (transit) {\n\t\t\t/*\n\t\t\t * Since namespace is created at runtime, profiles may\n\t\t\t * not be created by the moment the process transits to\n\t\t\t * that domain. Do not perform domain transition if\n\t\t\t * profile for that domain is not yet created.\n\t\t\t */\n\t\t\tif (tomoyo_policy_loaded &&\n\t\t\t    !entry->ns->profile_ptr[entry->profile])\n\t\t\t\treturn NULL;\n\t\t}\n\t\treturn entry;\n\t}\n\t/* Requested domain does not exist. */\n\t/* Don't create requested domain if domainname is invalid. */\n\tif (strlen(domainname) >= TOMOYO_EXEC_TMPSIZE - 10 ||\n\t    !tomoyo_correct_domain(domainname))\n\t\treturn NULL;\n\t/*\n\t * Since definition of profiles and acl_groups may differ across\n\t * namespaces, do not inherit \"use_profile\" and \"use_group\" settings\n\t * by automatically creating requested domain upon domain transition.\n\t */\n\tif (transit && tomoyo_namespace_jump(domainname))\n\t\treturn NULL;\n\te.ns = tomoyo_assign_namespace(domainname);\n\tif (!e.ns)\n\t\treturn NULL;\n\t/*\n\t * \"use_profile\" and \"use_group\" settings for automatically created\n\t * domains are inherited from current domain. These are 0 for manually\n\t * created domains.\n\t */\n\tif (transit) {\n\t\tconst struct tomoyo_domain_info *domain = tomoyo_domain();\n\t\te.profile = domain->profile;\n\t\te.group = domain->group;\n\t}\n\te.domainname = tomoyo_get_name(domainname);\n\tif (!e.domainname)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tentry = tomoyo_find_domain(domainname);\n\tif (!entry) {\n\t\tentry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->acl_info_list);\n\t\t\tlist_add_tail_rcu(&entry->list, &tomoyo_domain_list);\n\t\t\tcreated = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.domainname);\n\tif (entry && transit) {\n\t\tif (created) {\n\t\t\tstruct tomoyo_request_info r;\n\t\t\ttomoyo_init_request_info(&r, entry,\n\t\t\t\t\t\t TOMOYO_MAC_FILE_EXECUTE);\n\t\t\tr.granted = false;\n\t\t\ttomoyo_write_log(&r, \"use_profile %u\\n\",\n\t\t\t\t\t entry->profile);\n\t\t\ttomoyo_write_log(&r, \"use_group %u\\n\", entry->group);\n\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t}\n\t}\n\treturn entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ee->tmp",
            "TOMOYO_EXEC_TMPSIZE - 1",
            "\"%s %s\"",
            "old_domain->domainname->name",
            "candidate->name"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ee->tmp",
            "TOMOYO_EXEC_TMPSIZE - 1",
            "\"%s %s\"",
            "old_domain->ns->name",
            "candidate->name"
          ],
          "line": 793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ee->tmp",
            "TOMOYO_EXEC_TMPSIZE - 1",
            "\"<%s>\"",
            "candidate->name"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_transition_type",
          "args": [
            "old_domain->ns",
            "old_domain->domainname",
            "candidate"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_transition_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "334-361",
          "snippet": "static enum tomoyo_transition_type tomoyo_transition_type\n(const struct tomoyo_policy_namespace *ns,\n const struct tomoyo_path_info *domainname,\n const struct tomoyo_path_info *program)\n{\n\tconst char *last_name = tomoyo_last_word(domainname->name);\n\tenum tomoyo_transition_type type = TOMOYO_TRANSITION_CONTROL_NO_RESET;\n\twhile (type < TOMOYO_MAX_TRANSITION_TYPE) {\n\t\tconst struct list_head * const list =\n\t\t\t&ns->policy_list[TOMOYO_ID_TRANSITION_CONTROL];\n\t\tif (!tomoyo_scan_transition(list, domainname, program,\n\t\t\t\t\t    last_name, type)) {\n\t\t\ttype++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (type != TOMOYO_TRANSITION_CONTROL_NO_RESET &&\n\t\t    type != TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE)\n\t\t\tbreak;\n\t\t/*\n\t\t * Do not check for reset_domain if no_reset_domain matched.\n\t\t * Do not check for initialize_domain if no_initialize_domain\n\t\t * matched.\n\t\t */\n\t\ttype++;\n\t\ttype++;\n\t}\n\treturn type;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic enum tomoyo_transition_type tomoyo_transition_type\n(const struct tomoyo_policy_namespace *ns,\n const struct tomoyo_path_info *domainname,\n const struct tomoyo_path_info *program)\n{\n\tconst char *last_name = tomoyo_last_word(domainname->name);\n\tenum tomoyo_transition_type type = TOMOYO_TRANSITION_CONTROL_NO_RESET;\n\twhile (type < TOMOYO_MAX_TRANSITION_TYPE) {\n\t\tconst struct list_head * const list =\n\t\t\t&ns->policy_list[TOMOYO_ID_TRANSITION_CONTROL];\n\t\tif (!tomoyo_scan_transition(list, domainname, program,\n\t\t\t\t\t    last_name, type)) {\n\t\t\ttype++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (type != TOMOYO_TRANSITION_CONTROL_NO_RESET &&\n\t\t    type != TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE)\n\t\t\tbreak;\n\t\t/*\n\t\t * Do not check for reset_domain if no_reset_domain matched.\n\t\t * Do not check for initialize_domain if no_initialize_domain\n\t\t * matched.\n\t\t */\n\t\ttype++;\n\t\ttype++;\n\t}\n\treturn type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "ee->tmp",
            "TOMOYO_EXEC_TMPSIZE - 1",
            "\"%s %s\"",
            "old_domain->domainname->name",
            "domainname"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ee->tmp",
            "domainname",
            "TOMOYO_EXEC_TMPSIZE - 1"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "ee->tmp",
            "' '"
          ],
          "line": 763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "ee->tmp",
            "old_domain->domainname->name",
            "TOMOYO_EXEC_TMPSIZE - 1"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "domainname",
            "\"parent\""
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "domainname",
            "\"initialize\""
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "domainname",
            "\"reset\""
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "domainname",
            "\"child\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "domainname",
            "\"keep\""
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_execute_permission",
          "args": [
            "&ee->r",
            "candidate"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_execute_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "588-607",
          "snippet": "int tomoyo_execute_permission(struct tomoyo_request_info *r,\n\t\t\t      const struct tomoyo_path_info *filename)\n{\n\t/*\n\t * Unlike other permission checks, this check is done regardless of\n\t * profile mode settings in order to check for domain transition\n\t * preference.\n\t */\n\tr->type = TOMOYO_MAC_FILE_EXECUTE;\n\tr->mode = tomoyo_get_mode(r->domain->ns, r->profile, r->type);\n\tr->param_type = TOMOYO_TYPE_PATH_ACL;\n\tr->param.path.filename = filename;\n\tr->param.path.operation = TOMOYO_TYPE_EXECUTE;\n\ttomoyo_check_acl(r, tomoyo_check_path_acl);\n\tr->ee->transition = r->matched_acl && r->matched_acl->cond ?\n\t\tr->matched_acl->cond->transit : NULL;\n\tif (r->mode != TOMOYO_CONFIG_DISABLED)\n\t\treturn tomoyo_audit_path_log(r);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nint tomoyo_execute_permission(struct tomoyo_request_info *r,\n\t\t\t      const struct tomoyo_path_info *filename)\n{\n\t/*\n\t * Unlike other permission checks, this check is done regardless of\n\t * profile mode settings in order to check for domain transition\n\t * preference.\n\t */\n\tr->type = TOMOYO_MAC_FILE_EXECUTE;\n\tr->mode = tomoyo_get_mode(r->domain->ns, r->profile, r->type);\n\tr->param_type = TOMOYO_TYPE_PATH_ACL;\n\tr->param.path.filename = filename;\n\tr->param.path.operation = TOMOYO_TYPE_EXECUTE;\n\ttomoyo_check_acl(r, tomoyo_check_path_acl);\n\tr->ee->transition = r->matched_acl && r->matched_acl->cond ?\n\t\tr->matched_acl->cond->transit : NULL;\n\tif (r->mode != TOMOYO_CONFIG_DISABLED)\n\t\treturn tomoyo_audit_path_log(r);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_path_matches_pattern",
          "args": [
            "&exename",
            "ptr->original_name"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_matches_pattern",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "902-921",
          "snippet": "bool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,\n\t\t\t\t const struct tomoyo_path_info *pattern)\n{\n\tconst char *f = filename->name;\n\tconst char *p = pattern->name;\n\tconst int len = pattern->const_len;\n\n\t/* If @pattern doesn't contain pattern, I can use strcmp(). */\n\tif (!pattern->is_patterned)\n\t\treturn !tomoyo_pathcmp(filename, pattern);\n\t/* Don't compare directory and non-directory. */\n\tif (filename->is_dir != pattern->is_dir)\n\t\treturn false;\n\t/* Compare the initial length without patterns. */\n\tif (strncmp(f, p, len))\n\t\treturn false;\n\tf += len;\n\tp += len;\n\treturn tomoyo_path_matches_pattern2(f, p);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_path_matches_pattern(const struct tomoyo_path_info *filename,\n\t\t\t\t const struct tomoyo_path_info *pattern)\n{\n\tconst char *f = filename->name;\n\tconst char *p = pattern->name;\n\tconst int len = pattern->const_len;\n\n\t/* If @pattern doesn't contain pattern, I can use strcmp(). */\n\tif (!pattern->is_patterned)\n\t\treturn !tomoyo_pathcmp(filename, pattern);\n\t/* Don't compare directory and non-directory. */\n\tif (filename->is_dir != pattern->is_dir)\n\t\treturn false;\n\t/* Compare the initial length without patterns. */\n\tif (strncmp(f, p, len))\n\t\treturn false;\n\tf += len;\n\tp += len;\n\treturn tomoyo_path_matches_pattern2(f, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "ptr",
            "list",
            "head.list"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_fill_path_info",
          "args": [
            "&exename"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_fill_path_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "643-652",
          "snippet": "void tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_realpath_nofollow",
          "args": [
            "original_name"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_realpath_nofollow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "320-330",
          "snippet": "char *tomoyo_realpath_nofollow(const char *pathname)\n{\n\tstruct path path;\n\n\tif (pathname && kern_path(pathname, 0, &path) == 0) {\n\t\tchar *buf = tomoyo_realpath_from_path(&path);\n\t\tpath_put(&path);\n\t\treturn buf;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_realpath_nofollow(const char *pathname)\n{\n\tstruct path path;\n\n\tif (pathname && kern_path(pathname, 0, &path) == 0) {\n\t\tchar *buf = tomoyo_realpath_from_path(&path);\n\t\tpath_put(&path);\n\t\treturn buf;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_init_request_info",
          "args": [
            "&ee->r",
            "NULL",
            "TOMOYO_MAC_FILE_EXECUTE"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_init_request_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "984-997",
          "snippet": "int tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nint tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ee"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "TOMOYO_EXEC_TMPSIZE",
            "GFP_NOFS"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*ee)",
            "GFP_NOFS"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_domain",
          "args": [],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1204-1207",
          "snippet": "static inline struct tomoyo_domain_info *tomoyo_domain(void)\n{\n\treturn current_cred()->security;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline struct tomoyo_domain_info *tomoyo_domain(void)\n{\n\treturn current_cred()->security;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstruct tomoyo_domain_info tomoyo_kernel_domain;\n\nint tomoyo_find_next_domain(struct linux_binprm *bprm)\n{\n\tstruct tomoyo_domain_info *old_domain = tomoyo_domain();\n\tstruct tomoyo_domain_info *domain = NULL;\n\tconst char *original_name = bprm->filename;\n\tint retval = -ENOMEM;\n\tbool reject_on_transition_failure = false;\n\tconst struct tomoyo_path_info *candidate;\n\tstruct tomoyo_path_info exename;\n\tstruct tomoyo_execve *ee = kzalloc(sizeof(*ee), GFP_NOFS);\n\n\tif (!ee)\n\t\treturn -ENOMEM;\n\tee->tmp = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);\n\tif (!ee->tmp) {\n\t\tkfree(ee);\n\t\treturn -ENOMEM;\n\t}\n\t/* ee->dump->data is allocated by tomoyo_dump_page(). */\n\ttomoyo_init_request_info(&ee->r, NULL, TOMOYO_MAC_FILE_EXECUTE);\n\tee->r.ee = ee;\n\tee->bprm = bprm;\n\tee->r.obj = &ee->obj;\n\tee->obj.path1 = bprm->file->f_path;\n\t/* Get symlink's pathname of program. */\n\tretval = -ENOENT;\n\texename.name = tomoyo_realpath_nofollow(original_name);\n\tif (!exename.name)\n\t\tgoto out;\n\ttomoyo_fill_path_info(&exename);\nretry:\n\t/* Check 'aggregator' directive. */\n\t{\n\t\tstruct tomoyo_aggregator *ptr;\n\t\tstruct list_head *list =\n\t\t\t&old_domain->ns->policy_list[TOMOYO_ID_AGGREGATOR];\n\t\t/* Check 'aggregator' directive. */\n\t\tcandidate = &exename;\n\t\tlist_for_each_entry_rcu(ptr, list, head.list) {\n\t\t\tif (ptr->head.is_deleted ||\n\t\t\t    !tomoyo_path_matches_pattern(&exename,\n\t\t\t\t\t\t\t ptr->original_name))\n\t\t\t\tcontinue;\n\t\t\tcandidate = ptr->aggregated_name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Check execute permission. */\n\tretval = tomoyo_execute_permission(&ee->r, candidate);\n\tif (retval == TOMOYO_RETRY_REQUEST)\n\t\tgoto retry;\n\tif (retval < 0)\n\t\tgoto out;\n\t/*\n\t * To be able to specify domainnames with wildcards, use the\n\t * pathname specified in the policy (which may contain\n\t * wildcard) rather than the pathname passed to execve()\n\t * (which never contains wildcard).\n\t */\n\tif (ee->r.param.path.matched_path)\n\t\tcandidate = ee->r.param.path.matched_path;\n\n\t/*\n\t * Check for domain transition preference if \"file execute\" matched.\n\t * If preference is given, make do_execve() fail if domain transition\n\t * has failed, for domain transition preference should be used with\n\t * destination domain defined.\n\t */\n\tif (ee->transition) {\n\t\tconst char *domainname = ee->transition->name;\n\t\treject_on_transition_failure = true;\n\t\tif (!strcmp(domainname, \"keep\"))\n\t\t\tgoto force_keep_domain;\n\t\tif (!strcmp(domainname, \"child\"))\n\t\t\tgoto force_child_domain;\n\t\tif (!strcmp(domainname, \"reset\"))\n\t\t\tgoto force_reset_domain;\n\t\tif (!strcmp(domainname, \"initialize\"))\n\t\t\tgoto force_initialize_domain;\n\t\tif (!strcmp(domainname, \"parent\")) {\n\t\t\tchar *cp;\n\t\t\tstrncpy(ee->tmp, old_domain->domainname->name,\n\t\t\t\tTOMOYO_EXEC_TMPSIZE - 1);\n\t\t\tcp = strrchr(ee->tmp, ' ');\n\t\t\tif (cp)\n\t\t\t\t*cp = '\\0';\n\t\t} else if (*domainname == '<')\n\t\t\tstrncpy(ee->tmp, domainname, TOMOYO_EXEC_TMPSIZE - 1);\n\t\telse\n\t\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t\t old_domain->domainname->name, domainname);\n\t\tgoto force_jump_domain;\n\t}\n\t/*\n\t * No domain transition preference specified.\n\t * Calculate domain to transit to.\n\t */\n\tswitch (tomoyo_transition_type(old_domain->ns, old_domain->domainname,\n\t\t\t\t       candidate)) {\n\tcase TOMOYO_TRANSITION_CONTROL_RESET:\nforce_reset_domain:\n\t\t/* Transit to the root of specified namespace. */\n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"<%s>\",\n\t\t\t candidate->name);\n\t\t/*\n\t\t * Make do_execve() fail if domain transition across namespaces\n\t\t * has failed.\n\t\t */\n\t\treject_on_transition_failure = true;\n\t\tbreak;\n\tcase TOMOYO_TRANSITION_CONTROL_INITIALIZE:\nforce_initialize_domain:\n\t\t/* Transit to the child of current namespace's root. */\n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t old_domain->ns->name, candidate->name);\n\t\tbreak;\n\tcase TOMOYO_TRANSITION_CONTROL_KEEP:\nforce_keep_domain:\n\t\t/* Keep current domain. */\n\t\tdomain = old_domain;\n\t\tbreak;\n\tdefault:\n\t\tif (old_domain == &tomoyo_kernel_domain &&\n\t\t    !tomoyo_policy_loaded) {\n\t\t\t/*\n\t\t\t * Needn't to transit from kernel domain before\n\t\t\t * starting /sbin/init. But transit from kernel domain\n\t\t\t * if executing initializers because they might start\n\t\t\t * before /sbin/init.\n\t\t\t */\n\t\t\tdomain = old_domain;\n\t\t\tbreak;\n\t\t}\nforce_child_domain:\n\t\t/* Normal domain transition. */\n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t old_domain->domainname->name, candidate->name);\n\t\tbreak;\n\t}\nforce_jump_domain:\n\tif (!domain)\n\t\tdomain = tomoyo_assign_domain(ee->tmp, true);\n\tif (domain)\n\t\tretval = 0;\n\telse if (reject_on_transition_failure) {\n\t\tprintk(KERN_WARNING \"ERROR: Domain '%s' not ready.\\n\",\n\t\t       ee->tmp);\n\t\tretval = -ENOMEM;\n\t} else if (ee->r.mode == TOMOYO_CONFIG_ENFORCING)\n\t\tretval = -ENOMEM;\n\telse {\n\t\tretval = 0;\n\t\tif (!old_domain->flags[TOMOYO_DIF_TRANSITION_FAILED]) {\n\t\t\told_domain->flags[TOMOYO_DIF_TRANSITION_FAILED] = true;\n\t\t\tee->r.granted = false;\n\t\t\ttomoyo_write_log(&ee->r, \"%s\", tomoyo_dif\n\t\t\t\t\t [TOMOYO_DIF_TRANSITION_FAILED]);\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"ERROR: Domain '%s' not defined.\\n\", ee->tmp);\n\t\t}\n\t}\n out:\n\tif (!domain)\n\t\tdomain = old_domain;\n\t/* Update reference count on \"struct tomoyo_domain_info\". */\n\tatomic_inc(&domain->users);\n\tbprm->cred->security = domain;\n\tkfree(exename.name);\n\tif (!retval) {\n\t\tee->r.domain = domain;\n\t\tretval = tomoyo_environ(ee);\n\t}\n\tkfree(ee->tmp);\n\tkfree(ee->dump.data);\n\tkfree(ee);\n\treturn retval;\n}"
  },
  {
    "function_name": "tomoyo_environ",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "591-668",
    "snippet": "static int tomoyo_environ(struct tomoyo_execve *ee)\n{\n\tstruct tomoyo_request_info *r = &ee->r;\n\tstruct linux_binprm *bprm = ee->bprm;\n\t/* env_page.data is allocated by tomoyo_dump_page(). */\n\tstruct tomoyo_page_dump env_page = { };\n\tchar *arg_ptr; /* Size is TOMOYO_EXEC_TMPSIZE bytes */\n\tint arg_len = 0;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tint error = -ENOMEM;\n\n\tee->r.type = TOMOYO_MAC_ENVIRON;\n\tee->r.profile = r->domain->profile;\n\tee->r.mode = tomoyo_get_mode(r->domain->ns, ee->r.profile,\n\t\t\t\t     TOMOYO_MAC_ENVIRON);\n\tif (!r->mode || !envp_count)\n\t\treturn 0;\n\targ_ptr = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);\n\tif (!arg_ptr)\n\t\tgoto out;\n\twhile (error == -ENOMEM) {\n\t\tif (!tomoyo_dump_page(bprm, pos, &env_page))\n\t\t\tgoto out;\n\t\tpos += PAGE_SIZE - offset;\n\t\t/* Read. */\n\t\twhile (argv_count && offset < PAGE_SIZE) {\n\t\t\tif (!env_page.data[offset++])\n\t\t\t\targv_count--;\n\t\t}\n\t\tif (argv_count) {\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\tconst unsigned char c = env_page.data[offset++];\n\n\t\t\tif (c && arg_len < TOMOYO_EXEC_TMPSIZE - 10) {\n\t\t\t\tif (c == '=') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\0';\n\t\t\t\t} else if (c == '\\\\') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t\targ_ptr[arg_len++] = c;\n\t\t\t\t} else {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = (c >> 6) + '0';\n\t\t\t\t\targ_ptr[arg_len++]\n\t\t\t\t\t\t= ((c >> 3) & 7) + '0';\n\t\t\t\t\targ_ptr[arg_len++] = (c & 7) + '0';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targ_ptr[arg_len] = '\\0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\tif (tomoyo_env_perm(r, arg_ptr)) {\n\t\t\t\terror = -EPERM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!--envp_count) {\n\t\t\t\terror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ_len = 0;\n\t\t}\n\t\toffset = 0;\n\t}\nout:\n\tif (r->mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\tkfree(env_page.data);\n\tkfree(arg_ptr);\n\treturn error;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "arg_ptr"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "env_page.data"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_env_perm",
          "args": [
            "r",
            "arg_ptr"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_env_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/environ.c",
          "lines": "50-66",
          "snippet": "int tomoyo_env_perm(struct tomoyo_request_info *r, const char *env)\n{\n\tstruct tomoyo_path_info environ;\n\tint error;\n\n\tif (!env || !*env)\n\t\treturn 0;\n\tenviron.name = env;\n\ttomoyo_fill_path_info(&environ);\n\tr->param_type = TOMOYO_TYPE_ENV_ACL;\n\tr->param.environ.name = &environ;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_env_acl);\n\t\terror = tomoyo_audit_env_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\treturn error;\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nint tomoyo_env_perm(struct tomoyo_request_info *r, const char *env)\n{\n\tstruct tomoyo_path_info environ;\n\tint error;\n\n\tif (!env || !*env)\n\t\treturn 0;\n\tenviron.name = env;\n\ttomoyo_fill_path_info(&environ);\n\tr->param_type = TOMOYO_TYPE_ENV_ACL;\n\tr->param.environ.name = &environ;\n\tdo {\n\t\ttomoyo_check_acl(r, tomoyo_check_env_acl);\n\t\terror = tomoyo_audit_env_log(r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_dump_page",
          "args": [
            "bprm",
            "pos",
            "&env_page"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_dump_page",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "867-911",
          "snippet": "bool tomoyo_dump_page(struct linux_binprm *bprm, unsigned long pos,\n\t\t      struct tomoyo_page_dump *dump)\n{\n\tstruct page *page;\n\n\t/* dump->data is released by tomoyo_find_next_domain(). */\n\tif (!dump->data) {\n\t\tdump->data = kzalloc(PAGE_SIZE, GFP_NOFS);\n\t\tif (!dump->data)\n\t\t\treturn false;\n\t}\n\t/* Same with get_arg_page(bprm, pos, 0) in fs/exec.c */\n#ifdef CONFIG_MMU\n\t/*\n\t * This is called at execve() time in order to dig around\n\t * in the argv/environment of the new proceess\n\t * (represented by bprm).  'current' is the process doing\n\t * the execve().\n\t */\n\tif (get_user_pages_remote(current, bprm->mm, pos, 1,\n\t\t\t\tFOLL_FORCE, &page, NULL, NULL) <= 0)\n\t\treturn false;\n#else\n\tpage = bprm->page[pos / PAGE_SIZE];\n#endif\n\tif (page != dump->page) {\n\t\tconst unsigned int offset = pos % PAGE_SIZE;\n\t\t/*\n\t\t * Maybe kmap()/kunmap() should be used here.\n\t\t * But remove_arg_zero() uses kmap_atomic()/kunmap_atomic().\n\t\t * So do I.\n\t\t */\n\t\tchar *kaddr = kmap_atomic(page);\n\n\t\tdump->page = page;\n\t\tmemcpy(dump->data + offset, kaddr + offset,\n\t\t       PAGE_SIZE - offset);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Same with put_arg_page(page) in fs/exec.c */\n#ifdef CONFIG_MMU\n\tput_page(page);\n#endif\n\treturn true;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nbool tomoyo_dump_page(struct linux_binprm *bprm, unsigned long pos,\n\t\t      struct tomoyo_page_dump *dump)\n{\n\tstruct page *page;\n\n\t/* dump->data is released by tomoyo_find_next_domain(). */\n\tif (!dump->data) {\n\t\tdump->data = kzalloc(PAGE_SIZE, GFP_NOFS);\n\t\tif (!dump->data)\n\t\t\treturn false;\n\t}\n\t/* Same with get_arg_page(bprm, pos, 0) in fs/exec.c */\n#ifdef CONFIG_MMU\n\t/*\n\t * This is called at execve() time in order to dig around\n\t * in the argv/environment of the new proceess\n\t * (represented by bprm).  'current' is the process doing\n\t * the execve().\n\t */\n\tif (get_user_pages_remote(current, bprm->mm, pos, 1,\n\t\t\t\tFOLL_FORCE, &page, NULL, NULL) <= 0)\n\t\treturn false;\n#else\n\tpage = bprm->page[pos / PAGE_SIZE];\n#endif\n\tif (page != dump->page) {\n\t\tconst unsigned int offset = pos % PAGE_SIZE;\n\t\t/*\n\t\t * Maybe kmap()/kunmap() should be used here.\n\t\t * But remove_arg_zero() uses kmap_atomic()/kunmap_atomic().\n\t\t * So do I.\n\t\t */\n\t\tchar *kaddr = kmap_atomic(page);\n\n\t\tdump->page = page;\n\t\tmemcpy(dump->data + offset, kaddr + offset,\n\t\t       PAGE_SIZE - offset);\n\t\tkunmap_atomic(kaddr);\n\t}\n\t/* Same with put_arg_page(page) in fs/exec.c */\n#ifdef CONFIG_MMU\n\tput_page(page);\n#endif\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "TOMOYO_EXEC_TMPSIZE",
            "GFP_NOFS"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_mode",
          "args": [
            "r->domain->ns",
            "ee->r.profile",
            "TOMOYO_MAC_ENVIRON"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "957-973",
          "snippet": "int tomoyo_get_mode(const struct tomoyo_policy_namespace *ns, const u8 profile,\n\t\t    const u8 index)\n{\n\tu8 mode;\n\tstruct tomoyo_profile *p;\n\n\tif (!tomoyo_policy_loaded)\n\t\treturn TOMOYO_CONFIG_DISABLED;\n\tp = tomoyo_profile(ns, profile);\n\tmode = p->config[index];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->config[tomoyo_index2category[index]\n\t\t\t\t + TOMOYO_MAX_MAC_INDEX];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->default_config;\n\treturn mode & 3;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool tomoyo_policy_loaded;",
            "const u8 tomoyo_index2category[TOMOYO_MAX_MAC_INDEX] = {\n\t/* CONFIG::file group */\n\t[TOMOYO_MAC_FILE_EXECUTE]    = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_OPEN]       = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CREATE]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_UNLINK]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_GETATTR]    = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKDIR]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_RMDIR]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKFIFO]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKSOCK]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_SYMLINK]    = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKCHAR]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_LINK]       = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_RENAME]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CHMOD]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CHOWN]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CHGRP]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_IOCTL]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CHROOT]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MOUNT]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_UMOUNT]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = TOMOYO_MAC_CATEGORY_FILE,\n\t/* CONFIG::network group */\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t/* CONFIG::misc group */\n\t[TOMOYO_MAC_ENVIRON]         = TOMOYO_MAC_CATEGORY_MISC,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_policy_loaded;\nconst u8 tomoyo_index2category[TOMOYO_MAX_MAC_INDEX] = {\n\t/* CONFIG::file group */\n\t[TOMOYO_MAC_FILE_EXECUTE]    = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_OPEN]       = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CREATE]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_UNLINK]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_GETATTR]    = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKDIR]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_RMDIR]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKFIFO]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKSOCK]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_TRUNCATE]   = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_SYMLINK]    = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKBLOCK]    = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MKCHAR]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_LINK]       = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_RENAME]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CHMOD]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CHOWN]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CHGRP]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_IOCTL]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_CHROOT]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_MOUNT]      = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_UMOUNT]     = TOMOYO_MAC_CATEGORY_FILE,\n\t[TOMOYO_MAC_FILE_PIVOT_ROOT] = TOMOYO_MAC_CATEGORY_FILE,\n\t/* CONFIG::network group */\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_BIND]       =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_LISTEN]     =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_STREAM_CONNECT]    =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_BIND]        =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_DGRAM_SEND]        =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_RAW_BIND]          =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_INET_RAW_SEND]          =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND]       =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN]     =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT]    =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND]        =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND]        =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND]    =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN]  =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t[TOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT] =\n\tTOMOYO_MAC_CATEGORY_NETWORK,\n\t/* CONFIG::misc group */\n\t[TOMOYO_MAC_ENVIRON]         = TOMOYO_MAC_CATEGORY_MISC,\n};\n\nint tomoyo_get_mode(const struct tomoyo_policy_namespace *ns, const u8 profile,\n\t\t    const u8 index)\n{\n\tu8 mode;\n\tstruct tomoyo_profile *p;\n\n\tif (!tomoyo_policy_loaded)\n\t\treturn TOMOYO_CONFIG_DISABLED;\n\tp = tomoyo_profile(ns, profile);\n\tmode = p->config[index];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->config[tomoyo_index2category[index]\n\t\t\t\t + TOMOYO_MAX_MAC_INDEX];\n\tif (mode == TOMOYO_CONFIG_USE_DEFAULT)\n\t\tmode = p->default_config;\n\treturn mode & 3;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic int tomoyo_environ(struct tomoyo_execve *ee)\n{\n\tstruct tomoyo_request_info *r = &ee->r;\n\tstruct linux_binprm *bprm = ee->bprm;\n\t/* env_page.data is allocated by tomoyo_dump_page(). */\n\tstruct tomoyo_page_dump env_page = { };\n\tchar *arg_ptr; /* Size is TOMOYO_EXEC_TMPSIZE bytes */\n\tint arg_len = 0;\n\tunsigned long pos = bprm->p;\n\tint offset = pos % PAGE_SIZE;\n\tint argv_count = bprm->argc;\n\tint envp_count = bprm->envc;\n\tint error = -ENOMEM;\n\n\tee->r.type = TOMOYO_MAC_ENVIRON;\n\tee->r.profile = r->domain->profile;\n\tee->r.mode = tomoyo_get_mode(r->domain->ns, ee->r.profile,\n\t\t\t\t     TOMOYO_MAC_ENVIRON);\n\tif (!r->mode || !envp_count)\n\t\treturn 0;\n\targ_ptr = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);\n\tif (!arg_ptr)\n\t\tgoto out;\n\twhile (error == -ENOMEM) {\n\t\tif (!tomoyo_dump_page(bprm, pos, &env_page))\n\t\t\tgoto out;\n\t\tpos += PAGE_SIZE - offset;\n\t\t/* Read. */\n\t\twhile (argv_count && offset < PAGE_SIZE) {\n\t\t\tif (!env_page.data[offset++])\n\t\t\t\targv_count--;\n\t\t}\n\t\tif (argv_count) {\n\t\t\toffset = 0;\n\t\t\tcontinue;\n\t\t}\n\t\twhile (offset < PAGE_SIZE) {\n\t\t\tconst unsigned char c = env_page.data[offset++];\n\n\t\t\tif (c && arg_len < TOMOYO_EXEC_TMPSIZE - 10) {\n\t\t\t\tif (c == '=') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\0';\n\t\t\t\t} else if (c == '\\\\') {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t} else if (c > ' ' && c < 127) {\n\t\t\t\t\targ_ptr[arg_len++] = c;\n\t\t\t\t} else {\n\t\t\t\t\targ_ptr[arg_len++] = '\\\\';\n\t\t\t\t\targ_ptr[arg_len++] = (c >> 6) + '0';\n\t\t\t\t\targ_ptr[arg_len++]\n\t\t\t\t\t\t= ((c >> 3) & 7) + '0';\n\t\t\t\t\targ_ptr[arg_len++] = (c & 7) + '0';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\targ_ptr[arg_len] = '\\0';\n\t\t\t}\n\t\t\tif (c)\n\t\t\t\tcontinue;\n\t\t\tif (tomoyo_env_perm(r, arg_ptr)) {\n\t\t\t\terror = -EPERM;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!--envp_count) {\n\t\t\t\terror = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\targ_len = 0;\n\t\t}\n\t\toffset = 0;\n\t}\nout:\n\tif (r->mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\tkfree(env_page.data);\n\tkfree(arg_ptr);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_assign_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "507-582",
    "snippet": "struct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,\n\t\t\t\t\t\tconst bool transit)\n{\n\tstruct tomoyo_domain_info e = { };\n\tstruct tomoyo_domain_info *entry = tomoyo_find_domain(domainname);\n\tbool created = false;\n\tif (entry) {\n\t\tif (transit) {\n\t\t\t/*\n\t\t\t * Since namespace is created at runtime, profiles may\n\t\t\t * not be created by the moment the process transits to\n\t\t\t * that domain. Do not perform domain transition if\n\t\t\t * profile for that domain is not yet created.\n\t\t\t */\n\t\t\tif (tomoyo_policy_loaded &&\n\t\t\t    !entry->ns->profile_ptr[entry->profile])\n\t\t\t\treturn NULL;\n\t\t}\n\t\treturn entry;\n\t}\n\t/* Requested domain does not exist. */\n\t/* Don't create requested domain if domainname is invalid. */\n\tif (strlen(domainname) >= TOMOYO_EXEC_TMPSIZE - 10 ||\n\t    !tomoyo_correct_domain(domainname))\n\t\treturn NULL;\n\t/*\n\t * Since definition of profiles and acl_groups may differ across\n\t * namespaces, do not inherit \"use_profile\" and \"use_group\" settings\n\t * by automatically creating requested domain upon domain transition.\n\t */\n\tif (transit && tomoyo_namespace_jump(domainname))\n\t\treturn NULL;\n\te.ns = tomoyo_assign_namespace(domainname);\n\tif (!e.ns)\n\t\treturn NULL;\n\t/*\n\t * \"use_profile\" and \"use_group\" settings for automatically created\n\t * domains are inherited from current domain. These are 0 for manually\n\t * created domains.\n\t */\n\tif (transit) {\n\t\tconst struct tomoyo_domain_info *domain = tomoyo_domain();\n\t\te.profile = domain->profile;\n\t\te.group = domain->group;\n\t}\n\te.domainname = tomoyo_get_name(domainname);\n\tif (!e.domainname)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tentry = tomoyo_find_domain(domainname);\n\tif (!entry) {\n\t\tentry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->acl_info_list);\n\t\t\tlist_add_tail_rcu(&entry->list, &tomoyo_domain_list);\n\t\t\tcreated = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.domainname);\n\tif (entry && transit) {\n\t\tif (created) {\n\t\t\tstruct tomoyo_request_info r;\n\t\t\ttomoyo_init_request_info(&r, entry,\n\t\t\t\t\t\t TOMOYO_MAC_FILE_EXECUTE);\n\t\t\tr.granted = false;\n\t\t\ttomoyo_write_log(&r, \"use_profile %u\\n\",\n\t\t\t\t\t entry->profile);\n\t\t\ttomoyo_write_log(&r, \"use_group %u\\n\", entry->group);\n\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t}\n\t}\n\treturn entry;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_update_stat",
          "args": [
            "TOMOYO_STAT_POLICY_UPDATES"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "2269-2276",
          "snippet": "void tomoyo_update_stat(const u8 index)\n{\n\t/*\n\t * I don't use atomic operations because race condition is not fatal.\n\t */\n\ttomoyo_stat_updated[index]++;\n\ttomoyo_stat_modified[index] = ktime_get_real_seconds();\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static unsigned int tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];",
            "static time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int tomoyo_stat_updated[TOMOYO_MAX_POLICY_STAT];\nstatic time64_t tomoyo_stat_modified[TOMOYO_MAX_POLICY_STAT];\n\nvoid tomoyo_update_stat(const u8 index)\n{\n\t/*\n\t * I don't use atomic operations because race condition is not fatal.\n\t */\n\ttomoyo_stat_updated[index]++;\n\ttomoyo_stat_modified[index] = ktime_get_real_seconds();\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_write_log",
          "args": [
            "&r",
            "\"use_group %u\\n\"",
            "entry->group"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_write_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/audit.c",
          "lines": "412-422",
          "snippet": "void tomoyo_write_log(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint len;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_write_log(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint len;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_init_request_info",
          "args": [
            "&r",
            "entry",
            "TOMOYO_MAC_FILE_EXECUTE"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_init_request_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "984-997",
          "snippet": "int tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nint tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "e.domainname"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&entry->list",
            "&tomoyo_domain_list"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&entry->acl_info_list"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_commit_ok",
          "args": [
            "&e",
            "sizeof(e)"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_commit_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "73-83",
          "snippet": "void *tomoyo_commit_ok(void *data, const unsigned int size)\n{\n\tvoid *ptr = kzalloc(size, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tmemmove(ptr, data, size);\n\t\tmemset(data, 0, size);\n\t\treturn ptr;\n\t}\n\tkfree(ptr);\n\treturn NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nvoid *tomoyo_commit_ok(void *data, const unsigned int size)\n{\n\tvoid *ptr = kzalloc(size, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tmemmove(ptr, data, size);\n\t\tmemset(data, 0, size);\n\t\treturn ptr;\n\t}\n\tkfree(ptr);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_find_domain",
          "args": [
            "domainname"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_find_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "579-592",
          "snippet": "struct tomoyo_domain_info *tomoyo_find_domain(const char *domainname)\n{\n\tstruct tomoyo_domain_info *domain;\n\tstruct tomoyo_path_info name;\n\n\tname.name = domainname;\n\ttomoyo_fill_path_info(&name);\n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {\n\t\tif (!domain->is_deleted &&\n\t\t    !tomoyo_pathcmp(&name, domain->domainname))\n\t\t\treturn domain;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nstruct tomoyo_domain_info *tomoyo_find_domain(const char *domainname)\n{\n\tstruct tomoyo_domain_info *domain;\n\tstruct tomoyo_path_info name;\n\n\tname.name = domainname;\n\ttomoyo_fill_path_info(&name);\n\tlist_for_each_entry_rcu(domain, &tomoyo_domain_list, list) {\n\t\tif (!domain->is_deleted &&\n\t\t    !tomoyo_pathcmp(&name, domain->domainname))\n\t\t\treturn domain;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_name",
          "args": [
            "domainname"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "148-183",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_domain",
          "args": [],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1204-1207",
          "snippet": "static inline struct tomoyo_domain_info *tomoyo_domain(void)\n{\n\treturn current_cred()->security;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline struct tomoyo_domain_info *tomoyo_domain(void)\n{\n\treturn current_cred()->security;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_assign_namespace",
          "args": [
            "domainname"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_assign_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "448-480",
          "snippet": "struct tomoyo_policy_namespace *tomoyo_assign_namespace(const char *domainname)\n{\n\tstruct tomoyo_policy_namespace *ptr;\n\tstruct tomoyo_policy_namespace *entry;\n\tconst char *cp = domainname;\n\tunsigned int len = 0;\n\twhile (*cp && *cp++ != ' ')\n\t\tlen++;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (ptr)\n\t\treturn ptr;\n\tif (len >= TOMOYO_EXEC_TMPSIZE - 10 || !tomoyo_domain_def(domainname))\n\t\treturn NULL;\n\tentry = kzalloc(sizeof(*entry) + len + 1, GFP_NOFS);\n\tif (!entry)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (!ptr && tomoyo_memory_ok(entry)) {\n\t\tchar *name = (char *) (entry + 1);\n\t\tptr = entry;\n\t\tmemmove(name, domainname, len);\n\t\tname[len] = '\\0';\n\t\tentry->name = name;\n\t\ttomoyo_init_policy_namespace(entry);\n\t\tentry = NULL;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\tkfree(entry);\n\treturn ptr;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstruct tomoyo_policy_namespace *tomoyo_assign_namespace(const char *domainname)\n{\n\tstruct tomoyo_policy_namespace *ptr;\n\tstruct tomoyo_policy_namespace *entry;\n\tconst char *cp = domainname;\n\tunsigned int len = 0;\n\twhile (*cp && *cp++ != ' ')\n\t\tlen++;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (ptr)\n\t\treturn ptr;\n\tif (len >= TOMOYO_EXEC_TMPSIZE - 10 || !tomoyo_domain_def(domainname))\n\t\treturn NULL;\n\tentry = kzalloc(sizeof(*entry) + len + 1, GFP_NOFS);\n\tif (!entry)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (!ptr && tomoyo_memory_ok(entry)) {\n\t\tchar *name = (char *) (entry + 1);\n\t\tptr = entry;\n\t\tmemmove(name, domainname, len);\n\t\tname[len] = '\\0';\n\t\tentry->name = name;\n\t\ttomoyo_init_policy_namespace(entry);\n\t\tentry = NULL;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\tkfree(entry);\n\treturn ptr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_namespace_jump",
          "args": [
            "domainname"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_namespace_jump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "489-495",
          "snippet": "static bool tomoyo_namespace_jump(const char *domainname)\n{\n\tconst char *namespace = tomoyo_current_namespace()->name;\n\tconst int len = strlen(namespace);\n\treturn strncmp(domainname, namespace, len) ||\n\t\t(domainname[len] && domainname[len] != ' ');\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic bool tomoyo_namespace_jump(const char *domainname)\n{\n\tconst char *namespace = tomoyo_current_namespace()->name;\n\tconst int len = strlen(namespace);\n\treturn strncmp(domainname, namespace, len) ||\n\t\t(domainname[len] && domainname[len] != ' ');\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_domain",
          "args": [
            "domainname"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "527-544",
          "snippet": "bool tomoyo_correct_domain(const unsigned char *domainname)\n{\n\tif (!domainname || !tomoyo_domain_def(domainname))\n\t\treturn false;\n\tdomainname = strchr(domainname, ' ');\n\tif (!domainname++)\n\t\treturn true;\n\twhile (1) {\n\t\tconst unsigned char *cp = strchr(domainname, ' ');\n\t\tif (!cp)\n\t\t\tbreak;\n\t\tif (*domainname != '/' ||\n\t\t    !tomoyo_correct_word2(domainname, cp - domainname))\n\t\t\treturn false;\n\t\tdomainname = cp + 1;\n\t}\n\treturn tomoyo_correct_path(domainname);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_domain(const unsigned char *domainname)\n{\n\tif (!domainname || !tomoyo_domain_def(domainname))\n\t\treturn false;\n\tdomainname = strchr(domainname, ' ');\n\tif (!domainname++)\n\t\treturn true;\n\twhile (1) {\n\t\tconst unsigned char *cp = strchr(domainname, ' ');\n\t\tif (!cp)\n\t\t\tbreak;\n\t\tif (*domainname != '/' ||\n\t\t    !tomoyo_correct_word2(domainname, cp - domainname))\n\t\t\treturn false;\n\t\tdomainname = cp + 1;\n\t}\n\treturn tomoyo_correct_path(domainname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "domainname"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstruct tomoyo_domain_info *tomoyo_assign_domain(const char *domainname,\n\t\t\t\t\t\tconst bool transit)\n{\n\tstruct tomoyo_domain_info e = { };\n\tstruct tomoyo_domain_info *entry = tomoyo_find_domain(domainname);\n\tbool created = false;\n\tif (entry) {\n\t\tif (transit) {\n\t\t\t/*\n\t\t\t * Since namespace is created at runtime, profiles may\n\t\t\t * not be created by the moment the process transits to\n\t\t\t * that domain. Do not perform domain transition if\n\t\t\t * profile for that domain is not yet created.\n\t\t\t */\n\t\t\tif (tomoyo_policy_loaded &&\n\t\t\t    !entry->ns->profile_ptr[entry->profile])\n\t\t\t\treturn NULL;\n\t\t}\n\t\treturn entry;\n\t}\n\t/* Requested domain does not exist. */\n\t/* Don't create requested domain if domainname is invalid. */\n\tif (strlen(domainname) >= TOMOYO_EXEC_TMPSIZE - 10 ||\n\t    !tomoyo_correct_domain(domainname))\n\t\treturn NULL;\n\t/*\n\t * Since definition of profiles and acl_groups may differ across\n\t * namespaces, do not inherit \"use_profile\" and \"use_group\" settings\n\t * by automatically creating requested domain upon domain transition.\n\t */\n\tif (transit && tomoyo_namespace_jump(domainname))\n\t\treturn NULL;\n\te.ns = tomoyo_assign_namespace(domainname);\n\tif (!e.ns)\n\t\treturn NULL;\n\t/*\n\t * \"use_profile\" and \"use_group\" settings for automatically created\n\t * domains are inherited from current domain. These are 0 for manually\n\t * created domains.\n\t */\n\tif (transit) {\n\t\tconst struct tomoyo_domain_info *domain = tomoyo_domain();\n\t\te.profile = domain->profile;\n\t\te.group = domain->group;\n\t}\n\te.domainname = tomoyo_get_name(domainname);\n\tif (!e.domainname)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tentry = tomoyo_find_domain(domainname);\n\tif (!entry) {\n\t\tentry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->acl_info_list);\n\t\t\tlist_add_tail_rcu(&entry->list, &tomoyo_domain_list);\n\t\t\tcreated = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.domainname);\n\tif (entry && transit) {\n\t\tif (created) {\n\t\t\tstruct tomoyo_request_info r;\n\t\t\ttomoyo_init_request_info(&r, entry,\n\t\t\t\t\t\t TOMOYO_MAC_FILE_EXECUTE);\n\t\t\tr.granted = false;\n\t\t\ttomoyo_write_log(&r, \"use_profile %u\\n\",\n\t\t\t\t\t entry->profile);\n\t\t\ttomoyo_write_log(&r, \"use_group %u\\n\", entry->group);\n\t\t\ttomoyo_update_stat(TOMOYO_STAT_POLICY_UPDATES);\n\t\t}\n\t}\n\treturn entry;\n}"
  },
  {
    "function_name": "tomoyo_namespace_jump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "489-495",
    "snippet": "static bool tomoyo_namespace_jump(const char *domainname)\n{\n\tconst char *namespace = tomoyo_current_namespace()->name;\n\tconst int len = strlen(namespace);\n\treturn strncmp(domainname, namespace, len) ||\n\t\t(domainname[len] && domainname[len] != ' ');\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "domainname",
            "namespace",
            "len"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "namespace"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_current_namespace",
          "args": [],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_current_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1272-1275",
          "snippet": "static inline struct tomoyo_policy_namespace *tomoyo_current_namespace(void)\n{\n\treturn tomoyo_domain()->ns;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline struct tomoyo_policy_namespace *tomoyo_current_namespace(void)\n{\n\treturn tomoyo_domain()->ns;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic bool tomoyo_namespace_jump(const char *domainname)\n{\n\tconst char *namespace = tomoyo_current_namespace()->name;\n\tconst int len = strlen(namespace);\n\treturn strncmp(domainname, namespace, len) ||\n\t\t(domainname[len] && domainname[len] != ' ');\n}"
  },
  {
    "function_name": "tomoyo_assign_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "448-480",
    "snippet": "struct tomoyo_policy_namespace *tomoyo_assign_namespace(const char *domainname)\n{\n\tstruct tomoyo_policy_namespace *ptr;\n\tstruct tomoyo_policy_namespace *entry;\n\tconst char *cp = domainname;\n\tunsigned int len = 0;\n\twhile (*cp && *cp++ != ' ')\n\t\tlen++;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (ptr)\n\t\treturn ptr;\n\tif (len >= TOMOYO_EXEC_TMPSIZE - 10 || !tomoyo_domain_def(domainname))\n\t\treturn NULL;\n\tentry = kzalloc(sizeof(*entry) + len + 1, GFP_NOFS);\n\tif (!entry)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (!ptr && tomoyo_memory_ok(entry)) {\n\t\tchar *name = (char *) (entry + 1);\n\t\tptr = entry;\n\t\tmemmove(name, domainname, len);\n\t\tname[len] = '\\0';\n\t\tentry->name = name;\n\t\ttomoyo_init_policy_namespace(entry);\n\t\tentry = NULL;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\tkfree(entry);\n\treturn ptr;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "entry"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_init_policy_namespace",
          "args": [
            "entry"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_init_policy_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "344-356",
          "snippet": "void tomoyo_init_policy_namespace(struct tomoyo_policy_namespace *ns)\n{\n\tunsigned int idx;\n\tfor (idx = 0; idx < TOMOYO_MAX_ACL_GROUPS; idx++)\n\t\tINIT_LIST_HEAD(&ns->acl_group[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_GROUP; idx++)\n\t\tINIT_LIST_HEAD(&ns->group_list[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_POLICY; idx++)\n\t\tINIT_LIST_HEAD(&ns->policy_list[idx]);\n\tns->profile_version = 20110903;\n\ttomoyo_namespace_enabled = !list_empty(&tomoyo_namespace_list);\n\tlist_add_tail_rcu(&ns->namespace_list, &tomoyo_namespace_list);\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool tomoyo_namespace_enabled;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic bool tomoyo_namespace_enabled;\n\nvoid tomoyo_init_policy_namespace(struct tomoyo_policy_namespace *ns)\n{\n\tunsigned int idx;\n\tfor (idx = 0; idx < TOMOYO_MAX_ACL_GROUPS; idx++)\n\t\tINIT_LIST_HEAD(&ns->acl_group[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_GROUP; idx++)\n\t\tINIT_LIST_HEAD(&ns->group_list[idx]);\n\tfor (idx = 0; idx < TOMOYO_MAX_POLICY; idx++)\n\t\tINIT_LIST_HEAD(&ns->policy_list[idx]);\n\tns->profile_version = 20110903;\n\ttomoyo_namespace_enabled = !list_empty(&tomoyo_namespace_list);\n\tlist_add_tail_rcu(&ns->namespace_list, &tomoyo_namespace_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "name",
            "domainname",
            "len"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_memory_ok",
          "args": [
            "entry"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_memory_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "47-60",
          "snippet": "bool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];",
            "unsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nunsigned int tomoyo_memory_used[TOMOYO_MAX_MEMORY_STAT];\nunsigned int tomoyo_memory_quota[TOMOYO_MAX_MEMORY_STAT];\n\nbool tomoyo_memory_ok(void *ptr)\n{\n\tif (ptr) {\n\t\tconst size_t s = ksize(ptr);\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] += s;\n\t\tif (!tomoyo_memory_quota[TOMOYO_MEMORY_POLICY] ||\n\t\t    tomoyo_memory_used[TOMOYO_MEMORY_POLICY] <=\n\t\t    tomoyo_memory_quota[TOMOYO_MEMORY_POLICY])\n\t\t\treturn true;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= s;\n\t}\n\ttomoyo_warn_oom(__func__);\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_find_namespace",
          "args": [
            "domainname",
            "len"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_find_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "425-436",
          "snippet": "static struct tomoyo_policy_namespace *tomoyo_find_namespace\n(const char *name, const unsigned int len)\n{\n\tstruct tomoyo_policy_namespace *ns;\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tif (strncmp(name, ns->name, len) ||\n\t\t    (name[len] && name[len] != ' '))\n\t\t\tcontinue;\n\t\treturn ns;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic struct tomoyo_policy_namespace *tomoyo_find_namespace\n(const char *name, const unsigned int len)\n{\n\tstruct tomoyo_policy_namespace *ns;\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tif (strncmp(name, ns->name, len) ||\n\t\t    (name[len] && name[len] != ' '))\n\t\t\tcontinue;\n\t\treturn ns;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*entry) + len + 1",
            "GFP_NOFS"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_domain_def",
          "args": [
            "domainname"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_domain_def",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "553-568",
          "snippet": "bool tomoyo_domain_def(const unsigned char *buffer)\n{\n\tconst unsigned char *cp;\n\tint len;\n\tif (*buffer != '<')\n\t\treturn false;\n\tcp = strchr(buffer, ' ');\n\tif (!cp)\n\t\tlen = strlen(buffer);\n\telse\n\t\tlen = cp - buffer;\n\tif (buffer[len - 1] != '>' ||\n\t    !tomoyo_correct_word2(buffer + 1, len - 2))\n\t\treturn false;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_domain_def(const unsigned char *buffer)\n{\n\tconst unsigned char *cp;\n\tint len;\n\tif (*buffer != '<')\n\t\treturn false;\n\tcp = strchr(buffer, ' ');\n\tif (!cp)\n\t\tlen = strlen(buffer);\n\telse\n\t\tlen = cp - buffer;\n\tif (buffer[len - 1] != '>' ||\n\t    !tomoyo_correct_word2(buffer + 1, len - 2))\n\t\treturn false;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstruct tomoyo_policy_namespace *tomoyo_assign_namespace(const char *domainname)\n{\n\tstruct tomoyo_policy_namespace *ptr;\n\tstruct tomoyo_policy_namespace *entry;\n\tconst char *cp = domainname;\n\tunsigned int len = 0;\n\twhile (*cp && *cp++ != ' ')\n\t\tlen++;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (ptr)\n\t\treturn ptr;\n\tif (len >= TOMOYO_EXEC_TMPSIZE - 10 || !tomoyo_domain_def(domainname))\n\t\treturn NULL;\n\tentry = kzalloc(sizeof(*entry) + len + 1, GFP_NOFS);\n\tif (!entry)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tptr = tomoyo_find_namespace(domainname, len);\n\tif (!ptr && tomoyo_memory_ok(entry)) {\n\t\tchar *name = (char *) (entry + 1);\n\t\tptr = entry;\n\t\tmemmove(name, domainname, len);\n\t\tname[len] = '\\0';\n\t\tentry->name = name;\n\t\ttomoyo_init_policy_namespace(entry);\n\t\tentry = NULL;\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\tkfree(entry);\n\treturn ptr;\n}"
  },
  {
    "function_name": "tomoyo_find_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "425-436",
    "snippet": "static struct tomoyo_policy_namespace *tomoyo_find_namespace\n(const char *name, const unsigned int len)\n{\n\tstruct tomoyo_policy_namespace *ns;\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tif (strncmp(name, ns->name, len) ||\n\t\t    (name[len] && name[len] != ' '))\n\t\t\tcontinue;\n\t\treturn ns;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "name",
            "ns->name",
            "len"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ns",
            "&tomoyo_namespace_list",
            "namespace_list"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic struct tomoyo_policy_namespace *tomoyo_find_namespace\n(const char *name, const unsigned int len)\n{\n\tstruct tomoyo_policy_namespace *ns;\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tif (strncmp(name, ns->name, len) ||\n\t\t    (name[len] && name[len] != ' '))\n\t\t\tcontinue;\n\t\treturn ns;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "tomoyo_write_aggregator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "391-412",
    "snippet": "int tomoyo_write_aggregator(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_aggregator e = { };\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tconst char *original_name = tomoyo_read_token(param);\n\tconst char *aggregated_name = tomoyo_read_token(param);\n\tif (!tomoyo_correct_word(original_name) ||\n\t    !tomoyo_correct_path(aggregated_name))\n\t\treturn -EINVAL;\n\te.original_name = tomoyo_get_name(original_name);\n\te.aggregated_name = tomoyo_get_name(aggregated_name);\n\tif (!e.original_name || !e.aggregated_name ||\n\t    e.aggregated_name->is_patterned) /* No patterns allowed. */\n\t\tgoto out;\n\tparam->list = &param->ns->policy_list[TOMOYO_ID_AGGREGATOR];\n\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_aggregator);\nout:\n\ttomoyo_put_name(e.original_name);\n\ttomoyo_put_name(e.aggregated_name);\n\treturn error;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "e.aggregated_name"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_update_policy",
          "args": [
            "&e.head",
            "sizeof(e)",
            "param",
            "tomoyo_same_aggregator"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "31-62",
          "snippet": "int tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_head\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_head\n\t\t\t\t\t\t  *))\n{\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_head *entry;\n\tstruct list_head *list = param->list;\n\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -ENOMEM;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tentry->is_deleted = param->is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !param->is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_head\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_head\n\t\t\t\t\t\t  *))\n{\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_head *entry;\n\tstruct list_head *list = param->list;\n\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -ENOMEM;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tentry->is_deleted = param->is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !param->is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_get_name",
          "args": [
            "aggregated_name"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "148-183",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_path",
          "args": [
            "aggregated_name"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "515-518",
          "snippet": "bool tomoyo_correct_path(const char *filename)\n{\n\treturn *filename == '/' && tomoyo_correct_word(filename);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_path(const char *filename)\n{\n\treturn *filename == '/' && tomoyo_correct_word(filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_word",
          "args": [
            "original_name"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_word",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "502-505",
          "snippet": "bool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_word(const char *string)\n{\n\treturn tomoyo_correct_word2(string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_token",
          "args": [
            "param"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "131-141",
          "snippet": "char *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nchar *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_write_aggregator(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_aggregator e = { };\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tconst char *original_name = tomoyo_read_token(param);\n\tconst char *aggregated_name = tomoyo_read_token(param);\n\tif (!tomoyo_correct_word(original_name) ||\n\t    !tomoyo_correct_path(aggregated_name))\n\t\treturn -EINVAL;\n\te.original_name = tomoyo_get_name(original_name);\n\te.aggregated_name = tomoyo_get_name(aggregated_name);\n\tif (!e.original_name || !e.aggregated_name ||\n\t    e.aggregated_name->is_patterned) /* No patterns allowed. */\n\t\tgoto out;\n\tparam->list = &param->ns->policy_list[TOMOYO_ID_AGGREGATOR];\n\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_aggregator);\nout:\n\ttomoyo_put_name(e.original_name);\n\ttomoyo_put_name(e.aggregated_name);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_same_aggregator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "371-380",
    "snippet": "static bool tomoyo_same_aggregator(const struct tomoyo_acl_head *a,\n\t\t\t\t   const struct tomoyo_acl_head *b)\n{\n\tconst struct tomoyo_aggregator *p1 = container_of(a, typeof(*p1),\n\t\t\t\t\t\t\t  head);\n\tconst struct tomoyo_aggregator *p2 = container_of(b, typeof(*p2),\n\t\t\t\t\t\t\t  head);\n\treturn p1->original_name == p2->original_name &&\n\t\tp1->aggregated_name == p2->aggregated_name;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "typeof(*p2)",
            "head"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p2"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "typeof(*p1)",
            "head"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p1"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic bool tomoyo_same_aggregator(const struct tomoyo_acl_head *a,\n\t\t\t\t   const struct tomoyo_acl_head *b)\n{\n\tconst struct tomoyo_aggregator *p1 = container_of(a, typeof(*p1),\n\t\t\t\t\t\t\t  head);\n\tconst struct tomoyo_aggregator *p2 = container_of(b, typeof(*p2),\n\t\t\t\t\t\t\t  head);\n\treturn p1->original_name == p2->original_name &&\n\t\tp1->aggregated_name == p2->aggregated_name;\n}"
  },
  {
    "function_name": "tomoyo_transition_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "334-361",
    "snippet": "static enum tomoyo_transition_type tomoyo_transition_type\n(const struct tomoyo_policy_namespace *ns,\n const struct tomoyo_path_info *domainname,\n const struct tomoyo_path_info *program)\n{\n\tconst char *last_name = tomoyo_last_word(domainname->name);\n\tenum tomoyo_transition_type type = TOMOYO_TRANSITION_CONTROL_NO_RESET;\n\twhile (type < TOMOYO_MAX_TRANSITION_TYPE) {\n\t\tconst struct list_head * const list =\n\t\t\t&ns->policy_list[TOMOYO_ID_TRANSITION_CONTROL];\n\t\tif (!tomoyo_scan_transition(list, domainname, program,\n\t\t\t\t\t    last_name, type)) {\n\t\t\ttype++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (type != TOMOYO_TRANSITION_CONTROL_NO_RESET &&\n\t\t    type != TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE)\n\t\t\tbreak;\n\t\t/*\n\t\t * Do not check for reset_domain if no_reset_domain matched.\n\t\t * Do not check for initialize_domain if no_initialize_domain\n\t\t * matched.\n\t\t */\n\t\ttype++;\n\t\ttype++;\n\t}\n\treturn type;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_scan_transition",
          "args": [
            "list",
            "domainname",
            "program",
            "last_name",
            "type"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_scan_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "290-317",
          "snippet": "static inline bool tomoyo_scan_transition\n(const struct list_head *list, const struct tomoyo_path_info *domainname,\n const struct tomoyo_path_info *program, const char *last_name,\n const enum tomoyo_transition_type type)\n{\n\tconst struct tomoyo_transition_control *ptr;\n\tlist_for_each_entry_rcu(ptr, list, head.list) {\n\t\tif (ptr->head.is_deleted || ptr->type != type)\n\t\t\tcontinue;\n\t\tif (ptr->domainname) {\n\t\t\tif (!ptr->is_last_name) {\n\t\t\t\tif (ptr->domainname != domainname)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Use direct strcmp() since this is\n\t\t\t\t * unlikely used.\n\t\t\t\t */\n\t\t\t\tif (strcmp(ptr->domainname->name, last_name))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ptr->program && tomoyo_pathcmp(ptr->program, program))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic inline bool tomoyo_scan_transition\n(const struct list_head *list, const struct tomoyo_path_info *domainname,\n const struct tomoyo_path_info *program, const char *last_name,\n const enum tomoyo_transition_type type)\n{\n\tconst struct tomoyo_transition_control *ptr;\n\tlist_for_each_entry_rcu(ptr, list, head.list) {\n\t\tif (ptr->head.is_deleted || ptr->type != type)\n\t\t\tcontinue;\n\t\tif (ptr->domainname) {\n\t\t\tif (!ptr->is_last_name) {\n\t\t\t\tif (ptr->domainname != domainname)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Use direct strcmp() since this is\n\t\t\t\t * unlikely used.\n\t\t\t\t */\n\t\t\t\tif (strcmp(ptr->domainname->name, last_name))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ptr->program && tomoyo_pathcmp(ptr->program, program))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_last_word",
          "args": [
            "domainname->name"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_last_word",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "198-204",
          "snippet": "static const char *tomoyo_last_word(const char *name)\n{\n\tconst char *cp = strrchr(name, ' ');\n\tif (cp)\n\t\treturn cp + 1;\n\treturn name;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic const char *tomoyo_last_word(const char *name)\n{\n\tconst char *cp = strrchr(name, ' ');\n\tif (cp)\n\t\treturn cp + 1;\n\treturn name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic enum tomoyo_transition_type tomoyo_transition_type\n(const struct tomoyo_policy_namespace *ns,\n const struct tomoyo_path_info *domainname,\n const struct tomoyo_path_info *program)\n{\n\tconst char *last_name = tomoyo_last_word(domainname->name);\n\tenum tomoyo_transition_type type = TOMOYO_TRANSITION_CONTROL_NO_RESET;\n\twhile (type < TOMOYO_MAX_TRANSITION_TYPE) {\n\t\tconst struct list_head * const list =\n\t\t\t&ns->policy_list[TOMOYO_ID_TRANSITION_CONTROL];\n\t\tif (!tomoyo_scan_transition(list, domainname, program,\n\t\t\t\t\t    last_name, type)) {\n\t\t\ttype++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (type != TOMOYO_TRANSITION_CONTROL_NO_RESET &&\n\t\t    type != TOMOYO_TRANSITION_CONTROL_NO_INITIALIZE)\n\t\t\tbreak;\n\t\t/*\n\t\t * Do not check for reset_domain if no_reset_domain matched.\n\t\t * Do not check for initialize_domain if no_initialize_domain\n\t\t * matched.\n\t\t */\n\t\ttype++;\n\t\ttype++;\n\t}\n\treturn type;\n}"
  },
  {
    "function_name": "tomoyo_scan_transition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "290-317",
    "snippet": "static inline bool tomoyo_scan_transition\n(const struct list_head *list, const struct tomoyo_path_info *domainname,\n const struct tomoyo_path_info *program, const char *last_name,\n const enum tomoyo_transition_type type)\n{\n\tconst struct tomoyo_transition_control *ptr;\n\tlist_for_each_entry_rcu(ptr, list, head.list) {\n\t\tif (ptr->head.is_deleted || ptr->type != type)\n\t\t\tcontinue;\n\t\tif (ptr->domainname) {\n\t\t\tif (!ptr->is_last_name) {\n\t\t\t\tif (ptr->domainname != domainname)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Use direct strcmp() since this is\n\t\t\t\t * unlikely used.\n\t\t\t\t */\n\t\t\t\tif (strcmp(ptr->domainname->name, last_name))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ptr->program && tomoyo_pathcmp(ptr->program, program))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_pathcmp",
          "args": [
            "ptr->program",
            "program"
          ],
          "line": 312
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_pathcmp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1151-1155",
          "snippet": "static inline bool tomoyo_pathcmp(const struct tomoyo_path_info *a,\n\t\t\t\t  const struct tomoyo_path_info *b)\n{\n\treturn a->hash != b->hash || strcmp(a->name, b->name);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline bool tomoyo_pathcmp(const struct tomoyo_path_info *a,\n\t\t\t\t  const struct tomoyo_path_info *b)\n{\n\treturn a->hash != b->hash || strcmp(a->name, b->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "ptr->domainname->name",
            "last_name"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "ptr",
            "list",
            "head.list"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic inline bool tomoyo_scan_transition\n(const struct list_head *list, const struct tomoyo_path_info *domainname,\n const struct tomoyo_path_info *program, const char *last_name,\n const enum tomoyo_transition_type type)\n{\n\tconst struct tomoyo_transition_control *ptr;\n\tlist_for_each_entry_rcu(ptr, list, head.list) {\n\t\tif (ptr->head.is_deleted || ptr->type != type)\n\t\t\tcontinue;\n\t\tif (ptr->domainname) {\n\t\t\tif (!ptr->is_last_name) {\n\t\t\t\tif (ptr->domainname != domainname)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * Use direct strcmp() since this is\n\t\t\t\t * unlikely used.\n\t\t\t\t */\n\t\t\t\tif (strcmp(ptr->domainname->name, last_name))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (ptr->program && tomoyo_pathcmp(ptr->program, program))\n\t\t\tcontinue;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "tomoyo_write_transition_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "236-275",
    "snippet": "int tomoyo_write_transition_control(struct tomoyo_acl_param *param,\n\t\t\t\t    const u8 type)\n{\n\tstruct tomoyo_transition_control e = { .type = type };\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tchar *program = param->data;\n\tchar *domainname = strstr(program, \" from \");\n\tif (domainname) {\n\t\t*domainname = '\\0';\n\t\tdomainname += 6;\n\t} else if (type == TOMOYO_TRANSITION_CONTROL_NO_KEEP ||\n\t\t   type == TOMOYO_TRANSITION_CONTROL_KEEP) {\n\t\tdomainname = program;\n\t\tprogram = NULL;\n\t}\n\tif (program && strcmp(program, \"any\")) {\n\t\tif (!tomoyo_correct_path(program))\n\t\t\treturn -EINVAL;\n\t\te.program = tomoyo_get_name(program);\n\t\tif (!e.program)\n\t\t\tgoto out;\n\t}\n\tif (domainname && strcmp(domainname, \"any\")) {\n\t\tif (!tomoyo_correct_domain(domainname)) {\n\t\t\tif (!tomoyo_correct_path(domainname))\n\t\t\t\tgoto out;\n\t\t\te.is_last_name = true;\n\t\t}\n\t\te.domainname = tomoyo_get_name(domainname);\n\t\tif (!e.domainname)\n\t\t\tgoto out;\n\t}\n\tparam->list = &param->ns->policy_list[TOMOYO_ID_TRANSITION_CONTROL];\n\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_transition_control);\nout:\n\ttomoyo_put_name(e.domainname);\n\ttomoyo_put_name(e.program);\n\treturn error;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "e.program"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_update_policy",
          "args": [
            "&e.head",
            "sizeof(e)",
            "param",
            "tomoyo_same_transition_control"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "31-62",
          "snippet": "int tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_head\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_head\n\t\t\t\t\t\t  *))\n{\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_head *entry;\n\tstruct list_head *list = param->list;\n\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -ENOMEM;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tentry->is_deleted = param->is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !param->is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_head\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_head\n\t\t\t\t\t\t  *))\n{\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_head *entry;\n\tstruct list_head *list = param->list;\n\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -ENOMEM;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tentry->is_deleted = param->is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !param->is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_get_name",
          "args": [
            "domainname"
          ],
          "line": 264
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "148-183",
          "snippet": "const struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\n\nconst struct tomoyo_path_info *tomoyo_get_name(const char *name)\n{\n\tstruct tomoyo_name *ptr;\n\tunsigned int hash;\n\tint len;\n\tstruct list_head *head;\n\n\tif (!name)\n\t\treturn NULL;\n\tlen = strlen(name) + 1;\n\thash = full_name_hash(NULL, (const unsigned char *) name, len - 1);\n\thead = &tomoyo_name_list[hash_long(hash, TOMOYO_HASH_BITS)];\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn NULL;\n\tlist_for_each_entry(ptr, head, head.list) {\n\t\tif (hash != ptr->entry.hash || strcmp(name, ptr->entry.name) ||\n\t\t    atomic_read(&ptr->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&ptr->head.users);\n\t\tgoto out;\n\t}\n\tptr = kzalloc(sizeof(*ptr) + len, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tptr->entry.name = ((char *) ptr) + sizeof(*ptr);\n\t\tmemmove((char *) ptr->entry.name, name, len);\n\t\tatomic_set(&ptr->head.users, 1);\n\t\ttomoyo_fill_path_info(&ptr->entry);\n\t\tlist_add_tail(&ptr->head.list, head);\n\t} else {\n\t\tkfree(ptr);\n\t\tptr = NULL;\n\t}\nout:\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn ptr ? &ptr->entry : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_path",
          "args": [
            "domainname"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "515-518",
          "snippet": "bool tomoyo_correct_path(const char *filename)\n{\n\treturn *filename == '/' && tomoyo_correct_word(filename);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_path(const char *filename)\n{\n\treturn *filename == '/' && tomoyo_correct_word(filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_correct_domain",
          "args": [
            "domainname"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_correct_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "527-544",
          "snippet": "bool tomoyo_correct_domain(const unsigned char *domainname)\n{\n\tif (!domainname || !tomoyo_domain_def(domainname))\n\t\treturn false;\n\tdomainname = strchr(domainname, ' ');\n\tif (!domainname++)\n\t\treturn true;\n\twhile (1) {\n\t\tconst unsigned char *cp = strchr(domainname, ' ');\n\t\tif (!cp)\n\t\t\tbreak;\n\t\tif (*domainname != '/' ||\n\t\t    !tomoyo_correct_word2(domainname, cp - domainname))\n\t\t\treturn false;\n\t\tdomainname = cp + 1;\n\t}\n\treturn tomoyo_correct_path(domainname);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_correct_domain(const unsigned char *domainname)\n{\n\tif (!domainname || !tomoyo_domain_def(domainname))\n\t\treturn false;\n\tdomainname = strchr(domainname, ' ');\n\tif (!domainname++)\n\t\treturn true;\n\twhile (1) {\n\t\tconst unsigned char *cp = strchr(domainname, ' ');\n\t\tif (!cp)\n\t\t\tbreak;\n\t\tif (*domainname != '/' ||\n\t\t    !tomoyo_correct_word2(domainname, cp - domainname))\n\t\t\treturn false;\n\t\tdomainname = cp + 1;\n\t}\n\treturn tomoyo_correct_path(domainname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "domainname",
            "\"any\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "program",
            "\"any\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "program",
            "\" from \""
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_write_transition_control(struct tomoyo_acl_param *param,\n\t\t\t\t    const u8 type)\n{\n\tstruct tomoyo_transition_control e = { .type = type };\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tchar *program = param->data;\n\tchar *domainname = strstr(program, \" from \");\n\tif (domainname) {\n\t\t*domainname = '\\0';\n\t\tdomainname += 6;\n\t} else if (type == TOMOYO_TRANSITION_CONTROL_NO_KEEP ||\n\t\t   type == TOMOYO_TRANSITION_CONTROL_KEEP) {\n\t\tdomainname = program;\n\t\tprogram = NULL;\n\t}\n\tif (program && strcmp(program, \"any\")) {\n\t\tif (!tomoyo_correct_path(program))\n\t\t\treturn -EINVAL;\n\t\te.program = tomoyo_get_name(program);\n\t\tif (!e.program)\n\t\t\tgoto out;\n\t}\n\tif (domainname && strcmp(domainname, \"any\")) {\n\t\tif (!tomoyo_correct_domain(domainname)) {\n\t\t\tif (!tomoyo_correct_path(domainname))\n\t\t\t\tgoto out;\n\t\t\te.is_last_name = true;\n\t\t}\n\t\te.domainname = tomoyo_get_name(domainname);\n\t\tif (!e.domainname)\n\t\t\tgoto out;\n\t}\n\tparam->list = &param->ns->policy_list[TOMOYO_ID_TRANSITION_CONTROL];\n\terror = tomoyo_update_policy(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_transition_control);\nout:\n\ttomoyo_put_name(e.domainname);\n\ttomoyo_put_name(e.program);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_same_transition_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "214-226",
    "snippet": "static bool tomoyo_same_transition_control(const struct tomoyo_acl_head *a,\n\t\t\t\t\t   const struct tomoyo_acl_head *b)\n{\n\tconst struct tomoyo_transition_control *p1 = container_of(a,\n\t\t\t\t\t\t\t\t  typeof(*p1),\n\t\t\t\t\t\t\t\t  head);\n\tconst struct tomoyo_transition_control *p2 = container_of(b,\n\t\t\t\t\t\t\t\t  typeof(*p2),\n\t\t\t\t\t\t\t\t  head);\n\treturn p1->type == p2->type && p1->is_last_name == p2->is_last_name\n\t\t&& p1->domainname == p2->domainname\n\t\t&& p1->program == p2->program;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "typeof(*p2)",
            "head"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p2"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "typeof(*p1)",
            "head"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p1"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic bool tomoyo_same_transition_control(const struct tomoyo_acl_head *a,\n\t\t\t\t\t   const struct tomoyo_acl_head *b)\n{\n\tconst struct tomoyo_transition_control *p1 = container_of(a,\n\t\t\t\t\t\t\t\t  typeof(*p1),\n\t\t\t\t\t\t\t\t  head);\n\tconst struct tomoyo_transition_control *p2 = container_of(b,\n\t\t\t\t\t\t\t\t  typeof(*p2),\n\t\t\t\t\t\t\t\t  head);\n\treturn p1->type == p2->type && p1->is_last_name == p2->is_last_name\n\t\t&& p1->domainname == p2->domainname\n\t\t&& p1->program == p2->program;\n}"
  },
  {
    "function_name": "tomoyo_last_word",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "198-204",
    "snippet": "static const char *tomoyo_last_word(const char *name)\n{\n\tconst char *cp = strrchr(name, ' ');\n\tif (cp)\n\t\treturn cp + 1;\n\treturn name;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "name",
            "' '"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic const char *tomoyo_last_word(const char *name)\n{\n\tconst char *cp = strrchr(name, ' ');\n\tif (cp)\n\t\treturn cp + 1;\n\treturn name;\n}"
  },
  {
    "function_name": "tomoyo_check_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "159-186",
    "snippet": "void tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tbool retried = false;\n\tconst struct list_head *list = &domain->acl_info_list;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tif (!retried) {\n\t\tretried = true;\n\t\tlist = &domain->ns->acl_group[domain->group];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_condition",
          "args": [
            "r",
            "ptr->cond"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_condition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "745-1095",
          "snippet": "bool tomoyo_condition(struct tomoyo_request_info *r,\n\t\t      const struct tomoyo_condition *cond)\n{\n\tu32 i;\n\tunsigned long min_v[2] = { 0, 0 };\n\tunsigned long max_v[2] = { 0, 0 };\n\tconst struct tomoyo_condition_element *condp;\n\tconst struct tomoyo_number_union *numbers_p;\n\tconst struct tomoyo_name_union *names_p;\n\tconst struct tomoyo_argv *argv;\n\tconst struct tomoyo_envp *envp;\n\tstruct tomoyo_obj_info *obj;\n\tu16 condc;\n\tu16 argc;\n\tu16 envc;\n\tstruct linux_binprm *bprm = NULL;\n\tif (!cond)\n\t\treturn true;\n\tcondc = cond->condc;\n\targc = cond->argc;\n\tenvc = cond->envc;\n\tobj = r->obj;\n\tif (r->ee)\n\t\tbprm = r->ee->bprm;\n\tif (!bprm && (argc || envc))\n\t\treturn false;\n\tcondp = (struct tomoyo_condition_element *) (cond + 1);\n\tnumbers_p = (const struct tomoyo_number_union *) (condp + condc);\n\tnames_p = (const struct tomoyo_name_union *)\n\t\t(numbers_p + cond->numbers_count);\n\targv = (const struct tomoyo_argv *) (names_p + cond->names_count);\n\tenvp = (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < condc; i++) {\n\t\tconst bool match = condp->equals;\n\t\tconst u8 left = condp->left;\n\t\tconst u8 right = condp->right;\n\t\tbool is_bitop[2] = { false, false };\n\t\tu8 j;\n\t\tcondp++;\n\t\t/* Check argv[] and envp[] later. */\n\t\tif (left == TOMOYO_ARGV_ENTRY || left == TOMOYO_ENVP_ENTRY)\n\t\t\tcontinue;\n\t\t/* Check string expressions. */\n\t\tif (right == TOMOYO_NAME_UNION) {\n\t\t\tconst struct tomoyo_name_union *ptr = names_p++;\n\t\t\tswitch (left) {\n\t\t\t\tstruct tomoyo_path_info *symlink;\n\t\t\t\tstruct tomoyo_execve *ee;\n\t\t\t\tstruct file *file;\n\t\t\tcase TOMOYO_SYMLINK_TARGET:\n\t\t\t\tsymlink = obj ? obj->symlink_target : NULL;\n\t\t\t\tif (!symlink ||\n\t\t\t\t    !tomoyo_compare_name_union(symlink, ptr)\n\t\t\t\t    == match)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_REALPATH:\n\t\t\t\tee = r->ee;\n\t\t\t\tfile = ee ? ee->bprm->file : NULL;\n\t\t\t\tif (!tomoyo_scan_exec_realpath(file, ptr,\n\t\t\t\t\t\t\t       match))\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check numeric or bit-op expressions. */\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tconst u8 index = j ? right : left;\n\t\t\tunsigned long value = 0;\n\t\t\tswitch (index) {\n\t\t\tcase TOMOYO_TASK_UID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_uid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_EUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_euid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_SUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_suid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_FSUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_fsuid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_GID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_gid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_EGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_egid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_SGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_sgid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_FSGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_fsgid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_PID:\n\t\t\t\tvalue = tomoyo_sys_getpid();\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_PPID:\n\t\t\t\tvalue = tomoyo_sys_getppid();\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_SOCKET:\n\t\t\t\tvalue = S_IFSOCK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_SYMLINK:\n\t\t\t\tvalue = S_IFLNK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_FILE:\n\t\t\t\tvalue = S_IFREG;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_BLOCK_DEV:\n\t\t\t\tvalue = S_IFBLK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_DIRECTORY:\n\t\t\t\tvalue = S_IFDIR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_CHAR_DEV:\n\t\t\t\tvalue = S_IFCHR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_FIFO:\n\t\t\t\tvalue = S_IFIFO;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_SETUID:\n\t\t\t\tvalue = S_ISUID;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_SETGID:\n\t\t\t\tvalue = S_ISGID;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_STICKY:\n\t\t\t\tvalue = S_ISVTX;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_READ:\n\t\t\t\tvalue = S_IRUSR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_WRITE:\n\t\t\t\tvalue = S_IWUSR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_EXECUTE:\n\t\t\t\tvalue = S_IXUSR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_READ:\n\t\t\t\tvalue = S_IRGRP;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_WRITE:\n\t\t\t\tvalue = S_IWGRP;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_EXECUTE:\n\t\t\t\tvalue = S_IXGRP;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_READ:\n\t\t\t\tvalue = S_IROTH;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_WRITE:\n\t\t\t\tvalue = S_IWOTH;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_EXECUTE:\n\t\t\t\tvalue = S_IXOTH;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_ARGC:\n\t\t\t\tif (!bprm)\n\t\t\t\t\tgoto out;\n\t\t\t\tvalue = bprm->argc;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_ENVC:\n\t\t\t\tif (!bprm)\n\t\t\t\t\tgoto out;\n\t\t\t\tvalue = bprm->envc;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t/* Fetch values later. */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!obj)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (!obj->validate_done) {\n\t\t\t\t\ttomoyo_get_attributes(obj);\n\t\t\t\t\tobj->validate_done = true;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tu8 stat_index;\n\t\t\t\t\tstruct tomoyo_mini_stat *stat;\n\t\t\t\t\tswitch (index) {\n\t\t\t\t\tcase TOMOYO_PATH1_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH1_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH1_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\t\t\t\tstat_index = TOMOYO_PATH1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH2_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\t\t\t\tstat_index = TOMOYO_PATH2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\t\t\t\tstat_index =\n\t\t\t\t\t\t\tTOMOYO_PATH1_PARENT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\t\t\tstat_index =\n\t\t\t\t\t\t\tTOMOYO_PATH2_PARENT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (!obj->stat_valid[stat_index])\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tstat = &obj->stat[stat_index];\n\t\t\t\t\tswitch (index) {\n\t\t\t\t\tcase TOMOYO_PATH1_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_UID:\n\t\t\t\t\t\tvalue = from_kuid(&init_user_ns, stat->uid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_GID:\n\t\t\t\t\t\tvalue = from_kgid(&init_user_ns, stat->gid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_INO:\n\t\t\t\t\t\tvalue = stat->ino;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MAJOR:\n\t\t\t\t\t\tvalue = MAJOR(stat->dev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MINOR:\n\t\t\t\t\t\tvalue = MINOR(stat->dev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH2_TYPE:\n\t\t\t\t\t\tvalue = stat->mode & S_IFMT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MAJOR:\n\t\t\t\t\t\tvalue = MAJOR(stat->rdev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MINOR:\n\t\t\t\t\t\tvalue = MINOR(stat->rdev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\t\t\tvalue = stat->mode & S_IALLUGO;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmax_v[j] = value;\n\t\t\tmin_v[j] = value;\n\t\t\tswitch (index) {\n\t\t\tcase TOMOYO_MODE_SETUID:\n\t\t\tcase TOMOYO_MODE_SETGID:\n\t\t\tcase TOMOYO_MODE_STICKY:\n\t\t\tcase TOMOYO_MODE_OWNER_READ:\n\t\t\tcase TOMOYO_MODE_OWNER_WRITE:\n\t\t\tcase TOMOYO_MODE_OWNER_EXECUTE:\n\t\t\tcase TOMOYO_MODE_GROUP_READ:\n\t\t\tcase TOMOYO_MODE_GROUP_WRITE:\n\t\t\tcase TOMOYO_MODE_GROUP_EXECUTE:\n\t\t\tcase TOMOYO_MODE_OTHERS_READ:\n\t\t\tcase TOMOYO_MODE_OTHERS_WRITE:\n\t\t\tcase TOMOYO_MODE_OTHERS_EXECUTE:\n\t\t\t\tis_bitop[j] = true;\n\t\t\t}\n\t\t}\n\t\tif (left == TOMOYO_NUMBER_UNION) {\n\t\t\t/* Fetch values now. */\n\t\t\tconst struct tomoyo_number_union *ptr = numbers_p++;\n\t\t\tmin_v[0] = ptr->values[0];\n\t\t\tmax_v[0] = ptr->values[1];\n\t\t}\n\t\tif (right == TOMOYO_NUMBER_UNION) {\n\t\t\t/* Fetch values now. */\n\t\t\tconst struct tomoyo_number_union *ptr = numbers_p++;\n\t\t\tif (ptr->group) {\n\t\t\t\tif (tomoyo_number_matches_group(min_v[0],\n\t\t\t\t\t\t\t\tmax_v[0],\n\t\t\t\t\t\t\t\tptr->group)\n\t\t\t\t    == match)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif ((min_v[0] <= ptr->values[1] &&\n\t\t\t\t     max_v[0] >= ptr->values[0]) == match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * Bit operation is valid only when counterpart value\n\t\t * represents permission.\n\t\t */\n\t\tif (is_bitop[0] && is_bitop[1]) {\n\t\t\tgoto out;\n\t\t} else if (is_bitop[0]) {\n\t\t\tswitch (right) {\n\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\tif (!(max_v[0] & max_v[1]) == !match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t} else if (is_bitop[1]) {\n\t\t\tswitch (left) {\n\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\tif (!(max_v[0] & max_v[1]) == !match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t/* Normal value range comparison. */\n\t\tif ((min_v[0] <= max_v[1] && max_v[0] >= min_v[1]) == match)\n\t\t\tcontinue;\nout:\n\t\treturn false;\n\t}\n\t/* Check argv[] and envp[] now. */\n\tif (r->ee && (argc || envc))\n\t\treturn tomoyo_scan_bprm(r->ee, argc, argv, envc, envp);\n\treturn true;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nbool tomoyo_condition(struct tomoyo_request_info *r,\n\t\t      const struct tomoyo_condition *cond)\n{\n\tu32 i;\n\tunsigned long min_v[2] = { 0, 0 };\n\tunsigned long max_v[2] = { 0, 0 };\n\tconst struct tomoyo_condition_element *condp;\n\tconst struct tomoyo_number_union *numbers_p;\n\tconst struct tomoyo_name_union *names_p;\n\tconst struct tomoyo_argv *argv;\n\tconst struct tomoyo_envp *envp;\n\tstruct tomoyo_obj_info *obj;\n\tu16 condc;\n\tu16 argc;\n\tu16 envc;\n\tstruct linux_binprm *bprm = NULL;\n\tif (!cond)\n\t\treturn true;\n\tcondc = cond->condc;\n\targc = cond->argc;\n\tenvc = cond->envc;\n\tobj = r->obj;\n\tif (r->ee)\n\t\tbprm = r->ee->bprm;\n\tif (!bprm && (argc || envc))\n\t\treturn false;\n\tcondp = (struct tomoyo_condition_element *) (cond + 1);\n\tnumbers_p = (const struct tomoyo_number_union *) (condp + condc);\n\tnames_p = (const struct tomoyo_name_union *)\n\t\t(numbers_p + cond->numbers_count);\n\targv = (const struct tomoyo_argv *) (names_p + cond->names_count);\n\tenvp = (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < condc; i++) {\n\t\tconst bool match = condp->equals;\n\t\tconst u8 left = condp->left;\n\t\tconst u8 right = condp->right;\n\t\tbool is_bitop[2] = { false, false };\n\t\tu8 j;\n\t\tcondp++;\n\t\t/* Check argv[] and envp[] later. */\n\t\tif (left == TOMOYO_ARGV_ENTRY || left == TOMOYO_ENVP_ENTRY)\n\t\t\tcontinue;\n\t\t/* Check string expressions. */\n\t\tif (right == TOMOYO_NAME_UNION) {\n\t\t\tconst struct tomoyo_name_union *ptr = names_p++;\n\t\t\tswitch (left) {\n\t\t\t\tstruct tomoyo_path_info *symlink;\n\t\t\t\tstruct tomoyo_execve *ee;\n\t\t\t\tstruct file *file;\n\t\t\tcase TOMOYO_SYMLINK_TARGET:\n\t\t\t\tsymlink = obj ? obj->symlink_target : NULL;\n\t\t\t\tif (!symlink ||\n\t\t\t\t    !tomoyo_compare_name_union(symlink, ptr)\n\t\t\t\t    == match)\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_REALPATH:\n\t\t\t\tee = r->ee;\n\t\t\t\tfile = ee ? ee->bprm->file : NULL;\n\t\t\t\tif (!tomoyo_scan_exec_realpath(file, ptr,\n\t\t\t\t\t\t\t       match))\n\t\t\t\t\tgoto out;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\t/* Check numeric or bit-op expressions. */\n\t\tfor (j = 0; j < 2; j++) {\n\t\t\tconst u8 index = j ? right : left;\n\t\t\tunsigned long value = 0;\n\t\t\tswitch (index) {\n\t\t\tcase TOMOYO_TASK_UID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_uid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_EUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_euid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_SUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_suid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_FSUID:\n\t\t\t\tvalue = from_kuid(&init_user_ns, current_fsuid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_GID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_gid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_EGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_egid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_SGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_sgid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_FSGID:\n\t\t\t\tvalue = from_kgid(&init_user_ns, current_fsgid());\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_PID:\n\t\t\t\tvalue = tomoyo_sys_getpid();\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TASK_PPID:\n\t\t\t\tvalue = tomoyo_sys_getppid();\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_SOCKET:\n\t\t\t\tvalue = S_IFSOCK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_SYMLINK:\n\t\t\t\tvalue = S_IFLNK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_FILE:\n\t\t\t\tvalue = S_IFREG;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_BLOCK_DEV:\n\t\t\t\tvalue = S_IFBLK;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_DIRECTORY:\n\t\t\t\tvalue = S_IFDIR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_CHAR_DEV:\n\t\t\t\tvalue = S_IFCHR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_TYPE_IS_FIFO:\n\t\t\t\tvalue = S_IFIFO;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_SETUID:\n\t\t\t\tvalue = S_ISUID;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_SETGID:\n\t\t\t\tvalue = S_ISGID;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_STICKY:\n\t\t\t\tvalue = S_ISVTX;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_READ:\n\t\t\t\tvalue = S_IRUSR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_WRITE:\n\t\t\t\tvalue = S_IWUSR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OWNER_EXECUTE:\n\t\t\t\tvalue = S_IXUSR;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_READ:\n\t\t\t\tvalue = S_IRGRP;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_WRITE:\n\t\t\t\tvalue = S_IWGRP;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_GROUP_EXECUTE:\n\t\t\t\tvalue = S_IXGRP;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_READ:\n\t\t\t\tvalue = S_IROTH;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_WRITE:\n\t\t\t\tvalue = S_IWOTH;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_MODE_OTHERS_EXECUTE:\n\t\t\t\tvalue = S_IXOTH;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_ARGC:\n\t\t\t\tif (!bprm)\n\t\t\t\t\tgoto out;\n\t\t\t\tvalue = bprm->argc;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_EXEC_ENVC:\n\t\t\t\tif (!bprm)\n\t\t\t\t\tgoto out;\n\t\t\t\tvalue = bprm->envc;\n\t\t\t\tbreak;\n\t\t\tcase TOMOYO_NUMBER_UNION:\n\t\t\t\t/* Fetch values later. */\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (!obj)\n\t\t\t\t\tgoto out;\n\t\t\t\tif (!obj->validate_done) {\n\t\t\t\t\ttomoyo_get_attributes(obj);\n\t\t\t\t\tobj->validate_done = true;\n\t\t\t\t}\n\t\t\t\t{\n\t\t\t\t\tu8 stat_index;\n\t\t\t\t\tstruct tomoyo_mini_stat *stat;\n\t\t\t\t\tswitch (index) {\n\t\t\t\t\tcase TOMOYO_PATH1_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH1_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH1_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\t\t\t\tstat_index = TOMOYO_PATH1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH2_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\t\t\t\tstat_index = TOMOYO_PATH2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\t\t\t\tstat_index =\n\t\t\t\t\t\t\tTOMOYO_PATH1_PARENT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\t\t\tstat_index =\n\t\t\t\t\t\t\tTOMOYO_PATH2_PARENT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\t}\n\t\t\t\t\tif (!obj->stat_valid[stat_index])\n\t\t\t\t\t\tgoto out;\n\t\t\t\t\tstat = &obj->stat[stat_index];\n\t\t\t\t\tswitch (index) {\n\t\t\t\t\tcase TOMOYO_PATH1_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_UID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_UID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_UID:\n\t\t\t\t\t\tvalue = from_kuid(&init_user_ns, stat->uid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_GID:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_GID:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_GID:\n\t\t\t\t\t\tvalue = from_kgid(&init_user_ns, stat->gid);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_INO:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_INO:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_INO:\n\t\t\t\t\t\tvalue = stat->ino;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MAJOR:\n\t\t\t\t\t\tvalue = MAJOR(stat->dev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_MINOR:\n\t\t\t\t\t\tvalue = MINOR(stat->dev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_TYPE:\n\t\t\t\t\tcase TOMOYO_PATH2_TYPE:\n\t\t\t\t\t\tvalue = stat->mode & S_IFMT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MAJOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MAJOR:\n\t\t\t\t\t\tvalue = MAJOR(stat->rdev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_DEV_MINOR:\n\t\t\t\t\tcase TOMOYO_PATH2_DEV_MINOR:\n\t\t\t\t\t\tvalue = MINOR(stat->rdev);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\t\t\tvalue = stat->mode & S_IALLUGO;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmax_v[j] = value;\n\t\t\tmin_v[j] = value;\n\t\t\tswitch (index) {\n\t\t\tcase TOMOYO_MODE_SETUID:\n\t\t\tcase TOMOYO_MODE_SETGID:\n\t\t\tcase TOMOYO_MODE_STICKY:\n\t\t\tcase TOMOYO_MODE_OWNER_READ:\n\t\t\tcase TOMOYO_MODE_OWNER_WRITE:\n\t\t\tcase TOMOYO_MODE_OWNER_EXECUTE:\n\t\t\tcase TOMOYO_MODE_GROUP_READ:\n\t\t\tcase TOMOYO_MODE_GROUP_WRITE:\n\t\t\tcase TOMOYO_MODE_GROUP_EXECUTE:\n\t\t\tcase TOMOYO_MODE_OTHERS_READ:\n\t\t\tcase TOMOYO_MODE_OTHERS_WRITE:\n\t\t\tcase TOMOYO_MODE_OTHERS_EXECUTE:\n\t\t\t\tis_bitop[j] = true;\n\t\t\t}\n\t\t}\n\t\tif (left == TOMOYO_NUMBER_UNION) {\n\t\t\t/* Fetch values now. */\n\t\t\tconst struct tomoyo_number_union *ptr = numbers_p++;\n\t\t\tmin_v[0] = ptr->values[0];\n\t\t\tmax_v[0] = ptr->values[1];\n\t\t}\n\t\tif (right == TOMOYO_NUMBER_UNION) {\n\t\t\t/* Fetch values now. */\n\t\t\tconst struct tomoyo_number_union *ptr = numbers_p++;\n\t\t\tif (ptr->group) {\n\t\t\t\tif (tomoyo_number_matches_group(min_v[0],\n\t\t\t\t\t\t\t\tmax_v[0],\n\t\t\t\t\t\t\t\tptr->group)\n\t\t\t\t    == match)\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\tif ((min_v[0] <= ptr->values[1] &&\n\t\t\t\t     max_v[0] >= ptr->values[0]) == match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t/*\n\t\t * Bit operation is valid only when counterpart value\n\t\t * represents permission.\n\t\t */\n\t\tif (is_bitop[0] && is_bitop[1]) {\n\t\t\tgoto out;\n\t\t} else if (is_bitop[0]) {\n\t\t\tswitch (right) {\n\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\tif (!(max_v[0] & max_v[1]) == !match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t} else if (is_bitop[1]) {\n\t\t\tswitch (left) {\n\t\t\tcase TOMOYO_PATH1_PERM:\n\t\t\tcase TOMOYO_PATH1_PARENT_PERM:\n\t\t\tcase TOMOYO_PATH2_PERM:\n\t\t\tcase TOMOYO_PATH2_PARENT_PERM:\n\t\t\t\tif (!(max_v[0] & max_v[1]) == !match)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t\t/* Normal value range comparison. */\n\t\tif ((min_v[0] <= max_v[1] && max_v[0] >= min_v[1]) == match)\n\t\t\tcontinue;\nout:\n\t\treturn false;\n\t}\n\t/* Check argv[] and envp[] now. */\n\tif (r->ee && (argc || envc))\n\t\treturn tomoyo_scan_bprm(r->ee, argc, argv, envc, envp);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_entry",
          "args": [
            "r",
            "ptr"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "ptr",
            "list",
            "list"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nvoid tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tbool retried = false;\n\tconst struct list_head *list = &domain->acl_info_list;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tif (!retried) {\n\t\tretried = true;\n\t\tlist = &domain->ns->acl_group[domain->group];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}"
  },
  {
    "function_name": "tomoyo_update_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "91-147",
    "snippet": "int tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_info\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_info\n\t\t\t\t\t\t  *),\n\t\t\t bool (*merge_duplicate) (struct tomoyo_acl_info *,\n\t\t\t\t\t\t  struct tomoyo_acl_info *,\n\t\t\t\t\t\t  const bool))\n{\n\tconst bool is_delete = param->is_delete;\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_info *entry;\n\tstruct list_head * const list = param->list;\n\n\tif (param->data[0]) {\n\t\tnew_entry->cond = tomoyo_get_condition(param);\n\t\tif (!new_entry->cond)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Domain transition preference is allowed for only\n\t\t * \"file execute\" entries.\n\t\t */\n\t\tif (new_entry->cond->transit &&\n\t\t    !(new_entry->type == TOMOYO_TYPE_PATH_ACL &&\n\t\t      container_of(new_entry, struct tomoyo_path_acl, head)\n\t\t      ->perm == 1 << TOMOYO_TYPE_EXECUTE))\n\t\t\tgoto out;\n\t}\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!tomoyo_same_acl_head(entry, new_entry) ||\n\t\t    !check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tif (merge_duplicate)\n\t\t\tentry->is_deleted = merge_duplicate(entry, new_entry,\n\t\t\t\t\t\t\t    is_delete);\n\t\telse\n\t\t\tentry->is_deleted = is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_condition(new_entry->cond);\n\treturn error;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_condition",
          "args": [
            "new_entry->cond"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_condition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1180-1184",
          "snippet": "static inline void tomoyo_put_condition(struct tomoyo_condition *cond)\n{\n\tif (cond)\n\t\tatomic_dec(&cond->head.users);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_condition(struct tomoyo_condition *cond)\n{\n\tif (cond)\n\t\tatomic_dec(&cond->head.users);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&entry->list",
            "list"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_commit_ok",
          "args": [
            "new_entry",
            "size"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_commit_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "73-83",
          "snippet": "void *tomoyo_commit_ok(void *data, const unsigned int size)\n{\n\tvoid *ptr = kzalloc(size, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tmemmove(ptr, data, size);\n\t\tmemset(data, 0, size);\n\t\treturn ptr;\n\t}\n\tkfree(ptr);\n\treturn NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nvoid *tomoyo_commit_ok(void *data, const unsigned int size)\n{\n\tvoid *ptr = kzalloc(size, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tmemmove(ptr, data, size);\n\t\tmemset(data, 0, size);\n\t\treturn ptr;\n\t}\n\tkfree(ptr);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "merge_duplicate",
          "args": [
            "entry",
            "new_entry",
            "is_delete"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_duplicate",
          "args": [
            "entry",
            "new_entry"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_same_acl_head",
          "args": [
            "entry",
            "new_entry"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_same_acl_head",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "72-76",
          "snippet": "static inline bool tomoyo_same_acl_head(const struct tomoyo_acl_info *a,\n\t\t\t\t\tconst struct tomoyo_acl_info *b)\n{\n\treturn a->type == b->type && a->cond == b->cond;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic inline bool tomoyo_same_acl_head(const struct tomoyo_acl_info *a,\n\t\t\t\t\tconst struct tomoyo_acl_info *b)\n{\n\treturn a->type == b->type && a->cond == b->cond;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "entry",
            "list",
            "list"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "new_entry",
            "structtomoyo_path_acl",
            "head"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_get_condition",
          "args": [
            "param"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_condition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "479-685",
          "snippet": "struct tomoyo_condition *tomoyo_get_condition(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_condition *entry = NULL;\n\tstruct tomoyo_condition_element *condp = NULL;\n\tstruct tomoyo_number_union *numbers_p = NULL;\n\tstruct tomoyo_name_union *names_p = NULL;\n\tstruct tomoyo_argv *argv = NULL;\n\tstruct tomoyo_envp *envp = NULL;\n\tstruct tomoyo_condition e = { };\n\tchar * const start_of_string =\n\t\ttomoyo_get_transit_preference(param, &e);\n\tchar * const end_of_string = start_of_string + strlen(start_of_string);\n\tchar *pos;\nrerun:\n\tpos = start_of_string;\n\twhile (1) {\n\t\tu8 left = -1;\n\t\tu8 right = -1;\n\t\tchar *left_word = pos;\n\t\tchar *cp;\n\t\tchar *right_word;\n\t\tbool is_not;\n\t\tif (!*left_word)\n\t\t\tbreak;\n\t\t/*\n\t\t * Since left-hand condition does not allow use of \"path_group\"\n\t\t * or \"number_group\" and environment variable's names do not\n\t\t * accept '=', it is guaranteed that the original line consists\n\t\t * of one or more repetition of $left$operator$right blocks\n\t\t * where \"$left is free from '=' and ' '\" and \"$operator is\n\t\t * either '=' or '!='\" and \"$right is free from ' '\".\n\t\t * Therefore, we can reconstruct the original line at the end\n\t\t * of dry run even if we overwrite $operator with '\\0'.\n\t\t */\n\t\tcp = strchr(pos, ' ');\n\t\tif (cp) {\n\t\t\t*cp = '\\0'; /* Will restore later. */\n\t\t\tpos = cp + 1;\n\t\t} else {\n\t\t\tpos = \"\";\n\t\t}\n\t\tright_word = strchr(left_word, '=');\n\t\tif (!right_word || right_word == left_word)\n\t\t\tgoto out;\n\t\tis_not = *(right_word - 1) == '!';\n\t\tif (is_not)\n\t\t\t*(right_word++ - 1) = '\\0'; /* Will restore later. */\n\t\telse if (*(right_word + 1) != '=')\n\t\t\t*right_word++ = '\\0'; /* Will restore later. */\n\t\telse\n\t\t\tgoto out;\n\t\tdprintk(KERN_WARNING \"%u: <%s>%s=<%s>\\n\", __LINE__, left_word,\n\t\t\tis_not ? \"!\" : \"\", right_word);\n\t\tif (!strcmp(left_word, \"grant_log\")) {\n\t\t\tif (entry) {\n\t\t\t\tif (is_not ||\n\t\t\t\t    entry->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\t\t\t\tgoto out;\n\t\t\t\telse if (!strcmp(right_word, \"yes\"))\n\t\t\t\t\tentry->grant_log = TOMOYO_GRANTLOG_YES;\n\t\t\t\telse if (!strcmp(right_word, \"no\"))\n\t\t\t\t\tentry->grant_log = TOMOYO_GRANTLOG_NO;\n\t\t\t\telse\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp(left_word, \"exec.argv[\", 10)) {\n\t\t\tif (!argv) {\n\t\t\t\te.argc++;\n\t\t\t\te.condc++;\n\t\t\t} else {\n\t\t\t\te.argc--;\n\t\t\t\te.condc--;\n\t\t\t\tleft = TOMOYO_ARGV_ENTRY;\n\t\t\t\targv->is_not = is_not;\n\t\t\t\tif (!tomoyo_parse_argv(left_word + 10,\n\t\t\t\t\t\t       right_word, argv++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tif (!strncmp(left_word, \"exec.envp[\\\"\", 11)) {\n\t\t\tif (!envp) {\n\t\t\t\te.envc++;\n\t\t\t\te.condc++;\n\t\t\t} else {\n\t\t\t\te.envc--;\n\t\t\t\te.condc--;\n\t\t\t\tleft = TOMOYO_ENVP_ENTRY;\n\t\t\t\tenvp->is_not = is_not;\n\t\t\t\tif (!tomoyo_parse_envp(left_word + 11,\n\t\t\t\t\t\t       right_word, envp++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tleft = tomoyo_condition_type(left_word);\n\t\tdprintk(KERN_WARNING \"%u: <%s> left=%u\\n\", __LINE__, left_word,\n\t\t\tleft);\n\t\tif (left == TOMOYO_MAX_CONDITION_KEYWORD) {\n\t\t\tif (!numbers_p) {\n\t\t\t\te.numbers_count++;\n\t\t\t} else {\n\t\t\t\te.numbers_count--;\n\t\t\t\tleft = TOMOYO_NUMBER_UNION;\n\t\t\t\tparam->data = left_word;\n\t\t\t\tif (*left_word == '@' ||\n\t\t\t\t    !tomoyo_parse_number_union(param,\n\t\t\t\t\t\t\t       numbers_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!condp)\n\t\t\te.condc++;\n\t\telse\n\t\t\te.condc--;\n\t\tif (left == TOMOYO_EXEC_REALPATH ||\n\t\t    left == TOMOYO_SYMLINK_TARGET) {\n\t\t\tif (!names_p) {\n\t\t\t\te.names_count++;\n\t\t\t} else {\n\t\t\t\te.names_count--;\n\t\t\t\tright = TOMOYO_NAME_UNION;\n\t\t\t\tparam->data = right_word;\n\t\t\t\tif (!tomoyo_parse_name_union_quoted(param,\n\t\t\t\t\t\t\t\t    names_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tright = tomoyo_condition_type(right_word);\n\t\tif (right == TOMOYO_MAX_CONDITION_KEYWORD) {\n\t\t\tif (!numbers_p) {\n\t\t\t\te.numbers_count++;\n\t\t\t} else {\n\t\t\t\te.numbers_count--;\n\t\t\t\tright = TOMOYO_NUMBER_UNION;\n\t\t\t\tparam->data = right_word;\n\t\t\t\tif (!tomoyo_parse_number_union(param,\n\t\t\t\t\t\t\t       numbers_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\nstore_value:\n\t\tif (!condp) {\n\t\t\tdprintk(KERN_WARNING \"%u: dry_run left=%u right=%u \"\n\t\t\t\t\"match=%u\\n\", __LINE__, left, right, !is_not);\n\t\t\tcontinue;\n\t\t}\n\t\tcondp->left = left;\n\t\tcondp->right = right;\n\t\tcondp->equals = !is_not;\n\t\tdprintk(KERN_WARNING \"%u: left=%u right=%u match=%u\\n\",\n\t\t\t__LINE__, condp->left, condp->right,\n\t\t\tcondp->equals);\n\t\tcondp++;\n\t}\n\tdprintk(KERN_INFO \"%u: cond=%u numbers=%u names=%u ac=%u ec=%u\\n\",\n\t\t__LINE__, e.condc, e.numbers_count, e.names_count, e.argc,\n\t\te.envc);\n\tif (entry) {\n\t\tBUG_ON(e.names_count | e.numbers_count | e.argc | e.envc |\n\t\t       e.condc);\n\t\treturn tomoyo_commit_condition(entry);\n\t}\n\te.size = sizeof(*entry)\n\t\t+ e.condc * sizeof(struct tomoyo_condition_element)\n\t\t+ e.numbers_count * sizeof(struct tomoyo_number_union)\n\t\t+ e.names_count * sizeof(struct tomoyo_name_union)\n\t\t+ e.argc * sizeof(struct tomoyo_argv)\n\t\t+ e.envc * sizeof(struct tomoyo_envp);\n\tentry = kzalloc(e.size, GFP_NOFS);\n\tif (!entry)\n\t\tgoto out2;\n\t*entry = e;\n\te.transit = NULL;\n\tcondp = (struct tomoyo_condition_element *) (entry + 1);\n\tnumbers_p = (struct tomoyo_number_union *) (condp + e.condc);\n\tnames_p = (struct tomoyo_name_union *) (numbers_p + e.numbers_count);\n\targv = (struct tomoyo_argv *) (names_p + e.names_count);\n\tenvp = (struct tomoyo_envp *) (argv + e.argc);\n\t{\n\t\tbool flag = false;\n\t\tfor (pos = start_of_string; pos < end_of_string; pos++) {\n\t\t\tif (*pos)\n\t\t\t\tcontinue;\n\t\t\tif (flag) /* Restore \" \". */\n\t\t\t\t*pos = ' ';\n\t\t\telse if (*(pos + 1) == '=') /* Restore \"!=\". */\n\t\t\t\t*pos = '!';\n\t\t\telse /* Restore \"=\". */\n\t\t\t\t*pos = '=';\n\t\t\tflag = !flag;\n\t\t}\n\t}\n\tgoto rerun;\nout:\n\tdprintk(KERN_WARNING \"%u: %s failed\\n\", __LINE__, __func__);\n\tif (entry) {\n\t\ttomoyo_del_condition(&entry->head.list);\n\t\tkfree(entry);\n\t}\nout2:\n\ttomoyo_put_name(e.transit);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [
            "#define dprintk printk"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\n#define dprintk printk\n\nstruct tomoyo_condition *tomoyo_get_condition(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_condition *entry = NULL;\n\tstruct tomoyo_condition_element *condp = NULL;\n\tstruct tomoyo_number_union *numbers_p = NULL;\n\tstruct tomoyo_name_union *names_p = NULL;\n\tstruct tomoyo_argv *argv = NULL;\n\tstruct tomoyo_envp *envp = NULL;\n\tstruct tomoyo_condition e = { };\n\tchar * const start_of_string =\n\t\ttomoyo_get_transit_preference(param, &e);\n\tchar * const end_of_string = start_of_string + strlen(start_of_string);\n\tchar *pos;\nrerun:\n\tpos = start_of_string;\n\twhile (1) {\n\t\tu8 left = -1;\n\t\tu8 right = -1;\n\t\tchar *left_word = pos;\n\t\tchar *cp;\n\t\tchar *right_word;\n\t\tbool is_not;\n\t\tif (!*left_word)\n\t\t\tbreak;\n\t\t/*\n\t\t * Since left-hand condition does not allow use of \"path_group\"\n\t\t * or \"number_group\" and environment variable's names do not\n\t\t * accept '=', it is guaranteed that the original line consists\n\t\t * of one or more repetition of $left$operator$right blocks\n\t\t * where \"$left is free from '=' and ' '\" and \"$operator is\n\t\t * either '=' or '!='\" and \"$right is free from ' '\".\n\t\t * Therefore, we can reconstruct the original line at the end\n\t\t * of dry run even if we overwrite $operator with '\\0'.\n\t\t */\n\t\tcp = strchr(pos, ' ');\n\t\tif (cp) {\n\t\t\t*cp = '\\0'; /* Will restore later. */\n\t\t\tpos = cp + 1;\n\t\t} else {\n\t\t\tpos = \"\";\n\t\t}\n\t\tright_word = strchr(left_word, '=');\n\t\tif (!right_word || right_word == left_word)\n\t\t\tgoto out;\n\t\tis_not = *(right_word - 1) == '!';\n\t\tif (is_not)\n\t\t\t*(right_word++ - 1) = '\\0'; /* Will restore later. */\n\t\telse if (*(right_word + 1) != '=')\n\t\t\t*right_word++ = '\\0'; /* Will restore later. */\n\t\telse\n\t\t\tgoto out;\n\t\tdprintk(KERN_WARNING \"%u: <%s>%s=<%s>\\n\", __LINE__, left_word,\n\t\t\tis_not ? \"!\" : \"\", right_word);\n\t\tif (!strcmp(left_word, \"grant_log\")) {\n\t\t\tif (entry) {\n\t\t\t\tif (is_not ||\n\t\t\t\t    entry->grant_log != TOMOYO_GRANTLOG_AUTO)\n\t\t\t\t\tgoto out;\n\t\t\t\telse if (!strcmp(right_word, \"yes\"))\n\t\t\t\t\tentry->grant_log = TOMOYO_GRANTLOG_YES;\n\t\t\t\telse if (!strcmp(right_word, \"no\"))\n\t\t\t\t\tentry->grant_log = TOMOYO_GRANTLOG_NO;\n\t\t\t\telse\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (!strncmp(left_word, \"exec.argv[\", 10)) {\n\t\t\tif (!argv) {\n\t\t\t\te.argc++;\n\t\t\t\te.condc++;\n\t\t\t} else {\n\t\t\t\te.argc--;\n\t\t\t\te.condc--;\n\t\t\t\tleft = TOMOYO_ARGV_ENTRY;\n\t\t\t\targv->is_not = is_not;\n\t\t\t\tif (!tomoyo_parse_argv(left_word + 10,\n\t\t\t\t\t\t       right_word, argv++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tif (!strncmp(left_word, \"exec.envp[\\\"\", 11)) {\n\t\t\tif (!envp) {\n\t\t\t\te.envc++;\n\t\t\t\te.condc++;\n\t\t\t} else {\n\t\t\t\te.envc--;\n\t\t\t\te.condc--;\n\t\t\t\tleft = TOMOYO_ENVP_ENTRY;\n\t\t\t\tenvp->is_not = is_not;\n\t\t\t\tif (!tomoyo_parse_envp(left_word + 11,\n\t\t\t\t\t\t       right_word, envp++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tleft = tomoyo_condition_type(left_word);\n\t\tdprintk(KERN_WARNING \"%u: <%s> left=%u\\n\", __LINE__, left_word,\n\t\t\tleft);\n\t\tif (left == TOMOYO_MAX_CONDITION_KEYWORD) {\n\t\t\tif (!numbers_p) {\n\t\t\t\te.numbers_count++;\n\t\t\t} else {\n\t\t\t\te.numbers_count--;\n\t\t\t\tleft = TOMOYO_NUMBER_UNION;\n\t\t\t\tparam->data = left_word;\n\t\t\t\tif (*left_word == '@' ||\n\t\t\t\t    !tomoyo_parse_number_union(param,\n\t\t\t\t\t\t\t       numbers_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t\tif (!condp)\n\t\t\te.condc++;\n\t\telse\n\t\t\te.condc--;\n\t\tif (left == TOMOYO_EXEC_REALPATH ||\n\t\t    left == TOMOYO_SYMLINK_TARGET) {\n\t\t\tif (!names_p) {\n\t\t\t\te.names_count++;\n\t\t\t} else {\n\t\t\t\te.names_count--;\n\t\t\t\tright = TOMOYO_NAME_UNION;\n\t\t\t\tparam->data = right_word;\n\t\t\t\tif (!tomoyo_parse_name_union_quoted(param,\n\t\t\t\t\t\t\t\t    names_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tgoto store_value;\n\t\t}\n\t\tright = tomoyo_condition_type(right_word);\n\t\tif (right == TOMOYO_MAX_CONDITION_KEYWORD) {\n\t\t\tif (!numbers_p) {\n\t\t\t\te.numbers_count++;\n\t\t\t} else {\n\t\t\t\te.numbers_count--;\n\t\t\t\tright = TOMOYO_NUMBER_UNION;\n\t\t\t\tparam->data = right_word;\n\t\t\t\tif (!tomoyo_parse_number_union(param,\n\t\t\t\t\t\t\t       numbers_p++))\n\t\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\nstore_value:\n\t\tif (!condp) {\n\t\t\tdprintk(KERN_WARNING \"%u: dry_run left=%u right=%u \"\n\t\t\t\t\"match=%u\\n\", __LINE__, left, right, !is_not);\n\t\t\tcontinue;\n\t\t}\n\t\tcondp->left = left;\n\t\tcondp->right = right;\n\t\tcondp->equals = !is_not;\n\t\tdprintk(KERN_WARNING \"%u: left=%u right=%u match=%u\\n\",\n\t\t\t__LINE__, condp->left, condp->right,\n\t\t\tcondp->equals);\n\t\tcondp++;\n\t}\n\tdprintk(KERN_INFO \"%u: cond=%u numbers=%u names=%u ac=%u ec=%u\\n\",\n\t\t__LINE__, e.condc, e.numbers_count, e.names_count, e.argc,\n\t\te.envc);\n\tif (entry) {\n\t\tBUG_ON(e.names_count | e.numbers_count | e.argc | e.envc |\n\t\t       e.condc);\n\t\treturn tomoyo_commit_condition(entry);\n\t}\n\te.size = sizeof(*entry)\n\t\t+ e.condc * sizeof(struct tomoyo_condition_element)\n\t\t+ e.numbers_count * sizeof(struct tomoyo_number_union)\n\t\t+ e.names_count * sizeof(struct tomoyo_name_union)\n\t\t+ e.argc * sizeof(struct tomoyo_argv)\n\t\t+ e.envc * sizeof(struct tomoyo_envp);\n\tentry = kzalloc(e.size, GFP_NOFS);\n\tif (!entry)\n\t\tgoto out2;\n\t*entry = e;\n\te.transit = NULL;\n\tcondp = (struct tomoyo_condition_element *) (entry + 1);\n\tnumbers_p = (struct tomoyo_number_union *) (condp + e.condc);\n\tnames_p = (struct tomoyo_name_union *) (numbers_p + e.numbers_count);\n\targv = (struct tomoyo_argv *) (names_p + e.names_count);\n\tenvp = (struct tomoyo_envp *) (argv + e.argc);\n\t{\n\t\tbool flag = false;\n\t\tfor (pos = start_of_string; pos < end_of_string; pos++) {\n\t\t\tif (*pos)\n\t\t\t\tcontinue;\n\t\t\tif (flag) /* Restore \" \". */\n\t\t\t\t*pos = ' ';\n\t\t\telse if (*(pos + 1) == '=') /* Restore \"!=\". */\n\t\t\t\t*pos = '!';\n\t\t\telse /* Restore \"=\". */\n\t\t\t\t*pos = '=';\n\t\t\tflag = !flag;\n\t\t}\n\t}\n\tgoto rerun;\nout:\n\tdprintk(KERN_WARNING \"%u: %s failed\\n\", __LINE__, __func__);\n\tif (entry) {\n\t\ttomoyo_del_condition(&entry->head.list);\n\t\tkfree(entry);\n\t}\nout2:\n\ttomoyo_put_name(e.transit);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_info\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_info\n\t\t\t\t\t\t  *),\n\t\t\t bool (*merge_duplicate) (struct tomoyo_acl_info *,\n\t\t\t\t\t\t  struct tomoyo_acl_info *,\n\t\t\t\t\t\t  const bool))\n{\n\tconst bool is_delete = param->is_delete;\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_info *entry;\n\tstruct list_head * const list = param->list;\n\n\tif (param->data[0]) {\n\t\tnew_entry->cond = tomoyo_get_condition(param);\n\t\tif (!new_entry->cond)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Domain transition preference is allowed for only\n\t\t * \"file execute\" entries.\n\t\t */\n\t\tif (new_entry->cond->transit &&\n\t\t    !(new_entry->type == TOMOYO_TYPE_PATH_ACL &&\n\t\t      container_of(new_entry, struct tomoyo_path_acl, head)\n\t\t      ->perm == 1 << TOMOYO_TYPE_EXECUTE))\n\t\t\tgoto out;\n\t}\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!tomoyo_same_acl_head(entry, new_entry) ||\n\t\t    !check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tif (merge_duplicate)\n\t\t\tentry->is_deleted = merge_duplicate(entry, new_entry,\n\t\t\t\t\t\t\t    is_delete);\n\t\telse\n\t\t\tentry->is_deleted = is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_condition(new_entry->cond);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_same_acl_head",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "72-76",
    "snippet": "static inline bool tomoyo_same_acl_head(const struct tomoyo_acl_info *a,\n\t\t\t\t\tconst struct tomoyo_acl_info *b)\n{\n\treturn a->type == b->type && a->cond == b->cond;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstatic inline bool tomoyo_same_acl_head(const struct tomoyo_acl_info *a,\n\t\t\t\t\tconst struct tomoyo_acl_info *b)\n{\n\treturn a->type == b->type && a->cond == b->cond;\n}"
  },
  {
    "function_name": "tomoyo_update_policy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
    "lines": "31-62",
    "snippet": "int tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_head\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_head\n\t\t\t\t\t\t  *))\n{\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_head *entry;\n\tstruct list_head *list = param->list;\n\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -ENOMEM;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tentry->is_deleted = param->is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !param->is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn error;\n}",
    "includes": [
      "#include <linux/rculist.h>",
      "#include <linux/slab.h>",
      "#include <linux/binfmts.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&entry->list",
            "list"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_commit_ok",
          "args": [
            "new_entry",
            "size"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_commit_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "73-83",
          "snippet": "void *tomoyo_commit_ok(void *data, const unsigned int size)\n{\n\tvoid *ptr = kzalloc(size, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tmemmove(ptr, data, size);\n\t\tmemset(data, 0, size);\n\t\treturn ptr;\n\t}\n\tkfree(ptr);\n\treturn NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nvoid *tomoyo_commit_ok(void *data, const unsigned int size)\n{\n\tvoid *ptr = kzalloc(size, GFP_NOFS);\n\tif (tomoyo_memory_ok(ptr)) {\n\t\tmemmove(ptr, data, size);\n\t\tmemset(data, 0, size);\n\t\treturn ptr;\n\t}\n\tkfree(ptr);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_duplicate",
          "args": [
            "entry",
            "new_entry"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "entry",
            "list",
            "list"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock_interruptible",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_update_policy(struct tomoyo_acl_head *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_head\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_head\n\t\t\t\t\t\t  *))\n{\n\tint error = param->is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_head *entry;\n\tstruct list_head *list = param->list;\n\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\treturn -ENOMEM;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tentry->is_deleted = param->is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !param->is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n\treturn error;\n}"
  }
]