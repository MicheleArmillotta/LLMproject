[
  {
    "function_name": "integrity_load_x509",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/digsig.c",
    "lines": "112-148",
    "snippet": "int __init integrity_load_x509(const unsigned int id, const char *path)\n{\n\tkey_ref_t key;\n\tvoid *data;\n\tloff_t size;\n\tint rc;\n\n\tif (!keyring[id])\n\t\treturn -EINVAL;\n\n\trc = kernel_read_file_from_path(path, &data, &size, 0,\n\t\t\t\t\tREADING_X509_CERTIFICATE);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to open file: %s (%d)\", path, rc);\n\t\treturn rc;\n\t}\n\n\tkey = key_create_or_update(make_key_ref(keyring[id], 1),\n\t\t\t\t   \"asymmetric\",\n\t\t\t\t   NULL,\n\t\t\t\t   data,\n\t\t\t\t   size,\n\t\t\t\t   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\trc = PTR_ERR(key);\n\t\tpr_err(\"Problem loading X.509 certificate (%d): %s\\n\",\n\t\t       rc, path);\n\t} else {\n\t\tpr_notice(\"Loaded X.509 cert '%s': %s\\n\",\n\t\t\t  key_ref_to_ptr(key)->description, path);\n\t\tkey_ref_put(key);\n\t}\n\tvfree(data);\n\treturn 0;\n}",
    "includes": [
      "#include \"integrity.h\"",
      "#include <keys/system_keyring.h>",
      "#include <crypto/public_key.h>",
      "#include <linux/digsig.h>",
      "#include <linux/key-type.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct key *keyring[INTEGRITY_KEYRING_MAX];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "data"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_put",
          "args": [
            "key"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_notice",
          "args": [
            "\"Loaded X.509 cert '%s': %s\\n\"",
            "key_ref_to_ptr(key)->description",
            "path"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "key"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Problem loading X.509 certificate (%d): %s\\n\"",
            "rc",
            "path"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_create_or_update",
          "args": [
            "make_key_ref(keyring[id], 1)",
            "\"asymmetric\"",
            "NULL",
            "data",
            "size",
            "((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ)",
            "KEY_ALLOC_NOT_IN_QUOTA"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "key_create_or_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "800-955",
          "snippet": "key_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\tstruct key_restriction *restrict_link = NULL;\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n\t}\n\n\tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->instantiate ||\n\t    (!index_key.description && !index_key.type->preparse))\n\t\tgoto error_put_type;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tkey_ref = ERR_PTR(-EPERM);\n\tif (!(flags & KEY_ALLOC_BYPASS_RESTRICTION))\n\t\trestrict_link = keyring->restrict_link;\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\tif (restrict_link && restrict_link->check) {\n\t\tret = restrict_link->check(keyring, index_key.type,\n\t\t\t\t\t   &prep.payload, restrict_link->key);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\t/* if we're going to allocate a new key, we're going to have\n\t * to modify the keyring */\n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t/* if it's possible to update this type of key, search for an existing\n\t * key of the same type and description in the destination keyring and\n\t * update that instead if possible\n\t */\n\tif (index_key.type->update) {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref)\n\t\t\tgoto found_matching_key;\n\t}\n\n\t/* if the client doesn't provide, decide on the permissions we want */\n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t/* allocate a new key */\n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags, NULL);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t/* instantiate it and link it into the target keyring */\n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t/* we found a matching key, so we're going to try to update it\n\t * - we can drop the locks first as we have the key pinned\n\t */\n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey = key_ref_to_ptr(key_ref);\n\tif (test_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tif (ret < 0) {\n\t\t\tkey_ref_put(key_ref);\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t}\n\n\tkey_ref = __key_update(key_ref, &prep);\n\tgoto error_free_prep;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nkey_ref_t key_create_or_update(key_ref_t keyring_ref,\n\t\t\t       const char *type,\n\t\t\t       const char *description,\n\t\t\t       const void *payload,\n\t\t\t       size_t plen,\n\t\t\t       key_perm_t perm,\n\t\t\t       unsigned long flags)\n{\n\tstruct keyring_index_key index_key = {\n\t\t.description\t= description,\n\t};\n\tstruct key_preparsed_payload prep;\n\tstruct assoc_array_edit *edit;\n\tconst struct cred *cred = current_cred();\n\tstruct key *keyring, *key = NULL;\n\tkey_ref_t key_ref;\n\tint ret;\n\tstruct key_restriction *restrict_link = NULL;\n\n\t/* look up the key type to see if it's one of the registered kernel\n\t * types */\n\tindex_key.type = key_type_lookup(type);\n\tif (IS_ERR(index_key.type)) {\n\t\tkey_ref = ERR_PTR(-ENODEV);\n\t\tgoto error;\n\t}\n\n\tkey_ref = ERR_PTR(-EINVAL);\n\tif (!index_key.type->instantiate ||\n\t    (!index_key.description && !index_key.type->preparse))\n\t\tgoto error_put_type;\n\n\tkeyring = key_ref_to_ptr(keyring_ref);\n\n\tkey_check(keyring);\n\n\tkey_ref = ERR_PTR(-EPERM);\n\tif (!(flags & KEY_ALLOC_BYPASS_RESTRICTION))\n\t\trestrict_link = keyring->restrict_link;\n\n\tkey_ref = ERR_PTR(-ENOTDIR);\n\tif (keyring->type != &key_type_keyring)\n\t\tgoto error_put_type;\n\n\tmemset(&prep, 0, sizeof(prep));\n\tprep.data = payload;\n\tprep.datalen = plen;\n\tprep.quotalen = index_key.type->def_datalen;\n\tprep.expiry = TIME64_MAX;\n\tif (index_key.type->preparse) {\n\t\tret = index_key.type->preparse(&prep);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t\tif (!index_key.description)\n\t\t\tindex_key.description = prep.description;\n\t\tkey_ref = ERR_PTR(-EINVAL);\n\t\tif (!index_key.description)\n\t\t\tgoto error_free_prep;\n\t}\n\tindex_key.desc_len = strlen(index_key.description);\n\n\tret = __key_link_begin(keyring, &index_key, &edit);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_free_prep;\n\t}\n\n\tif (restrict_link && restrict_link->check) {\n\t\tret = restrict_link->check(keyring, index_key.type,\n\t\t\t\t\t   &prep.payload, restrict_link->key);\n\t\tif (ret < 0) {\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_link_end;\n\t\t}\n\t}\n\n\t/* if we're going to allocate a new key, we're going to have\n\t * to modify the keyring */\n\tret = key_permission(keyring_ref, KEY_NEED_WRITE);\n\tif (ret < 0) {\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\t/* if it's possible to update this type of key, search for an existing\n\t * key of the same type and description in the destination keyring and\n\t * update that instead if possible\n\t */\n\tif (index_key.type->update) {\n\t\tkey_ref = find_key_to_update(keyring_ref, &index_key);\n\t\tif (key_ref)\n\t\t\tgoto found_matching_key;\n\t}\n\n\t/* if the client doesn't provide, decide on the permissions we want */\n\tif (perm == KEY_PERM_UNDEF) {\n\t\tperm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n\t\tperm |= KEY_USR_VIEW;\n\n\t\tif (index_key.type->read)\n\t\t\tperm |= KEY_POS_READ;\n\n\t\tif (index_key.type == &key_type_keyring ||\n\t\t    index_key.type->update)\n\t\t\tperm |= KEY_POS_WRITE;\n\t}\n\n\t/* allocate a new key */\n\tkey = key_alloc(index_key.type, index_key.description,\n\t\t\tcred->fsuid, cred->fsgid, cred, perm, flags, NULL);\n\tif (IS_ERR(key)) {\n\t\tkey_ref = ERR_CAST(key);\n\t\tgoto error_link_end;\n\t}\n\n\t/* instantiate it and link it into the target keyring */\n\tret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);\n\tif (ret < 0) {\n\t\tkey_put(key);\n\t\tkey_ref = ERR_PTR(ret);\n\t\tgoto error_link_end;\n\t}\n\n\tkey_ref = make_key_ref(key, is_key_possessed(keyring_ref));\n\nerror_link_end:\n\t__key_link_end(keyring, &index_key, edit);\nerror_free_prep:\n\tif (index_key.type->preparse)\n\t\tindex_key.type->free_preparse(&prep);\nerror_put_type:\n\tkey_type_put(index_key.type);\nerror:\n\treturn key_ref;\n\n found_matching_key:\n\t/* we found a matching key, so we're going to try to update it\n\t * - we can drop the locks first as we have the key pinned\n\t */\n\t__key_link_end(keyring, &index_key, edit);\n\n\tkey = key_ref_to_ptr(key_ref);\n\tif (test_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags)) {\n\t\tret = wait_for_key_construction(key, true);\n\t\tif (ret < 0) {\n\t\t\tkey_ref_put(key_ref);\n\t\t\tkey_ref = ERR_PTR(ret);\n\t\t\tgoto error_free_prep;\n\t\t}\n\t}\n\n\tkey_ref = __key_update(key_ref, &prep);\n\tgoto error_free_prep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "keyring[id]",
            "1"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Unable to open file: %s (%d)\"",
            "path",
            "rc"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_read_file_from_path",
          "args": [
            "path",
            "&data",
            "&size",
            "0",
            "READING_X509_CERTIFICATE"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"integrity.h\"\n#include <keys/system_keyring.h>\n#include <crypto/public_key.h>\n#include <linux/digsig.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n\nstatic struct key *keyring[INTEGRITY_KEYRING_MAX];\n\nint __init integrity_load_x509(const unsigned int id, const char *path)\n{\n\tkey_ref_t key;\n\tvoid *data;\n\tloff_t size;\n\tint rc;\n\n\tif (!keyring[id])\n\t\treturn -EINVAL;\n\n\trc = kernel_read_file_from_path(path, &data, &size, 0,\n\t\t\t\t\tREADING_X509_CERTIFICATE);\n\tif (rc < 0) {\n\t\tpr_err(\"Unable to open file: %s (%d)\", path, rc);\n\t\treturn rc;\n\t}\n\n\tkey = key_create_or_update(make_key_ref(keyring[id], 1),\n\t\t\t\t   \"asymmetric\",\n\t\t\t\t   NULL,\n\t\t\t\t   data,\n\t\t\t\t   size,\n\t\t\t\t   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t    KEY_USR_VIEW | KEY_USR_READ),\n\t\t\t\t   KEY_ALLOC_NOT_IN_QUOTA);\n\tif (IS_ERR(key)) {\n\t\trc = PTR_ERR(key);\n\t\tpr_err(\"Problem loading X.509 certificate (%d): %s\\n\",\n\t\t       rc, path);\n\t} else {\n\t\tpr_notice(\"Loaded X.509 cert '%s': %s\\n\",\n\t\t\t  key_ref_to_ptr(key)->description, path);\n\t\tkey_ref_put(key);\n\t}\n\tvfree(data);\n\treturn 0;\n}"
  },
  {
    "function_name": "integrity_init_keyring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/digsig.c",
    "lines": "81-110",
    "snippet": "int __init integrity_init_keyring(const unsigned int id)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key_restriction *restriction;\n\tint err = 0;\n\n\tif (!init_keyring)\n\t\treturn 0;\n\n\trestriction = kzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\tif (!restriction)\n\t\treturn -ENOMEM;\n\n\trestriction->check = restrict_link_to_ima;\n\n\tkeyring[id] = keyring_alloc(keyring_name[id], KUIDT_INIT(0),\n\t\t\t\t    KGIDT_INIT(0), cred,\n\t\t\t\t    ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t     KEY_USR_VIEW | KEY_USR_READ |\n\t\t\t\t     KEY_USR_WRITE | KEY_USR_SEARCH),\n\t\t\t\t    KEY_ALLOC_NOT_IN_QUOTA,\n\t\t\t\t    restriction, NULL);\n\tif (IS_ERR(keyring[id])) {\n\t\terr = PTR_ERR(keyring[id]);\n\t\tpr_info(\"Can't allocate %s keyring (%d)\\n\",\n\t\t\tkeyring_name[id], err);\n\t\tkeyring[id] = NULL;\n\t}\n\treturn err;\n}",
    "includes": [
      "#include \"integrity.h\"",
      "#include <keys/system_keyring.h>",
      "#include <crypto/public_key.h>",
      "#include <linux/digsig.h>",
      "#include <linux/key-type.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [
      "#define restrict_link_to_ima restrict_link_by_builtin_trusted",
      "#define restrict_link_to_ima restrict_link_by_builtin_and_secondary_trusted"
    ],
    "globals_used": [
      "static struct key *keyring[INTEGRITY_KEYRING_MAX];",
      "static const char *keyring_name[INTEGRITY_KEYRING_MAX] = {\n#ifndef CONFIG_INTEGRITY_TRUSTED_KEYRING\n\t\"_evm\",\n\t\"_ima\",\n#else\n\t\".evm\",\n\t\".ima\",\n#endif\n\t\"_module\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Can't allocate %s keyring (%d)\\n\"",
            "keyring_name[id]",
            "err"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "keyring[id]"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "keyring[id]"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_alloc",
          "args": [
            "keyring_name[id]",
            "KUIDT_INIT(0)",
            "KGIDT_INIT(0)",
            "cred",
            "((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t     KEY_USR_VIEW | KEY_USR_READ |\n\t\t\t\t     KEY_USR_WRITE | KEY_USR_SEARCH)",
            "KEY_ALLOC_NOT_IN_QUOTA",
            "restriction",
            "NULL"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "494-514",
          "snippet": "struct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);",
            "struct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\nstruct key_type key_type_keyring = {\n\t.name\t\t= \"keyring\",\n\t.def_datalen\t= 0,\n\t.preparse\t= keyring_preparse,\n\t.free_preparse\t= keyring_free_preparse,\n\t.instantiate\t= keyring_instantiate,\n\t.revoke\t\t= keyring_revoke,\n\t.destroy\t= keyring_destroy,\n\t.describe\t= keyring_describe,\n\t.read\t\t= keyring_read,\n};\n\nstruct key *keyring_alloc(const char *description, kuid_t uid, kgid_t gid,\n\t\t\t  const struct cred *cred, key_perm_t perm,\n\t\t\t  unsigned long flags,\n\t\t\t  struct key_restriction *restrict_link,\n\t\t\t  struct key *dest)\n{\n\tstruct key *keyring;\n\tint ret;\n\n\tkeyring = key_alloc(&key_type_keyring, description,\n\t\t\t    uid, gid, cred, perm, flags, restrict_link);\n\tif (!IS_ERR(keyring)) {\n\t\tret = key_instantiate_and_link(keyring, NULL, 0, dest, NULL);\n\t\tif (ret < 0) {\n\t\t\tkey_put(keyring);\n\t\t\tkeyring = ERR_PTR(ret);\n\t\t}\n\t}\n\n\treturn keyring;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KGIDT_INIT",
          "args": [
            "0"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KUIDT_INIT",
          "args": [
            "0"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct key_restriction)",
            "GFP_KERNEL"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"integrity.h\"\n#include <keys/system_keyring.h>\n#include <crypto/public_key.h>\n#include <linux/digsig.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n\n#define restrict_link_to_ima restrict_link_by_builtin_trusted\n#define restrict_link_to_ima restrict_link_by_builtin_and_secondary_trusted\n\nstatic struct key *keyring[INTEGRITY_KEYRING_MAX];\nstatic const char *keyring_name[INTEGRITY_KEYRING_MAX] = {\n#ifndef CONFIG_INTEGRITY_TRUSTED_KEYRING\n\t\"_evm\",\n\t\"_ima\",\n#else\n\t\".evm\",\n\t\".ima\",\n#endif\n\t\"_module\",\n};\n\nint __init integrity_init_keyring(const unsigned int id)\n{\n\tconst struct cred *cred = current_cred();\n\tstruct key_restriction *restriction;\n\tint err = 0;\n\n\tif (!init_keyring)\n\t\treturn 0;\n\n\trestriction = kzalloc(sizeof(struct key_restriction), GFP_KERNEL);\n\tif (!restriction)\n\t\treturn -ENOMEM;\n\n\trestriction->check = restrict_link_to_ima;\n\n\tkeyring[id] = keyring_alloc(keyring_name[id], KUIDT_INIT(0),\n\t\t\t\t    KGIDT_INIT(0), cred,\n\t\t\t\t    ((KEY_POS_ALL & ~KEY_POS_SETATTR) |\n\t\t\t\t     KEY_USR_VIEW | KEY_USR_READ |\n\t\t\t\t     KEY_USR_WRITE | KEY_USR_SEARCH),\n\t\t\t\t    KEY_ALLOC_NOT_IN_QUOTA,\n\t\t\t\t    restriction, NULL);\n\tif (IS_ERR(keyring[id])) {\n\t\terr = PTR_ERR(keyring[id]);\n\t\tpr_info(\"Can't allocate %s keyring (%d)\\n\",\n\t\t\tkeyring_name[id], err);\n\t\tkeyring[id] = NULL;\n\t}\n\treturn err;\n}"
  },
  {
    "function_name": "integrity_digsig_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/digsig.c",
    "lines": "51-79",
    "snippet": "int integrity_digsig_verify(const unsigned int id, const char *sig, int siglen,\n\t\t\t    const char *digest, int digestlen)\n{\n\tif (id >= INTEGRITY_KEYRING_MAX || siglen < 2)\n\t\treturn -EINVAL;\n\n\tif (!keyring[id]) {\n\t\tkeyring[id] =\n\t\t\trequest_key(&key_type_keyring, keyring_name[id], NULL);\n\t\tif (IS_ERR(keyring[id])) {\n\t\t\tint err = PTR_ERR(keyring[id]);\n\t\t\tpr_err(\"no %s keyring: %d\\n\", keyring_name[id], err);\n\t\t\tkeyring[id] = NULL;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tswitch (sig[1]) {\n\tcase 1:\n\t\t/* v1 API expect signature without xattr type */\n\t\treturn digsig_verify(keyring[id], sig + 1, siglen - 1,\n\t\t\t\t     digest, digestlen);\n\tcase 2:\n\t\treturn asymmetric_verify(keyring[id], sig, siglen,\n\t\t\t\t\t digest, digestlen);\n\t}\n\n\treturn -EOPNOTSUPP;\n}",
    "includes": [
      "#include \"integrity.h\"",
      "#include <keys/system_keyring.h>",
      "#include <crypto/public_key.h>",
      "#include <linux/digsig.h>",
      "#include <linux/key-type.h>",
      "#include <linux/cred.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct key *keyring[INTEGRITY_KEYRING_MAX];",
      "static const char *keyring_name[INTEGRITY_KEYRING_MAX] = {\n#ifndef CONFIG_INTEGRITY_TRUSTED_KEYRING\n\t\"_evm\",\n\t\"_ima\",\n#else\n\t\".evm\",\n\t\".ima\",\n#endif\n\t\"_module\",\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "asymmetric_verify",
          "args": [
            "keyring[id]",
            "sig",
            "siglen",
            "digest",
            "digestlen"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "asymmetric_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/integrity.h",
          "lines": "154-158",
          "snippet": "static inline int asymmetric_verify(struct key *keyring, const char *sig,\n\t\t\t\t    int siglen, const char *data, int datalen)\n{\n\treturn -EOPNOTSUPP;\n}",
          "includes": [
            "#include <linux/key.h>",
            "#include <crypto/sha.h>",
            "#include <linux/integrity.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct ima_digest_data {\n\tu8 algo;\n\tu8 length;\n\tunion {\n\t\tstruct {\n\t\t\tu8 unused;\n\t\t\tu8 type;\n\t\t} sha1;\n\t\tstruct {\n\t\t\tu8 type;\n\t\t\tu8 algo;\n\t\t} ng;\n\t\tu8 data[2];\n\t} xattr;\n\tu8 digest[0];\n} __packed;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/key.h>\n#include <crypto/sha.h>\n#include <linux/integrity.h>\n#include <linux/types.h>\n\nstruct ima_digest_data {\n\tu8 algo;\n\tu8 length;\n\tunion {\n\t\tstruct {\n\t\t\tu8 unused;\n\t\t\tu8 type;\n\t\t} sha1;\n\t\tstruct {\n\t\t\tu8 type;\n\t\t\tu8 algo;\n\t\t} ng;\n\t\tu8 data[2];\n\t} xattr;\n\tu8 digest[0];\n} __packed;\n\nstatic inline int asymmetric_verify(struct key *keyring, const char *sig,\n\t\t\t\t    int siglen, const char *data, int datalen)\n{\n\treturn -EOPNOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "digsig_verify",
          "args": [
            "keyring[id]",
            "sig + 1",
            "siglen - 1",
            "digest",
            "digestlen"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_digsig_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/digsig.c",
          "lines": "51-79",
          "snippet": "int integrity_digsig_verify(const unsigned int id, const char *sig, int siglen,\n\t\t\t    const char *digest, int digestlen)\n{\n\tif (id >= INTEGRITY_KEYRING_MAX || siglen < 2)\n\t\treturn -EINVAL;\n\n\tif (!keyring[id]) {\n\t\tkeyring[id] =\n\t\t\trequest_key(&key_type_keyring, keyring_name[id], NULL);\n\t\tif (IS_ERR(keyring[id])) {\n\t\t\tint err = PTR_ERR(keyring[id]);\n\t\t\tpr_err(\"no %s keyring: %d\\n\", keyring_name[id], err);\n\t\t\tkeyring[id] = NULL;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tswitch (sig[1]) {\n\tcase 1:\n\t\t/* v1 API expect signature without xattr type */\n\t\treturn digsig_verify(keyring[id], sig + 1, siglen - 1,\n\t\t\t\t     digest, digestlen);\n\tcase 2:\n\t\treturn asymmetric_verify(keyring[id], sig, siglen,\n\t\t\t\t\t digest, digestlen);\n\t}\n\n\treturn -EOPNOTSUPP;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"no %s keyring: %d\\n\"",
            "keyring_name[id]",
            "err"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "keyring[id]"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "keyring[id]"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_key",
          "args": [
            "&key_type_keyring",
            "keyring_name[id]",
            "NULL"
          ],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "request_key_auth_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "84-104",
          "snippet": "static long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void request_key_auth_revoke(struct key *);",
            "static void request_key_auth_destroy(struct key *);",
            "static long request_key_auth_read(const struct key *, char __user *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstatic long request_key_auth_read(const struct key *, char __user *, size_t);\n\nstatic long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"integrity.h\"\n#include <keys/system_keyring.h>\n#include <crypto/public_key.h>\n#include <linux/digsig.h>\n#include <linux/key-type.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/err.h>\n\nstatic struct key *keyring[INTEGRITY_KEYRING_MAX];\nstatic const char *keyring_name[INTEGRITY_KEYRING_MAX] = {\n#ifndef CONFIG_INTEGRITY_TRUSTED_KEYRING\n\t\"_evm\",\n\t\"_ima\",\n#else\n\t\".evm\",\n\t\".ima\",\n#endif\n\t\"_module\",\n};\n\nint integrity_digsig_verify(const unsigned int id, const char *sig, int siglen,\n\t\t\t    const char *digest, int digestlen)\n{\n\tif (id >= INTEGRITY_KEYRING_MAX || siglen < 2)\n\t\treturn -EINVAL;\n\n\tif (!keyring[id]) {\n\t\tkeyring[id] =\n\t\t\trequest_key(&key_type_keyring, keyring_name[id], NULL);\n\t\tif (IS_ERR(keyring[id])) {\n\t\t\tint err = PTR_ERR(keyring[id]);\n\t\t\tpr_err(\"no %s keyring: %d\\n\", keyring_name[id], err);\n\t\t\tkeyring[id] = NULL;\n\t\t\treturn err;\n\t\t}\n\t}\n\n\tswitch (sig[1]) {\n\tcase 1:\n\t\t/* v1 API expect signature without xattr type */\n\t\treturn digsig_verify(keyring[id], sig + 1, siglen - 1,\n\t\t\t\t     digest, digestlen);\n\tcase 2:\n\t\treturn asymmetric_verify(keyring[id], sig, siglen,\n\t\t\t\t\t digest, digestlen);\n\t}\n\n\treturn -EOPNOTSUPP;\n}"
  }
]