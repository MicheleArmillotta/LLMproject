[
  {
    "function_name": "aa_inherit_files",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "652-676",
    "snippet": "void aa_inherit_files(const struct cred *cred, struct files_struct *files)\n{\n\tstruct aa_label *label = aa_get_newest_cred_label(cred);\n\tstruct file *devnull = NULL;\n\tunsigned int n;\n\n\trevalidate_tty(label);\n\n\t/* Revalidate access to inherited open files. */\n\tn = iterate_fd(files, 0, match_file, label);\n\tif (!n) /* none found? */\n\t\tgoto out;\n\n\tdevnull = dentry_open(&aa_null, O_RDWR, cred);\n\tif (IS_ERR(devnull))\n\t\tdevnull = NULL;\n\t/* replace all the matching ones with this */\n\tdo {\n\t\treplace_fd(n - 1, devnull, 0);\n\t} while ((n = iterate_fd(files, n, match_file, label)) != 0);\n\tif (devnull)\n\t\tfput(devnull);\nout:\n\taa_put_label(label);\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "label"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "devnull"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_fd",
          "args": [
            "files",
            "n",
            "match_file",
            "label"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replace_fd",
          "args": [
            "n - 1",
            "devnull",
            "0"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "devnull"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_open",
          "args": [
            "&aa_null",
            "O_RDWR",
            "cred"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iterate_fd",
          "args": [
            "files",
            "0",
            "match_file",
            "label"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "revalidate_tty",
          "args": [
            "label"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "revalidate_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "613-639",
          "snippet": "static void revalidate_tty(struct aa_label *label)\n{\n\tstruct tty_struct *tty;\n\tint drop_tty = 0;\n\n\ttty = get_current_tty();\n\tif (!tty)\n\t\treturn;\n\n\tspin_lock(&tty->files_lock);\n\tif (!list_empty(&tty->tty_files)) {\n\t\tstruct tty_file_private *file_priv;\n\t\tstruct file *file;\n\t\t/* TODO: Revalidate access to controlling tty. */\n\t\tfile_priv = list_first_entry(&tty->tty_files,\n\t\t\t\t\t     struct tty_file_private, list);\n\t\tfile = file_priv->file;\n\n\t\tif (aa_file_perm(OP_INHERIT, label, file, MAY_READ | MAY_WRITE))\n\t\t\tdrop_tty = 1;\n\t}\n\tspin_unlock(&tty->files_lock);\n\ttty_kref_put(tty);\n\n\tif (drop_tty)\n\t\tno_tty();\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic void revalidate_tty(struct aa_label *label)\n{\n\tstruct tty_struct *tty;\n\tint drop_tty = 0;\n\n\ttty = get_current_tty();\n\tif (!tty)\n\t\treturn;\n\n\tspin_lock(&tty->files_lock);\n\tif (!list_empty(&tty->tty_files)) {\n\t\tstruct tty_file_private *file_priv;\n\t\tstruct file *file;\n\t\t/* TODO: Revalidate access to controlling tty. */\n\t\tfile_priv = list_first_entry(&tty->tty_files,\n\t\t\t\t\t     struct tty_file_private, list);\n\t\tfile = file_priv->file;\n\n\t\tif (aa_file_perm(OP_INHERIT, label, file, MAY_READ | MAY_WRITE))\n\t\t\tdrop_tty = 1;\n\t}\n\tspin_unlock(&tty->files_lock);\n\ttty_kref_put(tty);\n\n\tif (drop_tty)\n\t\tno_tty();\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_get_newest_cred_label",
          "args": [
            "cred"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_cred_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/context.h",
          "lines": "80-83",
          "snippet": "static inline struct aa_label *aa_get_newest_cred_label(const struct cred *cred)\n{\n\treturn aa_get_newest_label(aa_cred_raw_label(cred));\n}",
          "includes": [
            "#include \"policy_ns.h\"",
            "#include \"label.h\"",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policy_ns.h\"\n#include \"label.h\"\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n\nstatic inline struct aa_label *aa_get_newest_cred_label(const struct cred *cred)\n{\n\treturn aa_get_newest_label(aa_cred_raw_label(cred));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nvoid aa_inherit_files(const struct cred *cred, struct files_struct *files)\n{\n\tstruct aa_label *label = aa_get_newest_cred_label(cred);\n\tstruct file *devnull = NULL;\n\tunsigned int n;\n\n\trevalidate_tty(label);\n\n\t/* Revalidate access to inherited open files. */\n\tn = iterate_fd(files, 0, match_file, label);\n\tif (!n) /* none found? */\n\t\tgoto out;\n\n\tdevnull = dentry_open(&aa_null, O_RDWR, cred);\n\tif (IS_ERR(devnull))\n\t\tdevnull = NULL;\n\t/* replace all the matching ones with this */\n\tdo {\n\t\treplace_fd(n - 1, devnull, 0);\n\t} while ((n = iterate_fd(files, n, match_file, label)) != 0);\n\tif (devnull)\n\t\tfput(devnull);\nout:\n\taa_put_label(label);\n}"
  },
  {
    "function_name": "match_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "641-648",
    "snippet": "static int match_file(const void *p, struct file *file, unsigned int fd)\n{\n\tstruct aa_label *label = (struct aa_label *)p;\n\n\tif (aa_file_perm(OP_INHERIT, label, file, aa_map_file_to_perms(file)))\n\t\treturn fd + 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_file_perm",
          "args": [
            "OP_INHERIT",
            "label",
            "file",
            "aa_map_file_to_perms(file)"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "aa_file_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "572-611",
          "snippet": "int aa_file_perm(const char *op, struct aa_label *label, struct file *file,\n\t\t u32 request)\n{\n\tstruct aa_file_ctx *fctx;\n\tstruct aa_label *flabel;\n\tu32 denied;\n\tint error = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!file);\n\n\tfctx = file_ctx(file);\n\n\trcu_read_lock();\n\tflabel  = rcu_dereference(fctx->label);\n\tAA_BUG(!flabel);\n\n\t/* revalidate access, if task is unconfined, or the cached cred\n\t * doesn't match or if the request is for more permissions than\n\t * was granted.\n\t *\n\t * Note: the test for !unconfined(flabel) is to handle file\n\t *       delegation from unconfined tasks\n\t */\n\tdenied = request & ~fctx->allow;\n\tif (unconfined(label) || unconfined(flabel) ||\n\t    (!denied && aa_label_is_subset(flabel, label)))\n\t\tgoto done;\n\n\t/* TODO: label cross check */\n\n\tif (file->f_path.mnt && path_mediated_fs(file->f_path.dentry))\n\t\terror = __file_path_perm(op, label, flabel, file, request,\n\t\t\t\t\t denied);\n\ndone:\n\trcu_read_unlock();\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_file_perm(const char *op, struct aa_label *label, struct file *file,\n\t\t u32 request)\n{\n\tstruct aa_file_ctx *fctx;\n\tstruct aa_label *flabel;\n\tu32 denied;\n\tint error = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!file);\n\n\tfctx = file_ctx(file);\n\n\trcu_read_lock();\n\tflabel  = rcu_dereference(fctx->label);\n\tAA_BUG(!flabel);\n\n\t/* revalidate access, if task is unconfined, or the cached cred\n\t * doesn't match or if the request is for more permissions than\n\t * was granted.\n\t *\n\t * Note: the test for !unconfined(flabel) is to handle file\n\t *       delegation from unconfined tasks\n\t */\n\tdenied = request & ~fctx->allow;\n\tif (unconfined(label) || unconfined(flabel) ||\n\t    (!denied && aa_label_is_subset(flabel, label)))\n\t\tgoto done;\n\n\t/* TODO: label cross check */\n\n\tif (file->f_path.mnt && path_mediated_fs(file->f_path.dentry))\n\t\terror = __file_path_perm(op, label, flabel, file, request,\n\t\t\t\t\t denied);\n\ndone:\n\trcu_read_unlock();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_map_file_to_perms",
          "args": [
            "file"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "aa_map_file_to_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/file.h",
          "lines": "217-236",
          "snippet": "static inline u32 aa_map_file_to_perms(struct file *file)\n{\n\tint flags = file->f_flags;\n\tu32 perms = 0;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\tperms |= MAY_WRITE;\n\tif (file->f_mode & FMODE_READ)\n\t\tperms |= MAY_READ;\n\n\tif ((flags & O_APPEND) && (perms & MAY_WRITE))\n\t\tperms = (perms & ~MAY_WRITE) | MAY_APPEND;\n\t/* trunc implies write permission */\n\tif (flags & O_TRUNC)\n\t\tperms |= MAY_WRITE;\n\tif (flags & O_CREAT)\n\t\tperms |= AA_MAY_CREATE;\n\n\treturn perms;\n}",
          "includes": [
            "#include \"perms.h\"",
            "#include \"match.h\"",
            "#include \"domain.h\"",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"perms.h\"\n#include \"match.h\"\n#include \"domain.h\"\n#include <linux/spinlock.h>\n\nstatic inline u32 aa_map_file_to_perms(struct file *file)\n{\n\tint flags = file->f_flags;\n\tu32 perms = 0;\n\n\tif (file->f_mode & FMODE_WRITE)\n\t\tperms |= MAY_WRITE;\n\tif (file->f_mode & FMODE_READ)\n\t\tperms |= MAY_READ;\n\n\tif ((flags & O_APPEND) && (perms & MAY_WRITE))\n\t\tperms = (perms & ~MAY_WRITE) | MAY_APPEND;\n\t/* trunc implies write permission */\n\tif (flags & O_TRUNC)\n\t\tperms |= MAY_WRITE;\n\tif (flags & O_CREAT)\n\t\tperms |= AA_MAY_CREATE;\n\n\treturn perms;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic int match_file(const void *p, struct file *file, unsigned int fd)\n{\n\tstruct aa_label *label = (struct aa_label *)p;\n\n\tif (aa_file_perm(OP_INHERIT, label, file, aa_map_file_to_perms(file)))\n\t\treturn fd + 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "revalidate_tty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "613-639",
    "snippet": "static void revalidate_tty(struct aa_label *label)\n{\n\tstruct tty_struct *tty;\n\tint drop_tty = 0;\n\n\ttty = get_current_tty();\n\tif (!tty)\n\t\treturn;\n\n\tspin_lock(&tty->files_lock);\n\tif (!list_empty(&tty->tty_files)) {\n\t\tstruct tty_file_private *file_priv;\n\t\tstruct file *file;\n\t\t/* TODO: Revalidate access to controlling tty. */\n\t\tfile_priv = list_first_entry(&tty->tty_files,\n\t\t\t\t\t     struct tty_file_private, list);\n\t\tfile = file_priv->file;\n\n\t\tif (aa_file_perm(OP_INHERIT, label, file, MAY_READ | MAY_WRITE))\n\t\t\tdrop_tty = 1;\n\t}\n\tspin_unlock(&tty->files_lock);\n\ttty_kref_put(tty);\n\n\tif (drop_tty)\n\t\tno_tty();\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "no_tty",
          "args": [],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tty_kref_put",
          "args": [
            "tty"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tty->files_lock"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_file_perm",
          "args": [
            "OP_INHERIT",
            "label",
            "file",
            "MAY_READ | MAY_WRITE"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "aa_file_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "572-611",
          "snippet": "int aa_file_perm(const char *op, struct aa_label *label, struct file *file,\n\t\t u32 request)\n{\n\tstruct aa_file_ctx *fctx;\n\tstruct aa_label *flabel;\n\tu32 denied;\n\tint error = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!file);\n\n\tfctx = file_ctx(file);\n\n\trcu_read_lock();\n\tflabel  = rcu_dereference(fctx->label);\n\tAA_BUG(!flabel);\n\n\t/* revalidate access, if task is unconfined, or the cached cred\n\t * doesn't match or if the request is for more permissions than\n\t * was granted.\n\t *\n\t * Note: the test for !unconfined(flabel) is to handle file\n\t *       delegation from unconfined tasks\n\t */\n\tdenied = request & ~fctx->allow;\n\tif (unconfined(label) || unconfined(flabel) ||\n\t    (!denied && aa_label_is_subset(flabel, label)))\n\t\tgoto done;\n\n\t/* TODO: label cross check */\n\n\tif (file->f_path.mnt && path_mediated_fs(file->f_path.dentry))\n\t\terror = __file_path_perm(op, label, flabel, file, request,\n\t\t\t\t\t denied);\n\ndone:\n\trcu_read_unlock();\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_file_perm(const char *op, struct aa_label *label, struct file *file,\n\t\t u32 request)\n{\n\tstruct aa_file_ctx *fctx;\n\tstruct aa_label *flabel;\n\tu32 denied;\n\tint error = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!file);\n\n\tfctx = file_ctx(file);\n\n\trcu_read_lock();\n\tflabel  = rcu_dereference(fctx->label);\n\tAA_BUG(!flabel);\n\n\t/* revalidate access, if task is unconfined, or the cached cred\n\t * doesn't match or if the request is for more permissions than\n\t * was granted.\n\t *\n\t * Note: the test for !unconfined(flabel) is to handle file\n\t *       delegation from unconfined tasks\n\t */\n\tdenied = request & ~fctx->allow;\n\tif (unconfined(label) || unconfined(flabel) ||\n\t    (!denied && aa_label_is_subset(flabel, label)))\n\t\tgoto done;\n\n\t/* TODO: label cross check */\n\n\tif (file->f_path.mnt && path_mediated_fs(file->f_path.dentry))\n\t\terror = __file_path_perm(op, label, flabel, file, request,\n\t\t\t\t\t denied);\n\ndone:\n\trcu_read_unlock();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_first_entry",
          "args": [
            "&tty->tty_files",
            "structtty_file_private",
            "list"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&tty->tty_files"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tty->files_lock"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_tty",
          "args": [],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic void revalidate_tty(struct aa_label *label)\n{\n\tstruct tty_struct *tty;\n\tint drop_tty = 0;\n\n\ttty = get_current_tty();\n\tif (!tty)\n\t\treturn;\n\n\tspin_lock(&tty->files_lock);\n\tif (!list_empty(&tty->tty_files)) {\n\t\tstruct tty_file_private *file_priv;\n\t\tstruct file *file;\n\t\t/* TODO: Revalidate access to controlling tty. */\n\t\tfile_priv = list_first_entry(&tty->tty_files,\n\t\t\t\t\t     struct tty_file_private, list);\n\t\tfile = file_priv->file;\n\n\t\tif (aa_file_perm(OP_INHERIT, label, file, MAY_READ | MAY_WRITE))\n\t\t\tdrop_tty = 1;\n\t}\n\tspin_unlock(&tty->files_lock);\n\ttty_kref_put(tty);\n\n\tif (drop_tty)\n\t\tno_tty();\n}"
  },
  {
    "function_name": "aa_file_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "572-611",
    "snippet": "int aa_file_perm(const char *op, struct aa_label *label, struct file *file,\n\t\t u32 request)\n{\n\tstruct aa_file_ctx *fctx;\n\tstruct aa_label *flabel;\n\tu32 denied;\n\tint error = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!file);\n\n\tfctx = file_ctx(file);\n\n\trcu_read_lock();\n\tflabel  = rcu_dereference(fctx->label);\n\tAA_BUG(!flabel);\n\n\t/* revalidate access, if task is unconfined, or the cached cred\n\t * doesn't match or if the request is for more permissions than\n\t * was granted.\n\t *\n\t * Note: the test for !unconfined(flabel) is to handle file\n\t *       delegation from unconfined tasks\n\t */\n\tdenied = request & ~fctx->allow;\n\tif (unconfined(label) || unconfined(flabel) ||\n\t    (!denied && aa_label_is_subset(flabel, label)))\n\t\tgoto done;\n\n\t/* TODO: label cross check */\n\n\tif (file->f_path.mnt && path_mediated_fs(file->f_path.dentry))\n\t\terror = __file_path_perm(op, label, flabel, file, request,\n\t\t\t\t\t denied);\n\ndone:\n\trcu_read_unlock();\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__file_path_perm",
          "args": [
            "op",
            "label",
            "flabel",
            "file",
            "request",
            "denied"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "__file_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "510-561",
          "snippet": "static int __file_path_perm(const char *op, struct aa_label *label,\n\t\t\t    struct aa_label *flabel, struct file *file,\n\t\t\t    u32 request, u32 denied)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tstruct path_cond cond = {\n\t\t.uid = file_inode(file)->i_uid,\n\t\t.mode = file_inode(file)->i_mode\n\t};\n\tchar *buffer;\n\tint flags, error;\n\n\t/* revalidation due to label out of date. No revocation at this time */\n\tif (!denied && aa_label_is_subset(flabel, label))\n\t\t/* TODO: check for revocation on stale profiles */\n\t\treturn 0;\n\n\tflags = PATH_DELEGATE_DELETED | (S_ISDIR(cond.mode) ? PATH_IS_DIR : 0);\n\tget_buffers(buffer);\n\n\t/* check every profile in task label not in current cache */\n\terror = fn_for_each_not_in_set(flabel, label, profile,\n\t\t\tprofile_path_perm(op, profile, &file->f_path, buffer,\n\t\t\t\t\t  request, &cond, flags, &perms));\n\tif (denied && !error) {\n\t\t/*\n\t\t * check every profile in file label that was not tested\n\t\t * in the initial check above.\n\t\t *\n\t\t * TODO: cache full perms so this only happens because of\n\t\t * conditionals\n\t\t * TODO: don't audit here\n\t\t */\n\t\tif (label == flabel)\n\t\t\terror = fn_for_each(label, profile,\n\t\t\t\tprofile_path_perm(op, profile, &file->f_path,\n\t\t\t\t\t\t  buffer, request, &cond, flags,\n\t\t\t\t\t\t  &perms));\n\t\telse\n\t\t\terror = fn_for_each_not_in_set(label, flabel, profile,\n\t\t\t\tprofile_path_perm(op, profile, &file->f_path,\n\t\t\t\t\t\t  buffer, request, &cond, flags,\n\t\t\t\t\t\t  &perms));\n\t}\n\tif (!error)\n\t\tupdate_file_ctx(file_ctx(file), label, request);\n\n\tput_buffers(buffer);\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic int __file_path_perm(const char *op, struct aa_label *label,\n\t\t\t    struct aa_label *flabel, struct file *file,\n\t\t\t    u32 request, u32 denied)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tstruct path_cond cond = {\n\t\t.uid = file_inode(file)->i_uid,\n\t\t.mode = file_inode(file)->i_mode\n\t};\n\tchar *buffer;\n\tint flags, error;\n\n\t/* revalidation due to label out of date. No revocation at this time */\n\tif (!denied && aa_label_is_subset(flabel, label))\n\t\t/* TODO: check for revocation on stale profiles */\n\t\treturn 0;\n\n\tflags = PATH_DELEGATE_DELETED | (S_ISDIR(cond.mode) ? PATH_IS_DIR : 0);\n\tget_buffers(buffer);\n\n\t/* check every profile in task label not in current cache */\n\terror = fn_for_each_not_in_set(flabel, label, profile,\n\t\t\tprofile_path_perm(op, profile, &file->f_path, buffer,\n\t\t\t\t\t  request, &cond, flags, &perms));\n\tif (denied && !error) {\n\t\t/*\n\t\t * check every profile in file label that was not tested\n\t\t * in the initial check above.\n\t\t *\n\t\t * TODO: cache full perms so this only happens because of\n\t\t * conditionals\n\t\t * TODO: don't audit here\n\t\t */\n\t\tif (label == flabel)\n\t\t\terror = fn_for_each(label, profile,\n\t\t\t\tprofile_path_perm(op, profile, &file->f_path,\n\t\t\t\t\t\t  buffer, request, &cond, flags,\n\t\t\t\t\t\t  &perms));\n\t\telse\n\t\t\terror = fn_for_each_not_in_set(label, flabel, profile,\n\t\t\t\tprofile_path_perm(op, profile, &file->f_path,\n\t\t\t\t\t\t  buffer, request, &cond, flags,\n\t\t\t\t\t\t  &perms));\n\t}\n\tif (!error)\n\t\tupdate_file_ctx(file_ctx(file), label, request);\n\n\tput_buffers(buffer);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_mediated_fs",
          "args": [
            "file->f_path.dentry"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "path_mediated_fs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "87-90",
          "snippet": "static inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\nstatic inline bool path_mediated_fs(struct dentry *dentry)\n{\n\treturn !(dentry->d_sb->s_flags & SB_NOUSER);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_label_is_subset",
          "args": [
            "flabel",
            "label"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_is_subset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "545-556",
          "snippet": "bool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nbool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "flabel"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unconfined",
          "args": [
            "label"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!flabel"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "fctx->label"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_ctx",
          "args": [
            "file"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_file_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/file.h",
          "lines": "72-78",
          "snippet": "static inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkzfree(ctx);\n\t}\n}",
          "includes": [
            "#include \"perms.h\"",
            "#include \"match.h\"",
            "#include \"domain.h\"",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"perms.h\"\n#include \"match.h\"\n#include \"domain.h\"\n#include <linux/spinlock.h>\n\nstatic inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkzfree(ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!file"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_file_perm(const char *op, struct aa_label *label, struct file *file,\n\t\t u32 request)\n{\n\tstruct aa_file_ctx *fctx;\n\tstruct aa_label *flabel;\n\tu32 denied;\n\tint error = 0;\n\n\tAA_BUG(!label);\n\tAA_BUG(!file);\n\n\tfctx = file_ctx(file);\n\n\trcu_read_lock();\n\tflabel  = rcu_dereference(fctx->label);\n\tAA_BUG(!flabel);\n\n\t/* revalidate access, if task is unconfined, or the cached cred\n\t * doesn't match or if the request is for more permissions than\n\t * was granted.\n\t *\n\t * Note: the test for !unconfined(flabel) is to handle file\n\t *       delegation from unconfined tasks\n\t */\n\tdenied = request & ~fctx->allow;\n\tif (unconfined(label) || unconfined(flabel) ||\n\t    (!denied && aa_label_is_subset(flabel, label)))\n\t\tgoto done;\n\n\t/* TODO: label cross check */\n\n\tif (file->f_path.mnt && path_mediated_fs(file->f_path.dentry))\n\t\terror = __file_path_perm(op, label, flabel, file, request,\n\t\t\t\t\t denied);\n\ndone:\n\trcu_read_unlock();\n\n\treturn error;\n}"
  },
  {
    "function_name": "__file_path_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "510-561",
    "snippet": "static int __file_path_perm(const char *op, struct aa_label *label,\n\t\t\t    struct aa_label *flabel, struct file *file,\n\t\t\t    u32 request, u32 denied)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tstruct path_cond cond = {\n\t\t.uid = file_inode(file)->i_uid,\n\t\t.mode = file_inode(file)->i_mode\n\t};\n\tchar *buffer;\n\tint flags, error;\n\n\t/* revalidation due to label out of date. No revocation at this time */\n\tif (!denied && aa_label_is_subset(flabel, label))\n\t\t/* TODO: check for revocation on stale profiles */\n\t\treturn 0;\n\n\tflags = PATH_DELEGATE_DELETED | (S_ISDIR(cond.mode) ? PATH_IS_DIR : 0);\n\tget_buffers(buffer);\n\n\t/* check every profile in task label not in current cache */\n\terror = fn_for_each_not_in_set(flabel, label, profile,\n\t\t\tprofile_path_perm(op, profile, &file->f_path, buffer,\n\t\t\t\t\t  request, &cond, flags, &perms));\n\tif (denied && !error) {\n\t\t/*\n\t\t * check every profile in file label that was not tested\n\t\t * in the initial check above.\n\t\t *\n\t\t * TODO: cache full perms so this only happens because of\n\t\t * conditionals\n\t\t * TODO: don't audit here\n\t\t */\n\t\tif (label == flabel)\n\t\t\terror = fn_for_each(label, profile,\n\t\t\t\tprofile_path_perm(op, profile, &file->f_path,\n\t\t\t\t\t\t  buffer, request, &cond, flags,\n\t\t\t\t\t\t  &perms));\n\t\telse\n\t\t\terror = fn_for_each_not_in_set(label, flabel, profile,\n\t\t\t\tprofile_path_perm(op, profile, &file->f_path,\n\t\t\t\t\t\t  buffer, request, &cond, flags,\n\t\t\t\t\t\t  &perms));\n\t}\n\tif (!error)\n\t\tupdate_file_ctx(file_ctx(file), label, request);\n\n\tput_buffers(buffer);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_buffers",
          "args": [
            "buffer"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_file_ctx",
          "args": [
            "file_ctx(file)",
            "label",
            "request"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "update_file_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "489-508",
          "snippet": "static void update_file_ctx(struct aa_file_ctx *fctx, struct aa_label *label,\n\t\t\t    u32 request)\n{\n\tstruct aa_label *l, *old;\n\n\t/* update caching of label on file_ctx */\n\tspin_lock(&fctx->lock);\n\told = rcu_dereference_protected(fctx->label,\n\t\t\t\t\tspin_is_locked(&fctx->lock));\n\tl = aa_label_merge(old, label, GFP_ATOMIC);\n\tif (l) {\n\t\tif (l != old) {\n\t\t\trcu_assign_pointer(fctx->label, l);\n\t\t\taa_put_label(old);\n\t\t} else\n\t\t\taa_put_label(l);\n\t\tfctx->allow |= request;\n\t}\n\tspin_unlock(&fctx->lock);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic void update_file_ctx(struct aa_file_ctx *fctx, struct aa_label *label,\n\t\t\t    u32 request)\n{\n\tstruct aa_label *l, *old;\n\n\t/* update caching of label on file_ctx */\n\tspin_lock(&fctx->lock);\n\told = rcu_dereference_protected(fctx->label,\n\t\t\t\t\tspin_is_locked(&fctx->lock));\n\tl = aa_label_merge(old, label, GFP_ATOMIC);\n\tif (l) {\n\t\tif (l != old) {\n\t\t\trcu_assign_pointer(fctx->label, l);\n\t\t\taa_put_label(old);\n\t\t} else\n\t\t\taa_put_label(l);\n\t\tfctx->allow |= request;\n\t}\n\tspin_unlock(&fctx->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_ctx",
          "args": [
            "file"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "aa_free_file_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/file.h",
          "lines": "72-78",
          "snippet": "static inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkzfree(ctx);\n\t}\n}",
          "includes": [
            "#include \"perms.h\"",
            "#include \"match.h\"",
            "#include \"domain.h\"",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"perms.h\"\n#include \"match.h\"\n#include \"domain.h\"\n#include <linux/spinlock.h>\n\nstatic inline void aa_free_file_ctx(struct aa_file_ctx *ctx)\n{\n\tif (ctx) {\n\t\taa_put_label(rcu_access_pointer(ctx->label));\n\t\tkzfree(ctx);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn_for_each_not_in_set",
          "args": [
            "label",
            "flabel",
            "profile",
            "profile_path_perm(op, profile, &file->f_path,\n\t\t\t\t\t\t  buffer, request, &cond, flags,\n\t\t\t\t\t\t  &perms)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_path_perm",
          "args": [
            "op",
            "profile",
            "&file->f_path",
            "buffer",
            "request",
            "&cond",
            "flags",
            "&perms"
          ],
          "line": 551
        },
        "resolved": true,
        "details": {
          "function_name": "profile_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "295-313",
          "snippet": "static int profile_path_perm(const char *op, struct aa_profile *profile,\n\t\t\t     const struct path *path, char *buffer, u32 request,\n\t\t\t     struct path_cond *cond, int flags,\n\t\t\t     struct aa_perms *perms)\n{\n\tconst char *name;\n\tint error;\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\n\terror = path_name(op, &profile->label, path,\n\t\t\t  flags | profile->path_flags, buffer, &name, cond,\n\t\t\t  request);\n\tif (error)\n\t\treturn error;\n\treturn __aa_path_perm(op, profile, name, request, cond, flags,\n\t\t\t      perms);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic int profile_path_perm(const char *op, struct aa_profile *profile,\n\t\t\t     const struct path *path, char *buffer, u32 request,\n\t\t\t     struct path_cond *cond, int flags,\n\t\t\t     struct aa_perms *perms)\n{\n\tconst char *name;\n\tint error;\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\n\terror = path_name(op, &profile->label, path,\n\t\t\t  flags | profile->path_flags, buffer, &name, cond,\n\t\t\t  request);\n\tif (error)\n\t\treturn error;\n\treturn __aa_path_perm(op, profile, name, request, cond, flags,\n\t\t\t      perms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn_for_each",
          "args": [
            "label",
            "profile",
            "profile_path_perm(op, profile, &file->f_path,\n\t\t\t\t\t\t  buffer, request, &cond, flags,\n\t\t\t\t\t\t  &perms)"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_for_each_not_in_set",
          "args": [
            "flabel",
            "label",
            "profile",
            "profile_path_perm(op, profile, &file->f_path, buffer,\n\t\t\t\t\t  request, &cond, flags, &perms)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_buffers",
          "args": [
            "buffer"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "cond.mode"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_is_subset",
          "args": [
            "flabel",
            "label"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_is_subset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "545-556",
          "snippet": "bool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nbool aa_label_is_subset(struct aa_label *set, struct aa_label *sub)\n{\n\tstruct label_it i = { };\n\n\tAA_BUG(!set);\n\tAA_BUG(!sub);\n\n\tif (sub == set)\n\t\treturn true;\n\n\treturn __aa_label_next_not_in_set(&i, set, sub) == NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "file_inode",
          "args": [
            "file"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic int __file_path_perm(const char *op, struct aa_label *label,\n\t\t\t    struct aa_label *flabel, struct file *file,\n\t\t\t    u32 request, u32 denied)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_perms perms = {};\n\tstruct path_cond cond = {\n\t\t.uid = file_inode(file)->i_uid,\n\t\t.mode = file_inode(file)->i_mode\n\t};\n\tchar *buffer;\n\tint flags, error;\n\n\t/* revalidation due to label out of date. No revocation at this time */\n\tif (!denied && aa_label_is_subset(flabel, label))\n\t\t/* TODO: check for revocation on stale profiles */\n\t\treturn 0;\n\n\tflags = PATH_DELEGATE_DELETED | (S_ISDIR(cond.mode) ? PATH_IS_DIR : 0);\n\tget_buffers(buffer);\n\n\t/* check every profile in task label not in current cache */\n\terror = fn_for_each_not_in_set(flabel, label, profile,\n\t\t\tprofile_path_perm(op, profile, &file->f_path, buffer,\n\t\t\t\t\t  request, &cond, flags, &perms));\n\tif (denied && !error) {\n\t\t/*\n\t\t * check every profile in file label that was not tested\n\t\t * in the initial check above.\n\t\t *\n\t\t * TODO: cache full perms so this only happens because of\n\t\t * conditionals\n\t\t * TODO: don't audit here\n\t\t */\n\t\tif (label == flabel)\n\t\t\terror = fn_for_each(label, profile,\n\t\t\t\tprofile_path_perm(op, profile, &file->f_path,\n\t\t\t\t\t\t  buffer, request, &cond, flags,\n\t\t\t\t\t\t  &perms));\n\t\telse\n\t\t\terror = fn_for_each_not_in_set(label, flabel, profile,\n\t\t\t\tprofile_path_perm(op, profile, &file->f_path,\n\t\t\t\t\t\t  buffer, request, &cond, flags,\n\t\t\t\t\t\t  &perms));\n\t}\n\tif (!error)\n\t\tupdate_file_ctx(file_ctx(file), label, request);\n\n\tput_buffers(buffer);\n\n\treturn error;\n}"
  },
  {
    "function_name": "update_file_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "489-508",
    "snippet": "static void update_file_ctx(struct aa_file_ctx *fctx, struct aa_label *label,\n\t\t\t    u32 request)\n{\n\tstruct aa_label *l, *old;\n\n\t/* update caching of label on file_ctx */\n\tspin_lock(&fctx->lock);\n\told = rcu_dereference_protected(fctx->label,\n\t\t\t\t\tspin_is_locked(&fctx->lock));\n\tl = aa_label_merge(old, label, GFP_ATOMIC);\n\tif (l) {\n\t\tif (l != old) {\n\t\t\trcu_assign_pointer(fctx->label, l);\n\t\t\taa_put_label(old);\n\t\t} else\n\t\t\taa_put_label(l);\n\t\tfctx->allow |= request;\n\t}\n\tspin_unlock(&fctx->lock);\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&fctx->lock"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "l"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "fctx->label",
            "l"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_merge",
          "args": [
            "old",
            "label",
            "GFP_ATOMIC"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_merge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1195-1233",
          "snippet": "struct aa_label *aa_label_merge(struct aa_label *a, struct aa_label *b,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn aa_get_newest_label(a);\n\n\t/* TODO: enable when read side is lockless\n\t * check if label exists before taking locks\n\tif (!label_is_stale(a) && !label_is_stale(b))\n\t\tlabel = aa_label_find_merge(a, b);\n\t*/\n\n\tif (!label) {\n\t\tstruct aa_label *new;\n\n\t\ta = aa_get_newest_label(a);\n\t\tb = aa_get_newest_label(b);\n\n\t\t/* could use label_merge_len(a, b), but requires double\n\t\t * comparison for small savings\n\t\t */\n\t\tnew = aa_label_alloc(a->size + b->size, NULL, gfp);\n\t\tif (!new)\n\t\t\tgoto out;\n\n\t\tlabel = label_merge_insert(new, a, b);\n\t\tlabel_free_or_put_new(label, new);\nout:\n\t\taa_put_label(a);\n\t\taa_put_label(b);\n\t}\n\n\treturn label;\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nstruct aa_label *aa_label_merge(struct aa_label *a, struct aa_label *b,\n\t\t\t\tgfp_t gfp)\n{\n\tstruct aa_label *label = NULL;\n\n\tAA_BUG(!a);\n\tAA_BUG(!b);\n\n\tif (a == b)\n\t\treturn aa_get_newest_label(a);\n\n\t/* TODO: enable when read side is lockless\n\t * check if label exists before taking locks\n\tif (!label_is_stale(a) && !label_is_stale(b))\n\t\tlabel = aa_label_find_merge(a, b);\n\t*/\n\n\tif (!label) {\n\t\tstruct aa_label *new;\n\n\t\ta = aa_get_newest_label(a);\n\t\tb = aa_get_newest_label(b);\n\n\t\t/* could use label_merge_len(a, b), but requires double\n\t\t * comparison for small savings\n\t\t */\n\t\tnew = aa_label_alloc(a->size + b->size, NULL, gfp);\n\t\tif (!new)\n\t\t\tgoto out;\n\n\t\tlabel = label_merge_insert(new, a, b);\n\t\tlabel_free_or_put_new(label, new);\nout:\n\t\taa_put_label(a);\n\t\taa_put_label(b);\n\t}\n\n\treturn label;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "fctx->label",
            "spin_is_locked(&fctx->lock)"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_is_locked",
          "args": [
            "&fctx->lock"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&fctx->lock"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic void update_file_ctx(struct aa_file_ctx *fctx, struct aa_label *label,\n\t\t\t    u32 request)\n{\n\tstruct aa_label *l, *old;\n\n\t/* update caching of label on file_ctx */\n\tspin_lock(&fctx->lock);\n\told = rcu_dereference_protected(fctx->label,\n\t\t\t\t\tspin_is_locked(&fctx->lock));\n\tl = aa_label_merge(old, label, GFP_ATOMIC);\n\tif (l) {\n\t\tif (l != old) {\n\t\t\trcu_assign_pointer(fctx->label, l);\n\t\t\taa_put_label(old);\n\t\t} else\n\t\t\taa_put_label(l);\n\t\tfctx->allow |= request;\n\t}\n\tspin_unlock(&fctx->lock);\n}"
  },
  {
    "function_name": "aa_path_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "466-487",
    "snippet": "int aa_path_link(struct aa_label *label, struct dentry *old_dentry,\n\t\t const struct path *new_dir, struct dentry *new_dentry)\n{\n\tstruct path link = { .mnt = new_dir->mnt, .dentry = new_dentry };\n\tstruct path target = { .mnt = new_dir->mnt, .dentry = old_dentry };\n\tstruct path_cond cond = {\n\t\td_backing_inode(old_dentry)->i_uid,\n\t\td_backing_inode(old_dentry)->i_mode\n\t};\n\tchar *buffer = NULL, *buffer2 = NULL;\n\tstruct aa_profile *profile;\n\tint error;\n\n\t/* buffer freed below, lname is pointer in buffer */\n\tget_buffers(buffer, buffer2);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_link(profile, &link, buffer, &target,\n\t\t\t\t\t  buffer2, &cond));\n\tput_buffers(buffer, buffer2);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_buffers",
          "args": [
            "buffer",
            "buffer2"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_for_each_confined",
          "args": [
            "label",
            "profile",
            "profile_path_link(profile, &link, buffer, &target,\n\t\t\t\t\t  buffer2, &cond)"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_path_link",
          "args": [
            "profile",
            "&link",
            "buffer",
            "&target",
            "buffer2",
            "&cond"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "profile_path_link",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "367-446",
          "snippet": "static int profile_path_link(struct aa_profile *profile,\n\t\t\t     const struct path *link, char *buffer,\n\t\t\t     const struct path *target, char *buffer2,\n\t\t\t     struct path_cond *cond)\n{\n\tconst char *lname, *tname = NULL;\n\tstruct aa_perms lperms = {}, perms;\n\tconst char *info = NULL;\n\tu32 request = AA_MAY_LINK;\n\tunsigned int state;\n\tint error;\n\n\terror = path_name(OP_LINK, &profile->label, link, profile->path_flags,\n\t\t\t  buffer, &lname, cond, AA_MAY_LINK);\n\tif (error)\n\t\tgoto audit;\n\n\t/* buffer2 freed below, tname is pointer in buffer2 */\n\terror = path_name(OP_LINK, &profile->label, target, profile->path_flags,\n\t\t\t  buffer2, &tname, cond, AA_MAY_LINK);\n\tif (error)\n\t\tgoto audit;\n\n\terror = -EACCES;\n\t/* aa_str_perms - handles the case of the dfa being NULL */\n\tstate = aa_str_perms(profile->file.dfa, profile->file.start, lname,\n\t\t\t     cond, &lperms);\n\n\tif (!(lperms.allow & AA_MAY_LINK))\n\t\tgoto audit;\n\n\t/* test to see if target can be paired with link */\n\tstate = aa_dfa_null_transition(profile->file.dfa, state);\n\taa_str_perms(profile->file.dfa, state, tname, cond, &perms);\n\n\t/* force audit/quiet masks for link are stored in the second entry\n\t * in the link pair.\n\t */\n\tlperms.audit = perms.audit;\n\tlperms.quiet = perms.quiet;\n\tlperms.kill = perms.kill;\n\n\tif (!(perms.allow & AA_MAY_LINK)) {\n\t\tinfo = \"target restricted\";\n\t\tlperms = perms;\n\t\tgoto audit;\n\t}\n\n\t/* done if link subset test is not required */\n\tif (!(perms.allow & AA_LINK_SUBSET))\n\t\tgoto done_tests;\n\n\t/* Do link perm subset test requiring allowed permission on link are\n\t * a subset of the allowed permissions on target.\n\t */\n\taa_str_perms(profile->file.dfa, profile->file.start, tname, cond,\n\t\t     &perms);\n\n\t/* AA_MAY_LINK is not considered in the subset test */\n\trequest = lperms.allow & ~AA_MAY_LINK;\n\tlperms.allow &= perms.allow | AA_MAY_LINK;\n\n\trequest |= AA_AUDIT_FILE_MASK & (lperms.allow & ~perms.allow);\n\tif (request & ~lperms.allow) {\n\t\tgoto audit;\n\t} else if ((lperms.allow & MAY_EXEC) &&\n\t\t   !xindex_is_subset(lperms.xindex, perms.xindex)) {\n\t\tlperms.allow &= ~MAY_EXEC;\n\t\trequest |= MAY_EXEC;\n\t\tinfo = \"link not subset of target\";\n\t\tgoto audit;\n\t}\n\ndone_tests:\n\terror = 0;\n\naudit:\n\treturn aa_audit_file(profile, &lperms, OP_LINK, request, lname, tname,\n\t\t\t     NULL, cond->uid, info, error);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic int profile_path_link(struct aa_profile *profile,\n\t\t\t     const struct path *link, char *buffer,\n\t\t\t     const struct path *target, char *buffer2,\n\t\t\t     struct path_cond *cond)\n{\n\tconst char *lname, *tname = NULL;\n\tstruct aa_perms lperms = {}, perms;\n\tconst char *info = NULL;\n\tu32 request = AA_MAY_LINK;\n\tunsigned int state;\n\tint error;\n\n\terror = path_name(OP_LINK, &profile->label, link, profile->path_flags,\n\t\t\t  buffer, &lname, cond, AA_MAY_LINK);\n\tif (error)\n\t\tgoto audit;\n\n\t/* buffer2 freed below, tname is pointer in buffer2 */\n\terror = path_name(OP_LINK, &profile->label, target, profile->path_flags,\n\t\t\t  buffer2, &tname, cond, AA_MAY_LINK);\n\tif (error)\n\t\tgoto audit;\n\n\terror = -EACCES;\n\t/* aa_str_perms - handles the case of the dfa being NULL */\n\tstate = aa_str_perms(profile->file.dfa, profile->file.start, lname,\n\t\t\t     cond, &lperms);\n\n\tif (!(lperms.allow & AA_MAY_LINK))\n\t\tgoto audit;\n\n\t/* test to see if target can be paired with link */\n\tstate = aa_dfa_null_transition(profile->file.dfa, state);\n\taa_str_perms(profile->file.dfa, state, tname, cond, &perms);\n\n\t/* force audit/quiet masks for link are stored in the second entry\n\t * in the link pair.\n\t */\n\tlperms.audit = perms.audit;\n\tlperms.quiet = perms.quiet;\n\tlperms.kill = perms.kill;\n\n\tif (!(perms.allow & AA_MAY_LINK)) {\n\t\tinfo = \"target restricted\";\n\t\tlperms = perms;\n\t\tgoto audit;\n\t}\n\n\t/* done if link subset test is not required */\n\tif (!(perms.allow & AA_LINK_SUBSET))\n\t\tgoto done_tests;\n\n\t/* Do link perm subset test requiring allowed permission on link are\n\t * a subset of the allowed permissions on target.\n\t */\n\taa_str_perms(profile->file.dfa, profile->file.start, tname, cond,\n\t\t     &perms);\n\n\t/* AA_MAY_LINK is not considered in the subset test */\n\trequest = lperms.allow & ~AA_MAY_LINK;\n\tlperms.allow &= perms.allow | AA_MAY_LINK;\n\n\trequest |= AA_AUDIT_FILE_MASK & (lperms.allow & ~perms.allow);\n\tif (request & ~lperms.allow) {\n\t\tgoto audit;\n\t} else if ((lperms.allow & MAY_EXEC) &&\n\t\t   !xindex_is_subset(lperms.xindex, perms.xindex)) {\n\t\tlperms.allow &= ~MAY_EXEC;\n\t\trequest |= MAY_EXEC;\n\t\tinfo = \"link not subset of target\";\n\t\tgoto audit;\n\t}\n\ndone_tests:\n\terror = 0;\n\naudit:\n\treturn aa_audit_file(profile, &lperms, OP_LINK, request, lname, tname,\n\t\t\t     NULL, cond->uid, info, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_buffers",
          "args": [
            "buffer",
            "buffer2"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "old_dentry"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "old_dentry"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_path_link(struct aa_label *label, struct dentry *old_dentry,\n\t\t const struct path *new_dir, struct dentry *new_dentry)\n{\n\tstruct path link = { .mnt = new_dir->mnt, .dentry = new_dentry };\n\tstruct path target = { .mnt = new_dir->mnt, .dentry = old_dentry };\n\tstruct path_cond cond = {\n\t\td_backing_inode(old_dentry)->i_uid,\n\t\td_backing_inode(old_dentry)->i_mode\n\t};\n\tchar *buffer = NULL, *buffer2 = NULL;\n\tstruct aa_profile *profile;\n\tint error;\n\n\t/* buffer freed below, lname is pointer in buffer */\n\tget_buffers(buffer, buffer2);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_link(profile, &link, buffer, &target,\n\t\t\t\t\t  buffer2, &cond));\n\tput_buffers(buffer, buffer2);\n\n\treturn error;\n}"
  },
  {
    "function_name": "profile_path_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "367-446",
    "snippet": "static int profile_path_link(struct aa_profile *profile,\n\t\t\t     const struct path *link, char *buffer,\n\t\t\t     const struct path *target, char *buffer2,\n\t\t\t     struct path_cond *cond)\n{\n\tconst char *lname, *tname = NULL;\n\tstruct aa_perms lperms = {}, perms;\n\tconst char *info = NULL;\n\tu32 request = AA_MAY_LINK;\n\tunsigned int state;\n\tint error;\n\n\terror = path_name(OP_LINK, &profile->label, link, profile->path_flags,\n\t\t\t  buffer, &lname, cond, AA_MAY_LINK);\n\tif (error)\n\t\tgoto audit;\n\n\t/* buffer2 freed below, tname is pointer in buffer2 */\n\terror = path_name(OP_LINK, &profile->label, target, profile->path_flags,\n\t\t\t  buffer2, &tname, cond, AA_MAY_LINK);\n\tif (error)\n\t\tgoto audit;\n\n\terror = -EACCES;\n\t/* aa_str_perms - handles the case of the dfa being NULL */\n\tstate = aa_str_perms(profile->file.dfa, profile->file.start, lname,\n\t\t\t     cond, &lperms);\n\n\tif (!(lperms.allow & AA_MAY_LINK))\n\t\tgoto audit;\n\n\t/* test to see if target can be paired with link */\n\tstate = aa_dfa_null_transition(profile->file.dfa, state);\n\taa_str_perms(profile->file.dfa, state, tname, cond, &perms);\n\n\t/* force audit/quiet masks for link are stored in the second entry\n\t * in the link pair.\n\t */\n\tlperms.audit = perms.audit;\n\tlperms.quiet = perms.quiet;\n\tlperms.kill = perms.kill;\n\n\tif (!(perms.allow & AA_MAY_LINK)) {\n\t\tinfo = \"target restricted\";\n\t\tlperms = perms;\n\t\tgoto audit;\n\t}\n\n\t/* done if link subset test is not required */\n\tif (!(perms.allow & AA_LINK_SUBSET))\n\t\tgoto done_tests;\n\n\t/* Do link perm subset test requiring allowed permission on link are\n\t * a subset of the allowed permissions on target.\n\t */\n\taa_str_perms(profile->file.dfa, profile->file.start, tname, cond,\n\t\t     &perms);\n\n\t/* AA_MAY_LINK is not considered in the subset test */\n\trequest = lperms.allow & ~AA_MAY_LINK;\n\tlperms.allow &= perms.allow | AA_MAY_LINK;\n\n\trequest |= AA_AUDIT_FILE_MASK & (lperms.allow & ~perms.allow);\n\tif (request & ~lperms.allow) {\n\t\tgoto audit;\n\t} else if ((lperms.allow & MAY_EXEC) &&\n\t\t   !xindex_is_subset(lperms.xindex, perms.xindex)) {\n\t\tlperms.allow &= ~MAY_EXEC;\n\t\trequest |= MAY_EXEC;\n\t\tinfo = \"link not subset of target\";\n\t\tgoto audit;\n\t}\n\ndone_tests:\n\terror = 0;\n\naudit:\n\treturn aa_audit_file(profile, &lperms, OP_LINK, request, lname, tname,\n\t\t\t     NULL, cond->uid, info, error);\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_audit_file",
          "args": [
            "profile",
            "&lperms",
            "OP_LINK",
            "request",
            "lname",
            "tname",
            "NULL",
            "cond->uid",
            "info",
            "error"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "103-153",
          "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xindex_is_subset",
          "args": [
            "lperms.xindex",
            "perms.xindex"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "xindex_is_subset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "358-365",
          "snippet": "static inline bool xindex_is_subset(u32 link, u32 target)\n{\n\tif (((link & ~AA_X_UNSAFE) != (target & ~AA_X_UNSAFE)) ||\n\t    ((link & AA_X_UNSAFE) && !(target & AA_X_UNSAFE)))\n\t\treturn 0;\n\n\treturn 1;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic inline bool xindex_is_subset(u32 link, u32 target)\n{\n\tif (((link & ~AA_X_UNSAFE) != (target & ~AA_X_UNSAFE)) ||\n\t    ((link & AA_X_UNSAFE) && !(target & AA_X_UNSAFE)))\n\t\treturn 0;\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_str_perms",
          "args": [
            "profile->file.dfa",
            "profile->file.start",
            "tname",
            "cond",
            "&perms"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "aa_str_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "268-277",
          "snippet": "unsigned int aa_str_perms(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *name, struct path_cond *cond,\n\t\t\t  struct aa_perms *perms)\n{\n\tunsigned int state;\n\tstate = aa_dfa_match(dfa, start, name);\n\t*perms = aa_compute_fperms(dfa, state, cond);\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nunsigned int aa_str_perms(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *name, struct path_cond *cond,\n\t\t\t  struct aa_perms *perms)\n{\n\tunsigned int state;\n\tstate = aa_dfa_match(dfa, start, name);\n\t*perms = aa_compute_fperms(dfa, state, cond);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_null_transition",
          "args": [
            "profile->file.dfa",
            "state"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_null_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "80-85",
          "snippet": "static inline unsigned int aa_dfa_null_transition(struct aa_dfa *dfa,\n\t\t\t\t\t\t  unsigned int start)\n{\n\t/* the null transition only needs the string's null terminator byte */\n\treturn aa_dfa_next(dfa, start, 0);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int aa_dfa_null_transition(struct aa_dfa *dfa,\n\t\t\t\t\t\t  unsigned int start)\n{\n\t/* the null transition only needs the string's null terminator byte */\n\treturn aa_dfa_next(dfa, start, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_name",
          "args": [
            "OP_LINK",
            "&profile->label",
            "target",
            "profile->path_flags",
            "buffer2",
            "&tname",
            "cond",
            "AA_MAY_LINK"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "path_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "168-186",
          "snippet": "static int path_name(const char *op, struct aa_label *label,\n\t\t     const struct path *path, int flags, char *buffer,\n\t\t     const char **name, struct path_cond *cond, u32 request)\n{\n\tstruct aa_profile *profile;\n\tconst char *info = NULL;\n\tint error;\n\n\terror = aa_path_name(path, flags, buffer, name, &info,\n\t\t\t     labels_profile(label)->disconnected);\n\tif (error) {\n\t\tfn_for_each_confined(label, profile,\n\t\t\taa_audit_file(profile, &nullperms, op, request, *name,\n\t\t\t\t      NULL, NULL, cond->uid, info, error));\n\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic int path_name(const char *op, struct aa_label *label,\n\t\t     const struct path *path, int flags, char *buffer,\n\t\t     const char **name, struct path_cond *cond, u32 request)\n{\n\tstruct aa_profile *profile;\n\tconst char *info = NULL;\n\tint error;\n\n\terror = aa_path_name(path, flags, buffer, name, &info,\n\t\t\t     labels_profile(label)->disconnected);\n\tif (error) {\n\t\tfn_for_each_confined(label, profile,\n\t\t\taa_audit_file(profile, &nullperms, op, request, *name,\n\t\t\t\t      NULL, NULL, cond->uid, info, error));\n\t\treturn error;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic int profile_path_link(struct aa_profile *profile,\n\t\t\t     const struct path *link, char *buffer,\n\t\t\t     const struct path *target, char *buffer2,\n\t\t\t     struct path_cond *cond)\n{\n\tconst char *lname, *tname = NULL;\n\tstruct aa_perms lperms = {}, perms;\n\tconst char *info = NULL;\n\tu32 request = AA_MAY_LINK;\n\tunsigned int state;\n\tint error;\n\n\terror = path_name(OP_LINK, &profile->label, link, profile->path_flags,\n\t\t\t  buffer, &lname, cond, AA_MAY_LINK);\n\tif (error)\n\t\tgoto audit;\n\n\t/* buffer2 freed below, tname is pointer in buffer2 */\n\terror = path_name(OP_LINK, &profile->label, target, profile->path_flags,\n\t\t\t  buffer2, &tname, cond, AA_MAY_LINK);\n\tif (error)\n\t\tgoto audit;\n\n\terror = -EACCES;\n\t/* aa_str_perms - handles the case of the dfa being NULL */\n\tstate = aa_str_perms(profile->file.dfa, profile->file.start, lname,\n\t\t\t     cond, &lperms);\n\n\tif (!(lperms.allow & AA_MAY_LINK))\n\t\tgoto audit;\n\n\t/* test to see if target can be paired with link */\n\tstate = aa_dfa_null_transition(profile->file.dfa, state);\n\taa_str_perms(profile->file.dfa, state, tname, cond, &perms);\n\n\t/* force audit/quiet masks for link are stored in the second entry\n\t * in the link pair.\n\t */\n\tlperms.audit = perms.audit;\n\tlperms.quiet = perms.quiet;\n\tlperms.kill = perms.kill;\n\n\tif (!(perms.allow & AA_MAY_LINK)) {\n\t\tinfo = \"target restricted\";\n\t\tlperms = perms;\n\t\tgoto audit;\n\t}\n\n\t/* done if link subset test is not required */\n\tif (!(perms.allow & AA_LINK_SUBSET))\n\t\tgoto done_tests;\n\n\t/* Do link perm subset test requiring allowed permission on link are\n\t * a subset of the allowed permissions on target.\n\t */\n\taa_str_perms(profile->file.dfa, profile->file.start, tname, cond,\n\t\t     &perms);\n\n\t/* AA_MAY_LINK is not considered in the subset test */\n\trequest = lperms.allow & ~AA_MAY_LINK;\n\tlperms.allow &= perms.allow | AA_MAY_LINK;\n\n\trequest |= AA_AUDIT_FILE_MASK & (lperms.allow & ~perms.allow);\n\tif (request & ~lperms.allow) {\n\t\tgoto audit;\n\t} else if ((lperms.allow & MAY_EXEC) &&\n\t\t   !xindex_is_subset(lperms.xindex, perms.xindex)) {\n\t\tlperms.allow &= ~MAY_EXEC;\n\t\trequest |= MAY_EXEC;\n\t\tinfo = \"link not subset of target\";\n\t\tgoto audit;\n\t}\n\ndone_tests:\n\terror = 0;\n\naudit:\n\treturn aa_audit_file(profile, &lperms, OP_LINK, request, lname, tname,\n\t\t\t     NULL, cond->uid, info, error);\n}"
  },
  {
    "function_name": "xindex_is_subset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "358-365",
    "snippet": "static inline bool xindex_is_subset(u32 link, u32 target)\n{\n\tif (((link & ~AA_X_UNSAFE) != (target & ~AA_X_UNSAFE)) ||\n\t    ((link & AA_X_UNSAFE) && !(target & AA_X_UNSAFE)))\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic inline bool xindex_is_subset(u32 link, u32 target)\n{\n\tif (((link & ~AA_X_UNSAFE) != (target & ~AA_X_UNSAFE)) ||\n\t    ((link & AA_X_UNSAFE) && !(target & AA_X_UNSAFE)))\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "aa_path_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "326-345",
    "snippet": "int aa_path_perm(const char *op, struct aa_label *label,\n\t\t const struct path *path, int flags, u32 request,\n\t\t struct path_cond *cond)\n{\n\tstruct aa_perms perms = {};\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tflags |= PATH_DELEGATE_DELETED | (S_ISDIR(cond->mode) ? PATH_IS_DIR :\n\t\t\t\t\t\t\t\t0);\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_perm(op, profile, path, buffer, request,\n\t\t\t\t\t  cond, flags, &perms));\n\n\tput_buffers(buffer);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_buffers",
          "args": [
            "buffer"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_for_each_confined",
          "args": [
            "label",
            "profile",
            "profile_path_perm(op, profile, path, buffer, request,\n\t\t\t\t\t  cond, flags, &perms)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_path_perm",
          "args": [
            "op",
            "profile",
            "path",
            "buffer",
            "request",
            "cond",
            "flags",
            "&perms"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "profile_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "295-313",
          "snippet": "static int profile_path_perm(const char *op, struct aa_profile *profile,\n\t\t\t     const struct path *path, char *buffer, u32 request,\n\t\t\t     struct path_cond *cond, int flags,\n\t\t\t     struct aa_perms *perms)\n{\n\tconst char *name;\n\tint error;\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\n\terror = path_name(op, &profile->label, path,\n\t\t\t  flags | profile->path_flags, buffer, &name, cond,\n\t\t\t  request);\n\tif (error)\n\t\treturn error;\n\treturn __aa_path_perm(op, profile, name, request, cond, flags,\n\t\t\t      perms);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic int profile_path_perm(const char *op, struct aa_profile *profile,\n\t\t\t     const struct path *path, char *buffer, u32 request,\n\t\t\t     struct path_cond *cond, int flags,\n\t\t\t     struct aa_perms *perms)\n{\n\tconst char *name;\n\tint error;\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\n\terror = path_name(op, &profile->label, path,\n\t\t\t  flags | profile->path_flags, buffer, &name, cond,\n\t\t\t  request);\n\tif (error)\n\t\treturn error;\n\treturn __aa_path_perm(op, profile, name, request, cond, flags,\n\t\t\t      perms);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_buffers",
          "args": [
            "buffer"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "cond->mode"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_path_perm(const char *op, struct aa_label *label,\n\t\t const struct path *path, int flags, u32 request,\n\t\t struct path_cond *cond)\n{\n\tstruct aa_perms perms = {};\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tflags |= PATH_DELEGATE_DELETED | (S_ISDIR(cond->mode) ? PATH_IS_DIR :\n\t\t\t\t\t\t\t\t0);\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_path_perm(op, profile, path, buffer, request,\n\t\t\t\t\t  cond, flags, &perms));\n\n\tput_buffers(buffer);\n\n\treturn error;\n}"
  },
  {
    "function_name": "profile_path_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "295-313",
    "snippet": "static int profile_path_perm(const char *op, struct aa_profile *profile,\n\t\t\t     const struct path *path, char *buffer, u32 request,\n\t\t\t     struct path_cond *cond, int flags,\n\t\t\t     struct aa_perms *perms)\n{\n\tconst char *name;\n\tint error;\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\n\terror = path_name(op, &profile->label, path,\n\t\t\t  flags | profile->path_flags, buffer, &name, cond,\n\t\t\t  request);\n\tif (error)\n\t\treturn error;\n\treturn __aa_path_perm(op, profile, name, request, cond, flags,\n\t\t\t      perms);\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__aa_path_perm",
          "args": [
            "op",
            "profile",
            "name",
            "request",
            "cond",
            "flags",
            "perms"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "__aa_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "279-292",
          "snippet": "int __aa_path_perm(const char *op, struct aa_profile *profile, const char *name,\n\t\t   u32 request, struct path_cond *cond, int flags,\n\t\t   struct aa_perms *perms)\n{\n\tint e = 0;\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\taa_str_perms(profile->file.dfa, profile->file.start, name, cond, perms);\n\tif (request & ~perms->allow)\n\t\te = -EACCES;\n\treturn aa_audit_file(profile, perms, op, request, name, NULL, NULL,\n\t\t\t     cond->uid, NULL, e);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint __aa_path_perm(const char *op, struct aa_profile *profile, const char *name,\n\t\t   u32 request, struct path_cond *cond, int flags,\n\t\t   struct aa_perms *perms)\n{\n\tint e = 0;\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\taa_str_perms(profile->file.dfa, profile->file.start, name, cond, perms);\n\tif (request & ~perms->allow)\n\t\te = -EACCES;\n\treturn aa_audit_file(profile, perms, op, request, name, NULL, NULL,\n\t\t\t     cond->uid, NULL, e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_name",
          "args": [
            "op",
            "&profile->label",
            "path",
            "flags | profile->path_flags",
            "buffer",
            "&name",
            "cond",
            "request"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "path_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "168-186",
          "snippet": "static int path_name(const char *op, struct aa_label *label,\n\t\t     const struct path *path, int flags, char *buffer,\n\t\t     const char **name, struct path_cond *cond, u32 request)\n{\n\tstruct aa_profile *profile;\n\tconst char *info = NULL;\n\tint error;\n\n\terror = aa_path_name(path, flags, buffer, name, &info,\n\t\t\t     labels_profile(label)->disconnected);\n\tif (error) {\n\t\tfn_for_each_confined(label, profile,\n\t\t\taa_audit_file(profile, &nullperms, op, request, *name,\n\t\t\t\t      NULL, NULL, cond->uid, info, error));\n\t\treturn error;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic int path_name(const char *op, struct aa_label *label,\n\t\t     const struct path *path, int flags, char *buffer,\n\t\t     const char **name, struct path_cond *cond, u32 request)\n{\n\tstruct aa_profile *profile;\n\tconst char *info = NULL;\n\tint error;\n\n\terror = aa_path_name(path, flags, buffer, name, &info,\n\t\t\t     labels_profile(label)->disconnected);\n\tif (error) {\n\t\tfn_for_each_confined(label, profile,\n\t\t\taa_audit_file(profile, &nullperms, op, request, *name,\n\t\t\t\t      NULL, NULL, cond->uid, info, error));\n\t\treturn error;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic int profile_path_perm(const char *op, struct aa_profile *profile,\n\t\t\t     const struct path *path, char *buffer, u32 request,\n\t\t\t     struct path_cond *cond, int flags,\n\t\t\t     struct aa_perms *perms)\n{\n\tconst char *name;\n\tint error;\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\n\terror = path_name(op, &profile->label, path,\n\t\t\t  flags | profile->path_flags, buffer, &name, cond,\n\t\t\t  request);\n\tif (error)\n\t\treturn error;\n\treturn __aa_path_perm(op, profile, name, request, cond, flags,\n\t\t\t      perms);\n}"
  },
  {
    "function_name": "__aa_path_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "279-292",
    "snippet": "int __aa_path_perm(const char *op, struct aa_profile *profile, const char *name,\n\t\t   u32 request, struct path_cond *cond, int flags,\n\t\t   struct aa_perms *perms)\n{\n\tint e = 0;\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\taa_str_perms(profile->file.dfa, profile->file.start, name, cond, perms);\n\tif (request & ~perms->allow)\n\t\te = -EACCES;\n\treturn aa_audit_file(profile, perms, op, request, name, NULL, NULL,\n\t\t\t     cond->uid, NULL, e);\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_audit_file",
          "args": [
            "profile",
            "perms",
            "op",
            "request",
            "name",
            "NULL",
            "NULL",
            "cond->uid",
            "NULL",
            "e"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "103-153",
          "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_str_perms",
          "args": [
            "profile->file.dfa",
            "profile->file.start",
            "name",
            "cond",
            "perms"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "aa_str_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "268-277",
          "snippet": "unsigned int aa_str_perms(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *name, struct path_cond *cond,\n\t\t\t  struct aa_perms *perms)\n{\n\tunsigned int state;\n\tstate = aa_dfa_match(dfa, start, name);\n\t*perms = aa_compute_fperms(dfa, state, cond);\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nunsigned int aa_str_perms(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *name, struct path_cond *cond,\n\t\t\t  struct aa_perms *perms)\n{\n\tunsigned int state;\n\tstate = aa_dfa_match(dfa, start, name);\n\t*perms = aa_compute_fperms(dfa, state, cond);\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint __aa_path_perm(const char *op, struct aa_profile *profile, const char *name,\n\t\t   u32 request, struct path_cond *cond, int flags,\n\t\t   struct aa_perms *perms)\n{\n\tint e = 0;\n\n\tif (profile_unconfined(profile))\n\t\treturn 0;\n\taa_str_perms(profile->file.dfa, profile->file.start, name, cond, perms);\n\tif (request & ~perms->allow)\n\t\te = -EACCES;\n\treturn aa_audit_file(profile, perms, op, request, name, NULL, NULL,\n\t\t\t     cond->uid, NULL, e);\n}"
  },
  {
    "function_name": "aa_str_perms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "268-277",
    "snippet": "unsigned int aa_str_perms(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *name, struct path_cond *cond,\n\t\t\t  struct aa_perms *perms)\n{\n\tunsigned int state;\n\tstate = aa_dfa_match(dfa, start, name);\n\t*perms = aa_compute_fperms(dfa, state, cond);\n\n\treturn state;\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_compute_fperms",
          "args": [
            "dfa",
            "state",
            "cond"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "aa_compute_fperms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "226-256",
          "snippet": "struct aa_perms aa_compute_fperms(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t  struct path_cond *cond)\n{\n\t/* FIXME: change over to new dfa format\n\t * currently file perms are encoded in the dfa, new format\n\t * splits the permissions from the dfa.  This mapping can be\n\t * done at profile load\n\t */\n\tstruct aa_perms perms = { };\n\n\tif (uid_eq(current_fsuid(), cond->uid)) {\n\t\tperms.allow = map_old_perms(dfa_user_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_user_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_user_quiet(dfa, state));\n\t\tperms.xindex = dfa_user_xindex(dfa, state);\n\t} else {\n\t\tperms.allow = map_old_perms(dfa_other_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_other_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_other_quiet(dfa, state));\n\t\tperms.xindex = dfa_other_xindex(dfa, state);\n\t}\n\tperms.allow |= AA_MAY_GETATTR;\n\n\t/* change_profile wasn't determined by ownership in old mapping */\n\tif (ACCEPT_TABLE(dfa)[state] & 0x80000000)\n\t\tperms.allow |= AA_MAY_CHANGE_PROFILE;\n\tif (ACCEPT_TABLE(dfa)[state] & 0x40000000)\n\t\tperms.allow |= AA_MAY_ONEXEC;\n\n\treturn perms;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstruct aa_perms aa_compute_fperms(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t  struct path_cond *cond)\n{\n\t/* FIXME: change over to new dfa format\n\t * currently file perms are encoded in the dfa, new format\n\t * splits the permissions from the dfa.  This mapping can be\n\t * done at profile load\n\t */\n\tstruct aa_perms perms = { };\n\n\tif (uid_eq(current_fsuid(), cond->uid)) {\n\t\tperms.allow = map_old_perms(dfa_user_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_user_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_user_quiet(dfa, state));\n\t\tperms.xindex = dfa_user_xindex(dfa, state);\n\t} else {\n\t\tperms.allow = map_old_perms(dfa_other_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_other_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_other_quiet(dfa, state));\n\t\tperms.xindex = dfa_other_xindex(dfa, state);\n\t}\n\tperms.allow |= AA_MAY_GETATTR;\n\n\t/* change_profile wasn't determined by ownership in old mapping */\n\tif (ACCEPT_TABLE(dfa)[state] & 0x80000000)\n\t\tperms.allow |= AA_MAY_CHANGE_PROFILE;\n\tif (ACCEPT_TABLE(dfa)[state] & 0x40000000)\n\t\tperms.allow |= AA_MAY_ONEXEC;\n\n\treturn perms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_match",
          "args": [
            "dfa",
            "start",
            "name"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "381-417",
          "snippet": "unsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nunsigned int aa_str_perms(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *name, struct path_cond *cond,\n\t\t\t  struct aa_perms *perms)\n{\n\tunsigned int state;\n\tstate = aa_dfa_match(dfa, start, name);\n\t*perms = aa_compute_fperms(dfa, state, cond);\n\n\treturn state;\n}"
  },
  {
    "function_name": "aa_compute_fperms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "226-256",
    "snippet": "struct aa_perms aa_compute_fperms(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t  struct path_cond *cond)\n{\n\t/* FIXME: change over to new dfa format\n\t * currently file perms are encoded in the dfa, new format\n\t * splits the permissions from the dfa.  This mapping can be\n\t * done at profile load\n\t */\n\tstruct aa_perms perms = { };\n\n\tif (uid_eq(current_fsuid(), cond->uid)) {\n\t\tperms.allow = map_old_perms(dfa_user_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_user_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_user_quiet(dfa, state));\n\t\tperms.xindex = dfa_user_xindex(dfa, state);\n\t} else {\n\t\tperms.allow = map_old_perms(dfa_other_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_other_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_other_quiet(dfa, state));\n\t\tperms.xindex = dfa_other_xindex(dfa, state);\n\t}\n\tperms.allow |= AA_MAY_GETATTR;\n\n\t/* change_profile wasn't determined by ownership in old mapping */\n\tif (ACCEPT_TABLE(dfa)[state] & 0x80000000)\n\t\tperms.allow |= AA_MAY_CHANGE_PROFILE;\n\tif (ACCEPT_TABLE(dfa)[state] & 0x40000000)\n\t\tperms.allow |= AA_MAY_ONEXEC;\n\n\treturn perms;\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACCEPT_TABLE",
          "args": [
            "dfa"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACCEPT_TABLE",
          "args": [
            "dfa"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_other_xindex",
          "args": [
            "dfa",
            "state"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_old_perms",
          "args": [
            "dfa_other_quiet(dfa, state)"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "map_old_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "194-213",
          "snippet": "static u32 map_old_perms(u32 old)\n{\n\tu32 new = old & 0xf;\n\tif (old & MAY_READ)\n\t\tnew |= AA_MAY_GETATTR | AA_MAY_OPEN;\n\tif (old & MAY_WRITE)\n\t\tnew |= AA_MAY_SETATTR | AA_MAY_CREATE | AA_MAY_DELETE |\n\t\t       AA_MAY_CHMOD | AA_MAY_CHOWN | AA_MAY_OPEN;\n\tif (old & 0x10)\n\t\tnew |= AA_MAY_LINK;\n\t/* the old mapping lock and link_subset flags where overlaid\n\t * and use was determined by part of a pair that they were in\n\t */\n\tif (old & 0x20)\n\t\tnew |= AA_MAY_LOCK | AA_LINK_SUBSET;\n\tif (old & 0x40)\t/* AA_EXEC_MMAP */\n\t\tnew |= AA_EXEC_MMAP;\n\n\treturn new;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic u32 map_old_perms(u32 old)\n{\n\tu32 new = old & 0xf;\n\tif (old & MAY_READ)\n\t\tnew |= AA_MAY_GETATTR | AA_MAY_OPEN;\n\tif (old & MAY_WRITE)\n\t\tnew |= AA_MAY_SETATTR | AA_MAY_CREATE | AA_MAY_DELETE |\n\t\t       AA_MAY_CHMOD | AA_MAY_CHOWN | AA_MAY_OPEN;\n\tif (old & 0x10)\n\t\tnew |= AA_MAY_LINK;\n\t/* the old mapping lock and link_subset flags where overlaid\n\t * and use was determined by part of a pair that they were in\n\t */\n\tif (old & 0x20)\n\t\tnew |= AA_MAY_LOCK | AA_LINK_SUBSET;\n\tif (old & 0x40)\t/* AA_EXEC_MMAP */\n\t\tnew |= AA_EXEC_MMAP;\n\n\treturn new;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dfa_other_quiet",
          "args": [
            "dfa",
            "state"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_other_audit",
          "args": [
            "dfa",
            "state"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_other_allow",
          "args": [
            "dfa",
            "state"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_user_xindex",
          "args": [
            "dfa",
            "state"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_user_quiet",
          "args": [
            "dfa",
            "state"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_user_audit",
          "args": [
            "dfa",
            "state"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_user_allow",
          "args": [
            "dfa",
            "state"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "current_fsuid()",
            "cond->uid"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstruct aa_perms aa_compute_fperms(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t  struct path_cond *cond)\n{\n\t/* FIXME: change over to new dfa format\n\t * currently file perms are encoded in the dfa, new format\n\t * splits the permissions from the dfa.  This mapping can be\n\t * done at profile load\n\t */\n\tstruct aa_perms perms = { };\n\n\tif (uid_eq(current_fsuid(), cond->uid)) {\n\t\tperms.allow = map_old_perms(dfa_user_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_user_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_user_quiet(dfa, state));\n\t\tperms.xindex = dfa_user_xindex(dfa, state);\n\t} else {\n\t\tperms.allow = map_old_perms(dfa_other_allow(dfa, state));\n\t\tperms.audit = map_old_perms(dfa_other_audit(dfa, state));\n\t\tperms.quiet = map_old_perms(dfa_other_quiet(dfa, state));\n\t\tperms.xindex = dfa_other_xindex(dfa, state);\n\t}\n\tperms.allow |= AA_MAY_GETATTR;\n\n\t/* change_profile wasn't determined by ownership in old mapping */\n\tif (ACCEPT_TABLE(dfa)[state] & 0x80000000)\n\t\tperms.allow |= AA_MAY_CHANGE_PROFILE;\n\tif (ACCEPT_TABLE(dfa)[state] & 0x40000000)\n\t\tperms.allow |= AA_MAY_ONEXEC;\n\n\treturn perms;\n}"
  },
  {
    "function_name": "map_old_perms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "194-213",
    "snippet": "static u32 map_old_perms(u32 old)\n{\n\tu32 new = old & 0xf;\n\tif (old & MAY_READ)\n\t\tnew |= AA_MAY_GETATTR | AA_MAY_OPEN;\n\tif (old & MAY_WRITE)\n\t\tnew |= AA_MAY_SETATTR | AA_MAY_CREATE | AA_MAY_DELETE |\n\t\t       AA_MAY_CHMOD | AA_MAY_CHOWN | AA_MAY_OPEN;\n\tif (old & 0x10)\n\t\tnew |= AA_MAY_LINK;\n\t/* the old mapping lock and link_subset flags where overlaid\n\t * and use was determined by part of a pair that they were in\n\t */\n\tif (old & 0x20)\n\t\tnew |= AA_MAY_LOCK | AA_LINK_SUBSET;\n\tif (old & 0x40)\t/* AA_EXEC_MMAP */\n\t\tnew |= AA_EXEC_MMAP;\n\n\treturn new;\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic u32 map_old_perms(u32 old)\n{\n\tu32 new = old & 0xf;\n\tif (old & MAY_READ)\n\t\tnew |= AA_MAY_GETATTR | AA_MAY_OPEN;\n\tif (old & MAY_WRITE)\n\t\tnew |= AA_MAY_SETATTR | AA_MAY_CREATE | AA_MAY_DELETE |\n\t\t       AA_MAY_CHMOD | AA_MAY_CHOWN | AA_MAY_OPEN;\n\tif (old & 0x10)\n\t\tnew |= AA_MAY_LINK;\n\t/* the old mapping lock and link_subset flags where overlaid\n\t * and use was determined by part of a pair that they were in\n\t */\n\tif (old & 0x20)\n\t\tnew |= AA_MAY_LOCK | AA_LINK_SUBSET;\n\tif (old & 0x40)\t/* AA_EXEC_MMAP */\n\t\tnew |= AA_EXEC_MMAP;\n\n\treturn new;\n}"
  },
  {
    "function_name": "path_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "168-186",
    "snippet": "static int path_name(const char *op, struct aa_label *label,\n\t\t     const struct path *path, int flags, char *buffer,\n\t\t     const char **name, struct path_cond *cond, u32 request)\n{\n\tstruct aa_profile *profile;\n\tconst char *info = NULL;\n\tint error;\n\n\terror = aa_path_name(path, flags, buffer, name, &info,\n\t\t\t     labels_profile(label)->disconnected);\n\tif (error) {\n\t\tfn_for_each_confined(label, profile,\n\t\t\taa_audit_file(profile, &nullperms, op, request, *name,\n\t\t\t\t      NULL, NULL, cond->uid, info, error));\n\t\treturn error;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn_for_each_confined",
          "args": [
            "label",
            "profile",
            "aa_audit_file(profile, &nullperms, op, request, *name,\n\t\t\t\t      NULL, NULL, cond->uid, info, error)"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_audit_file",
          "args": [
            "profile",
            "&nullperms",
            "op",
            "request",
            "*name",
            "NULL",
            "NULL",
            "cond->uid",
            "info",
            "error"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "103-153",
          "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_path_name",
          "args": [
            "path",
            "flags",
            "buffer",
            "name",
            "&info",
            "labels_profile(label)->disconnected"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "aa_path_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
          "lines": "201-221",
          "snippet": "int aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/path.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nint aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "labels_profile",
          "args": [
            "label"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic int path_name(const char *op, struct aa_label *label,\n\t\t     const struct path *path, int flags, char *buffer,\n\t\t     const char **name, struct path_cond *cond, u32 request)\n{\n\tstruct aa_profile *profile;\n\tconst char *info = NULL;\n\tint error;\n\n\terror = aa_path_name(path, flags, buffer, name, &info,\n\t\t\t     labels_profile(label)->disconnected);\n\tif (error) {\n\t\tfn_for_each_confined(label, profile,\n\t\t\taa_audit_file(profile, &nullperms, op, request, *name,\n\t\t\t\t      NULL, NULL, cond->uid, info, error));\n\t\treturn error;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "is_deleted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "161-166",
    "snippet": "static inline bool is_deleted(struct dentry *dentry)\n{\n\tif (d_unlinked(dentry) && d_backing_inode(dentry)->i_nlink == 0)\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_unlinked",
          "args": [
            "dentry"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic inline bool is_deleted(struct dentry *dentry)\n{\n\tif (d_unlinked(dentry) && d_backing_inode(dentry)->i_nlink == 0)\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "aa_audit_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "103-153",
    "snippet": "int aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_audit",
          "args": [
            "type",
            "profile",
            "&sa",
            "file_audit_cb"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/audit.c",
          "lines": "129-165",
          "snippet": "int aa_audit(int type, struct aa_profile *profile, struct common_audit_data *sa,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!aad(sa)->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET))\n\t\treturn aad(sa)->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\taad(sa)->label = &profile->label;\n\n\taa_audit_msg(type, sa, cb);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tsa->type == LSM_AUDIT_DATA_TASK && sa->u.tsk ?\n\t\t\t\t    sa->u.tsk : current);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(aad(sa)->error);\n\n\treturn aad(sa)->error;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/socket.h>\n#include <linux/audit.h>\n\nint aa_audit(int type, struct aa_profile *profile, struct common_audit_data *sa,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!aad(sa)->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET))\n\t\treturn aad(sa)->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\taad(sa)->label = &profile->label;\n\n\taa_audit_msg(type, sa, cb);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tsa->type == LSM_AUDIT_DATA_TASK && sa->u.tsk ?\n\t\t\t\t    sa->u.tsk : current);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(aad(sa)->error);\n\n\treturn aad(sa)->error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_MODE",
          "args": [
            "profile"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "AUDIT_MODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "283-289",
          "snippet": "static inline int AUDIT_MODE(struct aa_profile *profile)\n{\n\tif (aa_g_audit != AUDIT_NORMAL)\n\t\treturn aa_g_audit;\n\n\treturn profile->audit;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline int AUDIT_MODE(struct aa_profile *profile)\n{\n\tif (aa_g_audit != AUDIT_NORMAL)\n\t\treturn aa_g_audit;\n\n\treturn profile->audit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!aad(&sa)->request"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!aad(&sa)->request"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "AUDIT_MODE(profile) == AUDIT_ALL"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!aad(&sa)->error"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_AUDIT_DATA",
          "args": [
            "sa",
            "LSM_AUDIT_DATA_TASK",
            "op"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nint aa_audit_file(struct aa_profile *profile, struct aa_perms *perms,\n\t\t  const char *op, u32 request, const char *name,\n\t\t  const char *target, struct aa_label *tlabel,\n\t\t  kuid_t ouid, const char *info, int error)\n{\n\tint type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_TASK, op);\n\n\tsa.u.tsk = NULL;\n\taad(&sa)->request = request;\n\taad(&sa)->name = name;\n\taad(&sa)->fs.target = target;\n\taad(&sa)->peer = tlabel;\n\taad(&sa)->fs.ouid = ouid;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\tsa.u.tsk = NULL;\n\n\tif (likely(!aad(&sa)->error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\taad(&sa)->request &= mask;\n\n\t\tif (likely(!aad(&sa)->request))\n\t\t\treturn 0;\n\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\taad(&sa)->request = aad(&sa)->request & ~perms->allow;\n\t\tAA_BUG(!aad(&sa)->request);\n\n\t\tif (aad(&sa)->request & perms->kill)\n\t\t\ttype = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((aad(&sa)->request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\taad(&sa)->request &= ~perms->quiet;\n\n\t\tif (!aad(&sa)->request)\n\t\t\treturn aad(&sa)->error;\n\t}\n\n\taad(&sa)->denied = aad(&sa)->request & ~perms->allow;\n\treturn aa_audit(type, profile, &sa, file_audit_cb);\n}"
  },
  {
    "function_name": "file_audit_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "58-86",
    "snippet": "static void file_audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\tkuid_t fsuid = current_fsuid();\n\n\tif (aad(sa)->request & AA_AUDIT_FILE_MASK) {\n\t\taudit_log_format(ab, \" requested_mask=\");\n\t\taudit_file_mask(ab, aad(sa)->request);\n\t}\n\tif (aad(sa)->denied & AA_AUDIT_FILE_MASK) {\n\t\taudit_log_format(ab, \" denied_mask=\");\n\t\taudit_file_mask(ab, aad(sa)->denied);\n\t}\n\tif (aad(sa)->request & AA_AUDIT_FILE_MASK) {\n\t\taudit_log_format(ab, \" fsuid=%d\",\n\t\t\t\t from_kuid(&init_user_ns, fsuid));\n\t\taudit_log_format(ab, \" ouid=%d\",\n\t\t\t\t from_kuid(&init_user_ns, aad(sa)->fs.ouid));\n\t}\n\n\tif (aad(sa)->peer) {\n\t\taudit_log_format(ab, \" target=\");\n\t\taa_label_xaudit(ab, labels_ns(aad(sa)->label), aad(sa)->peer,\n\t\t\t\tFLAG_VIEW_SUBNS, GFP_ATOMIC);\n\t} else if (aad(sa)->fs.target) {\n\t\taudit_log_format(ab, \" target=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->fs.target);\n\t}\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "aad(sa)->fs.target"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" target=\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_label_xaudit",
          "args": [
            "ab",
            "labels_ns(aad(sa)->label)",
            "aad(sa)->peer",
            "FLAG_VIEW_SUBNS",
            "GFP_ATOMIC"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1710-1738",
          "snippet": "void aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xaudit(struct audit_buffer *ab, struct aa_ns *ns,\n\t\t     struct aa_label *label, int flags, gfp_t gfp)\n{\n\tconst char *str;\n\tchar *name = NULL;\n\tint len;\n\n\tAA_BUG(!ab);\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags) ||\n\t    display_mode(ns, label, flags)) {\n\t\tlen  = aa_label_asxprint(&name, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tstr = name;\n\t} else {\n\t\tstr = (char *) label->hname;\n\t\tlen = strlen(str);\n\t}\n\tif (audit_string_contains_control(str, len))\n\t\taudit_log_n_hex(ab, str, len);\n\telse\n\t\taudit_log_n_string(ab, str, len);\n\n\tkfree(name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "labels_ns",
          "args": [
            "aad(sa)->label"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" target=\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" ouid=%d\"",
            "from_kuid(&init_user_ns, aad(sa)->fs.ouid)"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "aad(sa)->fs.ouid"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" fsuid=%d\"",
            "from_kuid(&init_user_ns, fsuid)"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "fsuid"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_file_mask",
          "args": [
            "ab",
            "aad(sa)->denied"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "audit_file_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "45-51",
          "snippet": "static void audit_file_mask(struct audit_buffer *ab, u32 mask)\n{\n\tchar str[10];\n\n\taa_perm_mask_to_str(str, aa_file_perm_chrs, map_mask_to_chr_mask(mask));\n\taudit_log_string(ab, str);\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic void audit_file_mask(struct audit_buffer *ab, u32 mask)\n{\n\tchar str[10];\n\n\taa_perm_mask_to_str(str, aa_file_perm_chrs, map_mask_to_chr_mask(mask));\n\taudit_log_string(ab, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" denied_mask=\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" requested_mask=\""
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_fsuid",
          "args": [],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic void file_audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\tkuid_t fsuid = current_fsuid();\n\n\tif (aad(sa)->request & AA_AUDIT_FILE_MASK) {\n\t\taudit_log_format(ab, \" requested_mask=\");\n\t\taudit_file_mask(ab, aad(sa)->request);\n\t}\n\tif (aad(sa)->denied & AA_AUDIT_FILE_MASK) {\n\t\taudit_log_format(ab, \" denied_mask=\");\n\t\taudit_file_mask(ab, aad(sa)->denied);\n\t}\n\tif (aad(sa)->request & AA_AUDIT_FILE_MASK) {\n\t\taudit_log_format(ab, \" fsuid=%d\",\n\t\t\t\t from_kuid(&init_user_ns, fsuid));\n\t\taudit_log_format(ab, \" ouid=%d\",\n\t\t\t\t from_kuid(&init_user_ns, aad(sa)->fs.ouid));\n\t}\n\n\tif (aad(sa)->peer) {\n\t\taudit_log_format(ab, \" target=\");\n\t\taa_label_xaudit(ab, labels_ns(aad(sa)->label), aad(sa)->peer,\n\t\t\t\tFLAG_VIEW_SUBNS, GFP_ATOMIC);\n\t} else if (aad(sa)->fs.target) {\n\t\taudit_log_format(ab, \" target=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->fs.target);\n\t}\n}"
  },
  {
    "function_name": "audit_file_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "45-51",
    "snippet": "static void audit_file_mask(struct audit_buffer *ab, u32 mask)\n{\n\tchar str[10];\n\n\taa_perm_mask_to_str(str, aa_file_perm_chrs, map_mask_to_chr_mask(mask));\n\taudit_log_string(ab, str);\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_string",
          "args": [
            "ab",
            "str"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_perm_mask_to_str",
          "args": [
            "str",
            "aa_file_perm_chrs",
            "map_mask_to_chr_mask(mask)"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "aa_perm_mask_to_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/lib.c",
          "lines": "203-212",
          "snippet": "void aa_perm_mask_to_str(char *str, const char *chrs, u32 mask)\n{\n\tunsigned int i, perm = 1;\n\n\tfor (i = 0; i < 32; perm <<= 1, i++) {\n\t\tif (mask & perm)\n\t\t\t*str++ = chrs[i];\n\t}\n\t*str = '\\0';\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/perms.h\"",
            "#include \"include/lib.h\"",
            "#include \"include/apparmor.h\"",
            "#include \"include/audit.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/perms.h\"\n#include \"include/lib.h\"\n#include \"include/apparmor.h\"\n#include \"include/audit.h\"\n#include <linux/vmalloc.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/ctype.h>\n\nvoid aa_perm_mask_to_str(char *str, const char *chrs, u32 mask)\n{\n\tunsigned int i, perm = 1;\n\n\tfor (i = 0; i < 32; perm <<= 1, i++) {\n\t\tif (mask & perm)\n\t\t\t*str++ = chrs[i];\n\t}\n\t*str = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "map_mask_to_chr_mask",
          "args": [
            "mask"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "map_mask_to_chr_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
          "lines": "28-38",
          "snippet": "static u32 map_mask_to_chr_mask(u32 mask)\n{\n\tu32 m = mask & PERMS_CHRS_MASK;\n\n\tif (mask & AA_MAY_GETATTR)\n\t\tm |= MAY_READ;\n\tif (mask & (AA_MAY_SETATTR | AA_MAY_CHMOD | AA_MAY_CHOWN))\n\t\tm |= MAY_WRITE;\n\n\treturn m;\n}",
          "includes": [
            "#include \"include/label.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/tty.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic u32 map_mask_to_chr_mask(u32 mask)\n{\n\tu32 m = mask & PERMS_CHRS_MASK;\n\n\tif (mask & AA_MAY_GETATTR)\n\t\tm |= MAY_READ;\n\tif (mask & (AA_MAY_SETATTR | AA_MAY_CHMOD | AA_MAY_CHOWN))\n\t\tm |= MAY_WRITE;\n\n\treturn m;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic void audit_file_mask(struct audit_buffer *ab, u32 mask)\n{\n\tchar str[10];\n\n\taa_perm_mask_to_str(str, aa_file_perm_chrs, map_mask_to_chr_mask(mask));\n\taudit_log_string(ab, str);\n}"
  },
  {
    "function_name": "map_mask_to_chr_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/file.c",
    "lines": "28-38",
    "snippet": "static u32 map_mask_to_chr_mask(u32 mask)\n{\n\tu32 m = mask & PERMS_CHRS_MASK;\n\n\tif (mask & AA_MAY_GETATTR)\n\t\tm |= MAY_READ;\n\tif (mask & (AA_MAY_SETATTR | AA_MAY_CHMOD | AA_MAY_CHOWN))\n\t\tm |= MAY_WRITE;\n\n\treturn m;\n}",
    "includes": [
      "#include \"include/label.h\"",
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/tty.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"include/label.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/tty.h>\n\nstatic u32 map_mask_to_chr_mask(u32 mask)\n{\n\tu32 m = mask & PERMS_CHRS_MASK;\n\n\tif (mask & AA_MAY_GETATTR)\n\t\tm |= MAY_READ;\n\tif (mask & (AA_MAY_SETATTR | AA_MAY_CHMOD | AA_MAY_CHOWN))\n\t\tm |= MAY_WRITE;\n\n\treturn m;\n}"
  }
]