[
  {
    "function_name": "selinux_xfrm_postroute_last",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "434-468",
    "snippet": "int selinux_xfrm_postroute_last(u32 sk_sid, struct sk_buff *skb,\n\t\t\t\tstruct common_audit_data *ad, u8 proto)\n{\n\tstruct dst_entry *dst;\n\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\tcase IPPROTO_ESP:\n\tcase IPPROTO_COMP:\n\t\t/* We should have already seen this packet once before it\n\t\t * underwent xfrm(s). No need to subject it to the unlabeled\n\t\t * check. */\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdst = skb_dst(skb);\n\tif (dst) {\n\t\tstruct dst_entry *iter;\n\n\t\tfor (iter = dst; iter != NULL; iter = iter->child) {\n\t\t\tstruct xfrm_state *x = iter->xfrm;\n\n\t\t\tif (x && selinux_authorizable_xfrm(x))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* This check even when there's no association involved is intended,\n\t * according to Trent Jaeger, to make sure a process can't engage in\n\t * non-IPsec communication unless explicitly allowed by policy. */\n\treturn avc_has_perm(sk_sid, SECINITSID_UNLABELED,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__SENDTO, ad);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "sk_sid",
            "SECINITSID_UNLABELED",
            "SECCLASS_ASSOCIATION",
            "ASSOCIATION__SENDTO",
            "ad"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_authorizable_xfrm",
          "args": [
            "x"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_authorizable_xfrm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "68-71",
          "snippet": "static inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_dst",
          "args": [
            "skb"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint selinux_xfrm_postroute_last(u32 sk_sid, struct sk_buff *skb,\n\t\t\t\tstruct common_audit_data *ad, u8 proto)\n{\n\tstruct dst_entry *dst;\n\n\tswitch (proto) {\n\tcase IPPROTO_AH:\n\tcase IPPROTO_ESP:\n\tcase IPPROTO_COMP:\n\t\t/* We should have already seen this packet once before it\n\t\t * underwent xfrm(s). No need to subject it to the unlabeled\n\t\t * check. */\n\t\treturn 0;\n\tdefault:\n\t\tbreak;\n\t}\n\n\tdst = skb_dst(skb);\n\tif (dst) {\n\t\tstruct dst_entry *iter;\n\n\t\tfor (iter = dst; iter != NULL; iter = iter->child) {\n\t\t\tstruct xfrm_state *x = iter->xfrm;\n\n\t\t\tif (x && selinux_authorizable_xfrm(x))\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* This check even when there's no association involved is intended,\n\t * according to Trent Jaeger, to make sure a process can't engage in\n\t * non-IPsec communication unless explicitly allowed by policy. */\n\treturn avc_has_perm(sk_sid, SECINITSID_UNLABELED,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__SENDTO, ad);\n}"
  },
  {
    "function_name": "selinux_xfrm_sock_rcv_skb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "401-425",
    "snippet": "int selinux_xfrm_sock_rcv_skb(u32 sk_sid, struct sk_buff *skb,\n\t\t\t      struct common_audit_data *ad)\n{\n\tint i;\n\tstruct sec_path *sp = skb->sp;\n\tu32 peer_sid = SECINITSID_UNLABELED;\n\n\tif (sp) {\n\t\tfor (i = 0; i < sp->len; i++) {\n\t\t\tstruct xfrm_state *x = sp->xvec[i];\n\n\t\t\tif (x && selinux_authorizable_xfrm(x)) {\n\t\t\t\tstruct xfrm_sec_ctx *ctx = x->security;\n\t\t\t\tpeer_sid = ctx->ctx_sid;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* This check even when there's no association involved is intended,\n\t * according to Trent Jaeger, to make sure a process can't engage in\n\t * non-IPsec communication unless explicitly allowed by policy. */\n\treturn avc_has_perm(sk_sid, peer_sid,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__RECVFROM, ad);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "sk_sid",
            "peer_sid",
            "SECCLASS_ASSOCIATION",
            "ASSOCIATION__RECVFROM",
            "ad"
          ],
          "line": 423
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_authorizable_xfrm",
          "args": [
            "x"
          ],
          "line": 412
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_authorizable_xfrm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "68-71",
          "snippet": "static inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint selinux_xfrm_sock_rcv_skb(u32 sk_sid, struct sk_buff *skb,\n\t\t\t      struct common_audit_data *ad)\n{\n\tint i;\n\tstruct sec_path *sp = skb->sp;\n\tu32 peer_sid = SECINITSID_UNLABELED;\n\n\tif (sp) {\n\t\tfor (i = 0; i < sp->len; i++) {\n\t\t\tstruct xfrm_state *x = sp->xvec[i];\n\n\t\t\tif (x && selinux_authorizable_xfrm(x)) {\n\t\t\t\tstruct xfrm_sec_ctx *ctx = x->security;\n\t\t\t\tpeer_sid = ctx->ctx_sid;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* This check even when there's no association involved is intended,\n\t * according to Trent Jaeger, to make sure a process can't engage in\n\t * non-IPsec communication unless explicitly allowed by policy. */\n\treturn avc_has_perm(sk_sid, peer_sid,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__RECVFROM, ad);\n}"
  },
  {
    "function_name": "selinux_xfrm_state_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "389-392",
    "snippet": "int selinux_xfrm_state_delete(struct xfrm_state *x)\n{\n\treturn selinux_xfrm_delete(x->security);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_xfrm_delete",
          "args": [
            "x->security"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_xfrm_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "137-147",
          "snippet": "static int selinux_xfrm_delete(struct xfrm_sec_ctx *ctx)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\tif (!ctx)\n\t\treturn 0;\n\n\treturn avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT,\n\t\t\t    NULL);\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int selinux_xfrm_delete(struct xfrm_sec_ctx *ctx)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\tif (!ctx)\n\t\treturn 0;\n\n\treturn avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT,\n\t\t\t    NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint selinux_xfrm_state_delete(struct xfrm_state *x)\n{\n\treturn selinux_xfrm_delete(x->security);\n}"
  },
  {
    "function_name": "selinux_xfrm_state_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "381-384",
    "snippet": "void selinux_xfrm_state_free(struct xfrm_state *x)\n{\n\tselinux_xfrm_free(x->security);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_xfrm_free",
          "args": [
            "x->security"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_xfrm_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "125-132",
          "snippet": "static void selinux_xfrm_free(struct xfrm_sec_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tatomic_dec(&selinux_xfrm_refcount);\n\tkfree(ctx);\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\natomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);\n\nstatic void selinux_xfrm_free(struct xfrm_sec_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tatomic_dec(&selinux_xfrm_refcount);\n\tkfree(ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid selinux_xfrm_state_free(struct xfrm_state *x)\n{\n\tselinux_xfrm_free(x->security);\n}"
  },
  {
    "function_name": "selinux_xfrm_state_alloc_acquire",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "341-376",
    "snippet": "int selinux_xfrm_state_alloc_acquire(struct xfrm_state *x,\n\t\t\t\t     struct xfrm_sec_ctx *polsec, u32 secid)\n{\n\tint rc;\n\tstruct xfrm_sec_ctx *ctx;\n\tchar *ctx_str = NULL;\n\tint str_len;\n\n\tif (!polsec)\n\t\treturn 0;\n\n\tif (secid == 0)\n\t\treturn -EINVAL;\n\n\trc = security_sid_to_context(secid, &ctx_str, &str_len);\n\tif (rc)\n\t\treturn rc;\n\n\tctx = kmalloc(sizeof(*ctx) + str_len, GFP_ATOMIC);\n\tif (!ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tctx->ctx_doi = XFRM_SC_DOI_LSM;\n\tctx->ctx_alg = XFRM_SC_ALG_SELINUX;\n\tctx->ctx_sid = secid;\n\tctx->ctx_len = str_len;\n\tmemcpy(ctx->ctx_str, ctx_str, str_len);\n\n\tx->security = ctx;\n\tatomic_inc(&selinux_xfrm_refcount);\nout:\n\tkfree(ctx_str);\n\treturn rc;\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx_str"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&selinux_xfrm_refcount"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ctx->ctx_str",
            "ctx_str",
            "str_len"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ctx) + str_len",
            "GFP_ATOMIC"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_sid_to_context",
          "args": [
            "secid",
            "&ctx_str",
            "&str_len"
          ],
          "line": 355
        },
        "resolved": true,
        "details": {
          "function_name": "security_sid_to_context_force",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1314-1317",
          "snippet": "int security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_sid_to_context_force(u32 sid, char **scontext, u32 *scontext_len)\n{\n\treturn security_sid_to_context_core(sid, scontext, scontext_len, 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\natomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);\n\nint selinux_xfrm_state_alloc_acquire(struct xfrm_state *x,\n\t\t\t\t     struct xfrm_sec_ctx *polsec, u32 secid)\n{\n\tint rc;\n\tstruct xfrm_sec_ctx *ctx;\n\tchar *ctx_str = NULL;\n\tint str_len;\n\n\tif (!polsec)\n\t\treturn 0;\n\n\tif (secid == 0)\n\t\treturn -EINVAL;\n\n\trc = security_sid_to_context(secid, &ctx_str, &str_len);\n\tif (rc)\n\t\treturn rc;\n\n\tctx = kmalloc(sizeof(*ctx) + str_len, GFP_ATOMIC);\n\tif (!ctx) {\n\t\trc = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tctx->ctx_doi = XFRM_SC_DOI_LSM;\n\tctx->ctx_alg = XFRM_SC_ALG_SELINUX;\n\tctx->ctx_sid = secid;\n\tctx->ctx_len = str_len;\n\tmemcpy(ctx->ctx_str, ctx_str, str_len);\n\n\tx->security = ctx;\n\tatomic_inc(&selinux_xfrm_refcount);\nout:\n\tkfree(ctx_str);\n\treturn rc;\n}"
  },
  {
    "function_name": "selinux_xfrm_state_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "331-335",
    "snippet": "int selinux_xfrm_state_alloc(struct xfrm_state *x,\n\t\t\t     struct xfrm_user_sec_ctx *uctx)\n{\n\treturn selinux_xfrm_alloc_user(&x->security, uctx, GFP_KERNEL);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_xfrm_alloc_user",
          "args": [
            "&x->security",
            "uctx",
            "GFP_KERNEL"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_xfrm_alloc_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "77-120",
          "snippet": "static int selinux_xfrm_alloc_user(struct xfrm_sec_ctx **ctxp,\n\t\t\t\t   struct xfrm_user_sec_ctx *uctx,\n\t\t\t\t   gfp_t gfp)\n{\n\tint rc;\n\tconst struct task_security_struct *tsec = current_security();\n\tstruct xfrm_sec_ctx *ctx = NULL;\n\tu32 str_len;\n\n\tif (ctxp == NULL || uctx == NULL ||\n\t    uctx->ctx_doi != XFRM_SC_DOI_LSM ||\n\t    uctx->ctx_alg != XFRM_SC_ALG_SELINUX)\n\t\treturn -EINVAL;\n\n\tstr_len = uctx->ctx_len;\n\tif (str_len >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\tctx = kmalloc(sizeof(*ctx) + str_len + 1, gfp);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ctx_doi = XFRM_SC_DOI_LSM;\n\tctx->ctx_alg = XFRM_SC_ALG_SELINUX;\n\tctx->ctx_len = str_len;\n\tmemcpy(ctx->ctx_str, &uctx[1], str_len);\n\tctx->ctx_str[str_len] = '\\0';\n\trc = security_context_to_sid(ctx->ctx_str, str_len, &ctx->ctx_sid, gfp);\n\tif (rc)\n\t\tgoto err;\n\n\trc = avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t  SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\t*ctxp = ctx;\n\tatomic_inc(&selinux_xfrm_refcount);\n\treturn 0;\n\nerr:\n\tkfree(ctx);\n\treturn rc;\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\natomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);\n\nstatic int selinux_xfrm_alloc_user(struct xfrm_sec_ctx **ctxp,\n\t\t\t\t   struct xfrm_user_sec_ctx *uctx,\n\t\t\t\t   gfp_t gfp)\n{\n\tint rc;\n\tconst struct task_security_struct *tsec = current_security();\n\tstruct xfrm_sec_ctx *ctx = NULL;\n\tu32 str_len;\n\n\tif (ctxp == NULL || uctx == NULL ||\n\t    uctx->ctx_doi != XFRM_SC_DOI_LSM ||\n\t    uctx->ctx_alg != XFRM_SC_ALG_SELINUX)\n\t\treturn -EINVAL;\n\n\tstr_len = uctx->ctx_len;\n\tif (str_len >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\tctx = kmalloc(sizeof(*ctx) + str_len + 1, gfp);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ctx_doi = XFRM_SC_DOI_LSM;\n\tctx->ctx_alg = XFRM_SC_ALG_SELINUX;\n\tctx->ctx_len = str_len;\n\tmemcpy(ctx->ctx_str, &uctx[1], str_len);\n\tctx->ctx_str[str_len] = '\\0';\n\trc = security_context_to_sid(ctx->ctx_str, str_len, &ctx->ctx_sid, gfp);\n\tif (rc)\n\t\tgoto err;\n\n\trc = avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t  SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\t*ctxp = ctx;\n\tatomic_inc(&selinux_xfrm_refcount);\n\treturn 0;\n\nerr:\n\tkfree(ctx);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint selinux_xfrm_state_alloc(struct xfrm_state *x,\n\t\t\t     struct xfrm_user_sec_ctx *uctx)\n{\n\treturn selinux_xfrm_alloc_user(&x->security, uctx, GFP_KERNEL);\n}"
  },
  {
    "function_name": "selinux_xfrm_policy_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "322-325",
    "snippet": "int selinux_xfrm_policy_delete(struct xfrm_sec_ctx *ctx)\n{\n\treturn selinux_xfrm_delete(ctx);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_xfrm_delete",
          "args": [
            "ctx"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_xfrm_delete",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "137-147",
          "snippet": "static int selinux_xfrm_delete(struct xfrm_sec_ctx *ctx)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\tif (!ctx)\n\t\treturn 0;\n\n\treturn avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT,\n\t\t\t    NULL);\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int selinux_xfrm_delete(struct xfrm_sec_ctx *ctx)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\tif (!ctx)\n\t\treturn 0;\n\n\treturn avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT,\n\t\t\t    NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint selinux_xfrm_policy_delete(struct xfrm_sec_ctx *ctx)\n{\n\treturn selinux_xfrm_delete(ctx);\n}"
  },
  {
    "function_name": "selinux_xfrm_policy_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "314-317",
    "snippet": "void selinux_xfrm_policy_free(struct xfrm_sec_ctx *ctx)\n{\n\tselinux_xfrm_free(ctx);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_xfrm_free",
          "args": [
            "ctx"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_xfrm_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "125-132",
          "snippet": "static void selinux_xfrm_free(struct xfrm_sec_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tatomic_dec(&selinux_xfrm_refcount);\n\tkfree(ctx);\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\natomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);\n\nstatic void selinux_xfrm_free(struct xfrm_sec_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tatomic_dec(&selinux_xfrm_refcount);\n\tkfree(ctx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nvoid selinux_xfrm_policy_free(struct xfrm_sec_ctx *ctx)\n{\n\tselinux_xfrm_free(ctx);\n}"
  },
  {
    "function_name": "selinux_xfrm_policy_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "293-309",
    "snippet": "int selinux_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx,\n\t\t\t      struct xfrm_sec_ctx **new_ctxp)\n{\n\tstruct xfrm_sec_ctx *new_ctx;\n\n\tif (!old_ctx)\n\t\treturn 0;\n\n\tnew_ctx = kmemdup(old_ctx, sizeof(*old_ctx) + old_ctx->ctx_len,\n\t\t\t  GFP_ATOMIC);\n\tif (!new_ctx)\n\t\treturn -ENOMEM;\n\tatomic_inc(&selinux_xfrm_refcount);\n\t*new_ctxp = new_ctx;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&selinux_xfrm_refcount"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "old_ctx",
            "sizeof(*old_ctx) + old_ctx->ctx_len",
            "GFP_ATOMIC"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\natomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);\n\nint selinux_xfrm_policy_clone(struct xfrm_sec_ctx *old_ctx,\n\t\t\t      struct xfrm_sec_ctx **new_ctxp)\n{\n\tstruct xfrm_sec_ctx *new_ctx;\n\n\tif (!old_ctx)\n\t\treturn 0;\n\n\tnew_ctx = kmemdup(old_ctx, sizeof(*old_ctx) + old_ctx->ctx_len,\n\t\t\t  GFP_ATOMIC);\n\tif (!new_ctx)\n\t\treturn -ENOMEM;\n\tatomic_inc(&selinux_xfrm_refcount);\n\t*new_ctxp = new_ctx;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "selinux_xfrm_policy_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "282-287",
    "snippet": "int selinux_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,\n\t\t\t      struct xfrm_user_sec_ctx *uctx,\n\t\t\t      gfp_t gfp)\n{\n\treturn selinux_xfrm_alloc_user(ctxp, uctx, gfp);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_xfrm_alloc_user",
          "args": [
            "ctxp",
            "uctx",
            "gfp"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_xfrm_alloc_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "77-120",
          "snippet": "static int selinux_xfrm_alloc_user(struct xfrm_sec_ctx **ctxp,\n\t\t\t\t   struct xfrm_user_sec_ctx *uctx,\n\t\t\t\t   gfp_t gfp)\n{\n\tint rc;\n\tconst struct task_security_struct *tsec = current_security();\n\tstruct xfrm_sec_ctx *ctx = NULL;\n\tu32 str_len;\n\n\tif (ctxp == NULL || uctx == NULL ||\n\t    uctx->ctx_doi != XFRM_SC_DOI_LSM ||\n\t    uctx->ctx_alg != XFRM_SC_ALG_SELINUX)\n\t\treturn -EINVAL;\n\n\tstr_len = uctx->ctx_len;\n\tif (str_len >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\tctx = kmalloc(sizeof(*ctx) + str_len + 1, gfp);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ctx_doi = XFRM_SC_DOI_LSM;\n\tctx->ctx_alg = XFRM_SC_ALG_SELINUX;\n\tctx->ctx_len = str_len;\n\tmemcpy(ctx->ctx_str, &uctx[1], str_len);\n\tctx->ctx_str[str_len] = '\\0';\n\trc = security_context_to_sid(ctx->ctx_str, str_len, &ctx->ctx_sid, gfp);\n\tif (rc)\n\t\tgoto err;\n\n\trc = avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t  SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\t*ctxp = ctx;\n\tatomic_inc(&selinux_xfrm_refcount);\n\treturn 0;\n\nerr:\n\tkfree(ctx);\n\treturn rc;\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "atomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\natomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);\n\nstatic int selinux_xfrm_alloc_user(struct xfrm_sec_ctx **ctxp,\n\t\t\t\t   struct xfrm_user_sec_ctx *uctx,\n\t\t\t\t   gfp_t gfp)\n{\n\tint rc;\n\tconst struct task_security_struct *tsec = current_security();\n\tstruct xfrm_sec_ctx *ctx = NULL;\n\tu32 str_len;\n\n\tif (ctxp == NULL || uctx == NULL ||\n\t    uctx->ctx_doi != XFRM_SC_DOI_LSM ||\n\t    uctx->ctx_alg != XFRM_SC_ALG_SELINUX)\n\t\treturn -EINVAL;\n\n\tstr_len = uctx->ctx_len;\n\tif (str_len >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\tctx = kmalloc(sizeof(*ctx) + str_len + 1, gfp);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ctx_doi = XFRM_SC_DOI_LSM;\n\tctx->ctx_alg = XFRM_SC_ALG_SELINUX;\n\tctx->ctx_len = str_len;\n\tmemcpy(ctx->ctx_str, &uctx[1], str_len);\n\tctx->ctx_str[str_len] = '\\0';\n\trc = security_context_to_sid(ctx->ctx_str, str_len, &ctx->ctx_sid, gfp);\n\tif (rc)\n\t\tgoto err;\n\n\trc = avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t  SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\t*ctxp = ctx;\n\tatomic_inc(&selinux_xfrm_refcount);\n\treturn 0;\n\nerr:\n\tkfree(ctx);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint selinux_xfrm_policy_alloc(struct xfrm_sec_ctx **ctxp,\n\t\t\t      struct xfrm_user_sec_ctx *uctx,\n\t\t\t      gfp_t gfp)\n{\n\treturn selinux_xfrm_alloc_user(ctxp, uctx, gfp);\n}"
  },
  {
    "function_name": "selinux_xfrm_skb_sid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "268-277",
    "snippet": "int selinux_xfrm_skb_sid(struct sk_buff *skb, u32 *sid)\n{\n\tint rc;\n\n\trc = selinux_xfrm_skb_sid_ingress(skb, sid, 0);\n\tif (rc == 0 && *sid == SECSID_NULL)\n\t\t*sid = selinux_xfrm_skb_sid_egress(skb);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_xfrm_skb_sid_egress",
          "args": [
            "skb"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_xfrm_skb_sid_egress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "210-222",
          "snippet": "static u32 selinux_xfrm_skb_sid_egress(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct xfrm_state *x;\n\n\tif (dst == NULL)\n\t\treturn SECSID_NULL;\n\tx = dst->xfrm;\n\tif (x == NULL || !selinux_authorizable_xfrm(x))\n\t\treturn SECSID_NULL;\n\n\treturn x->security->ctx_sid;\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic u32 selinux_xfrm_skb_sid_egress(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct xfrm_state *x;\n\n\tif (dst == NULL)\n\t\treturn SECSID_NULL;\n\tx = dst->xfrm;\n\tif (x == NULL || !selinux_authorizable_xfrm(x))\n\t\treturn SECSID_NULL;\n\n\treturn x->security->ctx_sid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_xfrm_skb_sid_ingress",
          "args": [
            "skb",
            "sid",
            "0"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_xfrm_skb_sid_ingress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "224-253",
          "snippet": "static int selinux_xfrm_skb_sid_ingress(struct sk_buff *skb,\n\t\t\t\t\tu32 *sid, int ckall)\n{\n\tu32 sid_session = SECSID_NULL;\n\tstruct sec_path *sp = skb->sp;\n\n\tif (sp) {\n\t\tint i;\n\n\t\tfor (i = sp->len - 1; i >= 0; i--) {\n\t\t\tstruct xfrm_state *x = sp->xvec[i];\n\t\t\tif (selinux_authorizable_xfrm(x)) {\n\t\t\t\tstruct xfrm_sec_ctx *ctx = x->security;\n\n\t\t\t\tif (sid_session == SECSID_NULL) {\n\t\t\t\t\tsid_session = ctx->ctx_sid;\n\t\t\t\t\tif (!ckall)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t} else if (sid_session != ctx->ctx_sid) {\n\t\t\t\t\t*sid = SECSID_NULL;\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\t*sid = sid_session;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int selinux_xfrm_skb_sid_ingress(struct sk_buff *skb,\n\t\t\t\t\tu32 *sid, int ckall)\n{\n\tu32 sid_session = SECSID_NULL;\n\tstruct sec_path *sp = skb->sp;\n\n\tif (sp) {\n\t\tint i;\n\n\t\tfor (i = sp->len - 1; i >= 0; i--) {\n\t\t\tstruct xfrm_state *x = sp->xvec[i];\n\t\t\tif (selinux_authorizable_xfrm(x)) {\n\t\t\t\tstruct xfrm_sec_ctx *ctx = x->security;\n\n\t\t\t\tif (sid_session == SECSID_NULL) {\n\t\t\t\t\tsid_session = ctx->ctx_sid;\n\t\t\t\t\tif (!ckall)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t} else if (sid_session != ctx->ctx_sid) {\n\t\t\t\t\t*sid = SECSID_NULL;\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\t*sid = sid_session;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint selinux_xfrm_skb_sid(struct sk_buff *skb, u32 *sid)\n{\n\tint rc;\n\n\trc = selinux_xfrm_skb_sid_ingress(skb, sid, 0);\n\tif (rc == 0 && *sid == SECSID_NULL)\n\t\t*sid = selinux_xfrm_skb_sid_egress(skb);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "selinux_xfrm_decode_session",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "259-266",
    "snippet": "int selinux_xfrm_decode_session(struct sk_buff *skb, u32 *sid, int ckall)\n{\n\tif (skb == NULL) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\treturn selinux_xfrm_skb_sid_ingress(skb, sid, ckall);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_xfrm_skb_sid_ingress",
          "args": [
            "skb",
            "sid",
            "ckall"
          ],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_xfrm_skb_sid_ingress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "224-253",
          "snippet": "static int selinux_xfrm_skb_sid_ingress(struct sk_buff *skb,\n\t\t\t\t\tu32 *sid, int ckall)\n{\n\tu32 sid_session = SECSID_NULL;\n\tstruct sec_path *sp = skb->sp;\n\n\tif (sp) {\n\t\tint i;\n\n\t\tfor (i = sp->len - 1; i >= 0; i--) {\n\t\t\tstruct xfrm_state *x = sp->xvec[i];\n\t\t\tif (selinux_authorizable_xfrm(x)) {\n\t\t\t\tstruct xfrm_sec_ctx *ctx = x->security;\n\n\t\t\t\tif (sid_session == SECSID_NULL) {\n\t\t\t\t\tsid_session = ctx->ctx_sid;\n\t\t\t\t\tif (!ckall)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t} else if (sid_session != ctx->ctx_sid) {\n\t\t\t\t\t*sid = SECSID_NULL;\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\t*sid = sid_session;\n\treturn 0;\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int selinux_xfrm_skb_sid_ingress(struct sk_buff *skb,\n\t\t\t\t\tu32 *sid, int ckall)\n{\n\tu32 sid_session = SECSID_NULL;\n\tstruct sec_path *sp = skb->sp;\n\n\tif (sp) {\n\t\tint i;\n\n\t\tfor (i = sp->len - 1; i >= 0; i--) {\n\t\t\tstruct xfrm_state *x = sp->xvec[i];\n\t\t\tif (selinux_authorizable_xfrm(x)) {\n\t\t\t\tstruct xfrm_sec_ctx *ctx = x->security;\n\n\t\t\t\tif (sid_session == SECSID_NULL) {\n\t\t\t\t\tsid_session = ctx->ctx_sid;\n\t\t\t\t\tif (!ckall)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t} else if (sid_session != ctx->ctx_sid) {\n\t\t\t\t\t*sid = SECSID_NULL;\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\t*sid = sid_session;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint selinux_xfrm_decode_session(struct sk_buff *skb, u32 *sid, int ckall)\n{\n\tif (skb == NULL) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\treturn selinux_xfrm_skb_sid_ingress(skb, sid, ckall);\n}"
  },
  {
    "function_name": "selinux_xfrm_skb_sid_ingress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "224-253",
    "snippet": "static int selinux_xfrm_skb_sid_ingress(struct sk_buff *skb,\n\t\t\t\t\tu32 *sid, int ckall)\n{\n\tu32 sid_session = SECSID_NULL;\n\tstruct sec_path *sp = skb->sp;\n\n\tif (sp) {\n\t\tint i;\n\n\t\tfor (i = sp->len - 1; i >= 0; i--) {\n\t\t\tstruct xfrm_state *x = sp->xvec[i];\n\t\t\tif (selinux_authorizable_xfrm(x)) {\n\t\t\t\tstruct xfrm_sec_ctx *ctx = x->security;\n\n\t\t\t\tif (sid_session == SECSID_NULL) {\n\t\t\t\t\tsid_session = ctx->ctx_sid;\n\t\t\t\t\tif (!ckall)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t} else if (sid_session != ctx->ctx_sid) {\n\t\t\t\t\t*sid = SECSID_NULL;\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\t*sid = sid_session;\n\treturn 0;\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_authorizable_xfrm",
          "args": [
            "x"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_authorizable_xfrm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "68-71",
          "snippet": "static inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int selinux_xfrm_skb_sid_ingress(struct sk_buff *skb,\n\t\t\t\t\tu32 *sid, int ckall)\n{\n\tu32 sid_session = SECSID_NULL;\n\tstruct sec_path *sp = skb->sp;\n\n\tif (sp) {\n\t\tint i;\n\n\t\tfor (i = sp->len - 1; i >= 0; i--) {\n\t\t\tstruct xfrm_state *x = sp->xvec[i];\n\t\t\tif (selinux_authorizable_xfrm(x)) {\n\t\t\t\tstruct xfrm_sec_ctx *ctx = x->security;\n\n\t\t\t\tif (sid_session == SECSID_NULL) {\n\t\t\t\t\tsid_session = ctx->ctx_sid;\n\t\t\t\t\tif (!ckall)\n\t\t\t\t\t\tgoto out;\n\t\t\t\t} else if (sid_session != ctx->ctx_sid) {\n\t\t\t\t\t*sid = SECSID_NULL;\n\t\t\t\t\treturn -EINVAL;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\nout:\n\t*sid = sid_session;\n\treturn 0;\n}"
  },
  {
    "function_name": "selinux_xfrm_skb_sid_egress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "210-222",
    "snippet": "static u32 selinux_xfrm_skb_sid_egress(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct xfrm_state *x;\n\n\tif (dst == NULL)\n\t\treturn SECSID_NULL;\n\tx = dst->xfrm;\n\tif (x == NULL || !selinux_authorizable_xfrm(x))\n\t\treturn SECSID_NULL;\n\n\treturn x->security->ctx_sid;\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_authorizable_xfrm",
          "args": [
            "x"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_authorizable_xfrm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "68-71",
          "snippet": "static inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_dst",
          "args": [
            "skb"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic u32 selinux_xfrm_skb_sid_egress(struct sk_buff *skb)\n{\n\tstruct dst_entry *dst = skb_dst(skb);\n\tstruct xfrm_state *x;\n\n\tif (dst == NULL)\n\t\treturn SECSID_NULL;\n\tx = dst->xfrm;\n\tif (x == NULL || !selinux_authorizable_xfrm(x))\n\t\treturn SECSID_NULL;\n\n\treturn x->security->ctx_sid;\n}"
  },
  {
    "function_name": "selinux_xfrm_state_pol_flow_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "175-208",
    "snippet": "int selinux_xfrm_state_pol_flow_match(struct xfrm_state *x,\n\t\t\t\t      struct xfrm_policy *xp,\n\t\t\t\t      const struct flowi *fl)\n{\n\tu32 state_sid;\n\n\tif (!xp->security)\n\t\tif (x->security)\n\t\t\t/* unlabeled policy and labeled SA can't match */\n\t\t\treturn 0;\n\t\telse\n\t\t\t/* unlabeled policy and unlabeled SA match all flows */\n\t\t\treturn 1;\n\telse\n\t\tif (!x->security)\n\t\t\t/* unlabeled SA and labeled policy can't match */\n\t\t\treturn 0;\n\t\telse\n\t\t\tif (!selinux_authorizable_xfrm(x))\n\t\t\t\t/* Not a SELinux-labeled SA */\n\t\t\t\treturn 0;\n\n\tstate_sid = x->security->ctx_sid;\n\n\tif (fl->flowi_secid != state_sid)\n\t\treturn 0;\n\n\t/* We don't need a separate SA Vs. policy polmatch check since the SA\n\t * is now of the same label as the flow and a flow Vs. policy polmatch\n\t * check had already happened in selinux_xfrm_policy_lookup() above. */\n\treturn (avc_has_perm(fl->flowi_secid, state_sid,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__SENDTO,\n\t\t\t    NULL) ? 0 : 1);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "fl->flowi_secid",
            "state_sid",
            "SECCLASS_ASSOCIATION",
            "ASSOCIATION__SENDTO",
            "NULL"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_authorizable_xfrm",
          "args": [
            "x"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_authorizable_xfrm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "68-71",
          "snippet": "static inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint selinux_xfrm_state_pol_flow_match(struct xfrm_state *x,\n\t\t\t\t      struct xfrm_policy *xp,\n\t\t\t\t      const struct flowi *fl)\n{\n\tu32 state_sid;\n\n\tif (!xp->security)\n\t\tif (x->security)\n\t\t\t/* unlabeled policy and labeled SA can't match */\n\t\t\treturn 0;\n\t\telse\n\t\t\t/* unlabeled policy and unlabeled SA match all flows */\n\t\t\treturn 1;\n\telse\n\t\tif (!x->security)\n\t\t\t/* unlabeled SA and labeled policy can't match */\n\t\t\treturn 0;\n\t\telse\n\t\t\tif (!selinux_authorizable_xfrm(x))\n\t\t\t\t/* Not a SELinux-labeled SA */\n\t\t\t\treturn 0;\n\n\tstate_sid = x->security->ctx_sid;\n\n\tif (fl->flowi_secid != state_sid)\n\t\treturn 0;\n\n\t/* We don't need a separate SA Vs. policy polmatch check since the SA\n\t * is now of the same label as the flow and a flow Vs. policy polmatch\n\t * check had already happened in selinux_xfrm_policy_lookup() above. */\n\treturn (avc_has_perm(fl->flowi_secid, state_sid,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__SENDTO,\n\t\t\t    NULL) ? 0 : 1);\n}"
  },
  {
    "function_name": "selinux_xfrm_policy_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "153-169",
    "snippet": "int selinux_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid, u8 dir)\n{\n\tint rc;\n\n\t/* All flows should be treated as polmatch'ing an otherwise applicable\n\t * \"non-labeled\" policy. This would prevent inadvertent \"leaks\". */\n\tif (!ctx)\n\t\treturn 0;\n\n\t/* Context sid is either set to label or ANY_ASSOC */\n\tif (!selinux_authorizable_ctx(ctx))\n\t\treturn -EINVAL;\n\n\trc = avc_has_perm(fl_secid, ctx->ctx_sid,\n\t\t\t  SECCLASS_ASSOCIATION, ASSOCIATION__POLMATCH, NULL);\n\treturn (rc == -EACCES ? -ESRCH : rc);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "fl_secid",
            "ctx->ctx_sid",
            "SECCLASS_ASSOCIATION",
            "ASSOCIATION__POLMATCH",
            "NULL"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "selinux_authorizable_ctx",
          "args": [
            "ctx"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_authorizable_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "58-63",
          "snippet": "static inline int selinux_authorizable_ctx(struct xfrm_sec_ctx *ctx)\n{\n\treturn (ctx &&\n\t\t(ctx->ctx_doi == XFRM_SC_DOI_LSM) &&\n\t\t(ctx->ctx_alg == XFRM_SC_ALG_SELINUX));\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline int selinux_authorizable_ctx(struct xfrm_sec_ctx *ctx)\n{\n\treturn (ctx &&\n\t\t(ctx->ctx_doi == XFRM_SC_DOI_LSM) &&\n\t\t(ctx->ctx_alg == XFRM_SC_ALG_SELINUX));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nint selinux_xfrm_policy_lookup(struct xfrm_sec_ctx *ctx, u32 fl_secid, u8 dir)\n{\n\tint rc;\n\n\t/* All flows should be treated as polmatch'ing an otherwise applicable\n\t * \"non-labeled\" policy. This would prevent inadvertent \"leaks\". */\n\tif (!ctx)\n\t\treturn 0;\n\n\t/* Context sid is either set to label or ANY_ASSOC */\n\tif (!selinux_authorizable_ctx(ctx))\n\t\treturn -EINVAL;\n\n\trc = avc_has_perm(fl_secid, ctx->ctx_sid,\n\t\t\t  SECCLASS_ASSOCIATION, ASSOCIATION__POLMATCH, NULL);\n\treturn (rc == -EACCES ? -ESRCH : rc);\n}"
  },
  {
    "function_name": "selinux_xfrm_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "137-147",
    "snippet": "static int selinux_xfrm_delete(struct xfrm_sec_ctx *ctx)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\tif (!ctx)\n\t\treturn 0;\n\n\treturn avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT,\n\t\t\t    NULL);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "tsec->sid",
            "ctx->ctx_sid",
            "SECCLASS_ASSOCIATION",
            "ASSOCIATION__SETCONTEXT",
            "NULL"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic int selinux_xfrm_delete(struct xfrm_sec_ctx *ctx)\n{\n\tconst struct task_security_struct *tsec = current_security();\n\n\tif (!ctx)\n\t\treturn 0;\n\n\treturn avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t    SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT,\n\t\t\t    NULL);\n}"
  },
  {
    "function_name": "selinux_xfrm_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "125-132",
    "snippet": "static void selinux_xfrm_free(struct xfrm_sec_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tatomic_dec(&selinux_xfrm_refcount);\n\tkfree(ctx);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&selinux_xfrm_refcount"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\natomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);\n\nstatic void selinux_xfrm_free(struct xfrm_sec_ctx *ctx)\n{\n\tif (!ctx)\n\t\treturn;\n\n\tatomic_dec(&selinux_xfrm_refcount);\n\tkfree(ctx);\n}"
  },
  {
    "function_name": "selinux_xfrm_alloc_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "77-120",
    "snippet": "static int selinux_xfrm_alloc_user(struct xfrm_sec_ctx **ctxp,\n\t\t\t\t   struct xfrm_user_sec_ctx *uctx,\n\t\t\t\t   gfp_t gfp)\n{\n\tint rc;\n\tconst struct task_security_struct *tsec = current_security();\n\tstruct xfrm_sec_ctx *ctx = NULL;\n\tu32 str_len;\n\n\tif (ctxp == NULL || uctx == NULL ||\n\t    uctx->ctx_doi != XFRM_SC_DOI_LSM ||\n\t    uctx->ctx_alg != XFRM_SC_ALG_SELINUX)\n\t\treturn -EINVAL;\n\n\tstr_len = uctx->ctx_len;\n\tif (str_len >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\tctx = kmalloc(sizeof(*ctx) + str_len + 1, gfp);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ctx_doi = XFRM_SC_DOI_LSM;\n\tctx->ctx_alg = XFRM_SC_ALG_SELINUX;\n\tctx->ctx_len = str_len;\n\tmemcpy(ctx->ctx_str, &uctx[1], str_len);\n\tctx->ctx_str[str_len] = '\\0';\n\trc = security_context_to_sid(ctx->ctx_str, str_len, &ctx->ctx_sid, gfp);\n\tif (rc)\n\t\tgoto err;\n\n\trc = avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t  SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\t*ctxp = ctx;\n\tatomic_inc(&selinux_xfrm_refcount);\n\treturn 0;\n\nerr:\n\tkfree(ctx);\n\treturn rc;\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "atomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&selinux_xfrm_refcount"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "tsec->sid",
            "ctx->ctx_sid",
            "SECCLASS_ASSOCIATION",
            "ASSOCIATION__SETCONTEXT",
            "NULL"
          ],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_context_to_sid",
          "args": [
            "ctx->ctx_str",
            "str_len",
            "&ctx->ctx_sid",
            "gfp"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "security_context_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "1476-1481",
          "snippet": "int security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid,\n\t\t\t    gfp_t gfp)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, gfp, 0);\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int context_struct_to_string(struct context *context, char **scontext,\n\t\t\t\t    u32 *scontext_len);\n\nint security_context_to_sid(const char *scontext, u32 scontext_len, u32 *sid,\n\t\t\t    gfp_t gfp)\n{\n\treturn security_context_to_sid_core(scontext, scontext_len,\n\t\t\t\t\t    sid, SECSID_NULL, gfp, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "ctx->ctx_str",
            "&uctx[1]",
            "str_len"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ctx) + str_len + 1",
            "gfp"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_security",
          "args": [],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\natomic_t selinux_xfrm_refcount = ATOMIC_INIT(0);\n\nstatic int selinux_xfrm_alloc_user(struct xfrm_sec_ctx **ctxp,\n\t\t\t\t   struct xfrm_user_sec_ctx *uctx,\n\t\t\t\t   gfp_t gfp)\n{\n\tint rc;\n\tconst struct task_security_struct *tsec = current_security();\n\tstruct xfrm_sec_ctx *ctx = NULL;\n\tu32 str_len;\n\n\tif (ctxp == NULL || uctx == NULL ||\n\t    uctx->ctx_doi != XFRM_SC_DOI_LSM ||\n\t    uctx->ctx_alg != XFRM_SC_ALG_SELINUX)\n\t\treturn -EINVAL;\n\n\tstr_len = uctx->ctx_len;\n\tif (str_len >= PAGE_SIZE)\n\t\treturn -ENOMEM;\n\n\tctx = kmalloc(sizeof(*ctx) + str_len + 1, gfp);\n\tif (!ctx)\n\t\treturn -ENOMEM;\n\n\tctx->ctx_doi = XFRM_SC_DOI_LSM;\n\tctx->ctx_alg = XFRM_SC_ALG_SELINUX;\n\tctx->ctx_len = str_len;\n\tmemcpy(ctx->ctx_str, &uctx[1], str_len);\n\tctx->ctx_str[str_len] = '\\0';\n\trc = security_context_to_sid(ctx->ctx_str, str_len, &ctx->ctx_sid, gfp);\n\tif (rc)\n\t\tgoto err;\n\n\trc = avc_has_perm(tsec->sid, ctx->ctx_sid,\n\t\t\t  SECCLASS_ASSOCIATION, ASSOCIATION__SETCONTEXT, NULL);\n\tif (rc)\n\t\tgoto err;\n\n\t*ctxp = ctx;\n\tatomic_inc(&selinux_xfrm_refcount);\n\treturn 0;\n\nerr:\n\tkfree(ctx);\n\treturn rc;\n}"
  },
  {
    "function_name": "selinux_authorizable_xfrm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "68-71",
    "snippet": "static inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_authorizable_ctx",
          "args": [
            "x->security"
          ],
          "line": 70
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_authorizable_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
          "lines": "58-63",
          "snippet": "static inline int selinux_authorizable_ctx(struct xfrm_sec_ctx *ctx)\n{\n\treturn (ctx &&\n\t\t(ctx->ctx_doi == XFRM_SC_DOI_LSM) &&\n\t\t(ctx->ctx_alg == XFRM_SC_ALG_SELINUX));\n}",
          "includes": [
            "#include \"xfrm.h\"",
            "#include \"objsec.h\"",
            "#include \"avc.h\"",
            "#include <linux/atomic.h>",
            "#include <net/udp.h>",
            "#include <net/checksum.h>",
            "#include <net/xfrm.h>",
            "#include <linux/xfrm.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/tcp.h>",
            "#include <linux/ip.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/security.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline int selinux_authorizable_ctx(struct xfrm_sec_ctx *ctx)\n{\n\treturn (ctx &&\n\t\t(ctx->ctx_doi == XFRM_SC_DOI_LSM) &&\n\t\t(ctx->ctx_alg == XFRM_SC_ALG_SELINUX));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline int selinux_authorizable_xfrm(struct xfrm_state *x)\n{\n\treturn selinux_authorizable_ctx(x->security);\n}"
  },
  {
    "function_name": "selinux_authorizable_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/xfrm.c",
    "lines": "58-63",
    "snippet": "static inline int selinux_authorizable_ctx(struct xfrm_sec_ctx *ctx)\n{\n\treturn (ctx &&\n\t\t(ctx->ctx_doi == XFRM_SC_DOI_LSM) &&\n\t\t(ctx->ctx_alg == XFRM_SC_ALG_SELINUX));\n}",
    "includes": [
      "#include \"xfrm.h\"",
      "#include \"objsec.h\"",
      "#include \"avc.h\"",
      "#include <linux/atomic.h>",
      "#include <net/udp.h>",
      "#include <net/checksum.h>",
      "#include <net/xfrm.h>",
      "#include <linux/xfrm.h>",
      "#include <linux/skbuff.h>",
      "#include <linux/tcp.h>",
      "#include <linux/ip.h>",
      "#include <linux/slab.h>",
      "#include <linux/types.h>",
      "#include <linux/security.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xfrm.h\"\n#include \"objsec.h\"\n#include \"avc.h\"\n#include <linux/atomic.h>\n#include <net/udp.h>\n#include <net/checksum.h>\n#include <net/xfrm.h>\n#include <linux/xfrm.h>\n#include <linux/skbuff.h>\n#include <linux/tcp.h>\n#include <linux/ip.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/security.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n\nstatic inline int selinux_authorizable_ctx(struct xfrm_sec_ctx *ctx)\n{\n\treturn (ctx &&\n\t\t(ctx->ctx_doi == XFRM_SC_DOI_LSM) &&\n\t\t(ctx->ctx_alg == XFRM_SC_ALG_SELINUX));\n}"
  }
]