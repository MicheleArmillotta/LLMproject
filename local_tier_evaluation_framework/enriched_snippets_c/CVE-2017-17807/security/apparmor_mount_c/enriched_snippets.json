[
  {
    "function_name": "aa_pivotroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "651-695",
    "snippet": "int aa_pivotroot(struct aa_label *label, const struct path *old_path,\n\t\t const struct path *new_path)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *target = NULL;\n\tchar *old_buffer = NULL, *new_buffer = NULL, *info = NULL;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!old_path);\n\tAA_BUG(!new_path);\n\n\tget_buffers(old_buffer, new_buffer);\n\ttarget = fn_label_build(label, profile, GFP_ATOMIC,\n\t\t\tbuild_pivotroot(profile, new_path, new_buffer,\n\t\t\t\t\told_path, old_buffer));\n\tif (!target) {\n\t\tinfo = \"label build failed\";\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t} else if (!IS_ERR(target)) {\n\t\terror = aa_replace_current_label(target);\n\t\tif (error) {\n\t\t\t/* TODO: audit target */\n\t\t\taa_put_label(target);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\t/* already audited error */\n\t\terror = PTR_ERR(target);\nout:\n\tput_buffers(old_buffer, new_buffer);\n\n\treturn error;\n\nfail:\n\t/* TODO: add back in auditing of new_name and old_name */\n\terror = fn_for_each(label, profile,\n\t\t\taudit_mount(profile, OP_PIVOTROOT, NULL /*new_name */,\n\t\t\t\t    NULL /* old_name */,\n\t\t\t\t    NULL, NULL,\n\t\t\t\t    0, NULL, AA_MAY_PIVOTROOT, &nullperms, info,\n\t\t\t\t    error));\n\tgoto out;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fn_for_each",
          "args": [
            "label",
            "profile",
            "audit_mount(profile, OP_PIVOTROOT, NULL /*new_name */,\n\t\t\t\t    NULL /* old_name */,\n\t\t\t\t    NULL, NULL,\n\t\t\t\t    0, NULL, AA_MAY_PIVOTROOT, &nullperms, info,\n\t\t\t\t    error)"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_mount",
          "args": [
            "profile",
            "OP_PIVOTROOT",
            "NULL/*new_name */",
            "NULL/* old_name */",
            "NULL",
            "NULL",
            "0",
            "NULL",
            "AA_MAY_PIVOTROOT",
            "&nullperms",
            "info",
            "error"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "133-182",
          "snippet": "static int audit_mount(struct aa_profile *profile, const char *op,\n\t\t       const char *name, const char *src_name,\n\t\t       const char *type, const char *trans,\n\t\t       unsigned long flags, const void *data, u32 request,\n\t\t       struct aa_perms *perms, const char *info, int error)\n{\n\tint audit_type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, op);\n\n\tif (likely(!error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= mask;\n\n\t\tif (likely(!request))\n\t\t\treturn 0;\n\t\taudit_type = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\trequest = request & ~perms->allow;\n\n\t\tif (request & perms->kill)\n\t\t\taudit_type = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\trequest &= ~perms->quiet;\n\n\t\tif (!request)\n\t\t\treturn error;\n\t}\n\n\taad(&sa)->name = name;\n\taad(&sa)->mnt.src_name = src_name;\n\taad(&sa)->mnt.type = type;\n\taad(&sa)->mnt.trans = trans;\n\taad(&sa)->mnt.flags = flags;\n\tif (data && (perms->audit & AA_AUDIT_DATA))\n\t\taad(&sa)->mnt.data = data;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(audit_type, profile, &sa, audit_cb);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int audit_mount(struct aa_profile *profile, const char *op,\n\t\t       const char *name, const char *src_name,\n\t\t       const char *type, const char *trans,\n\t\t       unsigned long flags, const void *data, u32 request,\n\t\t       struct aa_perms *perms, const char *info, int error)\n{\n\tint audit_type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, op);\n\n\tif (likely(!error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= mask;\n\n\t\tif (likely(!request))\n\t\t\treturn 0;\n\t\taudit_type = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\trequest = request & ~perms->allow;\n\n\t\tif (request & perms->kill)\n\t\t\taudit_type = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\trequest &= ~perms->quiet;\n\n\t\tif (!request)\n\t\t\treturn error;\n\t}\n\n\taad(&sa)->name = name;\n\taad(&sa)->mnt.src_name = src_name;\n\taad(&sa)->mnt.type = type;\n\taad(&sa)->mnt.trans = trans;\n\taad(&sa)->mnt.flags = flags;\n\tif (data && (perms->audit & AA_AUDIT_DATA))\n\t\taad(&sa)->mnt.data = data;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(audit_type, profile, &sa, audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_buffers",
          "args": [
            "old_buffer",
            "new_buffer"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "target"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_put_label",
          "args": [
            "target"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "aa_put_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "416-420",
          "snippet": "static inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline void aa_put_label(struct aa_label *l)\n{\n\tif (l)\n\t\tkref_put(&l->count, aa_label_kref);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_replace_current_label",
          "args": [
            "target"
          ],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "aa_replace_current_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/context.c",
          "lines": "94-129",
          "snippet": "int aa_replace_current_label(struct aa_label *label)\n{\n\tstruct aa_task_ctx *ctx = current_ctx();\n\tstruct cred *new;\n\tAA_BUG(!label);\n\n\tif (ctx->label == label)\n\t\treturn 0;\n\n\tif (current_cred() != current_real_cred())\n\t\treturn -EBUSY;\n\n\tnew  = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\tif (unconfined(label) || (labels_ns(ctx->label) != labels_ns(label)))\n\t\t/* if switching to unconfined or a different label namespace\n\t\t * clear out context state\n\t\t */\n\t\taa_clear_task_ctx_trans(ctx);\n\n\t/*\n\t * be careful switching ctx->profile, when racing replacement it\n\t * is possible that ctx->profile->proxy->profile is the reference\n\t * keeping @profile valid, so make sure to get its reference before\n\t * dropping the reference on ctx->profile\n\t */\n\taa_get_label(label);\n\taa_put_label(ctx->label);\n\tctx->label = label;\n\n\tcommit_creds(new);\n\treturn 0;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/context.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/context.h\"\n\nint aa_replace_current_label(struct aa_label *label)\n{\n\tstruct aa_task_ctx *ctx = current_ctx();\n\tstruct cred *new;\n\tAA_BUG(!label);\n\n\tif (ctx->label == label)\n\t\treturn 0;\n\n\tif (current_cred() != current_real_cred())\n\t\treturn -EBUSY;\n\n\tnew  = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tctx = cred_ctx(new);\n\tif (unconfined(label) || (labels_ns(ctx->label) != labels_ns(label)))\n\t\t/* if switching to unconfined or a different label namespace\n\t\t * clear out context state\n\t\t */\n\t\taa_clear_task_ctx_trans(ctx);\n\n\t/*\n\t * be careful switching ctx->profile, when racing replacement it\n\t * is possible that ctx->profile->proxy->profile is the reference\n\t * keeping @profile valid, so make sure to get its reference before\n\t * dropping the reference on ctx->profile\n\t */\n\taa_get_label(label);\n\taa_put_label(ctx->label);\n\tctx->label = label;\n\n\tcommit_creds(new);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "target"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_label_build",
          "args": [
            "label",
            "profile",
            "GFP_ATOMIC",
            "build_pivotroot(profile, new_path, new_buffer,\n\t\t\t\t\told_path, old_buffer)"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "build_pivotroot",
          "args": [
            "profile",
            "new_path",
            "new_buffer",
            "old_path",
            "old_buffer"
          ],
          "line": 665
        },
        "resolved": true,
        "details": {
          "function_name": "build_pivotroot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "600-649",
          "snippet": "static struct aa_label *build_pivotroot(struct aa_profile *profile,\n\t\t\t\t\tconst struct path *new_path,\n\t\t\t\t\tchar *new_buffer,\n\t\t\t\t\tconst struct path *old_path,\n\t\t\t\t\tchar *old_buffer)\n{\n\tconst char *old_name, *new_name = NULL, *info = NULL;\n\tconst char *trans_name = NULL;\n\tstruct aa_perms perms = { };\n\tunsigned int state;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!new_path);\n\tAA_BUG(!old_path);\n\n\tif (profile_unconfined(profile))\n\t\treturn aa_get_newest_label(&profile->label);\n\n\terror = aa_path_name(old_path, path_flags(profile, old_path),\n\t\t\t     old_buffer, &old_name, &info,\n\t\t\t     profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\terror = aa_path_name(new_path, path_flags(profile, new_path),\n\t\t\t     new_buffer, &new_name, &info,\n\t\t\t     profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\n\terror = -EACCES;\n\tstate = aa_dfa_match(profile->policy.dfa,\n\t\t\t     profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t     new_name);\n\tstate = aa_dfa_null_transition(profile->policy.dfa, state);\n\tstate = aa_dfa_match(profile->policy.dfa, state, old_name);\n\tperms = compute_mnt_perms(profile->policy.dfa, state);\n\n\tif (AA_MAY_PIVOTROOT & perms.allow)\n\t\terror = 0;\n\naudit:\n\terror = audit_mount(profile, OP_PIVOTROOT, new_name, old_name,\n\t\t\t    NULL, trans_name, 0, NULL, AA_MAY_PIVOTROOT,\n\t\t\t    &perms, info, error);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\treturn aa_get_newest_label(&profile->label);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct aa_label *build_pivotroot(struct aa_profile *profile,\n\t\t\t\t\tconst struct path *new_path,\n\t\t\t\t\tchar *new_buffer,\n\t\t\t\t\tconst struct path *old_path,\n\t\t\t\t\tchar *old_buffer)\n{\n\tconst char *old_name, *new_name = NULL, *info = NULL;\n\tconst char *trans_name = NULL;\n\tstruct aa_perms perms = { };\n\tunsigned int state;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!new_path);\n\tAA_BUG(!old_path);\n\n\tif (profile_unconfined(profile))\n\t\treturn aa_get_newest_label(&profile->label);\n\n\terror = aa_path_name(old_path, path_flags(profile, old_path),\n\t\t\t     old_buffer, &old_name, &info,\n\t\t\t     profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\terror = aa_path_name(new_path, path_flags(profile, new_path),\n\t\t\t     new_buffer, &new_name, &info,\n\t\t\t     profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\n\terror = -EACCES;\n\tstate = aa_dfa_match(profile->policy.dfa,\n\t\t\t     profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t     new_name);\n\tstate = aa_dfa_null_transition(profile->policy.dfa, state);\n\tstate = aa_dfa_match(profile->policy.dfa, state, old_name);\n\tperms = compute_mnt_perms(profile->policy.dfa, state);\n\n\tif (AA_MAY_PIVOTROOT & perms.allow)\n\t\terror = 0;\n\naudit:\n\terror = audit_mount(profile, OP_PIVOTROOT, new_name, old_name,\n\t\t\t    NULL, trans_name, 0, NULL, AA_MAY_PIVOTROOT,\n\t\t\t    &perms, info, error);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\treturn aa_get_newest_label(&profile->label);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_buffers",
          "args": [
            "old_buffer",
            "new_buffer"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new_path"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!old_path"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_pivotroot(struct aa_label *label, const struct path *old_path,\n\t\t const struct path *new_path)\n{\n\tstruct aa_profile *profile;\n\tstruct aa_label *target = NULL;\n\tchar *old_buffer = NULL, *new_buffer = NULL, *info = NULL;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!old_path);\n\tAA_BUG(!new_path);\n\n\tget_buffers(old_buffer, new_buffer);\n\ttarget = fn_label_build(label, profile, GFP_ATOMIC,\n\t\t\tbuild_pivotroot(profile, new_path, new_buffer,\n\t\t\t\t\told_path, old_buffer));\n\tif (!target) {\n\t\tinfo = \"label build failed\";\n\t\terror = -ENOMEM;\n\t\tgoto fail;\n\t} else if (!IS_ERR(target)) {\n\t\terror = aa_replace_current_label(target);\n\t\tif (error) {\n\t\t\t/* TODO: audit target */\n\t\t\taa_put_label(target);\n\t\t\tgoto out;\n\t\t}\n\t} else\n\t\t/* already audited error */\n\t\terror = PTR_ERR(target);\nout:\n\tput_buffers(old_buffer, new_buffer);\n\n\treturn error;\n\nfail:\n\t/* TODO: add back in auditing of new_name and old_name */\n\terror = fn_for_each(label, profile,\n\t\t\taudit_mount(profile, OP_PIVOTROOT, NULL /*new_name */,\n\t\t\t\t    NULL /* old_name */,\n\t\t\t\t    NULL, NULL,\n\t\t\t\t    0, NULL, AA_MAY_PIVOTROOT, &nullperms, info,\n\t\t\t\t    error));\n\tgoto out;\n}"
  },
  {
    "function_name": "build_pivotroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "600-649",
    "snippet": "static struct aa_label *build_pivotroot(struct aa_profile *profile,\n\t\t\t\t\tconst struct path *new_path,\n\t\t\t\t\tchar *new_buffer,\n\t\t\t\t\tconst struct path *old_path,\n\t\t\t\t\tchar *old_buffer)\n{\n\tconst char *old_name, *new_name = NULL, *info = NULL;\n\tconst char *trans_name = NULL;\n\tstruct aa_perms perms = { };\n\tunsigned int state;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!new_path);\n\tAA_BUG(!old_path);\n\n\tif (profile_unconfined(profile))\n\t\treturn aa_get_newest_label(&profile->label);\n\n\terror = aa_path_name(old_path, path_flags(profile, old_path),\n\t\t\t     old_buffer, &old_name, &info,\n\t\t\t     profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\terror = aa_path_name(new_path, path_flags(profile, new_path),\n\t\t\t     new_buffer, &new_name, &info,\n\t\t\t     profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\n\terror = -EACCES;\n\tstate = aa_dfa_match(profile->policy.dfa,\n\t\t\t     profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t     new_name);\n\tstate = aa_dfa_null_transition(profile->policy.dfa, state);\n\tstate = aa_dfa_match(profile->policy.dfa, state, old_name);\n\tperms = compute_mnt_perms(profile->policy.dfa, state);\n\n\tif (AA_MAY_PIVOTROOT & perms.allow)\n\t\terror = 0;\n\naudit:\n\terror = audit_mount(profile, OP_PIVOTROOT, new_name, old_name,\n\t\t\t    NULL, trans_name, 0, NULL, AA_MAY_PIVOTROOT,\n\t\t\t    &perms, info, error);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\treturn aa_get_newest_label(&profile->label);\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_get_newest_label",
          "args": [
            "&profile->label"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "aa_get_newest_label",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/label.h",
          "lines": "393-414",
          "snippet": "static inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}",
          "includes": [
            "#include \"lib.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/rcupdate.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/audit.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lib.h\"\n#include \"apparmor.h\"\n#include <linux/rcupdate.h>\n#include <linux/rbtree.h>\n#include <linux/audit.h>\n#include <linux/atomic.h>\n\nstatic inline struct aa_label *aa_get_newest_label(struct aa_label *l)\n{\n\tif (!l)\n\t\treturn NULL;\n\n\tif (label_is_stale(l)) {\n\t\tstruct aa_label *tmp;\n\n\t\tAA_BUG(!l->proxy);\n\t\tAA_BUG(!l->proxy->label);\n\t\t/* BUG: only way this can happen is @l ref count and its\n\t\t * replacement count have gone to 0 and are on their way\n\t\t * to destruction. ie. we have a refcounting error\n\t\t */\n\t\ttmp = aa_get_label_rcu(&l->proxy->label);\n\t\tAA_BUG(!tmp);\n\n\t\treturn tmp;\n\t}\n\n\treturn aa_get_label(l);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_mount",
          "args": [
            "profile",
            "OP_PIVOTROOT",
            "new_name",
            "old_name",
            "NULL",
            "trans_name",
            "0",
            "NULL",
            "AA_MAY_PIVOTROOT",
            "&perms",
            "info",
            "error"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "133-182",
          "snippet": "static int audit_mount(struct aa_profile *profile, const char *op,\n\t\t       const char *name, const char *src_name,\n\t\t       const char *type, const char *trans,\n\t\t       unsigned long flags, const void *data, u32 request,\n\t\t       struct aa_perms *perms, const char *info, int error)\n{\n\tint audit_type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, op);\n\n\tif (likely(!error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= mask;\n\n\t\tif (likely(!request))\n\t\t\treturn 0;\n\t\taudit_type = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\trequest = request & ~perms->allow;\n\n\t\tif (request & perms->kill)\n\t\t\taudit_type = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\trequest &= ~perms->quiet;\n\n\t\tif (!request)\n\t\t\treturn error;\n\t}\n\n\taad(&sa)->name = name;\n\taad(&sa)->mnt.src_name = src_name;\n\taad(&sa)->mnt.type = type;\n\taad(&sa)->mnt.trans = trans;\n\taad(&sa)->mnt.flags = flags;\n\tif (data && (perms->audit & AA_AUDIT_DATA))\n\t\taad(&sa)->mnt.data = data;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(audit_type, profile, &sa, audit_cb);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int audit_mount(struct aa_profile *profile, const char *op,\n\t\t       const char *name, const char *src_name,\n\t\t       const char *type, const char *trans,\n\t\t       unsigned long flags, const void *data, u32 request,\n\t\t       struct aa_perms *perms, const char *info, int error)\n{\n\tint audit_type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, op);\n\n\tif (likely(!error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= mask;\n\n\t\tif (likely(!request))\n\t\t\treturn 0;\n\t\taudit_type = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\trequest = request & ~perms->allow;\n\n\t\tif (request & perms->kill)\n\t\t\taudit_type = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\trequest &= ~perms->quiet;\n\n\t\tif (!request)\n\t\t\treturn error;\n\t}\n\n\taad(&sa)->name = name;\n\taad(&sa)->mnt.src_name = src_name;\n\taad(&sa)->mnt.type = type;\n\taad(&sa)->mnt.trans = trans;\n\taad(&sa)->mnt.flags = flags;\n\tif (data && (perms->audit & AA_AUDIT_DATA))\n\t\taad(&sa)->mnt.data = data;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(audit_type, profile, &sa, audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compute_mnt_perms",
          "args": [
            "profile->policy.dfa",
            "state"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "compute_mnt_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "216-227",
          "snippet": "static struct aa_perms compute_mnt_perms(struct aa_dfa *dfa,\n\t\t\t\t\t   unsigned int state)\n{\n\tstruct aa_perms perms = {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t\t.xindex = dfa_user_xindex(dfa, state),\n\t};\n\n\treturn perms;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct aa_perms compute_mnt_perms(struct aa_dfa *dfa,\n\t\t\t\t\t   unsigned int state)\n{\n\tstruct aa_perms perms = {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t\t.xindex = dfa_user_xindex(dfa, state),\n\t};\n\n\treturn perms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_match",
          "args": [
            "profile->policy.dfa",
            "state",
            "old_name"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "381-417",
          "snippet": "unsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_null_transition",
          "args": [
            "profile->policy.dfa",
            "state"
          ],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_null_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "80-85",
          "snippet": "static inline unsigned int aa_dfa_null_transition(struct aa_dfa *dfa,\n\t\t\t\t\t\t  unsigned int start)\n{\n\t/* the null transition only needs the string's null terminator byte */\n\treturn aa_dfa_next(dfa, start, 0);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int aa_dfa_null_transition(struct aa_dfa *dfa,\n\t\t\t\t\t\t  unsigned int start)\n{\n\t/* the null transition only needs the string's null terminator byte */\n\treturn aa_dfa_next(dfa, start, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_path_name",
          "args": [
            "new_path",
            "path_flags(profile, new_path)",
            "new_buffer",
            "&new_name",
            "&info",
            "profile->disconnected"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "aa_path_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
          "lines": "201-221",
          "snippet": "int aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/path.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nint aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_flags",
          "args": [
            "profile",
            "new_path"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "path_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "295-302",
          "snippet": "static int path_flags(struct aa_profile *profile, const struct path *path)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\treturn profile->path_flags |\n\t\t(S_ISDIR(path->dentry->d_inode->i_mode) ? PATH_IS_DIR : 0);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int path_flags(struct aa_profile *profile, const struct path *path)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\treturn profile->path_flags |\n\t\t(S_ISDIR(path->dentry->d_inode->i_mode) ? PATH_IS_DIR : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "profile_unconfined",
          "args": [
            "profile"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!old_path"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!new_path"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!profile"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct aa_label *build_pivotroot(struct aa_profile *profile,\n\t\t\t\t\tconst struct path *new_path,\n\t\t\t\t\tchar *new_buffer,\n\t\t\t\t\tconst struct path *old_path,\n\t\t\t\t\tchar *old_buffer)\n{\n\tconst char *old_name, *new_name = NULL, *info = NULL;\n\tconst char *trans_name = NULL;\n\tstruct aa_perms perms = { };\n\tunsigned int state;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!new_path);\n\tAA_BUG(!old_path);\n\n\tif (profile_unconfined(profile))\n\t\treturn aa_get_newest_label(&profile->label);\n\n\terror = aa_path_name(old_path, path_flags(profile, old_path),\n\t\t\t     old_buffer, &old_name, &info,\n\t\t\t     profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\terror = aa_path_name(new_path, path_flags(profile, new_path),\n\t\t\t     new_buffer, &new_name, &info,\n\t\t\t     profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\n\terror = -EACCES;\n\tstate = aa_dfa_match(profile->policy.dfa,\n\t\t\t     profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t     new_name);\n\tstate = aa_dfa_null_transition(profile->policy.dfa, state);\n\tstate = aa_dfa_match(profile->policy.dfa, state, old_name);\n\tperms = compute_mnt_perms(profile->policy.dfa, state);\n\n\tif (AA_MAY_PIVOTROOT & perms.allow)\n\t\terror = 0;\n\naudit:\n\terror = audit_mount(profile, OP_PIVOTROOT, new_name, old_name,\n\t\t\t    NULL, trans_name, 0, NULL, AA_MAY_PIVOTROOT,\n\t\t\t    &perms, info, error);\n\tif (error)\n\t\treturn ERR_PTR(error);\n\n\treturn aa_get_newest_label(&profile->label);\n}"
  },
  {
    "function_name": "aa_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "578-594",
    "snippet": "int aa_umount(struct aa_label *label, struct vfsmount *mnt, int flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\tstruct path path = { .mnt = mnt, .dentry = mnt->mnt_root };\n\n\tAA_BUG(!label);\n\tAA_BUG(!mnt);\n\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_umount(profile, &path, buffer));\n\tput_buffers(buffer);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_buffers",
          "args": [
            "buffer"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_for_each_confined",
          "args": [
            "label",
            "profile",
            "profile_umount(profile, &path, buffer)"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "profile_umount",
          "args": [
            "profile",
            "&path",
            "buffer"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "profile_umount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "550-576",
          "snippet": "static int profile_umount(struct aa_profile *profile, struct path *path,\n\t\t\t  char *buffer)\n{\n\tstruct aa_perms perms = { };\n\tconst char *name = NULL, *info = NULL;\n\tunsigned int state;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\terror = aa_path_name(path, path_flags(profile, path), buffer, &name,\n\t\t\t     &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\n\tstate = aa_dfa_match(profile->policy.dfa,\n\t\t\t     profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t     name);\n\tperms = compute_mnt_perms(profile->policy.dfa, state);\n\tif (AA_MAY_UMOUNT & ~perms.allow)\n\t\terror = -EACCES;\n\naudit:\n\treturn audit_mount(profile, OP_UMOUNT, name, NULL, NULL, NULL, 0, NULL,\n\t\t\t   AA_MAY_UMOUNT, &perms, info, error);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int profile_umount(struct aa_profile *profile, struct path *path,\n\t\t\t  char *buffer)\n{\n\tstruct aa_perms perms = { };\n\tconst char *name = NULL, *info = NULL;\n\tunsigned int state;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\terror = aa_path_name(path, path_flags(profile, path), buffer, &name,\n\t\t\t     &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\n\tstate = aa_dfa_match(profile->policy.dfa,\n\t\t\t     profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t     name);\n\tperms = compute_mnt_perms(profile->policy.dfa, state);\n\tif (AA_MAY_UMOUNT & ~perms.allow)\n\t\terror = -EACCES;\n\naudit:\n\treturn audit_mount(profile, OP_UMOUNT, name, NULL, NULL, NULL, 0, NULL,\n\t\t\t   AA_MAY_UMOUNT, &perms, info, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_buffers",
          "args": [
            "buffer"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mnt"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_umount(struct aa_label *label, struct vfsmount *mnt, int flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\tstruct path path = { .mnt = mnt, .dentry = mnt->mnt_root };\n\n\tAA_BUG(!label);\n\tAA_BUG(!mnt);\n\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tprofile_umount(profile, &path, buffer));\n\tput_buffers(buffer);\n\n\treturn error;\n}"
  },
  {
    "function_name": "profile_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "550-576",
    "snippet": "static int profile_umount(struct aa_profile *profile, struct path *path,\n\t\t\t  char *buffer)\n{\n\tstruct aa_perms perms = { };\n\tconst char *name = NULL, *info = NULL;\n\tunsigned int state;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\terror = aa_path_name(path, path_flags(profile, path), buffer, &name,\n\t\t\t     &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\n\tstate = aa_dfa_match(profile->policy.dfa,\n\t\t\t     profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t     name);\n\tperms = compute_mnt_perms(profile->policy.dfa, state);\n\tif (AA_MAY_UMOUNT & ~perms.allow)\n\t\terror = -EACCES;\n\naudit:\n\treturn audit_mount(profile, OP_UMOUNT, name, NULL, NULL, NULL, 0, NULL,\n\t\t\t   AA_MAY_UMOUNT, &perms, info, error);\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_mount",
          "args": [
            "profile",
            "OP_UMOUNT",
            "name",
            "NULL",
            "NULL",
            "NULL",
            "0",
            "NULL",
            "AA_MAY_UMOUNT",
            "&perms",
            "info",
            "error"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "133-182",
          "snippet": "static int audit_mount(struct aa_profile *profile, const char *op,\n\t\t       const char *name, const char *src_name,\n\t\t       const char *type, const char *trans,\n\t\t       unsigned long flags, const void *data, u32 request,\n\t\t       struct aa_perms *perms, const char *info, int error)\n{\n\tint audit_type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, op);\n\n\tif (likely(!error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= mask;\n\n\t\tif (likely(!request))\n\t\t\treturn 0;\n\t\taudit_type = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\trequest = request & ~perms->allow;\n\n\t\tif (request & perms->kill)\n\t\t\taudit_type = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\trequest &= ~perms->quiet;\n\n\t\tif (!request)\n\t\t\treturn error;\n\t}\n\n\taad(&sa)->name = name;\n\taad(&sa)->mnt.src_name = src_name;\n\taad(&sa)->mnt.type = type;\n\taad(&sa)->mnt.trans = trans;\n\taad(&sa)->mnt.flags = flags;\n\tif (data && (perms->audit & AA_AUDIT_DATA))\n\t\taad(&sa)->mnt.data = data;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(audit_type, profile, &sa, audit_cb);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int audit_mount(struct aa_profile *profile, const char *op,\n\t\t       const char *name, const char *src_name,\n\t\t       const char *type, const char *trans,\n\t\t       unsigned long flags, const void *data, u32 request,\n\t\t       struct aa_perms *perms, const char *info, int error)\n{\n\tint audit_type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, op);\n\n\tif (likely(!error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= mask;\n\n\t\tif (likely(!request))\n\t\t\treturn 0;\n\t\taudit_type = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\trequest = request & ~perms->allow;\n\n\t\tif (request & perms->kill)\n\t\t\taudit_type = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\trequest &= ~perms->quiet;\n\n\t\tif (!request)\n\t\t\treturn error;\n\t}\n\n\taad(&sa)->name = name;\n\taad(&sa)->mnt.src_name = src_name;\n\taad(&sa)->mnt.type = type;\n\taad(&sa)->mnt.trans = trans;\n\taad(&sa)->mnt.flags = flags;\n\tif (data && (perms->audit & AA_AUDIT_DATA))\n\t\taad(&sa)->mnt.data = data;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(audit_type, profile, &sa, audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "compute_mnt_perms",
          "args": [
            "profile->policy.dfa",
            "state"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "compute_mnt_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "216-227",
          "snippet": "static struct aa_perms compute_mnt_perms(struct aa_dfa *dfa,\n\t\t\t\t\t   unsigned int state)\n{\n\tstruct aa_perms perms = {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t\t.xindex = dfa_user_xindex(dfa, state),\n\t};\n\n\treturn perms;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct aa_perms compute_mnt_perms(struct aa_dfa *dfa,\n\t\t\t\t\t   unsigned int state)\n{\n\tstruct aa_perms perms = {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t\t.xindex = dfa_user_xindex(dfa, state),\n\t};\n\n\treturn perms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_match",
          "args": [
            "profile->policy.dfa",
            "profile->policy.start[AA_CLASS_MOUNT]",
            "name"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "381-417",
          "snippet": "unsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_path_name",
          "args": [
            "path",
            "path_flags(profile, path)",
            "buffer",
            "&name",
            "&info",
            "profile->disconnected"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "aa_path_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
          "lines": "201-221",
          "snippet": "int aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/path.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nint aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_flags",
          "args": [
            "profile",
            "path"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "path_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "295-302",
          "snippet": "static int path_flags(struct aa_profile *profile, const struct path *path)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\treturn profile->path_flags |\n\t\t(S_ISDIR(path->dentry->d_inode->i_mode) ? PATH_IS_DIR : 0);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int path_flags(struct aa_profile *profile, const struct path *path)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\treturn profile->path_flags |\n\t\t(S_ISDIR(path->dentry->d_inode->i_mode) ? PATH_IS_DIR : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!path"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!profile"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int profile_umount(struct aa_profile *profile, struct path *path,\n\t\t\t  char *buffer)\n{\n\tstruct aa_perms perms = { };\n\tconst char *name = NULL, *info = NULL;\n\tunsigned int state;\n\tint error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\terror = aa_path_name(path, path_flags(profile, path), buffer, &name,\n\t\t\t     &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\n\tstate = aa_dfa_match(profile->policy.dfa,\n\t\t\t     profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t     name);\n\tperms = compute_mnt_perms(profile->policy.dfa, state);\n\tif (AA_MAY_UMOUNT & ~perms.allow)\n\t\terror = -EACCES;\n\naudit:\n\treturn audit_mount(profile, OP_UMOUNT, name, NULL, NULL, NULL, 0, NULL,\n\t\t\t   AA_MAY_UMOUNT, &perms, info, error);\n}"
  },
  {
    "function_name": "aa_new_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "498-548",
    "snippet": "int aa_new_mount(struct aa_label *label, const char *dev_name,\n\t\t const struct path *path, const char *type, unsigned long flags,\n\t\t void *data)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *dev_buffer = NULL;\n\tbool binary = true;\n\tint error;\n\tint requires_dev = 0;\n\tstruct path tmp_path, *dev_path = NULL;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (type) {\n\t\tstruct file_system_type *fstype;\n\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype)\n\t\t\treturn -ENODEV;\n\t\tbinary = fstype->fs_flags & FS_BINARY_MOUNTDATA;\n\t\trequires_dev = fstype->fs_flags & FS_REQUIRES_DEV;\n\t\tput_filesystem(fstype);\n\n\t\tif (requires_dev) {\n\t\t\tif (!dev_name || !*dev_name)\n\t\t\t\treturn -ENOENT;\n\n\t\t\terror = kern_path(dev_name, LOOKUP_FOLLOW, &tmp_path);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tdev_path = &tmp_path;\n\t\t}\n\t}\n\n\tget_buffers(buffer, dev_buffer);\n\tif (dev_path) {\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, dev_path, dev_buffer,\n\t\t\t\t  type, flags, data, binary));\n\t} else {\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt_path_str(profile, path, buffer, dev_name,\n\t\t\t\t\t   type, flags, data, binary, NULL));\n\t}\n\tput_buffers(buffer, dev_buffer);\n\tif (dev_path)\n\t\tpath_put(dev_path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "dev_path"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_buffers",
          "args": [
            "buffer",
            "dev_buffer"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_for_each_confined",
          "args": [
            "label",
            "profile",
            "match_mnt_path_str(profile, path, buffer, dev_name,\n\t\t\t\t\t   type, flags, data, binary, NULL)"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_mnt_path_str",
          "args": [
            "profile",
            "path",
            "buffer",
            "dev_name",
            "type",
            "flags",
            "data",
            "binary",
            "NULL"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "match_mnt_path_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "318-356",
          "snippet": "static int match_mnt_path_str(struct aa_profile *profile,\n\t\t\t      const struct path *mntpath, char *buffer,\n\t\t\t      const char *devname, const char *type,\n\t\t\t      unsigned long flags, void *data, bool binary,\n\t\t\t      const char *devinfo)\n{\n\tstruct aa_perms perms = { };\n\tconst char *mntpnt = NULL, *info = NULL;\n\tint pos, error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mntpath);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(mntpath, path_flags(profile, mntpath), buffer,\n\t\t\t     &mntpnt, &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\tif (IS_ERR(devname)) {\n\t\terror = PTR_ERR(devname);\n\t\tdevname = NULL;\n\t\tinfo = devinfo;\n\t\tgoto audit;\n\t}\n\n\terror = -EACCES;\n\tpos = do_match_mnt(profile->policy.dfa,\n\t\t\t   profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t   mntpnt, devname, type, flags, data, binary, &perms);\n\tif (pos) {\n\t\tinfo = mnt_info_table[pos];\n\t\tgoto audit;\n\t}\n\terror = 0;\n\naudit:\n\treturn audit_mount(profile, OP_MOUNT, mntpnt, devname, type, NULL,\n\t\t\t   flags, data, AA_MAY_MOUNT, &perms, info, error);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const mnt_info_table[] = {\n\t\"match succeeded\",\n\t\"failed mntpnt match\",\n\t\"failed srcname match\",\n\t\"failed type match\",\n\t\"failed flags match\",\n\t\"failed data match\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic const char * const mnt_info_table[] = {\n\t\"match succeeded\",\n\t\"failed mntpnt match\",\n\t\"failed srcname match\",\n\t\"failed type match\",\n\t\"failed flags match\",\n\t\"failed data match\"\n};\n\nstatic int match_mnt_path_str(struct aa_profile *profile,\n\t\t\t      const struct path *mntpath, char *buffer,\n\t\t\t      const char *devname, const char *type,\n\t\t\t      unsigned long flags, void *data, bool binary,\n\t\t\t      const char *devinfo)\n{\n\tstruct aa_perms perms = { };\n\tconst char *mntpnt = NULL, *info = NULL;\n\tint pos, error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mntpath);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(mntpath, path_flags(profile, mntpath), buffer,\n\t\t\t     &mntpnt, &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\tif (IS_ERR(devname)) {\n\t\terror = PTR_ERR(devname);\n\t\tdevname = NULL;\n\t\tinfo = devinfo;\n\t\tgoto audit;\n\t}\n\n\terror = -EACCES;\n\tpos = do_match_mnt(profile->policy.dfa,\n\t\t\t   profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t   mntpnt, devname, type, flags, data, binary, &perms);\n\tif (pos) {\n\t\tinfo = mnt_info_table[pos];\n\t\tgoto audit;\n\t}\n\terror = 0;\n\naudit:\n\treturn audit_mount(profile, OP_MOUNT, mntpnt, devname, type, NULL,\n\t\t\t   flags, data, AA_MAY_MOUNT, &perms, info, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fn_for_each_confined",
          "args": [
            "label",
            "profile",
            "match_mnt(profile, path, buffer, dev_path, dev_buffer,\n\t\t\t\t  type, flags, data, binary)"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_mnt",
          "args": [
            "profile",
            "path",
            "buffer",
            "dev_path",
            "dev_buffer",
            "type",
            "flags",
            "data",
            "binary"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "match_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "372-393",
          "snippet": "static int match_mnt(struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(profile, path, buffer, devname, type, flags,\n\t\t\t\t  data, binary, info);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int match_mnt(struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(profile, path, buffer, devname, type, flags,\n\t\t\t\t  data, binary, info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_buffers",
          "args": [
            "buffer",
            "dev_buffer"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "dev_name",
            "LOOKUP_FOLLOW",
            "&tmp_path"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_filesystem",
          "args": [
            "fstype"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_fs_type",
          "args": [
            "type"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!path"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_new_mount(struct aa_label *label, const char *dev_name,\n\t\t const struct path *path, const char *type, unsigned long flags,\n\t\t void *data)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *dev_buffer = NULL;\n\tbool binary = true;\n\tint error;\n\tint requires_dev = 0;\n\tstruct path tmp_path, *dev_path = NULL;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (type) {\n\t\tstruct file_system_type *fstype;\n\n\t\tfstype = get_fs_type(type);\n\t\tif (!fstype)\n\t\t\treturn -ENODEV;\n\t\tbinary = fstype->fs_flags & FS_BINARY_MOUNTDATA;\n\t\trequires_dev = fstype->fs_flags & FS_REQUIRES_DEV;\n\t\tput_filesystem(fstype);\n\n\t\tif (requires_dev) {\n\t\t\tif (!dev_name || !*dev_name)\n\t\t\t\treturn -ENOENT;\n\n\t\t\terror = kern_path(dev_name, LOOKUP_FOLLOW, &tmp_path);\n\t\t\tif (error)\n\t\t\t\treturn error;\n\t\t\tdev_path = &tmp_path;\n\t\t}\n\t}\n\n\tget_buffers(buffer, dev_buffer);\n\tif (dev_path) {\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, dev_path, dev_buffer,\n\t\t\t\t  type, flags, data, binary));\n\t} else {\n\t\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt_path_str(profile, path, buffer, dev_name,\n\t\t\t\t\t   type, flags, data, binary, NULL));\n\t}\n\tput_buffers(buffer, dev_buffer);\n\tif (dev_path)\n\t\tpath_put(dev_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "aa_move_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "470-496",
    "snippet": "int aa_move_mount(struct aa_label *label, const struct path *path,\n\t\t  const char *orig_name)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *old_buffer = NULL;\n\tstruct path old_path;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (!orig_name || !*orig_name)\n\t\treturn -EINVAL;\n\n\terror = kern_path(orig_name, LOOKUP_FOLLOW, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tget_buffers(buffer, old_buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, &old_path, old_buffer,\n\t\t\t\t  NULL, MS_MOVE, NULL, false));\n\tput_buffers(buffer, old_buffer);\n\tpath_put(&old_path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&old_path"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_buffers",
          "args": [
            "buffer",
            "old_buffer"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_for_each_confined",
          "args": [
            "label",
            "profile",
            "match_mnt(profile, path, buffer, &old_path, old_buffer,\n\t\t\t\t  NULL, MS_MOVE, NULL, false)"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_mnt",
          "args": [
            "profile",
            "path",
            "buffer",
            "&old_path",
            "old_buffer",
            "NULL",
            "MS_MOVE",
            "NULL",
            "false"
          ],
          "line": 490
        },
        "resolved": true,
        "details": {
          "function_name": "match_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "372-393",
          "snippet": "static int match_mnt(struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(profile, path, buffer, devname, type, flags,\n\t\t\t\t  data, binary, info);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int match_mnt(struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(profile, path, buffer, devname, type, flags,\n\t\t\t\t  data, binary, info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_buffers",
          "args": [
            "buffer",
            "old_buffer"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "orig_name",
            "LOOKUP_FOLLOW",
            "&old_path"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!path"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_move_mount(struct aa_label *label, const struct path *path,\n\t\t  const char *orig_name)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *old_buffer = NULL;\n\tstruct path old_path;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (!orig_name || !*orig_name)\n\t\treturn -EINVAL;\n\n\terror = kern_path(orig_name, LOOKUP_FOLLOW, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tget_buffers(buffer, old_buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, &old_path, old_buffer,\n\t\t\t\t  NULL, MS_MOVE, NULL, false));\n\tput_buffers(buffer, old_buffer);\n\tpath_put(&old_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "aa_mount_change_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "447-468",
    "snippet": "int aa_mount_change_type(struct aa_label *label, const struct path *path,\n\t\t\t unsigned long flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\t/* These are the flags allowed by do_change_type() */\n\tflags &= (MS_REC | MS_SILENT | MS_SHARED | MS_PRIVATE | MS_SLAVE |\n\t\t  MS_UNBINDABLE);\n\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, NULL, NULL, NULL,\n\t\t\t\t  flags, NULL, false));\n\tput_buffers(buffer);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_buffers",
          "args": [
            "buffer"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_for_each_confined",
          "args": [
            "label",
            "profile",
            "match_mnt(profile, path, buffer, NULL, NULL, NULL,\n\t\t\t\t  flags, NULL, false)"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_mnt",
          "args": [
            "profile",
            "path",
            "buffer",
            "NULL",
            "NULL",
            "NULL",
            "flags",
            "NULL",
            "false"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "match_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "372-393",
          "snippet": "static int match_mnt(struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(profile, path, buffer, devname, type, flags,\n\t\t\t\t  data, binary, info);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int match_mnt(struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(profile, path, buffer, devname, type, flags,\n\t\t\t\t  data, binary, info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_buffers",
          "args": [
            "buffer"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!path"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_mount_change_type(struct aa_label *label, const struct path *path,\n\t\t\t unsigned long flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\t/* These are the flags allowed by do_change_type() */\n\tflags &= (MS_REC | MS_SILENT | MS_SHARED | MS_PRIVATE | MS_SLAVE |\n\t\t  MS_UNBINDABLE);\n\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, NULL, NULL, NULL,\n\t\t\t\t  flags, NULL, false));\n\tput_buffers(buffer);\n\n\treturn error;\n}"
  },
  {
    "function_name": "aa_bind_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "417-445",
    "snippet": "int aa_bind_mount(struct aa_label *label, const struct path *path,\n\t\t  const char *dev_name, unsigned long flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *old_buffer = NULL;\n\tstruct path old_path;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (!dev_name || !*dev_name)\n\t\treturn -EINVAL;\n\n\tflags &= MS_REC | MS_BIND;\n\n\terror = kern_path(dev_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tget_buffers(buffer, old_buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, &old_path, old_buffer,\n\t\t\t\t  NULL, flags, NULL, false));\n\tput_buffers(buffer, old_buffer);\n\tpath_put(&old_path);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&old_path"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_buffers",
          "args": [
            "buffer",
            "old_buffer"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_for_each_confined",
          "args": [
            "label",
            "profile",
            "match_mnt(profile, path, buffer, &old_path, old_buffer,\n\t\t\t\t  NULL, flags, NULL, false)"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_mnt",
          "args": [
            "profile",
            "path",
            "buffer",
            "&old_path",
            "old_buffer",
            "NULL",
            "flags",
            "NULL",
            "false"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "match_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "372-393",
          "snippet": "static int match_mnt(struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(profile, path, buffer, devname, type, flags,\n\t\t\t\t  data, binary, info);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int match_mnt(struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(profile, path, buffer, devname, type, flags,\n\t\t\t\t  data, binary, info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_buffers",
          "args": [
            "buffer",
            "old_buffer"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kern_path",
          "args": [
            "dev_name",
            "LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT",
            "&old_path"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!path"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_bind_mount(struct aa_label *label, const struct path *path,\n\t\t  const char *dev_name, unsigned long flags)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL, *old_buffer = NULL;\n\tstruct path old_path;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tif (!dev_name || !*dev_name)\n\t\treturn -EINVAL;\n\n\tflags &= MS_REC | MS_BIND;\n\n\terror = kern_path(dev_name, LOOKUP_FOLLOW|LOOKUP_AUTOMOUNT, &old_path);\n\tif (error)\n\t\treturn error;\n\n\tget_buffers(buffer, old_buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, &old_path, old_buffer,\n\t\t\t\t  NULL, flags, NULL, false));\n\tput_buffers(buffer, old_buffer);\n\tpath_put(&old_path);\n\n\treturn error;\n}"
  },
  {
    "function_name": "aa_remount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "395-415",
    "snippet": "int aa_remount(struct aa_label *label, const struct path *path,\n\t       unsigned long flags, void *data)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tbool binary;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tbinary = path->dentry->d_sb->s_type->fs_flags & FS_BINARY_MOUNTDATA;\n\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, NULL, NULL, NULL,\n\t\t\t\t  flags, data, binary));\n\tput_buffers(buffer);\n\n\treturn error;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_buffers",
          "args": [
            "buffer"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn_for_each_confined",
          "args": [
            "label",
            "profile",
            "match_mnt(profile, path, buffer, NULL, NULL, NULL,\n\t\t\t\t  flags, data, binary)"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_mnt",
          "args": [
            "profile",
            "path",
            "buffer",
            "NULL",
            "NULL",
            "NULL",
            "flags",
            "data",
            "binary"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "match_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "372-393",
          "snippet": "static int match_mnt(struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(profile, path, buffer, devname, type, flags,\n\t\t\t\t  data, binary, info);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int match_mnt(struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(profile, path, buffer, devname, type, flags,\n\t\t\t\t  data, binary, info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_buffers",
          "args": [
            "buffer"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!path"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!label"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nint aa_remount(struct aa_label *label, const struct path *path,\n\t       unsigned long flags, void *data)\n{\n\tstruct aa_profile *profile;\n\tchar *buffer = NULL;\n\tbool binary;\n\tint error;\n\n\tAA_BUG(!label);\n\tAA_BUG(!path);\n\n\tbinary = path->dentry->d_sb->s_type->fs_flags & FS_BINARY_MOUNTDATA;\n\n\tget_buffers(buffer);\n\terror = fn_for_each_confined(label, profile,\n\t\t\tmatch_mnt(profile, path, buffer, NULL, NULL, NULL,\n\t\t\t\t  flags, data, binary));\n\tput_buffers(buffer);\n\n\treturn error;\n}"
  },
  {
    "function_name": "match_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "372-393",
    "snippet": "static int match_mnt(struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(profile, path, buffer, devname, type, flags,\n\t\t\t\t  data, binary, info);\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "match_mnt_path_str",
          "args": [
            "profile",
            "path",
            "buffer",
            "devname",
            "type",
            "flags",
            "data",
            "binary",
            "info"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "match_mnt_path_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "318-356",
          "snippet": "static int match_mnt_path_str(struct aa_profile *profile,\n\t\t\t      const struct path *mntpath, char *buffer,\n\t\t\t      const char *devname, const char *type,\n\t\t\t      unsigned long flags, void *data, bool binary,\n\t\t\t      const char *devinfo)\n{\n\tstruct aa_perms perms = { };\n\tconst char *mntpnt = NULL, *info = NULL;\n\tint pos, error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mntpath);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(mntpath, path_flags(profile, mntpath), buffer,\n\t\t\t     &mntpnt, &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\tif (IS_ERR(devname)) {\n\t\terror = PTR_ERR(devname);\n\t\tdevname = NULL;\n\t\tinfo = devinfo;\n\t\tgoto audit;\n\t}\n\n\terror = -EACCES;\n\tpos = do_match_mnt(profile->policy.dfa,\n\t\t\t   profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t   mntpnt, devname, type, flags, data, binary, &perms);\n\tif (pos) {\n\t\tinfo = mnt_info_table[pos];\n\t\tgoto audit;\n\t}\n\terror = 0;\n\naudit:\n\treturn audit_mount(profile, OP_MOUNT, mntpnt, devname, type, NULL,\n\t\t\t   flags, data, AA_MAY_MOUNT, &perms, info, error);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const mnt_info_table[] = {\n\t\"match succeeded\",\n\t\"failed mntpnt match\",\n\t\"failed srcname match\",\n\t\"failed type match\",\n\t\"failed flags match\",\n\t\"failed data match\"\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic const char * const mnt_info_table[] = {\n\t\"match succeeded\",\n\t\"failed mntpnt match\",\n\t\"failed srcname match\",\n\t\"failed type match\",\n\t\"failed flags match\",\n\t\"failed data match\"\n};\n\nstatic int match_mnt_path_str(struct aa_profile *profile,\n\t\t\t      const struct path *mntpath, char *buffer,\n\t\t\t      const char *devname, const char *type,\n\t\t\t      unsigned long flags, void *data, bool binary,\n\t\t\t      const char *devinfo)\n{\n\tstruct aa_perms perms = { };\n\tconst char *mntpnt = NULL, *info = NULL;\n\tint pos, error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mntpath);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(mntpath, path_flags(profile, mntpath), buffer,\n\t\t\t     &mntpnt, &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\tif (IS_ERR(devname)) {\n\t\terror = PTR_ERR(devname);\n\t\tdevname = NULL;\n\t\tinfo = devinfo;\n\t\tgoto audit;\n\t}\n\n\terror = -EACCES;\n\tpos = do_match_mnt(profile->policy.dfa,\n\t\t\t   profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t   mntpnt, devname, type, flags, data, binary, &perms);\n\tif (pos) {\n\t\tinfo = mnt_info_table[pos];\n\t\tgoto audit;\n\t}\n\terror = 0;\n\naudit:\n\treturn audit_mount(profile, OP_MOUNT, mntpnt, devname, type, NULL,\n\t\t\t   flags, data, AA_MAY_MOUNT, &perms, info, error);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "error"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_path_name",
          "args": [
            "devpath",
            "path_flags(profile, devpath)",
            "devbuffer",
            "&devname",
            "&info",
            "profile->disconnected"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "aa_path_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
          "lines": "201-221",
          "snippet": "int aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/path.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nint aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_flags",
          "args": [
            "profile",
            "devpath"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "path_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "295-302",
          "snippet": "static int path_flags(struct aa_profile *profile, const struct path *path)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\treturn profile->path_flags |\n\t\t(S_ISDIR(path->dentry->d_inode->i_mode) ? PATH_IS_DIR : 0);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int path_flags(struct aa_profile *profile, const struct path *path)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\treturn profile->path_flags |\n\t\t(S_ISDIR(path->dentry->d_inode->i_mode) ? PATH_IS_DIR : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "devpath && !devbuffer"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!profile"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int match_mnt(struct aa_profile *profile, const struct path *path,\n\t\t     char *buffer, struct path *devpath, char *devbuffer,\n\t\t     const char *type, unsigned long flags, void *data,\n\t\t     bool binary)\n{\n\tconst char *devname = NULL, *info = NULL;\n\tint error = -EACCES;\n\n\tAA_BUG(!profile);\n\tAA_BUG(devpath && !devbuffer);\n\n\tif (devpath) {\n\t\terror = aa_path_name(devpath, path_flags(profile, devpath),\n\t\t\t\t     devbuffer, &devname, &info,\n\t\t\t\t     profile->disconnected);\n\t\tif (error)\n\t\t\tdevname = ERR_PTR(error);\n\t}\n\n\treturn match_mnt_path_str(profile, path, buffer, devname, type, flags,\n\t\t\t\t  data, binary, info);\n}"
  },
  {
    "function_name": "match_mnt_path_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "318-356",
    "snippet": "static int match_mnt_path_str(struct aa_profile *profile,\n\t\t\t      const struct path *mntpath, char *buffer,\n\t\t\t      const char *devname, const char *type,\n\t\t\t      unsigned long flags, void *data, bool binary,\n\t\t\t      const char *devinfo)\n{\n\tstruct aa_perms perms = { };\n\tconst char *mntpnt = NULL, *info = NULL;\n\tint pos, error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mntpath);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(mntpath, path_flags(profile, mntpath), buffer,\n\t\t\t     &mntpnt, &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\tif (IS_ERR(devname)) {\n\t\terror = PTR_ERR(devname);\n\t\tdevname = NULL;\n\t\tinfo = devinfo;\n\t\tgoto audit;\n\t}\n\n\terror = -EACCES;\n\tpos = do_match_mnt(profile->policy.dfa,\n\t\t\t   profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t   mntpnt, devname, type, flags, data, binary, &perms);\n\tif (pos) {\n\t\tinfo = mnt_info_table[pos];\n\t\tgoto audit;\n\t}\n\terror = 0;\n\naudit:\n\treturn audit_mount(profile, OP_MOUNT, mntpnt, devname, type, NULL,\n\t\t\t   flags, data, AA_MAY_MOUNT, &perms, info, error);\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char * const mnt_info_table[] = {\n\t\"match succeeded\",\n\t\"failed mntpnt match\",\n\t\"failed srcname match\",\n\t\"failed type match\",\n\t\"failed flags match\",\n\t\"failed data match\"\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_mount",
          "args": [
            "profile",
            "OP_MOUNT",
            "mntpnt",
            "devname",
            "type",
            "NULL",
            "flags",
            "data",
            "AA_MAY_MOUNT",
            "&perms",
            "info",
            "error"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "133-182",
          "snippet": "static int audit_mount(struct aa_profile *profile, const char *op,\n\t\t       const char *name, const char *src_name,\n\t\t       const char *type, const char *trans,\n\t\t       unsigned long flags, const void *data, u32 request,\n\t\t       struct aa_perms *perms, const char *info, int error)\n{\n\tint audit_type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, op);\n\n\tif (likely(!error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= mask;\n\n\t\tif (likely(!request))\n\t\t\treturn 0;\n\t\taudit_type = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\trequest = request & ~perms->allow;\n\n\t\tif (request & perms->kill)\n\t\t\taudit_type = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\trequest &= ~perms->quiet;\n\n\t\tif (!request)\n\t\t\treturn error;\n\t}\n\n\taad(&sa)->name = name;\n\taad(&sa)->mnt.src_name = src_name;\n\taad(&sa)->mnt.type = type;\n\taad(&sa)->mnt.trans = trans;\n\taad(&sa)->mnt.flags = flags;\n\tif (data && (perms->audit & AA_AUDIT_DATA))\n\t\taad(&sa)->mnt.data = data;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(audit_type, profile, &sa, audit_cb);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int audit_mount(struct aa_profile *profile, const char *op,\n\t\t       const char *name, const char *src_name,\n\t\t       const char *type, const char *trans,\n\t\t       unsigned long flags, const void *data, u32 request,\n\t\t       struct aa_perms *perms, const char *info, int error)\n{\n\tint audit_type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, op);\n\n\tif (likely(!error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= mask;\n\n\t\tif (likely(!request))\n\t\t\treturn 0;\n\t\taudit_type = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\trequest = request & ~perms->allow;\n\n\t\tif (request & perms->kill)\n\t\t\taudit_type = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\trequest &= ~perms->quiet;\n\n\t\tif (!request)\n\t\t\treturn error;\n\t}\n\n\taad(&sa)->name = name;\n\taad(&sa)->mnt.src_name = src_name;\n\taad(&sa)->mnt.type = type;\n\taad(&sa)->mnt.trans = trans;\n\taad(&sa)->mnt.flags = flags;\n\tif (data && (perms->audit & AA_AUDIT_DATA))\n\t\taad(&sa)->mnt.data = data;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(audit_type, profile, &sa, audit_cb);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_match_mnt",
          "args": [
            "profile->policy.dfa",
            "profile->policy.start[AA_CLASS_MOUNT]",
            "mntpnt",
            "devname",
            "type",
            "flags",
            "data",
            "binary",
            "&perms"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "do_match_mnt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "242-292",
          "snippet": "static int do_match_mnt(struct aa_dfa *dfa, unsigned int start,\n\t\t\tconst char *mntpnt, const char *devname,\n\t\t\tconst char *type, unsigned long flags,\n\t\t\tvoid *data, bool binary, struct aa_perms *perms)\n{\n\tunsigned int state;\n\n\tAA_BUG(!dfa);\n\tAA_BUG(!perms);\n\n\tstate = aa_dfa_match(dfa, start, mntpnt);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 1;\n\n\tif (devname)\n\t\tstate = aa_dfa_match(dfa, state, devname);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 2;\n\n\tif (type)\n\t\tstate = aa_dfa_match(dfa, state, type);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 3;\n\n\tstate = match_mnt_flags(dfa, state, flags);\n\tif (!state)\n\t\treturn 4;\n\t*perms = compute_mnt_perms(dfa, state);\n\tif (perms->allow & AA_MAY_MOUNT)\n\t\treturn 0;\n\n\t/* only match data if not binary and the DFA flags data is expected */\n\tif (data && !binary && (perms->allow & AA_MNT_CONT_MATCH)) {\n\t\tstate = aa_dfa_null_transition(dfa, state);\n\t\tif (!state)\n\t\t\treturn 4;\n\n\t\tstate = aa_dfa_match(dfa, state, data);\n\t\tif (!state)\n\t\t\treturn 5;\n\t\t*perms = compute_mnt_perms(dfa, state);\n\t\tif (perms->allow & AA_MAY_MOUNT)\n\t\t\treturn 0;\n\t}\n\n\t/* failed at end of flags match */\n\treturn 4;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int do_match_mnt(struct aa_dfa *dfa, unsigned int start,\n\t\t\tconst char *mntpnt, const char *devname,\n\t\t\tconst char *type, unsigned long flags,\n\t\t\tvoid *data, bool binary, struct aa_perms *perms)\n{\n\tunsigned int state;\n\n\tAA_BUG(!dfa);\n\tAA_BUG(!perms);\n\n\tstate = aa_dfa_match(dfa, start, mntpnt);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 1;\n\n\tif (devname)\n\t\tstate = aa_dfa_match(dfa, state, devname);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 2;\n\n\tif (type)\n\t\tstate = aa_dfa_match(dfa, state, type);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 3;\n\n\tstate = match_mnt_flags(dfa, state, flags);\n\tif (!state)\n\t\treturn 4;\n\t*perms = compute_mnt_perms(dfa, state);\n\tif (perms->allow & AA_MAY_MOUNT)\n\t\treturn 0;\n\n\t/* only match data if not binary and the DFA flags data is expected */\n\tif (data && !binary && (perms->allow & AA_MNT_CONT_MATCH)) {\n\t\tstate = aa_dfa_null_transition(dfa, state);\n\t\tif (!state)\n\t\t\treturn 4;\n\n\t\tstate = aa_dfa_match(dfa, state, data);\n\t\tif (!state)\n\t\t\treturn 5;\n\t\t*perms = compute_mnt_perms(dfa, state);\n\t\tif (perms->allow & AA_MAY_MOUNT)\n\t\t\treturn 0;\n\t}\n\n\t/* failed at end of flags match */\n\treturn 4;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "devname"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "devname"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aa_path_name",
          "args": [
            "mntpath",
            "path_flags(profile, mntpath)",
            "buffer",
            "&mntpnt",
            "&info",
            "profile->disconnected"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "aa_path_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/path.c",
          "lines": "201-221",
          "snippet": "int aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/fs_struct.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/path.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/magic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/apparmor.h\"\n#include <linux/fs_struct.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/path.h>\n#include <linux/nsproxy.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/magic.h>\n\nint aa_path_name(const struct path *path, int flags, char *buffer,\n\t\t const char **name, const char **info, const char *disconnected)\n{\n\tchar *str = NULL;\n\tint error = d_namespace_path(path, buffer, &str, flags, disconnected);\n\n\tif (info && error) {\n\t\tif (error == -ENOENT)\n\t\t\t*info = \"Failed name lookup - deleted entry\";\n\t\telse if (error == -EACCES)\n\t\t\t*info = \"Failed name lookup - disconnected path\";\n\t\telse if (error == -ENAMETOOLONG)\n\t\t\t*info = \"Failed name lookup - name too long\";\n\t\telse\n\t\t\t*info = \"Failed name lookup\";\n\t}\n\n\t*name = str;\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "path_flags",
          "args": [
            "profile",
            "mntpath"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "path_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "295-302",
          "snippet": "static int path_flags(struct aa_profile *profile, const struct path *path)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\treturn profile->path_flags |\n\t\t(S_ISDIR(path->dentry->d_inode->i_mode) ? PATH_IS_DIR : 0);\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int path_flags(struct aa_profile *profile, const struct path *path)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\treturn profile->path_flags |\n\t\t(S_ISDIR(path->dentry->d_inode->i_mode) ? PATH_IS_DIR : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!buffer"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!mntpath"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!profile"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic const char * const mnt_info_table[] = {\n\t\"match succeeded\",\n\t\"failed mntpnt match\",\n\t\"failed srcname match\",\n\t\"failed type match\",\n\t\"failed flags match\",\n\t\"failed data match\"\n};\n\nstatic int match_mnt_path_str(struct aa_profile *profile,\n\t\t\t      const struct path *mntpath, char *buffer,\n\t\t\t      const char *devname, const char *type,\n\t\t\t      unsigned long flags, void *data, bool binary,\n\t\t\t      const char *devinfo)\n{\n\tstruct aa_perms perms = { };\n\tconst char *mntpnt = NULL, *info = NULL;\n\tint pos, error;\n\n\tAA_BUG(!profile);\n\tAA_BUG(!mntpath);\n\tAA_BUG(!buffer);\n\n\terror = aa_path_name(mntpath, path_flags(profile, mntpath), buffer,\n\t\t\t     &mntpnt, &info, profile->disconnected);\n\tif (error)\n\t\tgoto audit;\n\tif (IS_ERR(devname)) {\n\t\terror = PTR_ERR(devname);\n\t\tdevname = NULL;\n\t\tinfo = devinfo;\n\t\tgoto audit;\n\t}\n\n\terror = -EACCES;\n\tpos = do_match_mnt(profile->policy.dfa,\n\t\t\t   profile->policy.start[AA_CLASS_MOUNT],\n\t\t\t   mntpnt, devname, type, flags, data, binary, &perms);\n\tif (pos) {\n\t\tinfo = mnt_info_table[pos];\n\t\tgoto audit;\n\t}\n\terror = 0;\n\naudit:\n\treturn audit_mount(profile, OP_MOUNT, mntpnt, devname, type, NULL,\n\t\t\t   flags, data, AA_MAY_MOUNT, &perms, info, error);\n}"
  },
  {
    "function_name": "path_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "295-302",
    "snippet": "static int path_flags(struct aa_profile *profile, const struct path *path)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\treturn profile->path_flags |\n\t\t(S_ISDIR(path->dentry->d_inode->i_mode) ? PATH_IS_DIR : 0);\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "path->dentry->d_inode->i_mode"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!path"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!profile"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int path_flags(struct aa_profile *profile, const struct path *path)\n{\n\tAA_BUG(!profile);\n\tAA_BUG(!path);\n\n\treturn profile->path_flags |\n\t\t(S_ISDIR(path->dentry->d_inode->i_mode) ? PATH_IS_DIR : 0);\n}"
  },
  {
    "function_name": "do_match_mnt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "242-292",
    "snippet": "static int do_match_mnt(struct aa_dfa *dfa, unsigned int start,\n\t\t\tconst char *mntpnt, const char *devname,\n\t\t\tconst char *type, unsigned long flags,\n\t\t\tvoid *data, bool binary, struct aa_perms *perms)\n{\n\tunsigned int state;\n\n\tAA_BUG(!dfa);\n\tAA_BUG(!perms);\n\n\tstate = aa_dfa_match(dfa, start, mntpnt);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 1;\n\n\tif (devname)\n\t\tstate = aa_dfa_match(dfa, state, devname);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 2;\n\n\tif (type)\n\t\tstate = aa_dfa_match(dfa, state, type);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 3;\n\n\tstate = match_mnt_flags(dfa, state, flags);\n\tif (!state)\n\t\treturn 4;\n\t*perms = compute_mnt_perms(dfa, state);\n\tif (perms->allow & AA_MAY_MOUNT)\n\t\treturn 0;\n\n\t/* only match data if not binary and the DFA flags data is expected */\n\tif (data && !binary && (perms->allow & AA_MNT_CONT_MATCH)) {\n\t\tstate = aa_dfa_null_transition(dfa, state);\n\t\tif (!state)\n\t\t\treturn 4;\n\n\t\tstate = aa_dfa_match(dfa, state, data);\n\t\tif (!state)\n\t\t\treturn 5;\n\t\t*perms = compute_mnt_perms(dfa, state);\n\t\tif (perms->allow & AA_MAY_MOUNT)\n\t\t\treturn 0;\n\t}\n\n\t/* failed at end of flags match */\n\treturn 4;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compute_mnt_perms",
          "args": [
            "dfa",
            "state"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "compute_mnt_perms",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "216-227",
          "snippet": "static struct aa_perms compute_mnt_perms(struct aa_dfa *dfa,\n\t\t\t\t\t   unsigned int state)\n{\n\tstruct aa_perms perms = {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t\t.xindex = dfa_user_xindex(dfa, state),\n\t};\n\n\treturn perms;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct aa_perms compute_mnt_perms(struct aa_dfa *dfa,\n\t\t\t\t\t   unsigned int state)\n{\n\tstruct aa_perms perms = {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t\t.xindex = dfa_user_xindex(dfa, state),\n\t};\n\n\treturn perms;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_match",
          "args": [
            "dfa",
            "state",
            "data"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "381-417",
          "snippet": "unsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_match(struct aa_dfa *dfa, unsigned int start,\n\t\t\t  const char *str)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int state = start, pos;\n\n\tif (state == 0)\n\t\treturn 0;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + equiv[(u8) *str++];\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t} else {\n\t\t/* default is direct to next state */\n\t\twhile (*str) {\n\t\t\tpos = base_idx(base[state]) + (u8) *str++;\n\t\t\tif (check[pos] == state)\n\t\t\t\tstate = next[pos];\n\t\t\telse\n\t\t\t\tstate = def[state];\n\t\t}\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aa_dfa_null_transition",
          "args": [
            "dfa",
            "state"
          ],
          "line": 278
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_null_transition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/lib.h",
          "lines": "80-85",
          "snippet": "static inline unsigned int aa_dfa_null_transition(struct aa_dfa *dfa,\n\t\t\t\t\t\t  unsigned int start)\n{\n\t/* the null transition only needs the string's null terminator byte */\n\treturn aa_dfa_next(dfa, start, 0);\n}",
          "includes": [
            "#include \"match.h\"",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"match.h\"\n#include <linux/fs.h>\n#include <linux/slab.h>\n\nstatic inline unsigned int aa_dfa_null_transition(struct aa_dfa *dfa,\n\t\t\t\t\t\t  unsigned int start)\n{\n\t/* the null transition only needs the string's null terminator byte */\n\treturn aa_dfa_next(dfa, start, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "match_mnt_flags",
          "args": [
            "dfa",
            "state",
            "flags"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "match_mnt_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "196-207",
          "snippet": "static unsigned int match_mnt_flags(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t    unsigned long flags)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i <= 31 ; ++i) {\n\t\tif ((1 << i) & flags)\n\t\t\tstate = aa_dfa_next(dfa, state, i + 1);\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic unsigned int match_mnt_flags(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t    unsigned long flags)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i <= 31 ; ++i) {\n\t\tif ((1 << i) & flags)\n\t\t\tstate = aa_dfa_next(dfa, state, i + 1);\n\t}\n\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!perms"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AA_BUG",
          "args": [
            "!dfa"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int do_match_mnt(struct aa_dfa *dfa, unsigned int start,\n\t\t\tconst char *mntpnt, const char *devname,\n\t\t\tconst char *type, unsigned long flags,\n\t\t\tvoid *data, bool binary, struct aa_perms *perms)\n{\n\tunsigned int state;\n\n\tAA_BUG(!dfa);\n\tAA_BUG(!perms);\n\n\tstate = aa_dfa_match(dfa, start, mntpnt);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 1;\n\n\tif (devname)\n\t\tstate = aa_dfa_match(dfa, state, devname);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 2;\n\n\tif (type)\n\t\tstate = aa_dfa_match(dfa, state, type);\n\tstate = aa_dfa_null_transition(dfa, state);\n\tif (!state)\n\t\treturn 3;\n\n\tstate = match_mnt_flags(dfa, state, flags);\n\tif (!state)\n\t\treturn 4;\n\t*perms = compute_mnt_perms(dfa, state);\n\tif (perms->allow & AA_MAY_MOUNT)\n\t\treturn 0;\n\n\t/* only match data if not binary and the DFA flags data is expected */\n\tif (data && !binary && (perms->allow & AA_MNT_CONT_MATCH)) {\n\t\tstate = aa_dfa_null_transition(dfa, state);\n\t\tif (!state)\n\t\t\treturn 4;\n\n\t\tstate = aa_dfa_match(dfa, state, data);\n\t\tif (!state)\n\t\t\treturn 5;\n\t\t*perms = compute_mnt_perms(dfa, state);\n\t\tif (perms->allow & AA_MAY_MOUNT)\n\t\t\treturn 0;\n\t}\n\n\t/* failed at end of flags match */\n\treturn 4;\n}"
  },
  {
    "function_name": "compute_mnt_perms",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "216-227",
    "snippet": "static struct aa_perms compute_mnt_perms(struct aa_dfa *dfa,\n\t\t\t\t\t   unsigned int state)\n{\n\tstruct aa_perms perms = {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t\t.xindex = dfa_user_xindex(dfa, state),\n\t};\n\n\treturn perms;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dfa_user_xindex",
          "args": [
            "dfa",
            "state"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_user_quiet",
          "args": [
            "dfa",
            "state"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_user_audit",
          "args": [
            "dfa",
            "state"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dfa_user_allow",
          "args": [
            "dfa",
            "state"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic struct aa_perms compute_mnt_perms(struct aa_dfa *dfa,\n\t\t\t\t\t   unsigned int state)\n{\n\tstruct aa_perms perms = {\n\t\t.allow = dfa_user_allow(dfa, state),\n\t\t.audit = dfa_user_audit(dfa, state),\n\t\t.quiet = dfa_user_quiet(dfa, state),\n\t\t.xindex = dfa_user_xindex(dfa, state),\n\t};\n\n\treturn perms;\n}"
  },
  {
    "function_name": "match_mnt_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "196-207",
    "snippet": "static unsigned int match_mnt_flags(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t    unsigned long flags)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i <= 31 ; ++i) {\n\t\tif ((1 << i) & flags)\n\t\t\tstate = aa_dfa_next(dfa, state, i + 1);\n\t}\n\n\treturn state;\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_dfa_next",
          "args": [
            "dfa",
            "state",
            "i + 1"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "aa_dfa_next",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/match.c",
          "lines": "429-459",
          "snippet": "unsigned int aa_dfa_next(struct aa_dfa *dfa, unsigned int state,\n\t\t\t  const char c)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int pos;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\n\t\tpos = base_idx(base[state]) + equiv[(u8) c];\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t} else {\n\t\t/* default is direct to next state */\n\t\tpos = base_idx(base[state]) + (u8) c;\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t}\n\n\treturn state;\n}",
          "includes": [
            "#include \"include/match.h\"",
            "#include \"include/lib.h\"",
            "#include <linux/kref.h>",
            "#include <linux/err.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/match.h\"\n#include \"include/lib.h\"\n#include <linux/kref.h>\n#include <linux/err.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n#include <linux/errno.h>\n\nunsigned int aa_dfa_next(struct aa_dfa *dfa, unsigned int state,\n\t\t\t  const char c)\n{\n\tu16 *def = DEFAULT_TABLE(dfa);\n\tu32 *base = BASE_TABLE(dfa);\n\tu16 *next = NEXT_TABLE(dfa);\n\tu16 *check = CHECK_TABLE(dfa);\n\tunsigned int pos;\n\n\t/* current state is <state>, matching character *str */\n\tif (dfa->tables[YYTD_ID_EC]) {\n\t\t/* Equivalence class table defined */\n\t\tu8 *equiv = EQUIV_TABLE(dfa);\n\t\t/* default is direct to next state */\n\n\t\tpos = base_idx(base[state]) + equiv[(u8) c];\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t} else {\n\t\t/* default is direct to next state */\n\t\tpos = base_idx(base[state]) + (u8) c;\n\t\tif (check[pos] == state)\n\t\t\tstate = next[pos];\n\t\telse\n\t\t\tstate = def[state];\n\t}\n\n\treturn state;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic unsigned int match_mnt_flags(struct aa_dfa *dfa, unsigned int state,\n\t\t\t\t    unsigned long flags)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i <= 31 ; ++i) {\n\t\tif ((1 << i) & flags)\n\t\t\tstate = aa_dfa_next(dfa, state, i + 1);\n\t}\n\n\treturn state;\n}"
  },
  {
    "function_name": "audit_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "133-182",
    "snippet": "static int audit_mount(struct aa_profile *profile, const char *op,\n\t\t       const char *name, const char *src_name,\n\t\t       const char *type, const char *trans,\n\t\t       unsigned long flags, const void *data, u32 request,\n\t\t       struct aa_perms *perms, const char *info, int error)\n{\n\tint audit_type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, op);\n\n\tif (likely(!error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= mask;\n\n\t\tif (likely(!request))\n\t\t\treturn 0;\n\t\taudit_type = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\trequest = request & ~perms->allow;\n\n\t\tif (request & perms->kill)\n\t\t\taudit_type = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\trequest &= ~perms->quiet;\n\n\t\tif (!request)\n\t\t\treturn error;\n\t}\n\n\taad(&sa)->name = name;\n\taad(&sa)->mnt.src_name = src_name;\n\taad(&sa)->mnt.type = type;\n\taad(&sa)->mnt.trans = trans;\n\taad(&sa)->mnt.flags = flags;\n\tif (data && (perms->audit & AA_AUDIT_DATA))\n\t\taad(&sa)->mnt.data = data;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(audit_type, profile, &sa, audit_cb);\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "aa_audit",
          "args": [
            "audit_type",
            "profile",
            "&sa",
            "audit_cb"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "aa_audit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/audit.c",
          "lines": "129-165",
          "snippet": "int aa_audit(int type, struct aa_profile *profile, struct common_audit_data *sa,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!aad(sa)->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET))\n\t\treturn aad(sa)->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\taad(sa)->label = &profile->label;\n\n\taa_audit_msg(type, sa, cb);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tsa->type == LSM_AUDIT_DATA_TASK && sa->u.tsk ?\n\t\t\t\t    sa->u.tsk : current);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(aad(sa)->error);\n\n\treturn aad(sa)->error;\n}",
          "includes": [
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/socket.h>\n#include <linux/audit.h>\n\nint aa_audit(int type, struct aa_profile *profile, struct common_audit_data *sa,\n\t     void (*cb) (struct audit_buffer *, void *))\n{\n\tAA_BUG(!profile);\n\n\tif (type == AUDIT_APPARMOR_AUTO) {\n\t\tif (likely(!aad(sa)->error)) {\n\t\t\tif (AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\t\treturn 0;\n\t\t\ttype = AUDIT_APPARMOR_AUDIT;\n\t\t} else if (COMPLAIN_MODE(profile))\n\t\t\ttype = AUDIT_APPARMOR_ALLOWED;\n\t\telse\n\t\t\ttype = AUDIT_APPARMOR_DENIED;\n\t}\n\tif (AUDIT_MODE(profile) == AUDIT_QUIET ||\n\t    (type == AUDIT_APPARMOR_DENIED &&\n\t     AUDIT_MODE(profile) == AUDIT_QUIET))\n\t\treturn aad(sa)->error;\n\n\tif (KILL_MODE(profile) && type == AUDIT_APPARMOR_DENIED)\n\t\ttype = AUDIT_APPARMOR_KILL;\n\n\taad(sa)->label = &profile->label;\n\n\taa_audit_msg(type, sa, cb);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_KILL)\n\t\t(void)send_sig_info(SIGKILL, NULL,\n\t\t\tsa->type == LSM_AUDIT_DATA_TASK && sa->u.tsk ?\n\t\t\t\t    sa->u.tsk : current);\n\n\tif (aad(sa)->type == AUDIT_APPARMOR_ALLOWED)\n\t\treturn complain_error(aad(sa)->error);\n\n\treturn aad(sa)->error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "&sa"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_MODE",
          "args": [
            "profile"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "AUDIT_MODE",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/include/policy.h",
          "lines": "283-289",
          "snippet": "static inline int AUDIT_MODE(struct aa_profile *profile)\n{\n\tif (aa_g_audit != AUDIT_NORMAL)\n\t\treturn aa_g_audit;\n\n\treturn profile->audit;\n}",
          "includes": [
            "#include \"resource.h\"",
            "#include \"perms.h\"",
            "#include \"label.h\"",
            "#include \"lib.h\"",
            "#include \"file.h\"",
            "#include \"domain.h\"",
            "#include \"capability.h\"",
            "#include \"audit.h\"",
            "#include \"apparmor.h\"",
            "#include <linux/socket.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/kref.h>",
            "#include <linux/cred.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"resource.h\"\n#include \"perms.h\"\n#include \"label.h\"\n#include \"lib.h\"\n#include \"file.h\"\n#include \"domain.h\"\n#include \"capability.h\"\n#include \"audit.h\"\n#include \"apparmor.h\"\n#include <linux/socket.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/rhashtable.h>\n#include <linux/kref.h>\n#include <linux/cred.h>\n#include <linux/capability.h>\n\nstatic inline int AUDIT_MODE(struct aa_profile *profile)\n{\n\tif (aa_g_audit != AUDIT_NORMAL)\n\t\treturn aa_g_audit;\n\n\treturn profile->audit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!request"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "AUDIT_MODE(profile) == AUDIT_ALL"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!error"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DEFINE_AUDIT_DATA",
          "args": [
            "sa",
            "LSM_AUDIT_DATA_NONE",
            "op"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic int audit_mount(struct aa_profile *profile, const char *op,\n\t\t       const char *name, const char *src_name,\n\t\t       const char *type, const char *trans,\n\t\t       unsigned long flags, const void *data, u32 request,\n\t\t       struct aa_perms *perms, const char *info, int error)\n{\n\tint audit_type = AUDIT_APPARMOR_AUTO;\n\tDEFINE_AUDIT_DATA(sa, LSM_AUDIT_DATA_NONE, op);\n\n\tif (likely(!error)) {\n\t\tu32 mask = perms->audit;\n\n\t\tif (unlikely(AUDIT_MODE(profile) == AUDIT_ALL))\n\t\t\tmask = 0xffff;\n\n\t\t/* mask off perms that are not being force audited */\n\t\trequest &= mask;\n\n\t\tif (likely(!request))\n\t\t\treturn 0;\n\t\taudit_type = AUDIT_APPARMOR_AUDIT;\n\t} else {\n\t\t/* only report permissions that were denied */\n\t\trequest = request & ~perms->allow;\n\n\t\tif (request & perms->kill)\n\t\t\taudit_type = AUDIT_APPARMOR_KILL;\n\n\t\t/* quiet known rejects, assumes quiet and kill do not overlap */\n\t\tif ((request & perms->quiet) &&\n\t\t    AUDIT_MODE(profile) != AUDIT_NOQUIET &&\n\t\t    AUDIT_MODE(profile) != AUDIT_ALL)\n\t\t\trequest &= ~perms->quiet;\n\n\t\tif (!request)\n\t\t\treturn error;\n\t}\n\n\taad(&sa)->name = name;\n\taad(&sa)->mnt.src_name = src_name;\n\taad(&sa)->mnt.type = type;\n\taad(&sa)->mnt.trans = trans;\n\taad(&sa)->mnt.flags = flags;\n\tif (data && (perms->audit & AA_AUDIT_DATA))\n\t\taad(&sa)->mnt.data = data;\n\taad(&sa)->info = info;\n\taad(&sa)->error = error;\n\n\treturn aa_audit(audit_type, profile, &sa, audit_cb);\n}"
  },
  {
    "function_name": "audit_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "89-114",
    "snippet": "static void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\tif (aad(sa)->mnt.type) {\n\t\taudit_log_format(ab, \" fstype=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->mnt.type);\n\t}\n\tif (aad(sa)->mnt.src_name) {\n\t\taudit_log_format(ab, \" srcname=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->mnt.src_name);\n\t}\n\tif (aad(sa)->mnt.trans) {\n\t\taudit_log_format(ab, \" trans=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->mnt.trans);\n\t}\n\tif (aad(sa)->mnt.flags) {\n\t\taudit_log_format(ab, \" flags=\\\"\");\n\t\taudit_mnt_flags(ab, aad(sa)->mnt.flags);\n\t\taudit_log_format(ab, \"\\\"\");\n\t}\n\tif (aad(sa)->mnt.data) {\n\t\taudit_log_format(ab, \" options=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->mnt.data);\n\t}\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "aad(sa)->mnt.data"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" options=\""
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"\\\"\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_mnt_flags",
          "args": [
            "ab",
            "aad(sa)->mnt.flags"
          ],
          "line": 107
        },
        "resolved": true,
        "details": {
          "function_name": "audit_mnt_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
          "lines": "30-82",
          "snippet": "static void audit_mnt_flags(struct audit_buffer *ab, unsigned long flags)\n{\n\tif (flags & MS_RDONLY)\n\t\taudit_log_format(ab, \"ro\");\n\telse\n\t\taudit_log_format(ab, \"rw\");\n\tif (flags & MS_NOSUID)\n\t\taudit_log_format(ab, \", nosuid\");\n\tif (flags & MS_NODEV)\n\t\taudit_log_format(ab, \", nodev\");\n\tif (flags & MS_NOEXEC)\n\t\taudit_log_format(ab, \", noexec\");\n\tif (flags & MS_SYNCHRONOUS)\n\t\taudit_log_format(ab, \", sync\");\n\tif (flags & MS_REMOUNT)\n\t\taudit_log_format(ab, \", remount\");\n\tif (flags & MS_MANDLOCK)\n\t\taudit_log_format(ab, \", mand\");\n\tif (flags & MS_DIRSYNC)\n\t\taudit_log_format(ab, \", dirsync\");\n\tif (flags & MS_NOATIME)\n\t\taudit_log_format(ab, \", noatime\");\n\tif (flags & MS_NODIRATIME)\n\t\taudit_log_format(ab, \", nodiratime\");\n\tif (flags & MS_BIND)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rbind\" : \", bind\");\n\tif (flags & MS_MOVE)\n\t\taudit_log_format(ab, \", move\");\n\tif (flags & MS_SILENT)\n\t\taudit_log_format(ab, \", silent\");\n\tif (flags & MS_POSIXACL)\n\t\taudit_log_format(ab, \", acl\");\n\tif (flags & MS_UNBINDABLE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", runbindable\" :\n\t\t\t\t \", unbindable\");\n\tif (flags & MS_PRIVATE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rprivate\" :\n\t\t\t\t \", private\");\n\tif (flags & MS_SLAVE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rslave\" :\n\t\t\t\t \", slave\");\n\tif (flags & MS_SHARED)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rshared\" :\n\t\t\t\t \", shared\");\n\tif (flags & MS_RELATIME)\n\t\taudit_log_format(ab, \", relatime\");\n\tif (flags & MS_I_VERSION)\n\t\taudit_log_format(ab, \", iversion\");\n\tif (flags & MS_STRICTATIME)\n\t\taudit_log_format(ab, \", strictatime\");\n\tif (flags & MS_NOUSER)\n\t\taudit_log_format(ab, \", nouser\");\n}",
          "includes": [
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/mount.h\"",
            "#include \"include/match.h\"",
            "#include \"include/file.h\"",
            "#include \"include/domain.h\"",
            "#include \"include/context.h\"",
            "#include \"include/audit.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void audit_mnt_flags(struct audit_buffer *ab, unsigned long flags)\n{\n\tif (flags & MS_RDONLY)\n\t\taudit_log_format(ab, \"ro\");\n\telse\n\t\taudit_log_format(ab, \"rw\");\n\tif (flags & MS_NOSUID)\n\t\taudit_log_format(ab, \", nosuid\");\n\tif (flags & MS_NODEV)\n\t\taudit_log_format(ab, \", nodev\");\n\tif (flags & MS_NOEXEC)\n\t\taudit_log_format(ab, \", noexec\");\n\tif (flags & MS_SYNCHRONOUS)\n\t\taudit_log_format(ab, \", sync\");\n\tif (flags & MS_REMOUNT)\n\t\taudit_log_format(ab, \", remount\");\n\tif (flags & MS_MANDLOCK)\n\t\taudit_log_format(ab, \", mand\");\n\tif (flags & MS_DIRSYNC)\n\t\taudit_log_format(ab, \", dirsync\");\n\tif (flags & MS_NOATIME)\n\t\taudit_log_format(ab, \", noatime\");\n\tif (flags & MS_NODIRATIME)\n\t\taudit_log_format(ab, \", nodiratime\");\n\tif (flags & MS_BIND)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rbind\" : \", bind\");\n\tif (flags & MS_MOVE)\n\t\taudit_log_format(ab, \", move\");\n\tif (flags & MS_SILENT)\n\t\taudit_log_format(ab, \", silent\");\n\tif (flags & MS_POSIXACL)\n\t\taudit_log_format(ab, \", acl\");\n\tif (flags & MS_UNBINDABLE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", runbindable\" :\n\t\t\t\t \", unbindable\");\n\tif (flags & MS_PRIVATE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rprivate\" :\n\t\t\t\t \", private\");\n\tif (flags & MS_SLAVE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rslave\" :\n\t\t\t\t \", slave\");\n\tif (flags & MS_SHARED)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rshared\" :\n\t\t\t\t \", shared\");\n\tif (flags & MS_RELATIME)\n\t\taudit_log_format(ab, \", relatime\");\n\tif (flags & MS_I_VERSION)\n\t\taudit_log_format(ab, \", iversion\");\n\tif (flags & MS_STRICTATIME)\n\t\taudit_log_format(ab, \", strictatime\");\n\tif (flags & MS_NOUSER)\n\t\taudit_log_format(ab, \", nouser\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" flags=\\\"\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "aad(sa)->mnt.trans"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" trans=\""
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "aad(sa)->mnt.src_name"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" srcname=\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "aad(sa)->mnt.type"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" fstype=\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aad",
          "args": [
            "sa"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void audit_cb(struct audit_buffer *ab, void *va)\n{\n\tstruct common_audit_data *sa = va;\n\n\tif (aad(sa)->mnt.type) {\n\t\taudit_log_format(ab, \" fstype=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->mnt.type);\n\t}\n\tif (aad(sa)->mnt.src_name) {\n\t\taudit_log_format(ab, \" srcname=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->mnt.src_name);\n\t}\n\tif (aad(sa)->mnt.trans) {\n\t\taudit_log_format(ab, \" trans=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->mnt.trans);\n\t}\n\tif (aad(sa)->mnt.flags) {\n\t\taudit_log_format(ab, \" flags=\\\"\");\n\t\taudit_mnt_flags(ab, aad(sa)->mnt.flags);\n\t\taudit_log_format(ab, \"\\\"\");\n\t}\n\tif (aad(sa)->mnt.data) {\n\t\taudit_log_format(ab, \" options=\");\n\t\taudit_log_untrustedstring(ab, aad(sa)->mnt.data);\n\t}\n}"
  },
  {
    "function_name": "audit_mnt_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/mount.c",
    "lines": "30-82",
    "snippet": "static void audit_mnt_flags(struct audit_buffer *ab, unsigned long flags)\n{\n\tif (flags & MS_RDONLY)\n\t\taudit_log_format(ab, \"ro\");\n\telse\n\t\taudit_log_format(ab, \"rw\");\n\tif (flags & MS_NOSUID)\n\t\taudit_log_format(ab, \", nosuid\");\n\tif (flags & MS_NODEV)\n\t\taudit_log_format(ab, \", nodev\");\n\tif (flags & MS_NOEXEC)\n\t\taudit_log_format(ab, \", noexec\");\n\tif (flags & MS_SYNCHRONOUS)\n\t\taudit_log_format(ab, \", sync\");\n\tif (flags & MS_REMOUNT)\n\t\taudit_log_format(ab, \", remount\");\n\tif (flags & MS_MANDLOCK)\n\t\taudit_log_format(ab, \", mand\");\n\tif (flags & MS_DIRSYNC)\n\t\taudit_log_format(ab, \", dirsync\");\n\tif (flags & MS_NOATIME)\n\t\taudit_log_format(ab, \", noatime\");\n\tif (flags & MS_NODIRATIME)\n\t\taudit_log_format(ab, \", nodiratime\");\n\tif (flags & MS_BIND)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rbind\" : \", bind\");\n\tif (flags & MS_MOVE)\n\t\taudit_log_format(ab, \", move\");\n\tif (flags & MS_SILENT)\n\t\taudit_log_format(ab, \", silent\");\n\tif (flags & MS_POSIXACL)\n\t\taudit_log_format(ab, \", acl\");\n\tif (flags & MS_UNBINDABLE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", runbindable\" :\n\t\t\t\t \", unbindable\");\n\tif (flags & MS_PRIVATE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rprivate\" :\n\t\t\t\t \", private\");\n\tif (flags & MS_SLAVE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rslave\" :\n\t\t\t\t \", slave\");\n\tif (flags & MS_SHARED)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rshared\" :\n\t\t\t\t \", shared\");\n\tif (flags & MS_RELATIME)\n\t\taudit_log_format(ab, \", relatime\");\n\tif (flags & MS_I_VERSION)\n\t\taudit_log_format(ab, \", iversion\");\n\tif (flags & MS_STRICTATIME)\n\t\taudit_log_format(ab, \", strictatime\");\n\tif (flags & MS_NOUSER)\n\t\taudit_log_format(ab, \", nouser\");\n}",
    "includes": [
      "#include \"include/policy.h\"",
      "#include \"include/path.h\"",
      "#include \"include/mount.h\"",
      "#include \"include/match.h\"",
      "#include \"include/file.h\"",
      "#include \"include/domain.h\"",
      "#include \"include/context.h\"",
      "#include \"include/audit.h\"",
      "#include \"include/apparmor.h\"",
      "#include <linux/namei.h>",
      "#include <linux/mount.h>",
      "#include <linux/fs.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", nouser\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", strictatime\""
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", iversion\""
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", relatime\""
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "flags & MS_REC ? \", rshared\" :\n\t\t\t\t \", shared\""
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "flags & MS_REC ? \", rslave\" :\n\t\t\t\t \", slave\""
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "flags & MS_REC ? \", rprivate\" :\n\t\t\t\t \", private\""
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "flags & MS_REC ? \", runbindable\" :\n\t\t\t\t \", unbindable\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", acl\""
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", silent\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", move\""
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "flags & MS_REC ? \", rbind\" : \", bind\""
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", nodiratime\""
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", noatime\""
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", dirsync\""
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", mand\""
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", remount\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", sync\""
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", noexec\""
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", nodev\""
          ],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\", nosuid\""
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"rw\""
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"ro\""
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/mount.h\"\n#include \"include/match.h\"\n#include \"include/file.h\"\n#include \"include/domain.h\"\n#include \"include/context.h\"\n#include \"include/audit.h\"\n#include \"include/apparmor.h\"\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n\nstatic void audit_mnt_flags(struct audit_buffer *ab, unsigned long flags)\n{\n\tif (flags & MS_RDONLY)\n\t\taudit_log_format(ab, \"ro\");\n\telse\n\t\taudit_log_format(ab, \"rw\");\n\tif (flags & MS_NOSUID)\n\t\taudit_log_format(ab, \", nosuid\");\n\tif (flags & MS_NODEV)\n\t\taudit_log_format(ab, \", nodev\");\n\tif (flags & MS_NOEXEC)\n\t\taudit_log_format(ab, \", noexec\");\n\tif (flags & MS_SYNCHRONOUS)\n\t\taudit_log_format(ab, \", sync\");\n\tif (flags & MS_REMOUNT)\n\t\taudit_log_format(ab, \", remount\");\n\tif (flags & MS_MANDLOCK)\n\t\taudit_log_format(ab, \", mand\");\n\tif (flags & MS_DIRSYNC)\n\t\taudit_log_format(ab, \", dirsync\");\n\tif (flags & MS_NOATIME)\n\t\taudit_log_format(ab, \", noatime\");\n\tif (flags & MS_NODIRATIME)\n\t\taudit_log_format(ab, \", nodiratime\");\n\tif (flags & MS_BIND)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rbind\" : \", bind\");\n\tif (flags & MS_MOVE)\n\t\taudit_log_format(ab, \", move\");\n\tif (flags & MS_SILENT)\n\t\taudit_log_format(ab, \", silent\");\n\tif (flags & MS_POSIXACL)\n\t\taudit_log_format(ab, \", acl\");\n\tif (flags & MS_UNBINDABLE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", runbindable\" :\n\t\t\t\t \", unbindable\");\n\tif (flags & MS_PRIVATE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rprivate\" :\n\t\t\t\t \", private\");\n\tif (flags & MS_SLAVE)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rslave\" :\n\t\t\t\t \", slave\");\n\tif (flags & MS_SHARED)\n\t\taudit_log_format(ab, flags & MS_REC ? \", rshared\" :\n\t\t\t\t \", shared\");\n\tif (flags & MS_RELATIME)\n\t\taudit_log_format(ab, \", relatime\");\n\tif (flags & MS_I_VERSION)\n\t\taudit_log_format(ab, \", iversion\");\n\tif (flags & MS_STRICTATIME)\n\t\taudit_log_format(ab, \", strictatime\");\n\tif (flags & MS_NOUSER)\n\t\taudit_log_format(ab, \", nouser\");\n}"
  }
]