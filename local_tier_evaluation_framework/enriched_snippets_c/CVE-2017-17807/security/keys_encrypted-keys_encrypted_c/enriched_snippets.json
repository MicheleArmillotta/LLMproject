[
  {
    "function_name": "cleanup_encrypted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "1007-1011",
    "snippet": "static void __exit cleanup_encrypted(void)\n{\n\tcrypto_free_shash(hash_tfm);\n\tunregister_key_type(&key_type_encrypted);\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct crypto_shash *hash_tfm;",
      "struct key_type key_type_encrypted = {\n\t.name = \"encrypted\",\n\t.instantiate = encrypted_instantiate,\n\t.update = encrypted_update,\n\t.destroy = encrypted_destroy,\n\t.describe = user_describe,\n\t.read = encrypted_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_key_type",
          "args": [
            "&key_type_encrypted"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_key_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "1149-1157",
          "snippet": "void unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(key_types_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(key_types_sem);\n\nvoid unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "hash_tfm"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic struct crypto_shash *hash_tfm;\nstruct key_type key_type_encrypted = {\n\t.name = \"encrypted\",\n\t.instantiate = encrypted_instantiate,\n\t.update = encrypted_update,\n\t.destroy = encrypted_destroy,\n\t.describe = user_describe,\n\t.read = encrypted_read,\n};\n\nstatic void __exit cleanup_encrypted(void)\n{\n\tcrypto_free_shash(hash_tfm);\n\tunregister_key_type(&key_type_encrypted);\n}"
  },
  {
    "function_name": "init_encrypted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "983-1005",
    "snippet": "static int __init init_encrypted(void)\n{\n\tint ret;\n\n\thash_tfm = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hash_tfm)) {\n\t\tpr_err(\"encrypted_key: can't allocate %s transform: %ld\\n\",\n\t\t       hash_alg, PTR_ERR(hash_tfm));\n\t\treturn PTR_ERR(hash_tfm);\n\t}\n\n\tret = aes_get_sizes();\n\tif (ret < 0)\n\t\tgoto out;\n\tret = register_key_type(&key_type_encrypted);\n\tif (ret < 0)\n\t\tgoto out;\n\treturn 0;\nout:\n\tcrypto_free_shash(hash_tfm);\n\treturn ret;\n\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char hash_alg[] = \"sha256\";",
      "static struct crypto_shash *hash_tfm;",
      "struct key_type key_type_encrypted = {\n\t.name = \"encrypted\",\n\t.instantiate = encrypted_instantiate,\n\t.update = encrypted_update,\n\t.destroy = encrypted_destroy,\n\t.describe = user_describe,\n\t.read = encrypted_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "hash_tfm"
          ],
          "line": 1002
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_key_type",
          "args": [
            "&key_type_encrypted"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_key_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "1149-1157",
          "snippet": "void unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(key_types_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(key_types_sem);\n\nvoid unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "aes_get_sizes",
          "args": [],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "aes_get_sizes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "81-95",
          "snippet": "static int aes_get_sizes(void)\n{\n\tstruct crypto_skcipher *tfm;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to alloc_cipher (%ld)\\n\",\n\t\t       PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tivsize = crypto_skcipher_ivsize(tfm);\n\tblksize = crypto_skcipher_blocksize(tfm);\n\tcrypto_free_skcipher(tfm);\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char blkcipher_alg[] = \"cbc(aes)\";",
            "static unsigned int ivsize;",
            "static int blksize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char blkcipher_alg[] = \"cbc(aes)\";\nstatic unsigned int ivsize;\nstatic int blksize;\n\nstatic int aes_get_sizes(void)\n{\n\tstruct crypto_skcipher *tfm;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to alloc_cipher (%ld)\\n\",\n\t\t       PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tivsize = crypto_skcipher_ivsize(tfm);\n\tblksize = crypto_skcipher_blocksize(tfm);\n\tcrypto_free_skcipher(tfm);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hash_tfm"
          ],
          "line": 991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: can't allocate %s transform: %ld\\n\"",
            "hash_alg",
            "PTR_ERR(hash_tfm)"
          ],
          "line": 989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hash_tfm"
          ],
          "line": 990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hash_tfm"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "hash_alg",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char hash_alg[] = \"sha256\";\nstatic struct crypto_shash *hash_tfm;\nstruct key_type key_type_encrypted = {\n\t.name = \"encrypted\",\n\t.instantiate = encrypted_instantiate,\n\t.update = encrypted_update,\n\t.destroy = encrypted_destroy,\n\t.describe = user_describe,\n\t.read = encrypted_read,\n};\n\nstatic int __init init_encrypted(void)\n{\n\tint ret;\n\n\thash_tfm = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hash_tfm)) {\n\t\tpr_err(\"encrypted_key: can't allocate %s transform: %ld\\n\",\n\t\t       hash_alg, PTR_ERR(hash_tfm));\n\t\treturn PTR_ERR(hash_tfm);\n\t}\n\n\tret = aes_get_sizes();\n\tif (ret < 0)\n\t\tgoto out;\n\tret = register_key_type(&key_type_encrypted);\n\tif (ret < 0)\n\t\tgoto out;\n\treturn 0;\nout:\n\tcrypto_free_shash(hash_tfm);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "encrypted_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "968-971",
    "snippet": "static void encrypted_destroy(struct key *key)\n{\n\tkzfree(key->payload.data[0]);\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "key->payload.data[0]"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic void encrypted_destroy(struct key *key)\n{\n\tkzfree(key->payload.data[0]);\n}"
  },
  {
    "function_name": "encrypted_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "905-963",
    "snippet": "static long encrypted_read(const struct key *key, char __user *buffer,\n\t\t\t   size_t buflen)\n{\n\tstruct encrypted_key_payload *epayload;\n\tstruct key *mkey;\n\tconst u8 *master_key;\n\tsize_t master_keylen;\n\tchar derived_key[HASH_SIZE];\n\tchar *ascii_buf;\n\tsize_t asciiblob_len;\n\tint ret;\n\n\tepayload = dereference_key_locked(key);\n\n\t/* returns the hex encoded iv, encrypted-data, and hmac as ascii */\n\tasciiblob_len = epayload->datablob_len + ivsize + 1\n\t    + roundup(epayload->decrypted_datalen, blksize)\n\t    + (HASH_SIZE * 2);\n\n\tif (!buffer || buflen < asciiblob_len)\n\t\treturn asciiblob_len;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = datablob_hmac_append(epayload, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tascii_buf = datablob_format(epayload, asciiblob_len);\n\tif (!ascii_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\n\tif (copy_to_user(buffer, ascii_buf, asciiblob_len) != 0)\n\t\tret = -EFAULT;\n\tkzfree(ascii_buf);\n\n\treturn asciiblob_len;\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define HASH_SIZE SHA256_DIGEST_SIZE"
    ],
    "globals_used": [
      "static unsigned int ivsize;",
      "static int blksize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memzero_explicit",
          "args": [
            "derived_key",
            "sizeof(derived_key)"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "mkey"
          ],
          "line": 960
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mkey->sem"
          ],
          "line": 959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "ascii_buf"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "ascii_buf",
            "asciiblob_len"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memzero_explicit",
          "args": [
            "derived_key",
            "sizeof(derived_key)"
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mkey->sem"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datablob_format",
          "args": [
            "epayload",
            "asciiblob_len"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "datablob_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "269-293",
          "snippet": "static char *datablob_format(struct encrypted_key_payload *epayload,\n\t\t\t     size_t asciiblob_len)\n{\n\tchar *ascii_buf, *bufp;\n\tu8 *iv = epayload->iv;\n\tint len;\n\tint i;\n\n\tascii_buf = kmalloc(asciiblob_len + 1, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\tgoto out;\n\n\tascii_buf[asciiblob_len] = '\\0';\n\n\t/* copy datablob master_desc and datalen strings */\n\tlen = sprintf(ascii_buf, \"%s %s %s \", epayload->format,\n\t\t      epayload->master_desc, epayload->datalen);\n\n\t/* convert the hex encoded iv, encrypted-data and HMAC to ascii */\n\tbufp = &ascii_buf[len];\n\tfor (i = 0; i < (asciiblob_len - len) / 2; i++)\n\t\tbufp = hex_byte_pack(bufp, iv[i]);\nout:\n\treturn ascii_buf;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic char *datablob_format(struct encrypted_key_payload *epayload,\n\t\t\t     size_t asciiblob_len)\n{\n\tchar *ascii_buf, *bufp;\n\tu8 *iv = epayload->iv;\n\tint len;\n\tint i;\n\n\tascii_buf = kmalloc(asciiblob_len + 1, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\tgoto out;\n\n\tascii_buf[asciiblob_len] = '\\0';\n\n\t/* copy datablob master_desc and datalen strings */\n\tlen = sprintf(ascii_buf, \"%s %s %s \", epayload->format,\n\t\t      epayload->master_desc, epayload->datalen);\n\n\t/* convert the hex encoded iv, encrypted-data and HMAC to ascii */\n\tbufp = &ascii_buf[len];\n\tfor (i = 0; i < (asciiblob_len - len) / 2; i++)\n\t\tbufp = hex_byte_pack(bufp, iv[i]);\nout:\n\treturn ascii_buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datablob_hmac_append",
          "args": [
            "epayload",
            "master_key",
            "master_keylen"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "datablob_hmac_append",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "500-519",
          "snippet": "static int datablob_hmac_append(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *master_key, size_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 *digest;\n\tint ret;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdigest = epayload->format + epayload->datablob_len;\n\tret = calc_hmac(digest, derived_key, sizeof derived_key,\n\t\t\tepayload->format, epayload->datablob_len);\n\tif (!ret)\n\t\tdump_hmac(NULL, digest, HASH_SIZE);\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define HASH_SIZE SHA256_DIGEST_SIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic int datablob_hmac_append(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *master_key, size_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 *digest;\n\tint ret;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdigest = epayload->format + epayload->datablob_len;\n\tret = calc_hmac(digest, derived_key, sizeof derived_key,\n\t\t\tepayload->format, epayload->datablob_len);\n\tif (!ret)\n\t\tdump_hmac(NULL, digest, HASH_SIZE);\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "derived_key_encrypt",
          "args": [
            "epayload",
            "derived_key",
            "sizeof derived_key"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "derived_key_encrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "458-498",
          "snippet": "static int derived_key_encrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[2];\n\tstruct scatterlist sg_out[1];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\n\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_page(&sg_in[1], ZERO_PAGE(0), AES_BLOCK_SIZE, 0);\n\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_encrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to encrypt (%d)\\n\", ret);\n\telse\n\t\tdump_encrypted_data(epayload, encrypted_datalen);\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int blksize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic int blksize;\n\nstatic int derived_key_encrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[2];\n\tstruct scatterlist sg_out[1];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\n\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_page(&sg_in[1], ZERO_PAGE(0), AES_BLOCK_SIZE, 0);\n\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_encrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to encrypt (%d)\\n\", ret);\n\telse\n\t\tdump_encrypted_data(epayload, encrypted_datalen);\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_derived_key",
          "args": [
            "derived_key",
            "ENC_KEY",
            "master_key",
            "master_keylen"
          ],
          "line": 931
        },
        "resolved": true,
        "details": {
          "function_name": "get_derived_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "362-387",
          "snippet": "static int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(hash_tfm, derived_key, derived_buf, derived_buf_len);\n\tkzfree(derived_buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define HASH_SIZE SHA256_DIGEST_SIZE"
          ],
          "globals_used": [
            "static struct crypto_shash *hash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic struct crypto_shash *hash_tfm;\n\nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(hash_tfm, derived_key, derived_buf, derived_buf_len);\n\tkzfree(derived_buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mkey"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mkey"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_master_key",
          "args": [
            "epayload",
            "&master_key",
            "&master_keylen"
          ],
          "line": 927
        },
        "resolved": true,
        "details": {
          "function_name": "request_master_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "422-455",
          "snippet": "static struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)",
            "#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)"
          ],
          "globals_used": [
            "static const char KEY_TRUSTED_PREFIX[] = \"trusted:\";",
            "static const char KEY_USER_PREFIX[] = \"user:\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\n\nstatic struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "epayload->decrypted_datalen",
            "blksize"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dereference_key_locked",
          "args": [
            "key"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic unsigned int ivsize;\nstatic int blksize;\n\nstatic long encrypted_read(const struct key *key, char __user *buffer,\n\t\t\t   size_t buflen)\n{\n\tstruct encrypted_key_payload *epayload;\n\tstruct key *mkey;\n\tconst u8 *master_key;\n\tsize_t master_keylen;\n\tchar derived_key[HASH_SIZE];\n\tchar *ascii_buf;\n\tsize_t asciiblob_len;\n\tint ret;\n\n\tepayload = dereference_key_locked(key);\n\n\t/* returns the hex encoded iv, encrypted-data, and hmac as ascii */\n\tasciiblob_len = epayload->datablob_len + ivsize + 1\n\t    + roundup(epayload->decrypted_datalen, blksize)\n\t    + (HASH_SIZE * 2);\n\n\tif (!buffer || buflen < asciiblob_len)\n\t\treturn asciiblob_len;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_encrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = datablob_hmac_append(epayload, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tascii_buf = datablob_format(epayload, asciiblob_len);\n\tif (!ascii_buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\n\tif (copy_to_user(buffer, ascii_buf, asciiblob_len) != 0)\n\t\tret = -EFAULT;\n\tkzfree(ascii_buf);\n\n\treturn asciiblob_len;\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}"
  },
  {
    "function_name": "encrypted_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "847-895",
    "snippet": "static int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (key_is_negative(key))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkzfree(buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static unsigned int ivsize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "buf"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&epayload->rcu",
            "encrypted_rcu_free"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_keypointer",
          "args": [
            "key",
            "new_epayload"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_epayload->payload_data",
            "epayload->payload_data",
            "epayload->payload_datalen"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_epayload->iv",
            "epayload->iv",
            "ivsize"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ekey_init",
          "args": [
            "new_epayload",
            "epayload->format",
            "new_master_desc",
            "epayload->datalen"
          ],
          "line": 883
        },
        "resolved": true,
        "details": {
          "function_name": "__ekey_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "717-743",
          "snippet": "static void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char key_format_default[] = \"default\";",
            "static const char key_format_ecryptfs[] = \"ecryptfs\";",
            "static unsigned int ivsize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\n\nstatic void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "new_epayload"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "new_epayload"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encrypted_key_alloc",
          "args": [
            "key",
            "epayload->format",
            "new_master_desc",
            "epayload->datalen"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "encrypted_key_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "607-658",
          "snippet": "static struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\",\n\t\t\t       ECRYPTFS_MAX_KEY_BYTES);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define MIN_DATA_SIZE  20",
            "#define MAX_DATA_SIZE 4096",
            "#define HASH_SIZE SHA256_DIGEST_SIZE"
          ],
          "globals_used": [
            "static const char key_format_default[] = \"default\";",
            "static const char key_format_ecryptfs[] = \"ecryptfs\";",
            "static unsigned int ivsize;",
            "static int blksize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define MIN_DATA_SIZE  20\n#define MAX_DATA_SIZE 4096\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\nstatic int blksize;\n\nstatic struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\",\n\t\t\t       ECRYPTFS_MAX_KEY_BYTES);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_master_desc",
          "args": [
            "new_master_desc",
            "epayload->master_desc"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "valid_master_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "137-155",
          "snippet": "static int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)",
            "#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)"
          ],
          "globals_used": [
            "static const char KEY_TRUSTED_PREFIX[] = \"trusted:\";",
            "static const char KEY_USER_PREFIX[] = \"user:\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\n\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datablob_parse",
          "args": [
            "buf",
            "&format",
            "&new_master_desc",
            "NULL",
            "NULL"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "datablob_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "171-264",
          "snippet": "static int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_error, NULL}\n};",
            "static const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_error, NULL}\n};\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};\n\nstatic int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "buf",
            "prep->data",
            "datalen"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "datalen + 1",
            "GFP_KERNEL"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_is_negative",
          "args": [
            "key"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic unsigned int ivsize;\n\nstatic int encrypted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = key->payload.data[0];\n\tstruct encrypted_key_payload *new_epayload;\n\tchar *buf;\n\tchar *new_master_desc = NULL;\n\tconst char *format = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret = 0;\n\n\tif (key_is_negative(key))\n\t\treturn -ENOKEY;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tbuf = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!buf)\n\t\treturn -ENOMEM;\n\n\tbuf[datalen] = 0;\n\tmemcpy(buf, prep->data, datalen);\n\tret = datablob_parse(buf, &format, &new_master_desc, NULL, NULL);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = valid_master_desc(new_master_desc, epayload->master_desc);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tnew_epayload = encrypted_key_alloc(key, epayload->format,\n\t\t\t\t\t   new_master_desc, epayload->datalen);\n\tif (IS_ERR(new_epayload)) {\n\t\tret = PTR_ERR(new_epayload);\n\t\tgoto out;\n\t}\n\n\t__ekey_init(new_epayload, epayload->format, new_master_desc,\n\t\t    epayload->datalen);\n\n\tmemcpy(new_epayload->iv, epayload->iv, ivsize);\n\tmemcpy(new_epayload->payload_data, epayload->payload_data,\n\t       epayload->payload_datalen);\n\n\trcu_assign_keypointer(key, new_epayload);\n\tcall_rcu(&epayload->rcu, encrypted_rcu_free);\nout:\n\tkzfree(buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "encrypted_rcu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "830-836",
    "snippet": "static void encrypted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct encrypted_key_payload *epayload;\n\n\tepayload = container_of(rcu, struct encrypted_key_payload, rcu);\n\tkzfree(epayload);\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "epayload"
          ],
          "line": 835
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structencrypted_key_payload",
            "rcu"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic void encrypted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct encrypted_key_payload *epayload;\n\n\tepayload = container_of(rcu, struct encrypted_key_payload, rcu);\n\tkzfree(epayload);\n}"
  },
  {
    "function_name": "encrypted_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "786-828",
    "snippet": "static int encrypted_instantiate(struct key *key,\n\t\t\t\t struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tchar *datablob = NULL;\n\tconst char *format = NULL;\n\tchar *master_desc = NULL;\n\tchar *decrypted_datalen = NULL;\n\tchar *hex_encoded_iv = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tdatablob[datalen] = 0;\n\tmemcpy(datablob, prep->data, datalen);\n\tret = datablob_parse(datablob, &format, &master_desc,\n\t\t\t     &decrypted_datalen, &hex_encoded_iv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tepayload = encrypted_key_alloc(key, format, master_desc,\n\t\t\t\t       decrypted_datalen);\n\tif (IS_ERR(epayload)) {\n\t\tret = PTR_ERR(epayload);\n\t\tgoto out;\n\t}\n\tret = encrypted_init(epayload, key->description, format, master_desc,\n\t\t\t     decrypted_datalen, hex_encoded_iv);\n\tif (ret < 0) {\n\t\tkzfree(epayload);\n\t\tgoto out;\n\t}\n\n\trcu_assign_keypointer(key, epayload);\nout:\n\tkzfree(datablob);\n\treturn ret;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "datablob"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_keypointer",
          "args": [
            "key",
            "epayload"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "epayload"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encrypted_init",
          "args": [
            "epayload",
            "key->description",
            "format",
            "master_desc",
            "decrypted_datalen",
            "hex_encoded_iv"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "encrypted_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "751-776",
          "snippet": "static int encrypted_init(struct encrypted_key_payload *epayload,\n\t\t\t  const char *key_desc, const char *format,\n\t\t\t  const char *master_desc, const char *datalen,\n\t\t\t  const char *hex_encoded_iv)\n{\n\tint ret = 0;\n\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tret = valid_ecryptfs_desc(key_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\n\t\t\t\t       key_desc);\n\t}\n\n\t__ekey_init(epayload, format, master_desc, datalen);\n\tif (!hex_encoded_iv) {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\n\t\tget_random_bytes(epayload->decrypted_data,\n\t\t\t\t epayload->decrypted_datalen);\n\t} else\n\t\tret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\n\treturn ret;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char key_format_ecryptfs[] = \"ecryptfs\";",
            "static unsigned int ivsize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\n\nstatic int encrypted_init(struct encrypted_key_payload *epayload,\n\t\t\t  const char *key_desc, const char *format,\n\t\t\t  const char *master_desc, const char *datalen,\n\t\t\t  const char *hex_encoded_iv)\n{\n\tint ret = 0;\n\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tret = valid_ecryptfs_desc(key_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\n\t\t\t\t       key_desc);\n\t}\n\n\t__ekey_init(epayload, format, master_desc, datalen);\n\tif (!hex_encoded_iv) {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\n\t\tget_random_bytes(epayload->decrypted_data,\n\t\t\t\t epayload->decrypted_datalen);\n\t} else\n\t\tret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "epayload"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "epayload"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "encrypted_key_alloc",
          "args": [
            "key",
            "format",
            "master_desc",
            "decrypted_datalen"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "encrypted_key_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "607-658",
          "snippet": "static struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\",\n\t\t\t       ECRYPTFS_MAX_KEY_BYTES);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define MIN_DATA_SIZE  20",
            "#define MAX_DATA_SIZE 4096",
            "#define HASH_SIZE SHA256_DIGEST_SIZE"
          ],
          "globals_used": [
            "static const char key_format_default[] = \"default\";",
            "static const char key_format_ecryptfs[] = \"ecryptfs\";",
            "static unsigned int ivsize;",
            "static int blksize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define MIN_DATA_SIZE  20\n#define MAX_DATA_SIZE 4096\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\nstatic int blksize;\n\nstatic struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\",\n\t\t\t       ECRYPTFS_MAX_KEY_BYTES);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}"
        }
      },
      {
        "call_info": {
          "callee": "datablob_parse",
          "args": [
            "datablob",
            "&format",
            "&master_desc",
            "&decrypted_datalen",
            "&hex_encoded_iv"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "datablob_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "171-264",
          "snippet": "static int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_error, NULL}\n};",
            "static const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_error, NULL}\n};\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};\n\nstatic int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "datablob",
            "prep->data",
            "datalen"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "datalen + 1",
            "GFP_KERNEL"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic int encrypted_instantiate(struct key *key,\n\t\t\t\t struct key_preparsed_payload *prep)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tchar *datablob = NULL;\n\tconst char *format = NULL;\n\tchar *master_desc = NULL;\n\tchar *decrypted_datalen = NULL;\n\tchar *hex_encoded_iv = NULL;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tdatablob[datalen] = 0;\n\tmemcpy(datablob, prep->data, datalen);\n\tret = datablob_parse(datablob, &format, &master_desc,\n\t\t\t     &decrypted_datalen, &hex_encoded_iv);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tepayload = encrypted_key_alloc(key, format, master_desc,\n\t\t\t\t       decrypted_datalen);\n\tif (IS_ERR(epayload)) {\n\t\tret = PTR_ERR(epayload);\n\t\tgoto out;\n\t}\n\tret = encrypted_init(epayload, key->description, format, master_desc,\n\t\t\t     decrypted_datalen, hex_encoded_iv);\n\tif (ret < 0) {\n\t\tkzfree(epayload);\n\t\tgoto out;\n\t}\n\n\trcu_assign_keypointer(key, epayload);\nout:\n\tkzfree(datablob);\n\treturn ret;\n}"
  },
  {
    "function_name": "encrypted_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "751-776",
    "snippet": "static int encrypted_init(struct encrypted_key_payload *epayload,\n\t\t\t  const char *key_desc, const char *format,\n\t\t\t  const char *master_desc, const char *datalen,\n\t\t\t  const char *hex_encoded_iv)\n{\n\tint ret = 0;\n\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tret = valid_ecryptfs_desc(key_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\n\t\t\t\t       key_desc);\n\t}\n\n\t__ekey_init(epayload, format, master_desc, datalen);\n\tif (!hex_encoded_iv) {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\n\t\tget_random_bytes(epayload->decrypted_data,\n\t\t\t\t epayload->decrypted_datalen);\n\t} else\n\t\tret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\n\treturn ret;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char key_format_ecryptfs[] = \"ecryptfs\";",
      "static unsigned int ivsize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "encrypted_key_decrypt",
          "args": [
            "epayload",
            "format",
            "hex_encoded_iv"
          ],
          "line": 774
        },
        "resolved": true,
        "details": {
          "function_name": "encrypted_key_decrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "660-715",
          "snippet": "static int encrypted_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t\t const char *format, const char *hex_encoded_iv)\n{\n\tstruct key *mkey;\n\tu8 derived_key[HASH_SIZE];\n\tconst u8 *master_key;\n\tu8 *hmac;\n\tconst char *hex_encoded_data;\n\tunsigned int encrypted_datalen;\n\tsize_t master_keylen;\n\tsize_t asciilen;\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\n\tif (strlen(hex_encoded_iv) != asciilen)\n\t\treturn -EINVAL;\n\n\thex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\n\tret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tret = hex2bin(epayload->encrypted_data, hex_encoded_data,\n\t\t      encrypted_datalen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\thmac = epayload->format + epayload->datablob_len;\n\tret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\n\t\t      HASH_SIZE);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: bad hmac (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to decrypt key (%d)\\n\", ret);\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define HASH_SIZE SHA256_DIGEST_SIZE"
          ],
          "globals_used": [
            "static unsigned int ivsize;",
            "static int blksize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic unsigned int ivsize;\nstatic int blksize;\n\nstatic int encrypted_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t\t const char *format, const char *hex_encoded_iv)\n{\n\tstruct key *mkey;\n\tu8 derived_key[HASH_SIZE];\n\tconst u8 *master_key;\n\tu8 *hmac;\n\tconst char *hex_encoded_data;\n\tunsigned int encrypted_datalen;\n\tsize_t master_keylen;\n\tsize_t asciilen;\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\n\tif (strlen(hex_encoded_iv) != asciilen)\n\t\treturn -EINVAL;\n\n\thex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\n\tret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tret = hex2bin(epayload->encrypted_data, hex_encoded_data,\n\t\t      encrypted_datalen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\thmac = epayload->format + epayload->datablob_len;\n\tret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\n\t\t      HASH_SIZE);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: bad hmac (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to decrypt key (%d)\\n\", ret);\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "epayload->decrypted_data",
            "epayload->decrypted_datalen"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes",
          "args": [
            "epayload->iv",
            "ivsize"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ekey_init",
          "args": [
            "epayload",
            "format",
            "master_desc",
            "datalen"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "__ekey_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "717-743",
          "snippet": "static void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char key_format_default[] = \"default\";",
            "static const char key_format_ecryptfs[] = \"ecryptfs\";",
            "static unsigned int ivsize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\n\nstatic void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ecryptfs_fill_auth_tok",
          "args": [
            "(struct ecryptfs_auth_tok *)epayload->payload_data",
            "key_desc"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_fill_auth_tok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/ecryptfs_format.c",
          "lines": "50-78",
          "snippet": "int ecryptfs_fill_auth_tok(struct ecryptfs_auth_tok *auth_tok,\n\t\t\t   const char *key_desc)\n{\n\tint major, minor;\n\n\tecryptfs_get_versions(&major, &minor, NULL);\n\tauth_tok->version = (((uint16_t)(major << 8) & 0xFF00)\n\t\t\t     | ((uint16_t)minor & 0x00FF));\n\tauth_tok->token_type = ECRYPTFS_PASSWORD;\n\tstrncpy((char *)auth_tok->token.password.signature, key_desc,\n\t\tECRYPTFS_PASSWORD_SIG_SIZE);\n\tauth_tok->token.password.session_key_encryption_key_bytes =\n\t\tECRYPTFS_MAX_KEY_BYTES;\n\t/*\n\t * Removed auth_tok->token.password.salt and\n\t * auth_tok->token.password.session_key_encryption_key\n\t * initialization from the original code\n\t */\n\t/* TODO: Make the hash parameterizable via policy */\n\tauth_tok->token.password.flags |=\n\t\tECRYPTFS_SESSION_KEY_ENCRYPTION_KEY_SET;\n\t/* The kernel code will encrypt the session key. */\n\tauth_tok->session_key.encrypted_key[0] = 0;\n\tauth_tok->session_key.encrypted_key_size = 0;\n\t/* Default; subject to change by kernel eCryptfs */\n\tauth_tok->token.password.hash_algo = PGP_DIGEST_ALGO_SHA512;\n\tauth_tok->token.password.flags &= ~(ECRYPTFS_PERSISTENT_PASSWORD);\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include <linux/module.h>\n\nint ecryptfs_fill_auth_tok(struct ecryptfs_auth_tok *auth_tok,\n\t\t\t   const char *key_desc)\n{\n\tint major, minor;\n\n\tecryptfs_get_versions(&major, &minor, NULL);\n\tauth_tok->version = (((uint16_t)(major << 8) & 0xFF00)\n\t\t\t     | ((uint16_t)minor & 0x00FF));\n\tauth_tok->token_type = ECRYPTFS_PASSWORD;\n\tstrncpy((char *)auth_tok->token.password.signature, key_desc,\n\t\tECRYPTFS_PASSWORD_SIG_SIZE);\n\tauth_tok->token.password.session_key_encryption_key_bytes =\n\t\tECRYPTFS_MAX_KEY_BYTES;\n\t/*\n\t * Removed auth_tok->token.password.salt and\n\t * auth_tok->token.password.session_key_encryption_key\n\t * initialization from the original code\n\t */\n\t/* TODO: Make the hash parameterizable via policy */\n\tauth_tok->token.password.flags |=\n\t\tECRYPTFS_SESSION_KEY_ENCRYPTION_KEY_SET;\n\t/* The kernel code will encrypt the session key. */\n\tauth_tok->session_key.encrypted_key[0] = 0;\n\tauth_tok->session_key.encrypted_key_size = 0;\n\t/* Default; subject to change by kernel eCryptfs */\n\tauth_tok->token.password.hash_algo = PGP_DIGEST_ALGO_SHA512;\n\tauth_tok->token.password.flags &= ~(ECRYPTFS_PERSISTENT_PASSWORD);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_ecryptfs_desc",
          "args": [
            "key_desc"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "valid_ecryptfs_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "104-123",
          "snippet": "static int valid_ecryptfs_desc(const char *ecryptfs_desc)\n{\n\tint i;\n\n\tif (strlen(ecryptfs_desc) != KEY_ECRYPTFS_DESC_LEN) {\n\t\tpr_err(\"encrypted_key: key description must be %d hexadecimal \"\n\t\t       \"characters long\\n\", KEY_ECRYPTFS_DESC_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < KEY_ECRYPTFS_DESC_LEN; i++) {\n\t\tif (!isxdigit(ecryptfs_desc[i])) {\n\t\t\tpr_err(\"encrypted_key: key description must contain \"\n\t\t\t       \"only hexadecimal characters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define KEY_ECRYPTFS_DESC_LEN 16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define KEY_ECRYPTFS_DESC_LEN 16\n\nstatic int valid_ecryptfs_desc(const char *ecryptfs_desc)\n{\n\tint i;\n\n\tif (strlen(ecryptfs_desc) != KEY_ECRYPTFS_DESC_LEN) {\n\t\tpr_err(\"encrypted_key: key description must be %d hexadecimal \"\n\t\t       \"characters long\\n\", KEY_ECRYPTFS_DESC_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < KEY_ECRYPTFS_DESC_LEN; i++) {\n\t\tif (!isxdigit(ecryptfs_desc[i])) {\n\t\t\tpr_err(\"encrypted_key: key description must contain \"\n\t\t\t       \"only hexadecimal characters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "format",
            "key_format_ecryptfs"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\n\nstatic int encrypted_init(struct encrypted_key_payload *epayload,\n\t\t\t  const char *key_desc, const char *format,\n\t\t\t  const char *master_desc, const char *datalen,\n\t\t\t  const char *hex_encoded_iv)\n{\n\tint ret = 0;\n\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tret = valid_ecryptfs_desc(key_desc);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\n\t\tecryptfs_fill_auth_tok((struct ecryptfs_auth_tok *)epayload->payload_data,\n\t\t\t\t       key_desc);\n\t}\n\n\t__ekey_init(epayload, format, master_desc, datalen);\n\tif (!hex_encoded_iv) {\n\t\tget_random_bytes(epayload->iv, ivsize);\n\n\t\tget_random_bytes(epayload->decrypted_data,\n\t\t\t\t epayload->decrypted_datalen);\n\t} else\n\t\tret = encrypted_key_decrypt(epayload, format, hex_encoded_iv);\n\treturn ret;\n}"
  },
  {
    "function_name": "__ekey_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "717-743",
    "snippet": "static void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char key_format_default[] = \"default\";",
      "static const char key_format_ecryptfs[] = \"ecryptfs\";",
      "static unsigned int ivsize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "epayload->datalen",
            "datalen",
            "strlen(datalen)"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "datalen"
          ],
          "line": 742
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "epayload->master_desc",
            "master_desc",
            "strlen(master_desc)"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "master_desc"
          ],
          "line": 741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "epayload->format",
            "format",
            "format_len"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ecryptfs_get_auth_tok_key",
          "args": [
            "(struct ecryptfs_auth_tok *)epayload->payload_data"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "ecryptfs_get_auth_tok_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/ecryptfs_format.c",
          "lines": "21-24",
          "snippet": "u8 *ecryptfs_get_auth_tok_key(struct ecryptfs_auth_tok *auth_tok)\n{\n\treturn auth_tok->token.password.session_key_encryption_key;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include <linux/module.h>\n\nu8 *ecryptfs_get_auth_tok_key(struct ecryptfs_auth_tok *auth_tok)\n{\n\treturn auth_tok->token.password.session_key_encryption_key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "format",
            "key_format_ecryptfs"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "epayload->format",
            "key_format_default",
            "format_len"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "datalen"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "master_desc"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "format"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key_format_default"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\n\nstatic void __ekey_init(struct encrypted_key_payload *epayload,\n\t\t\tconst char *format, const char *master_desc,\n\t\t\tconst char *datalen)\n{\n\tunsigned int format_len;\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tepayload->format = epayload->payload_data + epayload->payload_datalen;\n\tepayload->master_desc = epayload->format + format_len + 1;\n\tepayload->datalen = epayload->master_desc + strlen(master_desc) + 1;\n\tepayload->iv = epayload->datalen + strlen(datalen) + 1;\n\tepayload->encrypted_data = epayload->iv + ivsize + 1;\n\tepayload->decrypted_data = epayload->payload_data;\n\n\tif (!format)\n\t\tmemcpy(epayload->format, key_format_default, format_len);\n\telse {\n\t\tif (!strcmp(format, key_format_ecryptfs))\n\t\t\tepayload->decrypted_data =\n\t\t\t\tecryptfs_get_auth_tok_key((struct ecryptfs_auth_tok *)epayload->payload_data);\n\n\t\tmemcpy(epayload->format, format, format_len);\n\t}\n\n\tmemcpy(epayload->master_desc, master_desc, strlen(master_desc));\n\tmemcpy(epayload->datalen, datalen, strlen(datalen));\n}"
  },
  {
    "function_name": "encrypted_key_decrypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "660-715",
    "snippet": "static int encrypted_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t\t const char *format, const char *hex_encoded_iv)\n{\n\tstruct key *mkey;\n\tu8 derived_key[HASH_SIZE];\n\tconst u8 *master_key;\n\tu8 *hmac;\n\tconst char *hex_encoded_data;\n\tunsigned int encrypted_datalen;\n\tsize_t master_keylen;\n\tsize_t asciilen;\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\n\tif (strlen(hex_encoded_iv) != asciilen)\n\t\treturn -EINVAL;\n\n\thex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\n\tret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tret = hex2bin(epayload->encrypted_data, hex_encoded_data,\n\t\t      encrypted_datalen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\thmac = epayload->format + epayload->datablob_len;\n\tret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\n\t\t      HASH_SIZE);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: bad hmac (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to decrypt key (%d)\\n\", ret);\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define HASH_SIZE SHA256_DIGEST_SIZE"
    ],
    "globals_used": [
      "static unsigned int ivsize;",
      "static int blksize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memzero_explicit",
          "args": [
            "derived_key",
            "sizeof(derived_key)"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "mkey"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&mkey->sem"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: failed to decrypt key (%d)\\n\"",
            "ret"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "derived_key_decrypt",
          "args": [
            "epayload",
            "derived_key",
            "sizeof derived_key"
          ],
          "line": 707
        },
        "resolved": true,
        "details": {
          "function_name": "derived_key_decrypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "560-604",
          "snippet": "static int derived_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[1];\n\tstruct scatterlist sg_out[2];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tu8 *pad;\n\tint ret;\n\n\t/* Throwaway buffer to hold the unused zero padding at the end */\n\tpad = kmalloc(AES_BLOCK_SIZE, GFP_KERNEL);\n\tif (!pad)\n\t\treturn -ENOMEM;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_encrypted_data(epayload, encrypted_datalen);\n\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, epayload->encrypted_data, encrypted_datalen);\n\tsg_set_buf(&sg_out[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_out[1], pad, AES_BLOCK_SIZE);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_decrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\nout:\n\tkfree(pad);\n\treturn ret;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int blksize;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic int blksize;\n\nstatic int derived_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[1];\n\tstruct scatterlist sg_out[2];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tu8 *pad;\n\tint ret;\n\n\t/* Throwaway buffer to hold the unused zero padding at the end */\n\tpad = kmalloc(AES_BLOCK_SIZE, GFP_KERNEL);\n\tif (!pad)\n\t\treturn -ENOMEM;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_encrypted_data(epayload, encrypted_datalen);\n\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, epayload->encrypted_data, encrypted_datalen);\n\tsg_set_buf(&sg_out[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_out[1], pad, AES_BLOCK_SIZE);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_decrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\nout:\n\tkfree(pad);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_derived_key",
          "args": [
            "derived_key",
            "ENC_KEY",
            "master_key",
            "master_keylen"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "get_derived_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "362-387",
          "snippet": "static int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(hash_tfm, derived_key, derived_buf, derived_buf_len);\n\tkzfree(derived_buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define HASH_SIZE SHA256_DIGEST_SIZE"
          ],
          "globals_used": [
            "static struct crypto_shash *hash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic struct crypto_shash *hash_tfm;\n\nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(hash_tfm, derived_key, derived_buf, derived_buf_len);\n\tkzfree(derived_buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: bad hmac (%d)\\n\"",
            "ret"
          ],
          "line": 699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datablob_hmac_verify",
          "args": [
            "epayload",
            "format",
            "master_key",
            "master_keylen"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "datablob_hmac_verify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "522-558",
          "snippet": "static int datablob_hmac_verify(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *format, const u8 *master_key,\n\t\t\t\tsize_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 digest[HASH_SIZE];\n\tint ret;\n\tchar *p;\n\tunsigned short len;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = epayload->datablob_len;\n\tif (!format) {\n\t\tp = epayload->master_desc;\n\t\tlen -= strlen(epayload->format) + 1;\n\t} else\n\t\tp = epayload->format;\n\n\tret = calc_hmac(digest, derived_key, sizeof derived_key, p, len);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_memneq(digest, epayload->format + epayload->datablob_len,\n\t\t\t    sizeof(digest));\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tdump_hmac(\"datablob\",\n\t\t\t  epayload->format + epayload->datablob_len,\n\t\t\t  HASH_SIZE);\n\t\tdump_hmac(\"calc\", digest, HASH_SIZE);\n\t}\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define HASH_SIZE SHA256_DIGEST_SIZE"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic int datablob_hmac_verify(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *format, const u8 *master_key,\n\t\t\t\tsize_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 digest[HASH_SIZE];\n\tint ret;\n\tchar *p;\n\tunsigned short len;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = epayload->datablob_len;\n\tif (!format) {\n\t\tp = epayload->master_desc;\n\t\tlen -= strlen(epayload->format) + 1;\n\t} else\n\t\tp = epayload->format;\n\n\tret = calc_hmac(digest, derived_key, sizeof derived_key, p, len);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_memneq(digest, epayload->format + epayload->datablob_len,\n\t\t\t    sizeof(digest));\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tdump_hmac(\"datablob\",\n\t\t\t  epayload->format + epayload->datablob_len,\n\t\t\t  HASH_SIZE);\n\t\tdump_hmac(\"calc\", digest, HASH_SIZE);\n\t}\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mkey"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mkey"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_master_key",
          "args": [
            "epayload",
            "&master_key",
            "&master_keylen"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "request_master_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "422-455",
          "snippet": "static struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)",
            "#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)"
          ],
          "globals_used": [
            "static const char KEY_TRUSTED_PREFIX[] = \"trusted:\";",
            "static const char KEY_USER_PREFIX[] = \"user:\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\n\nstatic struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hex2bin",
          "args": [
            "hmac",
            "hex_encoded_data + (encrypted_datalen * 2)",
            "HASH_SIZE"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex2bin",
          "args": [
            "epayload->encrypted_data",
            "hex_encoded_data",
            "encrypted_datalen"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex2bin",
          "args": [
            "epayload->iv",
            "hex_encoded_iv",
            "ivsize"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hex_encoded_iv"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "epayload->decrypted_datalen",
            "blksize"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic unsigned int ivsize;\nstatic int blksize;\n\nstatic int encrypted_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t\t const char *format, const char *hex_encoded_iv)\n{\n\tstruct key *mkey;\n\tu8 derived_key[HASH_SIZE];\n\tconst u8 *master_key;\n\tu8 *hmac;\n\tconst char *hex_encoded_data;\n\tunsigned int encrypted_datalen;\n\tsize_t master_keylen;\n\tsize_t asciilen;\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\tasciilen = (ivsize + 1 + encrypted_datalen + HASH_SIZE) * 2;\n\tif (strlen(hex_encoded_iv) != asciilen)\n\t\treturn -EINVAL;\n\n\thex_encoded_data = hex_encoded_iv + (2 * ivsize) + 2;\n\tret = hex2bin(epayload->iv, hex_encoded_iv, ivsize);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\tret = hex2bin(epayload->encrypted_data, hex_encoded_data,\n\t\t      encrypted_datalen);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\thmac = epayload->format + epayload->datablob_len;\n\tret = hex2bin(hmac, hex_encoded_data + (encrypted_datalen * 2),\n\t\t      HASH_SIZE);\n\tif (ret < 0)\n\t\treturn -EINVAL;\n\n\tmkey = request_master_key(epayload, &master_key, &master_keylen);\n\tif (IS_ERR(mkey))\n\t\treturn PTR_ERR(mkey);\n\n\tret = datablob_hmac_verify(epayload, format, master_key, master_keylen);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: bad hmac (%d)\\n\", ret);\n\t\tgoto out;\n\t}\n\n\tret = get_derived_key(derived_key, ENC_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = derived_key_decrypt(epayload, derived_key, sizeof derived_key);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to decrypt key (%d)\\n\", ret);\nout:\n\tup_read(&mkey->sem);\n\tkey_put(mkey);\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}"
  },
  {
    "function_name": "encrypted_key_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "607-658",
    "snippet": "static struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\",\n\t\t\t       ECRYPTFS_MAX_KEY_BYTES);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define MIN_DATA_SIZE  20",
      "#define MAX_DATA_SIZE 4096",
      "#define HASH_SIZE SHA256_DIGEST_SIZE"
    ],
    "globals_used": [
      "static const char key_format_default[] = \"default\";",
      "static const char key_format_ecryptfs[] = \"ecryptfs\";",
      "static unsigned int ivsize;",
      "static int blksize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1",
            "GFP_KERNEL"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_payload_reserve",
          "args": [
            "key",
            "payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "key_payload_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "370-401",
          "snippet": "int key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int key_quota_root_maxbytes = 25000000;",
            "unsigned int key_quota_maxbytes = 20000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nunsigned int key_quota_root_maxbytes = 25000000;\nunsigned int key_quota_maxbytes = 20000;\n\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "datalen"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "master_desc"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "decrypted_datalen",
            "blksize"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\"",
            "ECRYPTFS_MAX_KEY_BYTES"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "format",
            "key_format_ecryptfs"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "format"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key_format_default"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtol",
          "args": [
            "datalen",
            "10",
            "&dlen"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define MIN_DATA_SIZE  20\n#define MAX_DATA_SIZE 4096\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic const char key_format_default[] = \"default\";\nstatic const char key_format_ecryptfs[] = \"ecryptfs\";\nstatic unsigned int ivsize;\nstatic int blksize;\n\nstatic struct encrypted_key_payload *encrypted_key_alloc(struct key *key,\n\t\t\t\t\t\t\t const char *format,\n\t\t\t\t\t\t\t const char *master_desc,\n\t\t\t\t\t\t\t const char *datalen)\n{\n\tstruct encrypted_key_payload *epayload = NULL;\n\tunsigned short datablob_len;\n\tunsigned short decrypted_datalen;\n\tunsigned short payload_datalen;\n\tunsigned int encrypted_datalen;\n\tunsigned int format_len;\n\tlong dlen;\n\tint ret;\n\n\tret = kstrtol(datalen, 10, &dlen);\n\tif (ret < 0 || dlen < MIN_DATA_SIZE || dlen > MAX_DATA_SIZE)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tformat_len = (!format) ? strlen(key_format_default) : strlen(format);\n\tdecrypted_datalen = dlen;\n\tpayload_datalen = decrypted_datalen;\n\tif (format && !strcmp(format, key_format_ecryptfs)) {\n\t\tif (dlen != ECRYPTFS_MAX_KEY_BYTES) {\n\t\t\tpr_err(\"encrypted_key: keylen for the ecryptfs format \"\n\t\t\t       \"must be equal to %d bytes\\n\",\n\t\t\t       ECRYPTFS_MAX_KEY_BYTES);\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\t}\n\t\tdecrypted_datalen = ECRYPTFS_MAX_KEY_BYTES;\n\t\tpayload_datalen = sizeof(struct ecryptfs_auth_tok);\n\t}\n\n\tencrypted_datalen = roundup(decrypted_datalen, blksize);\n\n\tdatablob_len = format_len + 1 + strlen(master_desc) + 1\n\t    + strlen(datalen) + 1 + ivsize + 1 + encrypted_datalen;\n\n\tret = key_payload_reserve(key, payload_datalen + datablob_len\n\t\t\t\t  + HASH_SIZE + 1);\n\tif (ret < 0)\n\t\treturn ERR_PTR(ret);\n\n\tepayload = kzalloc(sizeof(*epayload) + payload_datalen +\n\t\t\t   datablob_len + HASH_SIZE + 1, GFP_KERNEL);\n\tif (!epayload)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tepayload->payload_datalen = payload_datalen;\n\tepayload->decrypted_datalen = decrypted_datalen;\n\tepayload->datablob_len = datablob_len;\n\treturn epayload;\n}"
  },
  {
    "function_name": "derived_key_decrypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "560-604",
    "snippet": "static int derived_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[1];\n\tstruct scatterlist sg_out[2];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tu8 *pad;\n\tint ret;\n\n\t/* Throwaway buffer to hold the unused zero padding at the end */\n\tpad = kmalloc(AES_BLOCK_SIZE, GFP_KERNEL);\n\tif (!pad)\n\t\treturn -ENOMEM;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_encrypted_data(epayload, encrypted_datalen);\n\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, epayload->encrypted_data, encrypted_datalen);\n\tsg_set_buf(&sg_out[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_out[1], pad, AES_BLOCK_SIZE);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_decrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\nout:\n\tkfree(pad);\n\treturn ret;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blksize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "pad"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_decrypted_data",
          "args": [
            "epayload"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "dump_decrypted_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.h",
          "lines": "53-55",
          "snippet": "static inline void dump_decrypted_data(struct encrypted_key_payload *epayload)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dump_decrypted_data(struct encrypted_key_payload *epayload)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_free_skcipher",
          "args": [
            "tfm"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skcipher_request_free",
          "args": [
            "req"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_skcipher_reqtfm",
          "args": [
            "req"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_skcipher_decrypt",
          "args": [
            "req"
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skcipher_request_set_crypt",
          "args": [
            "req",
            "sg_in",
            "sg_out",
            "encrypted_datalen",
            "iv"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iv",
            "epayload->iv",
            "sizeof(iv)"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_set_buf",
          "args": [
            "&sg_out[1]",
            "pad",
            "AES_BLOCK_SIZE"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_set_buf",
          "args": [
            "&sg_out[0]",
            "epayload->decrypted_data",
            "epayload->decrypted_datalen"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_set_buf",
          "args": [
            "sg_in",
            "epayload->encrypted_data",
            "encrypted_datalen"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_table",
          "args": [
            "sg_out",
            "2"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_table",
          "args": [
            "sg_in",
            "1"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_encrypted_data",
          "args": [
            "epayload",
            "encrypted_datalen"
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "dump_encrypted_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.h",
          "lines": "57-60",
          "snippet": "static inline void dump_encrypted_data(struct encrypted_key_payload *epayload,\n\t\t\t\t       unsigned int encrypted_datalen)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dump_encrypted_data(struct encrypted_key_payload *epayload,\n\t\t\t\t       unsigned int encrypted_datalen)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_skcipher_req",
          "args": [
            "derived_key",
            "derived_keylen"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "init_skcipher_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "389-420",
          "snippet": "static struct skcipher_request *init_skcipher_req(const u8 *key,\n\t\t\t\t\t\t  unsigned int key_len)\n{\n\tstruct skcipher_request *req;\n\tstruct crypto_skcipher *tfm;\n\tint ret;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(tfm));\n\t\treturn ERR_CAST(tfm);\n\t}\n\n\tret = crypto_skcipher_setkey(tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_err(\"encrypted_key: failed to allocate request for %s\\n\",\n\t\t       blkcipher_alg);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\treturn req;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char blkcipher_alg[] = \"cbc(aes)\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char blkcipher_alg[] = \"cbc(aes)\";\n\nstatic struct skcipher_request *init_skcipher_req(const u8 *key,\n\t\t\t\t\t\t  unsigned int key_len)\n{\n\tstruct skcipher_request *req;\n\tstruct crypto_skcipher *tfm;\n\tint ret;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(tfm));\n\t\treturn ERR_CAST(tfm);\n\t}\n\n\tret = crypto_skcipher_setkey(tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_err(\"encrypted_key: failed to allocate request for %s\\n\",\n\t\t       blkcipher_alg);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "epayload->decrypted_datalen",
            "blksize"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "AES_BLOCK_SIZE",
            "GFP_KERNEL"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic int blksize;\n\nstatic int derived_key_decrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[1];\n\tstruct scatterlist sg_out[2];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tu8 *pad;\n\tint ret;\n\n\t/* Throwaway buffer to hold the unused zero padding at the end */\n\tpad = kmalloc(AES_BLOCK_SIZE, GFP_KERNEL);\n\tif (!pad)\n\t\treturn -ENOMEM;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_encrypted_data(epayload, encrypted_datalen);\n\n\tsg_init_table(sg_in, 1);\n\tsg_init_table(sg_out, 2);\n\tsg_set_buf(sg_in, epayload->encrypted_data, encrypted_datalen);\n\tsg_set_buf(&sg_out[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_buf(&sg_out[1], pad, AES_BLOCK_SIZE);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_decrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\nout:\n\tkfree(pad);\n\treturn ret;\n}"
  },
  {
    "function_name": "datablob_hmac_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "522-558",
    "snippet": "static int datablob_hmac_verify(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *format, const u8 *master_key,\n\t\t\t\tsize_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 digest[HASH_SIZE];\n\tint ret;\n\tchar *p;\n\tunsigned short len;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = epayload->datablob_len;\n\tif (!format) {\n\t\tp = epayload->master_desc;\n\t\tlen -= strlen(epayload->format) + 1;\n\t} else\n\t\tp = epayload->format;\n\n\tret = calc_hmac(digest, derived_key, sizeof derived_key, p, len);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_memneq(digest, epayload->format + epayload->datablob_len,\n\t\t\t    sizeof(digest));\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tdump_hmac(\"datablob\",\n\t\t\t  epayload->format + epayload->datablob_len,\n\t\t\t  HASH_SIZE);\n\t\tdump_hmac(\"calc\", digest, HASH_SIZE);\n\t}\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define HASH_SIZE SHA256_DIGEST_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memzero_explicit",
          "args": [
            "derived_key",
            "sizeof(derived_key)"
          ],
          "line": 556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_hmac",
          "args": [
            "\"calc\"",
            "digest",
            "HASH_SIZE"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "dump_hmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.h",
          "lines": "62-65",
          "snippet": "static inline void dump_hmac(const char *str, const u8 *digest,\n\t\t\t     unsigned int hmac_size)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dump_hmac(const char *str, const u8 *digest,\n\t\t\t     unsigned int hmac_size)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_memneq",
          "args": [
            "digest",
            "epayload->format + epayload->datablob_len",
            "sizeof(digest)"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_hmac",
          "args": [
            "digest",
            "derived_key",
            "sizeof derived_key",
            "p",
            "len"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "calc_hmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "339-357",
          "snippet": "static int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct crypto_shash *tfm;\n\tint err;\n\n\ttfm = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: can't alloc %s transform: %ld\\n\",\n\t\t       hmac_alg, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = crypto_shash_setkey(tfm, key, keylen);\n\tif (!err)\n\t\terr = calc_hash(tfm, digest, buf, buflen);\n\tcrypto_free_shash(tfm);\n\treturn err;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hmac_alg[] = \"hmac(sha256)\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char hmac_alg[] = \"hmac(sha256)\";\n\nstatic int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct crypto_shash *tfm;\n\tint err;\n\n\ttfm = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: can't alloc %s transform: %ld\\n\",\n\t\t       hmac_alg, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = crypto_shash_setkey(tfm, key, keylen);\n\tif (!err)\n\t\terr = calc_hash(tfm, digest, buf, buflen);\n\tcrypto_free_shash(tfm);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "epayload->format"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_derived_key",
          "args": [
            "derived_key",
            "AUTH_KEY",
            "master_key",
            "master_keylen"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "get_derived_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "362-387",
          "snippet": "static int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(hash_tfm, derived_key, derived_buf, derived_buf_len);\n\tkzfree(derived_buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define HASH_SIZE SHA256_DIGEST_SIZE"
          ],
          "globals_used": [
            "static struct crypto_shash *hash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic struct crypto_shash *hash_tfm;\n\nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(hash_tfm, derived_key, derived_buf, derived_buf_len);\n\tkzfree(derived_buf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic int datablob_hmac_verify(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *format, const u8 *master_key,\n\t\t\t\tsize_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 digest[HASH_SIZE];\n\tint ret;\n\tchar *p;\n\tunsigned short len;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tlen = epayload->datablob_len;\n\tif (!format) {\n\t\tp = epayload->master_desc;\n\t\tlen -= strlen(epayload->format) + 1;\n\t} else\n\t\tp = epayload->format;\n\n\tret = calc_hmac(digest, derived_key, sizeof derived_key, p, len);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_memneq(digest, epayload->format + epayload->datablob_len,\n\t\t\t    sizeof(digest));\n\tif (ret) {\n\t\tret = -EINVAL;\n\t\tdump_hmac(\"datablob\",\n\t\t\t  epayload->format + epayload->datablob_len,\n\t\t\t  HASH_SIZE);\n\t\tdump_hmac(\"calc\", digest, HASH_SIZE);\n\t}\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}"
  },
  {
    "function_name": "datablob_hmac_append",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "500-519",
    "snippet": "static int datablob_hmac_append(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *master_key, size_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 *digest;\n\tint ret;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdigest = epayload->format + epayload->datablob_len;\n\tret = calc_hmac(digest, derived_key, sizeof derived_key,\n\t\t\tepayload->format, epayload->datablob_len);\n\tif (!ret)\n\t\tdump_hmac(NULL, digest, HASH_SIZE);\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define HASH_SIZE SHA256_DIGEST_SIZE"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memzero_explicit",
          "args": [
            "derived_key",
            "sizeof(derived_key)"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_hmac",
          "args": [
            "NULL",
            "digest",
            "HASH_SIZE"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "dump_hmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.h",
          "lines": "62-65",
          "snippet": "static inline void dump_hmac(const char *str, const u8 *digest,\n\t\t\t     unsigned int hmac_size)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dump_hmac(const char *str, const u8 *digest,\n\t\t\t     unsigned int hmac_size)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_hmac",
          "args": [
            "digest",
            "derived_key",
            "sizeof derived_key",
            "epayload->format",
            "epayload->datablob_len"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "calc_hmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "339-357",
          "snippet": "static int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct crypto_shash *tfm;\n\tint err;\n\n\ttfm = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: can't alloc %s transform: %ld\\n\",\n\t\t       hmac_alg, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = crypto_shash_setkey(tfm, key, keylen);\n\tif (!err)\n\t\terr = calc_hash(tfm, digest, buf, buflen);\n\tcrypto_free_shash(tfm);\n\treturn err;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hmac_alg[] = \"hmac(sha256)\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char hmac_alg[] = \"hmac(sha256)\";\n\nstatic int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct crypto_shash *tfm;\n\tint err;\n\n\ttfm = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: can't alloc %s transform: %ld\\n\",\n\t\t       hmac_alg, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = crypto_shash_setkey(tfm, key, keylen);\n\tif (!err)\n\t\terr = calc_hash(tfm, digest, buf, buflen);\n\tcrypto_free_shash(tfm);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_derived_key",
          "args": [
            "derived_key",
            "AUTH_KEY",
            "master_key",
            "master_keylen"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "get_derived_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "362-387",
          "snippet": "static int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(hash_tfm, derived_key, derived_buf, derived_buf_len);\n\tkzfree(derived_buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define HASH_SIZE SHA256_DIGEST_SIZE"
          ],
          "globals_used": [
            "static struct crypto_shash *hash_tfm;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic struct crypto_shash *hash_tfm;\n\nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(hash_tfm, derived_key, derived_buf, derived_buf_len);\n\tkzfree(derived_buf);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic int datablob_hmac_append(struct encrypted_key_payload *epayload,\n\t\t\t\tconst u8 *master_key, size_t master_keylen)\n{\n\tu8 derived_key[HASH_SIZE];\n\tu8 *digest;\n\tint ret;\n\n\tret = get_derived_key(derived_key, AUTH_KEY, master_key, master_keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tdigest = epayload->format + epayload->datablob_len;\n\tret = calc_hmac(digest, derived_key, sizeof derived_key,\n\t\t\tepayload->format, epayload->datablob_len);\n\tif (!ret)\n\t\tdump_hmac(NULL, digest, HASH_SIZE);\nout:\n\tmemzero_explicit(derived_key, sizeof(derived_key));\n\treturn ret;\n}"
  },
  {
    "function_name": "derived_key_encrypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "458-498",
    "snippet": "static int derived_key_encrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[2];\n\tstruct scatterlist sg_out[1];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\n\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_page(&sg_in[1], ZERO_PAGE(0), AES_BLOCK_SIZE, 0);\n\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_encrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to encrypt (%d)\\n\", ret);\n\telse\n\t\tdump_encrypted_data(epayload, encrypted_datalen);\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int blksize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_encrypted_data",
          "args": [
            "epayload",
            "encrypted_datalen"
          ],
          "line": 495
        },
        "resolved": true,
        "details": {
          "function_name": "dump_encrypted_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.h",
          "lines": "57-60",
          "snippet": "static inline void dump_encrypted_data(struct encrypted_key_payload *epayload,\n\t\t\t\t       unsigned int encrypted_datalen)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dump_encrypted_data(struct encrypted_key_payload *epayload,\n\t\t\t\t       unsigned int encrypted_datalen)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: failed to encrypt (%d)\\n\"",
            "ret"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_skcipher",
          "args": [
            "tfm"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skcipher_request_free",
          "args": [
            "req"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_skcipher_reqtfm",
          "args": [
            "req"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_skcipher_encrypt",
          "args": [
            "req"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skcipher_request_set_crypt",
          "args": [
            "req",
            "sg_in",
            "sg_out",
            "encrypted_datalen",
            "iv"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "iv",
            "epayload->iv",
            "sizeof(iv)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_set_buf",
          "args": [
            "sg_out",
            "epayload->encrypted_data",
            "encrypted_datalen"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_table",
          "args": [
            "sg_out",
            "1"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_set_page",
          "args": [
            "&sg_in[1]",
            "ZERO_PAGE(0)",
            "AES_BLOCK_SIZE",
            "0"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ZERO_PAGE",
          "args": [
            "0"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_set_buf",
          "args": [
            "&sg_in[0]",
            "epayload->decrypted_data",
            "epayload->decrypted_datalen"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_table",
          "args": [
            "sg_in",
            "2"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_decrypted_data",
          "args": [
            "epayload"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "dump_decrypted_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.h",
          "lines": "53-55",
          "snippet": "static inline void dump_decrypted_data(struct encrypted_key_payload *epayload)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dump_decrypted_data(struct encrypted_key_payload *epayload)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "req"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "req"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_skcipher_req",
          "args": [
            "derived_key",
            "derived_keylen"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "init_skcipher_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "389-420",
          "snippet": "static struct skcipher_request *init_skcipher_req(const u8 *key,\n\t\t\t\t\t\t  unsigned int key_len)\n{\n\tstruct skcipher_request *req;\n\tstruct crypto_skcipher *tfm;\n\tint ret;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(tfm));\n\t\treturn ERR_CAST(tfm);\n\t}\n\n\tret = crypto_skcipher_setkey(tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_err(\"encrypted_key: failed to allocate request for %s\\n\",\n\t\t       blkcipher_alg);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\treturn req;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char blkcipher_alg[] = \"cbc(aes)\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char blkcipher_alg[] = \"cbc(aes)\";\n\nstatic struct skcipher_request *init_skcipher_req(const u8 *key,\n\t\t\t\t\t\t  unsigned int key_len)\n{\n\tstruct skcipher_request *req;\n\tstruct crypto_skcipher *tfm;\n\tint ret;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(tfm));\n\t\treturn ERR_CAST(tfm);\n\t}\n\n\tret = crypto_skcipher_setkey(tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_err(\"encrypted_key: failed to allocate request for %s\\n\",\n\t\t       blkcipher_alg);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\treturn req;\n}"
        }
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "epayload->decrypted_datalen",
            "blksize"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic int blksize;\n\nstatic int derived_key_encrypt(struct encrypted_key_payload *epayload,\n\t\t\t       const u8 *derived_key,\n\t\t\t       unsigned int derived_keylen)\n{\n\tstruct scatterlist sg_in[2];\n\tstruct scatterlist sg_out[1];\n\tstruct crypto_skcipher *tfm;\n\tstruct skcipher_request *req;\n\tunsigned int encrypted_datalen;\n\tu8 iv[AES_BLOCK_SIZE];\n\tint ret;\n\n\tencrypted_datalen = roundup(epayload->decrypted_datalen, blksize);\n\n\treq = init_skcipher_req(derived_key, derived_keylen);\n\tret = PTR_ERR(req);\n\tif (IS_ERR(req))\n\t\tgoto out;\n\tdump_decrypted_data(epayload);\n\n\tsg_init_table(sg_in, 2);\n\tsg_set_buf(&sg_in[0], epayload->decrypted_data,\n\t\t   epayload->decrypted_datalen);\n\tsg_set_page(&sg_in[1], ZERO_PAGE(0), AES_BLOCK_SIZE, 0);\n\n\tsg_init_table(sg_out, 1);\n\tsg_set_buf(sg_out, epayload->encrypted_data, encrypted_datalen);\n\n\tmemcpy(iv, epayload->iv, sizeof(iv));\n\tskcipher_request_set_crypt(req, sg_in, sg_out, encrypted_datalen, iv);\n\tret = crypto_skcipher_encrypt(req);\n\ttfm = crypto_skcipher_reqtfm(req);\n\tskcipher_request_free(req);\n\tcrypto_free_skcipher(tfm);\n\tif (ret < 0)\n\t\tpr_err(\"encrypted_key: failed to encrypt (%d)\\n\", ret);\n\telse\n\t\tdump_encrypted_data(epayload, encrypted_datalen);\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "request_master_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "422-455",
    "snippet": "static struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)",
      "#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)"
    ],
    "globals_used": [
      "static const char KEY_TRUSTED_PREFIX[] = \"trusted:\";",
      "static const char KEY_USER_PREFIX[] = \"user:\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_master_key",
          "args": [
            "*master_key",
            "*master_keylen"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "dump_master_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.h",
          "lines": "49-51",
          "snippet": "static inline void dump_master_key(const u8 *master_key, size_t master_keylen)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dump_master_key(const u8 *master_key, size_t master_keylen)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"encrypted_key: key %s not found\"",
            "epayload->master_desc"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"encrypted_key: key %s not supported\"",
            "epayload->master_desc"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "mkey"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "mkey"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_user_key",
          "args": [
            "epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN",
            "master_key",
            "master_keylen"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "request_user_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "300-323",
          "snippet": "static struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload_locked(ukey);\n\tif (!upayload) {\n\t\t/* key was revoked before we acquired its semaphore */\n\t\tup_read(&ukey->sem);\n\t\tkey_put(ukey);\n\t\tukey = ERR_PTR(-EKEYREVOKED);\n\t\tgoto error;\n\t}\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload_locked(ukey);\n\tif (!upayload) {\n\t\t/* key was revoked before we acquired its semaphore */\n\t\tup_read(&ukey->sem);\n\t\tkey_put(ukey);\n\t\tukey = ERR_PTR(-EKEYREVOKED);\n\t\tgoto error;\n\t}\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "epayload->master_desc",
            "KEY_USER_PREFIX",
            "KEY_USER_PREFIX_LEN"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_trusted_key",
          "args": [
            "epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN",
            "master_key",
            "master_keylen"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "request_trusted_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.h",
          "lines": "11-16",
          "snippet": "static inline struct key *request_trusted_key(const char *trusted_desc,\n\t\t\t\t\t      const u8 **master_key,\n\t\t\t\t\t      size_t *master_keylen)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline struct key *request_trusted_key(const char *trusted_desc,\n\t\t\t\t\t      const u8 **master_key,\n\t\t\t\t\t      size_t *master_keylen)\n{\n\treturn ERR_PTR(-EOPNOTSUPP);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "epayload->master_desc",
            "KEY_TRUSTED_PREFIX",
            "KEY_TRUSTED_PREFIX_LEN"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\n\nstatic struct key *request_master_key(struct encrypted_key_payload *epayload,\n\t\t\t\t      const u8 **master_key, size_t *master_keylen)\n{\n\tstruct key *mkey = ERR_PTR(-EINVAL);\n\n\tif (!strncmp(epayload->master_desc, KEY_TRUSTED_PREFIX,\n\t\t     KEY_TRUSTED_PREFIX_LEN)) {\n\t\tmkey = request_trusted_key(epayload->master_desc +\n\t\t\t\t\t   KEY_TRUSTED_PREFIX_LEN,\n\t\t\t\t\t   master_key, master_keylen);\n\t} else if (!strncmp(epayload->master_desc, KEY_USER_PREFIX,\n\t\t\t    KEY_USER_PREFIX_LEN)) {\n\t\tmkey = request_user_key(epayload->master_desc +\n\t\t\t\t\tKEY_USER_PREFIX_LEN,\n\t\t\t\t\tmaster_key, master_keylen);\n\t} else\n\t\tgoto out;\n\n\tif (IS_ERR(mkey)) {\n\t\tint ret = PTR_ERR(mkey);\n\n\t\tif (ret == -ENOTSUPP)\n\t\t\tpr_info(\"encrypted_key: key %s not supported\",\n\t\t\t\tepayload->master_desc);\n\t\telse\n\t\t\tpr_info(\"encrypted_key: key %s not found\",\n\t\t\t\tepayload->master_desc);\n\t\tgoto out;\n\t}\n\n\tdump_master_key(*master_key, *master_keylen);\nout:\n\treturn mkey;\n}"
  },
  {
    "function_name": "init_skcipher_req",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "389-420",
    "snippet": "static struct skcipher_request *init_skcipher_req(const u8 *key,\n\t\t\t\t\t\t  unsigned int key_len)\n{\n\tstruct skcipher_request *req;\n\tstruct crypto_skcipher *tfm;\n\tint ret;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(tfm));\n\t\treturn ERR_CAST(tfm);\n\t}\n\n\tret = crypto_skcipher_setkey(tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_err(\"encrypted_key: failed to allocate request for %s\\n\",\n\t\t       blkcipher_alg);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\treturn req;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char blkcipher_alg[] = \"cbc(aes)\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "skcipher_request_set_callback",
          "args": [
            "req",
            "0",
            "NULL",
            "NULL"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_skcipher",
          "args": [
            "tfm"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: failed to allocate request for %s\\n\"",
            "blkcipher_alg"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skcipher_request_alloc",
          "args": [
            "tfm",
            "GFP_KERNEL"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_skcipher",
          "args": [
            "tfm"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: failed to setkey (%d)\\n\"",
            "ret"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_skcipher_setkey",
          "args": [
            "tfm",
            "key",
            "key_len"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "tfm"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: failed to load %s transform (%ld)\\n\"",
            "blkcipher_alg",
            "PTR_ERR(tfm)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_skcipher",
          "args": [
            "blkcipher_alg",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char blkcipher_alg[] = \"cbc(aes)\";\n\nstatic struct skcipher_request *init_skcipher_req(const u8 *key,\n\t\t\t\t\t\t  unsigned int key_len)\n{\n\tstruct skcipher_request *req;\n\tstruct crypto_skcipher *tfm;\n\tint ret;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to load %s transform (%ld)\\n\",\n\t\t       blkcipher_alg, PTR_ERR(tfm));\n\t\treturn ERR_CAST(tfm);\n\t}\n\n\tret = crypto_skcipher_setkey(tfm, key, key_len);\n\tif (ret < 0) {\n\t\tpr_err(\"encrypted_key: failed to setkey (%d)\\n\", ret);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\treq = skcipher_request_alloc(tfm, GFP_KERNEL);\n\tif (!req) {\n\t\tpr_err(\"encrypted_key: failed to allocate request for %s\\n\",\n\t\t       blkcipher_alg);\n\t\tcrypto_free_skcipher(tfm);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\treturn req;\n}"
  },
  {
    "function_name": "get_derived_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "362-387",
    "snippet": "static int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(hash_tfm, derived_key, derived_buf, derived_buf_len);\n\tkzfree(derived_buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define HASH_SIZE SHA256_DIGEST_SIZE"
    ],
    "globals_used": [
      "static struct crypto_shash *hash_tfm;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "derived_buf"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_hash",
          "args": [
            "hash_tfm",
            "derived_key",
            "derived_buf",
            "derived_buf_len"
          ],
          "line": 384
        },
        "resolved": true,
        "details": {
          "function_name": "calc_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "325-337",
          "snippet": "static int calc_hash(struct crypto_shash *tfm, u8 *digest,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tint err;\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\terr = crypto_shash_digest(desc, buf, buflen, digest);\n\tshash_desc_zero(desc);\n\treturn err;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic int calc_hash(struct crypto_shash *tfm, u8 *digest,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tint err;\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\terr = crypto_shash_digest(desc, buf, buflen, digest);\n\tshash_desc_zero(desc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "derived_buf + strlen(derived_buf) + 1",
            "master_key",
            "master_keylen"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "derived_buf"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "derived_buf",
            "\"ENC_KEY\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "derived_buf",
            "\"AUTH_KEY\""
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "derived_buf_len",
            "GFP_KERNEL"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"AUTH_KEY\""
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define HASH_SIZE SHA256_DIGEST_SIZE\n\nstatic struct crypto_shash *hash_tfm;\n\nstatic int get_derived_key(u8 *derived_key, enum derived_key_type key_type,\n\t\t\t   const u8 *master_key, size_t master_keylen)\n{\n\tu8 *derived_buf;\n\tunsigned int derived_buf_len;\n\tint ret;\n\n\tderived_buf_len = strlen(\"AUTH_KEY\") + 1 + master_keylen;\n\tif (derived_buf_len < HASH_SIZE)\n\t\tderived_buf_len = HASH_SIZE;\n\n\tderived_buf = kzalloc(derived_buf_len, GFP_KERNEL);\n\tif (!derived_buf)\n\t\treturn -ENOMEM;\n\n\tif (key_type)\n\t\tstrcpy(derived_buf, \"AUTH_KEY\");\n\telse\n\t\tstrcpy(derived_buf, \"ENC_KEY\");\n\n\tmemcpy(derived_buf + strlen(derived_buf) + 1, master_key,\n\t       master_keylen);\n\tret = calc_hash(hash_tfm, derived_key, derived_buf, derived_buf_len);\n\tkzfree(derived_buf);\n\treturn ret;\n}"
  },
  {
    "function_name": "calc_hmac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "339-357",
    "snippet": "static int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct crypto_shash *tfm;\n\tint err;\n\n\ttfm = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: can't alloc %s transform: %ld\\n\",\n\t\t       hmac_alg, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = crypto_shash_setkey(tfm, key, keylen);\n\tif (!err)\n\t\terr = calc_hash(tfm, digest, buf, buflen);\n\tcrypto_free_shash(tfm);\n\treturn err;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char hmac_alg[] = \"hmac(sha256)\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "tfm"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calc_hash",
          "args": [
            "tfm",
            "digest",
            "buf",
            "buflen"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "calc_hash",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "325-337",
          "snippet": "static int calc_hash(struct crypto_shash *tfm, u8 *digest,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tint err;\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\terr = crypto_shash_digest(desc, buf, buflen, digest);\n\tshash_desc_zero(desc);\n\treturn err;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic int calc_hash(struct crypto_shash *tfm, u8 *digest,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tint err;\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\terr = crypto_shash_digest(desc, buf, buflen, digest);\n\tshash_desc_zero(desc);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_shash_setkey",
          "args": [
            "tfm",
            "key",
            "keylen"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: can't alloc %s transform: %ld\\n\"",
            "hmac_alg",
            "PTR_ERR(tfm)"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "hmac_alg",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char hmac_alg[] = \"hmac(sha256)\";\n\nstatic int calc_hmac(u8 *digest, const u8 *key, unsigned int keylen,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tstruct crypto_shash *tfm;\n\tint err;\n\n\ttfm = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: can't alloc %s transform: %ld\\n\",\n\t\t       hmac_alg, PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\n\terr = crypto_shash_setkey(tfm, key, keylen);\n\tif (!err)\n\t\terr = calc_hash(tfm, digest, buf, buflen);\n\tcrypto_free_shash(tfm);\n\treturn err;\n}"
  },
  {
    "function_name": "calc_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "325-337",
    "snippet": "static int calc_hash(struct crypto_shash *tfm, u8 *digest,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tint err;\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\terr = crypto_shash_digest(desc, buf, buflen, digest);\n\tshash_desc_zero(desc);\n\treturn err;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "shash_desc_zero",
          "args": [
            "desc"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_digest",
          "args": [
            "desc",
            "buf",
            "buflen",
            "digest"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SHASH_DESC_ON_STACK",
          "args": [
            "desc",
            "tfm"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic int calc_hash(struct crypto_shash *tfm, u8 *digest,\n\t\t     const u8 *buf, unsigned int buflen)\n{\n\tSHASH_DESC_ON_STACK(desc, tfm);\n\tint err;\n\n\tdesc->tfm = tfm;\n\tdesc->flags = 0;\n\n\terr = crypto_shash_digest(desc, buf, buflen, digest);\n\tshash_desc_zero(desc);\n\treturn err;\n}"
  },
  {
    "function_name": "request_user_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "300-323",
    "snippet": "static struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload_locked(ukey);\n\tif (!upayload) {\n\t\t/* key was revoked before we acquired its semaphore */\n\t\tup_read(&ukey->sem);\n\t\tkey_put(ukey);\n\t\tukey = ERR_PTR(-EKEYREVOKED);\n\t\tgoto error;\n\t}\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EKEYREVOKED"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "ukey"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&ukey->sem"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_key_payload_locked",
          "args": [
            "ukey"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&ukey->sem"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ukey"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_key",
          "args": [
            "&key_type_user",
            "master_desc",
            "NULL"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "request_key_auth_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "84-104",
          "snippet": "static long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void request_key_auth_revoke(struct key *);",
            "static void request_key_auth_destroy(struct key *);",
            "static long request_key_auth_read(const struct key *, char __user *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstatic long request_key_auth_read(const struct key *, char __user *, size_t);\n\nstatic long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic struct key *request_user_key(const char *master_desc, const u8 **master_key,\n\t\t\t\t    size_t *master_keylen)\n{\n\tconst struct user_key_payload *upayload;\n\tstruct key *ukey;\n\n\tukey = request_key(&key_type_user, master_desc, NULL);\n\tif (IS_ERR(ukey))\n\t\tgoto error;\n\n\tdown_read(&ukey->sem);\n\tupayload = user_key_payload_locked(ukey);\n\tif (!upayload) {\n\t\t/* key was revoked before we acquired its semaphore */\n\t\tup_read(&ukey->sem);\n\t\tkey_put(ukey);\n\t\tukey = ERR_PTR(-EKEYREVOKED);\n\t\tgoto error;\n\t}\n\t*master_key = upayload->data;\n\t*master_keylen = upayload->datalen;\nerror:\n\treturn ukey;\n}"
  },
  {
    "function_name": "datablob_format",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "269-293",
    "snippet": "static char *datablob_format(struct encrypted_key_payload *epayload,\n\t\t\t     size_t asciiblob_len)\n{\n\tchar *ascii_buf, *bufp;\n\tu8 *iv = epayload->iv;\n\tint len;\n\tint i;\n\n\tascii_buf = kmalloc(asciiblob_len + 1, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\tgoto out;\n\n\tascii_buf[asciiblob_len] = '\\0';\n\n\t/* copy datablob master_desc and datalen strings */\n\tlen = sprintf(ascii_buf, \"%s %s %s \", epayload->format,\n\t\t      epayload->master_desc, epayload->datalen);\n\n\t/* convert the hex encoded iv, encrypted-data and HMAC to ascii */\n\tbufp = &ascii_buf[len];\n\tfor (i = 0; i < (asciiblob_len - len) / 2; i++)\n\t\tbufp = hex_byte_pack(bufp, iv[i]);\nout:\n\treturn ascii_buf;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hex_byte_pack",
          "args": [
            "bufp",
            "iv[i]"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ascii_buf",
            "\"%s %s %s \"",
            "epayload->format",
            "epayload->master_desc",
            "epayload->datalen"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "asciiblob_len + 1",
            "GFP_KERNEL"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic char *datablob_format(struct encrypted_key_payload *epayload,\n\t\t\t     size_t asciiblob_len)\n{\n\tchar *ascii_buf, *bufp;\n\tu8 *iv = epayload->iv;\n\tint len;\n\tint i;\n\n\tascii_buf = kmalloc(asciiblob_len + 1, GFP_KERNEL);\n\tif (!ascii_buf)\n\t\tgoto out;\n\n\tascii_buf[asciiblob_len] = '\\0';\n\n\t/* copy datablob master_desc and datalen strings */\n\tlen = sprintf(ascii_buf, \"%s %s %s \", epayload->format,\n\t\t      epayload->master_desc, epayload->datalen);\n\n\t/* convert the hex encoded iv, encrypted-data and HMAC to ascii */\n\tbufp = &ascii_buf[len];\n\tfor (i = 0; i < (asciiblob_len - len) / 2; i++)\n\t\tbufp = hex_byte_pack(bufp, iv[i]);\nout:\n\treturn ascii_buf;\n}"
  },
  {
    "function_name": "datablob_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "171-264",
    "snippet": "static int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_error, NULL}\n};",
      "static const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"encrypted_key: keyword \\'%s\\' not recognized\\n\"",
            "keyword"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\"",
            "keyword"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"encrypted_key: hex blob is missing\\n\""
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&datablob",
            "\" \\t\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\"",
            "keyword"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\"",
            "keyword"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"encrypted_key: keylen parameter is missing\\n\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&datablob",
            "\" \\t\""
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\"",
            "*master_desc"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_master_desc",
          "args": [
            "*master_desc",
            "NULL"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "valid_master_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
          "lines": "137-155",
          "snippet": "static int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ecryptfs_format.h\"",
            "#include \"encrypted.h\"",
            "#include <crypto/skcipher.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <crypto/algapi.h>",
            "#include <crypto/aes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/random.h>",
            "#include <linux/key-type.h>",
            "#include <keys/encrypted-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [
            "#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)",
            "#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)"
          ],
          "globals_used": [
            "static const char KEY_TRUSTED_PREFIX[] = \"trusted:\";",
            "static const char KEY_USER_PREFIX[] = \"user:\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\n\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"encrypted_key: master key parameter is missing\\n\""
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&datablob",
            "\" \\t\""
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "key_format_tokens",
            "args"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: insufficient parameters specified\\n\""
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&datablob",
            "\" \\t\""
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "keyword",
            "key_tokens",
            "args"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"encrypted_key: insufficient parameters specified\\n\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&datablob",
            "\" \\t\""
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const match_table_t key_format_tokens = {\n\t{Opt_default, \"default\"},\n\t{Opt_ecryptfs, \"ecryptfs\"},\n\t{Opt_error, NULL}\n};\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_err, NULL}\n};\n\nstatic int datablob_parse(char *datablob, const char **format,\n\t\t\t  char **master_desc, char **decrypted_datalen,\n\t\t\t  char **hex_encoded_iv)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tint key_format;\n\tchar *p, *keyword;\n\n\tkeyword = strsep(&datablob, \" \\t\");\n\tif (!keyword) {\n\t\tpr_info(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\tkey_cmd = match_token(keyword, key_tokens, args);\n\n\t/* Get optional format: default | ecryptfs */\n\tp = strsep(&datablob, \" \\t\");\n\tif (!p) {\n\t\tpr_err(\"encrypted_key: insufficient parameters specified\\n\");\n\t\treturn ret;\n\t}\n\n\tkey_format = match_token(p, key_format_tokens, args);\n\tswitch (key_format) {\n\tcase Opt_ecryptfs:\n\tcase Opt_default:\n\t\t*format = p;\n\t\t*master_desc = strsep(&datablob, \" \\t\");\n\t\tbreak;\n\tcase Opt_error:\n\t\t*master_desc = p;\n\t\tbreak;\n\t}\n\n\tif (!*master_desc) {\n\t\tpr_info(\"encrypted_key: master key parameter is missing\\n\");\n\t\tgoto out;\n\t}\n\n\tif (valid_master_desc(*master_desc, NULL) < 0) {\n\t\tpr_info(\"encrypted_key: master key parameter \\'%s\\' \"\n\t\t\t\"is invalid\\n\", *master_desc);\n\t\tgoto out;\n\t}\n\n\tif (decrypted_datalen) {\n\t\t*decrypted_datalen = strsep(&datablob, \" \\t\");\n\t\tif (!*decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keylen parameter is missing\\n\");\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_load:\n\t\tif (!decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .update method\\n\", keyword);\n\t\t\tbreak;\n\t\t}\n\t\t*hex_encoded_iv = strsep(&datablob, \" \\t\");\n\t\tif (!*hex_encoded_iv) {\n\t\t\tpr_info(\"encrypted_key: hex blob is missing\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_update:\n\t\tif (decrypted_datalen) {\n\t\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not allowed \"\n\t\t\t\t\"when called from .instantiate method\\n\",\n\t\t\t\tkeyword);\n\t\t\tbreak;\n\t\t}\n\t\tret = 0;\n\t\tbreak;\n\tcase Opt_err:\n\t\tpr_info(\"encrypted_key: keyword \\'%s\\' not recognized\\n\",\n\t\t\tkeyword);\n\t\tbreak;\n\t}\nout:\n\treturn ret;\n}"
  },
  {
    "function_name": "valid_master_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "137-155",
    "snippet": "static int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)",
      "#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)"
    ],
    "globals_used": [
      "static const char KEY_TRUSTED_PREFIX[] = \"trusted:\";",
      "static const char KEY_USER_PREFIX[] = \"user:\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_desc",
            "orig_desc",
            "prefix_len"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_desc",
            "KEY_USER_PREFIX",
            "KEY_USER_PREFIX_LEN"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "new_desc",
            "KEY_TRUSTED_PREFIX",
            "KEY_TRUSTED_PREFIX_LEN"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define KEY_USER_PREFIX_LEN (sizeof (KEY_USER_PREFIX) - 1)\n#define KEY_TRUSTED_PREFIX_LEN (sizeof (KEY_TRUSTED_PREFIX) - 1)\n\nstatic const char KEY_TRUSTED_PREFIX[] = \"trusted:\";\nstatic const char KEY_USER_PREFIX[] = \"user:\";\n\nstatic int valid_master_desc(const char *new_desc, const char *orig_desc)\n{\n\tint prefix_len;\n\n\tif (!strncmp(new_desc, KEY_TRUSTED_PREFIX, KEY_TRUSTED_PREFIX_LEN))\n\t\tprefix_len = KEY_TRUSTED_PREFIX_LEN;\n\telse if (!strncmp(new_desc, KEY_USER_PREFIX, KEY_USER_PREFIX_LEN))\n\t\tprefix_len = KEY_USER_PREFIX_LEN;\n\telse\n\t\treturn -EINVAL;\n\n\tif (!new_desc[prefix_len])\n\t\treturn -EINVAL;\n\n\tif (orig_desc && strncmp(new_desc, orig_desc, prefix_len))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "valid_ecryptfs_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "104-123",
    "snippet": "static int valid_ecryptfs_desc(const char *ecryptfs_desc)\n{\n\tint i;\n\n\tif (strlen(ecryptfs_desc) != KEY_ECRYPTFS_DESC_LEN) {\n\t\tpr_err(\"encrypted_key: key description must be %d hexadecimal \"\n\t\t       \"characters long\\n\", KEY_ECRYPTFS_DESC_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < KEY_ECRYPTFS_DESC_LEN; i++) {\n\t\tif (!isxdigit(ecryptfs_desc[i])) {\n\t\t\tpr_err(\"encrypted_key: key description must contain \"\n\t\t\t       \"only hexadecimal characters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [
      "#define KEY_ECRYPTFS_DESC_LEN 16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: key description must contain \"\n\t\t\t       \"only hexadecimal characters\\n\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "ecryptfs_desc[i]"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: key description must be %d hexadecimal \"\n\t\t       \"characters long\\n\"",
            "KEY_ECRYPTFS_DESC_LEN"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ecryptfs_desc"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\n#define KEY_ECRYPTFS_DESC_LEN 16\n\nstatic int valid_ecryptfs_desc(const char *ecryptfs_desc)\n{\n\tint i;\n\n\tif (strlen(ecryptfs_desc) != KEY_ECRYPTFS_DESC_LEN) {\n\t\tpr_err(\"encrypted_key: key description must be %d hexadecimal \"\n\t\t       \"characters long\\n\", KEY_ECRYPTFS_DESC_LEN);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0; i < KEY_ECRYPTFS_DESC_LEN; i++) {\n\t\tif (!isxdigit(ecryptfs_desc[i])) {\n\t\t\tpr_err(\"encrypted_key: key description must contain \"\n\t\t\t       \"only hexadecimal characters\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "aes_get_sizes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/encrypted-keys/encrypted.c",
    "lines": "81-95",
    "snippet": "static int aes_get_sizes(void)\n{\n\tstruct crypto_skcipher *tfm;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to alloc_cipher (%ld)\\n\",\n\t\t       PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tivsize = crypto_skcipher_ivsize(tfm);\n\tblksize = crypto_skcipher_blocksize(tfm);\n\tcrypto_free_skcipher(tfm);\n\treturn 0;\n}",
    "includes": [
      "#include \"ecryptfs_format.h\"",
      "#include \"encrypted.h\"",
      "#include <crypto/skcipher.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <crypto/algapi.h>",
      "#include <crypto/aes.h>",
      "#include <linux/ctype.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/random.h>",
      "#include <linux/key-type.h>",
      "#include <keys/encrypted-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char blkcipher_alg[] = \"cbc(aes)\";",
      "static unsigned int ivsize;",
      "static int blksize;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_skcipher",
          "args": [
            "tfm"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_skcipher_blocksize",
          "args": [
            "tfm"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_skcipher_ivsize",
          "args": [
            "tfm"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"encrypted_key: failed to alloc_cipher (%ld)\\n\"",
            "PTR_ERR(tfm)"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tfm"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tfm"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_skcipher",
          "args": [
            "blkcipher_alg",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ecryptfs_format.h\"\n#include \"encrypted.h\"\n#include <crypto/skcipher.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <crypto/algapi.h>\n#include <crypto/aes.h>\n#include <linux/ctype.h>\n#include <linux/scatterlist.h>\n#include <linux/rcupdate.h>\n#include <linux/random.h>\n#include <linux/key-type.h>\n#include <keys/encrypted-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n\nstatic const char blkcipher_alg[] = \"cbc(aes)\";\nstatic unsigned int ivsize;\nstatic int blksize;\n\nstatic int aes_get_sizes(void)\n{\n\tstruct crypto_skcipher *tfm;\n\n\ttfm = crypto_alloc_skcipher(blkcipher_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm)) {\n\t\tpr_err(\"encrypted_key: failed to alloc_cipher (%ld)\\n\",\n\t\t       PTR_ERR(tfm));\n\t\treturn PTR_ERR(tfm);\n\t}\n\tivsize = crypto_skcipher_ivsize(tfm);\n\tblksize = crypto_skcipher_blocksize(tfm);\n\tcrypto_free_skcipher(tfm);\n\treturn 0;\n}"
  }
]