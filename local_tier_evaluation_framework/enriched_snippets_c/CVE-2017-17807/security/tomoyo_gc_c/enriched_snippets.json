[
  {
    "function_name": "tomoyo_notify_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "631-651",
    "snippet": "void tomoyo_notify_gc(struct tomoyo_io_buffer *head, const bool is_register)\n{\n\tbool is_write = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tif (is_register) {\n\t\thead->users = 1;\n\t\tlist_add(&head->list, &tomoyo_io_buffer_list);\n\t} else {\n\t\tis_write = head->write_buf != NULL;\n\t\tif (!--head->users) {\n\t\t\tlist_del(&head->list);\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head->write_buf);\n\t\t\tkfree(head);\n\t\t}\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\tif (is_write)\n\t\tkthread_run(tomoyo_gc_thread, NULL, \"GC for TOMOYO\");\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tomoyo_io_buffer_list);",
      "static DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_run",
          "args": [
            "tomoyo_gc_thread",
            "NULL",
            "\"GC for TOMOYO\""
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_io_buffer_list_lock"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "head"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "head->write_buf"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "head->read_buf"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&head->list"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&head->list",
            "&tomoyo_io_buffer_list"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_io_buffer_list_lock"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic LIST_HEAD(tomoyo_io_buffer_list);\nstatic DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);\n\nvoid tomoyo_notify_gc(struct tomoyo_io_buffer *head, const bool is_register)\n{\n\tbool is_write = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tif (is_register) {\n\t\thead->users = 1;\n\t\tlist_add(&head->list, &tomoyo_io_buffer_list);\n\t} else {\n\t\tis_write = head->write_buf != NULL;\n\t\tif (!--head->users) {\n\t\t\tlist_del(&head->list);\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head->write_buf);\n\t\t\tkfree(head);\n\t\t}\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\tif (is_write)\n\t\tkthread_run(tomoyo_gc_thread, NULL, \"GC for TOMOYO\");\n}"
  },
  {
    "function_name": "tomoyo_gc_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "594-621",
    "snippet": "static int tomoyo_gc_thread(void *unused)\n{\n\t/* Garbage collector thread is exclusive. */\n\tstatic DEFINE_MUTEX(tomoyo_gc_mutex);\n\tif (!mutex_trylock(&tomoyo_gc_mutex))\n\t\tgoto out;\n\ttomoyo_collect_entry();\n\t{\n\t\tstruct tomoyo_io_buffer *head;\n\t\tstruct tomoyo_io_buffer *tmp;\n\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\tlist_for_each_entry_safe(head, tmp, &tomoyo_io_buffer_list,\n\t\t\t\t\t list) {\n\t\t\tif (head->users)\n\t\t\t\tcontinue;\n\t\t\tlist_del(&head->list);\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head->write_buf);\n\t\t\tkfree(head);\n\t\t}\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t}\n\tmutex_unlock(&tomoyo_gc_mutex);\nout:\n\t/* This acts as do_exit(0). */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tomoyo_io_buffer_list);",
      "static DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tomoyo_gc_mutex"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_io_buffer_list_lock"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "head"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "head->write_buf"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "head->read_buf"
          ],
          "line": 611
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&head->list"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "head",
            "tmp",
            "&tomoyo_io_buffer_list",
            "list"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_io_buffer_list_lock"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_collect_entry",
          "args": [],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_collect_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "511-585",
          "snippet": "static void tomoyo_collect_entry(void)\n{\n\tint i;\n\tenum tomoyo_policy_id id;\n\tstruct tomoyo_policy_namespace *ns;\n\tmutex_lock(&tomoyo_policy_lock);\n\t{\n\t\tstruct tomoyo_domain_info *domain;\n\t\tstruct tomoyo_domain_info *tmp;\n\t\tlist_for_each_entry_safe(domain, tmp, &tomoyo_domain_list,\n\t\t\t\t\t list) {\n\t\t\ttomoyo_collect_acl(&domain->acl_info_list);\n\t\t\tif (!domain->is_deleted || atomic_read(&domain->users))\n\t\t\t\tcontinue;\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_DOMAIN, &domain->list);\n\t\t}\n\t}\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tfor (id = 0; id < TOMOYO_MAX_POLICY; id++)\n\t\t\ttomoyo_collect_member(id, &ns->policy_list[id]);\n\t\tfor (i = 0; i < TOMOYO_MAX_ACL_GROUPS; i++)\n\t\t\ttomoyo_collect_acl(&ns->acl_group[i]);\n\t}\n\t{\n\t\tstruct tomoyo_shared_acl_head *ptr;\n\t\tstruct tomoyo_shared_acl_head *tmp;\n\t\tlist_for_each_entry_safe(ptr, tmp, &tomoyo_condition_list,\n\t\t\t\t\t list) {\n\t\t\tif (atomic_read(&ptr->users) > 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_set(&ptr->users, TOMOYO_GC_IN_PROGRESS);\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_CONDITION, &ptr->list);\n\t\t}\n\t}\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tfor (i = 0; i < TOMOYO_MAX_GROUP; i++) {\n\t\t\tstruct list_head *list = &ns->group_list[i];\n\t\t\tstruct tomoyo_group *group;\n\t\t\tstruct tomoyo_group *tmp;\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tid = TOMOYO_ID_PATH_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tid = TOMOYO_ID_NUMBER_GROUP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tid = TOMOYO_ID_ADDRESS_GROUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_for_each_entry_safe(group, tmp, list, head.list) {\n\t\t\t\ttomoyo_collect_member(id, &group->member_list);\n\t\t\t\tif (!list_empty(&group->member_list) ||\n\t\t\t\t    atomic_read(&group->head.users) > 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tatomic_set(&group->head.users,\n\t\t\t\t\t   TOMOYO_GC_IN_PROGRESS);\n\t\t\t\ttomoyo_try_to_gc(TOMOYO_ID_GROUP,\n\t\t\t\t\t\t &group->head.list);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_HASH; i++) {\n\t\tstruct list_head *list = &tomoyo_name_list[i];\n\t\tstruct tomoyo_shared_acl_head *ptr;\n\t\tstruct tomoyo_shared_acl_head *tmp;\n\t\tlist_for_each_entry_safe(ptr, tmp, list, list) {\n\t\t\tif (atomic_read(&ptr->users) > 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_set(&ptr->users, TOMOYO_GC_IN_PROGRESS);\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_NAME, &ptr->list);\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_collect_entry(void)\n{\n\tint i;\n\tenum tomoyo_policy_id id;\n\tstruct tomoyo_policy_namespace *ns;\n\tmutex_lock(&tomoyo_policy_lock);\n\t{\n\t\tstruct tomoyo_domain_info *domain;\n\t\tstruct tomoyo_domain_info *tmp;\n\t\tlist_for_each_entry_safe(domain, tmp, &tomoyo_domain_list,\n\t\t\t\t\t list) {\n\t\t\ttomoyo_collect_acl(&domain->acl_info_list);\n\t\t\tif (!domain->is_deleted || atomic_read(&domain->users))\n\t\t\t\tcontinue;\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_DOMAIN, &domain->list);\n\t\t}\n\t}\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tfor (id = 0; id < TOMOYO_MAX_POLICY; id++)\n\t\t\ttomoyo_collect_member(id, &ns->policy_list[id]);\n\t\tfor (i = 0; i < TOMOYO_MAX_ACL_GROUPS; i++)\n\t\t\ttomoyo_collect_acl(&ns->acl_group[i]);\n\t}\n\t{\n\t\tstruct tomoyo_shared_acl_head *ptr;\n\t\tstruct tomoyo_shared_acl_head *tmp;\n\t\tlist_for_each_entry_safe(ptr, tmp, &tomoyo_condition_list,\n\t\t\t\t\t list) {\n\t\t\tif (atomic_read(&ptr->users) > 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_set(&ptr->users, TOMOYO_GC_IN_PROGRESS);\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_CONDITION, &ptr->list);\n\t\t}\n\t}\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tfor (i = 0; i < TOMOYO_MAX_GROUP; i++) {\n\t\t\tstruct list_head *list = &ns->group_list[i];\n\t\t\tstruct tomoyo_group *group;\n\t\t\tstruct tomoyo_group *tmp;\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tid = TOMOYO_ID_PATH_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tid = TOMOYO_ID_NUMBER_GROUP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tid = TOMOYO_ID_ADDRESS_GROUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_for_each_entry_safe(group, tmp, list, head.list) {\n\t\t\t\ttomoyo_collect_member(id, &group->member_list);\n\t\t\t\tif (!list_empty(&group->member_list) ||\n\t\t\t\t    atomic_read(&group->head.users) > 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tatomic_set(&group->head.users,\n\t\t\t\t\t   TOMOYO_GC_IN_PROGRESS);\n\t\t\t\ttomoyo_try_to_gc(TOMOYO_ID_GROUP,\n\t\t\t\t\t\t &group->head.list);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_HASH; i++) {\n\t\tstruct list_head *list = &tomoyo_name_list[i];\n\t\tstruct tomoyo_shared_acl_head *ptr;\n\t\tstruct tomoyo_shared_acl_head *tmp;\n\t\tlist_for_each_entry_safe(ptr, tmp, list, list) {\n\t\t\tif (atomic_read(&ptr->users) > 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_set(&ptr->users, TOMOYO_GC_IN_PROGRESS);\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_NAME, &ptr->list);\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_trylock",
          "args": [
            "&tomoyo_gc_mutex"
          ],
          "line": 598
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic LIST_HEAD(tomoyo_io_buffer_list);\nstatic DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);\n\nstatic int tomoyo_gc_thread(void *unused)\n{\n\t/* Garbage collector thread is exclusive. */\n\tstatic DEFINE_MUTEX(tomoyo_gc_mutex);\n\tif (!mutex_trylock(&tomoyo_gc_mutex))\n\t\tgoto out;\n\ttomoyo_collect_entry();\n\t{\n\t\tstruct tomoyo_io_buffer *head;\n\t\tstruct tomoyo_io_buffer *tmp;\n\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\tlist_for_each_entry_safe(head, tmp, &tomoyo_io_buffer_list,\n\t\t\t\t\t list) {\n\t\t\tif (head->users)\n\t\t\t\tcontinue;\n\t\t\tlist_del(&head->list);\n\t\t\tkfree(head->read_buf);\n\t\t\tkfree(head->write_buf);\n\t\t\tkfree(head);\n\t\t}\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t}\n\tmutex_unlock(&tomoyo_gc_mutex);\nout:\n\t/* This acts as do_exit(0). */\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_collect_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "511-585",
    "snippet": "static void tomoyo_collect_entry(void)\n{\n\tint i;\n\tenum tomoyo_policy_id id;\n\tstruct tomoyo_policy_namespace *ns;\n\tmutex_lock(&tomoyo_policy_lock);\n\t{\n\t\tstruct tomoyo_domain_info *domain;\n\t\tstruct tomoyo_domain_info *tmp;\n\t\tlist_for_each_entry_safe(domain, tmp, &tomoyo_domain_list,\n\t\t\t\t\t list) {\n\t\t\ttomoyo_collect_acl(&domain->acl_info_list);\n\t\t\tif (!domain->is_deleted || atomic_read(&domain->users))\n\t\t\t\tcontinue;\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_DOMAIN, &domain->list);\n\t\t}\n\t}\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tfor (id = 0; id < TOMOYO_MAX_POLICY; id++)\n\t\t\ttomoyo_collect_member(id, &ns->policy_list[id]);\n\t\tfor (i = 0; i < TOMOYO_MAX_ACL_GROUPS; i++)\n\t\t\ttomoyo_collect_acl(&ns->acl_group[i]);\n\t}\n\t{\n\t\tstruct tomoyo_shared_acl_head *ptr;\n\t\tstruct tomoyo_shared_acl_head *tmp;\n\t\tlist_for_each_entry_safe(ptr, tmp, &tomoyo_condition_list,\n\t\t\t\t\t list) {\n\t\t\tif (atomic_read(&ptr->users) > 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_set(&ptr->users, TOMOYO_GC_IN_PROGRESS);\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_CONDITION, &ptr->list);\n\t\t}\n\t}\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tfor (i = 0; i < TOMOYO_MAX_GROUP; i++) {\n\t\t\tstruct list_head *list = &ns->group_list[i];\n\t\t\tstruct tomoyo_group *group;\n\t\t\tstruct tomoyo_group *tmp;\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tid = TOMOYO_ID_PATH_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tid = TOMOYO_ID_NUMBER_GROUP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tid = TOMOYO_ID_ADDRESS_GROUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_for_each_entry_safe(group, tmp, list, head.list) {\n\t\t\t\ttomoyo_collect_member(id, &group->member_list);\n\t\t\t\tif (!list_empty(&group->member_list) ||\n\t\t\t\t    atomic_read(&group->head.users) > 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tatomic_set(&group->head.users,\n\t\t\t\t\t   TOMOYO_GC_IN_PROGRESS);\n\t\t\t\ttomoyo_try_to_gc(TOMOYO_ID_GROUP,\n\t\t\t\t\t\t &group->head.list);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_HASH; i++) {\n\t\tstruct list_head *list = &tomoyo_name_list[i];\n\t\tstruct tomoyo_shared_acl_head *ptr;\n\t\tstruct tomoyo_shared_acl_head *tmp;\n\t\tlist_for_each_entry_safe(ptr, tmp, list, list) {\n\t\t\tif (atomic_read(&ptr->users) > 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_set(&ptr->users, TOMOYO_GC_IN_PROGRESS);\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_NAME, &ptr->list);\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_try_to_gc",
          "args": [
            "TOMOYO_ID_NAME",
            "&ptr->list"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_try_to_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "375-464",
          "snippet": "static void tomoyo_try_to_gc(const enum tomoyo_policy_id type,\n\t\t\t     struct list_head *element)\n{\n\t/*\n\t * __list_del_entry() guarantees that the list element became no longer\n\t * reachable from the list which the element was originally on (e.g.\n\t * tomoyo_domain_list). Also, synchronize_srcu() guarantees that the\n\t * list element became no longer referenced by syscall users.\n\t */\n\t__list_del_entry(element);\n\tmutex_unlock(&tomoyo_policy_lock);\n\tsynchronize_srcu(&tomoyo_ss);\n\t/*\n\t * However, there are two users which may still be using the list\n\t * element. We need to defer until both users forget this element.\n\t *\n\t * Don't kfree() until \"struct tomoyo_io_buffer\"->r.{domain,group,acl}\n\t * and \"struct tomoyo_io_buffer\"->w.domain forget this element.\n\t */\n\tif (tomoyo_struct_used_by_io_buffer(element))\n\t\tgoto reinject;\n\tswitch (type) {\n\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\ttomoyo_del_transition_control(element);\n\t\tbreak;\n\tcase TOMOYO_ID_MANAGER:\n\t\ttomoyo_del_manager(element);\n\t\tbreak;\n\tcase TOMOYO_ID_AGGREGATOR:\n\t\ttomoyo_del_aggregator(element);\n\t\tbreak;\n\tcase TOMOYO_ID_GROUP:\n\t\ttomoyo_del_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_PATH_GROUP:\n\t\ttomoyo_del_path_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ADDRESS_GROUP:\n\t\ttomoyo_del_address_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NUMBER_GROUP:\n\t\ttomoyo_del_number_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_CONDITION:\n\t\ttomoyo_del_condition(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NAME:\n\t\t/*\n\t\t * Don't kfree() until all \"struct tomoyo_io_buffer\"->r.w[]\n\t\t * forget this element.\n\t\t */\n\t\tif (tomoyo_name_used_by_io_buffer\n\t\t    (container_of(element, typeof(struct tomoyo_name),\n\t\t\t\t  head.list)->entry.name))\n\t\t\tgoto reinject;\n\t\ttomoyo_del_name(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ACL:\n\t\ttomoyo_del_acl(element);\n\t\tbreak;\n\tcase TOMOYO_ID_DOMAIN:\n\t\t/*\n\t\t * Don't kfree() until all \"struct cred\"->security forget this\n\t\t * element.\n\t\t */\n\t\tif (atomic_read(&container_of\n\t\t\t\t(element, typeof(struct tomoyo_domain_info),\n\t\t\t\t list)->users))\n\t\t\tgoto reinject;\n\t\tbreak;\n\tcase TOMOYO_MAX_POLICY:\n\t\tbreak;\n\t}\n\tmutex_lock(&tomoyo_policy_lock);\n\tif (type == TOMOYO_ID_DOMAIN)\n\t\ttomoyo_del_domain(element);\n\ttomoyo_memory_free(element);\n\treturn;\nreinject:\n\t/*\n\t * We can safely reinject this element here bacause\n\t * (1) Appending list elements and removing list elements are protected\n\t *     by tomoyo_policy_lock mutex.\n\t * (2) Only this function removes list elements and this function is\n\t *     exclusively executed by tomoyo_gc_mutex mutex.\n\t * are true.\n\t */\n\tmutex_lock(&tomoyo_policy_lock);\n\tlist_add_rcu(element, element->prev);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_try_to_gc(const enum tomoyo_policy_id type,\n\t\t\t     struct list_head *element)\n{\n\t/*\n\t * __list_del_entry() guarantees that the list element became no longer\n\t * reachable from the list which the element was originally on (e.g.\n\t * tomoyo_domain_list). Also, synchronize_srcu() guarantees that the\n\t * list element became no longer referenced by syscall users.\n\t */\n\t__list_del_entry(element);\n\tmutex_unlock(&tomoyo_policy_lock);\n\tsynchronize_srcu(&tomoyo_ss);\n\t/*\n\t * However, there are two users which may still be using the list\n\t * element. We need to defer until both users forget this element.\n\t *\n\t * Don't kfree() until \"struct tomoyo_io_buffer\"->r.{domain,group,acl}\n\t * and \"struct tomoyo_io_buffer\"->w.domain forget this element.\n\t */\n\tif (tomoyo_struct_used_by_io_buffer(element))\n\t\tgoto reinject;\n\tswitch (type) {\n\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\ttomoyo_del_transition_control(element);\n\t\tbreak;\n\tcase TOMOYO_ID_MANAGER:\n\t\ttomoyo_del_manager(element);\n\t\tbreak;\n\tcase TOMOYO_ID_AGGREGATOR:\n\t\ttomoyo_del_aggregator(element);\n\t\tbreak;\n\tcase TOMOYO_ID_GROUP:\n\t\ttomoyo_del_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_PATH_GROUP:\n\t\ttomoyo_del_path_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ADDRESS_GROUP:\n\t\ttomoyo_del_address_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NUMBER_GROUP:\n\t\ttomoyo_del_number_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_CONDITION:\n\t\ttomoyo_del_condition(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NAME:\n\t\t/*\n\t\t * Don't kfree() until all \"struct tomoyo_io_buffer\"->r.w[]\n\t\t * forget this element.\n\t\t */\n\t\tif (tomoyo_name_used_by_io_buffer\n\t\t    (container_of(element, typeof(struct tomoyo_name),\n\t\t\t\t  head.list)->entry.name))\n\t\t\tgoto reinject;\n\t\ttomoyo_del_name(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ACL:\n\t\ttomoyo_del_acl(element);\n\t\tbreak;\n\tcase TOMOYO_ID_DOMAIN:\n\t\t/*\n\t\t * Don't kfree() until all \"struct cred\"->security forget this\n\t\t * element.\n\t\t */\n\t\tif (atomic_read(&container_of\n\t\t\t\t(element, typeof(struct tomoyo_domain_info),\n\t\t\t\t list)->users))\n\t\t\tgoto reinject;\n\t\tbreak;\n\tcase TOMOYO_MAX_POLICY:\n\t\tbreak;\n\t}\n\tmutex_lock(&tomoyo_policy_lock);\n\tif (type == TOMOYO_ID_DOMAIN)\n\t\ttomoyo_del_domain(element);\n\ttomoyo_memory_free(element);\n\treturn;\nreinject:\n\t/*\n\t * We can safely reinject this element here bacause\n\t * (1) Appending list elements and removing list elements are protected\n\t *     by tomoyo_policy_lock mutex.\n\t * (2) Only this function removes list elements and this function is\n\t *     exclusively executed by tomoyo_gc_mutex mutex.\n\t * are true.\n\t */\n\tmutex_lock(&tomoyo_policy_lock);\n\tlist_add_rcu(element, element->prev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ptr->users",
            "TOMOYO_GC_IN_PROGRESS"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ptr->users"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ptr",
            "tmp",
            "list",
            "list"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&group->head.users",
            "TOMOYO_GC_IN_PROGRESS"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&group->head.users"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&group->member_list"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_collect_member",
          "args": [
            "id",
            "&group->member_list"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_collect_member",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "474-485",
          "snippet": "static void tomoyo_collect_member(const enum tomoyo_policy_id id,\n\t\t\t\t  struct list_head *member_list)\n{\n\tstruct tomoyo_acl_head *member;\n\tstruct tomoyo_acl_head *tmp;\n\tlist_for_each_entry_safe(member, tmp, member_list, list) {\n\t\tif (!member->is_deleted)\n\t\t\tcontinue;\n\t\tmember->is_deleted = TOMOYO_GC_IN_PROGRESS;\n\t\ttomoyo_try_to_gc(id, &member->list);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_collect_member(const enum tomoyo_policy_id id,\n\t\t\t\t  struct list_head *member_list)\n{\n\tstruct tomoyo_acl_head *member;\n\tstruct tomoyo_acl_head *tmp;\n\tlist_for_each_entry_safe(member, tmp, member_list, list) {\n\t\tif (!member->is_deleted)\n\t\t\tcontinue;\n\t\tmember->is_deleted = TOMOYO_GC_IN_PROGRESS;\n\t\ttomoyo_try_to_gc(id, &member->list);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "group",
            "tmp",
            "list",
            "head.list"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ns",
            "&tomoyo_namespace_list",
            "namespace_list"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&ptr->users",
            "TOMOYO_GC_IN_PROGRESS"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&ptr->users"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ptr",
            "tmp",
            "&tomoyo_condition_list",
            "list"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_collect_acl",
          "args": [
            "&ns->acl_group[i]"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_collect_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "494-504",
          "snippet": "static void tomoyo_collect_acl(struct list_head *list)\n{\n\tstruct tomoyo_acl_info *acl;\n\tstruct tomoyo_acl_info *tmp;\n\tlist_for_each_entry_safe(acl, tmp, list, list) {\n\t\tif (!acl->is_deleted)\n\t\t\tcontinue;\n\t\tacl->is_deleted = TOMOYO_GC_IN_PROGRESS;\n\t\ttomoyo_try_to_gc(TOMOYO_ID_ACL, &acl->list);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_collect_acl(struct list_head *list)\n{\n\tstruct tomoyo_acl_info *acl;\n\tstruct tomoyo_acl_info *tmp;\n\tlist_for_each_entry_safe(acl, tmp, list, list) {\n\t\tif (!acl->is_deleted)\n\t\t\tcontinue;\n\t\tacl->is_deleted = TOMOYO_GC_IN_PROGRESS;\n\t\ttomoyo_try_to_gc(TOMOYO_ID_ACL, &acl->list);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ns",
            "&tomoyo_namespace_list",
            "namespace_list"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&domain->users"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "domain",
            "tmp",
            "&tomoyo_domain_list",
            "list"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_collect_entry(void)\n{\n\tint i;\n\tenum tomoyo_policy_id id;\n\tstruct tomoyo_policy_namespace *ns;\n\tmutex_lock(&tomoyo_policy_lock);\n\t{\n\t\tstruct tomoyo_domain_info *domain;\n\t\tstruct tomoyo_domain_info *tmp;\n\t\tlist_for_each_entry_safe(domain, tmp, &tomoyo_domain_list,\n\t\t\t\t\t list) {\n\t\t\ttomoyo_collect_acl(&domain->acl_info_list);\n\t\t\tif (!domain->is_deleted || atomic_read(&domain->users))\n\t\t\t\tcontinue;\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_DOMAIN, &domain->list);\n\t\t}\n\t}\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tfor (id = 0; id < TOMOYO_MAX_POLICY; id++)\n\t\t\ttomoyo_collect_member(id, &ns->policy_list[id]);\n\t\tfor (i = 0; i < TOMOYO_MAX_ACL_GROUPS; i++)\n\t\t\ttomoyo_collect_acl(&ns->acl_group[i]);\n\t}\n\t{\n\t\tstruct tomoyo_shared_acl_head *ptr;\n\t\tstruct tomoyo_shared_acl_head *tmp;\n\t\tlist_for_each_entry_safe(ptr, tmp, &tomoyo_condition_list,\n\t\t\t\t\t list) {\n\t\t\tif (atomic_read(&ptr->users) > 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_set(&ptr->users, TOMOYO_GC_IN_PROGRESS);\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_CONDITION, &ptr->list);\n\t\t}\n\t}\n\tlist_for_each_entry(ns, &tomoyo_namespace_list, namespace_list) {\n\t\tfor (i = 0; i < TOMOYO_MAX_GROUP; i++) {\n\t\t\tstruct list_head *list = &ns->group_list[i];\n\t\t\tstruct tomoyo_group *group;\n\t\t\tstruct tomoyo_group *tmp;\n\t\t\tswitch (i) {\n\t\t\tcase 0:\n\t\t\t\tid = TOMOYO_ID_PATH_GROUP;\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\tid = TOMOYO_ID_NUMBER_GROUP;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tid = TOMOYO_ID_ADDRESS_GROUP;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlist_for_each_entry_safe(group, tmp, list, head.list) {\n\t\t\t\ttomoyo_collect_member(id, &group->member_list);\n\t\t\t\tif (!list_empty(&group->member_list) ||\n\t\t\t\t    atomic_read(&group->head.users) > 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tatomic_set(&group->head.users,\n\t\t\t\t\t   TOMOYO_GC_IN_PROGRESS);\n\t\t\t\ttomoyo_try_to_gc(TOMOYO_ID_GROUP,\n\t\t\t\t\t\t &group->head.list);\n\t\t\t}\n\t\t}\n\t}\n\tfor (i = 0; i < TOMOYO_MAX_HASH; i++) {\n\t\tstruct list_head *list = &tomoyo_name_list[i];\n\t\tstruct tomoyo_shared_acl_head *ptr;\n\t\tstruct tomoyo_shared_acl_head *tmp;\n\t\tlist_for_each_entry_safe(ptr, tmp, list, list) {\n\t\t\tif (atomic_read(&ptr->users) > 0)\n\t\t\t\tcontinue;\n\t\t\tatomic_set(&ptr->users, TOMOYO_GC_IN_PROGRESS);\n\t\t\ttomoyo_try_to_gc(TOMOYO_ID_NAME, &ptr->list);\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\n}"
  },
  {
    "function_name": "tomoyo_collect_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "494-504",
    "snippet": "static void tomoyo_collect_acl(struct list_head *list)\n{\n\tstruct tomoyo_acl_info *acl;\n\tstruct tomoyo_acl_info *tmp;\n\tlist_for_each_entry_safe(acl, tmp, list, list) {\n\t\tif (!acl->is_deleted)\n\t\t\tcontinue;\n\t\tacl->is_deleted = TOMOYO_GC_IN_PROGRESS;\n\t\ttomoyo_try_to_gc(TOMOYO_ID_ACL, &acl->list);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_try_to_gc",
          "args": [
            "TOMOYO_ID_ACL",
            "&acl->list"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_try_to_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "375-464",
          "snippet": "static void tomoyo_try_to_gc(const enum tomoyo_policy_id type,\n\t\t\t     struct list_head *element)\n{\n\t/*\n\t * __list_del_entry() guarantees that the list element became no longer\n\t * reachable from the list which the element was originally on (e.g.\n\t * tomoyo_domain_list). Also, synchronize_srcu() guarantees that the\n\t * list element became no longer referenced by syscall users.\n\t */\n\t__list_del_entry(element);\n\tmutex_unlock(&tomoyo_policy_lock);\n\tsynchronize_srcu(&tomoyo_ss);\n\t/*\n\t * However, there are two users which may still be using the list\n\t * element. We need to defer until both users forget this element.\n\t *\n\t * Don't kfree() until \"struct tomoyo_io_buffer\"->r.{domain,group,acl}\n\t * and \"struct tomoyo_io_buffer\"->w.domain forget this element.\n\t */\n\tif (tomoyo_struct_used_by_io_buffer(element))\n\t\tgoto reinject;\n\tswitch (type) {\n\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\ttomoyo_del_transition_control(element);\n\t\tbreak;\n\tcase TOMOYO_ID_MANAGER:\n\t\ttomoyo_del_manager(element);\n\t\tbreak;\n\tcase TOMOYO_ID_AGGREGATOR:\n\t\ttomoyo_del_aggregator(element);\n\t\tbreak;\n\tcase TOMOYO_ID_GROUP:\n\t\ttomoyo_del_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_PATH_GROUP:\n\t\ttomoyo_del_path_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ADDRESS_GROUP:\n\t\ttomoyo_del_address_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NUMBER_GROUP:\n\t\ttomoyo_del_number_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_CONDITION:\n\t\ttomoyo_del_condition(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NAME:\n\t\t/*\n\t\t * Don't kfree() until all \"struct tomoyo_io_buffer\"->r.w[]\n\t\t * forget this element.\n\t\t */\n\t\tif (tomoyo_name_used_by_io_buffer\n\t\t    (container_of(element, typeof(struct tomoyo_name),\n\t\t\t\t  head.list)->entry.name))\n\t\t\tgoto reinject;\n\t\ttomoyo_del_name(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ACL:\n\t\ttomoyo_del_acl(element);\n\t\tbreak;\n\tcase TOMOYO_ID_DOMAIN:\n\t\t/*\n\t\t * Don't kfree() until all \"struct cred\"->security forget this\n\t\t * element.\n\t\t */\n\t\tif (atomic_read(&container_of\n\t\t\t\t(element, typeof(struct tomoyo_domain_info),\n\t\t\t\t list)->users))\n\t\t\tgoto reinject;\n\t\tbreak;\n\tcase TOMOYO_MAX_POLICY:\n\t\tbreak;\n\t}\n\tmutex_lock(&tomoyo_policy_lock);\n\tif (type == TOMOYO_ID_DOMAIN)\n\t\ttomoyo_del_domain(element);\n\ttomoyo_memory_free(element);\n\treturn;\nreinject:\n\t/*\n\t * We can safely reinject this element here bacause\n\t * (1) Appending list elements and removing list elements are protected\n\t *     by tomoyo_policy_lock mutex.\n\t * (2) Only this function removes list elements and this function is\n\t *     exclusively executed by tomoyo_gc_mutex mutex.\n\t * are true.\n\t */\n\tmutex_lock(&tomoyo_policy_lock);\n\tlist_add_rcu(element, element->prev);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_try_to_gc(const enum tomoyo_policy_id type,\n\t\t\t     struct list_head *element)\n{\n\t/*\n\t * __list_del_entry() guarantees that the list element became no longer\n\t * reachable from the list which the element was originally on (e.g.\n\t * tomoyo_domain_list). Also, synchronize_srcu() guarantees that the\n\t * list element became no longer referenced by syscall users.\n\t */\n\t__list_del_entry(element);\n\tmutex_unlock(&tomoyo_policy_lock);\n\tsynchronize_srcu(&tomoyo_ss);\n\t/*\n\t * However, there are two users which may still be using the list\n\t * element. We need to defer until both users forget this element.\n\t *\n\t * Don't kfree() until \"struct tomoyo_io_buffer\"->r.{domain,group,acl}\n\t * and \"struct tomoyo_io_buffer\"->w.domain forget this element.\n\t */\n\tif (tomoyo_struct_used_by_io_buffer(element))\n\t\tgoto reinject;\n\tswitch (type) {\n\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\ttomoyo_del_transition_control(element);\n\t\tbreak;\n\tcase TOMOYO_ID_MANAGER:\n\t\ttomoyo_del_manager(element);\n\t\tbreak;\n\tcase TOMOYO_ID_AGGREGATOR:\n\t\ttomoyo_del_aggregator(element);\n\t\tbreak;\n\tcase TOMOYO_ID_GROUP:\n\t\ttomoyo_del_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_PATH_GROUP:\n\t\ttomoyo_del_path_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ADDRESS_GROUP:\n\t\ttomoyo_del_address_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NUMBER_GROUP:\n\t\ttomoyo_del_number_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_CONDITION:\n\t\ttomoyo_del_condition(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NAME:\n\t\t/*\n\t\t * Don't kfree() until all \"struct tomoyo_io_buffer\"->r.w[]\n\t\t * forget this element.\n\t\t */\n\t\tif (tomoyo_name_used_by_io_buffer\n\t\t    (container_of(element, typeof(struct tomoyo_name),\n\t\t\t\t  head.list)->entry.name))\n\t\t\tgoto reinject;\n\t\ttomoyo_del_name(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ACL:\n\t\ttomoyo_del_acl(element);\n\t\tbreak;\n\tcase TOMOYO_ID_DOMAIN:\n\t\t/*\n\t\t * Don't kfree() until all \"struct cred\"->security forget this\n\t\t * element.\n\t\t */\n\t\tif (atomic_read(&container_of\n\t\t\t\t(element, typeof(struct tomoyo_domain_info),\n\t\t\t\t list)->users))\n\t\t\tgoto reinject;\n\t\tbreak;\n\tcase TOMOYO_MAX_POLICY:\n\t\tbreak;\n\t}\n\tmutex_lock(&tomoyo_policy_lock);\n\tif (type == TOMOYO_ID_DOMAIN)\n\t\ttomoyo_del_domain(element);\n\ttomoyo_memory_free(element);\n\treturn;\nreinject:\n\t/*\n\t * We can safely reinject this element here bacause\n\t * (1) Appending list elements and removing list elements are protected\n\t *     by tomoyo_policy_lock mutex.\n\t * (2) Only this function removes list elements and this function is\n\t *     exclusively executed by tomoyo_gc_mutex mutex.\n\t * are true.\n\t */\n\tmutex_lock(&tomoyo_policy_lock);\n\tlist_add_rcu(element, element->prev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "acl",
            "tmp",
            "list",
            "list"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_collect_acl(struct list_head *list)\n{\n\tstruct tomoyo_acl_info *acl;\n\tstruct tomoyo_acl_info *tmp;\n\tlist_for_each_entry_safe(acl, tmp, list, list) {\n\t\tif (!acl->is_deleted)\n\t\t\tcontinue;\n\t\tacl->is_deleted = TOMOYO_GC_IN_PROGRESS;\n\t\ttomoyo_try_to_gc(TOMOYO_ID_ACL, &acl->list);\n\t}\n}"
  },
  {
    "function_name": "tomoyo_collect_member",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "474-485",
    "snippet": "static void tomoyo_collect_member(const enum tomoyo_policy_id id,\n\t\t\t\t  struct list_head *member_list)\n{\n\tstruct tomoyo_acl_head *member;\n\tstruct tomoyo_acl_head *tmp;\n\tlist_for_each_entry_safe(member, tmp, member_list, list) {\n\t\tif (!member->is_deleted)\n\t\t\tcontinue;\n\t\tmember->is_deleted = TOMOYO_GC_IN_PROGRESS;\n\t\ttomoyo_try_to_gc(id, &member->list);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_try_to_gc",
          "args": [
            "id",
            "&member->list"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_try_to_gc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "375-464",
          "snippet": "static void tomoyo_try_to_gc(const enum tomoyo_policy_id type,\n\t\t\t     struct list_head *element)\n{\n\t/*\n\t * __list_del_entry() guarantees that the list element became no longer\n\t * reachable from the list which the element was originally on (e.g.\n\t * tomoyo_domain_list). Also, synchronize_srcu() guarantees that the\n\t * list element became no longer referenced by syscall users.\n\t */\n\t__list_del_entry(element);\n\tmutex_unlock(&tomoyo_policy_lock);\n\tsynchronize_srcu(&tomoyo_ss);\n\t/*\n\t * However, there are two users which may still be using the list\n\t * element. We need to defer until both users forget this element.\n\t *\n\t * Don't kfree() until \"struct tomoyo_io_buffer\"->r.{domain,group,acl}\n\t * and \"struct tomoyo_io_buffer\"->w.domain forget this element.\n\t */\n\tif (tomoyo_struct_used_by_io_buffer(element))\n\t\tgoto reinject;\n\tswitch (type) {\n\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\ttomoyo_del_transition_control(element);\n\t\tbreak;\n\tcase TOMOYO_ID_MANAGER:\n\t\ttomoyo_del_manager(element);\n\t\tbreak;\n\tcase TOMOYO_ID_AGGREGATOR:\n\t\ttomoyo_del_aggregator(element);\n\t\tbreak;\n\tcase TOMOYO_ID_GROUP:\n\t\ttomoyo_del_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_PATH_GROUP:\n\t\ttomoyo_del_path_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ADDRESS_GROUP:\n\t\ttomoyo_del_address_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NUMBER_GROUP:\n\t\ttomoyo_del_number_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_CONDITION:\n\t\ttomoyo_del_condition(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NAME:\n\t\t/*\n\t\t * Don't kfree() until all \"struct tomoyo_io_buffer\"->r.w[]\n\t\t * forget this element.\n\t\t */\n\t\tif (tomoyo_name_used_by_io_buffer\n\t\t    (container_of(element, typeof(struct tomoyo_name),\n\t\t\t\t  head.list)->entry.name))\n\t\t\tgoto reinject;\n\t\ttomoyo_del_name(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ACL:\n\t\ttomoyo_del_acl(element);\n\t\tbreak;\n\tcase TOMOYO_ID_DOMAIN:\n\t\t/*\n\t\t * Don't kfree() until all \"struct cred\"->security forget this\n\t\t * element.\n\t\t */\n\t\tif (atomic_read(&container_of\n\t\t\t\t(element, typeof(struct tomoyo_domain_info),\n\t\t\t\t list)->users))\n\t\t\tgoto reinject;\n\t\tbreak;\n\tcase TOMOYO_MAX_POLICY:\n\t\tbreak;\n\t}\n\tmutex_lock(&tomoyo_policy_lock);\n\tif (type == TOMOYO_ID_DOMAIN)\n\t\ttomoyo_del_domain(element);\n\ttomoyo_memory_free(element);\n\treturn;\nreinject:\n\t/*\n\t * We can safely reinject this element here bacause\n\t * (1) Appending list elements and removing list elements are protected\n\t *     by tomoyo_policy_lock mutex.\n\t * (2) Only this function removes list elements and this function is\n\t *     exclusively executed by tomoyo_gc_mutex mutex.\n\t * are true.\n\t */\n\tmutex_lock(&tomoyo_policy_lock);\n\tlist_add_rcu(element, element->prev);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_try_to_gc(const enum tomoyo_policy_id type,\n\t\t\t     struct list_head *element)\n{\n\t/*\n\t * __list_del_entry() guarantees that the list element became no longer\n\t * reachable from the list which the element was originally on (e.g.\n\t * tomoyo_domain_list). Also, synchronize_srcu() guarantees that the\n\t * list element became no longer referenced by syscall users.\n\t */\n\t__list_del_entry(element);\n\tmutex_unlock(&tomoyo_policy_lock);\n\tsynchronize_srcu(&tomoyo_ss);\n\t/*\n\t * However, there are two users which may still be using the list\n\t * element. We need to defer until both users forget this element.\n\t *\n\t * Don't kfree() until \"struct tomoyo_io_buffer\"->r.{domain,group,acl}\n\t * and \"struct tomoyo_io_buffer\"->w.domain forget this element.\n\t */\n\tif (tomoyo_struct_used_by_io_buffer(element))\n\t\tgoto reinject;\n\tswitch (type) {\n\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\ttomoyo_del_transition_control(element);\n\t\tbreak;\n\tcase TOMOYO_ID_MANAGER:\n\t\ttomoyo_del_manager(element);\n\t\tbreak;\n\tcase TOMOYO_ID_AGGREGATOR:\n\t\ttomoyo_del_aggregator(element);\n\t\tbreak;\n\tcase TOMOYO_ID_GROUP:\n\t\ttomoyo_del_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_PATH_GROUP:\n\t\ttomoyo_del_path_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ADDRESS_GROUP:\n\t\ttomoyo_del_address_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NUMBER_GROUP:\n\t\ttomoyo_del_number_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_CONDITION:\n\t\ttomoyo_del_condition(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NAME:\n\t\t/*\n\t\t * Don't kfree() until all \"struct tomoyo_io_buffer\"->r.w[]\n\t\t * forget this element.\n\t\t */\n\t\tif (tomoyo_name_used_by_io_buffer\n\t\t    (container_of(element, typeof(struct tomoyo_name),\n\t\t\t\t  head.list)->entry.name))\n\t\t\tgoto reinject;\n\t\ttomoyo_del_name(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ACL:\n\t\ttomoyo_del_acl(element);\n\t\tbreak;\n\tcase TOMOYO_ID_DOMAIN:\n\t\t/*\n\t\t * Don't kfree() until all \"struct cred\"->security forget this\n\t\t * element.\n\t\t */\n\t\tif (atomic_read(&container_of\n\t\t\t\t(element, typeof(struct tomoyo_domain_info),\n\t\t\t\t list)->users))\n\t\t\tgoto reinject;\n\t\tbreak;\n\tcase TOMOYO_MAX_POLICY:\n\t\tbreak;\n\t}\n\tmutex_lock(&tomoyo_policy_lock);\n\tif (type == TOMOYO_ID_DOMAIN)\n\t\ttomoyo_del_domain(element);\n\ttomoyo_memory_free(element);\n\treturn;\nreinject:\n\t/*\n\t * We can safely reinject this element here bacause\n\t * (1) Appending list elements and removing list elements are protected\n\t *     by tomoyo_policy_lock mutex.\n\t * (2) Only this function removes list elements and this function is\n\t *     exclusively executed by tomoyo_gc_mutex mutex.\n\t * are true.\n\t */\n\tmutex_lock(&tomoyo_policy_lock);\n\tlist_add_rcu(element, element->prev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "member",
            "tmp",
            "member_list",
            "list"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_collect_member(const enum tomoyo_policy_id id,\n\t\t\t\t  struct list_head *member_list)\n{\n\tstruct tomoyo_acl_head *member;\n\tstruct tomoyo_acl_head *tmp;\n\tlist_for_each_entry_safe(member, tmp, member_list, list) {\n\t\tif (!member->is_deleted)\n\t\t\tcontinue;\n\t\tmember->is_deleted = TOMOYO_GC_IN_PROGRESS;\n\t\ttomoyo_try_to_gc(id, &member->list);\n\t}\n}"
  },
  {
    "function_name": "tomoyo_try_to_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "375-464",
    "snippet": "static void tomoyo_try_to_gc(const enum tomoyo_policy_id type,\n\t\t\t     struct list_head *element)\n{\n\t/*\n\t * __list_del_entry() guarantees that the list element became no longer\n\t * reachable from the list which the element was originally on (e.g.\n\t * tomoyo_domain_list). Also, synchronize_srcu() guarantees that the\n\t * list element became no longer referenced by syscall users.\n\t */\n\t__list_del_entry(element);\n\tmutex_unlock(&tomoyo_policy_lock);\n\tsynchronize_srcu(&tomoyo_ss);\n\t/*\n\t * However, there are two users which may still be using the list\n\t * element. We need to defer until both users forget this element.\n\t *\n\t * Don't kfree() until \"struct tomoyo_io_buffer\"->r.{domain,group,acl}\n\t * and \"struct tomoyo_io_buffer\"->w.domain forget this element.\n\t */\n\tif (tomoyo_struct_used_by_io_buffer(element))\n\t\tgoto reinject;\n\tswitch (type) {\n\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\ttomoyo_del_transition_control(element);\n\t\tbreak;\n\tcase TOMOYO_ID_MANAGER:\n\t\ttomoyo_del_manager(element);\n\t\tbreak;\n\tcase TOMOYO_ID_AGGREGATOR:\n\t\ttomoyo_del_aggregator(element);\n\t\tbreak;\n\tcase TOMOYO_ID_GROUP:\n\t\ttomoyo_del_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_PATH_GROUP:\n\t\ttomoyo_del_path_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ADDRESS_GROUP:\n\t\ttomoyo_del_address_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NUMBER_GROUP:\n\t\ttomoyo_del_number_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_CONDITION:\n\t\ttomoyo_del_condition(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NAME:\n\t\t/*\n\t\t * Don't kfree() until all \"struct tomoyo_io_buffer\"->r.w[]\n\t\t * forget this element.\n\t\t */\n\t\tif (tomoyo_name_used_by_io_buffer\n\t\t    (container_of(element, typeof(struct tomoyo_name),\n\t\t\t\t  head.list)->entry.name))\n\t\t\tgoto reinject;\n\t\ttomoyo_del_name(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ACL:\n\t\ttomoyo_del_acl(element);\n\t\tbreak;\n\tcase TOMOYO_ID_DOMAIN:\n\t\t/*\n\t\t * Don't kfree() until all \"struct cred\"->security forget this\n\t\t * element.\n\t\t */\n\t\tif (atomic_read(&container_of\n\t\t\t\t(element, typeof(struct tomoyo_domain_info),\n\t\t\t\t list)->users))\n\t\t\tgoto reinject;\n\t\tbreak;\n\tcase TOMOYO_MAX_POLICY:\n\t\tbreak;\n\t}\n\tmutex_lock(&tomoyo_policy_lock);\n\tif (type == TOMOYO_ID_DOMAIN)\n\t\ttomoyo_del_domain(element);\n\ttomoyo_memory_free(element);\n\treturn;\nreinject:\n\t/*\n\t * We can safely reinject this element here bacause\n\t * (1) Appending list elements and removing list elements are protected\n\t *     by tomoyo_policy_lock mutex.\n\t * (2) Only this function removes list elements and this function is\n\t *     exclusively executed by tomoyo_gc_mutex mutex.\n\t * are true.\n\t */\n\tmutex_lock(&tomoyo_policy_lock);\n\tlist_add_rcu(element, element->prev);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_rcu",
          "args": [
            "element",
            "element->prev"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_memory_free",
          "args": [
            "element"
          ],
          "line": 451
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_memory_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "21-25",
          "snippet": "static inline void tomoyo_memory_free(void *ptr)\n{\n\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= ksize(ptr);\n\tkfree(ptr);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_memory_free(void *ptr)\n{\n\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= ksize(ptr);\n\tkfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_del_domain",
          "args": [
            "element"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "244-260",
          "snippet": "static inline void tomoyo_del_domain(struct list_head *element)\n{\n\tstruct tomoyo_domain_info *domain =\n\t\tcontainer_of(element, typeof(*domain), list);\n\tstruct tomoyo_acl_info *acl;\n\tstruct tomoyo_acl_info *tmp;\n\t/*\n\t * Since this domain is referenced from neither\n\t * \"struct tomoyo_io_buffer\" nor \"struct cred\"->security, we can delete\n\t * elements without checking for is_deleted flag.\n\t */\n\tlist_for_each_entry_safe(acl, tmp, &domain->acl_info_list, list) {\n\t\ttomoyo_del_acl(&acl->list);\n\t\ttomoyo_memory_free(acl);\n\t}\n\ttomoyo_put_name(domain->domainname);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_domain(struct list_head *element)\n{\n\tstruct tomoyo_domain_info *domain =\n\t\tcontainer_of(element, typeof(*domain), list);\n\tstruct tomoyo_acl_info *acl;\n\tstruct tomoyo_acl_info *tmp;\n\t/*\n\t * Since this domain is referenced from neither\n\t * \"struct tomoyo_io_buffer\" nor \"struct cred\"->security, we can delete\n\t * elements without checking for is_deleted flag.\n\t */\n\tlist_for_each_entry_safe(acl, tmp, &domain->acl_info_list, list) {\n\t\ttomoyo_del_acl(&acl->list);\n\t\ttomoyo_memory_free(acl);\n\t}\n\ttomoyo_put_name(domain->domainname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&container_of\n\t\t\t\t(element, typeof(struct tomoyo_domain_info),\n\t\t\t\t list)->users"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "element",
            "typeof(struct tomoyo_domain_info)",
            "list"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "structtomoyo_domain_info"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_del_acl",
          "args": [
            "element"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "151-233",
          "snippet": "static void tomoyo_del_acl(struct list_head *element)\n{\n\tstruct tomoyo_acl_info *acl =\n\t\tcontainer_of(element, typeof(*acl), list);\n\ttomoyo_put_condition(acl->cond);\n\tswitch (acl->type) {\n\tcase TOMOYO_TYPE_PATH_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH2_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path2_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name1);\n\t\t\ttomoyo_put_name_union(&entry->name2);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH_NUMBER_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_number_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->number);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MKDEV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mkdev_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->mode);\n\t\t\ttomoyo_put_number_union(&entry->major);\n\t\t\ttomoyo_put_number_union(&entry->minor);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MOUNT_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mount_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->dev_name);\n\t\t\ttomoyo_put_name_union(&entry->dir_name);\n\t\t\ttomoyo_put_name_union(&entry->fs_type);\n\t\t\ttomoyo_put_number_union(&entry->flags);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_ENV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_env_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name(entry->env);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_INET_ACL:\n\t\t{\n\t\t\tstruct tomoyo_inet_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_group(entry->address.group);\n\t\t\ttomoyo_put_number_union(&entry->port);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_UNIX_ACL:\n\t\t{\n\t\t\tstruct tomoyo_unix_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MANUAL_TASK_ACL:\n\t\t{\n\t\t\tstruct tomoyo_task_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name(entry->domainname);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_del_acl(struct list_head *element)\n{\n\tstruct tomoyo_acl_info *acl =\n\t\tcontainer_of(element, typeof(*acl), list);\n\ttomoyo_put_condition(acl->cond);\n\tswitch (acl->type) {\n\tcase TOMOYO_TYPE_PATH_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH2_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path2_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name1);\n\t\t\ttomoyo_put_name_union(&entry->name2);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH_NUMBER_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_number_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->number);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MKDEV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mkdev_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->mode);\n\t\t\ttomoyo_put_number_union(&entry->major);\n\t\t\ttomoyo_put_number_union(&entry->minor);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MOUNT_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mount_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->dev_name);\n\t\t\ttomoyo_put_name_union(&entry->dir_name);\n\t\t\ttomoyo_put_name_union(&entry->fs_type);\n\t\t\ttomoyo_put_number_union(&entry->flags);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_ENV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_env_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name(entry->env);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_INET_ACL:\n\t\t{\n\t\t\tstruct tomoyo_inet_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_group(entry->address.group);\n\t\t\ttomoyo_put_number_union(&entry->port);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_UNIX_ACL:\n\t\t{\n\t\t\tstruct tomoyo_unix_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MANUAL_TASK_ACL:\n\t\t{\n\t\t\tstruct tomoyo_task_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name(entry->domainname);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_del_name",
          "args": [
            "element"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "308-311",
          "snippet": "static inline void tomoyo_del_name(struct list_head *element)\n{\n\t/* Nothing to do. */\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_name(struct list_head *element)\n{\n\t/* Nothing to do. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_name_used_by_io_buffer",
          "args": [
            "container_of(element, typeof(struct tomoyo_name),\n\t\t\t\t  head.list)->entry.name"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_name_used_by_io_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "71-98",
          "snippet": "static bool tomoyo_name_used_by_io_buffer(const char *string)\n{\n\tstruct tomoyo_io_buffer *head;\n\tconst size_t size = strlen(string) + 1;\n\tbool in_use = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tlist_for_each_entry(head, &tomoyo_io_buffer_list, list) {\n\t\tint i;\n\t\thead->users++;\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t\tmutex_lock(&head->io_sem);\n\t\tfor (i = 0; i < TOMOYO_MAX_IO_READ_QUEUE; i++) {\n\t\t\tconst char *w = head->r.w[i];\n\t\t\tif (w < string || w > string + size)\n\t\t\t\tcontinue;\n\t\t\tin_use = true;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&head->io_sem);\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\thead->users--;\n\t\tif (in_use)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\treturn in_use;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(tomoyo_io_buffer_list);",
            "static DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic LIST_HEAD(tomoyo_io_buffer_list);\nstatic DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);\n\nstatic bool tomoyo_name_used_by_io_buffer(const char *string)\n{\n\tstruct tomoyo_io_buffer *head;\n\tconst size_t size = strlen(string) + 1;\n\tbool in_use = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tlist_for_each_entry(head, &tomoyo_io_buffer_list, list) {\n\t\tint i;\n\t\thead->users++;\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t\tmutex_lock(&head->io_sem);\n\t\tfor (i = 0; i < TOMOYO_MAX_IO_READ_QUEUE; i++) {\n\t\t\tconst char *w = head->r.w[i];\n\t\t\tif (w < string || w > string + size)\n\t\t\t\tcontinue;\n\t\t\tin_use = true;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&head->io_sem);\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\thead->users--;\n\t\tif (in_use)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\treturn in_use;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "element",
            "typeof(struct tomoyo_name)",
            "head.list"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "structtomoyo_name"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_del_condition",
          "args": [
            "element"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_condition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "269-299",
          "snippet": "void tomoyo_del_condition(struct list_head *element)\n{\n\tstruct tomoyo_condition *cond = container_of(element, typeof(*cond),\n\t\t\t\t\t\t     head.list);\n\tconst u16 condc = cond->condc;\n\tconst u16 numbers_count = cond->numbers_count;\n\tconst u16 names_count = cond->names_count;\n\tconst u16 argc = cond->argc;\n\tconst u16 envc = cond->envc;\n\tunsigned int i;\n\tconst struct tomoyo_condition_element *condp\n\t\t= (const struct tomoyo_condition_element *) (cond + 1);\n\tstruct tomoyo_number_union *numbers_p\n\t\t= (struct tomoyo_number_union *) (condp + condc);\n\tstruct tomoyo_name_union *names_p\n\t\t= (struct tomoyo_name_union *) (numbers_p + numbers_count);\n\tconst struct tomoyo_argv *argv\n\t\t= (const struct tomoyo_argv *) (names_p + names_count);\n\tconst struct tomoyo_envp *envp\n\t\t= (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < numbers_count; i++)\n\t\ttomoyo_put_number_union(numbers_p++);\n\tfor (i = 0; i < names_count; i++)\n\t\ttomoyo_put_name_union(names_p++);\n\tfor (i = 0; i < argc; argv++, i++)\n\t\ttomoyo_put_name(argv->value);\n\tfor (i = 0; i < envc; envp++, i++) {\n\t\ttomoyo_put_name(envp->name);\n\t\ttomoyo_put_name(envp->value);\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nvoid tomoyo_del_condition(struct list_head *element)\n{\n\tstruct tomoyo_condition *cond = container_of(element, typeof(*cond),\n\t\t\t\t\t\t     head.list);\n\tconst u16 condc = cond->condc;\n\tconst u16 numbers_count = cond->numbers_count;\n\tconst u16 names_count = cond->names_count;\n\tconst u16 argc = cond->argc;\n\tconst u16 envc = cond->envc;\n\tunsigned int i;\n\tconst struct tomoyo_condition_element *condp\n\t\t= (const struct tomoyo_condition_element *) (cond + 1);\n\tstruct tomoyo_number_union *numbers_p\n\t\t= (struct tomoyo_number_union *) (condp + condc);\n\tstruct tomoyo_name_union *names_p\n\t\t= (struct tomoyo_name_union *) (numbers_p + numbers_count);\n\tconst struct tomoyo_argv *argv\n\t\t= (const struct tomoyo_argv *) (names_p + names_count);\n\tconst struct tomoyo_envp *envp\n\t\t= (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < numbers_count; i++)\n\t\ttomoyo_put_number_union(numbers_p++);\n\tfor (i = 0; i < names_count; i++)\n\t\ttomoyo_put_name_union(names_p++);\n\tfor (i = 0; i < argc; argv++, i++)\n\t\ttomoyo_put_name(argv->value);\n\tfor (i = 0; i < envc; envp++, i++) {\n\t\ttomoyo_put_name(envp->name);\n\t\ttomoyo_put_name(envp->value);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_del_number_group",
          "args": [
            "element"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_number_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "360-363",
          "snippet": "static inline void tomoyo_del_number_group(struct list_head *element)\n{\n\t/* Nothing to do. */\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_number_group(struct list_head *element)\n{\n\t/* Nothing to do. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_del_address_group",
          "args": [
            "element"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_address_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "348-351",
          "snippet": "static inline void tomoyo_del_address_group(struct list_head *element)\n{\n\t/* Nothing to do. */\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_address_group(struct list_head *element)\n{\n\t/* Nothing to do. */\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_del_path_group",
          "args": [
            "element"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_path_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "320-325",
          "snippet": "static inline void tomoyo_del_path_group(struct list_head *element)\n{\n\tstruct tomoyo_path_group *member =\n\t\tcontainer_of(element, typeof(*member), head.list);\n\ttomoyo_put_name(member->member_name);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_path_group(struct list_head *element)\n{\n\tstruct tomoyo_path_group *member =\n\t\tcontainer_of(element, typeof(*member), head.list);\n\ttomoyo_put_name(member->member_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_del_group",
          "args": [
            "element"
          ],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "334-339",
          "snippet": "static inline void tomoyo_del_group(struct list_head *element)\n{\n\tstruct tomoyo_group *group =\n\t\tcontainer_of(element, typeof(*group), head.list);\n\ttomoyo_put_name(group->group_name);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_group(struct list_head *element)\n{\n\tstruct tomoyo_group *group =\n\t\tcontainer_of(element, typeof(*group), head.list);\n\ttomoyo_put_name(group->group_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_del_aggregator",
          "args": [
            "element"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_aggregator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "122-128",
          "snippet": "static inline void tomoyo_del_aggregator(struct list_head *element)\n{\n\tstruct tomoyo_aggregator *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\ttomoyo_put_name(ptr->original_name);\n\ttomoyo_put_name(ptr->aggregated_name);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_aggregator(struct list_head *element)\n{\n\tstruct tomoyo_aggregator *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\ttomoyo_put_name(ptr->original_name);\n\ttomoyo_put_name(ptr->aggregated_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_del_manager",
          "args": [
            "element"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "137-142",
          "snippet": "static inline void tomoyo_del_manager(struct list_head *element)\n{\n\tstruct tomoyo_manager *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\ttomoyo_put_name(ptr->manager);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_manager(struct list_head *element)\n{\n\tstruct tomoyo_manager *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\ttomoyo_put_name(ptr->manager);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_del_transition_control",
          "args": [
            "element"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_transition_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "107-113",
          "snippet": "static inline void tomoyo_del_transition_control(struct list_head *element)\n{\n\tstruct tomoyo_transition_control *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\ttomoyo_put_name(ptr->domainname);\n\ttomoyo_put_name(ptr->program);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_transition_control(struct list_head *element)\n{\n\tstruct tomoyo_transition_control *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\ttomoyo_put_name(ptr->domainname);\n\ttomoyo_put_name(ptr->program);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_struct_used_by_io_buffer",
          "args": [
            "element"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_struct_used_by_io_buffer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "40-61",
          "snippet": "static bool tomoyo_struct_used_by_io_buffer(const struct list_head *element)\n{\n\tstruct tomoyo_io_buffer *head;\n\tbool in_use = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tlist_for_each_entry(head, &tomoyo_io_buffer_list, list) {\n\t\thead->users++;\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t\tmutex_lock(&head->io_sem);\n\t\tif (head->r.domain == element || head->r.group == element ||\n\t\t    head->r.acl == element || &head->w.domain->list == element)\n\t\t\tin_use = true;\n\t\tmutex_unlock(&head->io_sem);\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\thead->users--;\n\t\tif (in_use)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\treturn in_use;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(tomoyo_io_buffer_list);",
            "static DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic LIST_HEAD(tomoyo_io_buffer_list);\nstatic DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);\n\nstatic bool tomoyo_struct_used_by_io_buffer(const struct list_head *element)\n{\n\tstruct tomoyo_io_buffer *head;\n\tbool in_use = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tlist_for_each_entry(head, &tomoyo_io_buffer_list, list) {\n\t\thead->users++;\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t\tmutex_lock(&head->io_sem);\n\t\tif (head->r.domain == element || head->r.group == element ||\n\t\t    head->r.acl == element || &head->w.domain->list == element)\n\t\t\tin_use = true;\n\t\tmutex_unlock(&head->io_sem);\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\thead->users--;\n\t\tif (in_use)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\treturn in_use;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_srcu",
          "args": [
            "&tomoyo_ss"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tomoyo_policy_lock"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__list_del_entry",
          "args": [
            "element"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_try_to_gc(const enum tomoyo_policy_id type,\n\t\t\t     struct list_head *element)\n{\n\t/*\n\t * __list_del_entry() guarantees that the list element became no longer\n\t * reachable from the list which the element was originally on (e.g.\n\t * tomoyo_domain_list). Also, synchronize_srcu() guarantees that the\n\t * list element became no longer referenced by syscall users.\n\t */\n\t__list_del_entry(element);\n\tmutex_unlock(&tomoyo_policy_lock);\n\tsynchronize_srcu(&tomoyo_ss);\n\t/*\n\t * However, there are two users which may still be using the list\n\t * element. We need to defer until both users forget this element.\n\t *\n\t * Don't kfree() until \"struct tomoyo_io_buffer\"->r.{domain,group,acl}\n\t * and \"struct tomoyo_io_buffer\"->w.domain forget this element.\n\t */\n\tif (tomoyo_struct_used_by_io_buffer(element))\n\t\tgoto reinject;\n\tswitch (type) {\n\tcase TOMOYO_ID_TRANSITION_CONTROL:\n\t\ttomoyo_del_transition_control(element);\n\t\tbreak;\n\tcase TOMOYO_ID_MANAGER:\n\t\ttomoyo_del_manager(element);\n\t\tbreak;\n\tcase TOMOYO_ID_AGGREGATOR:\n\t\ttomoyo_del_aggregator(element);\n\t\tbreak;\n\tcase TOMOYO_ID_GROUP:\n\t\ttomoyo_del_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_PATH_GROUP:\n\t\ttomoyo_del_path_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ADDRESS_GROUP:\n\t\ttomoyo_del_address_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NUMBER_GROUP:\n\t\ttomoyo_del_number_group(element);\n\t\tbreak;\n\tcase TOMOYO_ID_CONDITION:\n\t\ttomoyo_del_condition(element);\n\t\tbreak;\n\tcase TOMOYO_ID_NAME:\n\t\t/*\n\t\t * Don't kfree() until all \"struct tomoyo_io_buffer\"->r.w[]\n\t\t * forget this element.\n\t\t */\n\t\tif (tomoyo_name_used_by_io_buffer\n\t\t    (container_of(element, typeof(struct tomoyo_name),\n\t\t\t\t  head.list)->entry.name))\n\t\t\tgoto reinject;\n\t\ttomoyo_del_name(element);\n\t\tbreak;\n\tcase TOMOYO_ID_ACL:\n\t\ttomoyo_del_acl(element);\n\t\tbreak;\n\tcase TOMOYO_ID_DOMAIN:\n\t\t/*\n\t\t * Don't kfree() until all \"struct cred\"->security forget this\n\t\t * element.\n\t\t */\n\t\tif (atomic_read(&container_of\n\t\t\t\t(element, typeof(struct tomoyo_domain_info),\n\t\t\t\t list)->users))\n\t\t\tgoto reinject;\n\t\tbreak;\n\tcase TOMOYO_MAX_POLICY:\n\t\tbreak;\n\t}\n\tmutex_lock(&tomoyo_policy_lock);\n\tif (type == TOMOYO_ID_DOMAIN)\n\t\ttomoyo_del_domain(element);\n\ttomoyo_memory_free(element);\n\treturn;\nreinject:\n\t/*\n\t * We can safely reinject this element here bacause\n\t * (1) Appending list elements and removing list elements are protected\n\t *     by tomoyo_policy_lock mutex.\n\t * (2) Only this function removes list elements and this function is\n\t *     exclusively executed by tomoyo_gc_mutex mutex.\n\t * are true.\n\t */\n\tmutex_lock(&tomoyo_policy_lock);\n\tlist_add_rcu(element, element->prev);\n}"
  },
  {
    "function_name": "tomoyo_del_number_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "360-363",
    "snippet": "static inline void tomoyo_del_number_group(struct list_head *element)\n{\n\t/* Nothing to do. */\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_number_group(struct list_head *element)\n{\n\t/* Nothing to do. */\n}"
  },
  {
    "function_name": "tomoyo_del_address_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "348-351",
    "snippet": "static inline void tomoyo_del_address_group(struct list_head *element)\n{\n\t/* Nothing to do. */\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_address_group(struct list_head *element)\n{\n\t/* Nothing to do. */\n}"
  },
  {
    "function_name": "tomoyo_del_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "334-339",
    "snippet": "static inline void tomoyo_del_group(struct list_head *element)\n{\n\tstruct tomoyo_group *group =\n\t\tcontainer_of(element, typeof(*group), head.list);\n\ttomoyo_put_name(group->group_name);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "group->group_name"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "element",
            "typeof(*group)",
            "head.list"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*group"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_group(struct list_head *element)\n{\n\tstruct tomoyo_group *group =\n\t\tcontainer_of(element, typeof(*group), head.list);\n\ttomoyo_put_name(group->group_name);\n}"
  },
  {
    "function_name": "tomoyo_del_path_group",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "320-325",
    "snippet": "static inline void tomoyo_del_path_group(struct list_head *element)\n{\n\tstruct tomoyo_path_group *member =\n\t\tcontainer_of(element, typeof(*member), head.list);\n\ttomoyo_put_name(member->member_name);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "member->member_name"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "element",
            "typeof(*member)",
            "head.list"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*member"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_path_group(struct list_head *element)\n{\n\tstruct tomoyo_path_group *member =\n\t\tcontainer_of(element, typeof(*member), head.list);\n\ttomoyo_put_name(member->member_name);\n}"
  },
  {
    "function_name": "tomoyo_del_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "308-311",
    "snippet": "static inline void tomoyo_del_name(struct list_head *element)\n{\n\t/* Nothing to do. */\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_name(struct list_head *element)\n{\n\t/* Nothing to do. */\n}"
  },
  {
    "function_name": "tomoyo_del_condition",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "269-299",
    "snippet": "void tomoyo_del_condition(struct list_head *element)\n{\n\tstruct tomoyo_condition *cond = container_of(element, typeof(*cond),\n\t\t\t\t\t\t     head.list);\n\tconst u16 condc = cond->condc;\n\tconst u16 numbers_count = cond->numbers_count;\n\tconst u16 names_count = cond->names_count;\n\tconst u16 argc = cond->argc;\n\tconst u16 envc = cond->envc;\n\tunsigned int i;\n\tconst struct tomoyo_condition_element *condp\n\t\t= (const struct tomoyo_condition_element *) (cond + 1);\n\tstruct tomoyo_number_union *numbers_p\n\t\t= (struct tomoyo_number_union *) (condp + condc);\n\tstruct tomoyo_name_union *names_p\n\t\t= (struct tomoyo_name_union *) (numbers_p + numbers_count);\n\tconst struct tomoyo_argv *argv\n\t\t= (const struct tomoyo_argv *) (names_p + names_count);\n\tconst struct tomoyo_envp *envp\n\t\t= (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < numbers_count; i++)\n\t\ttomoyo_put_number_union(numbers_p++);\n\tfor (i = 0; i < names_count; i++)\n\t\ttomoyo_put_name_union(names_p++);\n\tfor (i = 0; i < argc; argv++, i++)\n\t\ttomoyo_put_name(argv->value);\n\tfor (i = 0; i < envc; envp++, i++) {\n\t\ttomoyo_put_name(envp->name);\n\t\ttomoyo_put_name(envp->value);\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "envp->value"
          ],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_put_name_union",
          "args": [
            "names_p++"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "67-71",
          "snippet": "void tomoyo_put_name_union(struct tomoyo_name_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n\ttomoyo_put_name(ptr->filename);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_put_name_union(struct tomoyo_name_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n\ttomoyo_put_name(ptr->filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_put_number_union",
          "args": [
            "numbers_p++"
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_number_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "99-102",
          "snippet": "void tomoyo_put_number_union(struct tomoyo_number_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_put_number_union(struct tomoyo_number_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "element",
            "typeof(*cond)",
            "head.list"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*cond"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nvoid tomoyo_del_condition(struct list_head *element)\n{\n\tstruct tomoyo_condition *cond = container_of(element, typeof(*cond),\n\t\t\t\t\t\t     head.list);\n\tconst u16 condc = cond->condc;\n\tconst u16 numbers_count = cond->numbers_count;\n\tconst u16 names_count = cond->names_count;\n\tconst u16 argc = cond->argc;\n\tconst u16 envc = cond->envc;\n\tunsigned int i;\n\tconst struct tomoyo_condition_element *condp\n\t\t= (const struct tomoyo_condition_element *) (cond + 1);\n\tstruct tomoyo_number_union *numbers_p\n\t\t= (struct tomoyo_number_union *) (condp + condc);\n\tstruct tomoyo_name_union *names_p\n\t\t= (struct tomoyo_name_union *) (numbers_p + numbers_count);\n\tconst struct tomoyo_argv *argv\n\t\t= (const struct tomoyo_argv *) (names_p + names_count);\n\tconst struct tomoyo_envp *envp\n\t\t= (const struct tomoyo_envp *) (argv + argc);\n\tfor (i = 0; i < numbers_count; i++)\n\t\ttomoyo_put_number_union(numbers_p++);\n\tfor (i = 0; i < names_count; i++)\n\t\ttomoyo_put_name_union(names_p++);\n\tfor (i = 0; i < argc; argv++, i++)\n\t\ttomoyo_put_name(argv->value);\n\tfor (i = 0; i < envc; envp++, i++) {\n\t\ttomoyo_put_name(envp->name);\n\t\ttomoyo_put_name(envp->value);\n\t}\n}"
  },
  {
    "function_name": "tomoyo_del_domain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "244-260",
    "snippet": "static inline void tomoyo_del_domain(struct list_head *element)\n{\n\tstruct tomoyo_domain_info *domain =\n\t\tcontainer_of(element, typeof(*domain), list);\n\tstruct tomoyo_acl_info *acl;\n\tstruct tomoyo_acl_info *tmp;\n\t/*\n\t * Since this domain is referenced from neither\n\t * \"struct tomoyo_io_buffer\" nor \"struct cred\"->security, we can delete\n\t * elements without checking for is_deleted flag.\n\t */\n\tlist_for_each_entry_safe(acl, tmp, &domain->acl_info_list, list) {\n\t\ttomoyo_del_acl(&acl->list);\n\t\ttomoyo_memory_free(acl);\n\t}\n\ttomoyo_put_name(domain->domainname);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "domain->domainname"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_memory_free",
          "args": [
            "acl"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_memory_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "21-25",
          "snippet": "static inline void tomoyo_memory_free(void *ptr)\n{\n\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= ksize(ptr);\n\tkfree(ptr);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_memory_free(void *ptr)\n{\n\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= ksize(ptr);\n\tkfree(ptr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_del_acl",
          "args": [
            "&acl->list"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_del_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
          "lines": "151-233",
          "snippet": "static void tomoyo_del_acl(struct list_head *element)\n{\n\tstruct tomoyo_acl_info *acl =\n\t\tcontainer_of(element, typeof(*acl), list);\n\ttomoyo_put_condition(acl->cond);\n\tswitch (acl->type) {\n\tcase TOMOYO_TYPE_PATH_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH2_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path2_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name1);\n\t\t\ttomoyo_put_name_union(&entry->name2);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH_NUMBER_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_number_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->number);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MKDEV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mkdev_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->mode);\n\t\t\ttomoyo_put_number_union(&entry->major);\n\t\t\ttomoyo_put_number_union(&entry->minor);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MOUNT_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mount_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->dev_name);\n\t\t\ttomoyo_put_name_union(&entry->dir_name);\n\t\t\ttomoyo_put_name_union(&entry->fs_type);\n\t\t\ttomoyo_put_number_union(&entry->flags);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_ENV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_env_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name(entry->env);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_INET_ACL:\n\t\t{\n\t\t\tstruct tomoyo_inet_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_group(entry->address.group);\n\t\t\ttomoyo_put_number_union(&entry->port);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_UNIX_ACL:\n\t\t{\n\t\t\tstruct tomoyo_unix_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MANUAL_TASK_ACL:\n\t\t{\n\t\t\tstruct tomoyo_task_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name(entry->domainname);\n\t\t}\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/kthread.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_del_acl(struct list_head *element)\n{\n\tstruct tomoyo_acl_info *acl =\n\t\tcontainer_of(element, typeof(*acl), list);\n\ttomoyo_put_condition(acl->cond);\n\tswitch (acl->type) {\n\tcase TOMOYO_TYPE_PATH_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH2_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path2_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name1);\n\t\t\ttomoyo_put_name_union(&entry->name2);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH_NUMBER_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_number_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->number);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MKDEV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mkdev_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->mode);\n\t\t\ttomoyo_put_number_union(&entry->major);\n\t\t\ttomoyo_put_number_union(&entry->minor);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MOUNT_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mount_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->dev_name);\n\t\t\ttomoyo_put_name_union(&entry->dir_name);\n\t\t\ttomoyo_put_name_union(&entry->fs_type);\n\t\t\ttomoyo_put_number_union(&entry->flags);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_ENV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_env_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name(entry->env);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_INET_ACL:\n\t\t{\n\t\t\tstruct tomoyo_inet_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_group(entry->address.group);\n\t\t\ttomoyo_put_number_union(&entry->port);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_UNIX_ACL:\n\t\t{\n\t\t\tstruct tomoyo_unix_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MANUAL_TASK_ACL:\n\t\t{\n\t\t\tstruct tomoyo_task_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name(entry->domainname);\n\t\t}\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "acl",
            "tmp",
            "&domain->acl_info_list",
            "list"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "element",
            "typeof(*domain)",
            "list"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*domain"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_domain(struct list_head *element)\n{\n\tstruct tomoyo_domain_info *domain =\n\t\tcontainer_of(element, typeof(*domain), list);\n\tstruct tomoyo_acl_info *acl;\n\tstruct tomoyo_acl_info *tmp;\n\t/*\n\t * Since this domain is referenced from neither\n\t * \"struct tomoyo_io_buffer\" nor \"struct cred\"->security, we can delete\n\t * elements without checking for is_deleted flag.\n\t */\n\tlist_for_each_entry_safe(acl, tmp, &domain->acl_info_list, list) {\n\t\ttomoyo_del_acl(&acl->list);\n\t\ttomoyo_memory_free(acl);\n\t}\n\ttomoyo_put_name(domain->domainname);\n}"
  },
  {
    "function_name": "tomoyo_del_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "151-233",
    "snippet": "static void tomoyo_del_acl(struct list_head *element)\n{\n\tstruct tomoyo_acl_info *acl =\n\t\tcontainer_of(element, typeof(*acl), list);\n\ttomoyo_put_condition(acl->cond);\n\tswitch (acl->type) {\n\tcase TOMOYO_TYPE_PATH_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH2_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path2_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name1);\n\t\t\ttomoyo_put_name_union(&entry->name2);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH_NUMBER_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_number_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->number);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MKDEV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mkdev_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->mode);\n\t\t\ttomoyo_put_number_union(&entry->major);\n\t\t\ttomoyo_put_number_union(&entry->minor);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MOUNT_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mount_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->dev_name);\n\t\t\ttomoyo_put_name_union(&entry->dir_name);\n\t\t\ttomoyo_put_name_union(&entry->fs_type);\n\t\t\ttomoyo_put_number_union(&entry->flags);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_ENV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_env_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name(entry->env);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_INET_ACL:\n\t\t{\n\t\t\tstruct tomoyo_inet_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_group(entry->address.group);\n\t\t\ttomoyo_put_number_union(&entry->port);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_UNIX_ACL:\n\t\t{\n\t\t\tstruct tomoyo_unix_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MANUAL_TASK_ACL:\n\t\t{\n\t\t\tstruct tomoyo_task_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name(entry->domainname);\n\t\t}\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "entry->domainname"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*entry)",
            "head"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*entry"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_put_name_union",
          "args": [
            "&entry->name"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "67-71",
          "snippet": "void tomoyo_put_name_union(struct tomoyo_name_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n\ttomoyo_put_name(ptr->filename);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_put_name_union(struct tomoyo_name_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n\ttomoyo_put_name(ptr->filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*entry)",
            "head"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*entry"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_put_number_union",
          "args": [
            "&entry->port"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_number_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "99-102",
          "snippet": "void tomoyo_put_number_union(struct tomoyo_number_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_put_number_union(struct tomoyo_number_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_put_group",
          "args": [
            "entry->address.group"
          ],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1193-1197",
          "snippet": "static inline void tomoyo_put_group(struct tomoyo_group *group)\n{\n\tif (group)\n\t\tatomic_dec(&group->head.users);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_group(struct tomoyo_group *group)\n{\n\tif (group)\n\t\tatomic_dec(&group->head.users);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*entry)",
            "head"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*entry"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*entry)",
            "head"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*entry"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*entry)",
            "head"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*entry"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*entry)",
            "head"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*entry"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*entry)",
            "head"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*entry"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*entry)",
            "head"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*entry"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "acl",
            "typeof(*entry)",
            "head"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*entry"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_put_condition",
          "args": [
            "acl->cond"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_condition",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1180-1184",
          "snippet": "static inline void tomoyo_put_condition(struct tomoyo_condition *cond)\n{\n\tif (cond)\n\t\tatomic_dec(&cond->head.users);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_condition(struct tomoyo_condition *cond)\n{\n\tif (cond)\n\t\tatomic_dec(&cond->head.users);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "element",
            "typeof(*acl)",
            "list"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*acl"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic void tomoyo_del_acl(struct list_head *element)\n{\n\tstruct tomoyo_acl_info *acl =\n\t\tcontainer_of(element, typeof(*acl), list);\n\ttomoyo_put_condition(acl->cond);\n\tswitch (acl->type) {\n\tcase TOMOYO_TYPE_PATH_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH2_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path2_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name1);\n\t\t\ttomoyo_put_name_union(&entry->name2);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_PATH_NUMBER_ACL:\n\t\t{\n\t\t\tstruct tomoyo_path_number_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->number);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MKDEV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mkdev_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t\ttomoyo_put_number_union(&entry->mode);\n\t\t\ttomoyo_put_number_union(&entry->major);\n\t\t\ttomoyo_put_number_union(&entry->minor);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MOUNT_ACL:\n\t\t{\n\t\t\tstruct tomoyo_mount_acl *entry\n\t\t\t\t= container_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name_union(&entry->dev_name);\n\t\t\ttomoyo_put_name_union(&entry->dir_name);\n\t\t\ttomoyo_put_name_union(&entry->fs_type);\n\t\t\ttomoyo_put_number_union(&entry->flags);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_ENV_ACL:\n\t\t{\n\t\t\tstruct tomoyo_env_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name(entry->env);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_INET_ACL:\n\t\t{\n\t\t\tstruct tomoyo_inet_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_group(entry->address.group);\n\t\t\ttomoyo_put_number_union(&entry->port);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_UNIX_ACL:\n\t\t{\n\t\t\tstruct tomoyo_unix_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\n\t\t\ttomoyo_put_name_union(&entry->name);\n\t\t}\n\t\tbreak;\n\tcase TOMOYO_TYPE_MANUAL_TASK_ACL:\n\t\t{\n\t\t\tstruct tomoyo_task_acl *entry =\n\t\t\t\tcontainer_of(acl, typeof(*entry), head);\n\t\t\ttomoyo_put_name(entry->domainname);\n\t\t}\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "tomoyo_del_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "137-142",
    "snippet": "static inline void tomoyo_del_manager(struct list_head *element)\n{\n\tstruct tomoyo_manager *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\ttomoyo_put_name(ptr->manager);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "ptr->manager"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "element",
            "typeof(*ptr)",
            "head.list"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_manager(struct list_head *element)\n{\n\tstruct tomoyo_manager *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\ttomoyo_put_name(ptr->manager);\n}"
  },
  {
    "function_name": "tomoyo_del_aggregator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "122-128",
    "snippet": "static inline void tomoyo_del_aggregator(struct list_head *element)\n{\n\tstruct tomoyo_aggregator *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\ttomoyo_put_name(ptr->original_name);\n\ttomoyo_put_name(ptr->aggregated_name);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "ptr->aggregated_name"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "element",
            "typeof(*ptr)",
            "head.list"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_aggregator(struct list_head *element)\n{\n\tstruct tomoyo_aggregator *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\ttomoyo_put_name(ptr->original_name);\n\ttomoyo_put_name(ptr->aggregated_name);\n}"
  },
  {
    "function_name": "tomoyo_del_transition_control",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "107-113",
    "snippet": "static inline void tomoyo_del_transition_control(struct list_head *element)\n{\n\tstruct tomoyo_transition_control *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\ttomoyo_put_name(ptr->domainname);\n\ttomoyo_put_name(ptr->program);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name",
          "args": [
            "ptr->program"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1164-1171",
          "snippet": "static inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_name(const struct tomoyo_path_info *name)\n{\n\tif (name) {\n\t\tstruct tomoyo_name *ptr =\n\t\t\tcontainer_of(name, typeof(*ptr), entry);\n\t\tatomic_dec(&ptr->head.users);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "element",
            "typeof(*ptr)",
            "head.list"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*ptr"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_del_transition_control(struct list_head *element)\n{\n\tstruct tomoyo_transition_control *ptr =\n\t\tcontainer_of(element, typeof(*ptr), head.list);\n\ttomoyo_put_name(ptr->domainname);\n\ttomoyo_put_name(ptr->program);\n}"
  },
  {
    "function_name": "tomoyo_name_used_by_io_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "71-98",
    "snippet": "static bool tomoyo_name_used_by_io_buffer(const char *string)\n{\n\tstruct tomoyo_io_buffer *head;\n\tconst size_t size = strlen(string) + 1;\n\tbool in_use = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tlist_for_each_entry(head, &tomoyo_io_buffer_list, list) {\n\t\tint i;\n\t\thead->users++;\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t\tmutex_lock(&head->io_sem);\n\t\tfor (i = 0; i < TOMOYO_MAX_IO_READ_QUEUE; i++) {\n\t\t\tconst char *w = head->r.w[i];\n\t\t\tif (w < string || w > string + size)\n\t\t\t\tcontinue;\n\t\t\tin_use = true;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&head->io_sem);\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\thead->users--;\n\t\tif (in_use)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\treturn in_use;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tomoyo_io_buffer_list);",
      "static DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_io_buffer_list_lock"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_io_buffer_list_lock"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&head->io_sem"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&head->io_sem"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_io_buffer_list_lock"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "head",
            "&tomoyo_io_buffer_list",
            "list"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_io_buffer_list_lock"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "string"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic LIST_HEAD(tomoyo_io_buffer_list);\nstatic DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);\n\nstatic bool tomoyo_name_used_by_io_buffer(const char *string)\n{\n\tstruct tomoyo_io_buffer *head;\n\tconst size_t size = strlen(string) + 1;\n\tbool in_use = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tlist_for_each_entry(head, &tomoyo_io_buffer_list, list) {\n\t\tint i;\n\t\thead->users++;\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t\tmutex_lock(&head->io_sem);\n\t\tfor (i = 0; i < TOMOYO_MAX_IO_READ_QUEUE; i++) {\n\t\t\tconst char *w = head->r.w[i];\n\t\t\tif (w < string || w > string + size)\n\t\t\t\tcontinue;\n\t\t\tin_use = true;\n\t\t\tbreak;\n\t\t}\n\t\tmutex_unlock(&head->io_sem);\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\thead->users--;\n\t\tif (in_use)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\treturn in_use;\n}"
  },
  {
    "function_name": "tomoyo_struct_used_by_io_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "40-61",
    "snippet": "static bool tomoyo_struct_used_by_io_buffer(const struct list_head *element)\n{\n\tstruct tomoyo_io_buffer *head;\n\tbool in_use = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tlist_for_each_entry(head, &tomoyo_io_buffer_list, list) {\n\t\thead->users++;\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t\tmutex_lock(&head->io_sem);\n\t\tif (head->r.domain == element || head->r.group == element ||\n\t\t    head->r.acl == element || &head->w.domain->list == element)\n\t\t\tin_use = true;\n\t\tmutex_unlock(&head->io_sem);\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\thead->users--;\n\t\tif (in_use)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\treturn in_use;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(tomoyo_io_buffer_list);",
      "static DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_io_buffer_list_lock"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_io_buffer_list_lock"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&head->io_sem"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&head->io_sem"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tomoyo_io_buffer_list_lock"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "head",
            "&tomoyo_io_buffer_list",
            "list"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tomoyo_io_buffer_list_lock"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic LIST_HEAD(tomoyo_io_buffer_list);\nstatic DEFINE_SPINLOCK(tomoyo_io_buffer_list_lock);\n\nstatic bool tomoyo_struct_used_by_io_buffer(const struct list_head *element)\n{\n\tstruct tomoyo_io_buffer *head;\n\tbool in_use = false;\n\n\tspin_lock(&tomoyo_io_buffer_list_lock);\n\tlist_for_each_entry(head, &tomoyo_io_buffer_list, list) {\n\t\thead->users++;\n\t\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\t\tmutex_lock(&head->io_sem);\n\t\tif (head->r.domain == element || head->r.group == element ||\n\t\t    head->r.acl == element || &head->w.domain->list == element)\n\t\t\tin_use = true;\n\t\tmutex_unlock(&head->io_sem);\n\t\tspin_lock(&tomoyo_io_buffer_list_lock);\n\t\thead->users--;\n\t\tif (in_use)\n\t\t\tbreak;\n\t}\n\tspin_unlock(&tomoyo_io_buffer_list_lock);\n\treturn in_use;\n}"
  },
  {
    "function_name": "tomoyo_memory_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/gc.c",
    "lines": "21-25",
    "snippet": "static inline void tomoyo_memory_free(void *ptr)\n{\n\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= ksize(ptr);\n\tkfree(ptr);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include <linux/kthread.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ptr"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ksize",
          "args": [
            "ptr"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include <linux/kthread.h>\n#include \"common.h\"\n\nstatic inline void tomoyo_memory_free(void *ptr)\n{\n\ttomoyo_memory_used[TOMOYO_MEMORY_POLICY] -= ksize(ptr);\n\tkfree(ptr);\n}"
  }
]