[
  {
    "function_name": "ebitmap_cache_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
    "lines": "533-536",
    "snippet": "void ebitmap_cache_destroy(void)\n{\n\tkmem_cache_destroy(ebitmap_node_cachep);\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"ebitmap.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ebitmap_node_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "ebitmap_node_cachep"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_cache_destroy(void)\n{\n\tkmem_cache_destroy(ebitmap_node_cachep);\n}"
  },
  {
    "function_name": "ebitmap_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
    "lines": "526-531",
    "snippet": "void ebitmap_cache_init(void)\n{\n\tebitmap_node_cachep = kmem_cache_create(\"ebitmap_node\",\n\t\t\t\t\t\t\tsizeof(struct ebitmap_node),\n\t\t\t\t\t\t\t0, SLAB_PANIC, NULL);\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"ebitmap.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ebitmap_node_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"ebitmap_node\"",
            "sizeof(struct ebitmap_node)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_cache_init(void)\n{\n\tebitmap_node_cachep = kmem_cache_create(\"ebitmap_node\",\n\t\t\t\t\t\t\tsizeof(struct ebitmap_node),\n\t\t\t\t\t\t\t0, SLAB_PANIC, NULL);\n}"
  },
  {
    "function_name": "ebitmap_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
    "lines": "451-524",
    "snippet": "int ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"ebitmap.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BITS_PER_U64\t(sizeof(u64) * 8)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf64",
            "sizeof(u64)",
            "1",
            "fp"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "map"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "last_startbit"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "bit",
            "BITS_PER_U64"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "map"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "last_startbit"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "bit",
            "BITS_PER_U64"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "bit",
            "(int)BITS_PER_U64"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "e",
            "n",
            "bit"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "count"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "last_bit"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup",
          "args": [
            "bit + 1",
            "BITS_PER_U64"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "bit",
            "BITS_PER_U64"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rounddown",
          "args": [
            "bit",
            "(int)BITS_PER_U64"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_for_each_positive_bit",
          "args": [
            "e",
            "n",
            "bit"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "BITS_PER_U64"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nint ebitmap_write(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n;\n\tu32 count;\n\t__le32 buf[3];\n\tu64 map;\n\tint bit, last_bit, last_startbit, rc;\n\n\tbuf[0] = cpu_to_le32(BITS_PER_U64);\n\n\tcount = 0;\n\tlast_bit = 0;\n\tlast_startbit = -1;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\tcount++;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tlast_bit = roundup(bit + 1, BITS_PER_U64);\n\t}\n\tbuf[1] = cpu_to_le32(last_bit);\n\tbuf[2] = cpu_to_le32(count);\n\n\trc = put_entry(buf, sizeof(u32), 3, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tmap = 0;\n\tlast_startbit = INT_MIN;\n\tebitmap_for_each_positive_bit(e, n, bit) {\n\t\tif (rounddown(bit, (int)BITS_PER_U64) > last_startbit) {\n\t\t\t__le64 buf64[1];\n\n\t\t\t/* this is the very first bit */\n\t\t\tif (!map) {\n\t\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t\t\tmap = (u64)1 << (bit - last_startbit);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* write the last node */\n\t\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\tbuf64[0] = cpu_to_le64(map);\n\t\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\n\t\t\t/* set up for the next node */\n\t\t\tmap = 0;\n\t\t\tlast_startbit = rounddown(bit, BITS_PER_U64);\n\t\t}\n\t\tmap |= (u64)1 << (bit - last_startbit);\n\t}\n\t/* write the last node */\n\tif (map) {\n\t\t__le64 buf64[1];\n\n\t\t/* write the last node */\n\t\tbuf[0] = cpu_to_le32(last_startbit);\n\t\trc = put_entry(buf, sizeof(u32), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\n\t\tbuf64[0] = cpu_to_le64(map);\n\t\trc = put_entry(buf64, sizeof(u64), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "ebitmap_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
    "lines": "346-449",
    "snippet": "int ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"ebitmap.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define BITS_PER_U64\t(sizeof(u64) * 8)"
    ],
    "globals_used": [
      "static struct kmem_cache *ebitmap_node_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "e"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EBITMAP_SHIFT_UNIT_SIZE",
          "args": [
            "map"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "map"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: ebitmap: truncated map\\n\""
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "&map",
            "fp",
            "sizeof(u64)"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\"",
            "startbit",
            "n->startbit"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "ebitmap_node_cachep",
            "GFP_KERNEL"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\"",
            "startbit",
            "(e->highbit - mapunit)"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\"",
            "startbit",
            "mapunit"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "startbit"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: ebitmap: truncated map\\n\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\"",
            "mapunit",
            "BITS_PER_U64",
            "e->highbit"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_xprintk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1764-1785",
          "snippet": "void aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_xprintk(struct aa_ns *ns, struct aa_label *label, int flags,\n\t\t      gfp_t gfp)\n{\n\tAA_BUG(!label);\n\n\tif (!use_label_hname(ns, label, flags)) {\n\t\tchar *str;\n\t\tint len;\n\n\t\tlen = aa_label_asxprint(&str, ns, label, flags, gfp);\n\t\tif (len == -1) {\n\t\t\tAA_DEBUG(\"label print error\");\n\t\t\treturn;\n\t\t}\n\t\tpr_info(\"%s\", str);\n\t\tkfree(str);\n\t} else if (display_mode(ns, label, flags))\n\t\tpr_info(\"%s (%s)\", label->hname,\n\t\t       label_modename(ns, label, flags));\n\telse\n\t\tpr_info(\"%s\", label->hname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[2]"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[1]"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_init",
          "args": [
            "e"
          ],
          "line": 354
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.h",
          "lines": "60-63",
          "snippet": "static inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}",
          "includes": [
            "#include <net/netlabel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/netlabel.h>\n\nstatic inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\n#define BITS_PER_U64\t(sizeof(u64) * 8)\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_read(struct ebitmap *e, void *fp)\n{\n\tstruct ebitmap_node *n = NULL;\n\tu32 mapunit, count, startbit, index;\n\tu64 map;\n\t__le32 buf[3];\n\tint rc, i;\n\n\tebitmap_init(e);\n\n\trc = next_entry(buf, fp, sizeof buf);\n\tif (rc < 0)\n\t\tgoto out;\n\n\tmapunit = le32_to_cpu(buf[0]);\n\te->highbit = le32_to_cpu(buf[1]);\n\tcount = le32_to_cpu(buf[2]);\n\n\tif (mapunit != BITS_PER_U64) {\n\t\tprintk(KERN_ERR \"SELinux: ebitmap: map size %u does not \"\n\t\t       \"match my size %zd (high bit was %d)\\n\",\n\t\t       mapunit, BITS_PER_U64, e->highbit);\n\t\tgoto bad;\n\t}\n\n\t/* round up e->highbit */\n\te->highbit += EBITMAP_SIZE - 1;\n\te->highbit -= (e->highbit % EBITMAP_SIZE);\n\n\tif (!e->highbit) {\n\t\te->node = NULL;\n\t\tgoto ok;\n\t}\n\n\tif (e->highbit && !count)\n\t\tgoto bad;\n\n\tfor (i = 0; i < count; i++) {\n\t\trc = next_entry(&startbit, fp, sizeof(u32));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tstartbit = le32_to_cpu(startbit);\n\n\t\tif (startbit & (mapunit - 1)) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"not a multiple of the map unit size (%u)\\n\",\n\t\t\t       startbit, mapunit);\n\t\t\tgoto bad;\n\t\t}\n\t\tif (startbit > e->highbit - mapunit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap start bit (%d) is \"\n\t\t\t       \"beyond the end of the bitmap (%u)\\n\",\n\t\t\t       startbit, (e->highbit - mapunit));\n\t\t\tgoto bad;\n\t\t}\n\n\t\tif (!n || startbit >= n->startbit + EBITMAP_SIZE) {\n\t\t\tstruct ebitmap_node *tmp;\n\t\t\ttmp = kmem_cache_zalloc(ebitmap_node_cachep, GFP_KERNEL);\n\t\t\tif (!tmp) {\n\t\t\t\tprintk(KERN_ERR\n\t\t\t\t       \"SELinux: ebitmap: out of memory\\n\");\n\t\t\t\trc = -ENOMEM;\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\t/* round down */\n\t\t\ttmp->startbit = startbit - (startbit % EBITMAP_SIZE);\n\t\t\tif (n)\n\t\t\t\tn->next = tmp;\n\t\t\telse\n\t\t\t\te->node = tmp;\n\t\t\tn = tmp;\n\t\t} else if (startbit <= n->startbit) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: start bit %d\"\n\t\t\t       \" comes after start bit %d\\n\",\n\t\t\t       startbit, n->startbit);\n\t\t\tgoto bad;\n\t\t}\n\n\t\trc = next_entry(&map, fp, sizeof(u64));\n\t\tif (rc < 0) {\n\t\t\tprintk(KERN_ERR \"SELinux: ebitmap: truncated map\\n\");\n\t\t\tgoto bad;\n\t\t}\n\t\tmap = le64_to_cpu(map);\n\n\t\tindex = (startbit - n->startbit) / EBITMAP_UNIT_SIZE;\n\t\twhile (map) {\n\t\t\tn->maps[index++] = map & (-1UL);\n\t\t\tmap = EBITMAP_SHIFT_UNIT_SIZE(map);\n\t\t}\n\t}\nok:\n\trc = 0;\nout:\n\treturn rc;\nbad:\n\tif (!rc)\n\t\trc = -EINVAL;\n\tebitmap_destroy(e);\n\tgoto out;\n}"
  },
  {
    "function_name": "ebitmap_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
    "lines": "327-344",
    "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"ebitmap.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ebitmap_node_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ebitmap_node_cachep",
            "temp"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
  },
  {
    "function_name": "ebitmap_set_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
    "lines": "259-325",
    "snippet": "int ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* drop this node from the bitmap */\n\t\t\t\tif (!n->next) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this was the highest map\n\t\t\t\t\t * within the bitmap\n\t\t\t\t\t */\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t/* this node will be the highest map within the bitmap */\n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"ebitmap.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ebitmap_node_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_node_set_bit",
          "args": [
            "new",
            "bit"
          ],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_node_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.h",
          "lines": "100-108",
          "snippet": "static inline void ebitmap_node_set_bit(struct ebitmap_node *n,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tn->maps[index] |= (EBITMAP_BIT << ofs);\n}",
          "includes": [
            "#include <net/netlabel.h>"
          ],
          "macros_used": [
            "#define EBITMAP_BIT\t\t1ULL",
            "#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/netlabel.h>\n\n#define EBITMAP_BIT\t\t1ULL\n#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))\n\nstatic inline void ebitmap_node_set_bit(struct ebitmap_node *n,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tn->maps[index] |= (EBITMAP_BIT << ofs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "ebitmap_node_cachep",
            "GFP_ATOMIC"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "ebitmap_node_cachep",
            "n"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_first_bit",
          "args": [
            "n->maps",
            "EBITMAP_SIZE"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_node_clr_bit",
          "args": [
            "n",
            "bit"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_node_clr_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.h",
          "lines": "110-118",
          "snippet": "static inline void ebitmap_node_clr_bit(struct ebitmap_node *n,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tn->maps[index] &= ~(EBITMAP_BIT << ofs);\n}",
          "includes": [
            "#include <net/netlabel.h>"
          ],
          "macros_used": [
            "#define EBITMAP_BIT\t\t1ULL",
            "#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/netlabel.h>\n\n#define EBITMAP_BIT\t\t1ULL\n#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))\n\nstatic inline void ebitmap_node_clr_bit(struct ebitmap_node *n,\n\t\t\t\t\tunsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tn->maps[index] &= ~(EBITMAP_BIT << ofs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* drop this node from the bitmap */\n\t\t\t\tif (!n->next) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this was the highest map\n\t\t\t\t\t * within the bitmap\n\t\t\t\t\t */\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t/* this node will be the highest map within the bitmap */\n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ebitmap_get_bit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
    "lines": "242-257",
    "snippet": "int ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"ebitmap.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_node_get_bit",
          "args": [
            "n",
            "bit"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_node_get_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.h",
          "lines": "88-98",
          "snippet": "static inline int ebitmap_node_get_bit(struct ebitmap_node *n,\n\t\t\t\t       unsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tif ((n->maps[index] & (EBITMAP_BIT << ofs)))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include <net/netlabel.h>"
          ],
          "macros_used": [
            "#define EBITMAP_BIT\t\t1ULL",
            "#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/netlabel.h>\n\n#define EBITMAP_BIT\t\t1ULL\n#define EBITMAP_UNIT_NUMS\t((EBITMAP_NODE_SIZE-sizeof(void *)-sizeof(u32))\\\n\t\t\t\t\t/ sizeof(unsigned long))\n\nstatic inline int ebitmap_node_get_bit(struct ebitmap_node *n,\n\t\t\t\t       unsigned int bit)\n{\n\tunsigned int index = EBITMAP_NODE_INDEX(n, bit);\n\tunsigned int ofs = EBITMAP_NODE_OFFSET(n, bit);\n\n\tBUG_ON(index >= EBITMAP_UNIT_NUMS);\n\tif ((n->maps[index] & (EBITMAP_BIT << ofs)))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_get_bit(struct ebitmap *e, unsigned long bit)\n{\n\tstruct ebitmap_node *n;\n\n\tif (e->highbit < bit)\n\t\treturn 0;\n\n\tn = e->node;\n\twhile (n && (n->startbit <= bit)) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit)\n\t\t\treturn ebitmap_node_get_bit(n, bit);\n\t\tn = n->next;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "ebitmap_contains",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
    "lines": "201-240",
    "snippet": "int ebitmap_contains(struct ebitmap *e1, struct ebitmap *e2, u32 last_e2bit)\n{\n\tstruct ebitmap_node *n1, *n2;\n\tint i;\n\n\tif (e1->highbit < e2->highbit)\n\t\treturn 0;\n\n\tn1 = e1->node;\n\tn2 = e2->node;\n\n\twhile (n1 && n2 && (n1->startbit <= n2->startbit)) {\n\t\tif (n1->startbit < n2->startbit) {\n\t\t\tn1 = n1->next;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = EBITMAP_UNIT_NUMS - 1; (i >= 0) && !n2->maps[i]; )\n\t\t\ti--;\t/* Skip trailing NULL map entries */\n\t\tif (last_e2bit && (i >= 0)) {\n\t\t\tu32 lastsetbit = n2->startbit + i * EBITMAP_UNIT_SIZE +\n\t\t\t\t\t __fls(n2->maps[i]);\n\t\t\tif (lastsetbit > last_e2bit)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\twhile (i >= 0) {\n\t\t\tif ((n1->maps[i] & n2->maps[i]) != n2->maps[i])\n\t\t\t\treturn 0;\n\t\t\ti--;\n\t\t}\n\n\t\tn1 = n1->next;\n\t\tn2 = n2->next;\n\t}\n\n\tif (n2)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"ebitmap.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__fls",
          "args": [
            "n2->maps[i]"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_contains(struct ebitmap *e1, struct ebitmap *e2, u32 last_e2bit)\n{\n\tstruct ebitmap_node *n1, *n2;\n\tint i;\n\n\tif (e1->highbit < e2->highbit)\n\t\treturn 0;\n\n\tn1 = e1->node;\n\tn2 = e2->node;\n\n\twhile (n1 && n2 && (n1->startbit <= n2->startbit)) {\n\t\tif (n1->startbit < n2->startbit) {\n\t\t\tn1 = n1->next;\n\t\t\tcontinue;\n\t\t}\n\t\tfor (i = EBITMAP_UNIT_NUMS - 1; (i >= 0) && !n2->maps[i]; )\n\t\t\ti--;\t/* Skip trailing NULL map entries */\n\t\tif (last_e2bit && (i >= 0)) {\n\t\t\tu32 lastsetbit = n2->startbit + i * EBITMAP_UNIT_SIZE +\n\t\t\t\t\t __fls(n2->maps[i]);\n\t\t\tif (lastsetbit > last_e2bit)\n\t\t\t\treturn 0;\n\t\t}\n\n\t\twhile (i >= 0) {\n\t\t\tif ((n1->maps[i] & n2->maps[i]) != n2->maps[i])\n\t\t\t\treturn 0;\n\t\t\ti--;\n\t\t}\n\n\t\tn1 = n1->next;\n\t\tn2 = n2->next;\n\t}\n\n\tif (n2)\n\t\treturn 0;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ebitmap_netlbl_import",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
    "lines": "143-193",
    "snippet": "int ebitmap_netlbl_import(struct ebitmap *ebmap,\n\t\t\t  struct netlbl_lsm_catmap *catmap)\n{\n\tint rc;\n\tstruct ebitmap_node *e_iter = NULL;\n\tstruct ebitmap_node *e_prev = NULL;\n\tu32 offset = 0, idx;\n\tunsigned long bitmap;\n\n\tfor (;;) {\n\t\trc = netlbl_catmap_getlong(catmap, &offset, &bitmap);\n\t\tif (rc < 0)\n\t\t\tgoto netlbl_import_failure;\n\t\tif (offset == (u32)-1)\n\t\t\treturn 0;\n\n\t\t/* don't waste ebitmap space if the netlabel bitmap is empty */\n\t\tif (bitmap == 0) {\n\t\t\toffset += EBITMAP_UNIT_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (e_iter == NULL ||\n\t\t    offset >= e_iter->startbit + EBITMAP_SIZE) {\n\t\t\te_prev = e_iter;\n\t\t\te_iter = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\t\tif (e_iter == NULL)\n\t\t\t\tgoto netlbl_import_failure;\n\t\t\te_iter->startbit = offset - (offset % EBITMAP_SIZE);\n\t\t\tif (e_prev == NULL)\n\t\t\t\tebmap->node = e_iter;\n\t\t\telse\n\t\t\t\te_prev->next = e_iter;\n\t\t\tebmap->highbit = e_iter->startbit + EBITMAP_SIZE;\n\t\t}\n\n\t\t/* offset will always be aligned to an unsigned long */\n\t\tidx = EBITMAP_NODE_INDEX(e_iter, offset);\n\t\te_iter->maps[idx] = bitmap;\n\n\t\t/* next */\n\t\toffset += EBITMAP_UNIT_SIZE;\n\t}\n\n\t/* NOTE: we should never reach this return */\n\treturn 0;\n\nnetlbl_import_failure:\n\tebitmap_destroy(ebmap);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"ebitmap.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ebitmap_node_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "ebmap"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "EBITMAP_NODE_INDEX",
          "args": [
            "e_iter",
            "offset"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "ebitmap_node_cachep",
            "GFP_ATOMIC"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_catmap_getlong",
          "args": [
            "catmap",
            "&offset",
            "&bitmap"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_netlbl_import(struct ebitmap *ebmap,\n\t\t\t  struct netlbl_lsm_catmap *catmap)\n{\n\tint rc;\n\tstruct ebitmap_node *e_iter = NULL;\n\tstruct ebitmap_node *e_prev = NULL;\n\tu32 offset = 0, idx;\n\tunsigned long bitmap;\n\n\tfor (;;) {\n\t\trc = netlbl_catmap_getlong(catmap, &offset, &bitmap);\n\t\tif (rc < 0)\n\t\t\tgoto netlbl_import_failure;\n\t\tif (offset == (u32)-1)\n\t\t\treturn 0;\n\n\t\t/* don't waste ebitmap space if the netlabel bitmap is empty */\n\t\tif (bitmap == 0) {\n\t\t\toffset += EBITMAP_UNIT_SIZE;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (e_iter == NULL ||\n\t\t    offset >= e_iter->startbit + EBITMAP_SIZE) {\n\t\t\te_prev = e_iter;\n\t\t\te_iter = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\t\tif (e_iter == NULL)\n\t\t\t\tgoto netlbl_import_failure;\n\t\t\te_iter->startbit = offset - (offset % EBITMAP_SIZE);\n\t\t\tif (e_prev == NULL)\n\t\t\t\tebmap->node = e_iter;\n\t\t\telse\n\t\t\t\te_prev->next = e_iter;\n\t\t\tebmap->highbit = e_iter->startbit + EBITMAP_SIZE;\n\t\t}\n\n\t\t/* offset will always be aligned to an unsigned long */\n\t\tidx = EBITMAP_NODE_INDEX(e_iter, offset);\n\t\te_iter->maps[idx] = bitmap;\n\n\t\t/* next */\n\t\toffset += EBITMAP_UNIT_SIZE;\n\t}\n\n\t/* NOTE: we should never reach this return */\n\treturn 0;\n\nnetlbl_import_failure:\n\tebitmap_destroy(ebmap);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "ebitmap_netlbl_export",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
    "lines": "91-131",
    "snippet": "int ebitmap_netlbl_export(struct ebitmap *ebmap,\n\t\t\t  struct netlbl_lsm_catmap **catmap)\n{\n\tstruct ebitmap_node *e_iter = ebmap->node;\n\tunsigned long e_map;\n\tu32 offset;\n\tunsigned int iter;\n\tint rc;\n\n\tif (e_iter == NULL) {\n\t\t*catmap = NULL;\n\t\treturn 0;\n\t}\n\n\tif (*catmap != NULL)\n\t\tnetlbl_catmap_free(*catmap);\n\t*catmap = NULL;\n\n\twhile (e_iter) {\n\t\toffset = e_iter->startbit;\n\t\tfor (iter = 0; iter < EBITMAP_UNIT_NUMS; iter++) {\n\t\t\te_map = e_iter->maps[iter];\n\t\t\tif (e_map != 0) {\n\t\t\t\trc = netlbl_catmap_setlong(catmap,\n\t\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t\t   e_map,\n\t\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto netlbl_export_failure;\n\t\t\t}\n\t\t\toffset += EBITMAP_UNIT_SIZE;\n\t\t}\n\t\te_iter = e_iter->next;\n\t}\n\n\treturn 0;\n\nnetlbl_export_failure:\n\tnetlbl_catmap_free(*catmap);\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"ebitmap.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_catmap_free",
          "args": [
            "*catmap"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_catmap_setlong",
          "args": [
            "catmap",
            "offset",
            "e_map",
            "GFP_ATOMIC"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_catmap_free",
          "args": [
            "*catmap"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_netlbl_export(struct ebitmap *ebmap,\n\t\t\t  struct netlbl_lsm_catmap **catmap)\n{\n\tstruct ebitmap_node *e_iter = ebmap->node;\n\tunsigned long e_map;\n\tu32 offset;\n\tunsigned int iter;\n\tint rc;\n\n\tif (e_iter == NULL) {\n\t\t*catmap = NULL;\n\t\treturn 0;\n\t}\n\n\tif (*catmap != NULL)\n\t\tnetlbl_catmap_free(*catmap);\n\t*catmap = NULL;\n\n\twhile (e_iter) {\n\t\toffset = e_iter->startbit;\n\t\tfor (iter = 0; iter < EBITMAP_UNIT_NUMS; iter++) {\n\t\t\te_map = e_iter->maps[iter];\n\t\t\tif (e_map != 0) {\n\t\t\t\trc = netlbl_catmap_setlong(catmap,\n\t\t\t\t\t\t\t   offset,\n\t\t\t\t\t\t\t   e_map,\n\t\t\t\t\t\t\t   GFP_ATOMIC);\n\t\t\t\tif (rc != 0)\n\t\t\t\t\tgoto netlbl_export_failure;\n\t\t\t}\n\t\t\toffset += EBITMAP_UNIT_SIZE;\n\t\t}\n\t\te_iter = e_iter->next;\n\t}\n\n\treturn 0;\n\nnetlbl_export_failure:\n\tnetlbl_catmap_free(*catmap);\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "ebitmap_cpy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
    "lines": "52-78",
    "snippet": "int ebitmap_cpy(struct ebitmap *dst, struct ebitmap *src)\n{\n\tstruct ebitmap_node *n, *new, *prev;\n\n\tebitmap_init(dst);\n\tn = src->node;\n\tprev = NULL;\n\twhile (n) {\n\t\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\tebitmap_destroy(dst);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnew->startbit = n->startbit;\n\t\tmemcpy(new->maps, n->maps, EBITMAP_SIZE / 8);\n\t\tnew->next = NULL;\n\t\tif (prev)\n\t\t\tprev->next = new;\n\t\telse\n\t\t\tdst->node = new;\n\t\tprev = new;\n\t\tn = n->next;\n\t}\n\n\tdst->highbit = src->highbit;\n\treturn 0;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"ebitmap.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *ebitmap_node_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new->maps",
            "n->maps",
            "EBITMAP_SIZE / 8"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_destroy",
          "args": [
            "dst"
          ],
          "line": 62
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "327-344",
          "snippet": "void ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nvoid ebitmap_destroy(struct ebitmap *e)\n{\n\tstruct ebitmap_node *n, *temp;\n\n\tif (!e)\n\t\treturn;\n\n\tn = e->node;\n\twhile (n) {\n\t\ttemp = n;\n\t\tn = n->next;\n\t\tkmem_cache_free(ebitmap_node_cachep, temp);\n\t}\n\n\te->highbit = 0;\n\te->node = NULL;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "ebitmap_node_cachep",
            "GFP_ATOMIC"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ebitmap_init",
          "args": [
            "dst"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.h",
          "lines": "60-63",
          "snippet": "static inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}",
          "includes": [
            "#include <net/netlabel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/netlabel.h>\n\nstatic inline void ebitmap_init(struct ebitmap *e)\n{\n\tmemset(e, 0, sizeof(*e));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_cpy(struct ebitmap *dst, struct ebitmap *src)\n{\n\tstruct ebitmap_node *n, *new, *prev;\n\n\tebitmap_init(dst);\n\tn = src->node;\n\tprev = NULL;\n\twhile (n) {\n\t\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\t\tif (!new) {\n\t\t\tebitmap_destroy(dst);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tnew->startbit = n->startbit;\n\t\tmemcpy(new->maps, n->maps, EBITMAP_SIZE / 8);\n\t\tnew->next = NULL;\n\t\tif (prev)\n\t\t\tprev->next = new;\n\t\telse\n\t\t\tdst->node = new;\n\t\tprev = new;\n\t\tn = n->next;\n\t}\n\n\tdst->highbit = src->highbit;\n\treturn 0;\n}"
  },
  {
    "function_name": "ebitmap_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
    "lines": "30-50",
    "snippet": "int ebitmap_cmp(struct ebitmap *e1, struct ebitmap *e2)\n{\n\tstruct ebitmap_node *n1, *n2;\n\n\tif (e1->highbit != e2->highbit)\n\t\treturn 0;\n\n\tn1 = e1->node;\n\tn2 = e2->node;\n\twhile (n1 && n2 &&\n\t       (n1->startbit == n2->startbit) &&\n\t       !memcmp(n1->maps, n2->maps, EBITMAP_SIZE / 8)) {\n\t\tn1 = n1->next;\n\t\tn2 = n2->next;\n\t}\n\n\tif (n1 || n2)\n\t\treturn 0;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"ebitmap.h\"",
      "#include <net/netlabel.h>",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "n1->maps",
            "n2->maps",
            "EBITMAP_SIZE / 8"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint ebitmap_cmp(struct ebitmap *e1, struct ebitmap *e2)\n{\n\tstruct ebitmap_node *n1, *n2;\n\n\tif (e1->highbit != e2->highbit)\n\t\treturn 0;\n\n\tn1 = e1->node;\n\tn2 = e2->node;\n\twhile (n1 && n2 &&\n\t       (n1->startbit == n2->startbit) &&\n\t       !memcmp(n1->maps, n2->maps, EBITMAP_SIZE / 8)) {\n\t\tn1 = n1->next;\n\t\tn2 = n2->next;\n\t}\n\n\tif (n1 || n2)\n\t\treturn 0;\n\n\treturn 1;\n}"
  }
]