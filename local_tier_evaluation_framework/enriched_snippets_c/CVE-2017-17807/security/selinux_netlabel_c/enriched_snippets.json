[
  {
    "function_name": "selinux_netlbl_socket_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "482-515",
    "snippet": "int selinux_netlbl_socket_connect(struct sock *sk, struct sockaddr *addr)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (sksec->nlbl_state != NLBL_REQSKB &&\n\t    sksec->nlbl_state != NLBL_CONNLABELED)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\n\t/* connected sockets are allowed to disconnect when the address family\n\t * is set to AF_UNSPEC, if that is what is happening we want to reset\n\t * the socket */\n\tif (addr->sa_family == AF_UNSPEC) {\n\t\tnetlbl_sock_delattr(sk);\n\t\tsksec->nlbl_state = NLBL_REQSKB;\n\t\trc = 0;\n\t\tgoto socket_connect_return;\n\t}\n\tsecattr = selinux_netlbl_sock_genattr(sk);\n\tif (secattr == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto socket_connect_return;\n\t}\n\trc = netlbl_conn_setattr(sk, addr, secattr);\n\tif (rc == 0)\n\t\tsksec->nlbl_state = NLBL_CONNLABELED;\n\nsocket_connect_return:\n\trelease_sock(sk);\n\treturn rc;\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_sock",
          "args": [
            "sk"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_conn_setattr",
          "args": [
            "sk",
            "addr",
            "secattr"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_netlbl_sock_genattr",
          "args": [
            "sk"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_netlbl_sock_genattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
          "lines": "82-102",
          "snippet": "static struct netlbl_lsm_secattr *selinux_netlbl_sock_genattr(struct sock *sk)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (sksec->nlbl_secattr != NULL)\n\t\treturn sksec->nlbl_secattr;\n\n\tsecattr = netlbl_secattr_alloc(GFP_ATOMIC);\n\tif (secattr == NULL)\n\t\treturn NULL;\n\trc = security_netlbl_sid_to_secattr(sksec->sid, secattr);\n\tif (rc != 0) {\n\t\tnetlbl_secattr_free(secattr);\n\t\treturn NULL;\n\t}\n\tsksec->nlbl_secattr = secattr;\n\n\treturn secattr;\n}",
          "includes": [
            "#include \"netlabel.h\"",
            "#include \"security.h\"",
            "#include \"objsec.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/netlabel.h>",
            "#include <net/sock.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/gfp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nstatic struct netlbl_lsm_secattr *selinux_netlbl_sock_genattr(struct sock *sk)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (sksec->nlbl_secattr != NULL)\n\t\treturn sksec->nlbl_secattr;\n\n\tsecattr = netlbl_secattr_alloc(GFP_ATOMIC);\n\tif (secattr == NULL)\n\t\treturn NULL;\n\trc = security_netlbl_sid_to_secattr(sksec->sid, secattr);\n\tif (rc != 0) {\n\t\tnetlbl_secattr_free(secattr);\n\t\treturn NULL;\n\t}\n\tsksec->nlbl_secattr = secattr;\n\n\treturn secattr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_sock_delattr",
          "args": [
            "sk"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_sock",
          "args": [
            "sk"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nint selinux_netlbl_socket_connect(struct sock *sk, struct sockaddr *addr)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (sksec->nlbl_state != NLBL_REQSKB &&\n\t    sksec->nlbl_state != NLBL_CONNLABELED)\n\t\treturn 0;\n\n\tlock_sock(sk);\n\n\t/* connected sockets are allowed to disconnect when the address family\n\t * is set to AF_UNSPEC, if that is what is happening we want to reset\n\t * the socket */\n\tif (addr->sa_family == AF_UNSPEC) {\n\t\tnetlbl_sock_delattr(sk);\n\t\tsksec->nlbl_state = NLBL_REQSKB;\n\t\trc = 0;\n\t\tgoto socket_connect_return;\n\t}\n\tsecattr = selinux_netlbl_sock_genattr(sk);\n\tif (secattr == NULL) {\n\t\trc = -ENOMEM;\n\t\tgoto socket_connect_return;\n\t}\n\trc = netlbl_conn_setattr(sk, addr, secattr);\n\tif (rc == 0)\n\t\tsksec->nlbl_state = NLBL_CONNLABELED;\n\nsocket_connect_return:\n\trelease_sock(sk);\n\treturn rc;\n}"
  },
  {
    "function_name": "selinux_netlbl_socket_setsockopt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "443-470",
    "snippet": "int selinux_netlbl_socket_setsockopt(struct socket *sock,\n\t\t\t\t     int level,\n\t\t\t\t     int optname)\n{\n\tint rc = 0;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr secattr;\n\n\tif (selinux_netlbl_option(level, optname) &&\n\t    (sksec->nlbl_state == NLBL_LABELED ||\n\t     sksec->nlbl_state == NLBL_CONNLABELED)) {\n\t\tnetlbl_secattr_init(&secattr);\n\t\tlock_sock(sk);\n\t\t/* call the netlabel function directly as we want to see the\n\t\t * on-the-wire label that is assigned via the socket's options\n\t\t * and not the cached netlabel/lsm attributes */\n\t\trc = netlbl_sock_getattr(sk, &secattr);\n\t\trelease_sock(sk);\n\t\tif (rc == 0)\n\t\t\trc = -EACCES;\n\t\telse if (rc == -ENOMSG)\n\t\t\trc = 0;\n\t\tnetlbl_secattr_destroy(&secattr);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_secattr_destroy",
          "args": [
            "&secattr"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "release_sock",
          "args": [
            "sk"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_sock_getattr",
          "args": [
            "sk",
            "&secattr"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_netlbl_sock_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
          "lines": "113-128",
          "snippet": "static struct netlbl_lsm_secattr *selinux_netlbl_sock_getattr(\n\t\t\t\t\t\t\tconst struct sock *sk,\n\t\t\t\t\t\t\tu32 sid)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr = sksec->nlbl_secattr;\n\n\tif (secattr == NULL)\n\t\treturn NULL;\n\n\tif ((secattr->flags & NETLBL_SECATTR_SECID) &&\n\t    (secattr->attr.secid == sid))\n\t\treturn secattr;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"netlabel.h\"",
            "#include \"security.h\"",
            "#include \"objsec.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/netlabel.h>",
            "#include <net/sock.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/gfp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nstatic struct netlbl_lsm_secattr *selinux_netlbl_sock_getattr(\n\t\t\t\t\t\t\tconst struct sock *sk,\n\t\t\t\t\t\t\tu32 sid)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr = sksec->nlbl_secattr;\n\n\tif (secattr == NULL)\n\t\treturn NULL;\n\n\tif ((secattr->flags & NETLBL_SECATTR_SECID) &&\n\t    (secattr->attr.secid == sid))\n\t\treturn secattr;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_sock",
          "args": [
            "sk"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_init",
          "args": [
            "&secattr"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_netlbl_option",
          "args": [
            "level",
            "optname"
          ],
          "line": 452
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_netlbl_option",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
          "lines": "424-428",
          "snippet": "static inline int selinux_netlbl_option(int level, int optname)\n{\n\treturn (level == IPPROTO_IP && optname == IP_OPTIONS) ||\n\t\t(level == IPPROTO_IPV6 && optname == IPV6_HOPOPTS);\n}",
          "includes": [
            "#include \"netlabel.h\"",
            "#include \"security.h\"",
            "#include \"objsec.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/netlabel.h>",
            "#include <net/sock.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/gfp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nstatic inline int selinux_netlbl_option(int level, int optname)\n{\n\treturn (level == IPPROTO_IP && optname == IP_OPTIONS) ||\n\t\t(level == IPPROTO_IPV6 && optname == IPV6_HOPOPTS);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nint selinux_netlbl_socket_setsockopt(struct socket *sock,\n\t\t\t\t     int level,\n\t\t\t\t     int optname)\n{\n\tint rc = 0;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr secattr;\n\n\tif (selinux_netlbl_option(level, optname) &&\n\t    (sksec->nlbl_state == NLBL_LABELED ||\n\t     sksec->nlbl_state == NLBL_CONNLABELED)) {\n\t\tnetlbl_secattr_init(&secattr);\n\t\tlock_sock(sk);\n\t\t/* call the netlabel function directly as we want to see the\n\t\t * on-the-wire label that is assigned via the socket's options\n\t\t * and not the cached netlabel/lsm attributes */\n\t\trc = netlbl_sock_getattr(sk, &secattr);\n\t\trelease_sock(sk);\n\t\tif (rc == 0)\n\t\t\trc = -EACCES;\n\t\telse if (rc == -ENOMSG)\n\t\t\trc = 0;\n\t\tnetlbl_secattr_destroy(&secattr);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "selinux_netlbl_option",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "424-428",
    "snippet": "static inline int selinux_netlbl_option(int level, int optname)\n{\n\treturn (level == IPPROTO_IP && optname == IP_OPTIONS) ||\n\t\t(level == IPPROTO_IPV6 && optname == IPV6_HOPOPTS);\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nstatic inline int selinux_netlbl_option(int level, int optname)\n{\n\treturn (level == IPPROTO_IP && optname == IP_OPTIONS) ||\n\t\t(level == IPPROTO_IPV6 && optname == IPV6_HOPOPTS);\n}"
  },
  {
    "function_name": "selinux_netlbl_sock_rcv_skb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "371-413",
    "snippet": "int selinux_netlbl_sock_rcv_skb(struct sk_security_struct *sksec,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tu16 family,\n\t\t\t\tstruct common_audit_data *ad)\n{\n\tint rc;\n\tu32 nlbl_sid;\n\tu32 perm;\n\tstruct netlbl_lsm_secattr secattr;\n\n\tif (!netlbl_enabled())\n\t\treturn 0;\n\n\tnetlbl_secattr_init(&secattr);\n\trc = netlbl_skbuff_getattr(skb, family, &secattr);\n\tif (rc == 0 && secattr.flags != NETLBL_SECATTR_NONE)\n\t\trc = selinux_netlbl_sidlookup_cached(skb, family,\n\t\t\t\t\t\t     &secattr, &nlbl_sid);\n\telse\n\t\tnlbl_sid = SECINITSID_UNLABELED;\n\tnetlbl_secattr_destroy(&secattr);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tswitch (sksec->sclass) {\n\tcase SECCLASS_UDP_SOCKET:\n\t\tperm = UDP_SOCKET__RECVFROM;\n\t\tbreak;\n\tcase SECCLASS_TCP_SOCKET:\n\t\tperm = TCP_SOCKET__RECVFROM;\n\t\tbreak;\n\tdefault:\n\t\tperm = RAWIP_SOCKET__RECVFROM;\n\t}\n\n\trc = avc_has_perm(sksec->sid, nlbl_sid, sksec->sclass, perm, ad);\n\tif (rc == 0)\n\t\treturn 0;\n\n\tif (nlbl_sid != SECINITSID_UNLABELED)\n\t\tnetlbl_skbuff_err(skb, family, rc, 0);\n\treturn rc;\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_skbuff_err",
          "args": [
            "skb",
            "family",
            "rc",
            "0"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avc_has_perm",
          "args": [
            "sksec->sid",
            "nlbl_sid",
            "sksec->sclass",
            "perm",
            "ad"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "avc_has_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/avc.c",
          "lines": "1138-1150",
          "snippet": "int avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}",
          "includes": [
            "#include \"classmap.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include <net/ipv6.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/audit.h>",
            "#include <linux/ip.h>",
            "#include <net/af_unix.h>",
            "#include <linux/un.h>",
            "#include <net/sock.h>",
            "#include <linux/list.h>",
            "#include <linux/percpu.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/init.h>",
            "#include <linux/dcache.h>",
            "#include <linux/fs.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/stddef.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static noinline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"classmap.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include <net/ipv6.h>\n#include <linux/ipv6.h>\n#include <linux/audit.h>\n#include <linux/ip.h>\n#include <net/af_unix.h>\n#include <linux/un.h>\n#include <net/sock.h>\n#include <linux/list.h>\n#include <linux/percpu.h>\n#include <linux/skbuff.h>\n#include <linux/init.h>\n#include <linux/dcache.h>\n#include <linux/fs.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/stddef.h>\n#include <linux/types.h>\n\nstatic noinline struct;\n\nint avc_has_perm(u32 ssid, u32 tsid, u16 tclass,\n\t\t u32 requested, struct common_audit_data *auditdata)\n{\n\tstruct av_decision avd;\n\tint rc, rc2;\n\n\trc = avc_has_perm_noaudit(ssid, tsid, tclass, requested, 0, &avd);\n\n\trc2 = avc_audit(ssid, tsid, tclass, requested, &avd, rc, auditdata, 0);\n\tif (rc2)\n\t\treturn rc2;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_destroy",
          "args": [
            "&secattr"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_netlbl_sidlookup_cached",
          "args": [
            "skb",
            "family",
            "&secattr",
            "&nlbl_sid"
          ],
          "line": 387
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_netlbl_sidlookup_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
          "lines": "56-70",
          "snippet": "static int selinux_netlbl_sidlookup_cached(struct sk_buff *skb,\n\t\t\t\t\t   u16 family,\n\t\t\t\t\t   struct netlbl_lsm_secattr *secattr,\n\t\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\n\trc = security_netlbl_secattr_to_sid(secattr, sid);\n\tif (rc == 0 &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHEABLE) &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHE))\n\t\tnetlbl_cache_add(skb, family, secattr);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"netlabel.h\"",
            "#include \"security.h\"",
            "#include \"objsec.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/netlabel.h>",
            "#include <net/sock.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/gfp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nstatic int selinux_netlbl_sidlookup_cached(struct sk_buff *skb,\n\t\t\t\t\t   u16 family,\n\t\t\t\t\t   struct netlbl_lsm_secattr *secattr,\n\t\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\n\trc = security_netlbl_secattr_to_sid(secattr, sid);\n\tif (rc == 0 &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHEABLE) &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHE))\n\t\tnetlbl_cache_add(skb, family, secattr);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_skbuff_getattr",
          "args": [
            "skb",
            "family",
            "&secattr"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_init",
          "args": [
            "&secattr"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_enabled",
          "args": [],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nint selinux_netlbl_sock_rcv_skb(struct sk_security_struct *sksec,\n\t\t\t\tstruct sk_buff *skb,\n\t\t\t\tu16 family,\n\t\t\t\tstruct common_audit_data *ad)\n{\n\tint rc;\n\tu32 nlbl_sid;\n\tu32 perm;\n\tstruct netlbl_lsm_secattr secattr;\n\n\tif (!netlbl_enabled())\n\t\treturn 0;\n\n\tnetlbl_secattr_init(&secattr);\n\trc = netlbl_skbuff_getattr(skb, family, &secattr);\n\tif (rc == 0 && secattr.flags != NETLBL_SECATTR_NONE)\n\t\trc = selinux_netlbl_sidlookup_cached(skb, family,\n\t\t\t\t\t\t     &secattr, &nlbl_sid);\n\telse\n\t\tnlbl_sid = SECINITSID_UNLABELED;\n\tnetlbl_secattr_destroy(&secattr);\n\tif (rc != 0)\n\t\treturn rc;\n\n\tswitch (sksec->sclass) {\n\tcase SECCLASS_UDP_SOCKET:\n\t\tperm = UDP_SOCKET__RECVFROM;\n\t\tbreak;\n\tcase SECCLASS_TCP_SOCKET:\n\t\tperm = TCP_SOCKET__RECVFROM;\n\t\tbreak;\n\tdefault:\n\t\tperm = RAWIP_SOCKET__RECVFROM;\n\t}\n\n\trc = avc_has_perm(sksec->sid, nlbl_sid, sksec->sclass, perm, ad);\n\tif (rc == 0)\n\t\treturn 0;\n\n\tif (nlbl_sid != SECINITSID_UNLABELED)\n\t\tnetlbl_skbuff_err(skb, family, rc, 0);\n\treturn rc;\n}"
  },
  {
    "function_name": "selinux_netlbl_socket_post_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "332-356",
    "snippet": "int selinux_netlbl_socket_post_create(struct sock *sk, u16 family)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (family != PF_INET && family != PF_INET6)\n\t\treturn 0;\n\n\tsecattr = selinux_netlbl_sock_genattr(sk);\n\tif (secattr == NULL)\n\t\treturn -ENOMEM;\n\trc = netlbl_sock_setattr(sk, family, secattr);\n\tswitch (rc) {\n\tcase 0:\n\t\tsksec->nlbl_state = NLBL_LABELED;\n\t\tbreak;\n\tcase -EDESTADDRREQ:\n\t\tsksec->nlbl_state = NLBL_REQSKB;\n\t\trc = 0;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_sock_setattr",
          "args": [
            "sk",
            "family",
            "secattr"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_netlbl_sock_genattr",
          "args": [
            "sk"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_netlbl_sock_genattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
          "lines": "82-102",
          "snippet": "static struct netlbl_lsm_secattr *selinux_netlbl_sock_genattr(struct sock *sk)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (sksec->nlbl_secattr != NULL)\n\t\treturn sksec->nlbl_secattr;\n\n\tsecattr = netlbl_secattr_alloc(GFP_ATOMIC);\n\tif (secattr == NULL)\n\t\treturn NULL;\n\trc = security_netlbl_sid_to_secattr(sksec->sid, secattr);\n\tif (rc != 0) {\n\t\tnetlbl_secattr_free(secattr);\n\t\treturn NULL;\n\t}\n\tsksec->nlbl_secattr = secattr;\n\n\treturn secattr;\n}",
          "includes": [
            "#include \"netlabel.h\"",
            "#include \"security.h\"",
            "#include \"objsec.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/netlabel.h>",
            "#include <net/sock.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/gfp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nstatic struct netlbl_lsm_secattr *selinux_netlbl_sock_genattr(struct sock *sk)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (sksec->nlbl_secattr != NULL)\n\t\treturn sksec->nlbl_secattr;\n\n\tsecattr = netlbl_secattr_alloc(GFP_ATOMIC);\n\tif (secattr == NULL)\n\t\treturn NULL;\n\trc = security_netlbl_sid_to_secattr(sksec->sid, secattr);\n\tif (rc != 0) {\n\t\tnetlbl_secattr_free(secattr);\n\t\treturn NULL;\n\t}\n\tsksec->nlbl_secattr = secattr;\n\n\treturn secattr;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nint selinux_netlbl_socket_post_create(struct sock *sk, u16 family)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (family != PF_INET && family != PF_INET6)\n\t\treturn 0;\n\n\tsecattr = selinux_netlbl_sock_genattr(sk);\n\tif (secattr == NULL)\n\t\treturn -ENOMEM;\n\trc = netlbl_sock_setattr(sk, family, secattr);\n\tswitch (rc) {\n\tcase 0:\n\t\tsksec->nlbl_state = NLBL_LABELED;\n\t\tbreak;\n\tcase -EDESTADDRREQ:\n\t\tsksec->nlbl_state = NLBL_REQSKB;\n\t\trc = 0;\n\t\tbreak;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "selinux_netlbl_inet_csk_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "312-320",
    "snippet": "void selinux_netlbl_inet_csk_clone(struct sock *sk, u16 family)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\tif (family == PF_INET)\n\t\tsksec->nlbl_state = NLBL_LABELED;\n\telse\n\t\tsksec->nlbl_state = NLBL_UNSET;\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nvoid selinux_netlbl_inet_csk_clone(struct sock *sk, u16 family)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\n\tif (family == PF_INET)\n\t\tsksec->nlbl_state = NLBL_LABELED;\n\telse\n\t\tsksec->nlbl_state = NLBL_UNSET;\n}"
  },
  {
    "function_name": "selinux_netlbl_inet_conn_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "284-300",
    "snippet": "int selinux_netlbl_inet_conn_request(struct request_sock *req, u16 family)\n{\n\tint rc;\n\tstruct netlbl_lsm_secattr secattr;\n\n\tif (family != PF_INET && family != PF_INET6)\n\t\treturn 0;\n\n\tnetlbl_secattr_init(&secattr);\n\trc = security_netlbl_sid_to_secattr(req->secid, &secattr);\n\tif (rc != 0)\n\t\tgoto inet_conn_request_return;\n\trc = netlbl_req_setattr(req, &secattr);\ninet_conn_request_return:\n\tnetlbl_secattr_destroy(&secattr);\n\treturn rc;\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_secattr_destroy",
          "args": [
            "&secattr"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_req_setattr",
          "args": [
            "req",
            "&secattr"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_netlbl_sid_to_secattr",
          "args": [
            "req->secid",
            "&secattr"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "security_netlbl_sid_to_secattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3506-3534",
          "snippet": "int security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\tstruct context *ctx;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOENT;\n\tctx = sidtab_search(&sidtab, sid);\n\tif (ctx == NULL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsecattr->domain = kstrdup(sym_name(&policydb, SYM_TYPES, ctx->type - 1),\n\t\t\t\t  GFP_ATOMIC);\n\tif (secattr->domain == NULL)\n\t\tgoto out;\n\n\tsecattr->attr.secid = sid;\n\tsecattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;\n\tmls_export_netlbl_lvl(ctx, secattr);\n\trc = mls_export_netlbl_cat(ctx, secattr);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nint security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\tstruct context *ctx;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOENT;\n\tctx = sidtab_search(&sidtab, sid);\n\tif (ctx == NULL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsecattr->domain = kstrdup(sym_name(&policydb, SYM_TYPES, ctx->type - 1),\n\t\t\t\t  GFP_ATOMIC);\n\tif (secattr->domain == NULL)\n\t\tgoto out;\n\n\tsecattr->attr.secid = sid;\n\tsecattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;\n\tmls_export_netlbl_lvl(ctx, secattr);\n\trc = mls_export_netlbl_cat(ctx, secattr);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_init",
          "args": [
            "&secattr"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nint selinux_netlbl_inet_conn_request(struct request_sock *req, u16 family)\n{\n\tint rc;\n\tstruct netlbl_lsm_secattr secattr;\n\n\tif (family != PF_INET && family != PF_INET6)\n\t\treturn 0;\n\n\tnetlbl_secattr_init(&secattr);\n\trc = security_netlbl_sid_to_secattr(req->secid, &secattr);\n\tif (rc != 0)\n\t\tgoto inet_conn_request_return;\n\trc = netlbl_req_setattr(req, &secattr);\ninet_conn_request_return:\n\tnetlbl_secattr_destroy(&secattr);\n\treturn rc;\n}"
  },
  {
    "function_name": "selinux_netlbl_skbuff_setsid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "239-271",
    "snippet": "int selinux_netlbl_skbuff_setsid(struct sk_buff *skb,\n\t\t\t\t u16 family,\n\t\t\t\t u32 sid)\n{\n\tint rc;\n\tstruct netlbl_lsm_secattr secattr_storage;\n\tstruct netlbl_lsm_secattr *secattr = NULL;\n\tstruct sock *sk;\n\n\t/* if this is a locally generated packet check to see if it is already\n\t * being labeled by it's parent socket, if it is just exit */\n\tsk = skb_to_full_sk(skb);\n\tif (sk != NULL) {\n\t\tstruct sk_security_struct *sksec = sk->sk_security;\n\t\tif (sksec->nlbl_state != NLBL_REQSKB)\n\t\t\treturn 0;\n\t\tsecattr = selinux_netlbl_sock_getattr(sk, sid);\n\t}\n\tif (secattr == NULL) {\n\t\tsecattr = &secattr_storage;\n\t\tnetlbl_secattr_init(secattr);\n\t\trc = security_netlbl_sid_to_secattr(sid, secattr);\n\t\tif (rc != 0)\n\t\t\tgoto skbuff_setsid_return;\n\t}\n\n\trc = netlbl_skbuff_setattr(skb, family, secattr);\n\nskbuff_setsid_return:\n\tif (secattr == &secattr_storage)\n\t\tnetlbl_secattr_destroy(secattr);\n\treturn rc;\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_secattr_destroy",
          "args": [
            "secattr"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_skbuff_setattr",
          "args": [
            "skb",
            "family",
            "secattr"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_netlbl_sid_to_secattr",
          "args": [
            "sid",
            "secattr"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "security_netlbl_sid_to_secattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3506-3534",
          "snippet": "int security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\tstruct context *ctx;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOENT;\n\tctx = sidtab_search(&sidtab, sid);\n\tif (ctx == NULL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsecattr->domain = kstrdup(sym_name(&policydb, SYM_TYPES, ctx->type - 1),\n\t\t\t\t  GFP_ATOMIC);\n\tif (secattr->domain == NULL)\n\t\tgoto out;\n\n\tsecattr->attr.secid = sid;\n\tsecattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;\n\tmls_export_netlbl_lvl(ctx, secattr);\n\trc = mls_export_netlbl_cat(ctx, secattr);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nint security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\tstruct context *ctx;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOENT;\n\tctx = sidtab_search(&sidtab, sid);\n\tif (ctx == NULL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsecattr->domain = kstrdup(sym_name(&policydb, SYM_TYPES, ctx->type - 1),\n\t\t\t\t  GFP_ATOMIC);\n\tif (secattr->domain == NULL)\n\t\tgoto out;\n\n\tsecattr->attr.secid = sid;\n\tsecattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;\n\tmls_export_netlbl_lvl(ctx, secattr);\n\trc = mls_export_netlbl_cat(ctx, secattr);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_init",
          "args": [
            "secattr"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_netlbl_sock_getattr",
          "args": [
            "sk",
            "sid"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_netlbl_sock_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
          "lines": "113-128",
          "snippet": "static struct netlbl_lsm_secattr *selinux_netlbl_sock_getattr(\n\t\t\t\t\t\t\tconst struct sock *sk,\n\t\t\t\t\t\t\tu32 sid)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr = sksec->nlbl_secattr;\n\n\tif (secattr == NULL)\n\t\treturn NULL;\n\n\tif ((secattr->flags & NETLBL_SECATTR_SECID) &&\n\t    (secattr->attr.secid == sid))\n\t\treturn secattr;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"netlabel.h\"",
            "#include \"security.h\"",
            "#include \"objsec.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/netlabel.h>",
            "#include <net/sock.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/gfp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nstatic struct netlbl_lsm_secattr *selinux_netlbl_sock_getattr(\n\t\t\t\t\t\t\tconst struct sock *sk,\n\t\t\t\t\t\t\tu32 sid)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr = sksec->nlbl_secattr;\n\n\tif (secattr == NULL)\n\t\treturn NULL;\n\n\tif ((secattr->flags & NETLBL_SECATTR_SECID) &&\n\t    (secattr->attr.secid == sid))\n\t\treturn secattr;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_to_full_sk",
          "args": [
            "skb"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nint selinux_netlbl_skbuff_setsid(struct sk_buff *skb,\n\t\t\t\t u16 family,\n\t\t\t\t u32 sid)\n{\n\tint rc;\n\tstruct netlbl_lsm_secattr secattr_storage;\n\tstruct netlbl_lsm_secattr *secattr = NULL;\n\tstruct sock *sk;\n\n\t/* if this is a locally generated packet check to see if it is already\n\t * being labeled by it's parent socket, if it is just exit */\n\tsk = skb_to_full_sk(skb);\n\tif (sk != NULL) {\n\t\tstruct sk_security_struct *sksec = sk->sk_security;\n\t\tif (sksec->nlbl_state != NLBL_REQSKB)\n\t\t\treturn 0;\n\t\tsecattr = selinux_netlbl_sock_getattr(sk, sid);\n\t}\n\tif (secattr == NULL) {\n\t\tsecattr = &secattr_storage;\n\t\tnetlbl_secattr_init(secattr);\n\t\trc = security_netlbl_sid_to_secattr(sid, secattr);\n\t\tif (rc != 0)\n\t\t\tgoto skbuff_setsid_return;\n\t}\n\n\trc = netlbl_skbuff_setattr(skb, family, secattr);\n\nskbuff_setsid_return:\n\tif (secattr == &secattr_storage)\n\t\tnetlbl_secattr_destroy(secattr);\n\treturn rc;\n}"
  },
  {
    "function_name": "selinux_netlbl_skbuff_getsid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "202-226",
    "snippet": "int selinux_netlbl_skbuff_getsid(struct sk_buff *skb,\n\t\t\t\t u16 family,\n\t\t\t\t u32 *type,\n\t\t\t\t u32 *sid)\n{\n\tint rc;\n\tstruct netlbl_lsm_secattr secattr;\n\n\tif (!netlbl_enabled()) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\n\tnetlbl_secattr_init(&secattr);\n\trc = netlbl_skbuff_getattr(skb, family, &secattr);\n\tif (rc == 0 && secattr.flags != NETLBL_SECATTR_NONE)\n\t\trc = selinux_netlbl_sidlookup_cached(skb, family,\n\t\t\t\t\t\t     &secattr, sid);\n\telse\n\t\t*sid = SECSID_NULL;\n\t*type = secattr.type;\n\tnetlbl_secattr_destroy(&secattr);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_secattr_destroy",
          "args": [
            "&secattr"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "selinux_netlbl_sidlookup_cached",
          "args": [
            "skb",
            "family",
            "&secattr",
            "sid"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_netlbl_sidlookup_cached",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
          "lines": "56-70",
          "snippet": "static int selinux_netlbl_sidlookup_cached(struct sk_buff *skb,\n\t\t\t\t\t   u16 family,\n\t\t\t\t\t   struct netlbl_lsm_secattr *secattr,\n\t\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\n\trc = security_netlbl_secattr_to_sid(secattr, sid);\n\tif (rc == 0 &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHEABLE) &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHE))\n\t\tnetlbl_cache_add(skb, family, secattr);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"netlabel.h\"",
            "#include \"security.h\"",
            "#include \"objsec.h\"",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/netlabel.h>",
            "#include <net/sock.h>",
            "#include <linux/ipv6.h>",
            "#include <linux/ip.h>",
            "#include <linux/gfp.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nstatic int selinux_netlbl_sidlookup_cached(struct sk_buff *skb,\n\t\t\t\t\t   u16 family,\n\t\t\t\t\t   struct netlbl_lsm_secattr *secattr,\n\t\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\n\trc = security_netlbl_secattr_to_sid(secattr, sid);\n\tif (rc == 0 &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHEABLE) &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHE))\n\t\tnetlbl_cache_add(skb, family, secattr);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_skbuff_getattr",
          "args": [
            "skb",
            "family",
            "&secattr"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_init",
          "args": [
            "&secattr"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "netlbl_enabled",
          "args": [],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nint selinux_netlbl_skbuff_getsid(struct sk_buff *skb,\n\t\t\t\t u16 family,\n\t\t\t\t u32 *type,\n\t\t\t\t u32 *sid)\n{\n\tint rc;\n\tstruct netlbl_lsm_secattr secattr;\n\n\tif (!netlbl_enabled()) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\n\tnetlbl_secattr_init(&secattr);\n\trc = netlbl_skbuff_getattr(skb, family, &secattr);\n\tif (rc == 0 && secattr.flags != NETLBL_SECATTR_NONE)\n\t\trc = selinux_netlbl_sidlookup_cached(skb, family,\n\t\t\t\t\t\t     &secattr, sid);\n\telse\n\t\t*sid = SECSID_NULL;\n\t*type = secattr.type;\n\tnetlbl_secattr_destroy(&secattr);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "selinux_netlbl_sk_security_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "184-187",
    "snippet": "void selinux_netlbl_sk_security_reset(struct sk_security_struct *sksec)\n{\n\tsksec->nlbl_state = NLBL_UNSET;\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nvoid selinux_netlbl_sk_security_reset(struct sk_security_struct *sksec)\n{\n\tsksec->nlbl_state = NLBL_UNSET;\n}"
  },
  {
    "function_name": "selinux_netlbl_sk_security_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "168-172",
    "snippet": "void selinux_netlbl_sk_security_free(struct sk_security_struct *sksec)\n{\n\tif (sksec->nlbl_secattr != NULL)\n\t\tnetlbl_secattr_free(sksec->nlbl_secattr);\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_secattr_free",
          "args": [
            "sksec->nlbl_secattr"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nvoid selinux_netlbl_sk_security_free(struct sk_security_struct *sksec)\n{\n\tif (sksec->nlbl_secattr != NULL)\n\t\tnetlbl_secattr_free(sksec->nlbl_secattr);\n}"
  },
  {
    "function_name": "selinux_netlbl_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "155-158",
    "snippet": "void selinux_netlbl_err(struct sk_buff *skb, u16 family, int error, int gateway)\n{\n\tnetlbl_skbuff_err(skb, family, error, gateway);\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_skbuff_err",
          "args": [
            "skb",
            "family",
            "error",
            "gateway"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nvoid selinux_netlbl_err(struct sk_buff *skb, u16 family, int error, int gateway)\n{\n\tnetlbl_skbuff_err(skb, family, error, gateway);\n}"
  },
  {
    "function_name": "selinux_netlbl_cache_invalidate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "137-140",
    "snippet": "void selinux_netlbl_cache_invalidate(void)\n{\n\tnetlbl_cache_invalidate();\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_cache_invalidate",
          "args": [],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "selinux_netlbl_cache_invalidate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
          "lines": "137-140",
          "snippet": "void selinux_netlbl_cache_invalidate(void)\n{\n\tnetlbl_cache_invalidate();\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nvoid selinux_netlbl_cache_invalidate(void)\n{\n\tnetlbl_cache_invalidate();\n}"
  },
  {
    "function_name": "selinux_netlbl_sock_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "113-128",
    "snippet": "static struct netlbl_lsm_secattr *selinux_netlbl_sock_getattr(\n\t\t\t\t\t\t\tconst struct sock *sk,\n\t\t\t\t\t\t\tu32 sid)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr = sksec->nlbl_secattr;\n\n\tif (secattr == NULL)\n\t\treturn NULL;\n\n\tif ((secattr->flags & NETLBL_SECATTR_SECID) &&\n\t    (secattr->attr.secid == sid))\n\t\treturn secattr;\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nstatic struct netlbl_lsm_secattr *selinux_netlbl_sock_getattr(\n\t\t\t\t\t\t\tconst struct sock *sk,\n\t\t\t\t\t\t\tu32 sid)\n{\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr = sksec->nlbl_secattr;\n\n\tif (secattr == NULL)\n\t\treturn NULL;\n\n\tif ((secattr->flags & NETLBL_SECATTR_SECID) &&\n\t    (secattr->attr.secid == sid))\n\t\treturn secattr;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "selinux_netlbl_sock_genattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "82-102",
    "snippet": "static struct netlbl_lsm_secattr *selinux_netlbl_sock_genattr(struct sock *sk)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (sksec->nlbl_secattr != NULL)\n\t\treturn sksec->nlbl_secattr;\n\n\tsecattr = netlbl_secattr_alloc(GFP_ATOMIC);\n\tif (secattr == NULL)\n\t\treturn NULL;\n\trc = security_netlbl_sid_to_secattr(sksec->sid, secattr);\n\tif (rc != 0) {\n\t\tnetlbl_secattr_free(secattr);\n\t\treturn NULL;\n\t}\n\tsksec->nlbl_secattr = secattr;\n\n\treturn secattr;\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_secattr_free",
          "args": [
            "secattr"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_netlbl_sid_to_secattr",
          "args": [
            "sksec->sid",
            "secattr"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "security_netlbl_sid_to_secattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3506-3534",
          "snippet": "int security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\tstruct context *ctx;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOENT;\n\tctx = sidtab_search(&sidtab, sid);\n\tif (ctx == NULL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsecattr->domain = kstrdup(sym_name(&policydb, SYM_TYPES, ctx->type - 1),\n\t\t\t\t  GFP_ATOMIC);\n\tif (secattr->domain == NULL)\n\t\tgoto out;\n\n\tsecattr->attr.secid = sid;\n\tsecattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;\n\tmls_export_netlbl_lvl(ctx, secattr);\n\trc = mls_export_netlbl_cat(ctx, secattr);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nint security_netlbl_sid_to_secattr(u32 sid, struct netlbl_lsm_secattr *secattr)\n{\n\tint rc;\n\tstruct context *ctx;\n\n\tif (!ss_initialized)\n\t\treturn 0;\n\n\tread_lock(&policy_rwlock);\n\n\trc = -ENOENT;\n\tctx = sidtab_search(&sidtab, sid);\n\tif (ctx == NULL)\n\t\tgoto out;\n\n\trc = -ENOMEM;\n\tsecattr->domain = kstrdup(sym_name(&policydb, SYM_TYPES, ctx->type - 1),\n\t\t\t\t  GFP_ATOMIC);\n\tif (secattr->domain == NULL)\n\t\tgoto out;\n\n\tsecattr->attr.secid = sid;\n\tsecattr->flags |= NETLBL_SECATTR_DOMAIN_CPY | NETLBL_SECATTR_SECID;\n\tmls_export_netlbl_lvl(ctx, secattr);\n\trc = mls_export_netlbl_cat(ctx, secattr);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "netlbl_secattr_alloc",
          "args": [
            "GFP_ATOMIC"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nstatic struct netlbl_lsm_secattr *selinux_netlbl_sock_genattr(struct sock *sk)\n{\n\tint rc;\n\tstruct sk_security_struct *sksec = sk->sk_security;\n\tstruct netlbl_lsm_secattr *secattr;\n\n\tif (sksec->nlbl_secattr != NULL)\n\t\treturn sksec->nlbl_secattr;\n\n\tsecattr = netlbl_secattr_alloc(GFP_ATOMIC);\n\tif (secattr == NULL)\n\t\treturn NULL;\n\trc = security_netlbl_sid_to_secattr(sksec->sid, secattr);\n\tif (rc != 0) {\n\t\tnetlbl_secattr_free(secattr);\n\t\treturn NULL;\n\t}\n\tsksec->nlbl_secattr = secattr;\n\n\treturn secattr;\n}"
  },
  {
    "function_name": "selinux_netlbl_sidlookup_cached",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/netlabel.c",
    "lines": "56-70",
    "snippet": "static int selinux_netlbl_sidlookup_cached(struct sk_buff *skb,\n\t\t\t\t\t   u16 family,\n\t\t\t\t\t   struct netlbl_lsm_secattr *secattr,\n\t\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\n\trc = security_netlbl_secattr_to_sid(secattr, sid);\n\tif (rc == 0 &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHEABLE) &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHE))\n\t\tnetlbl_cache_add(skb, family, secattr);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"netlabel.h\"",
      "#include \"security.h\"",
      "#include \"objsec.h\"",
      "#include <net/ipv6.h>",
      "#include <net/ip.h>",
      "#include <net/netlabel.h>",
      "#include <net/sock.h>",
      "#include <linux/ipv6.h>",
      "#include <linux/ip.h>",
      "#include <linux/gfp.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "netlbl_cache_add",
          "args": [
            "skb",
            "family",
            "secattr"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_netlbl_secattr_to_sid",
          "args": [
            "secattr",
            "sid"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "security_netlbl_secattr_to_sid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3439-3494",
          "snippet": "int security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\tstruct context *ctx;\n\tstruct context ctx_new;\n\n\tif (!ss_initialized) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\n\tread_lock(&policy_rwlock);\n\n\tif (secattr->flags & NETLBL_SECATTR_CACHE)\n\t\t*sid = *(u32 *)secattr->cache->data;\n\telse if (secattr->flags & NETLBL_SECATTR_SECID)\n\t\t*sid = secattr->attr.secid;\n\telse if (secattr->flags & NETLBL_SECATTR_MLS_LVL) {\n\t\trc = -EIDRM;\n\t\tctx = sidtab_search(&sidtab, SECINITSID_NETMSG);\n\t\tif (ctx == NULL)\n\t\t\tgoto out;\n\n\t\tcontext_init(&ctx_new);\n\t\tctx_new.user = ctx->user;\n\t\tctx_new.role = ctx->role;\n\t\tctx_new.type = ctx->type;\n\t\tmls_import_netlbl_lvl(&ctx_new, secattr);\n\t\tif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\n\t\t\trc = mls_import_netlbl_cat(&ctx_new, secattr);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\trc = -EIDRM;\n\t\tif (!mls_context_isvalid(&policydb, &ctx_new))\n\t\t\tgoto out_free;\n\n\t\trc = sidtab_context_to_sid(&sidtab, &ctx_new, sid);\n\t\tif (rc)\n\t\t\tgoto out_free;\n\n\t\tsecurity_netlbl_cache_add(secattr, *sid);\n\n\t\tebitmap_destroy(&ctx_new.range.level[0].cat);\n\t} else\n\t\t*sid = SECSID_NULL;\n\n\tread_unlock(&policy_rwlock);\n\treturn 0;\nout_free:\n\tebitmap_destroy(&ctx_new.range.level[0].cat);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_RWLOCK(policy_rwlock);",
            "static struct sidtab sidtab;",
            "struct policydb policydb;",
            "int ss_initialized;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_RWLOCK(policy_rwlock);\nstatic struct sidtab sidtab;\nstruct policydb policydb;\nint ss_initialized;\n\nint security_netlbl_secattr_to_sid(struct netlbl_lsm_secattr *secattr,\n\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\tstruct context *ctx;\n\tstruct context ctx_new;\n\n\tif (!ss_initialized) {\n\t\t*sid = SECSID_NULL;\n\t\treturn 0;\n\t}\n\n\tread_lock(&policy_rwlock);\n\n\tif (secattr->flags & NETLBL_SECATTR_CACHE)\n\t\t*sid = *(u32 *)secattr->cache->data;\n\telse if (secattr->flags & NETLBL_SECATTR_SECID)\n\t\t*sid = secattr->attr.secid;\n\telse if (secattr->flags & NETLBL_SECATTR_MLS_LVL) {\n\t\trc = -EIDRM;\n\t\tctx = sidtab_search(&sidtab, SECINITSID_NETMSG);\n\t\tif (ctx == NULL)\n\t\t\tgoto out;\n\n\t\tcontext_init(&ctx_new);\n\t\tctx_new.user = ctx->user;\n\t\tctx_new.role = ctx->role;\n\t\tctx_new.type = ctx->type;\n\t\tmls_import_netlbl_lvl(&ctx_new, secattr);\n\t\tif (secattr->flags & NETLBL_SECATTR_MLS_CAT) {\n\t\t\trc = mls_import_netlbl_cat(&ctx_new, secattr);\n\t\t\tif (rc)\n\t\t\t\tgoto out;\n\t\t}\n\t\trc = -EIDRM;\n\t\tif (!mls_context_isvalid(&policydb, &ctx_new))\n\t\t\tgoto out_free;\n\n\t\trc = sidtab_context_to_sid(&sidtab, &ctx_new, sid);\n\t\tif (rc)\n\t\t\tgoto out_free;\n\n\t\tsecurity_netlbl_cache_add(secattr, *sid);\n\n\t\tebitmap_destroy(&ctx_new.range.level[0].cat);\n\t} else\n\t\t*sid = SECSID_NULL;\n\n\tread_unlock(&policy_rwlock);\n\treturn 0;\nout_free:\n\tebitmap_destroy(&ctx_new.range.level[0].cat);\nout:\n\tread_unlock(&policy_rwlock);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"netlabel.h\"\n#include \"security.h\"\n#include \"objsec.h\"\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/netlabel.h>\n#include <net/sock.h>\n#include <linux/ipv6.h>\n#include <linux/ip.h>\n#include <linux/gfp.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n\nstatic int selinux_netlbl_sidlookup_cached(struct sk_buff *skb,\n\t\t\t\t\t   u16 family,\n\t\t\t\t\t   struct netlbl_lsm_secattr *secattr,\n\t\t\t\t\t   u32 *sid)\n{\n\tint rc;\n\n\trc = security_netlbl_secattr_to_sid(secattr, sid);\n\tif (rc == 0 &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHEABLE) &&\n\t    (secattr->flags & NETLBL_SECATTR_CACHE))\n\t\tnetlbl_cache_add(skb, family, secattr);\n\n\treturn rc;\n}"
  }
]