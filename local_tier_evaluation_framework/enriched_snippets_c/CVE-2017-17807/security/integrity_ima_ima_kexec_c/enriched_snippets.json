[
  {
    "function_name": "ima_load_kexec_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_kexec.c",
    "lines": "142-168",
    "snippet": "void ima_load_kexec_buffer(void)\n{\n\tvoid *kexec_buffer = NULL;\n\tsize_t kexec_buffer_size = 0;\n\tint rc;\n\n\trc = ima_get_kexec_buffer(&kexec_buffer, &kexec_buffer_size);\n\tswitch (rc) {\n\tcase 0:\n\t\trc = ima_restore_measurement_list(kexec_buffer_size,\n\t\t\t\t\t\t  kexec_buffer);\n\t\tif (rc != 0)\n\t\t\tpr_err(\"Failed to restore the measurement list: %d\\n\",\n\t\t\t\trc);\n\n\t\tima_free_kexec_buffer();\n\t\tbreak;\n\tcase -ENOTSUPP:\n\t\tpr_debug(\"Restoring the measurement list not supported\\n\");\n\t\tbreak;\n\tcase -ENOENT:\n\t\tpr_debug(\"No measurement list to restore\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Error restoring the measurement list: %d\\n\", rc);\n\t}\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/kexec.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Error restoring the measurement list: %d\\n\"",
            "rc"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"No measurement list to restore\\n\""
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Restoring the measurement list not supported\\n\""
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_free_kexec_buffer",
          "args": [],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Failed to restore the measurement list: %d\\n\"",
            "rc"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_restore_measurement_list",
          "args": [
            "kexec_buffer_size",
            "kexec_buffer"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "ima_restore_measurement_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "323-436",
          "snippet": "int ima_restore_measurement_list(loff_t size, void *buf)\n{\n\tchar template_name[MAX_TEMPLATE_NAME_LEN];\n\n\tstruct ima_kexec_hdr *khdr = buf;\n\tstruct ima_field_data hdr[HDR__LAST] = {\n\t\t[HDR_PCR] = {.len = sizeof(u32)},\n\t\t[HDR_DIGEST] = {.len = TPM_DIGEST_SIZE},\n\t};\n\n\tvoid *bufp = buf + sizeof(*khdr);\n\tvoid *bufendp;\n\tstruct ima_template_entry *entry;\n\tstruct ima_template_desc *template_desc;\n\tDECLARE_BITMAP(hdr_mask, HDR__LAST);\n\tunsigned long count = 0;\n\tint ret = 0;\n\n\tif (!buf || size < sizeof(*khdr))\n\t\treturn 0;\n\n\tif (ima_canonical_fmt) {\n\t\tkhdr->version = le16_to_cpu(khdr->version);\n\t\tkhdr->count = le64_to_cpu(khdr->count);\n\t\tkhdr->buffer_size = le64_to_cpu(khdr->buffer_size);\n\t}\n\n\tif (khdr->version != 1) {\n\t\tpr_err(\"attempting to restore a incompatible measurement list\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (khdr->count > ULONG_MAX - 1) {\n\t\tpr_err(\"attempting to restore too many measurements\");\n\t\treturn -EINVAL;\n\t}\n\n\tbitmap_zero(hdr_mask, HDR__LAST);\n\tbitmap_set(hdr_mask, HDR_PCR, 1);\n\tbitmap_set(hdr_mask, HDR_DIGEST, 1);\n\n\t/*\n\t * ima kexec buffer prefix: version, buffer size, count\n\t * v1 format: pcr, digest, template-name-len, template-name,\n\t *\t      template-data-size, template-data\n\t */\n\tbufendp = buf + khdr->buffer_size;\n\twhile ((bufp < bufendp) && (count++ < khdr->count)) {\n\t\tint enforce_mask = ENFORCE_FIELDS;\n\n\t\tenforce_mask |= (count == khdr->count) ? ENFORCE_BUFEND : 0;\n\t\tret = ima_parse_buf(bufp, bufendp, &bufp, HDR__LAST, hdr, NULL,\n\t\t\t\t    hdr_mask, enforce_mask, \"entry header\");\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (hdr[HDR_TEMPLATE_NAME].len >= MAX_TEMPLATE_NAME_LEN) {\n\t\t\tpr_err(\"attempting to restore a template name \\\n\t\t\t\tthat is too long\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* template name is not null terminated */\n\t\tmemcpy(template_name, hdr[HDR_TEMPLATE_NAME].data,\n\t\t       hdr[HDR_TEMPLATE_NAME].len);\n\t\ttemplate_name[hdr[HDR_TEMPLATE_NAME].len] = 0;\n\n\t\tif (strcmp(template_name, \"ima\") == 0) {\n\t\t\tpr_err(\"attempting to restore an unsupported \\\n\t\t\t\ttemplate \\\"%s\\\" failed\\n\", template_name);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttemplate_desc = lookup_template_desc(template_name);\n\t\tif (!template_desc) {\n\t\t\ttemplate_desc = restore_template_fmt(template_name);\n\t\t\tif (!template_desc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Only the running system's template format is initialized\n\t\t * on boot.  As needed, initialize the other template formats.\n\t\t */\n\t\tret = template_desc_init_fields(template_desc->fmt,\n\t\t\t\t\t\t&(template_desc->fields),\n\t\t\t\t\t\t&(template_desc->num_fields));\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"attempting to restore the template fmt \\\"%s\\\" \\\n\t\t\t\tfailed\\n\", template_desc->fmt);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ima_restore_template_data(template_desc,\n\t\t\t\t\t\thdr[HDR_TEMPLATE_DATA].data,\n\t\t\t\t\t\thdr[HDR_TEMPLATE_DATA].len,\n\t\t\t\t\t\t&entry);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tmemcpy(entry->digest, hdr[HDR_DIGEST].data,\n\t\t       hdr[HDR_DIGEST].len);\n\t\tentry->pcr = !ima_canonical_fmt ? *(hdr[HDR_PCR].data) :\n\t\t\t     le32_to_cpu(*(hdr[HDR_PCR].data));\n\t\tret = ima_restore_measurement_entry(entry);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [
            "#define MAX_TEMPLATE_NAME_LEN 15"
          ],
          "globals_used": [
            "static struct ima_template_desc *lookup_template_desc(const char *name);",
            "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\n#define MAX_TEMPLATE_NAME_LEN 15\n\nstatic struct ima_template_desc *lookup_template_desc(const char *name);\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);\n\nint ima_restore_measurement_list(loff_t size, void *buf)\n{\n\tchar template_name[MAX_TEMPLATE_NAME_LEN];\n\n\tstruct ima_kexec_hdr *khdr = buf;\n\tstruct ima_field_data hdr[HDR__LAST] = {\n\t\t[HDR_PCR] = {.len = sizeof(u32)},\n\t\t[HDR_DIGEST] = {.len = TPM_DIGEST_SIZE},\n\t};\n\n\tvoid *bufp = buf + sizeof(*khdr);\n\tvoid *bufendp;\n\tstruct ima_template_entry *entry;\n\tstruct ima_template_desc *template_desc;\n\tDECLARE_BITMAP(hdr_mask, HDR__LAST);\n\tunsigned long count = 0;\n\tint ret = 0;\n\n\tif (!buf || size < sizeof(*khdr))\n\t\treturn 0;\n\n\tif (ima_canonical_fmt) {\n\t\tkhdr->version = le16_to_cpu(khdr->version);\n\t\tkhdr->count = le64_to_cpu(khdr->count);\n\t\tkhdr->buffer_size = le64_to_cpu(khdr->buffer_size);\n\t}\n\n\tif (khdr->version != 1) {\n\t\tpr_err(\"attempting to restore a incompatible measurement list\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (khdr->count > ULONG_MAX - 1) {\n\t\tpr_err(\"attempting to restore too many measurements\");\n\t\treturn -EINVAL;\n\t}\n\n\tbitmap_zero(hdr_mask, HDR__LAST);\n\tbitmap_set(hdr_mask, HDR_PCR, 1);\n\tbitmap_set(hdr_mask, HDR_DIGEST, 1);\n\n\t/*\n\t * ima kexec buffer prefix: version, buffer size, count\n\t * v1 format: pcr, digest, template-name-len, template-name,\n\t *\t      template-data-size, template-data\n\t */\n\tbufendp = buf + khdr->buffer_size;\n\twhile ((bufp < bufendp) && (count++ < khdr->count)) {\n\t\tint enforce_mask = ENFORCE_FIELDS;\n\n\t\tenforce_mask |= (count == khdr->count) ? ENFORCE_BUFEND : 0;\n\t\tret = ima_parse_buf(bufp, bufendp, &bufp, HDR__LAST, hdr, NULL,\n\t\t\t\t    hdr_mask, enforce_mask, \"entry header\");\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (hdr[HDR_TEMPLATE_NAME].len >= MAX_TEMPLATE_NAME_LEN) {\n\t\t\tpr_err(\"attempting to restore a template name \\\n\t\t\t\tthat is too long\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* template name is not null terminated */\n\t\tmemcpy(template_name, hdr[HDR_TEMPLATE_NAME].data,\n\t\t       hdr[HDR_TEMPLATE_NAME].len);\n\t\ttemplate_name[hdr[HDR_TEMPLATE_NAME].len] = 0;\n\n\t\tif (strcmp(template_name, \"ima\") == 0) {\n\t\t\tpr_err(\"attempting to restore an unsupported \\\n\t\t\t\ttemplate \\\"%s\\\" failed\\n\", template_name);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttemplate_desc = lookup_template_desc(template_name);\n\t\tif (!template_desc) {\n\t\t\ttemplate_desc = restore_template_fmt(template_name);\n\t\t\tif (!template_desc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Only the running system's template format is initialized\n\t\t * on boot.  As needed, initialize the other template formats.\n\t\t */\n\t\tret = template_desc_init_fields(template_desc->fmt,\n\t\t\t\t\t\t&(template_desc->fields),\n\t\t\t\t\t\t&(template_desc->num_fields));\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"attempting to restore the template fmt \\\"%s\\\" \\\n\t\t\t\tfailed\\n\", template_desc->fmt);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ima_restore_template_data(template_desc,\n\t\t\t\t\t\thdr[HDR_TEMPLATE_DATA].data,\n\t\t\t\t\t\thdr[HDR_TEMPLATE_DATA].len,\n\t\t\t\t\t\t&entry);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tmemcpy(entry->digest, hdr[HDR_DIGEST].data,\n\t\t       hdr[HDR_DIGEST].len);\n\t\tentry->pcr = !ima_canonical_fmt ? *(hdr[HDR_PCR].data) :\n\t\t\t     le32_to_cpu(*(hdr[HDR_PCR].data));\n\t\tret = ima_restore_measurement_entry(entry);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_get_kexec_buffer",
          "args": [
            "&kexec_buffer",
            "&kexec_buffer_size"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/kexec.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n\nvoid ima_load_kexec_buffer(void)\n{\n\tvoid *kexec_buffer = NULL;\n\tsize_t kexec_buffer_size = 0;\n\tint rc;\n\n\trc = ima_get_kexec_buffer(&kexec_buffer, &kexec_buffer_size);\n\tswitch (rc) {\n\tcase 0:\n\t\trc = ima_restore_measurement_list(kexec_buffer_size,\n\t\t\t\t\t\t  kexec_buffer);\n\t\tif (rc != 0)\n\t\t\tpr_err(\"Failed to restore the measurement list: %d\\n\",\n\t\t\t\trc);\n\n\t\tima_free_kexec_buffer();\n\t\tbreak;\n\tcase -ENOTSUPP:\n\t\tpr_debug(\"Restoring the measurement list not supported\\n\");\n\t\tbreak;\n\tcase -ENOENT:\n\t\tpr_debug(\"No measurement list to restore\\n\");\n\t\tbreak;\n\tdefault:\n\t\tpr_debug(\"Error restoring the measurement list: %d\\n\", rc);\n\t}\n}"
  },
  {
    "function_name": "ima_add_kexec_buffer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_kexec.c",
    "lines": "83-136",
    "snippet": "void ima_add_kexec_buffer(struct kimage *image)\n{\n\tstruct kexec_buf kbuf = { .image = image, .buf_align = PAGE_SIZE,\n\t\t\t\t  .buf_min = 0, .buf_max = ULONG_MAX,\n\t\t\t\t  .top_down = true };\n\tunsigned long binary_runtime_size;\n\n\t/* use more understandable variable names than defined in kbuf */\n\tvoid *kexec_buffer = NULL;\n\tsize_t kexec_buffer_size;\n\tsize_t kexec_segment_size;\n\tint ret;\n\n\t/*\n\t * Reserve an extra half page of memory for additional measurements\n\t * added during the kexec load.\n\t */\n\tbinary_runtime_size = ima_get_binary_runtime_size();\n\tif (binary_runtime_size >= ULONG_MAX - PAGE_SIZE)\n\t\tkexec_segment_size = ULONG_MAX;\n\telse\n\t\tkexec_segment_size = ALIGN(ima_get_binary_runtime_size() +\n\t\t\t\t\t   PAGE_SIZE / 2, PAGE_SIZE);\n\tif ((kexec_segment_size == ULONG_MAX) ||\n\t    ((kexec_segment_size >> PAGE_SHIFT) > totalram_pages / 2)) {\n\t\tpr_err(\"Binary measurement list too large.\\n\");\n\t\treturn;\n\t}\n\n\tima_dump_measurement_list(&kexec_buffer_size, &kexec_buffer,\n\t\t\t\t  kexec_segment_size);\n\tif (!kexec_buffer) {\n\t\tpr_err(\"Not enough memory for the kexec measurement buffer.\\n\");\n\t\treturn;\n\t}\n\n\tkbuf.buffer = kexec_buffer;\n\tkbuf.bufsz = kexec_buffer_size;\n\tkbuf.memsz = kexec_segment_size;\n\tret = kexec_add_buffer(&kbuf);\n\tif (ret) {\n\t\tpr_err(\"Error passing over kexec measurement buffer.\\n\");\n\t\treturn;\n\t}\n\n\tret = arch_ima_add_kexec_buffer(image, kbuf.mem, kexec_segment_size);\n\tif (ret) {\n\t\tpr_err(\"Error passing over kexec measurement buffer.\\n\");\n\t\treturn;\n\t}\n\n\tpr_debug(\"kexec measurement buffer for the loaded kernel at 0x%lx.\\n\",\n\t\t kbuf.mem);\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/kexec.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"kexec measurement buffer for the loaded kernel at 0x%lx.\\n\"",
            "kbuf.mem"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error passing over kexec measurement buffer.\\n\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_ima_add_kexec_buffer",
          "args": [
            "image",
            "kbuf.mem",
            "kexec_segment_size"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Error passing over kexec measurement buffer.\\n\""
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kexec_add_buffer",
          "args": [
            "&kbuf"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Not enough memory for the kexec measurement buffer.\\n\""
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_dump_measurement_list",
          "args": [
            "&kexec_buffer_size",
            "&kexec_buffer",
            "kexec_segment_size"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "ima_dump_measurement_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_kexec.c",
          "lines": "19-75",
          "snippet": "static int ima_dump_measurement_list(unsigned long *buffer_size, void **buffer,\n\t\t\t\t     unsigned long segment_size)\n{\n\tstruct ima_queue_entry *qe;\n\tstruct seq_file file;\n\tstruct ima_kexec_hdr khdr;\n\tint ret = 0;\n\n\t/* segment size can't change between kexec load and execute */\n\tfile.buf = vmalloc(segment_size);\n\tif (!file.buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfile.size = segment_size;\n\tfile.read_pos = 0;\n\tfile.count = sizeof(khdr);\t/* reserved space */\n\n\tmemset(&khdr, 0, sizeof(khdr));\n\tkhdr.version = 1;\n\tlist_for_each_entry_rcu(qe, &ima_measurements, later) {\n\t\tif (file.count < file.size) {\n\t\t\tkhdr.count++;\n\t\t\tima_measurements_show(&file, qe);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * fill in reserved space with some buffer details\n\t * (eg. version, buffer size, number of measurements)\n\t */\n\tkhdr.buffer_size = file.count;\n\tif (ima_canonical_fmt) {\n\t\tkhdr.version = cpu_to_le16(khdr.version);\n\t\tkhdr.count = cpu_to_le64(khdr.count);\n\t\tkhdr.buffer_size = cpu_to_le64(khdr.buffer_size);\n\t}\n\tmemcpy(file.buf, &khdr, sizeof(khdr));\n\n\tprint_hex_dump(KERN_DEBUG, \"ima dump: \", DUMP_PREFIX_NONE,\n\t\t\t16, 1, file.buf,\n\t\t\tfile.count < 100 ? file.count : 100, true);\n\n\t*buffer_size = file.count;\n\t*buffer = file.buf;\nout:\n\tif (ret == -EINVAL)\n\t\tvfree(file.buf);\n\treturn ret;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/kexec.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/seq_file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/kexec.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n\nstatic int ima_dump_measurement_list(unsigned long *buffer_size, void **buffer,\n\t\t\t\t     unsigned long segment_size)\n{\n\tstruct ima_queue_entry *qe;\n\tstruct seq_file file;\n\tstruct ima_kexec_hdr khdr;\n\tint ret = 0;\n\n\t/* segment size can't change between kexec load and execute */\n\tfile.buf = vmalloc(segment_size);\n\tif (!file.buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfile.size = segment_size;\n\tfile.read_pos = 0;\n\tfile.count = sizeof(khdr);\t/* reserved space */\n\n\tmemset(&khdr, 0, sizeof(khdr));\n\tkhdr.version = 1;\n\tlist_for_each_entry_rcu(qe, &ima_measurements, later) {\n\t\tif (file.count < file.size) {\n\t\t\tkhdr.count++;\n\t\t\tima_measurements_show(&file, qe);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * fill in reserved space with some buffer details\n\t * (eg. version, buffer size, number of measurements)\n\t */\n\tkhdr.buffer_size = file.count;\n\tif (ima_canonical_fmt) {\n\t\tkhdr.version = cpu_to_le16(khdr.version);\n\t\tkhdr.count = cpu_to_le64(khdr.count);\n\t\tkhdr.buffer_size = cpu_to_le64(khdr.buffer_size);\n\t}\n\tmemcpy(file.buf, &khdr, sizeof(khdr));\n\n\tprint_hex_dump(KERN_DEBUG, \"ima dump: \", DUMP_PREFIX_NONE,\n\t\t\t16, 1, file.buf,\n\t\t\tfile.count < 100 ? file.count : 100, true);\n\n\t*buffer_size = file.count;\n\t*buffer = file.buf;\nout:\n\tif (ret == -EINVAL)\n\t\tvfree(file.buf);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Binary measurement list too large.\\n\""
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "ima_get_binary_runtime_size() +\n\t\t\t\t\t   PAGE_SIZE / 2",
            "PAGE_SIZE"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_get_binary_runtime_size",
          "args": [],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "ima_get_binary_runtime_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
          "lines": "133-139",
          "snippet": "unsigned long ima_get_binary_runtime_size(void)\n{\n\tif (binary_runtime_size >= (ULONG_MAX - sizeof(struct ima_kexec_hdr)))\n\t\treturn ULONG_MAX;\n\telse\n\t\treturn binary_runtime_size + sizeof(struct ima_kexec_hdr);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nunsigned long ima_get_binary_runtime_size(void)\n{\n\tif (binary_runtime_size >= (ULONG_MAX - sizeof(struct ima_kexec_hdr)))\n\t\treturn ULONG_MAX;\n\telse\n\t\treturn binary_runtime_size + sizeof(struct ima_kexec_hdr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/kexec.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n\nvoid ima_add_kexec_buffer(struct kimage *image)\n{\n\tstruct kexec_buf kbuf = { .image = image, .buf_align = PAGE_SIZE,\n\t\t\t\t  .buf_min = 0, .buf_max = ULONG_MAX,\n\t\t\t\t  .top_down = true };\n\tunsigned long binary_runtime_size;\n\n\t/* use more understandable variable names than defined in kbuf */\n\tvoid *kexec_buffer = NULL;\n\tsize_t kexec_buffer_size;\n\tsize_t kexec_segment_size;\n\tint ret;\n\n\t/*\n\t * Reserve an extra half page of memory for additional measurements\n\t * added during the kexec load.\n\t */\n\tbinary_runtime_size = ima_get_binary_runtime_size();\n\tif (binary_runtime_size >= ULONG_MAX - PAGE_SIZE)\n\t\tkexec_segment_size = ULONG_MAX;\n\telse\n\t\tkexec_segment_size = ALIGN(ima_get_binary_runtime_size() +\n\t\t\t\t\t   PAGE_SIZE / 2, PAGE_SIZE);\n\tif ((kexec_segment_size == ULONG_MAX) ||\n\t    ((kexec_segment_size >> PAGE_SHIFT) > totalram_pages / 2)) {\n\t\tpr_err(\"Binary measurement list too large.\\n\");\n\t\treturn;\n\t}\n\n\tima_dump_measurement_list(&kexec_buffer_size, &kexec_buffer,\n\t\t\t\t  kexec_segment_size);\n\tif (!kexec_buffer) {\n\t\tpr_err(\"Not enough memory for the kexec measurement buffer.\\n\");\n\t\treturn;\n\t}\n\n\tkbuf.buffer = kexec_buffer;\n\tkbuf.bufsz = kexec_buffer_size;\n\tkbuf.memsz = kexec_segment_size;\n\tret = kexec_add_buffer(&kbuf);\n\tif (ret) {\n\t\tpr_err(\"Error passing over kexec measurement buffer.\\n\");\n\t\treturn;\n\t}\n\n\tret = arch_ima_add_kexec_buffer(image, kbuf.mem, kexec_segment_size);\n\tif (ret) {\n\t\tpr_err(\"Error passing over kexec measurement buffer.\\n\");\n\t\treturn;\n\t}\n\n\tpr_debug(\"kexec measurement buffer for the loaded kernel at 0x%lx.\\n\",\n\t\t kbuf.mem);\n}"
  },
  {
    "function_name": "ima_dump_measurement_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_kexec.c",
    "lines": "19-75",
    "snippet": "static int ima_dump_measurement_list(unsigned long *buffer_size, void **buffer,\n\t\t\t\t     unsigned long segment_size)\n{\n\tstruct ima_queue_entry *qe;\n\tstruct seq_file file;\n\tstruct ima_kexec_hdr khdr;\n\tint ret = 0;\n\n\t/* segment size can't change between kexec load and execute */\n\tfile.buf = vmalloc(segment_size);\n\tif (!file.buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfile.size = segment_size;\n\tfile.read_pos = 0;\n\tfile.count = sizeof(khdr);\t/* reserved space */\n\n\tmemset(&khdr, 0, sizeof(khdr));\n\tkhdr.version = 1;\n\tlist_for_each_entry_rcu(qe, &ima_measurements, later) {\n\t\tif (file.count < file.size) {\n\t\t\tkhdr.count++;\n\t\t\tima_measurements_show(&file, qe);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * fill in reserved space with some buffer details\n\t * (eg. version, buffer size, number of measurements)\n\t */\n\tkhdr.buffer_size = file.count;\n\tif (ima_canonical_fmt) {\n\t\tkhdr.version = cpu_to_le16(khdr.version);\n\t\tkhdr.count = cpu_to_le64(khdr.count);\n\t\tkhdr.buffer_size = cpu_to_le64(khdr.buffer_size);\n\t}\n\tmemcpy(file.buf, &khdr, sizeof(khdr));\n\n\tprint_hex_dump(KERN_DEBUG, \"ima dump: \", DUMP_PREFIX_NONE,\n\t\t\t16, 1, file.buf,\n\t\t\tfile.count < 100 ? file.count : 100, true);\n\n\t*buffer_size = file.count;\n\t*buffer = file.buf;\nout:\n\tif (ret == -EINVAL)\n\t\tvfree(file.buf);\n\treturn ret;\n}",
    "includes": [
      "#include \"ima.h\"",
      "#include <linux/kexec.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/seq_file.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfree",
          "args": [
            "file.buf"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_hex_dump",
          "args": [
            "KERN_DEBUG",
            "\"ima dump: \"",
            "DUMP_PREFIX_NONE",
            "16",
            "1",
            "file.buf",
            "file.count < 100 ? file.count : 100",
            "true"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "file.buf",
            "&khdr",
            "sizeof(khdr)"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "khdr.buffer_size"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le64",
          "args": [
            "khdr.count"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "khdr.version"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_measurements_show",
          "args": [
            "&file",
            "qe"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "ima_measurements_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_fs.c",
          "lines": "129-188",
          "snippet": "int ima_measurements_show(struct seq_file *m, void *v)\n{\n\t/* the list never shrinks, so we don't need a lock here */\n\tstruct ima_queue_entry *qe = v;\n\tstruct ima_template_entry *e;\n\tchar *template_name;\n\tu32 pcr, namelen, template_data_len; /* temporary fields */\n\tbool is_ima_template = false;\n\tint i;\n\n\t/* get entry */\n\te = qe->entry;\n\tif (e == NULL)\n\t\treturn -1;\n\n\ttemplate_name = (e->template_desc->name[0] != '\\0') ?\n\t    e->template_desc->name : e->template_desc->fmt;\n\n\t/*\n\t * 1st: PCRIndex\n\t * PCR used defaults to the same (config option) in\n\t * little-endian format, unless set in policy\n\t */\n\tpcr = !ima_canonical_fmt ? e->pcr : cpu_to_le32(e->pcr);\n\tima_putc(m, &pcr, sizeof(e->pcr));\n\n\t/* 2nd: template digest */\n\tima_putc(m, e->digest, TPM_DIGEST_SIZE);\n\n\t/* 3rd: template name size */\n\tnamelen = !ima_canonical_fmt ? strlen(template_name) :\n\t\tcpu_to_le32(strlen(template_name));\n\tima_putc(m, &namelen, sizeof(namelen));\n\n\t/* 4th:  template name */\n\tima_putc(m, template_name, strlen(template_name));\n\n\t/* 5th:  template length (except for 'ima' template) */\n\tif (strcmp(template_name, IMA_TEMPLATE_IMA_NAME) == 0)\n\t\tis_ima_template = true;\n\n\tif (!is_ima_template) {\n\t\ttemplate_data_len = !ima_canonical_fmt ? e->template_data_len :\n\t\t\tcpu_to_le32(e->template_data_len);\n\t\tima_putc(m, &template_data_len, sizeof(e->template_data_len));\n\t}\n\n\t/* 6th:  template specific data */\n\tfor (i = 0; i < e->template_desc->num_fields; i++) {\n\t\tenum ima_show_type show = IMA_SHOW_BINARY;\n\t\tstruct ima_template_field *field = e->template_desc->fields[i];\n\n\t\tif (is_ima_template && strcmp(field->field_id, \"d\") == 0)\n\t\t\tshow = IMA_SHOW_BINARY_NO_FIELD_LEN;\n\t\tif (is_ima_template && strcmp(field->field_id, \"n\") == 0)\n\t\t\tshow = IMA_SHOW_BINARY_OLD_STRING_FMT;\n\t\tfield->field_show(m, show, &e->template_data[i]);\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/parser.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/rculist.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>",
            "#include <linux/fcntl.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool ima_canonical_fmt;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/vmalloc.h>\n#include <linux/parser.h>\n#include <linux/rcupdate.h>\n#include <linux/rculist.h>\n#include <linux/seq_file.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/fcntl.h>\n\nbool ima_canonical_fmt;\n\nint ima_measurements_show(struct seq_file *m, void *v)\n{\n\t/* the list never shrinks, so we don't need a lock here */\n\tstruct ima_queue_entry *qe = v;\n\tstruct ima_template_entry *e;\n\tchar *template_name;\n\tu32 pcr, namelen, template_data_len; /* temporary fields */\n\tbool is_ima_template = false;\n\tint i;\n\n\t/* get entry */\n\te = qe->entry;\n\tif (e == NULL)\n\t\treturn -1;\n\n\ttemplate_name = (e->template_desc->name[0] != '\\0') ?\n\t    e->template_desc->name : e->template_desc->fmt;\n\n\t/*\n\t * 1st: PCRIndex\n\t * PCR used defaults to the same (config option) in\n\t * little-endian format, unless set in policy\n\t */\n\tpcr = !ima_canonical_fmt ? e->pcr : cpu_to_le32(e->pcr);\n\tima_putc(m, &pcr, sizeof(e->pcr));\n\n\t/* 2nd: template digest */\n\tima_putc(m, e->digest, TPM_DIGEST_SIZE);\n\n\t/* 3rd: template name size */\n\tnamelen = !ima_canonical_fmt ? strlen(template_name) :\n\t\tcpu_to_le32(strlen(template_name));\n\tima_putc(m, &namelen, sizeof(namelen));\n\n\t/* 4th:  template name */\n\tima_putc(m, template_name, strlen(template_name));\n\n\t/* 5th:  template length (except for 'ima' template) */\n\tif (strcmp(template_name, IMA_TEMPLATE_IMA_NAME) == 0)\n\t\tis_ima_template = true;\n\n\tif (!is_ima_template) {\n\t\ttemplate_data_len = !ima_canonical_fmt ? e->template_data_len :\n\t\t\tcpu_to_le32(e->template_data_len);\n\t\tima_putc(m, &template_data_len, sizeof(e->template_data_len));\n\t}\n\n\t/* 6th:  template specific data */\n\tfor (i = 0; i < e->template_desc->num_fields; i++) {\n\t\tenum ima_show_type show = IMA_SHOW_BINARY;\n\t\tstruct ima_template_field *field = e->template_desc->fields[i];\n\n\t\tif (is_ima_template && strcmp(field->field_id, \"d\") == 0)\n\t\t\tshow = IMA_SHOW_BINARY_NO_FIELD_LEN;\n\t\tif (is_ima_template && strcmp(field->field_id, \"n\") == 0)\n\t\t\tshow = IMA_SHOW_BINARY_OLD_STRING_FMT;\n\t\tfield->field_show(m, show, &e->template_data[i]);\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "qe",
            "&ima_measurements",
            "later"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&khdr",
            "0",
            "sizeof(khdr)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vmalloc",
          "args": [
            "segment_size"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima.h\"\n#include <linux/kexec.h>\n#include <linux/vmalloc.h>\n#include <linux/seq_file.h>\n\nstatic int ima_dump_measurement_list(unsigned long *buffer_size, void **buffer,\n\t\t\t\t     unsigned long segment_size)\n{\n\tstruct ima_queue_entry *qe;\n\tstruct seq_file file;\n\tstruct ima_kexec_hdr khdr;\n\tint ret = 0;\n\n\t/* segment size can't change between kexec load and execute */\n\tfile.buf = vmalloc(segment_size);\n\tif (!file.buf) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tfile.size = segment_size;\n\tfile.read_pos = 0;\n\tfile.count = sizeof(khdr);\t/* reserved space */\n\n\tmemset(&khdr, 0, sizeof(khdr));\n\tkhdr.version = 1;\n\tlist_for_each_entry_rcu(qe, &ima_measurements, later) {\n\t\tif (file.count < file.size) {\n\t\t\tkhdr.count++;\n\t\t\tima_measurements_show(&file, qe);\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/*\n\t * fill in reserved space with some buffer details\n\t * (eg. version, buffer size, number of measurements)\n\t */\n\tkhdr.buffer_size = file.count;\n\tif (ima_canonical_fmt) {\n\t\tkhdr.version = cpu_to_le16(khdr.version);\n\t\tkhdr.count = cpu_to_le64(khdr.count);\n\t\tkhdr.buffer_size = cpu_to_le64(khdr.buffer_size);\n\t}\n\tmemcpy(file.buf, &khdr, sizeof(khdr));\n\n\tprint_hex_dump(KERN_DEBUG, \"ima dump: \", DUMP_PREFIX_NONE,\n\t\t\t16, 1, file.buf,\n\t\t\tfile.count < 100 ? file.count : 100, true);\n\n\t*buffer_size = file.count;\n\t*buffer = file.buf;\nout:\n\tif (ret == -EINVAL)\n\t\tvfree(file.buf);\n\treturn ret;\n}"
  }
]