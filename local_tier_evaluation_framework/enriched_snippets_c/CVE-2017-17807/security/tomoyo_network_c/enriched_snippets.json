[
  {
    "function_name": "tomoyo_socket_sendmsg_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "753-772",
    "snippet": "int tomoyo_socket_sendmsg_permission(struct socket *sock, struct msghdr *msg,\n\t\t\t\t     int size)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!msg->msg_name || !family ||\n\t    (type != SOCK_DGRAM && type != SOCK_RAW))\n\t\treturn 0;\n\taddress.protocol = type;\n\taddress.operation = TOMOYO_NETWORK_SEND;\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address((struct sockaddr *)\n\t\t\t\t\t\t msg->msg_name,\n\t\t\t\t\t\t msg->msg_namelen, &address);\n\treturn tomoyo_check_inet_address((struct sockaddr *) msg->msg_name,\n\t\t\t\t\t msg->msg_namelen,\n\t\t\t\t\t sock->sk->sk_protocol, &address);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_check_inet_address",
          "args": [
            "(struct sockaddr *) msg->msg_name",
            "msg->msg_namelen",
            "sock->sk->sk_protocol",
            "&address"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_inet_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "501-533",
          "snippet": "static int tomoyo_check_inet_address(const struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     const u16 port,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_inet_addr_info *i = &address->inet;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET6:\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = true;\n\t\ti->address = (__be32 *)\n\t\t\t((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr;\n\t\ti->port = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tcase AF_INET:\n\t\tif (addr_len < sizeof(struct sockaddr_in))\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = false;\n\t\ti->address = (__be32 *)\n\t\t\t&((struct sockaddr_in *) addr)->sin_addr;\n\t\ti->port = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tdefault:\n\t\tgoto skip;\n\t}\n\tif (address->protocol == SOCK_RAW)\n\t\ti->port = htons(port);\n\treturn tomoyo_inet_entry(address);\nskip:\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_check_inet_address(const struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     const u16 port,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_inet_addr_info *i = &address->inet;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET6:\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = true;\n\t\ti->address = (__be32 *)\n\t\t\t((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr;\n\t\ti->port = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tcase AF_INET:\n\t\tif (addr_len < sizeof(struct sockaddr_in))\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = false;\n\t\ti->address = (__be32 *)\n\t\t\t&((struct sockaddr_in *) addr)->sin_addr;\n\t\ti->port = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tdefault:\n\t\tgoto skip;\n\t}\n\tif (address->protocol == SOCK_RAW)\n\t\ti->port = htons(port);\n\treturn tomoyo_inet_entry(address);\nskip:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_check_unix_address",
          "args": [
            "(struct sockaddr *)\n\t\t\t\t\t\t msg->msg_name",
            "msg->msg_namelen",
            "&address"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_unix_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "591-602",
          "snippet": "static int tomoyo_check_unix_address(struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_unix_addr_info *u = &address->unix0;\n\n\tif (addr->sa_family != AF_UNIX)\n\t\treturn 0;\n\tu->addr = ((struct sockaddr_un *) addr)->sun_path;\n\tu->addr_len = addr_len;\n\treturn tomoyo_unix_entry(address);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_check_unix_address(struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_unix_addr_info *u = &address->unix0;\n\n\tif (addr->sa_family != AF_UNIX)\n\t\treturn 0;\n\tu->addr = ((struct sockaddr_un *) addr)->sun_path;\n\tu->addr_len = addr_len;\n\treturn tomoyo_unix_entry(address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_sock_family",
          "args": [
            "sock->sk"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_sock_family",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "622-637",
          "snippet": "static u8 tomoyo_sock_family(struct sock *sk)\n{\n\tu8 family;\n\n\tif (tomoyo_kernel_service())\n\t\treturn 0;\n\tfamily = sk->sk_family;\n\tswitch (family) {\n\tcase PF_INET:\n\tcase PF_INET6:\n\tcase PF_UNIX:\n\t\treturn family;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic u8 tomoyo_sock_family(struct sock *sk)\n{\n\tu8 family;\n\n\tif (tomoyo_kernel_service())\n\t\treturn 0;\n\tfamily = sk->sk_family;\n\tswitch (family) {\n\tcase PF_INET:\n\tcase PF_INET6:\n\tcase PF_UNIX:\n\t\treturn family;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nint tomoyo_socket_sendmsg_permission(struct socket *sock, struct msghdr *msg,\n\t\t\t\t     int size)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!msg->msg_name || !family ||\n\t    (type != SOCK_DGRAM && type != SOCK_RAW))\n\t\treturn 0;\n\taddress.protocol = type;\n\taddress.operation = TOMOYO_NETWORK_SEND;\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address((struct sockaddr *)\n\t\t\t\t\t\t msg->msg_name,\n\t\t\t\t\t\t msg->msg_namelen, &address);\n\treturn tomoyo_check_inet_address((struct sockaddr *) msg->msg_name,\n\t\t\t\t\t msg->msg_namelen,\n\t\t\t\t\t sock->sk->sk_protocol, &address);\n}"
  },
  {
    "function_name": "tomoyo_socket_bind_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "718-742",
    "snippet": "int tomoyo_socket_bind_permission(struct socket *sock, struct sockaddr *addr,\n\t\t\t\t  int addr_len)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!family)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SOCK_STREAM:\n\tcase SOCK_DGRAM:\n\tcase SOCK_RAW:\n\tcase SOCK_SEQPACKET:\n\t\taddress.protocol = type;\n\t\taddress.operation = TOMOYO_NETWORK_BIND;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address(addr, addr_len, &address);\n\treturn tomoyo_check_inet_address(addr, addr_len, sock->sk->sk_protocol,\n\t\t\t\t\t &address);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_check_inet_address",
          "args": [
            "addr",
            "addr_len",
            "sock->sk->sk_protocol",
            "&address"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_inet_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "501-533",
          "snippet": "static int tomoyo_check_inet_address(const struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     const u16 port,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_inet_addr_info *i = &address->inet;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET6:\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = true;\n\t\ti->address = (__be32 *)\n\t\t\t((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr;\n\t\ti->port = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tcase AF_INET:\n\t\tif (addr_len < sizeof(struct sockaddr_in))\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = false;\n\t\ti->address = (__be32 *)\n\t\t\t&((struct sockaddr_in *) addr)->sin_addr;\n\t\ti->port = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tdefault:\n\t\tgoto skip;\n\t}\n\tif (address->protocol == SOCK_RAW)\n\t\ti->port = htons(port);\n\treturn tomoyo_inet_entry(address);\nskip:\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_check_inet_address(const struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     const u16 port,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_inet_addr_info *i = &address->inet;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET6:\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = true;\n\t\ti->address = (__be32 *)\n\t\t\t((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr;\n\t\ti->port = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tcase AF_INET:\n\t\tif (addr_len < sizeof(struct sockaddr_in))\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = false;\n\t\ti->address = (__be32 *)\n\t\t\t&((struct sockaddr_in *) addr)->sin_addr;\n\t\ti->port = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tdefault:\n\t\tgoto skip;\n\t}\n\tif (address->protocol == SOCK_RAW)\n\t\ti->port = htons(port);\n\treturn tomoyo_inet_entry(address);\nskip:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_check_unix_address",
          "args": [
            "addr",
            "addr_len",
            "&address"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_unix_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "591-602",
          "snippet": "static int tomoyo_check_unix_address(struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_unix_addr_info *u = &address->unix0;\n\n\tif (addr->sa_family != AF_UNIX)\n\t\treturn 0;\n\tu->addr = ((struct sockaddr_un *) addr)->sun_path;\n\tu->addr_len = addr_len;\n\treturn tomoyo_unix_entry(address);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_check_unix_address(struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_unix_addr_info *u = &address->unix0;\n\n\tif (addr->sa_family != AF_UNIX)\n\t\treturn 0;\n\tu->addr = ((struct sockaddr_un *) addr)->sun_path;\n\tu->addr_len = addr_len;\n\treturn tomoyo_unix_entry(address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_sock_family",
          "args": [
            "sock->sk"
          ],
          "line": 722
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_sock_family",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "622-637",
          "snippet": "static u8 tomoyo_sock_family(struct sock *sk)\n{\n\tu8 family;\n\n\tif (tomoyo_kernel_service())\n\t\treturn 0;\n\tfamily = sk->sk_family;\n\tswitch (family) {\n\tcase PF_INET:\n\tcase PF_INET6:\n\tcase PF_UNIX:\n\t\treturn family;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic u8 tomoyo_sock_family(struct sock *sk)\n{\n\tu8 family;\n\n\tif (tomoyo_kernel_service())\n\t\treturn 0;\n\tfamily = sk->sk_family;\n\tswitch (family) {\n\tcase PF_INET:\n\tcase PF_INET6:\n\tcase PF_UNIX:\n\t\treturn family;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nint tomoyo_socket_bind_permission(struct socket *sock, struct sockaddr *addr,\n\t\t\t\t  int addr_len)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!family)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SOCK_STREAM:\n\tcase SOCK_DGRAM:\n\tcase SOCK_RAW:\n\tcase SOCK_SEQPACKET:\n\t\taddress.protocol = type;\n\t\taddress.operation = TOMOYO_NETWORK_BIND;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address(addr, addr_len, &address);\n\treturn tomoyo_check_inet_address(addr, addr_len, sock->sk->sk_protocol,\n\t\t\t\t\t &address);\n}"
  },
  {
    "function_name": "tomoyo_socket_connect_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "681-707",
    "snippet": "int tomoyo_socket_connect_permission(struct socket *sock,\n\t\t\t\t     struct sockaddr *addr, int addr_len)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!family)\n\t\treturn 0;\n\taddress.protocol = type;\n\tswitch (type) {\n\tcase SOCK_DGRAM:\n\tcase SOCK_RAW:\n\t\taddress.operation = TOMOYO_NETWORK_SEND;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\tcase SOCK_SEQPACKET:\n\t\taddress.operation = TOMOYO_NETWORK_CONNECT;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address(addr, addr_len, &address);\n\treturn tomoyo_check_inet_address(addr, addr_len, sock->sk->sk_protocol,\n\t\t\t\t\t &address);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_check_inet_address",
          "args": [
            "addr",
            "addr_len",
            "sock->sk->sk_protocol",
            "&address"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_inet_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "501-533",
          "snippet": "static int tomoyo_check_inet_address(const struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     const u16 port,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_inet_addr_info *i = &address->inet;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET6:\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = true;\n\t\ti->address = (__be32 *)\n\t\t\t((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr;\n\t\ti->port = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tcase AF_INET:\n\t\tif (addr_len < sizeof(struct sockaddr_in))\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = false;\n\t\ti->address = (__be32 *)\n\t\t\t&((struct sockaddr_in *) addr)->sin_addr;\n\t\ti->port = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tdefault:\n\t\tgoto skip;\n\t}\n\tif (address->protocol == SOCK_RAW)\n\t\ti->port = htons(port);\n\treturn tomoyo_inet_entry(address);\nskip:\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_check_inet_address(const struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     const u16 port,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_inet_addr_info *i = &address->inet;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET6:\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = true;\n\t\ti->address = (__be32 *)\n\t\t\t((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr;\n\t\ti->port = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tcase AF_INET:\n\t\tif (addr_len < sizeof(struct sockaddr_in))\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = false;\n\t\ti->address = (__be32 *)\n\t\t\t&((struct sockaddr_in *) addr)->sin_addr;\n\t\ti->port = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tdefault:\n\t\tgoto skip;\n\t}\n\tif (address->protocol == SOCK_RAW)\n\t\ti->port = htons(port);\n\treturn tomoyo_inet_entry(address);\nskip:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_check_unix_address",
          "args": [
            "addr",
            "addr_len",
            "&address"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_unix_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "591-602",
          "snippet": "static int tomoyo_check_unix_address(struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_unix_addr_info *u = &address->unix0;\n\n\tif (addr->sa_family != AF_UNIX)\n\t\treturn 0;\n\tu->addr = ((struct sockaddr_un *) addr)->sun_path;\n\tu->addr_len = addr_len;\n\treturn tomoyo_unix_entry(address);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_check_unix_address(struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_unix_addr_info *u = &address->unix0;\n\n\tif (addr->sa_family != AF_UNIX)\n\t\treturn 0;\n\tu->addr = ((struct sockaddr_un *) addr)->sun_path;\n\tu->addr_len = addr_len;\n\treturn tomoyo_unix_entry(address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_sock_family",
          "args": [
            "sock->sk"
          ],
          "line": 685
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_sock_family",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "622-637",
          "snippet": "static u8 tomoyo_sock_family(struct sock *sk)\n{\n\tu8 family;\n\n\tif (tomoyo_kernel_service())\n\t\treturn 0;\n\tfamily = sk->sk_family;\n\tswitch (family) {\n\tcase PF_INET:\n\tcase PF_INET6:\n\tcase PF_UNIX:\n\t\treturn family;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic u8 tomoyo_sock_family(struct sock *sk)\n{\n\tu8 family;\n\n\tif (tomoyo_kernel_service())\n\t\treturn 0;\n\tfamily = sk->sk_family;\n\tswitch (family) {\n\tcase PF_INET:\n\tcase PF_INET6:\n\tcase PF_UNIX:\n\t\treturn family;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nint tomoyo_socket_connect_permission(struct socket *sock,\n\t\t\t\t     struct sockaddr *addr, int addr_len)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!family)\n\t\treturn 0;\n\taddress.protocol = type;\n\tswitch (type) {\n\tcase SOCK_DGRAM:\n\tcase SOCK_RAW:\n\t\taddress.operation = TOMOYO_NETWORK_SEND;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\tcase SOCK_SEQPACKET:\n\t\taddress.operation = TOMOYO_NETWORK_CONNECT;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address(addr, addr_len, &address);\n\treturn tomoyo_check_inet_address(addr, addr_len, sock->sk->sk_protocol,\n\t\t\t\t\t &address);\n}"
  },
  {
    "function_name": "tomoyo_socket_listen_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "646-670",
    "snippet": "int tomoyo_socket_listen_permission(struct socket *sock)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\tstruct sockaddr_storage addr;\n\tint addr_len;\n\n\tif (!family || (type != SOCK_STREAM && type != SOCK_SEQPACKET))\n\t\treturn 0;\n\t{\n\t\tconst int error = sock->ops->getname(sock, (struct sockaddr *)\n\t\t\t\t\t\t     &addr, &addr_len, 0);\n\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\taddress.protocol = type;\n\taddress.operation = TOMOYO_NETWORK_LISTEN;\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address((struct sockaddr *) &addr,\n\t\t\t\t\t\t addr_len, &address);\n\treturn tomoyo_check_inet_address((struct sockaddr *) &addr, addr_len,\n\t\t\t\t\t 0, &address);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_check_inet_address",
          "args": [
            "(struct sockaddr *) &addr",
            "addr_len",
            "0",
            "&address"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_inet_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "501-533",
          "snippet": "static int tomoyo_check_inet_address(const struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     const u16 port,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_inet_addr_info *i = &address->inet;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET6:\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = true;\n\t\ti->address = (__be32 *)\n\t\t\t((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr;\n\t\ti->port = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tcase AF_INET:\n\t\tif (addr_len < sizeof(struct sockaddr_in))\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = false;\n\t\ti->address = (__be32 *)\n\t\t\t&((struct sockaddr_in *) addr)->sin_addr;\n\t\ti->port = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tdefault:\n\t\tgoto skip;\n\t}\n\tif (address->protocol == SOCK_RAW)\n\t\ti->port = htons(port);\n\treturn tomoyo_inet_entry(address);\nskip:\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_check_inet_address(const struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     const u16 port,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_inet_addr_info *i = &address->inet;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET6:\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = true;\n\t\ti->address = (__be32 *)\n\t\t\t((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr;\n\t\ti->port = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tcase AF_INET:\n\t\tif (addr_len < sizeof(struct sockaddr_in))\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = false;\n\t\ti->address = (__be32 *)\n\t\t\t&((struct sockaddr_in *) addr)->sin_addr;\n\t\ti->port = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tdefault:\n\t\tgoto skip;\n\t}\n\tif (address->protocol == SOCK_RAW)\n\t\ti->port = htons(port);\n\treturn tomoyo_inet_entry(address);\nskip:\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_check_unix_address",
          "args": [
            "(struct sockaddr *) &addr",
            "addr_len",
            "&address"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_unix_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "591-602",
          "snippet": "static int tomoyo_check_unix_address(struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_unix_addr_info *u = &address->unix0;\n\n\tif (addr->sa_family != AF_UNIX)\n\t\treturn 0;\n\tu->addr = ((struct sockaddr_un *) addr)->sun_path;\n\tu->addr_len = addr_len;\n\treturn tomoyo_unix_entry(address);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_check_unix_address(struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_unix_addr_info *u = &address->unix0;\n\n\tif (addr->sa_family != AF_UNIX)\n\t\treturn 0;\n\tu->addr = ((struct sockaddr_un *) addr)->sun_path;\n\tu->addr_len = addr_len;\n\treturn tomoyo_unix_entry(address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sock->ops->getname",
          "args": [
            "sock",
            "(struct sockaddr *)\n\t\t\t\t\t\t     &addr",
            "&addr_len",
            "0"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_sock_family",
          "args": [
            "sock->sk"
          ],
          "line": 649
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_sock_family",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "622-637",
          "snippet": "static u8 tomoyo_sock_family(struct sock *sk)\n{\n\tu8 family;\n\n\tif (tomoyo_kernel_service())\n\t\treturn 0;\n\tfamily = sk->sk_family;\n\tswitch (family) {\n\tcase PF_INET:\n\tcase PF_INET6:\n\tcase PF_UNIX:\n\t\treturn family;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic u8 tomoyo_sock_family(struct sock *sk)\n{\n\tu8 family;\n\n\tif (tomoyo_kernel_service())\n\t\treturn 0;\n\tfamily = sk->sk_family;\n\tswitch (family) {\n\tcase PF_INET:\n\tcase PF_INET6:\n\tcase PF_UNIX:\n\t\treturn family;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nint tomoyo_socket_listen_permission(struct socket *sock)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\tstruct sockaddr_storage addr;\n\tint addr_len;\n\n\tif (!family || (type != SOCK_STREAM && type != SOCK_SEQPACKET))\n\t\treturn 0;\n\t{\n\t\tconst int error = sock->ops->getname(sock, (struct sockaddr *)\n\t\t\t\t\t\t     &addr, &addr_len, 0);\n\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\taddress.protocol = type;\n\taddress.operation = TOMOYO_NETWORK_LISTEN;\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address((struct sockaddr *) &addr,\n\t\t\t\t\t\t addr_len, &address);\n\treturn tomoyo_check_inet_address((struct sockaddr *) &addr, addr_len,\n\t\t\t\t\t 0, &address);\n}"
  },
  {
    "function_name": "tomoyo_sock_family",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "622-637",
    "snippet": "static u8 tomoyo_sock_family(struct sock *sk)\n{\n\tu8 family;\n\n\tif (tomoyo_kernel_service())\n\t\treturn 0;\n\tfamily = sk->sk_family;\n\tswitch (family) {\n\tcase PF_INET:\n\tcase PF_INET6:\n\tcase PF_UNIX:\n\t\treturn family;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_kernel_service",
          "args": [],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_kernel_service",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "609-613",
          "snippet": "static bool tomoyo_kernel_service(void)\n{\n\t/* Nothing to do if I am a kernel service. */\n\treturn uaccess_kernel();\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_kernel_service(void)\n{\n\t/* Nothing to do if I am a kernel service. */\n\treturn uaccess_kernel();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic u8 tomoyo_sock_family(struct sock *sk)\n{\n\tu8 family;\n\n\tif (tomoyo_kernel_service())\n\t\treturn 0;\n\tfamily = sk->sk_family;\n\tswitch (family) {\n\tcase PF_INET:\n\tcase PF_INET6:\n\tcase PF_UNIX:\n\t\treturn family;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "tomoyo_kernel_service",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "609-613",
    "snippet": "static bool tomoyo_kernel_service(void)\n{\n\t/* Nothing to do if I am a kernel service. */\n\treturn uaccess_kernel();\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uaccess_kernel",
          "args": [],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_kernel_service(void)\n{\n\t/* Nothing to do if I am a kernel service. */\n\treturn uaccess_kernel();\n}"
  },
  {
    "function_name": "tomoyo_check_unix_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "591-602",
    "snippet": "static int tomoyo_check_unix_address(struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_unix_addr_info *u = &address->unix0;\n\n\tif (addr->sa_family != AF_UNIX)\n\t\treturn 0;\n\tu->addr = ((struct sockaddr_un *) addr)->sun_path;\n\tu->addr_len = addr_len;\n\treturn tomoyo_unix_entry(address);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_unix_entry",
          "args": [
            "address"
          ],
          "line": 601
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_unix_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "542-580",
          "snippet": "static int tomoyo_unix_entry(const struct tomoyo_addr_info *address)\n{\n\tconst int idx = tomoyo_read_lock();\n\tstruct tomoyo_request_info r;\n\tint error = 0;\n\tconst u8 type = tomoyo_unix2mac[address->protocol][address->operation];\n\n\tif (type && tomoyo_init_request_info(&r, NULL, type)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tchar *buf = address->unix0.addr;\n\t\tint len = address->unix0.addr_len - sizeof(sa_family_t);\n\n\t\tif (len <= 0) {\n\t\t\tbuf = \"anonymous\";\n\t\t\tlen = 9;\n\t\t} else if (buf[0]) {\n\t\t\tlen = strnlen(buf, len);\n\t\t}\n\t\tbuf = tomoyo_encode2(buf, len);\n\t\tif (buf) {\n\t\t\tstruct tomoyo_path_info addr;\n\n\t\t\taddr.name = buf;\n\t\t\ttomoyo_fill_path_info(&addr);\n\t\t\tr.param_type = TOMOYO_TYPE_UNIX_ACL;\n\t\t\tr.param.unix_network.protocol = address->protocol;\n\t\t\tr.param.unix_network.operation = address->operation;\n\t\t\tr.param.unix_network.address = &addr;\n\t\t\tdo {\n\t\t\t\ttomoyo_check_acl(&r, tomoyo_check_unix_acl);\n\t\t\t\terror = tomoyo_audit_unix_log(&r);\n\t\t\t} while (error == TOMOYO_RETRY_REQUEST);\n\t\t\tkfree(buf);\n\t\t} else\n\t\t\terror = -ENOMEM;\n\t}\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 tomoyo_unix2mac\n[TOMOYO_SOCK_MAX][TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[SOCK_STREAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT,\n\t},\n\t[SOCK_DGRAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND,\n\t},\n\t[SOCK_SEQPACKET] = {\n\t\t[TOMOYO_NETWORK_BIND]    =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const u8 tomoyo_unix2mac\n[TOMOYO_SOCK_MAX][TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[SOCK_STREAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT,\n\t},\n\t[SOCK_DGRAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND,\n\t},\n\t[SOCK_SEQPACKET] = {\n\t\t[TOMOYO_NETWORK_BIND]    =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT,\n\t},\n};\n\nstatic int tomoyo_unix_entry(const struct tomoyo_addr_info *address)\n{\n\tconst int idx = tomoyo_read_lock();\n\tstruct tomoyo_request_info r;\n\tint error = 0;\n\tconst u8 type = tomoyo_unix2mac[address->protocol][address->operation];\n\n\tif (type && tomoyo_init_request_info(&r, NULL, type)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tchar *buf = address->unix0.addr;\n\t\tint len = address->unix0.addr_len - sizeof(sa_family_t);\n\n\t\tif (len <= 0) {\n\t\t\tbuf = \"anonymous\";\n\t\t\tlen = 9;\n\t\t} else if (buf[0]) {\n\t\t\tlen = strnlen(buf, len);\n\t\t}\n\t\tbuf = tomoyo_encode2(buf, len);\n\t\tif (buf) {\n\t\t\tstruct tomoyo_path_info addr;\n\n\t\t\taddr.name = buf;\n\t\t\ttomoyo_fill_path_info(&addr);\n\t\t\tr.param_type = TOMOYO_TYPE_UNIX_ACL;\n\t\t\tr.param.unix_network.protocol = address->protocol;\n\t\t\tr.param.unix_network.operation = address->operation;\n\t\t\tr.param.unix_network.address = &addr;\n\t\t\tdo {\n\t\t\t\ttomoyo_check_acl(&r, tomoyo_check_unix_acl);\n\t\t\t\terror = tomoyo_audit_unix_log(&r);\n\t\t\t} while (error == TOMOYO_RETRY_REQUEST);\n\t\t\tkfree(buf);\n\t\t} else\n\t\t\terror = -ENOMEM;\n\t}\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_check_unix_address(struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_unix_addr_info *u = &address->unix0;\n\n\tif (addr->sa_family != AF_UNIX)\n\t\treturn 0;\n\tu->addr = ((struct sockaddr_un *) addr)->sun_path;\n\tu->addr_len = addr_len;\n\treturn tomoyo_unix_entry(address);\n}"
  },
  {
    "function_name": "tomoyo_unix_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "542-580",
    "snippet": "static int tomoyo_unix_entry(const struct tomoyo_addr_info *address)\n{\n\tconst int idx = tomoyo_read_lock();\n\tstruct tomoyo_request_info r;\n\tint error = 0;\n\tconst u8 type = tomoyo_unix2mac[address->protocol][address->operation];\n\n\tif (type && tomoyo_init_request_info(&r, NULL, type)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tchar *buf = address->unix0.addr;\n\t\tint len = address->unix0.addr_len - sizeof(sa_family_t);\n\n\t\tif (len <= 0) {\n\t\t\tbuf = \"anonymous\";\n\t\t\tlen = 9;\n\t\t} else if (buf[0]) {\n\t\t\tlen = strnlen(buf, len);\n\t\t}\n\t\tbuf = tomoyo_encode2(buf, len);\n\t\tif (buf) {\n\t\t\tstruct tomoyo_path_info addr;\n\n\t\t\taddr.name = buf;\n\t\t\ttomoyo_fill_path_info(&addr);\n\t\t\tr.param_type = TOMOYO_TYPE_UNIX_ACL;\n\t\t\tr.param.unix_network.protocol = address->protocol;\n\t\t\tr.param.unix_network.operation = address->operation;\n\t\t\tr.param.unix_network.address = &addr;\n\t\t\tdo {\n\t\t\t\ttomoyo_check_acl(&r, tomoyo_check_unix_acl);\n\t\t\t\terror = tomoyo_audit_unix_log(&r);\n\t\t\t} while (error == TOMOYO_RETRY_REQUEST);\n\t\t\tkfree(buf);\n\t\t} else\n\t\t\terror = -ENOMEM;\n\t}\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const u8 tomoyo_unix2mac\n[TOMOYO_SOCK_MAX][TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[SOCK_STREAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT,\n\t},\n\t[SOCK_DGRAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND,\n\t},\n\t[SOCK_SEQPACKET] = {\n\t\t[TOMOYO_NETWORK_BIND]    =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_read_unlock",
          "args": [
            "idx"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_audit_unix_log",
          "args": [
            "&r"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_audit_unix_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "404-409",
          "snippet": "static int tomoyo_audit_unix_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_audit_net_log(r, \"unix\", r->param.unix_network.protocol,\n\t\t\t\t    r->param.unix_network.operation,\n\t\t\t\t    r->param.unix_network.address->name);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_audit_unix_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_audit_net_log(r, \"unix\", r->param.unix_network.protocol,\n\t\t\t\t    r->param.unix_network.operation,\n\t\t\t\t    r->param.unix_network.address->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_check_acl",
          "args": [
            "&r",
            "tomoyo_check_unix_acl"
          ],
          "line": 571
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "159-186",
          "snippet": "void tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tbool retried = false;\n\tconst struct list_head *list = &domain->acl_info_list;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tif (!retried) {\n\t\tretried = true;\n\t\tlist = &domain->ns->acl_group[domain->group];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nvoid tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tbool retried = false;\n\tconst struct list_head *list = &domain->acl_info_list;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tif (!retried) {\n\t\tretried = true;\n\t\tlist = &domain->ns->acl_group[domain->group];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_fill_path_info",
          "args": [
            "&addr"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_fill_path_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "643-652",
          "snippet": "void tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nvoid tomoyo_fill_path_info(struct tomoyo_path_info *ptr)\n{\n\tconst char *name = ptr->name;\n\tconst int len = strlen(name);\n\n\tptr->const_len = tomoyo_const_part_length(name);\n\tptr->is_dir = len && (name[len - 1] == '/');\n\tptr->is_patterned = (ptr->const_len < len);\n\tptr->hash = full_name_hash(NULL, name, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_encode2",
          "args": [
            "buf",
            "len"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_encode2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/realpath.c",
          "lines": "22-65",
          "snippet": "char *tomoyo_encode2(const char *str, int str_len)\n{\n\tint i;\n\tint len = 0;\n\tconst char *p = str;\n\tchar *cp;\n\tchar *cp0;\n\n\tif (!p)\n\t\treturn NULL;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\')\n\t\t\tlen += 2;\n\t\telse if (c > ' ' && c < 127)\n\t\t\tlen++;\n\t\telse\n\t\t\tlen += 4;\n\t}\n\tlen++;\n\t/* Reserve space for appending \"/\". */\n\tcp = kzalloc(len + 10, GFP_NOFS);\n\tif (!cp)\n\t\treturn NULL;\n\tcp0 = cp;\n\tp = str;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\') {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = '\\\\';\n\t\t} else if (c > ' ' && c < 127) {\n\t\t\t*cp++ = c;\n\t\t} else {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = (c >> 6) + '0';\n\t\t\t*cp++ = ((c >> 3) & 7) + '0';\n\t\t\t*cp++ = (c & 7) + '0';\n\t\t}\n\t}\n\treturn cp0;\n}",
          "includes": [
            "#include <linux/magic.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/magic.h>\n#include \"common.h\"\n\nchar *tomoyo_encode2(const char *str, int str_len)\n{\n\tint i;\n\tint len = 0;\n\tconst char *p = str;\n\tchar *cp;\n\tchar *cp0;\n\n\tif (!p)\n\t\treturn NULL;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\')\n\t\t\tlen += 2;\n\t\telse if (c > ' ' && c < 127)\n\t\t\tlen++;\n\t\telse\n\t\t\tlen += 4;\n\t}\n\tlen++;\n\t/* Reserve space for appending \"/\". */\n\tcp = kzalloc(len + 10, GFP_NOFS);\n\tif (!cp)\n\t\treturn NULL;\n\tcp0 = cp;\n\tp = str;\n\tfor (i = 0; i < str_len; i++) {\n\t\tconst unsigned char c = p[i];\n\n\t\tif (c == '\\\\') {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = '\\\\';\n\t\t} else if (c > ' ' && c < 127) {\n\t\t\t*cp++ = c;\n\t\t} else {\n\t\t\t*cp++ = '\\\\';\n\t\t\t*cp++ = (c >> 6) + '0';\n\t\t\t*cp++ = ((c >> 3) & 7) + '0';\n\t\t\t*cp++ = (c & 7) + '0';\n\t\t}\n\t}\n\treturn cp0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strnlen",
          "args": [
            "buf",
            "len"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_init_request_info",
          "args": [
            "&r",
            "NULL",
            "type"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_init_request_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "984-997",
          "snippet": "int tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nint tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_lock",
          "args": [],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1096-1099",
          "snippet": "static inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const u8 tomoyo_unix2mac\n[TOMOYO_SOCK_MAX][TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[SOCK_STREAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_UNIX_STREAM_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_UNIX_STREAM_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_UNIX_STREAM_CONNECT,\n\t},\n\t[SOCK_DGRAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_UNIX_DGRAM_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_UNIX_DGRAM_SEND,\n\t},\n\t[SOCK_SEQPACKET] = {\n\t\t[TOMOYO_NETWORK_BIND]    =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_UNIX_SEQPACKET_CONNECT,\n\t},\n};\n\nstatic int tomoyo_unix_entry(const struct tomoyo_addr_info *address)\n{\n\tconst int idx = tomoyo_read_lock();\n\tstruct tomoyo_request_info r;\n\tint error = 0;\n\tconst u8 type = tomoyo_unix2mac[address->protocol][address->operation];\n\n\tif (type && tomoyo_init_request_info(&r, NULL, type)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tchar *buf = address->unix0.addr;\n\t\tint len = address->unix0.addr_len - sizeof(sa_family_t);\n\n\t\tif (len <= 0) {\n\t\t\tbuf = \"anonymous\";\n\t\t\tlen = 9;\n\t\t} else if (buf[0]) {\n\t\t\tlen = strnlen(buf, len);\n\t\t}\n\t\tbuf = tomoyo_encode2(buf, len);\n\t\tif (buf) {\n\t\t\tstruct tomoyo_path_info addr;\n\n\t\t\taddr.name = buf;\n\t\t\ttomoyo_fill_path_info(&addr);\n\t\t\tr.param_type = TOMOYO_TYPE_UNIX_ACL;\n\t\t\tr.param.unix_network.protocol = address->protocol;\n\t\t\tr.param.unix_network.operation = address->operation;\n\t\t\tr.param.unix_network.address = &addr;\n\t\t\tdo {\n\t\t\t\ttomoyo_check_acl(&r, tomoyo_check_unix_acl);\n\t\t\t\terror = tomoyo_audit_unix_log(&r);\n\t\t\t} while (error == TOMOYO_RETRY_REQUEST);\n\t\t\tkfree(buf);\n\t\t} else\n\t\t\terror = -ENOMEM;\n\t}\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_check_inet_address",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "501-533",
    "snippet": "static int tomoyo_check_inet_address(const struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     const u16 port,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_inet_addr_info *i = &address->inet;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET6:\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = true;\n\t\ti->address = (__be32 *)\n\t\t\t((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr;\n\t\ti->port = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tcase AF_INET:\n\t\tif (addr_len < sizeof(struct sockaddr_in))\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = false;\n\t\ti->address = (__be32 *)\n\t\t\t&((struct sockaddr_in *) addr)->sin_addr;\n\t\ti->port = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tdefault:\n\t\tgoto skip;\n\t}\n\tif (address->protocol == SOCK_RAW)\n\t\ti->port = htons(port);\n\treturn tomoyo_inet_entry(address);\nskip:\n\treturn 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_inet_entry",
          "args": [
            "address"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_inet_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "467-489",
          "snippet": "static int tomoyo_inet_entry(const struct tomoyo_addr_info *address)\n{\n\tconst int idx = tomoyo_read_lock();\n\tstruct tomoyo_request_info r;\n\tint error = 0;\n\tconst u8 type = tomoyo_inet2mac[address->protocol][address->operation];\n\n\tif (type && tomoyo_init_request_info(&r, NULL, type)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tr.param_type = TOMOYO_TYPE_INET_ACL;\n\t\tr.param.inet_network.protocol = address->protocol;\n\t\tr.param.inet_network.operation = address->operation;\n\t\tr.param.inet_network.is_ipv6 = address->inet.is_ipv6;\n\t\tr.param.inet_network.address = address->inet.address;\n\t\tr.param.inet_network.port = ntohs(address->inet.port);\n\t\tdo {\n\t\t\ttomoyo_check_acl(&r, tomoyo_check_inet_acl);\n\t\t\terror = tomoyo_audit_inet_log(&r);\n\t\t} while (error == TOMOYO_RETRY_REQUEST);\n\t}\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 tomoyo_inet2mac\n[TOMOYO_SOCK_MAX][TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[SOCK_STREAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_STREAM_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_INET_STREAM_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_INET_STREAM_CONNECT,\n\t},\n\t[SOCK_DGRAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_DGRAM_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_INET_DGRAM_SEND,\n\t},\n\t[SOCK_RAW]    = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_RAW_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_INET_RAW_SEND,\n\t},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const u8 tomoyo_inet2mac\n[TOMOYO_SOCK_MAX][TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[SOCK_STREAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_STREAM_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_INET_STREAM_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_INET_STREAM_CONNECT,\n\t},\n\t[SOCK_DGRAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_DGRAM_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_INET_DGRAM_SEND,\n\t},\n\t[SOCK_RAW]    = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_RAW_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_INET_RAW_SEND,\n\t},\n};\n\nstatic int tomoyo_inet_entry(const struct tomoyo_addr_info *address)\n{\n\tconst int idx = tomoyo_read_lock();\n\tstruct tomoyo_request_info r;\n\tint error = 0;\n\tconst u8 type = tomoyo_inet2mac[address->protocol][address->operation];\n\n\tif (type && tomoyo_init_request_info(&r, NULL, type)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tr.param_type = TOMOYO_TYPE_INET_ACL;\n\t\tr.param.inet_network.protocol = address->protocol;\n\t\tr.param.inet_network.operation = address->operation;\n\t\tr.param.inet_network.is_ipv6 = address->inet.is_ipv6;\n\t\tr.param.inet_network.address = address->inet.address;\n\t\tr.param.inet_network.port = ntohs(address->inet.port);\n\t\tdo {\n\t\t\ttomoyo_check_acl(&r, tomoyo_check_inet_acl);\n\t\t\terror = tomoyo_audit_inet_log(&r);\n\t\t} while (error == TOMOYO_RETRY_REQUEST);\n\t}\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htons",
          "args": [
            "port"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_check_inet_address(const struct sockaddr *addr,\n\t\t\t\t     const unsigned int addr_len,\n\t\t\t\t     const u16 port,\n\t\t\t\t     struct tomoyo_addr_info *address)\n{\n\tstruct tomoyo_inet_addr_info *i = &address->inet;\n\n\tswitch (addr->sa_family) {\n\tcase AF_INET6:\n\t\tif (addr_len < SIN6_LEN_RFC2133)\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = true;\n\t\ti->address = (__be32 *)\n\t\t\t((struct sockaddr_in6 *) addr)->sin6_addr.s6_addr;\n\t\ti->port = ((struct sockaddr_in6 *) addr)->sin6_port;\n\t\tbreak;\n\tcase AF_INET:\n\t\tif (addr_len < sizeof(struct sockaddr_in))\n\t\t\tgoto skip;\n\t\ti->is_ipv6 = false;\n\t\ti->address = (__be32 *)\n\t\t\t&((struct sockaddr_in *) addr)->sin_addr;\n\t\ti->port = ((struct sockaddr_in *) addr)->sin_port;\n\t\tbreak;\n\tdefault:\n\t\tgoto skip;\n\t}\n\tif (address->protocol == SOCK_RAW)\n\t\ti->port = htons(port);\n\treturn tomoyo_inet_entry(address);\nskip:\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_inet_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "467-489",
    "snippet": "static int tomoyo_inet_entry(const struct tomoyo_addr_info *address)\n{\n\tconst int idx = tomoyo_read_lock();\n\tstruct tomoyo_request_info r;\n\tint error = 0;\n\tconst u8 type = tomoyo_inet2mac[address->protocol][address->operation];\n\n\tif (type && tomoyo_init_request_info(&r, NULL, type)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tr.param_type = TOMOYO_TYPE_INET_ACL;\n\t\tr.param.inet_network.protocol = address->protocol;\n\t\tr.param.inet_network.operation = address->operation;\n\t\tr.param.inet_network.is_ipv6 = address->inet.is_ipv6;\n\t\tr.param.inet_network.address = address->inet.address;\n\t\tr.param.inet_network.port = ntohs(address->inet.port);\n\t\tdo {\n\t\t\ttomoyo_check_acl(&r, tomoyo_check_inet_acl);\n\t\t\terror = tomoyo_audit_inet_log(&r);\n\t\t} while (error == TOMOYO_RETRY_REQUEST);\n\t}\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const u8 tomoyo_inet2mac\n[TOMOYO_SOCK_MAX][TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[SOCK_STREAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_STREAM_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_INET_STREAM_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_INET_STREAM_CONNECT,\n\t},\n\t[SOCK_DGRAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_DGRAM_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_INET_DGRAM_SEND,\n\t},\n\t[SOCK_RAW]    = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_RAW_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_INET_RAW_SEND,\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_read_unlock",
          "args": [
            "idx"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_audit_inet_log",
          "args": [
            "&r"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_audit_inet_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "379-395",
          "snippet": "static int tomoyo_audit_inet_log(struct tomoyo_request_info *r)\n{\n\tchar buf[128];\n\tint len;\n\tconst __be32 *address = r->param.inet_network.address;\n\n\tif (r->param.inet_network.is_ipv6)\n\t\ttomoyo_print_ipv6(buf, sizeof(buf), (const struct in6_addr *)\n\t\t\t\t  address, (const struct in6_addr *) address);\n\telse\n\t\ttomoyo_print_ipv4(buf, sizeof(buf), address, address);\n\tlen = strlen(buf);\n\tsnprintf(buf + len, sizeof(buf) - len, \" %u\",\n\t\t r->param.inet_network.port);\n\treturn tomoyo_audit_net_log(r, \"inet\", r->param.inet_network.protocol,\n\t\t\t\t    r->param.inet_network.operation, buf);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_audit_inet_log(struct tomoyo_request_info *r)\n{\n\tchar buf[128];\n\tint len;\n\tconst __be32 *address = r->param.inet_network.address;\n\n\tif (r->param.inet_network.is_ipv6)\n\t\ttomoyo_print_ipv6(buf, sizeof(buf), (const struct in6_addr *)\n\t\t\t\t  address, (const struct in6_addr *) address);\n\telse\n\t\ttomoyo_print_ipv4(buf, sizeof(buf), address, address);\n\tlen = strlen(buf);\n\tsnprintf(buf + len, sizeof(buf) - len, \" %u\",\n\t\t r->param.inet_network.port);\n\treturn tomoyo_audit_net_log(r, \"inet\", r->param.inet_network.protocol,\n\t\t\t\t    r->param.inet_network.operation, buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_check_acl",
          "args": [
            "&r",
            "tomoyo_check_inet_acl"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_acl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "159-186",
          "snippet": "void tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tbool retried = false;\n\tconst struct list_head *list = &domain->acl_info_list;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tif (!retried) {\n\t\tretried = true;\n\t\tlist = &domain->ns->acl_group[domain->group];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nvoid tomoyo_check_acl(struct tomoyo_request_info *r,\n\t\t      bool (*check_entry) (struct tomoyo_request_info *,\n\t\t\t\t\t   const struct tomoyo_acl_info *))\n{\n\tconst struct tomoyo_domain_info *domain = r->domain;\n\tstruct tomoyo_acl_info *ptr;\n\tbool retried = false;\n\tconst struct list_head *list = &domain->acl_info_list;\n\nretry:\n\tlist_for_each_entry_rcu(ptr, list, list) {\n\t\tif (ptr->is_deleted || ptr->type != r->param_type)\n\t\t\tcontinue;\n\t\tif (!check_entry(r, ptr))\n\t\t\tcontinue;\n\t\tif (!tomoyo_condition(r, ptr->cond))\n\t\t\tcontinue;\n\t\tr->matched_acl = ptr;\n\t\tr->granted = true;\n\t\treturn;\n\t}\n\tif (!retried) {\n\t\tretried = true;\n\t\tlist = &domain->ns->acl_group[domain->group];\n\t\tgoto retry;\n\t}\n\tr->granted = false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "address->inet.port"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_init_request_info",
          "args": [
            "&r",
            "NULL",
            "type"
          ],
          "line": 474
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_init_request_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "984-997",
          "snippet": "int tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nint tomoyo_init_request_info(struct tomoyo_request_info *r,\n\t\t\t     struct tomoyo_domain_info *domain, const u8 index)\n{\n\tu8 profile;\n\tmemset(r, 0, sizeof(*r));\n\tif (!domain)\n\t\tdomain = tomoyo_domain();\n\tr->domain = domain;\n\tprofile = domain->profile;\n\tr->profile = profile;\n\tr->type = index;\n\tr->mode = tomoyo_get_mode(domain->ns, profile, index);\n\treturn r->mode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_lock",
          "args": [],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1096-1099",
          "snippet": "static inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const u8 tomoyo_inet2mac\n[TOMOYO_SOCK_MAX][TOMOYO_MAX_NETWORK_OPERATION] = {\n\t[SOCK_STREAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_STREAM_BIND,\n\t\t[TOMOYO_NETWORK_LISTEN]  =\n\t\tTOMOYO_MAC_NETWORK_INET_STREAM_LISTEN,\n\t\t[TOMOYO_NETWORK_CONNECT] =\n\t\tTOMOYO_MAC_NETWORK_INET_STREAM_CONNECT,\n\t},\n\t[SOCK_DGRAM] = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_DGRAM_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_INET_DGRAM_SEND,\n\t},\n\t[SOCK_RAW]    = {\n\t\t[TOMOYO_NETWORK_BIND]    = TOMOYO_MAC_NETWORK_INET_RAW_BIND,\n\t\t[TOMOYO_NETWORK_SEND]    = TOMOYO_MAC_NETWORK_INET_RAW_SEND,\n\t},\n};\n\nstatic int tomoyo_inet_entry(const struct tomoyo_addr_info *address)\n{\n\tconst int idx = tomoyo_read_lock();\n\tstruct tomoyo_request_info r;\n\tint error = 0;\n\tconst u8 type = tomoyo_inet2mac[address->protocol][address->operation];\n\n\tif (type && tomoyo_init_request_info(&r, NULL, type)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tr.param_type = TOMOYO_TYPE_INET_ACL;\n\t\tr.param.inet_network.protocol = address->protocol;\n\t\tr.param.inet_network.operation = address->operation;\n\t\tr.param.inet_network.is_ipv6 = address->inet.is_ipv6;\n\t\tr.param.inet_network.address = address->inet.address;\n\t\tr.param.inet_network.port = ntohs(address->inet.port);\n\t\tdo {\n\t\t\ttomoyo_check_acl(&r, tomoyo_check_inet_acl);\n\t\t\terror = tomoyo_audit_inet_log(&r);\n\t\t} while (error == TOMOYO_RETRY_REQUEST);\n\t}\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_check_unix_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "449-458",
    "snippet": "static bool tomoyo_check_unix_acl(struct tomoyo_request_info *r,\n\t\t\t\t  const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_unix_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\n\treturn (acl->perm & (1 << r->param.unix_network.operation)) &&\n\t\ttomoyo_compare_name_union(r->param.unix_network.address,\n\t\t\t\t\t  &acl->name);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_compare_name_union",
          "args": [
            "r->param.unix_network.address",
            "&acl->name"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_compare_name_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "81-90",
          "snippet": "const struct tomoyo_path_info *\ntomoyo_compare_name_union(const struct tomoyo_path_info *name,\n\t\t\t  const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_path_matches_group(name, ptr->group);\n\tif (tomoyo_path_matches_pattern(name, ptr->filename))\n\t\treturn ptr->filename;\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst struct tomoyo_path_info *\ntomoyo_compare_name_union(const struct tomoyo_path_info *name,\n\t\t\t  const struct tomoyo_name_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_path_matches_group(name, ptr->group);\n\tif (tomoyo_path_matches_pattern(name, ptr->filename))\n\t\treturn ptr->filename;\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ptr",
            "typeof(*acl)",
            "head"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*acl"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_check_unix_acl(struct tomoyo_request_info *r,\n\t\t\t\t  const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_unix_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\n\treturn (acl->perm & (1 << r->param.unix_network.operation)) &&\n\t\ttomoyo_compare_name_union(r->param.unix_network.address,\n\t\t\t\t\t  &acl->name);\n}"
  },
  {
    "function_name": "tomoyo_check_inet_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "419-439",
    "snippet": "static bool tomoyo_check_inet_acl(struct tomoyo_request_info *r,\n\t\t\t\t  const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_inet_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\tconst u8 size = r->param.inet_network.is_ipv6 ? 16 : 4;\n\n\tif (!(acl->perm & (1 << r->param.inet_network.operation)) ||\n\t    !tomoyo_compare_number_union(r->param.inet_network.port,\n\t\t\t\t\t &acl->port))\n\t\treturn false;\n\tif (acl->address.group)\n\t\treturn tomoyo_address_matches_group\n\t\t\t(r->param.inet_network.is_ipv6,\n\t\t\t r->param.inet_network.address, acl->address.group);\n\treturn acl->address.is_ipv6 == r->param.inet_network.is_ipv6 &&\n\t\tmemcmp(&acl->address.ip[0],\n\t\t       r->param.inet_network.address, size) <= 0 &&\n\t\tmemcmp(r->param.inet_network.address,\n\t\t       &acl->address.ip[1], size) <= 0;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "r->param.inet_network.address",
            "&acl->address.ip[1]",
            "size"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "&acl->address.ip[0]",
            "r->param.inet_network.address",
            "size"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_address_matches_group",
          "args": [
            "r->param.inet_network.is_ipv6",
            "r->param.inet_network.address",
            "acl->address.group"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_address_matches_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/group.c",
          "lines": "182-201",
          "snippet": "bool tomoyo_address_matches_group(const bool is_ipv6, const __be32 *address,\n\t\t\t\t  const struct tomoyo_group *group)\n{\n\tstruct tomoyo_address_group *member;\n\tbool matched = false;\n\tconst u8 size = is_ipv6 ? 16 : 4;\n\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (member->address.is_ipv6 != is_ipv6)\n\t\t\tcontinue;\n\t\tif (memcmp(&member->address.ip[0], address, size) > 0 ||\n\t\t    memcmp(address, &member->address.ip[1], size) > 0)\n\t\t\tcontinue;\n\t\tmatched = true;\n\t\tbreak;\n\t}\n\treturn matched;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_address_matches_group(const bool is_ipv6, const __be32 *address,\n\t\t\t\t  const struct tomoyo_group *group)\n{\n\tstruct tomoyo_address_group *member;\n\tbool matched = false;\n\tconst u8 size = is_ipv6 ? 16 : 4;\n\n\tlist_for_each_entry_rcu(member, &group->member_list, head.list) {\n\t\tif (member->head.is_deleted)\n\t\t\tcontinue;\n\t\tif (member->address.is_ipv6 != is_ipv6)\n\t\t\tcontinue;\n\t\tif (memcmp(&member->address.ip[0], address, size) > 0 ||\n\t\t    memcmp(address, &member->address.ip[1], size) > 0)\n\t\t\tcontinue;\n\t\tmatched = true;\n\t\tbreak;\n\t}\n\treturn matched;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_compare_number_union",
          "args": [
            "r->param.inet_network.port",
            "&acl->port"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_compare_number_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "112-118",
          "snippet": "bool tomoyo_compare_number_union(const unsigned long value,\n\t\t\t\t const struct tomoyo_number_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_number_matches_group(value, value, ptr->group);\n\treturn value >= ptr->values[0] && value <= ptr->values[1];\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nbool tomoyo_compare_number_union(const unsigned long value,\n\t\t\t\t const struct tomoyo_number_union *ptr)\n{\n\tif (ptr->group)\n\t\treturn tomoyo_number_matches_group(value, value, ptr->group);\n\treturn value >= ptr->values[0] && value <= ptr->values[1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ptr",
            "typeof(*acl)",
            "head"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*acl"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_check_inet_acl(struct tomoyo_request_info *r,\n\t\t\t\t  const struct tomoyo_acl_info *ptr)\n{\n\tconst struct tomoyo_inet_acl *acl =\n\t\tcontainer_of(ptr, typeof(*acl), head);\n\tconst u8 size = r->param.inet_network.is_ipv6 ? 16 : 4;\n\n\tif (!(acl->perm & (1 << r->param.inet_network.operation)) ||\n\t    !tomoyo_compare_number_union(r->param.inet_network.port,\n\t\t\t\t\t &acl->port))\n\t\treturn false;\n\tif (acl->address.group)\n\t\treturn tomoyo_address_matches_group\n\t\t\t(r->param.inet_network.is_ipv6,\n\t\t\t r->param.inet_network.address, acl->address.group);\n\treturn acl->address.is_ipv6 == r->param.inet_network.is_ipv6 &&\n\t\tmemcmp(&acl->address.ip[0],\n\t\t       r->param.inet_network.address, size) <= 0 &&\n\t\tmemcmp(r->param.inet_network.address,\n\t\t       &acl->address.ip[1], size) <= 0;\n}"
  },
  {
    "function_name": "tomoyo_audit_unix_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "404-409",
    "snippet": "static int tomoyo_audit_unix_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_audit_net_log(r, \"unix\", r->param.unix_network.protocol,\n\t\t\t\t    r->param.unix_network.operation,\n\t\t\t\t    r->param.unix_network.address->name);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_audit_net_log",
          "args": [
            "r",
            "\"unix\"",
            "r->param.unix_network.protocol",
            "r->param.unix_network.operation",
            "r->param.unix_network.address->name"
          ],
          "line": 406
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_audit_net_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "363-370",
          "snippet": "static int tomoyo_audit_net_log(struct tomoyo_request_info *r,\n\t\t\t\tconst char *family, const u8 protocol,\n\t\t\t\tconst u8 operation, const char *address)\n{\n\treturn tomoyo_supervisor(r, \"network %s %s %s %s\\n\", family,\n\t\t\t\t tomoyo_proto_keyword[protocol],\n\t\t\t\t tomoyo_socket_keyword[operation], address);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char * const tomoyo_proto_keyword[TOMOYO_SOCK_MAX] = {\n\t[SOCK_STREAM]    = \"stream\",\n\t[SOCK_DGRAM]     = \"dgram\",\n\t[SOCK_RAW]       = \"raw\",\n\t[SOCK_SEQPACKET] = \"seqpacket\",\n\t[0] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n\t[4] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst char * const tomoyo_proto_keyword[TOMOYO_SOCK_MAX] = {\n\t[SOCK_STREAM]    = \"stream\",\n\t[SOCK_DGRAM]     = \"dgram\",\n\t[SOCK_RAW]       = \"raw\",\n\t[SOCK_SEQPACKET] = \"seqpacket\",\n\t[0] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n\t[4] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n};\n\nstatic int tomoyo_audit_net_log(struct tomoyo_request_info *r,\n\t\t\t\tconst char *family, const u8 protocol,\n\t\t\t\tconst u8 operation, const char *address)\n{\n\treturn tomoyo_supervisor(r, \"network %s %s %s %s\\n\", family,\n\t\t\t\t tomoyo_proto_keyword[protocol],\n\t\t\t\t tomoyo_socket_keyword[operation], address);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_audit_unix_log(struct tomoyo_request_info *r)\n{\n\treturn tomoyo_audit_net_log(r, \"unix\", r->param.unix_network.protocol,\n\t\t\t\t    r->param.unix_network.operation,\n\t\t\t\t    r->param.unix_network.address->name);\n}"
  },
  {
    "function_name": "tomoyo_audit_inet_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "379-395",
    "snippet": "static int tomoyo_audit_inet_log(struct tomoyo_request_info *r)\n{\n\tchar buf[128];\n\tint len;\n\tconst __be32 *address = r->param.inet_network.address;\n\n\tif (r->param.inet_network.is_ipv6)\n\t\ttomoyo_print_ipv6(buf, sizeof(buf), (const struct in6_addr *)\n\t\t\t\t  address, (const struct in6_addr *) address);\n\telse\n\t\ttomoyo_print_ipv4(buf, sizeof(buf), address, address);\n\tlen = strlen(buf);\n\tsnprintf(buf + len, sizeof(buf) - len, \" %u\",\n\t\t r->param.inet_network.port);\n\treturn tomoyo_audit_net_log(r, \"inet\", r->param.inet_network.protocol,\n\t\t\t\t    r->param.inet_network.operation, buf);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_audit_net_log",
          "args": [
            "r",
            "\"inet\"",
            "r->param.inet_network.protocol",
            "r->param.inet_network.operation",
            "buf"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_audit_net_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "363-370",
          "snippet": "static int tomoyo_audit_net_log(struct tomoyo_request_info *r,\n\t\t\t\tconst char *family, const u8 protocol,\n\t\t\t\tconst u8 operation, const char *address)\n{\n\treturn tomoyo_supervisor(r, \"network %s %s %s %s\\n\", family,\n\t\t\t\t tomoyo_proto_keyword[protocol],\n\t\t\t\t tomoyo_socket_keyword[operation], address);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const char * const tomoyo_proto_keyword[TOMOYO_SOCK_MAX] = {\n\t[SOCK_STREAM]    = \"stream\",\n\t[SOCK_DGRAM]     = \"dgram\",\n\t[SOCK_RAW]       = \"raw\",\n\t[SOCK_SEQPACKET] = \"seqpacket\",\n\t[0] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n\t[4] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst char * const tomoyo_proto_keyword[TOMOYO_SOCK_MAX] = {\n\t[SOCK_STREAM]    = \"stream\",\n\t[SOCK_DGRAM]     = \"dgram\",\n\t[SOCK_RAW]       = \"raw\",\n\t[SOCK_SEQPACKET] = \"seqpacket\",\n\t[0] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n\t[4] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n};\n\nstatic int tomoyo_audit_net_log(struct tomoyo_request_info *r,\n\t\t\t\tconst char *family, const u8 protocol,\n\t\t\t\tconst u8 operation, const char *address)\n{\n\treturn tomoyo_supervisor(r, \"network %s %s %s %s\\n\", family,\n\t\t\t\t tomoyo_proto_keyword[protocol],\n\t\t\t\t tomoyo_socket_keyword[operation], address);\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + len",
            "sizeof(buf) - len",
            "\" %u\"",
            "r->param.inet_network.port"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_print_ipv4",
          "args": [
            "buf",
            "sizeof(buf)",
            "address",
            "address"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_ipv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "90-95",
          "snippet": "static void tomoyo_print_ipv4(char *buffer, const unsigned int buffer_len,\n\t\t\t      const __be32 *min_ip, const __be32 *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI4%c%pI4\", min_ip,\n\t\t *min_ip == *max_ip ? '\\0' : '-', max_ip);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic void tomoyo_print_ipv4(char *buffer, const unsigned int buffer_len,\n\t\t\t      const __be32 *min_ip, const __be32 *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI4%c%pI4\", min_ip,\n\t\t *min_ip == *max_ip ? '\\0' : '-', max_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_ipv6",
          "args": [
            "buf",
            "sizeof(buf)",
            "(const struct in6_addr *)\n\t\t\t\t  address",
            "(const struct in6_addr *) address"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_ipv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "107-113",
          "snippet": "static void tomoyo_print_ipv6(char *buffer, const unsigned int buffer_len,\n\t\t\t      const struct in6_addr *min_ip,\n\t\t\t      const struct in6_addr *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI6c%c%pI6c\", min_ip,\n\t\t !memcmp(min_ip, max_ip, 16) ? '\\0' : '-', max_ip);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic void tomoyo_print_ipv6(char *buffer, const unsigned int buffer_len,\n\t\t\t      const struct in6_addr *min_ip,\n\t\t\t      const struct in6_addr *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI6c%c%pI6c\", min_ip,\n\t\t !memcmp(min_ip, max_ip, 16) ? '\\0' : '-', max_ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic int tomoyo_audit_inet_log(struct tomoyo_request_info *r)\n{\n\tchar buf[128];\n\tint len;\n\tconst __be32 *address = r->param.inet_network.address;\n\n\tif (r->param.inet_network.is_ipv6)\n\t\ttomoyo_print_ipv6(buf, sizeof(buf), (const struct in6_addr *)\n\t\t\t\t  address, (const struct in6_addr *) address);\n\telse\n\t\ttomoyo_print_ipv4(buf, sizeof(buf), address, address);\n\tlen = strlen(buf);\n\tsnprintf(buf + len, sizeof(buf) - len, \" %u\",\n\t\t r->param.inet_network.port);\n\treturn tomoyo_audit_net_log(r, \"inet\", r->param.inet_network.protocol,\n\t\t\t\t    r->param.inet_network.operation, buf);\n}"
  },
  {
    "function_name": "tomoyo_audit_net_log",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "363-370",
    "snippet": "static int tomoyo_audit_net_log(struct tomoyo_request_info *r,\n\t\t\t\tconst char *family, const u8 protocol,\n\t\t\t\tconst u8 operation, const char *address)\n{\n\treturn tomoyo_supervisor(r, \"network %s %s %s %s\\n\", family,\n\t\t\t\t tomoyo_proto_keyword[protocol],\n\t\t\t\t tomoyo_socket_keyword[operation], address);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char * const tomoyo_proto_keyword[TOMOYO_SOCK_MAX] = {\n\t[SOCK_STREAM]    = \"stream\",\n\t[SOCK_DGRAM]     = \"dgram\",\n\t[SOCK_RAW]       = \"raw\",\n\t[SOCK_SEQPACKET] = \"seqpacket\",\n\t[0] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n\t[4] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_supervisor",
          "args": [
            "r",
            "\"network %s %s %s %s\\n\"",
            "family",
            "tomoyo_proto_keyword[protocol]",
            "tomoyo_socket_keyword[operation]",
            "address"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_supervisor",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.c",
          "lines": "1996-2088",
          "snippet": "int tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint error;\n\tint len;\n\tstatic unsigned int tomoyo_serial;\n\tstruct tomoyo_query entry = { };\n\tbool quota_exceeded = false;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\t/* Write /sys/kernel/security/tomoyo/audit. */\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n\t/* Nothing more to do if granted. */\n\tif (r->granted)\n\t\treturn 0;\n\tif (r->mode)\n\t\ttomoyo_update_stat(r->mode);\n\tswitch (r->mode) {\n\tcase TOMOYO_CONFIG_ENFORCING:\n\t\terror = -EPERM;\n\t\tif (atomic_read(&tomoyo_query_observers))\n\t\t\tbreak;\n\t\tgoto out;\n\tcase TOMOYO_CONFIG_LEARNING:\n\t\terror = 0;\n\t\t/* Check max_learning_entry parameter. */\n\t\tif (tomoyo_domain_quota_is_ok(r))\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* Get message. */\n\tva_start(args, fmt);\n\tentry.query = tomoyo_init_log(r, len, fmt, args);\n\tva_end(args);\n\tif (!entry.query)\n\t\tgoto out;\n\tentry.query_len = strlen(entry.query) + 1;\n\tif (!error) {\n\t\ttomoyo_add_entry(r->domain, entry.query);\n\t\tgoto out;\n\t}\n\tlen = tomoyo_round2(entry.query_len);\n\tentry.domain = r->domain;\n\tspin_lock(&tomoyo_query_list_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_QUERY] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_QUERY] + len\n\t    >= tomoyo_memory_quota[TOMOYO_MEMORY_QUERY]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\tentry.serial = tomoyo_serial++;\n\t\tentry.retry = r->retry;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] += len;\n\t\tlist_add_tail(&entry.list, &tomoyo_query_list);\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (quota_exceeded)\n\t\tgoto out;\n\t/* Give 10 seconds for supervisor's opinion. */\n\twhile (entry.timer < 10) {\n\t\twake_up_all(&tomoyo_query_wait);\n\t\tif (wait_event_interruptible_timeout\n\t\t    (tomoyo_answer_wait, entry.answer ||\n\t\t     !atomic_read(&tomoyo_query_observers), HZ))\n\t\t\tbreak;\n\t\telse\n\t\t\tentry.timer++;\n\t}\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_del(&entry.list);\n\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] -= len;\n\tspin_unlock(&tomoyo_query_list_lock);\n\tswitch (entry.answer) {\n\tcase 3: /* Asked to retry by administrator. */\n\t\terror = TOMOYO_RETRY_REQUEST;\n\t\tr->retry++;\n\t\tbreak;\n\tcase 1:\n\t\t/* Granted by administrator. */\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\t/* Timed out or rejected by administrator. */\n\t\tbreak;\n\t}\nout:\n\tkfree(entry.query);\n\treturn error;\n}",
          "includes": [
            "#include \"builtin-policy.h\"",
            "#include \"common.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);",
            "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_query_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);",
            "static LIST_HEAD(tomoyo_query_list);",
            "static DEFINE_SPINLOCK(tomoyo_query_list_lock);",
            "static atomic_t tomoyo_query_observers = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"builtin-policy.h\"\n#include \"common.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n\nstatic struct tomoyo_domain_info *tomoyo_find_domain_by_qid\n(unsigned int serial);\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_query_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(tomoyo_answer_wait);\nstatic LIST_HEAD(tomoyo_query_list);\nstatic DEFINE_SPINLOCK(tomoyo_query_list_lock);\nstatic atomic_t tomoyo_query_observers = ATOMIC_INIT(0);\n\nint tomoyo_supervisor(struct tomoyo_request_info *r, const char *fmt, ...)\n{\n\tva_list args;\n\tint error;\n\tint len;\n\tstatic unsigned int tomoyo_serial;\n\tstruct tomoyo_query entry = { };\n\tbool quota_exceeded = false;\n\tva_start(args, fmt);\n\tlen = vsnprintf((char *) &len, 1, fmt, args) + 1;\n\tva_end(args);\n\t/* Write /sys/kernel/security/tomoyo/audit. */\n\tva_start(args, fmt);\n\ttomoyo_write_log2(r, len, fmt, args);\n\tva_end(args);\n\t/* Nothing more to do if granted. */\n\tif (r->granted)\n\t\treturn 0;\n\tif (r->mode)\n\t\ttomoyo_update_stat(r->mode);\n\tswitch (r->mode) {\n\tcase TOMOYO_CONFIG_ENFORCING:\n\t\terror = -EPERM;\n\t\tif (atomic_read(&tomoyo_query_observers))\n\t\t\tbreak;\n\t\tgoto out;\n\tcase TOMOYO_CONFIG_LEARNING:\n\t\terror = 0;\n\t\t/* Check max_learning_entry parameter. */\n\t\tif (tomoyo_domain_quota_is_ok(r))\n\t\t\tbreak;\n\t\t/* fall through */\n\tdefault:\n\t\treturn 0;\n\t}\n\t/* Get message. */\n\tva_start(args, fmt);\n\tentry.query = tomoyo_init_log(r, len, fmt, args);\n\tva_end(args);\n\tif (!entry.query)\n\t\tgoto out;\n\tentry.query_len = strlen(entry.query) + 1;\n\tif (!error) {\n\t\ttomoyo_add_entry(r->domain, entry.query);\n\t\tgoto out;\n\t}\n\tlen = tomoyo_round2(entry.query_len);\n\tentry.domain = r->domain;\n\tspin_lock(&tomoyo_query_list_lock);\n\tif (tomoyo_memory_quota[TOMOYO_MEMORY_QUERY] &&\n\t    tomoyo_memory_used[TOMOYO_MEMORY_QUERY] + len\n\t    >= tomoyo_memory_quota[TOMOYO_MEMORY_QUERY]) {\n\t\tquota_exceeded = true;\n\t} else {\n\t\tentry.serial = tomoyo_serial++;\n\t\tentry.retry = r->retry;\n\t\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] += len;\n\t\tlist_add_tail(&entry.list, &tomoyo_query_list);\n\t}\n\tspin_unlock(&tomoyo_query_list_lock);\n\tif (quota_exceeded)\n\t\tgoto out;\n\t/* Give 10 seconds for supervisor's opinion. */\n\twhile (entry.timer < 10) {\n\t\twake_up_all(&tomoyo_query_wait);\n\t\tif (wait_event_interruptible_timeout\n\t\t    (tomoyo_answer_wait, entry.answer ||\n\t\t     !atomic_read(&tomoyo_query_observers), HZ))\n\t\t\tbreak;\n\t\telse\n\t\t\tentry.timer++;\n\t}\n\tspin_lock(&tomoyo_query_list_lock);\n\tlist_del(&entry.list);\n\ttomoyo_memory_used[TOMOYO_MEMORY_QUERY] -= len;\n\tspin_unlock(&tomoyo_query_list_lock);\n\tswitch (entry.answer) {\n\tcase 3: /* Asked to retry by administrator. */\n\t\terror = TOMOYO_RETRY_REQUEST;\n\t\tr->retry++;\n\t\tbreak;\n\tcase 1:\n\t\t/* Granted by administrator. */\n\t\terror = 0;\n\t\tbreak;\n\tdefault:\n\t\t/* Timed out or rejected by administrator. */\n\t\tbreak;\n\t}\nout:\n\tkfree(entry.query);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst char * const tomoyo_proto_keyword[TOMOYO_SOCK_MAX] = {\n\t[SOCK_STREAM]    = \"stream\",\n\t[SOCK_DGRAM]     = \"dgram\",\n\t[SOCK_RAW]       = \"raw\",\n\t[SOCK_SEQPACKET] = \"seqpacket\",\n\t[0] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n\t[4] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n};\n\nstatic int tomoyo_audit_net_log(struct tomoyo_request_info *r,\n\t\t\t\tconst char *family, const u8 protocol,\n\t\t\t\tconst u8 operation, const char *address)\n{\n\treturn tomoyo_supervisor(r, \"network %s %s %s %s\\n\", family,\n\t\t\t\t tomoyo_proto_keyword[protocol],\n\t\t\t\t tomoyo_socket_keyword[operation], address);\n}"
  },
  {
    "function_name": "tomoyo_write_unix_network",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "327-350",
    "snippet": "int tomoyo_write_unix_network(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_unix_acl e = { .head.type = TOMOYO_TYPE_UNIX_ACL };\n\tint error;\n\tu8 type;\n\tconst char *protocol = tomoyo_read_token(param);\n\tconst char *operation = tomoyo_read_token(param);\n\n\tfor (e.protocol = 0; e.protocol < TOMOYO_SOCK_MAX; e.protocol++)\n\t\tif (!strcmp(protocol, tomoyo_proto_keyword[e.protocol]))\n\t\t\tbreak;\n\tfor (type = 0; type < TOMOYO_MAX_NETWORK_OPERATION; type++)\n\t\tif (tomoyo_permstr(operation, tomoyo_socket_keyword[type]))\n\t\t\te.perm |= 1 << type;\n\tif (e.protocol == TOMOYO_SOCK_MAX || !e.perm)\n\t\treturn -EINVAL;\n\tif (!tomoyo_parse_name_union(param, &e.name))\n\t\treturn -EINVAL;\n\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_unix_acl,\n\t\t\t\t     tomoyo_merge_unix_acl);\n\ttomoyo_put_name_union(&e.name);\n\treturn error;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char * const tomoyo_proto_keyword[TOMOYO_SOCK_MAX] = {\n\t[SOCK_STREAM]    = \"stream\",\n\t[SOCK_DGRAM]     = \"dgram\",\n\t[SOCK_RAW]       = \"raw\",\n\t[SOCK_SEQPACKET] = \"seqpacket\",\n\t[0] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n\t[4] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_name_union",
          "args": [
            "&e.name"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_name_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "67-71",
          "snippet": "void tomoyo_put_name_union(struct tomoyo_name_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n\ttomoyo_put_name(ptr->filename);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_put_name_union(struct tomoyo_name_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n\ttomoyo_put_name(ptr->filename);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_update_domain",
          "args": [
            "&e.head",
            "sizeof(e)",
            "param",
            "tomoyo_same_unix_acl",
            "tomoyo_merge_unix_acl"
          ],
          "line": 345
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "91-147",
          "snippet": "int tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_info\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_info\n\t\t\t\t\t\t  *),\n\t\t\t bool (*merge_duplicate) (struct tomoyo_acl_info *,\n\t\t\t\t\t\t  struct tomoyo_acl_info *,\n\t\t\t\t\t\t  const bool))\n{\n\tconst bool is_delete = param->is_delete;\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_info *entry;\n\tstruct list_head * const list = param->list;\n\n\tif (param->data[0]) {\n\t\tnew_entry->cond = tomoyo_get_condition(param);\n\t\tif (!new_entry->cond)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Domain transition preference is allowed for only\n\t\t * \"file execute\" entries.\n\t\t */\n\t\tif (new_entry->cond->transit &&\n\t\t    !(new_entry->type == TOMOYO_TYPE_PATH_ACL &&\n\t\t      container_of(new_entry, struct tomoyo_path_acl, head)\n\t\t      ->perm == 1 << TOMOYO_TYPE_EXECUTE))\n\t\t\tgoto out;\n\t}\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!tomoyo_same_acl_head(entry, new_entry) ||\n\t\t    !check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tif (merge_duplicate)\n\t\t\tentry->is_deleted = merge_duplicate(entry, new_entry,\n\t\t\t\t\t\t\t    is_delete);\n\t\telse\n\t\t\tentry->is_deleted = is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_condition(new_entry->cond);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_info\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_info\n\t\t\t\t\t\t  *),\n\t\t\t bool (*merge_duplicate) (struct tomoyo_acl_info *,\n\t\t\t\t\t\t  struct tomoyo_acl_info *,\n\t\t\t\t\t\t  const bool))\n{\n\tconst bool is_delete = param->is_delete;\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_info *entry;\n\tstruct list_head * const list = param->list;\n\n\tif (param->data[0]) {\n\t\tnew_entry->cond = tomoyo_get_condition(param);\n\t\tif (!new_entry->cond)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Domain transition preference is allowed for only\n\t\t * \"file execute\" entries.\n\t\t */\n\t\tif (new_entry->cond->transit &&\n\t\t    !(new_entry->type == TOMOYO_TYPE_PATH_ACL &&\n\t\t      container_of(new_entry, struct tomoyo_path_acl, head)\n\t\t      ->perm == 1 << TOMOYO_TYPE_EXECUTE))\n\t\t\tgoto out;\n\t}\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!tomoyo_same_acl_head(entry, new_entry) ||\n\t\t    !check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tif (merge_duplicate)\n\t\t\tentry->is_deleted = merge_duplicate(entry, new_entry,\n\t\t\t\t\t\t\t    is_delete);\n\t\telse\n\t\t\tentry->is_deleted = is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_condition(new_entry->cond);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_name_union",
          "args": [
            "param",
            "&e.name"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_name_union_quoted",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/condition.c",
          "lines": "269-277",
          "snippet": "static bool tomoyo_parse_name_union_quoted(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_name_union *ptr)\n{\n\tchar *filename = param->data;\n\tif (*filename == '@')\n\t\treturn tomoyo_parse_name_union(param, ptr);\n\tptr->filename = tomoyo_get_dqword(filename);\n\treturn ptr->filename != NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_parse_name_union_quoted(struct tomoyo_acl_param *param,\n\t\t\t\t\t   struct tomoyo_name_union *ptr)\n{\n\tchar *filename = param->data;\n\tif (*filename == '@')\n\t\treturn tomoyo_parse_name_union(param, ptr);\n\tptr->filename = tomoyo_get_dqword(filename);\n\treturn ptr->filename != NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_permstr",
          "args": [
            "operation",
            "tomoyo_socket_keyword[type]"
          ],
          "line": 339
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_permstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "113-119",
          "snippet": "bool tomoyo_permstr(const char *string, const char *keyword)\n{\n\tconst char *cp = strstr(string, keyword);\n\tif (cp)\n\t\treturn cp == string || *(cp - 1) == '/';\n\treturn false;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_permstr(const char *string, const char *keyword)\n{\n\tconst char *cp = strstr(string, keyword);\n\tif (cp)\n\t\treturn cp == string || *(cp - 1) == '/';\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "protocol",
            "tomoyo_proto_keyword[e.protocol]"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_read_token",
          "args": [
            "param"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "131-141",
          "snippet": "char *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nchar *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst char * const tomoyo_proto_keyword[TOMOYO_SOCK_MAX] = {\n\t[SOCK_STREAM]    = \"stream\",\n\t[SOCK_DGRAM]     = \"dgram\",\n\t[SOCK_RAW]       = \"raw\",\n\t[SOCK_SEQPACKET] = \"seqpacket\",\n\t[0] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n\t[4] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n};\n\nint tomoyo_write_unix_network(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_unix_acl e = { .head.type = TOMOYO_TYPE_UNIX_ACL };\n\tint error;\n\tu8 type;\n\tconst char *protocol = tomoyo_read_token(param);\n\tconst char *operation = tomoyo_read_token(param);\n\n\tfor (e.protocol = 0; e.protocol < TOMOYO_SOCK_MAX; e.protocol++)\n\t\tif (!strcmp(protocol, tomoyo_proto_keyword[e.protocol]))\n\t\t\tbreak;\n\tfor (type = 0; type < TOMOYO_MAX_NETWORK_OPERATION; type++)\n\t\tif (tomoyo_permstr(operation, tomoyo_socket_keyword[type]))\n\t\t\te.perm |= 1 << type;\n\tif (e.protocol == TOMOYO_SOCK_MAX || !e.perm)\n\t\treturn -EINVAL;\n\tif (!tomoyo_parse_name_union(param, &e.name))\n\t\treturn -EINVAL;\n\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_unix_acl,\n\t\t\t\t     tomoyo_merge_unix_acl);\n\ttomoyo_put_name_union(&e.name);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_write_inet_network",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "282-318",
    "snippet": "int tomoyo_write_inet_network(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_inet_acl e = { .head.type = TOMOYO_TYPE_INET_ACL };\n\tint error = -EINVAL;\n\tu8 type;\n\tconst char *protocol = tomoyo_read_token(param);\n\tconst char *operation = tomoyo_read_token(param);\n\n\tfor (e.protocol = 0; e.protocol < TOMOYO_SOCK_MAX; e.protocol++)\n\t\tif (!strcmp(protocol, tomoyo_proto_keyword[e.protocol]))\n\t\t\tbreak;\n\tfor (type = 0; type < TOMOYO_MAX_NETWORK_OPERATION; type++)\n\t\tif (tomoyo_permstr(operation, tomoyo_socket_keyword[type]))\n\t\t\te.perm |= 1 << type;\n\tif (e.protocol == TOMOYO_SOCK_MAX || !e.perm)\n\t\treturn -EINVAL;\n\tif (param->data[0] == '@') {\n\t\tparam->data++;\n\t\te.address.group =\n\t\t\ttomoyo_get_group(param, TOMOYO_ADDRESS_GROUP);\n\t\tif (!e.address.group)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tif (!tomoyo_parse_ipaddr_union(param, &e.address))\n\t\t\tgoto out;\n\t}\n\tif (!tomoyo_parse_number_union(param, &e.port) ||\n\t    e.port.values[1] > 65535)\n\t\tgoto out;\n\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_inet_acl,\n\t\t\t\t     tomoyo_merge_inet_acl);\nout:\n\ttomoyo_put_group(e.address.group);\n\ttomoyo_put_number_union(&e.port);\n\treturn error;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const char * const tomoyo_proto_keyword[TOMOYO_SOCK_MAX] = {\n\t[SOCK_STREAM]    = \"stream\",\n\t[SOCK_DGRAM]     = \"dgram\",\n\t[SOCK_RAW]       = \"raw\",\n\t[SOCK_SEQPACKET] = \"seqpacket\",\n\t[0] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n\t[4] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_put_number_union",
          "args": [
            "&e.port"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_number_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "99-102",
          "snippet": "void tomoyo_put_number_union(struct tomoyo_number_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_put_number_union(struct tomoyo_number_union *ptr)\n{\n\ttomoyo_put_group(ptr->group);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_put_group",
          "args": [
            "e.address.group"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_put_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1193-1197",
          "snippet": "static inline void tomoyo_put_group(struct tomoyo_group *group)\n{\n\tif (group)\n\t\tatomic_dec(&group->head.users);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_put_group(struct tomoyo_group *group)\n{\n\tif (group)\n\t\tatomic_dec(&group->head.users);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_update_domain",
          "args": [
            "&e.head",
            "sizeof(e)",
            "param",
            "tomoyo_same_inet_acl",
            "tomoyo_merge_inet_acl"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_update_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "91-147",
          "snippet": "int tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_info\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_info\n\t\t\t\t\t\t  *),\n\t\t\t bool (*merge_duplicate) (struct tomoyo_acl_info *,\n\t\t\t\t\t\t  struct tomoyo_acl_info *,\n\t\t\t\t\t\t  const bool))\n{\n\tconst bool is_delete = param->is_delete;\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_info *entry;\n\tstruct list_head * const list = param->list;\n\n\tif (param->data[0]) {\n\t\tnew_entry->cond = tomoyo_get_condition(param);\n\t\tif (!new_entry->cond)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Domain transition preference is allowed for only\n\t\t * \"file execute\" entries.\n\t\t */\n\t\tif (new_entry->cond->transit &&\n\t\t    !(new_entry->type == TOMOYO_TYPE_PATH_ACL &&\n\t\t      container_of(new_entry, struct tomoyo_path_acl, head)\n\t\t      ->perm == 1 << TOMOYO_TYPE_EXECUTE))\n\t\t\tgoto out;\n\t}\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!tomoyo_same_acl_head(entry, new_entry) ||\n\t\t    !check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tif (merge_duplicate)\n\t\t\tentry->is_deleted = merge_duplicate(entry, new_entry,\n\t\t\t\t\t\t\t    is_delete);\n\t\telse\n\t\t\tentry->is_deleted = is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_condition(new_entry->cond);\n\treturn error;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nint tomoyo_update_domain(struct tomoyo_acl_info *new_entry, const int size,\n\t\t\t struct tomoyo_acl_param *param,\n\t\t\t bool (*check_duplicate) (const struct tomoyo_acl_info\n\t\t\t\t\t\t  *,\n\t\t\t\t\t\t  const struct tomoyo_acl_info\n\t\t\t\t\t\t  *),\n\t\t\t bool (*merge_duplicate) (struct tomoyo_acl_info *,\n\t\t\t\t\t\t  struct tomoyo_acl_info *,\n\t\t\t\t\t\t  const bool))\n{\n\tconst bool is_delete = param->is_delete;\n\tint error = is_delete ? -ENOENT : -ENOMEM;\n\tstruct tomoyo_acl_info *entry;\n\tstruct list_head * const list = param->list;\n\n\tif (param->data[0]) {\n\t\tnew_entry->cond = tomoyo_get_condition(param);\n\t\tif (!new_entry->cond)\n\t\t\treturn -EINVAL;\n\t\t/*\n\t\t * Domain transition preference is allowed for only\n\t\t * \"file execute\" entries.\n\t\t */\n\t\tif (new_entry->cond->transit &&\n\t\t    !(new_entry->type == TOMOYO_TYPE_PATH_ACL &&\n\t\t      container_of(new_entry, struct tomoyo_path_acl, head)\n\t\t      ->perm == 1 << TOMOYO_TYPE_EXECUTE))\n\t\t\tgoto out;\n\t}\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist_for_each_entry_rcu(entry, list, list) {\n\t\tif (entry->is_deleted == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tif (!tomoyo_same_acl_head(entry, new_entry) ||\n\t\t    !check_duplicate(entry, new_entry))\n\t\t\tcontinue;\n\t\tif (merge_duplicate)\n\t\t\tentry->is_deleted = merge_duplicate(entry, new_entry,\n\t\t\t\t\t\t\t    is_delete);\n\t\telse\n\t\t\tentry->is_deleted = is_delete;\n\t\terror = 0;\n\t\tbreak;\n\t}\n\tif (error && !is_delete) {\n\t\tentry = tomoyo_commit_ok(new_entry, size);\n\t\tif (entry) {\n\t\t\tlist_add_tail_rcu(&entry->list, list);\n\t\t\terror = 0;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_condition(new_entry->cond);\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_number_union",
          "args": [
            "param",
            "&e.port"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_number_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "263-294",
          "snippet": "bool tomoyo_parse_number_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_number_union *ptr)\n{\n\tchar *data;\n\tu8 type;\n\tunsigned long v;\n\tmemset(ptr, 0, sizeof(*ptr));\n\tif (param->data[0] == '@') {\n\t\tparam->data++;\n\t\tptr->group = tomoyo_get_group(param, TOMOYO_NUMBER_GROUP);\n\t\treturn ptr->group != NULL;\n\t}\n\tdata = tomoyo_read_token(param);\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID)\n\t\treturn false;\n\tptr->values[0] = v;\n\tptr->value_type[0] = type;\n\tif (!*data) {\n\t\tptr->values[1] = v;\n\t\tptr->value_type[1] = type;\n\t\treturn true;\n\t}\n\tif (*data++ != '-')\n\t\treturn false;\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID || *data || ptr->values[0] > v)\n\t\treturn false;\n\tptr->values[1] = v;\n\tptr->value_type[1] = type;\n\treturn true;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_parse_number_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_number_union *ptr)\n{\n\tchar *data;\n\tu8 type;\n\tunsigned long v;\n\tmemset(ptr, 0, sizeof(*ptr));\n\tif (param->data[0] == '@') {\n\t\tparam->data++;\n\t\tptr->group = tomoyo_get_group(param, TOMOYO_NUMBER_GROUP);\n\t\treturn ptr->group != NULL;\n\t}\n\tdata = tomoyo_read_token(param);\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID)\n\t\treturn false;\n\tptr->values[0] = v;\n\tptr->value_type[0] = type;\n\tif (!*data) {\n\t\tptr->values[1] = v;\n\t\tptr->value_type[1] = type;\n\t\treturn true;\n\t}\n\tif (*data++ != '-')\n\t\treturn false;\n\ttype = tomoyo_parse_ulong(&v, &data);\n\tif (type == TOMOYO_VALUE_TYPE_INVALID || *data || ptr->values[0] > v)\n\t\treturn false;\n\tptr->values[1] = v;\n\tptr->value_type[1] = type;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_parse_ipaddr_union",
          "args": [
            "param",
            "&e.address"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_parse_ipaddr_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "50-78",
          "snippet": "bool tomoyo_parse_ipaddr_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_ipaddr_union *ptr)\n{\n\tu8 * const min = ptr->ip[0].in6_u.u6_addr8;\n\tu8 * const max = ptr->ip[1].in6_u.u6_addr8;\n\tchar *address = tomoyo_read_token(param);\n\tconst char *end;\n\n\tif (!strchr(address, ':') &&\n\t    in4_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = false;\n\t\tif (!*end)\n\t\t\tptr->ip[1].s6_addr32[0] = ptr->ip[0].s6_addr32[0];\n\t\telse if (*end++ != '-' ||\n\t\t\t in4_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tif (in6_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = true;\n\t\tif (!*end)\n\t\t\tmemmove(max, min, sizeof(u16) * 8);\n\t\telse if (*end++ != '-' ||\n\t\t\t in6_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nbool tomoyo_parse_ipaddr_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_ipaddr_union *ptr)\n{\n\tu8 * const min = ptr->ip[0].in6_u.u6_addr8;\n\tu8 * const max = ptr->ip[1].in6_u.u6_addr8;\n\tchar *address = tomoyo_read_token(param);\n\tconst char *end;\n\n\tif (!strchr(address, ':') &&\n\t    in4_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = false;\n\t\tif (!*end)\n\t\t\tptr->ip[1].s6_addr32[0] = ptr->ip[0].s6_addr32[0];\n\t\telse if (*end++ != '-' ||\n\t\t\t in4_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tif (in6_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = true;\n\t\tif (!*end)\n\t\t\tmemmove(max, min, sizeof(u16) * 8);\n\t\telse if (*end++ != '-' ||\n\t\t\t in6_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_get_group",
          "args": [
            "param",
            "TOMOYO_ADDRESS_GROUP"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_get_group",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "93-131",
          "snippet": "struct tomoyo_group *tomoyo_get_group(struct tomoyo_acl_param *param,\n\t\t\t\t      const u8 idx)\n{\n\tstruct tomoyo_group e = { };\n\tstruct tomoyo_group *group = NULL;\n\tstruct list_head *list;\n\tconst char *group_name = tomoyo_read_token(param);\n\tbool found = false;\n\tif (!tomoyo_correct_word(group_name) || idx >= TOMOYO_MAX_GROUP)\n\t\treturn NULL;\n\te.group_name = tomoyo_get_name(group_name);\n\tif (!e.group_name)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist = &param->ns->group_list[idx];\n\tlist_for_each_entry(group, list, head.list) {\n\t\tif (e.group_name != group->group_name ||\n\t\t    atomic_read(&group->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&group->head.users);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tstruct tomoyo_group *entry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->member_list);\n\t\t\tatomic_set(&entry->head.users, 1);\n\t\t\tlist_add_tail_rcu(&entry->head.list, list);\n\t\t\tgroup = entry;\n\t\t\tfound = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.group_name);\n\treturn found ? group : NULL;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct tomoyo_group *tomoyo_get_group(struct tomoyo_acl_param *param,\n\t\t\t\t      const u8 idx)\n{\n\tstruct tomoyo_group e = { };\n\tstruct tomoyo_group *group = NULL;\n\tstruct list_head *list;\n\tconst char *group_name = tomoyo_read_token(param);\n\tbool found = false;\n\tif (!tomoyo_correct_word(group_name) || idx >= TOMOYO_MAX_GROUP)\n\t\treturn NULL;\n\te.group_name = tomoyo_get_name(group_name);\n\tif (!e.group_name)\n\t\treturn NULL;\n\tif (mutex_lock_interruptible(&tomoyo_policy_lock))\n\t\tgoto out;\n\tlist = &param->ns->group_list[idx];\n\tlist_for_each_entry(group, list, head.list) {\n\t\tif (e.group_name != group->group_name ||\n\t\t    atomic_read(&group->head.users) == TOMOYO_GC_IN_PROGRESS)\n\t\t\tcontinue;\n\t\tatomic_inc(&group->head.users);\n\t\tfound = true;\n\t\tbreak;\n\t}\n\tif (!found) {\n\t\tstruct tomoyo_group *entry = tomoyo_commit_ok(&e, sizeof(e));\n\t\tif (entry) {\n\t\t\tINIT_LIST_HEAD(&entry->member_list);\n\t\t\tatomic_set(&entry->head.users, 1);\n\t\t\tlist_add_tail_rcu(&entry->head.list, list);\n\t\t\tgroup = entry;\n\t\t\tfound = true;\n\t\t}\n\t}\n\tmutex_unlock(&tomoyo_policy_lock);\nout:\n\ttomoyo_put_name(e.group_name);\n\treturn found ? group : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_permstr",
          "args": [
            "operation",
            "tomoyo_socket_keyword[type]"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_permstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "113-119",
          "snippet": "bool tomoyo_permstr(const char *string, const char *keyword)\n{\n\tconst char *cp = strstr(string, keyword);\n\tif (cp)\n\t\treturn cp == string || *(cp - 1) == '/';\n\treturn false;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nbool tomoyo_permstr(const char *string, const char *keyword)\n{\n\tconst char *cp = strstr(string, keyword);\n\tif (cp)\n\t\treturn cp == string || *(cp - 1) == '/';\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "protocol",
            "tomoyo_proto_keyword[e.protocol]"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_read_token",
          "args": [
            "param"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "131-141",
          "snippet": "char *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nchar *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst char * const tomoyo_proto_keyword[TOMOYO_SOCK_MAX] = {\n\t[SOCK_STREAM]    = \"stream\",\n\t[SOCK_DGRAM]     = \"dgram\",\n\t[SOCK_RAW]       = \"raw\",\n\t[SOCK_SEQPACKET] = \"seqpacket\",\n\t[0] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n\t[4] = \" \", /* Dummy for avoiding NULL pointer dereference. */\n};\n\nint tomoyo_write_inet_network(struct tomoyo_acl_param *param)\n{\n\tstruct tomoyo_inet_acl e = { .head.type = TOMOYO_TYPE_INET_ACL };\n\tint error = -EINVAL;\n\tu8 type;\n\tconst char *protocol = tomoyo_read_token(param);\n\tconst char *operation = tomoyo_read_token(param);\n\n\tfor (e.protocol = 0; e.protocol < TOMOYO_SOCK_MAX; e.protocol++)\n\t\tif (!strcmp(protocol, tomoyo_proto_keyword[e.protocol]))\n\t\t\tbreak;\n\tfor (type = 0; type < TOMOYO_MAX_NETWORK_OPERATION; type++)\n\t\tif (tomoyo_permstr(operation, tomoyo_socket_keyword[type]))\n\t\t\te.perm |= 1 << type;\n\tif (e.protocol == TOMOYO_SOCK_MAX || !e.perm)\n\t\treturn -EINVAL;\n\tif (param->data[0] == '@') {\n\t\tparam->data++;\n\t\te.address.group =\n\t\t\ttomoyo_get_group(param, TOMOYO_ADDRESS_GROUP);\n\t\tif (!e.address.group)\n\t\t\treturn -ENOMEM;\n\t} else {\n\t\tif (!tomoyo_parse_ipaddr_union(param, &e.address))\n\t\t\tgoto out;\n\t}\n\tif (!tomoyo_parse_number_union(param, &e.port) ||\n\t    e.port.values[1] > 65535)\n\t\tgoto out;\n\terror = tomoyo_update_domain(&e.head, sizeof(e), param,\n\t\t\t\t     tomoyo_same_inet_acl,\n\t\t\t\t     tomoyo_merge_inet_acl);\nout:\n\ttomoyo_put_group(e.address.group);\n\ttomoyo_put_number_union(&e.port);\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_merge_unix_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "256-271",
    "snippet": "static bool tomoyo_merge_unix_acl(struct tomoyo_acl_info *a,\n\t\t\t\t  struct tomoyo_acl_info *b,\n\t\t\t\t  const bool is_delete)\n{\n\tu8 * const a_perm =\n\t\t&container_of(a, struct tomoyo_unix_acl, head)->perm;\n\tu8 perm = *a_perm;\n\tconst u8 b_perm = container_of(b, struct tomoyo_unix_acl, head)->perm;\n\n\tif (is_delete)\n\t\tperm &= ~b_perm;\n\telse\n\t\tperm |= b_perm;\n\t*a_perm = perm;\n\treturn !perm;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "structtomoyo_unix_acl",
            "head"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "structtomoyo_unix_acl",
            "head"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_merge_unix_acl(struct tomoyo_acl_info *a,\n\t\t\t\t  struct tomoyo_acl_info *b,\n\t\t\t\t  const bool is_delete)\n{\n\tu8 * const a_perm =\n\t\t&container_of(a, struct tomoyo_unix_acl, head)->perm;\n\tu8 perm = *a_perm;\n\tconst u8 b_perm = container_of(b, struct tomoyo_unix_acl, head)->perm;\n\n\tif (is_delete)\n\t\tperm &= ~b_perm;\n\telse\n\t\tperm |= b_perm;\n\t*a_perm = perm;\n\treturn !perm;\n}"
  },
  {
    "function_name": "tomoyo_merge_inet_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "230-245",
    "snippet": "static bool tomoyo_merge_inet_acl(struct tomoyo_acl_info *a,\n\t\t\t\t  struct tomoyo_acl_info *b,\n\t\t\t\t  const bool is_delete)\n{\n\tu8 * const a_perm =\n\t\t&container_of(a, struct tomoyo_inet_acl, head)->perm;\n\tu8 perm = *a_perm;\n\tconst u8 b_perm = container_of(b, struct tomoyo_inet_acl, head)->perm;\n\n\tif (is_delete)\n\t\tperm &= ~b_perm;\n\telse\n\t\tperm |= b_perm;\n\t*a_perm = perm;\n\treturn !perm;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "structtomoyo_inet_acl",
            "head"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "structtomoyo_inet_acl",
            "head"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_merge_inet_acl(struct tomoyo_acl_info *a,\n\t\t\t\t  struct tomoyo_acl_info *b,\n\t\t\t\t  const bool is_delete)\n{\n\tu8 * const a_perm =\n\t\t&container_of(a, struct tomoyo_inet_acl, head)->perm;\n\tu8 perm = *a_perm;\n\tconst u8 b_perm = container_of(b, struct tomoyo_inet_acl, head)->perm;\n\n\tif (is_delete)\n\t\tperm &= ~b_perm;\n\telse\n\t\tperm |= b_perm;\n\t*a_perm = perm;\n\treturn !perm;\n}"
  },
  {
    "function_name": "tomoyo_same_unix_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "211-219",
    "snippet": "static bool tomoyo_same_unix_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_unix_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_unix_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn p1->protocol == p2->protocol &&\n\t\ttomoyo_same_name_union(&p1->name, &p2->name);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_same_name_union",
          "args": [
            "&p1->name",
            "&p2->name"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_same_name_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1230-1234",
          "snippet": "static inline bool tomoyo_same_name_union\n(const struct tomoyo_name_union *a, const struct tomoyo_name_union *b)\n{\n\treturn a->filename == b->filename && a->group == b->group;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline bool tomoyo_same_name_union\n(const struct tomoyo_name_union *a, const struct tomoyo_name_union *b)\n{\n\treturn a->filename == b->filename && a->group == b->group;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "typeof(*p2)",
            "head"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p2"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "typeof(*p1)",
            "head"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p1"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_same_unix_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_unix_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_unix_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn p1->protocol == p2->protocol &&\n\t\ttomoyo_same_name_union(&p1->name, &p2->name);\n}"
  },
  {
    "function_name": "tomoyo_same_inet_acl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "192-201",
    "snippet": "static bool tomoyo_same_inet_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_inet_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_inet_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn p1->protocol == p2->protocol &&\n\t\ttomoyo_same_ipaddr_union(&p1->address, &p2->address) &&\n\t\ttomoyo_same_number_union(&p1->port, &p2->port);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_same_number_union",
          "args": [
            "&p1->port",
            "&p2->port"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_same_number_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1244-1250",
          "snippet": "static inline bool tomoyo_same_number_union\n(const struct tomoyo_number_union *a, const struct tomoyo_number_union *b)\n{\n\treturn a->values[0] == b->values[0] && a->values[1] == b->values[1] &&\n\t\ta->group == b->group && a->value_type[0] == b->value_type[0] &&\n\t\ta->value_type[1] == b->value_type[1];\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline bool tomoyo_same_number_union\n(const struct tomoyo_number_union *a, const struct tomoyo_number_union *b)\n{\n\treturn a->values[0] == b->values[0] && a->values[1] == b->values[1] &&\n\t\ta->group == b->group && a->value_type[0] == b->value_type[0] &&\n\t\ta->value_type[1] == b->value_type[1];\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_same_ipaddr_union",
          "args": [
            "&p1->address",
            "&p2->address"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_same_ipaddr_union",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1260-1265",
          "snippet": "static inline bool tomoyo_same_ipaddr_union\n(const struct tomoyo_ipaddr_union *a, const struct tomoyo_ipaddr_union *b)\n{\n\treturn !memcmp(a->ip, b->ip, sizeof(a->ip)) && a->group == b->group &&\n\t\ta->is_ipv6 == b->is_ipv6;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline bool tomoyo_same_ipaddr_union\n(const struct tomoyo_ipaddr_union *a, const struct tomoyo_ipaddr_union *b)\n{\n\treturn !memcmp(a->ip, b->ip, sizeof(a->ip)) && a->group == b->group &&\n\t\ta->is_ipv6 == b->is_ipv6;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "b",
            "typeof(*p2)",
            "head"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p2"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "a",
            "typeof(*p1)",
            "head"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*p1"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic bool tomoyo_same_inet_acl(const struct tomoyo_acl_info *a,\n\t\t\t\t const struct tomoyo_acl_info *b)\n{\n\tconst struct tomoyo_inet_acl *p1 = container_of(a, typeof(*p1), head);\n\tconst struct tomoyo_inet_acl *p2 = container_of(b, typeof(*p2), head);\n\n\treturn p1->protocol == p2->protocol &&\n\t\ttomoyo_same_ipaddr_union(&p1->address, &p2->address) &&\n\t\ttomoyo_same_number_union(&p1->port, &p2->port);\n}"
  },
  {
    "function_name": "tomoyo_print_ip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "124-132",
    "snippet": "void tomoyo_print_ip(char *buf, const unsigned int size,\n\t\t     const struct tomoyo_ipaddr_union *ptr)\n{\n\tif (ptr->is_ipv6)\n\t\ttomoyo_print_ipv6(buf, size, &ptr->ip[0], &ptr->ip[1]);\n\telse\n\t\ttomoyo_print_ipv4(buf, size, &ptr->ip[0].s6_addr32[0],\n\t\t\t\t  &ptr->ip[1].s6_addr32[0]);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_print_ipv4",
          "args": [
            "buf",
            "size",
            "&ptr->ip[0].s6_addr32[0]",
            "&ptr->ip[1].s6_addr32[0]"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_ipv4",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "90-95",
          "snippet": "static void tomoyo_print_ipv4(char *buffer, const unsigned int buffer_len,\n\t\t\t      const __be32 *min_ip, const __be32 *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI4%c%pI4\", min_ip,\n\t\t *min_ip == *max_ip ? '\\0' : '-', max_ip);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic void tomoyo_print_ipv4(char *buffer, const unsigned int buffer_len,\n\t\t\t      const __be32 *min_ip, const __be32 *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI4%c%pI4\", min_ip,\n\t\t *min_ip == *max_ip ? '\\0' : '-', max_ip);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_print_ipv6",
          "args": [
            "buf",
            "size",
            "&ptr->ip[0]",
            "&ptr->ip[1]"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_print_ipv6",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "107-113",
          "snippet": "static void tomoyo_print_ipv6(char *buffer, const unsigned int buffer_len,\n\t\t\t      const struct in6_addr *min_ip,\n\t\t\t      const struct in6_addr *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI6c%c%pI6c\", min_ip,\n\t\t !memcmp(min_ip, max_ip, 16) ? '\\0' : '-', max_ip);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic void tomoyo_print_ipv6(char *buffer, const unsigned int buffer_len,\n\t\t\t      const struct in6_addr *min_ip,\n\t\t\t      const struct in6_addr *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI6c%c%pI6c\", min_ip,\n\t\t !memcmp(min_ip, max_ip, 16) ? '\\0' : '-', max_ip);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nvoid tomoyo_print_ip(char *buf, const unsigned int size,\n\t\t     const struct tomoyo_ipaddr_union *ptr)\n{\n\tif (ptr->is_ipv6)\n\t\ttomoyo_print_ipv6(buf, size, &ptr->ip[0], &ptr->ip[1]);\n\telse\n\t\ttomoyo_print_ipv4(buf, size, &ptr->ip[0].s6_addr32[0],\n\t\t\t\t  &ptr->ip[1].s6_addr32[0]);\n}"
  },
  {
    "function_name": "tomoyo_print_ipv6",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "107-113",
    "snippet": "static void tomoyo_print_ipv6(char *buffer, const unsigned int buffer_len,\n\t\t\t      const struct in6_addr *min_ip,\n\t\t\t      const struct in6_addr *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI6c%c%pI6c\", min_ip,\n\t\t !memcmp(min_ip, max_ip, 16) ? '\\0' : '-', max_ip);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "buffer_len",
            "\"%pI6c%c%pI6c\"",
            "min_ip",
            "!memcmp(min_ip, max_ip, 16) ? '\\0' : '-'",
            "max_ip"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "min_ip",
            "max_ip",
            "16"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic void tomoyo_print_ipv6(char *buffer, const unsigned int buffer_len,\n\t\t\t      const struct in6_addr *min_ip,\n\t\t\t      const struct in6_addr *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI6c%c%pI6c\", min_ip,\n\t\t !memcmp(min_ip, max_ip, 16) ? '\\0' : '-', max_ip);\n}"
  },
  {
    "function_name": "tomoyo_print_ipv4",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "90-95",
    "snippet": "static void tomoyo_print_ipv4(char *buffer, const unsigned int buffer_len,\n\t\t\t      const __be32 *min_ip, const __be32 *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI4%c%pI4\", min_ip,\n\t\t *min_ip == *max_ip ? '\\0' : '-', max_ip);\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buffer",
            "buffer_len",
            "\"%pI4%c%pI4\"",
            "min_ip",
            "*min_ip == *max_ip ? '\\0' : '-'",
            "max_ip"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic void tomoyo_print_ipv4(char *buffer, const unsigned int buffer_len,\n\t\t\t      const __be32 *min_ip, const __be32 *max_ip)\n{\n\tsnprintf(buffer, buffer_len, \"%pI4%c%pI4\", min_ip,\n\t\t *min_ip == *max_ip ? '\\0' : '-', max_ip);\n}"
  },
  {
    "function_name": "tomoyo_parse_ipaddr_union",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
    "lines": "50-78",
    "snippet": "bool tomoyo_parse_ipaddr_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_ipaddr_union *ptr)\n{\n\tu8 * const min = ptr->ip[0].in6_u.u6_addr8;\n\tu8 * const max = ptr->ip[1].in6_u.u6_addr8;\n\tchar *address = tomoyo_read_token(param);\n\tconst char *end;\n\n\tif (!strchr(address, ':') &&\n\t    in4_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = false;\n\t\tif (!*end)\n\t\t\tptr->ip[1].s6_addr32[0] = ptr->ip[0].s6_addr32[0];\n\t\telse if (*end++ != '-' ||\n\t\t\t in4_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tif (in6_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = true;\n\t\tif (!*end)\n\t\t\tmemmove(max, min, sizeof(u16) * 8);\n\t\telse if (*end++ != '-' ||\n\t\t\t in6_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/slab.h>",
      "#include \"common.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "in6_pton",
          "args": [
            "end",
            "-1",
            "max",
            "'\\0'",
            "&end"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "max",
            "min",
            "sizeof(u16) * 8"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in6_pton",
          "args": [
            "address",
            "-1",
            "min",
            "'-'",
            "&end"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in4_pton",
          "args": [
            "end",
            "-1",
            "max",
            "'\\0'",
            "&end"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in4_pton",
          "args": [
            "address",
            "-1",
            "min",
            "'-'",
            "&end"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "address",
            "':'"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_read_token",
          "args": [
            "param"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_token",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/util.c",
          "lines": "131-141",
          "snippet": "char *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n\nchar *tomoyo_read_token(struct tomoyo_acl_param *param)\n{\n\tchar *pos = param->data;\n\tchar *del = strchr(pos, ' ');\n\tif (del)\n\t\t*del++ = '\\0';\n\telse\n\t\tdel = pos + strlen(pos);\n\tparam->data = del;\n\treturn pos;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nbool tomoyo_parse_ipaddr_union(struct tomoyo_acl_param *param,\n\t\t\t       struct tomoyo_ipaddr_union *ptr)\n{\n\tu8 * const min = ptr->ip[0].in6_u.u6_addr8;\n\tu8 * const max = ptr->ip[1].in6_u.u6_addr8;\n\tchar *address = tomoyo_read_token(param);\n\tconst char *end;\n\n\tif (!strchr(address, ':') &&\n\t    in4_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = false;\n\t\tif (!*end)\n\t\t\tptr->ip[1].s6_addr32[0] = ptr->ip[0].s6_addr32[0];\n\t\telse if (*end++ != '-' ||\n\t\t\t in4_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\tif (in6_pton(address, -1, min, '-', &end) > 0) {\n\t\tptr->is_ipv6 = true;\n\t\tif (!*end)\n\t\t\tmemmove(max, min, sizeof(u16) * 8);\n\t\telse if (*end++ != '-' ||\n\t\t\t in6_pton(end, -1, max, '\\0', &end) <= 0 || *end)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\treturn false;\n}"
  }
]