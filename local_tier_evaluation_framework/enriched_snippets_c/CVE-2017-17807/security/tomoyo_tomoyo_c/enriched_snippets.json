[
  {
    "function_name": "tomoyo_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "539-551",
    "snippet": "static int __init tomoyo_init(void)\n{\n\tstruct cred *cred = (struct cred *) current_cred();\n\n\tif (!security_module_enable(\"tomoyo\"))\n\t\treturn 0;\n\t/* register ourselves with the security framework */\n\tsecurity_add_hooks(tomoyo_hooks, ARRAY_SIZE(tomoyo_hooks), \"tomoyo\");\n\tprintk(KERN_INFO \"TOMOYO Linux initialized\\n\");\n\tcred->security = &tomoyo_kernel_domain;\n\ttomoyo_mm_init();\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct security_hook_list tomoyo_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(cred_alloc_blank, tomoyo_cred_alloc_blank),\n\tLSM_HOOK_INIT(cred_prepare, tomoyo_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, tomoyo_cred_transfer),\n\tLSM_HOOK_INIT(cred_free, tomoyo_cred_free),\n\tLSM_HOOK_INIT(bprm_set_creds, tomoyo_bprm_set_creds),\n\tLSM_HOOK_INIT(bprm_check_security, tomoyo_bprm_check_security),\n\tLSM_HOOK_INIT(file_fcntl, tomoyo_file_fcntl),\n\tLSM_HOOK_INIT(file_open, tomoyo_file_open),\n\tLSM_HOOK_INIT(path_truncate, tomoyo_path_truncate),\n\tLSM_HOOK_INIT(path_unlink, tomoyo_path_unlink),\n\tLSM_HOOK_INIT(path_mkdir, tomoyo_path_mkdir),\n\tLSM_HOOK_INIT(path_rmdir, tomoyo_path_rmdir),\n\tLSM_HOOK_INIT(path_symlink, tomoyo_path_symlink),\n\tLSM_HOOK_INIT(path_mknod, tomoyo_path_mknod),\n\tLSM_HOOK_INIT(path_link, tomoyo_path_link),\n\tLSM_HOOK_INIT(path_rename, tomoyo_path_rename),\n\tLSM_HOOK_INIT(inode_getattr, tomoyo_inode_getattr),\n\tLSM_HOOK_INIT(file_ioctl, tomoyo_file_ioctl),\n\tLSM_HOOK_INIT(path_chmod, tomoyo_path_chmod),\n\tLSM_HOOK_INIT(path_chown, tomoyo_path_chown),\n\tLSM_HOOK_INIT(path_chroot, tomoyo_path_chroot),\n\tLSM_HOOK_INIT(sb_mount, tomoyo_sb_mount),\n\tLSM_HOOK_INIT(sb_umount, tomoyo_sb_umount),\n\tLSM_HOOK_INIT(sb_pivotroot, tomoyo_sb_pivotroot),\n\tLSM_HOOK_INIT(socket_bind, tomoyo_socket_bind),\n\tLSM_HOOK_INIT(socket_connect, tomoyo_socket_connect),\n\tLSM_HOOK_INIT(socket_listen, tomoyo_socket_listen),\n\tLSM_HOOK_INIT(socket_sendmsg, tomoyo_socket_sendmsg),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_mm_init",
          "args": [],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_mm_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/memory.c",
          "lines": "191-202",
          "snippet": "void __init tomoyo_mm_init(void)\n{\n\tint idx;\n\tfor (idx = 0; idx < TOMOYO_MAX_HASH; idx++)\n\t\tINIT_LIST_HEAD(&tomoyo_name_list[idx]);\n\ttomoyo_kernel_namespace.name = \"<kernel>\";\n\ttomoyo_init_policy_namespace(&tomoyo_kernel_namespace);\n\ttomoyo_kernel_domain.ns = &tomoyo_kernel_namespace;\n\tINIT_LIST_HEAD(&tomoyo_kernel_domain.acl_info_list);\n\ttomoyo_kernel_domain.domainname = tomoyo_get_name(\"<kernel>\");\n\tlist_add_tail_rcu(&tomoyo_kernel_domain.list, &tomoyo_domain_list);\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct list_head tomoyo_name_list[TOMOYO_MAX_HASH];",
            "struct tomoyo_policy_namespace tomoyo_kernel_namespace;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n#include <linux/hash.h>\n\nstruct list_head tomoyo_name_list[TOMOYO_MAX_HASH];\nstruct tomoyo_policy_namespace tomoyo_kernel_namespace;\n\nvoid __init tomoyo_mm_init(void)\n{\n\tint idx;\n\tfor (idx = 0; idx < TOMOYO_MAX_HASH; idx++)\n\t\tINIT_LIST_HEAD(&tomoyo_name_list[idx]);\n\ttomoyo_kernel_namespace.name = \"<kernel>\";\n\ttomoyo_init_policy_namespace(&tomoyo_kernel_namespace);\n\ttomoyo_kernel_domain.ns = &tomoyo_kernel_namespace;\n\tINIT_LIST_HEAD(&tomoyo_kernel_domain.acl_info_list);\n\ttomoyo_kernel_domain.domainname = tomoyo_get_name(\"<kernel>\");\n\tlist_add_tail_rcu(&tomoyo_kernel_domain.list, &tomoyo_domain_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"TOMOYO Linux initialized\\n\""
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_add_hooks",
          "args": [
            "tomoyo_hooks",
            "ARRAY_SIZE(tomoyo_hooks)",
            "\"tomoyo\""
          ],
          "line": 546
        },
        "resolved": true,
        "details": {
          "function_name": "security_add_hooks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "159-170",
          "snippet": "void __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t\tchar *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\tlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *lsm_names;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nchar *lsm_names;\n\nvoid __init security_add_hooks(struct security_hook_list *hooks, int count,\n\t\t\t\tchar *lsm)\n{\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\thooks[i].lsm = lsm;\n\t\tlist_add_tail_rcu(&hooks[i].list, hooks[i].head);\n\t}\n\tif (lsm_append(lsm, &lsm_names) < 0)\n\t\tpanic(\"%s - Cannot get early memory.\\n\", __func__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "tomoyo_hooks"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_module_enable",
          "args": [
            "\"tomoyo\""
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "security_module_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/security.c",
          "lines": "146-149",
          "snippet": "int __init security_module_enable(const char *module)\n{\n\treturn !strcmp(module, chosen_lsm);\n}",
          "includes": [
            "#include <net/flow.h>",
            "#include <linux/string.h>",
            "#include <linux/backing-dev.h>",
            "#include <linux/personality.h>",
            "#include <linux/mount.h>",
            "#include <linux/mman.h>",
            "#include <linux/fsnotify.h>",
            "#include <linux/evm.h>",
            "#include <linux/ima.h>",
            "#include <linux/integrity.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/dcache.h>",
            "#include <linux/capability.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =\n\tCONFIG_DEFAULT_SECURITY;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <net/flow.h>\n#include <linux/string.h>\n#include <linux/backing-dev.h>\n#include <linux/personality.h>\n#include <linux/mount.h>\n#include <linux/mman.h>\n#include <linux/fsnotify.h>\n#include <linux/evm.h>\n#include <linux/ima.h>\n#include <linux/integrity.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/dcache.h>\n#include <linux/capability.h>\n#include <linux/bpf.h>\n\nstatic __initdata char chosen_lsm[SECURITY_NAME_MAX + 1] =\n\tCONFIG_DEFAULT_SECURITY;\n\nint __init security_module_enable(const char *module)\n{\n\treturn !strcmp(module, chosen_lsm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic struct security_hook_list tomoyo_hooks[] __lsm_ro_after_init = {\n\tLSM_HOOK_INIT(cred_alloc_blank, tomoyo_cred_alloc_blank),\n\tLSM_HOOK_INIT(cred_prepare, tomoyo_cred_prepare),\n\tLSM_HOOK_INIT(cred_transfer, tomoyo_cred_transfer),\n\tLSM_HOOK_INIT(cred_free, tomoyo_cred_free),\n\tLSM_HOOK_INIT(bprm_set_creds, tomoyo_bprm_set_creds),\n\tLSM_HOOK_INIT(bprm_check_security, tomoyo_bprm_check_security),\n\tLSM_HOOK_INIT(file_fcntl, tomoyo_file_fcntl),\n\tLSM_HOOK_INIT(file_open, tomoyo_file_open),\n\tLSM_HOOK_INIT(path_truncate, tomoyo_path_truncate),\n\tLSM_HOOK_INIT(path_unlink, tomoyo_path_unlink),\n\tLSM_HOOK_INIT(path_mkdir, tomoyo_path_mkdir),\n\tLSM_HOOK_INIT(path_rmdir, tomoyo_path_rmdir),\n\tLSM_HOOK_INIT(path_symlink, tomoyo_path_symlink),\n\tLSM_HOOK_INIT(path_mknod, tomoyo_path_mknod),\n\tLSM_HOOK_INIT(path_link, tomoyo_path_link),\n\tLSM_HOOK_INIT(path_rename, tomoyo_path_rename),\n\tLSM_HOOK_INIT(inode_getattr, tomoyo_inode_getattr),\n\tLSM_HOOK_INIT(file_ioctl, tomoyo_file_ioctl),\n\tLSM_HOOK_INIT(path_chmod, tomoyo_path_chmod),\n\tLSM_HOOK_INIT(path_chown, tomoyo_path_chown),\n\tLSM_HOOK_INIT(path_chroot, tomoyo_path_chroot),\n\tLSM_HOOK_INIT(sb_mount, tomoyo_sb_mount),\n\tLSM_HOOK_INIT(sb_umount, tomoyo_sb_umount),\n\tLSM_HOOK_INIT(sb_pivotroot, tomoyo_sb_pivotroot),\n\tLSM_HOOK_INIT(socket_bind, tomoyo_socket_bind),\n\tLSM_HOOK_INIT(socket_connect, tomoyo_socket_connect),\n\tLSM_HOOK_INIT(socket_listen, tomoyo_socket_listen),\n\tLSM_HOOK_INIT(socket_sendmsg, tomoyo_socket_sendmsg),\n};\n\nstatic int __init tomoyo_init(void)\n{\n\tstruct cred *cred = (struct cred *) current_cred();\n\n\tif (!security_module_enable(\"tomoyo\"))\n\t\treturn 0;\n\t/* register ourselves with the security framework */\n\tsecurity_add_hooks(tomoyo_hooks, ARRAY_SIZE(tomoyo_hooks), \"tomoyo\");\n\tprintk(KERN_INFO \"TOMOYO Linux initialized\\n\");\n\tcred->security = &tomoyo_kernel_domain;\n\ttomoyo_mm_init();\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_socket_sendmsg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "490-494",
    "snippet": "static int tomoyo_socket_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t\t int size)\n{\n\treturn tomoyo_socket_sendmsg_permission(sock, msg, size);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_socket_sendmsg_permission",
          "args": [
            "sock",
            "msg",
            "size"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_socket_sendmsg_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "753-772",
          "snippet": "int tomoyo_socket_sendmsg_permission(struct socket *sock, struct msghdr *msg,\n\t\t\t\t     int size)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!msg->msg_name || !family ||\n\t    (type != SOCK_DGRAM && type != SOCK_RAW))\n\t\treturn 0;\n\taddress.protocol = type;\n\taddress.operation = TOMOYO_NETWORK_SEND;\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address((struct sockaddr *)\n\t\t\t\t\t\t msg->msg_name,\n\t\t\t\t\t\t msg->msg_namelen, &address);\n\treturn tomoyo_check_inet_address((struct sockaddr *) msg->msg_name,\n\t\t\t\t\t msg->msg_namelen,\n\t\t\t\t\t sock->sk->sk_protocol, &address);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nint tomoyo_socket_sendmsg_permission(struct socket *sock, struct msghdr *msg,\n\t\t\t\t     int size)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!msg->msg_name || !family ||\n\t    (type != SOCK_DGRAM && type != SOCK_RAW))\n\t\treturn 0;\n\taddress.protocol = type;\n\taddress.operation = TOMOYO_NETWORK_SEND;\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address((struct sockaddr *)\n\t\t\t\t\t\t msg->msg_name,\n\t\t\t\t\t\t msg->msg_namelen, &address);\n\treturn tomoyo_check_inet_address((struct sockaddr *) msg->msg_name,\n\t\t\t\t\t msg->msg_namelen,\n\t\t\t\t\t sock->sk->sk_protocol, &address);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_socket_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t\t\t int size)\n{\n\treturn tomoyo_socket_sendmsg_permission(sock, msg, size);\n}"
  },
  {
    "function_name": "tomoyo_socket_bind",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "475-479",
    "snippet": "static int tomoyo_socket_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int addr_len)\n{\n\treturn tomoyo_socket_bind_permission(sock, addr, addr_len);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_socket_bind_permission",
          "args": [
            "sock",
            "addr",
            "addr_len"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_socket_bind_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "718-742",
          "snippet": "int tomoyo_socket_bind_permission(struct socket *sock, struct sockaddr *addr,\n\t\t\t\t  int addr_len)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!family)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SOCK_STREAM:\n\tcase SOCK_DGRAM:\n\tcase SOCK_RAW:\n\tcase SOCK_SEQPACKET:\n\t\taddress.protocol = type;\n\t\taddress.operation = TOMOYO_NETWORK_BIND;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address(addr, addr_len, &address);\n\treturn tomoyo_check_inet_address(addr, addr_len, sock->sk->sk_protocol,\n\t\t\t\t\t &address);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nint tomoyo_socket_bind_permission(struct socket *sock, struct sockaddr *addr,\n\t\t\t\t  int addr_len)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!family)\n\t\treturn 0;\n\tswitch (type) {\n\tcase SOCK_STREAM:\n\tcase SOCK_DGRAM:\n\tcase SOCK_RAW:\n\tcase SOCK_SEQPACKET:\n\t\taddress.protocol = type;\n\t\taddress.operation = TOMOYO_NETWORK_BIND;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address(addr, addr_len, &address);\n\treturn tomoyo_check_inet_address(addr, addr_len, sock->sk->sk_protocol,\n\t\t\t\t\t &address);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_socket_bind(struct socket *sock, struct sockaddr *addr,\n\t\t\t      int addr_len)\n{\n\treturn tomoyo_socket_bind_permission(sock, addr, addr_len);\n}"
  },
  {
    "function_name": "tomoyo_socket_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "460-464",
    "snippet": "static int tomoyo_socket_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t\t int addr_len)\n{\n\treturn tomoyo_socket_connect_permission(sock, addr, addr_len);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_socket_connect_permission",
          "args": [
            "sock",
            "addr",
            "addr_len"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_socket_connect_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "681-707",
          "snippet": "int tomoyo_socket_connect_permission(struct socket *sock,\n\t\t\t\t     struct sockaddr *addr, int addr_len)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!family)\n\t\treturn 0;\n\taddress.protocol = type;\n\tswitch (type) {\n\tcase SOCK_DGRAM:\n\tcase SOCK_RAW:\n\t\taddress.operation = TOMOYO_NETWORK_SEND;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\tcase SOCK_SEQPACKET:\n\t\taddress.operation = TOMOYO_NETWORK_CONNECT;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address(addr, addr_len, &address);\n\treturn tomoyo_check_inet_address(addr, addr_len, sock->sk->sk_protocol,\n\t\t\t\t\t &address);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nint tomoyo_socket_connect_permission(struct socket *sock,\n\t\t\t\t     struct sockaddr *addr, int addr_len)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\n\tif (!family)\n\t\treturn 0;\n\taddress.protocol = type;\n\tswitch (type) {\n\tcase SOCK_DGRAM:\n\tcase SOCK_RAW:\n\t\taddress.operation = TOMOYO_NETWORK_SEND;\n\t\tbreak;\n\tcase SOCK_STREAM:\n\tcase SOCK_SEQPACKET:\n\t\taddress.operation = TOMOYO_NETWORK_CONNECT;\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address(addr, addr_len, &address);\n\treturn tomoyo_check_inet_address(addr, addr_len, sock->sk->sk_protocol,\n\t\t\t\t\t &address);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_socket_connect(struct socket *sock, struct sockaddr *addr,\n\t\t\t\t int addr_len)\n{\n\treturn tomoyo_socket_connect_permission(sock, addr, addr_len);\n}"
  },
  {
    "function_name": "tomoyo_socket_listen",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "446-449",
    "snippet": "static int tomoyo_socket_listen(struct socket *sock, int backlog)\n{\n\treturn tomoyo_socket_listen_permission(sock);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_socket_listen_permission",
          "args": [
            "sock"
          ],
          "line": 448
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_socket_listen_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/network.c",
          "lines": "646-670",
          "snippet": "int tomoyo_socket_listen_permission(struct socket *sock)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\tstruct sockaddr_storage addr;\n\tint addr_len;\n\n\tif (!family || (type != SOCK_STREAM && type != SOCK_SEQPACKET))\n\t\treturn 0;\n\t{\n\t\tconst int error = sock->ops->getname(sock, (struct sockaddr *)\n\t\t\t\t\t\t     &addr, &addr_len, 0);\n\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\taddress.protocol = type;\n\taddress.operation = TOMOYO_NETWORK_LISTEN;\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address((struct sockaddr *) &addr,\n\t\t\t\t\t\t addr_len, &address);\n\treturn tomoyo_check_inet_address((struct sockaddr *) &addr, addr_len,\n\t\t\t\t\t 0, &address);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nint tomoyo_socket_listen_permission(struct socket *sock)\n{\n\tstruct tomoyo_addr_info address;\n\tconst u8 family = tomoyo_sock_family(sock->sk);\n\tconst unsigned int type = sock->type;\n\tstruct sockaddr_storage addr;\n\tint addr_len;\n\n\tif (!family || (type != SOCK_STREAM && type != SOCK_SEQPACKET))\n\t\treturn 0;\n\t{\n\t\tconst int error = sock->ops->getname(sock, (struct sockaddr *)\n\t\t\t\t\t\t     &addr, &addr_len, 0);\n\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\taddress.protocol = type;\n\taddress.operation = TOMOYO_NETWORK_LISTEN;\n\tif (family == PF_UNIX)\n\t\treturn tomoyo_check_unix_address((struct sockaddr *) &addr,\n\t\t\t\t\t\t addr_len, &address);\n\treturn tomoyo_check_inet_address((struct sockaddr *) &addr, addr_len,\n\t\t\t\t\t 0, &address);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_socket_listen(struct socket *sock, int backlog)\n{\n\treturn tomoyo_socket_listen_permission(sock);\n}"
  },
  {
    "function_name": "tomoyo_sb_pivotroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "433-436",
    "snippet": "static int tomoyo_sb_pivotroot(const struct path *old_path, const struct path *new_path)\n{\n\treturn tomoyo_path2_perm(TOMOYO_TYPE_PIVOT_ROOT, new_path, old_path);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path2_perm",
          "args": [
            "TOMOYO_TYPE_PIVOT_ROOT",
            "new_path",
            "old_path"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path2_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "886-935",
          "snippet": "int tomoyo_path2_perm(const u8 operation, const struct path *path1,\n\t\t      const struct path *path2)\n{\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf1;\n\tstruct tomoyo_path_info buf2;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path1->mnt, .dentry = path1->dentry },\n\t\t.path2 = { .mnt = path2->mnt, .dentry = path2->dentry }\n\t};\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pp2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tbuf1.name = NULL;\n\tbuf2.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf1, path1) ||\n\t    !tomoyo_get_realpath(&buf2, path2))\n\t\tgoto out;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RENAME:\n\tcase TOMOYO_TYPE_LINK:\n\t\tif (!d_is_dir(path1->dentry))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase TOMOYO_TYPE_PIVOT_ROOT:\n\t\ttomoyo_add_slash(&buf1);\n\t\ttomoyo_add_slash(&buf2);\n\t\tbreak;\n\t}\n\tr.obj = &obj;\n\tr.param_type = TOMOYO_TYPE_PATH2_ACL;\n\tr.param.path2.operation = operation;\n\tr.param.path2.filename1 = &buf1;\n\tr.param.path2.filename2 = &buf2;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path2_acl);\n\t\terror = tomoyo_audit_path2_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(buf1.name);\n\tkfree(buf2.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const u8 tomoyo_pp2mac[TOMOYO_MAX_PATH2_OPERATION] = {\n\t[TOMOYO_TYPE_LINK]       = TOMOYO_MAC_FILE_LINK,\n\t[TOMOYO_TYPE_RENAME]     = TOMOYO_MAC_FILE_RENAME,\n\t[TOMOYO_TYPE_PIVOT_ROOT] = TOMOYO_MAC_FILE_PIVOT_ROOT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst u8 tomoyo_pp2mac[TOMOYO_MAX_PATH2_OPERATION] = {\n\t[TOMOYO_TYPE_LINK]       = TOMOYO_MAC_FILE_LINK,\n\t[TOMOYO_TYPE_RENAME]     = TOMOYO_MAC_FILE_RENAME,\n\t[TOMOYO_TYPE_PIVOT_ROOT] = TOMOYO_MAC_FILE_PIVOT_ROOT,\n};\n\nint tomoyo_path2_perm(const u8 operation, const struct path *path1,\n\t\t      const struct path *path2)\n{\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf1;\n\tstruct tomoyo_path_info buf2;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path1->mnt, .dentry = path1->dentry },\n\t\t.path2 = { .mnt = path2->mnt, .dentry = path2->dentry }\n\t};\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pp2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tbuf1.name = NULL;\n\tbuf2.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf1, path1) ||\n\t    !tomoyo_get_realpath(&buf2, path2))\n\t\tgoto out;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RENAME:\n\tcase TOMOYO_TYPE_LINK:\n\t\tif (!d_is_dir(path1->dentry))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase TOMOYO_TYPE_PIVOT_ROOT:\n\t\ttomoyo_add_slash(&buf1);\n\t\ttomoyo_add_slash(&buf2);\n\t\tbreak;\n\t}\n\tr.obj = &obj;\n\tr.param_type = TOMOYO_TYPE_PATH2_ACL;\n\tr.param.path2.operation = operation;\n\tr.param.path2.filename1 = &buf1;\n\tr.param.path2.filename2 = &buf2;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path2_acl);\n\t\terror = tomoyo_audit_path2_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(buf1.name);\n\tkfree(buf2.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_sb_pivotroot(const struct path *old_path, const struct path *new_path)\n{\n\treturn tomoyo_path2_perm(TOMOYO_TYPE_PIVOT_ROOT, new_path, old_path);\n}"
  },
  {
    "function_name": "tomoyo_sb_umount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "419-423",
    "snippet": "static int tomoyo_sb_umount(struct vfsmount *mnt, int flags)\n{\n\tstruct path path = { .mnt = mnt, .dentry = mnt->mnt_root };\n\treturn tomoyo_path_perm(TOMOYO_TYPE_UMOUNT, &path, NULL);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_perm",
          "args": [
            "TOMOYO_TYPE_UMOUNT",
            "&path",
            "NULL"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "786-830",
          "snippet": "int tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};\n\nint tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_sb_umount(struct vfsmount *mnt, int flags)\n{\n\tstruct path path = { .mnt = mnt, .dentry = mnt->mnt_root };\n\treturn tomoyo_path_perm(TOMOYO_TYPE_UMOUNT, &path, NULL);\n}"
  },
  {
    "function_name": "tomoyo_sb_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "405-409",
    "snippet": "static int tomoyo_sb_mount(const char *dev_name, const struct path *path,\n\t\t\t   const char *type, unsigned long flags, void *data)\n{\n\treturn tomoyo_mount_permission(dev_name, path, type, flags, data);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_mount_permission",
          "args": [
            "dev_name",
            "path",
            "type",
            "flags",
            "data"
          ],
          "line": 408
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_mount_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/mount.c",
          "lines": "188-237",
          "snippet": "int tomoyo_mount_permission(const char *dev_name, const struct path *path,\n\t\t\t    const char *type, unsigned long flags,\n\t\t\t    void *data_page)\n{\n\tstruct tomoyo_request_info r;\n\tint error;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_MOUNT)\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\tif (flags & MS_REMOUNT) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_REMOUNT];\n\t\tflags &= ~MS_REMOUNT;\n\t} else if (flags & MS_BIND) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_BIND];\n\t\tflags &= ~MS_BIND;\n\t} else if (flags & MS_SHARED) {\n\t\tif (flags & (MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_SHARED];\n\t\tflags &= ~MS_SHARED;\n\t} else if (flags & MS_PRIVATE) {\n\t\tif (flags & (MS_SHARED | MS_SLAVE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_PRIVATE];\n\t\tflags &= ~MS_PRIVATE;\n\t} else if (flags & MS_SLAVE) {\n\t\tif (flags & (MS_SHARED | MS_PRIVATE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_SLAVE];\n\t\tflags &= ~MS_SLAVE;\n\t} else if (flags & MS_UNBINDABLE) {\n\t\tif (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_UNBINDABLE];\n\t\tflags &= ~MS_UNBINDABLE;\n\t} else if (flags & MS_MOVE) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MOVE];\n\t\tflags &= ~MS_MOVE;\n\t}\n\tif (!type)\n\t\ttype = \"<NULL>\";\n\tidx = tomoyo_read_lock();\n\terror = tomoyo_mount_acl(&r, dev_name, path, type, flags);\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const tomoyo_mounts[TOMOYO_MAX_SPECIAL_MOUNT] = {\n\t[TOMOYO_MOUNT_BIND]            = \"--bind\",\n\t[TOMOYO_MOUNT_MOVE]            = \"--move\",\n\t[TOMOYO_MOUNT_REMOUNT]         = \"--remount\",\n\t[TOMOYO_MOUNT_MAKE_UNBINDABLE] = \"--make-unbindable\",\n\t[TOMOYO_MOUNT_MAKE_PRIVATE]    = \"--make-private\",\n\t[TOMOYO_MOUNT_MAKE_SLAVE]      = \"--make-slave\",\n\t[TOMOYO_MOUNT_MAKE_SHARED]     = \"--make-shared\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/slab.h>\n\nstatic const char * const tomoyo_mounts[TOMOYO_MAX_SPECIAL_MOUNT] = {\n\t[TOMOYO_MOUNT_BIND]            = \"--bind\",\n\t[TOMOYO_MOUNT_MOVE]            = \"--move\",\n\t[TOMOYO_MOUNT_REMOUNT]         = \"--remount\",\n\t[TOMOYO_MOUNT_MAKE_UNBINDABLE] = \"--make-unbindable\",\n\t[TOMOYO_MOUNT_MAKE_PRIVATE]    = \"--make-private\",\n\t[TOMOYO_MOUNT_MAKE_SLAVE]      = \"--make-slave\",\n\t[TOMOYO_MOUNT_MAKE_SHARED]     = \"--make-shared\",\n};\n\nint tomoyo_mount_permission(const char *dev_name, const struct path *path,\n\t\t\t    const char *type, unsigned long flags,\n\t\t\t    void *data_page)\n{\n\tstruct tomoyo_request_info r;\n\tint error;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, TOMOYO_MAC_FILE_MOUNT)\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tif ((flags & MS_MGC_MSK) == MS_MGC_VAL)\n\t\tflags &= ~MS_MGC_MSK;\n\tif (flags & MS_REMOUNT) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_REMOUNT];\n\t\tflags &= ~MS_REMOUNT;\n\t} else if (flags & MS_BIND) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_BIND];\n\t\tflags &= ~MS_BIND;\n\t} else if (flags & MS_SHARED) {\n\t\tif (flags & (MS_PRIVATE | MS_SLAVE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_SHARED];\n\t\tflags &= ~MS_SHARED;\n\t} else if (flags & MS_PRIVATE) {\n\t\tif (flags & (MS_SHARED | MS_SLAVE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_PRIVATE];\n\t\tflags &= ~MS_PRIVATE;\n\t} else if (flags & MS_SLAVE) {\n\t\tif (flags & (MS_SHARED | MS_PRIVATE | MS_UNBINDABLE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_SLAVE];\n\t\tflags &= ~MS_SLAVE;\n\t} else if (flags & MS_UNBINDABLE) {\n\t\tif (flags & (MS_SHARED | MS_PRIVATE | MS_SLAVE))\n\t\t\treturn -EINVAL;\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MAKE_UNBINDABLE];\n\t\tflags &= ~MS_UNBINDABLE;\n\t} else if (flags & MS_MOVE) {\n\t\ttype = tomoyo_mounts[TOMOYO_MOUNT_MOVE];\n\t\tflags &= ~MS_MOVE;\n\t}\n\tif (!type)\n\t\ttype = \"<NULL>\";\n\tidx = tomoyo_read_lock();\n\terror = tomoyo_mount_acl(&r, dev_name, path, type, flags);\n\ttomoyo_read_unlock(idx);\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_sb_mount(const char *dev_name, const struct path *path,\n\t\t\t   const char *type, unsigned long flags, void *data)\n{\n\treturn tomoyo_mount_permission(dev_name, path, type, flags, data);\n}"
  },
  {
    "function_name": "tomoyo_path_chroot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "389-392",
    "snippet": "static int tomoyo_path_chroot(const struct path *path)\n{\n\treturn tomoyo_path_perm(TOMOYO_TYPE_CHROOT, path, NULL);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_perm",
          "args": [
            "TOMOYO_TYPE_CHROOT",
            "path",
            "NULL"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "786-830",
          "snippet": "int tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};\n\nint tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_path_chroot(const struct path *path)\n{\n\treturn tomoyo_path_perm(TOMOYO_TYPE_CHROOT, path, NULL);\n}"
  },
  {
    "function_name": "tomoyo_path_chown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "370-380",
    "snippet": "static int tomoyo_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n{\n\tint error = 0;\n\tif (uid_valid(uid))\n\t\terror = tomoyo_path_number_perm(TOMOYO_TYPE_CHOWN, path,\n\t\t\t\t\t\tfrom_kuid(&init_user_ns, uid));\n\tif (!error && gid_valid(gid))\n\t\terror = tomoyo_path_number_perm(TOMOYO_TYPE_CHGRP, path,\n\t\t\t\t\t\tfrom_kgid(&init_user_ns, gid));\n\treturn error;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_number_perm",
          "args": [
            "TOMOYO_TYPE_CHGRP",
            "path",
            "from_kgid(&init_user_ns, gid)"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_number_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "691-725",
          "snippet": "int tomoyo_path_number_perm(const u8 type, const struct path *path,\n\t\t\t    unsigned long number)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])\n\t    == TOMOYO_CONFIG_DISABLED || !path->dentry)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tif (type == TOMOYO_TYPE_MKDIR)\n\t\ttomoyo_add_slash(&buf);\n\tr.param_type = TOMOYO_TYPE_PATH_NUMBER_ACL;\n\tr.param.path_number.operation = type;\n\tr.param.path_number.filename = &buf;\n\tr.param.path_number.number = number;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path_number_acl);\n\t\terror = tomoyo_audit_path_number_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\tkfree(buf.name);\n out:\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION] = {\n\t[TOMOYO_TYPE_CREATE] = TOMOYO_MAC_FILE_CREATE,\n\t[TOMOYO_TYPE_MKDIR]  = TOMOYO_MAC_FILE_MKDIR,\n\t[TOMOYO_TYPE_MKFIFO] = TOMOYO_MAC_FILE_MKFIFO,\n\t[TOMOYO_TYPE_MKSOCK] = TOMOYO_MAC_FILE_MKSOCK,\n\t[TOMOYO_TYPE_IOCTL]  = TOMOYO_MAC_FILE_IOCTL,\n\t[TOMOYO_TYPE_CHMOD]  = TOMOYO_MAC_FILE_CHMOD,\n\t[TOMOYO_TYPE_CHOWN]  = TOMOYO_MAC_FILE_CHOWN,\n\t[TOMOYO_TYPE_CHGRP]  = TOMOYO_MAC_FILE_CHGRP,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION] = {\n\t[TOMOYO_TYPE_CREATE] = TOMOYO_MAC_FILE_CREATE,\n\t[TOMOYO_TYPE_MKDIR]  = TOMOYO_MAC_FILE_MKDIR,\n\t[TOMOYO_TYPE_MKFIFO] = TOMOYO_MAC_FILE_MKFIFO,\n\t[TOMOYO_TYPE_MKSOCK] = TOMOYO_MAC_FILE_MKSOCK,\n\t[TOMOYO_TYPE_IOCTL]  = TOMOYO_MAC_FILE_IOCTL,\n\t[TOMOYO_TYPE_CHMOD]  = TOMOYO_MAC_FILE_CHMOD,\n\t[TOMOYO_TYPE_CHOWN]  = TOMOYO_MAC_FILE_CHOWN,\n\t[TOMOYO_TYPE_CHGRP]  = TOMOYO_MAC_FILE_CHGRP,\n};\n\nint tomoyo_path_number_perm(const u8 type, const struct path *path,\n\t\t\t    unsigned long number)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])\n\t    == TOMOYO_CONFIG_DISABLED || !path->dentry)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tif (type == TOMOYO_TYPE_MKDIR)\n\t\ttomoyo_add_slash(&buf);\n\tr.param_type = TOMOYO_TYPE_PATH_NUMBER_ACL;\n\tr.param.path_number.operation = type;\n\tr.param.path_number.filename = &buf;\n\tr.param.path_number.number = number;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path_number_acl);\n\t\terror = tomoyo_audit_path_number_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\tkfree(buf.name);\n out:\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "gid"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "gid"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "uid"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "uid"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_path_chown(const struct path *path, kuid_t uid, kgid_t gid)\n{\n\tint error = 0;\n\tif (uid_valid(uid))\n\t\terror = tomoyo_path_number_perm(TOMOYO_TYPE_CHOWN, path,\n\t\t\t\t\t\tfrom_kuid(&init_user_ns, uid));\n\tif (!error && gid_valid(gid))\n\t\terror = tomoyo_path_number_perm(TOMOYO_TYPE_CHGRP, path,\n\t\t\t\t\t\tfrom_kgid(&init_user_ns, gid));\n\treturn error;\n}"
  },
  {
    "function_name": "tomoyo_path_chmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "355-359",
    "snippet": "static int tomoyo_path_chmod(const struct path *path, umode_t mode)\n{\n\treturn tomoyo_path_number_perm(TOMOYO_TYPE_CHMOD, path,\n\t\t\t\t       mode & S_IALLUGO);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_number_perm",
          "args": [
            "TOMOYO_TYPE_CHMOD",
            "path",
            "mode & S_IALLUGO"
          ],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_number_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "691-725",
          "snippet": "int tomoyo_path_number_perm(const u8 type, const struct path *path,\n\t\t\t    unsigned long number)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])\n\t    == TOMOYO_CONFIG_DISABLED || !path->dentry)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tif (type == TOMOYO_TYPE_MKDIR)\n\t\ttomoyo_add_slash(&buf);\n\tr.param_type = TOMOYO_TYPE_PATH_NUMBER_ACL;\n\tr.param.path_number.operation = type;\n\tr.param.path_number.filename = &buf;\n\tr.param.path_number.number = number;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path_number_acl);\n\t\terror = tomoyo_audit_path_number_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\tkfree(buf.name);\n out:\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION] = {\n\t[TOMOYO_TYPE_CREATE] = TOMOYO_MAC_FILE_CREATE,\n\t[TOMOYO_TYPE_MKDIR]  = TOMOYO_MAC_FILE_MKDIR,\n\t[TOMOYO_TYPE_MKFIFO] = TOMOYO_MAC_FILE_MKFIFO,\n\t[TOMOYO_TYPE_MKSOCK] = TOMOYO_MAC_FILE_MKSOCK,\n\t[TOMOYO_TYPE_IOCTL]  = TOMOYO_MAC_FILE_IOCTL,\n\t[TOMOYO_TYPE_CHMOD]  = TOMOYO_MAC_FILE_CHMOD,\n\t[TOMOYO_TYPE_CHOWN]  = TOMOYO_MAC_FILE_CHOWN,\n\t[TOMOYO_TYPE_CHGRP]  = TOMOYO_MAC_FILE_CHGRP,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION] = {\n\t[TOMOYO_TYPE_CREATE] = TOMOYO_MAC_FILE_CREATE,\n\t[TOMOYO_TYPE_MKDIR]  = TOMOYO_MAC_FILE_MKDIR,\n\t[TOMOYO_TYPE_MKFIFO] = TOMOYO_MAC_FILE_MKFIFO,\n\t[TOMOYO_TYPE_MKSOCK] = TOMOYO_MAC_FILE_MKSOCK,\n\t[TOMOYO_TYPE_IOCTL]  = TOMOYO_MAC_FILE_IOCTL,\n\t[TOMOYO_TYPE_CHMOD]  = TOMOYO_MAC_FILE_CHMOD,\n\t[TOMOYO_TYPE_CHOWN]  = TOMOYO_MAC_FILE_CHOWN,\n\t[TOMOYO_TYPE_CHGRP]  = TOMOYO_MAC_FILE_CHGRP,\n};\n\nint tomoyo_path_number_perm(const u8 type, const struct path *path,\n\t\t\t    unsigned long number)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])\n\t    == TOMOYO_CONFIG_DISABLED || !path->dentry)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tif (type == TOMOYO_TYPE_MKDIR)\n\t\ttomoyo_add_slash(&buf);\n\tr.param_type = TOMOYO_TYPE_PATH_NUMBER_ACL;\n\tr.param.path_number.operation = type;\n\tr.param.path_number.filename = &buf;\n\tr.param.path_number.number = number;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path_number_acl);\n\t\terror = tomoyo_audit_path_number_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\tkfree(buf.name);\n out:\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_path_chmod(const struct path *path, umode_t mode)\n{\n\treturn tomoyo_path_number_perm(TOMOYO_TYPE_CHMOD, path,\n\t\t\t\t       mode & S_IALLUGO);\n}"
  },
  {
    "function_name": "tomoyo_file_ioctl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "341-345",
    "snippet": "static int tomoyo_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\treturn tomoyo_path_number_perm(TOMOYO_TYPE_IOCTL, &file->f_path, cmd);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_number_perm",
          "args": [
            "TOMOYO_TYPE_IOCTL",
            "&file->f_path",
            "cmd"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_number_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "691-725",
          "snippet": "int tomoyo_path_number_perm(const u8 type, const struct path *path,\n\t\t\t    unsigned long number)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])\n\t    == TOMOYO_CONFIG_DISABLED || !path->dentry)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tif (type == TOMOYO_TYPE_MKDIR)\n\t\ttomoyo_add_slash(&buf);\n\tr.param_type = TOMOYO_TYPE_PATH_NUMBER_ACL;\n\tr.param.path_number.operation = type;\n\tr.param.path_number.filename = &buf;\n\tr.param.path_number.number = number;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path_number_acl);\n\t\terror = tomoyo_audit_path_number_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\tkfree(buf.name);\n out:\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION] = {\n\t[TOMOYO_TYPE_CREATE] = TOMOYO_MAC_FILE_CREATE,\n\t[TOMOYO_TYPE_MKDIR]  = TOMOYO_MAC_FILE_MKDIR,\n\t[TOMOYO_TYPE_MKFIFO] = TOMOYO_MAC_FILE_MKFIFO,\n\t[TOMOYO_TYPE_MKSOCK] = TOMOYO_MAC_FILE_MKSOCK,\n\t[TOMOYO_TYPE_IOCTL]  = TOMOYO_MAC_FILE_IOCTL,\n\t[TOMOYO_TYPE_CHMOD]  = TOMOYO_MAC_FILE_CHMOD,\n\t[TOMOYO_TYPE_CHOWN]  = TOMOYO_MAC_FILE_CHOWN,\n\t[TOMOYO_TYPE_CHGRP]  = TOMOYO_MAC_FILE_CHGRP,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION] = {\n\t[TOMOYO_TYPE_CREATE] = TOMOYO_MAC_FILE_CREATE,\n\t[TOMOYO_TYPE_MKDIR]  = TOMOYO_MAC_FILE_MKDIR,\n\t[TOMOYO_TYPE_MKFIFO] = TOMOYO_MAC_FILE_MKFIFO,\n\t[TOMOYO_TYPE_MKSOCK] = TOMOYO_MAC_FILE_MKSOCK,\n\t[TOMOYO_TYPE_IOCTL]  = TOMOYO_MAC_FILE_IOCTL,\n\t[TOMOYO_TYPE_CHMOD]  = TOMOYO_MAC_FILE_CHMOD,\n\t[TOMOYO_TYPE_CHOWN]  = TOMOYO_MAC_FILE_CHOWN,\n\t[TOMOYO_TYPE_CHGRP]  = TOMOYO_MAC_FILE_CHGRP,\n};\n\nint tomoyo_path_number_perm(const u8 type, const struct path *path,\n\t\t\t    unsigned long number)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])\n\t    == TOMOYO_CONFIG_DISABLED || !path->dentry)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tif (type == TOMOYO_TYPE_MKDIR)\n\t\ttomoyo_add_slash(&buf);\n\tr.param_type = TOMOYO_TYPE_PATH_NUMBER_ACL;\n\tr.param.path_number.operation = type;\n\tr.param.path_number.filename = &buf;\n\tr.param.path_number.number = number;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path_number_acl);\n\t\terror = tomoyo_audit_path_number_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\tkfree(buf.name);\n out:\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_file_ioctl(struct file *file, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\treturn tomoyo_path_number_perm(TOMOYO_TYPE_IOCTL, &file->f_path, cmd);\n}"
  },
  {
    "function_name": "tomoyo_file_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "323-330",
    "snippet": "static int tomoyo_file_open(struct file *f, const struct cred *cred)\n{\n\tint flags = f->f_flags;\n\t/* Don't check read permission here if called from do_execve(). */\n\tif (current->in_execve)\n\t\treturn 0;\n\treturn tomoyo_check_open_permission(tomoyo_domain(), &f->f_path, flags);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_check_open_permission",
          "args": [
            "tomoyo_domain()",
            "&f->f_path",
            "flags"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_open_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "736-774",
          "snippet": "int tomoyo_check_open_permission(struct tomoyo_domain_info *domain,\n\t\t\t\t const struct path *path, const int flag)\n{\n\tconst u8 acc_mode = ACC_MODE(flag);\n\tint error = 0;\n\tstruct tomoyo_path_info buf;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint idx;\n\n\tbuf.name = NULL;\n\tr.mode = TOMOYO_CONFIG_DISABLED;\n\tidx = tomoyo_read_lock();\n\tif (acc_mode &&\n\t    tomoyo_init_request_info(&r, domain, TOMOYO_MAC_FILE_OPEN)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tif (!tomoyo_get_realpath(&buf, path)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tr.obj = &obj;\n\t\tif (acc_mode & MAY_READ)\n\t\t\terror = tomoyo_path_permission(&r, TOMOYO_TYPE_READ,\n\t\t\t\t\t\t       &buf);\n\t\tif (!error && (acc_mode & MAY_WRITE))\n\t\t\terror = tomoyo_path_permission(&r, (flag & O_APPEND) ?\n\t\t\t\t\t\t       TOMOYO_TYPE_APPEND :\n\t\t\t\t\t\t       TOMOYO_TYPE_WRITE,\n\t\t\t\t\t\t       &buf);\n\t}\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nint tomoyo_check_open_permission(struct tomoyo_domain_info *domain,\n\t\t\t\t const struct path *path, const int flag)\n{\n\tconst u8 acc_mode = ACC_MODE(flag);\n\tint error = 0;\n\tstruct tomoyo_path_info buf;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint idx;\n\n\tbuf.name = NULL;\n\tr.mode = TOMOYO_CONFIG_DISABLED;\n\tidx = tomoyo_read_lock();\n\tif (acc_mode &&\n\t    tomoyo_init_request_info(&r, domain, TOMOYO_MAC_FILE_OPEN)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tif (!tomoyo_get_realpath(&buf, path)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tr.obj = &obj;\n\t\tif (acc_mode & MAY_READ)\n\t\t\terror = tomoyo_path_permission(&r, TOMOYO_TYPE_READ,\n\t\t\t\t\t\t       &buf);\n\t\tif (!error && (acc_mode & MAY_WRITE))\n\t\t\terror = tomoyo_path_permission(&r, (flag & O_APPEND) ?\n\t\t\t\t\t\t       TOMOYO_TYPE_APPEND :\n\t\t\t\t\t\t       TOMOYO_TYPE_WRITE,\n\t\t\t\t\t\t       &buf);\n\t}\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_domain",
          "args": [],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1204-1207",
          "snippet": "static inline struct tomoyo_domain_info *tomoyo_domain(void)\n{\n\treturn current_cred()->security;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline struct tomoyo_domain_info *tomoyo_domain(void)\n{\n\treturn current_cred()->security;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_file_open(struct file *f, const struct cred *cred)\n{\n\tint flags = f->f_flags;\n\t/* Don't check read permission here if called from do_execve(). */\n\tif (current->in_execve)\n\t\treturn 0;\n\treturn tomoyo_check_open_permission(tomoyo_domain(), &f->f_path, flags);\n}"
  },
  {
    "function_name": "tomoyo_file_fcntl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "306-313",
    "snippet": "static int tomoyo_file_fcntl(struct file *file, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tif (!(cmd == F_SETFL && ((arg ^ file->f_flags) & O_APPEND)))\n\t\treturn 0;\n\treturn tomoyo_check_open_permission(tomoyo_domain(), &file->f_path,\n\t\t\t\t\t    O_WRONLY | (arg & O_APPEND));\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_check_open_permission",
          "args": [
            "tomoyo_domain()",
            "&file->f_path",
            "O_WRONLY | (arg & O_APPEND)"
          ],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_open_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "736-774",
          "snippet": "int tomoyo_check_open_permission(struct tomoyo_domain_info *domain,\n\t\t\t\t const struct path *path, const int flag)\n{\n\tconst u8 acc_mode = ACC_MODE(flag);\n\tint error = 0;\n\tstruct tomoyo_path_info buf;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint idx;\n\n\tbuf.name = NULL;\n\tr.mode = TOMOYO_CONFIG_DISABLED;\n\tidx = tomoyo_read_lock();\n\tif (acc_mode &&\n\t    tomoyo_init_request_info(&r, domain, TOMOYO_MAC_FILE_OPEN)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tif (!tomoyo_get_realpath(&buf, path)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tr.obj = &obj;\n\t\tif (acc_mode & MAY_READ)\n\t\t\terror = tomoyo_path_permission(&r, TOMOYO_TYPE_READ,\n\t\t\t\t\t\t       &buf);\n\t\tif (!error && (acc_mode & MAY_WRITE))\n\t\t\terror = tomoyo_path_permission(&r, (flag & O_APPEND) ?\n\t\t\t\t\t\t       TOMOYO_TYPE_APPEND :\n\t\t\t\t\t\t       TOMOYO_TYPE_WRITE,\n\t\t\t\t\t\t       &buf);\n\t}\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nint tomoyo_check_open_permission(struct tomoyo_domain_info *domain,\n\t\t\t\t const struct path *path, const int flag)\n{\n\tconst u8 acc_mode = ACC_MODE(flag);\n\tint error = 0;\n\tstruct tomoyo_path_info buf;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint idx;\n\n\tbuf.name = NULL;\n\tr.mode = TOMOYO_CONFIG_DISABLED;\n\tidx = tomoyo_read_lock();\n\tif (acc_mode &&\n\t    tomoyo_init_request_info(&r, domain, TOMOYO_MAC_FILE_OPEN)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tif (!tomoyo_get_realpath(&buf, path)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tr.obj = &obj;\n\t\tif (acc_mode & MAY_READ)\n\t\t\terror = tomoyo_path_permission(&r, TOMOYO_TYPE_READ,\n\t\t\t\t\t\t       &buf);\n\t\tif (!error && (acc_mode & MAY_WRITE))\n\t\t\terror = tomoyo_path_permission(&r, (flag & O_APPEND) ?\n\t\t\t\t\t\t       TOMOYO_TYPE_APPEND :\n\t\t\t\t\t\t       TOMOYO_TYPE_WRITE,\n\t\t\t\t\t\t       &buf);\n\t}\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_domain",
          "args": [],
          "line": 311
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1204-1207",
          "snippet": "static inline struct tomoyo_domain_info *tomoyo_domain(void)\n{\n\treturn current_cred()->security;\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline struct tomoyo_domain_info *tomoyo_domain(void)\n{\n\treturn current_cred()->security;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_file_fcntl(struct file *file, unsigned int cmd,\n\t\t\t     unsigned long arg)\n{\n\tif (!(cmd == F_SETFL && ((arg ^ file->f_flags) & O_APPEND)))\n\t\treturn 0;\n\treturn tomoyo_check_open_permission(tomoyo_domain(), &file->f_path,\n\t\t\t\t\t    O_WRONLY | (arg & O_APPEND));\n}"
  },
  {
    "function_name": "tomoyo_path_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "287-295",
    "snippet": "static int tomoyo_path_rename(const struct path *old_parent,\n\t\t\t      struct dentry *old_dentry,\n\t\t\t      const struct path *new_parent,\n\t\t\t      struct dentry *new_dentry)\n{\n\tstruct path path1 = { .mnt = old_parent->mnt, .dentry = old_dentry };\n\tstruct path path2 = { .mnt = new_parent->mnt, .dentry = new_dentry };\n\treturn tomoyo_path2_perm(TOMOYO_TYPE_RENAME, &path1, &path2);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path2_perm",
          "args": [
            "TOMOYO_TYPE_RENAME",
            "&path1",
            "&path2"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path2_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "886-935",
          "snippet": "int tomoyo_path2_perm(const u8 operation, const struct path *path1,\n\t\t      const struct path *path2)\n{\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf1;\n\tstruct tomoyo_path_info buf2;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path1->mnt, .dentry = path1->dentry },\n\t\t.path2 = { .mnt = path2->mnt, .dentry = path2->dentry }\n\t};\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pp2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tbuf1.name = NULL;\n\tbuf2.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf1, path1) ||\n\t    !tomoyo_get_realpath(&buf2, path2))\n\t\tgoto out;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RENAME:\n\tcase TOMOYO_TYPE_LINK:\n\t\tif (!d_is_dir(path1->dentry))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase TOMOYO_TYPE_PIVOT_ROOT:\n\t\ttomoyo_add_slash(&buf1);\n\t\ttomoyo_add_slash(&buf2);\n\t\tbreak;\n\t}\n\tr.obj = &obj;\n\tr.param_type = TOMOYO_TYPE_PATH2_ACL;\n\tr.param.path2.operation = operation;\n\tr.param.path2.filename1 = &buf1;\n\tr.param.path2.filename2 = &buf2;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path2_acl);\n\t\terror = tomoyo_audit_path2_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(buf1.name);\n\tkfree(buf2.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const u8 tomoyo_pp2mac[TOMOYO_MAX_PATH2_OPERATION] = {\n\t[TOMOYO_TYPE_LINK]       = TOMOYO_MAC_FILE_LINK,\n\t[TOMOYO_TYPE_RENAME]     = TOMOYO_MAC_FILE_RENAME,\n\t[TOMOYO_TYPE_PIVOT_ROOT] = TOMOYO_MAC_FILE_PIVOT_ROOT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst u8 tomoyo_pp2mac[TOMOYO_MAX_PATH2_OPERATION] = {\n\t[TOMOYO_TYPE_LINK]       = TOMOYO_MAC_FILE_LINK,\n\t[TOMOYO_TYPE_RENAME]     = TOMOYO_MAC_FILE_RENAME,\n\t[TOMOYO_TYPE_PIVOT_ROOT] = TOMOYO_MAC_FILE_PIVOT_ROOT,\n};\n\nint tomoyo_path2_perm(const u8 operation, const struct path *path1,\n\t\t      const struct path *path2)\n{\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf1;\n\tstruct tomoyo_path_info buf2;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path1->mnt, .dentry = path1->dentry },\n\t\t.path2 = { .mnt = path2->mnt, .dentry = path2->dentry }\n\t};\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pp2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tbuf1.name = NULL;\n\tbuf2.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf1, path1) ||\n\t    !tomoyo_get_realpath(&buf2, path2))\n\t\tgoto out;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RENAME:\n\tcase TOMOYO_TYPE_LINK:\n\t\tif (!d_is_dir(path1->dentry))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase TOMOYO_TYPE_PIVOT_ROOT:\n\t\ttomoyo_add_slash(&buf1);\n\t\ttomoyo_add_slash(&buf2);\n\t\tbreak;\n\t}\n\tr.obj = &obj;\n\tr.param_type = TOMOYO_TYPE_PATH2_ACL;\n\tr.param.path2.operation = operation;\n\tr.param.path2.filename1 = &buf1;\n\tr.param.path2.filename2 = &buf2;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path2_acl);\n\t\terror = tomoyo_audit_path2_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(buf1.name);\n\tkfree(buf2.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_path_rename(const struct path *old_parent,\n\t\t\t      struct dentry *old_dentry,\n\t\t\t      const struct path *new_parent,\n\t\t\t      struct dentry *new_dentry)\n{\n\tstruct path path1 = { .mnt = old_parent->mnt, .dentry = old_dentry };\n\tstruct path path2 = { .mnt = new_parent->mnt, .dentry = new_dentry };\n\treturn tomoyo_path2_perm(TOMOYO_TYPE_RENAME, &path1, &path2);\n}"
  },
  {
    "function_name": "tomoyo_path_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "269-275",
    "snippet": "static int tomoyo_path_link(struct dentry *old_dentry, const struct path *new_dir,\n\t\t\t    struct dentry *new_dentry)\n{\n\tstruct path path1 = { .mnt = new_dir->mnt, .dentry = old_dentry };\n\tstruct path path2 = { .mnt = new_dir->mnt, .dentry = new_dentry };\n\treturn tomoyo_path2_perm(TOMOYO_TYPE_LINK, &path1, &path2);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path2_perm",
          "args": [
            "TOMOYO_TYPE_LINK",
            "&path1",
            "&path2"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path2_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "886-935",
          "snippet": "int tomoyo_path2_perm(const u8 operation, const struct path *path1,\n\t\t      const struct path *path2)\n{\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf1;\n\tstruct tomoyo_path_info buf2;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path1->mnt, .dentry = path1->dentry },\n\t\t.path2 = { .mnt = path2->mnt, .dentry = path2->dentry }\n\t};\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pp2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tbuf1.name = NULL;\n\tbuf2.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf1, path1) ||\n\t    !tomoyo_get_realpath(&buf2, path2))\n\t\tgoto out;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RENAME:\n\tcase TOMOYO_TYPE_LINK:\n\t\tif (!d_is_dir(path1->dentry))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase TOMOYO_TYPE_PIVOT_ROOT:\n\t\ttomoyo_add_slash(&buf1);\n\t\ttomoyo_add_slash(&buf2);\n\t\tbreak;\n\t}\n\tr.obj = &obj;\n\tr.param_type = TOMOYO_TYPE_PATH2_ACL;\n\tr.param.path2.operation = operation;\n\tr.param.path2.filename1 = &buf1;\n\tr.param.path2.filename2 = &buf2;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path2_acl);\n\t\terror = tomoyo_audit_path2_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(buf1.name);\n\tkfree(buf2.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const u8 tomoyo_pp2mac[TOMOYO_MAX_PATH2_OPERATION] = {\n\t[TOMOYO_TYPE_LINK]       = TOMOYO_MAC_FILE_LINK,\n\t[TOMOYO_TYPE_RENAME]     = TOMOYO_MAC_FILE_RENAME,\n\t[TOMOYO_TYPE_PIVOT_ROOT] = TOMOYO_MAC_FILE_PIVOT_ROOT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst u8 tomoyo_pp2mac[TOMOYO_MAX_PATH2_OPERATION] = {\n\t[TOMOYO_TYPE_LINK]       = TOMOYO_MAC_FILE_LINK,\n\t[TOMOYO_TYPE_RENAME]     = TOMOYO_MAC_FILE_RENAME,\n\t[TOMOYO_TYPE_PIVOT_ROOT] = TOMOYO_MAC_FILE_PIVOT_ROOT,\n};\n\nint tomoyo_path2_perm(const u8 operation, const struct path *path1,\n\t\t      const struct path *path2)\n{\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf1;\n\tstruct tomoyo_path_info buf2;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path1->mnt, .dentry = path1->dentry },\n\t\t.path2 = { .mnt = path2->mnt, .dentry = path2->dentry }\n\t};\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pp2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tbuf1.name = NULL;\n\tbuf2.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf1, path1) ||\n\t    !tomoyo_get_realpath(&buf2, path2))\n\t\tgoto out;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RENAME:\n\tcase TOMOYO_TYPE_LINK:\n\t\tif (!d_is_dir(path1->dentry))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase TOMOYO_TYPE_PIVOT_ROOT:\n\t\ttomoyo_add_slash(&buf1);\n\t\ttomoyo_add_slash(&buf2);\n\t\tbreak;\n\t}\n\tr.obj = &obj;\n\tr.param_type = TOMOYO_TYPE_PATH2_ACL;\n\tr.param.path2.operation = operation;\n\tr.param.path2.filename1 = &buf1;\n\tr.param.path2.filename2 = &buf2;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path2_acl);\n\t\terror = tomoyo_audit_path2_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n out:\n\tkfree(buf1.name);\n\tkfree(buf2.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_path_link(struct dentry *old_dentry, const struct path *new_dir,\n\t\t\t    struct dentry *new_dentry)\n{\n\tstruct path path1 = { .mnt = new_dir->mnt, .dentry = old_dentry };\n\tstruct path path2 = { .mnt = new_dir->mnt, .dentry = new_dentry };\n\treturn tomoyo_path2_perm(TOMOYO_TYPE_LINK, &path1, &path2);\n}"
  },
  {
    "function_name": "tomoyo_path_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "230-258",
    "snippet": "static int tomoyo_path_mknod(const struct path *parent, struct dentry *dentry,\n\t\t\t     umode_t mode, unsigned int dev)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\tint type = TOMOYO_TYPE_CREATE;\n\tconst unsigned int perm = mode & S_IALLUGO;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFCHR:\n\t\ttype = TOMOYO_TYPE_MKCHAR;\n\t\tbreak;\n\tcase S_IFBLK:\n\t\ttype = TOMOYO_TYPE_MKBLOCK;\n\t\tbreak;\n\tdefault:\n\t\tgoto no_dev;\n\t}\n\treturn tomoyo_mkdev_perm(type, &path, perm, dev);\n no_dev:\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\t\ttype = TOMOYO_TYPE_MKFIFO;\n\t\tbreak;\n\tcase S_IFSOCK:\n\t\ttype = TOMOYO_TYPE_MKSOCK;\n\t\tbreak;\n\t}\n\treturn tomoyo_path_number_perm(type, &path, perm);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_number_perm",
          "args": [
            "type",
            "&path",
            "perm"
          ],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_number_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "691-725",
          "snippet": "int tomoyo_path_number_perm(const u8 type, const struct path *path,\n\t\t\t    unsigned long number)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])\n\t    == TOMOYO_CONFIG_DISABLED || !path->dentry)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tif (type == TOMOYO_TYPE_MKDIR)\n\t\ttomoyo_add_slash(&buf);\n\tr.param_type = TOMOYO_TYPE_PATH_NUMBER_ACL;\n\tr.param.path_number.operation = type;\n\tr.param.path_number.filename = &buf;\n\tr.param.path_number.number = number;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path_number_acl);\n\t\terror = tomoyo_audit_path_number_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\tkfree(buf.name);\n out:\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION] = {\n\t[TOMOYO_TYPE_CREATE] = TOMOYO_MAC_FILE_CREATE,\n\t[TOMOYO_TYPE_MKDIR]  = TOMOYO_MAC_FILE_MKDIR,\n\t[TOMOYO_TYPE_MKFIFO] = TOMOYO_MAC_FILE_MKFIFO,\n\t[TOMOYO_TYPE_MKSOCK] = TOMOYO_MAC_FILE_MKSOCK,\n\t[TOMOYO_TYPE_IOCTL]  = TOMOYO_MAC_FILE_IOCTL,\n\t[TOMOYO_TYPE_CHMOD]  = TOMOYO_MAC_FILE_CHMOD,\n\t[TOMOYO_TYPE_CHOWN]  = TOMOYO_MAC_FILE_CHOWN,\n\t[TOMOYO_TYPE_CHGRP]  = TOMOYO_MAC_FILE_CHGRP,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION] = {\n\t[TOMOYO_TYPE_CREATE] = TOMOYO_MAC_FILE_CREATE,\n\t[TOMOYO_TYPE_MKDIR]  = TOMOYO_MAC_FILE_MKDIR,\n\t[TOMOYO_TYPE_MKFIFO] = TOMOYO_MAC_FILE_MKFIFO,\n\t[TOMOYO_TYPE_MKSOCK] = TOMOYO_MAC_FILE_MKSOCK,\n\t[TOMOYO_TYPE_IOCTL]  = TOMOYO_MAC_FILE_IOCTL,\n\t[TOMOYO_TYPE_CHMOD]  = TOMOYO_MAC_FILE_CHMOD,\n\t[TOMOYO_TYPE_CHOWN]  = TOMOYO_MAC_FILE_CHOWN,\n\t[TOMOYO_TYPE_CHGRP]  = TOMOYO_MAC_FILE_CHGRP,\n};\n\nint tomoyo_path_number_perm(const u8 type, const struct path *path,\n\t\t\t    unsigned long number)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])\n\t    == TOMOYO_CONFIG_DISABLED || !path->dentry)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tif (type == TOMOYO_TYPE_MKDIR)\n\t\ttomoyo_add_slash(&buf);\n\tr.param_type = TOMOYO_TYPE_PATH_NUMBER_ACL;\n\tr.param.path_number.operation = type;\n\tr.param.path_number.filename = &buf;\n\tr.param.path_number.number = number;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path_number_acl);\n\t\terror = tomoyo_audit_path_number_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\tkfree(buf.name);\n out:\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_mkdev_perm",
          "args": [
            "type",
            "&path",
            "perm",
            "dev"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_mkdev_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "842-875",
          "snippet": "int tomoyo_mkdev_perm(const u8 operation, const struct path *path,\n\t\t      const unsigned int mode, unsigned int dev)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pnnn2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\terror = -ENOMEM;\n\tif (tomoyo_get_realpath(&buf, path)) {\n\t\tr.obj = &obj;\n\t\tdev = new_decode_dev(dev);\n\t\tr.param_type = TOMOYO_TYPE_MKDEV_ACL;\n\t\tr.param.mkdev.filename = &buf;\n\t\tr.param.mkdev.operation = operation;\n\t\tr.param.mkdev.mode = mode;\n\t\tr.param.mkdev.major = MAJOR(dev);\n\t\tr.param.mkdev.minor = MINOR(dev);\n\t\ttomoyo_check_acl(&r, tomoyo_check_mkdev_acl);\n\t\terror = tomoyo_audit_mkdev_log(&r);\n\t\tkfree(buf.name);\n\t}\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const u8 tomoyo_pnnn2mac[TOMOYO_MAX_MKDEV_OPERATION] = {\n\t[TOMOYO_TYPE_MKBLOCK] = TOMOYO_MAC_FILE_MKBLOCK,\n\t[TOMOYO_TYPE_MKCHAR]  = TOMOYO_MAC_FILE_MKCHAR,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst u8 tomoyo_pnnn2mac[TOMOYO_MAX_MKDEV_OPERATION] = {\n\t[TOMOYO_TYPE_MKBLOCK] = TOMOYO_MAC_FILE_MKBLOCK,\n\t[TOMOYO_TYPE_MKCHAR]  = TOMOYO_MAC_FILE_MKCHAR,\n};\n\nint tomoyo_mkdev_perm(const u8 operation, const struct path *path,\n\t\t      const unsigned int mode, unsigned int dev)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pnnn2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\terror = -ENOMEM;\n\tif (tomoyo_get_realpath(&buf, path)) {\n\t\tr.obj = &obj;\n\t\tdev = new_decode_dev(dev);\n\t\tr.param_type = TOMOYO_TYPE_MKDEV_ACL;\n\t\tr.param.mkdev.filename = &buf;\n\t\tr.param.mkdev.operation = operation;\n\t\tr.param.mkdev.mode = mode;\n\t\tr.param.mkdev.major = MAJOR(dev);\n\t\tr.param.mkdev.minor = MINOR(dev);\n\t\ttomoyo_check_acl(&r, tomoyo_check_mkdev_acl);\n\t\terror = tomoyo_audit_mkdev_log(&r);\n\t\tkfree(buf.name);\n\t}\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_path_mknod(const struct path *parent, struct dentry *dentry,\n\t\t\t     umode_t mode, unsigned int dev)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\tint type = TOMOYO_TYPE_CREATE;\n\tconst unsigned int perm = mode & S_IALLUGO;\n\n\tswitch (mode & S_IFMT) {\n\tcase S_IFCHR:\n\t\ttype = TOMOYO_TYPE_MKCHAR;\n\t\tbreak;\n\tcase S_IFBLK:\n\t\ttype = TOMOYO_TYPE_MKBLOCK;\n\t\tbreak;\n\tdefault:\n\t\tgoto no_dev;\n\t}\n\treturn tomoyo_mkdev_perm(type, &path, perm, dev);\n no_dev:\n\tswitch (mode & S_IFMT) {\n\tcase S_IFIFO:\n\t\ttype = TOMOYO_TYPE_MKFIFO;\n\t\tbreak;\n\tcase S_IFSOCK:\n\t\ttype = TOMOYO_TYPE_MKSOCK;\n\t\tbreak;\n\t}\n\treturn tomoyo_path_number_perm(type, &path, perm);\n}"
  },
  {
    "function_name": "tomoyo_path_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "213-218",
    "snippet": "static int tomoyo_path_symlink(const struct path *parent, struct dentry *dentry,\n\t\t\t       const char *old_name)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\treturn tomoyo_path_perm(TOMOYO_TYPE_SYMLINK, &path, old_name);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_perm",
          "args": [
            "TOMOYO_TYPE_SYMLINK",
            "&path",
            "old_name"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "786-830",
          "snippet": "int tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};\n\nint tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_path_symlink(const struct path *parent, struct dentry *dentry,\n\t\t\t       const char *old_name)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\treturn tomoyo_path_perm(TOMOYO_TYPE_SYMLINK, &path, old_name);\n}"
  },
  {
    "function_name": "tomoyo_path_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "198-202",
    "snippet": "static int tomoyo_path_rmdir(const struct path *parent, struct dentry *dentry)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\treturn tomoyo_path_perm(TOMOYO_TYPE_RMDIR, &path, NULL);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_perm",
          "args": [
            "TOMOYO_TYPE_RMDIR",
            "&path",
            "NULL"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "786-830",
          "snippet": "int tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};\n\nint tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_path_rmdir(const struct path *parent, struct dentry *dentry)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\treturn tomoyo_path_perm(TOMOYO_TYPE_RMDIR, &path, NULL);\n}"
  },
  {
    "function_name": "tomoyo_path_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "182-188",
    "snippet": "static int tomoyo_path_mkdir(const struct path *parent, struct dentry *dentry,\n\t\t\t     umode_t mode)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\treturn tomoyo_path_number_perm(TOMOYO_TYPE_MKDIR, &path,\n\t\t\t\t       mode & S_IALLUGO);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_number_perm",
          "args": [
            "TOMOYO_TYPE_MKDIR",
            "&path",
            "mode & S_IALLUGO"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_number_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "691-725",
          "snippet": "int tomoyo_path_number_perm(const u8 type, const struct path *path,\n\t\t\t    unsigned long number)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])\n\t    == TOMOYO_CONFIG_DISABLED || !path->dentry)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tif (type == TOMOYO_TYPE_MKDIR)\n\t\ttomoyo_add_slash(&buf);\n\tr.param_type = TOMOYO_TYPE_PATH_NUMBER_ACL;\n\tr.param.path_number.operation = type;\n\tr.param.path_number.filename = &buf;\n\tr.param.path_number.number = number;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path_number_acl);\n\t\terror = tomoyo_audit_path_number_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\tkfree(buf.name);\n out:\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "const u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION] = {\n\t[TOMOYO_TYPE_CREATE] = TOMOYO_MAC_FILE_CREATE,\n\t[TOMOYO_TYPE_MKDIR]  = TOMOYO_MAC_FILE_MKDIR,\n\t[TOMOYO_TYPE_MKFIFO] = TOMOYO_MAC_FILE_MKFIFO,\n\t[TOMOYO_TYPE_MKSOCK] = TOMOYO_MAC_FILE_MKSOCK,\n\t[TOMOYO_TYPE_IOCTL]  = TOMOYO_MAC_FILE_IOCTL,\n\t[TOMOYO_TYPE_CHMOD]  = TOMOYO_MAC_FILE_CHMOD,\n\t[TOMOYO_TYPE_CHOWN]  = TOMOYO_MAC_FILE_CHOWN,\n\t[TOMOYO_TYPE_CHGRP]  = TOMOYO_MAC_FILE_CHGRP,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nconst u8 tomoyo_pn2mac[TOMOYO_MAX_PATH_NUMBER_OPERATION] = {\n\t[TOMOYO_TYPE_CREATE] = TOMOYO_MAC_FILE_CREATE,\n\t[TOMOYO_TYPE_MKDIR]  = TOMOYO_MAC_FILE_MKDIR,\n\t[TOMOYO_TYPE_MKFIFO] = TOMOYO_MAC_FILE_MKFIFO,\n\t[TOMOYO_TYPE_MKSOCK] = TOMOYO_MAC_FILE_MKSOCK,\n\t[TOMOYO_TYPE_IOCTL]  = TOMOYO_MAC_FILE_IOCTL,\n\t[TOMOYO_TYPE_CHMOD]  = TOMOYO_MAC_FILE_CHMOD,\n\t[TOMOYO_TYPE_CHOWN]  = TOMOYO_MAC_FILE_CHOWN,\n\t[TOMOYO_TYPE_CHGRP]  = TOMOYO_MAC_FILE_CHGRP,\n};\n\nint tomoyo_path_number_perm(const u8 type, const struct path *path,\n\t\t\t    unsigned long number)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error = -ENOMEM;\n\tstruct tomoyo_path_info buf;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_pn2mac[type])\n\t    == TOMOYO_CONFIG_DISABLED || !path->dentry)\n\t\treturn 0;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tif (type == TOMOYO_TYPE_MKDIR)\n\t\ttomoyo_add_slash(&buf);\n\tr.param_type = TOMOYO_TYPE_PATH_NUMBER_ACL;\n\tr.param.path_number.operation = type;\n\tr.param.path_number.filename = &buf;\n\tr.param.path_number.number = number;\n\tdo {\n\t\ttomoyo_check_acl(&r, tomoyo_check_path_number_acl);\n\t\terror = tomoyo_audit_path_number_log(&r);\n\t} while (error == TOMOYO_RETRY_REQUEST);\n\tkfree(buf.name);\n out:\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_path_mkdir(const struct path *parent, struct dentry *dentry,\n\t\t\t     umode_t mode)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\treturn tomoyo_path_number_perm(TOMOYO_TYPE_MKDIR, &path,\n\t\t\t\t       mode & S_IALLUGO);\n}"
  },
  {
    "function_name": "tomoyo_path_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "167-171",
    "snippet": "static int tomoyo_path_unlink(const struct path *parent, struct dentry *dentry)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\treturn tomoyo_path_perm(TOMOYO_TYPE_UNLINK, &path, NULL);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_perm",
          "args": [
            "TOMOYO_TYPE_UNLINK",
            "&path",
            "NULL"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "786-830",
          "snippet": "int tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};\n\nint tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_path_unlink(const struct path *parent, struct dentry *dentry)\n{\n\tstruct path path = { .mnt = parent->mnt, .dentry = dentry };\n\treturn tomoyo_path_perm(TOMOYO_TYPE_UNLINK, &path, NULL);\n}"
  },
  {
    "function_name": "tomoyo_path_truncate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "154-157",
    "snippet": "static int tomoyo_path_truncate(const struct path *path)\n{\n\treturn tomoyo_path_perm(TOMOYO_TYPE_TRUNCATE, path, NULL);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_perm",
          "args": [
            "TOMOYO_TYPE_TRUNCATE",
            "path",
            "NULL"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "786-830",
          "snippet": "int tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};\n\nint tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_path_truncate(const struct path *path)\n{\n\treturn tomoyo_path_perm(TOMOYO_TYPE_TRUNCATE, path, NULL);\n}"
  },
  {
    "function_name": "tomoyo_inode_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "142-145",
    "snippet": "static int tomoyo_inode_getattr(const struct path *path)\n{\n\treturn tomoyo_path_perm(TOMOYO_TYPE_GETATTR, path, NULL);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_path_perm",
          "args": [
            "TOMOYO_TYPE_GETATTR",
            "path",
            "NULL"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_path_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "786-830",
          "snippet": "int tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nstatic const u8 tomoyo_p2mac[TOMOYO_MAX_PATH_OPERATION] = {\n\t[TOMOYO_TYPE_EXECUTE]    = TOMOYO_MAC_FILE_EXECUTE,\n\t[TOMOYO_TYPE_READ]       = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_WRITE]      = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_APPEND]     = TOMOYO_MAC_FILE_OPEN,\n\t[TOMOYO_TYPE_UNLINK]     = TOMOYO_MAC_FILE_UNLINK,\n\t[TOMOYO_TYPE_GETATTR]    = TOMOYO_MAC_FILE_GETATTR,\n\t[TOMOYO_TYPE_RMDIR]      = TOMOYO_MAC_FILE_RMDIR,\n\t[TOMOYO_TYPE_TRUNCATE]   = TOMOYO_MAC_FILE_TRUNCATE,\n\t[TOMOYO_TYPE_SYMLINK]    = TOMOYO_MAC_FILE_SYMLINK,\n\t[TOMOYO_TYPE_CHROOT]     = TOMOYO_MAC_FILE_CHROOT,\n\t[TOMOYO_TYPE_UMOUNT]     = TOMOYO_MAC_FILE_UMOUNT,\n};\n\nint tomoyo_path_perm(const u8 operation, const struct path *path, const char *target)\n{\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint error;\n\tstruct tomoyo_path_info buf;\n\tbool is_enforce;\n\tstruct tomoyo_path_info symlink_target;\n\tint idx;\n\n\tif (tomoyo_init_request_info(&r, NULL, tomoyo_p2mac[operation])\n\t    == TOMOYO_CONFIG_DISABLED)\n\t\treturn 0;\n\tis_enforce = (r.mode == TOMOYO_CONFIG_ENFORCING);\n\terror = -ENOMEM;\n\tbuf.name = NULL;\n\tidx = tomoyo_read_lock();\n\tif (!tomoyo_get_realpath(&buf, path))\n\t\tgoto out;\n\tr.obj = &obj;\n\tswitch (operation) {\n\tcase TOMOYO_TYPE_RMDIR:\n\tcase TOMOYO_TYPE_CHROOT:\n\t\ttomoyo_add_slash(&buf);\n\t\tbreak;\n\tcase TOMOYO_TYPE_SYMLINK:\n\t\tsymlink_target.name = tomoyo_encode(target);\n\t\tif (!symlink_target.name)\n\t\t\tgoto out;\n\t\ttomoyo_fill_path_info(&symlink_target);\n\t\tobj.symlink_target = &symlink_target;\n\t\tbreak;\n\t}\n\terror = tomoyo_path_permission(&r, operation, &buf);\n\tif (operation == TOMOYO_TYPE_SYMLINK)\n\t\tkfree(symlink_target.name);\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (!is_enforce)\n\t\terror = 0;\n\treturn error;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_inode_getattr(const struct path *path)\n{\n\treturn tomoyo_path_perm(TOMOYO_TYPE_GETATTR, path, NULL);\n}"
  },
  {
    "function_name": "tomoyo_bprm_check_security",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "113-132",
    "snippet": "static int tomoyo_bprm_check_security(struct linux_binprm *bprm)\n{\n\tstruct tomoyo_domain_info *domain = bprm->cred->security;\n\n\t/*\n\t * Execute permission is checked against pathname passed to do_execve()\n\t * using current domain.\n\t */\n\tif (!domain) {\n\t\tconst int idx = tomoyo_read_lock();\n\t\tconst int err = tomoyo_find_next_domain(bprm);\n\t\ttomoyo_read_unlock(idx);\n\t\treturn err;\n\t}\n\t/*\n\t * Read permission is checked against interpreters using next domain.\n\t */\n\treturn tomoyo_check_open_permission(domain, &bprm->file->f_path,\n\t\t\t\t\t    O_RDONLY);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_check_open_permission",
          "args": [
            "domain",
            "&bprm->file->f_path",
            "O_RDONLY"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_check_open_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/file.c",
          "lines": "736-774",
          "snippet": "int tomoyo_check_open_permission(struct tomoyo_domain_info *domain,\n\t\t\t\t const struct path *path, const int flag)\n{\n\tconst u8 acc_mode = ACC_MODE(flag);\n\tint error = 0;\n\tstruct tomoyo_path_info buf;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint idx;\n\n\tbuf.name = NULL;\n\tr.mode = TOMOYO_CONFIG_DISABLED;\n\tidx = tomoyo_read_lock();\n\tif (acc_mode &&\n\t    tomoyo_init_request_info(&r, domain, TOMOYO_MAC_FILE_OPEN)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tif (!tomoyo_get_realpath(&buf, path)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tr.obj = &obj;\n\t\tif (acc_mode & MAY_READ)\n\t\t\terror = tomoyo_path_permission(&r, TOMOYO_TYPE_READ,\n\t\t\t\t\t\t       &buf);\n\t\tif (!error && (acc_mode & MAY_WRITE))\n\t\t\terror = tomoyo_path_permission(&r, (flag & O_APPEND) ?\n\t\t\t\t\t\t       TOMOYO_TYPE_APPEND :\n\t\t\t\t\t\t       TOMOYO_TYPE_WRITE,\n\t\t\t\t\t\t       &buf);\n\t}\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include \"common.h\"\n\nint tomoyo_check_open_permission(struct tomoyo_domain_info *domain,\n\t\t\t\t const struct path *path, const int flag)\n{\n\tconst u8 acc_mode = ACC_MODE(flag);\n\tint error = 0;\n\tstruct tomoyo_path_info buf;\n\tstruct tomoyo_request_info r;\n\tstruct tomoyo_obj_info obj = {\n\t\t.path1 = { .mnt = path->mnt, .dentry = path->dentry },\n\t};\n\tint idx;\n\n\tbuf.name = NULL;\n\tr.mode = TOMOYO_CONFIG_DISABLED;\n\tidx = tomoyo_read_lock();\n\tif (acc_mode &&\n\t    tomoyo_init_request_info(&r, domain, TOMOYO_MAC_FILE_OPEN)\n\t    != TOMOYO_CONFIG_DISABLED) {\n\t\tif (!tomoyo_get_realpath(&buf, path)) {\n\t\t\terror = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t\tr.obj = &obj;\n\t\tif (acc_mode & MAY_READ)\n\t\t\terror = tomoyo_path_permission(&r, TOMOYO_TYPE_READ,\n\t\t\t\t\t\t       &buf);\n\t\tif (!error && (acc_mode & MAY_WRITE))\n\t\t\terror = tomoyo_path_permission(&r, (flag & O_APPEND) ?\n\t\t\t\t\t\t       TOMOYO_TYPE_APPEND :\n\t\t\t\t\t\t       TOMOYO_TYPE_WRITE,\n\t\t\t\t\t\t       &buf);\n\t}\n out:\n\tkfree(buf.name);\n\ttomoyo_read_unlock(idx);\n\tif (r.mode != TOMOYO_CONFIG_ENFORCING)\n\t\terror = 0;\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_unlock",
          "args": [
            "idx"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1108-1111",
          "snippet": "static inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline void tomoyo_read_unlock(int idx)\n{\n\tsrcu_read_unlock(&tomoyo_ss, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_find_next_domain",
          "args": [
            "bprm"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_find_next_domain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/domain.c",
          "lines": "679-856",
          "snippet": "int tomoyo_find_next_domain(struct linux_binprm *bprm)\n{\n\tstruct tomoyo_domain_info *old_domain = tomoyo_domain();\n\tstruct tomoyo_domain_info *domain = NULL;\n\tconst char *original_name = bprm->filename;\n\tint retval = -ENOMEM;\n\tbool reject_on_transition_failure = false;\n\tconst struct tomoyo_path_info *candidate;\n\tstruct tomoyo_path_info exename;\n\tstruct tomoyo_execve *ee = kzalloc(sizeof(*ee), GFP_NOFS);\n\n\tif (!ee)\n\t\treturn -ENOMEM;\n\tee->tmp = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);\n\tif (!ee->tmp) {\n\t\tkfree(ee);\n\t\treturn -ENOMEM;\n\t}\n\t/* ee->dump->data is allocated by tomoyo_dump_page(). */\n\ttomoyo_init_request_info(&ee->r, NULL, TOMOYO_MAC_FILE_EXECUTE);\n\tee->r.ee = ee;\n\tee->bprm = bprm;\n\tee->r.obj = &ee->obj;\n\tee->obj.path1 = bprm->file->f_path;\n\t/* Get symlink's pathname of program. */\n\tretval = -ENOENT;\n\texename.name = tomoyo_realpath_nofollow(original_name);\n\tif (!exename.name)\n\t\tgoto out;\n\ttomoyo_fill_path_info(&exename);\nretry:\n\t/* Check 'aggregator' directive. */\n\t{\n\t\tstruct tomoyo_aggregator *ptr;\n\t\tstruct list_head *list =\n\t\t\t&old_domain->ns->policy_list[TOMOYO_ID_AGGREGATOR];\n\t\t/* Check 'aggregator' directive. */\n\t\tcandidate = &exename;\n\t\tlist_for_each_entry_rcu(ptr, list, head.list) {\n\t\t\tif (ptr->head.is_deleted ||\n\t\t\t    !tomoyo_path_matches_pattern(&exename,\n\t\t\t\t\t\t\t ptr->original_name))\n\t\t\t\tcontinue;\n\t\t\tcandidate = ptr->aggregated_name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Check execute permission. */\n\tretval = tomoyo_execute_permission(&ee->r, candidate);\n\tif (retval == TOMOYO_RETRY_REQUEST)\n\t\tgoto retry;\n\tif (retval < 0)\n\t\tgoto out;\n\t/*\n\t * To be able to specify domainnames with wildcards, use the\n\t * pathname specified in the policy (which may contain\n\t * wildcard) rather than the pathname passed to execve()\n\t * (which never contains wildcard).\n\t */\n\tif (ee->r.param.path.matched_path)\n\t\tcandidate = ee->r.param.path.matched_path;\n\n\t/*\n\t * Check for domain transition preference if \"file execute\" matched.\n\t * If preference is given, make do_execve() fail if domain transition\n\t * has failed, for domain transition preference should be used with\n\t * destination domain defined.\n\t */\n\tif (ee->transition) {\n\t\tconst char *domainname = ee->transition->name;\n\t\treject_on_transition_failure = true;\n\t\tif (!strcmp(domainname, \"keep\"))\n\t\t\tgoto force_keep_domain;\n\t\tif (!strcmp(domainname, \"child\"))\n\t\t\tgoto force_child_domain;\n\t\tif (!strcmp(domainname, \"reset\"))\n\t\t\tgoto force_reset_domain;\n\t\tif (!strcmp(domainname, \"initialize\"))\n\t\t\tgoto force_initialize_domain;\n\t\tif (!strcmp(domainname, \"parent\")) {\n\t\t\tchar *cp;\n\t\t\tstrncpy(ee->tmp, old_domain->domainname->name,\n\t\t\t\tTOMOYO_EXEC_TMPSIZE - 1);\n\t\t\tcp = strrchr(ee->tmp, ' ');\n\t\t\tif (cp)\n\t\t\t\t*cp = '\\0';\n\t\t} else if (*domainname == '<')\n\t\t\tstrncpy(ee->tmp, domainname, TOMOYO_EXEC_TMPSIZE - 1);\n\t\telse\n\t\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t\t old_domain->domainname->name, domainname);\n\t\tgoto force_jump_domain;\n\t}\n\t/*\n\t * No domain transition preference specified.\n\t * Calculate domain to transit to.\n\t */\n\tswitch (tomoyo_transition_type(old_domain->ns, old_domain->domainname,\n\t\t\t\t       candidate)) {\n\tcase TOMOYO_TRANSITION_CONTROL_RESET:\nforce_reset_domain:\n\t\t/* Transit to the root of specified namespace. */\n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"<%s>\",\n\t\t\t candidate->name);\n\t\t/*\n\t\t * Make do_execve() fail if domain transition across namespaces\n\t\t * has failed.\n\t\t */\n\t\treject_on_transition_failure = true;\n\t\tbreak;\n\tcase TOMOYO_TRANSITION_CONTROL_INITIALIZE:\nforce_initialize_domain:\n\t\t/* Transit to the child of current namespace's root. */\n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t old_domain->ns->name, candidate->name);\n\t\tbreak;\n\tcase TOMOYO_TRANSITION_CONTROL_KEEP:\nforce_keep_domain:\n\t\t/* Keep current domain. */\n\t\tdomain = old_domain;\n\t\tbreak;\n\tdefault:\n\t\tif (old_domain == &tomoyo_kernel_domain &&\n\t\t    !tomoyo_policy_loaded) {\n\t\t\t/*\n\t\t\t * Needn't to transit from kernel domain before\n\t\t\t * starting /sbin/init. But transit from kernel domain\n\t\t\t * if executing initializers because they might start\n\t\t\t * before /sbin/init.\n\t\t\t */\n\t\t\tdomain = old_domain;\n\t\t\tbreak;\n\t\t}\nforce_child_domain:\n\t\t/* Normal domain transition. */\n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t old_domain->domainname->name, candidate->name);\n\t\tbreak;\n\t}\nforce_jump_domain:\n\tif (!domain)\n\t\tdomain = tomoyo_assign_domain(ee->tmp, true);\n\tif (domain)\n\t\tretval = 0;\n\telse if (reject_on_transition_failure) {\n\t\tprintk(KERN_WARNING \"ERROR: Domain '%s' not ready.\\n\",\n\t\t       ee->tmp);\n\t\tretval = -ENOMEM;\n\t} else if (ee->r.mode == TOMOYO_CONFIG_ENFORCING)\n\t\tretval = -ENOMEM;\n\telse {\n\t\tretval = 0;\n\t\tif (!old_domain->flags[TOMOYO_DIF_TRANSITION_FAILED]) {\n\t\t\told_domain->flags[TOMOYO_DIF_TRANSITION_FAILED] = true;\n\t\t\tee->r.granted = false;\n\t\t\ttomoyo_write_log(&ee->r, \"%s\", tomoyo_dif\n\t\t\t\t\t [TOMOYO_DIF_TRANSITION_FAILED]);\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"ERROR: Domain '%s' not defined.\\n\", ee->tmp);\n\t\t}\n\t}\n out:\n\tif (!domain)\n\t\tdomain = old_domain;\n\t/* Update reference count on \"struct tomoyo_domain_info\". */\n\tatomic_inc(&domain->users);\n\tbprm->cred->security = domain;\n\tkfree(exename.name);\n\tif (!retval) {\n\t\tee->r.domain = domain;\n\t\tretval = tomoyo_environ(ee);\n\t}\n\tkfree(ee->tmp);\n\tkfree(ee->dump.data);\n\tkfree(ee);\n\treturn retval;\n}",
          "includes": [
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/binfmts.h>",
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct tomoyo_domain_info tomoyo_kernel_domain;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/binfmts.h>\n#include \"common.h\"\n\nstruct tomoyo_domain_info tomoyo_kernel_domain;\n\nint tomoyo_find_next_domain(struct linux_binprm *bprm)\n{\n\tstruct tomoyo_domain_info *old_domain = tomoyo_domain();\n\tstruct tomoyo_domain_info *domain = NULL;\n\tconst char *original_name = bprm->filename;\n\tint retval = -ENOMEM;\n\tbool reject_on_transition_failure = false;\n\tconst struct tomoyo_path_info *candidate;\n\tstruct tomoyo_path_info exename;\n\tstruct tomoyo_execve *ee = kzalloc(sizeof(*ee), GFP_NOFS);\n\n\tif (!ee)\n\t\treturn -ENOMEM;\n\tee->tmp = kzalloc(TOMOYO_EXEC_TMPSIZE, GFP_NOFS);\n\tif (!ee->tmp) {\n\t\tkfree(ee);\n\t\treturn -ENOMEM;\n\t}\n\t/* ee->dump->data is allocated by tomoyo_dump_page(). */\n\ttomoyo_init_request_info(&ee->r, NULL, TOMOYO_MAC_FILE_EXECUTE);\n\tee->r.ee = ee;\n\tee->bprm = bprm;\n\tee->r.obj = &ee->obj;\n\tee->obj.path1 = bprm->file->f_path;\n\t/* Get symlink's pathname of program. */\n\tretval = -ENOENT;\n\texename.name = tomoyo_realpath_nofollow(original_name);\n\tif (!exename.name)\n\t\tgoto out;\n\ttomoyo_fill_path_info(&exename);\nretry:\n\t/* Check 'aggregator' directive. */\n\t{\n\t\tstruct tomoyo_aggregator *ptr;\n\t\tstruct list_head *list =\n\t\t\t&old_domain->ns->policy_list[TOMOYO_ID_AGGREGATOR];\n\t\t/* Check 'aggregator' directive. */\n\t\tcandidate = &exename;\n\t\tlist_for_each_entry_rcu(ptr, list, head.list) {\n\t\t\tif (ptr->head.is_deleted ||\n\t\t\t    !tomoyo_path_matches_pattern(&exename,\n\t\t\t\t\t\t\t ptr->original_name))\n\t\t\t\tcontinue;\n\t\t\tcandidate = ptr->aggregated_name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* Check execute permission. */\n\tretval = tomoyo_execute_permission(&ee->r, candidate);\n\tif (retval == TOMOYO_RETRY_REQUEST)\n\t\tgoto retry;\n\tif (retval < 0)\n\t\tgoto out;\n\t/*\n\t * To be able to specify domainnames with wildcards, use the\n\t * pathname specified in the policy (which may contain\n\t * wildcard) rather than the pathname passed to execve()\n\t * (which never contains wildcard).\n\t */\n\tif (ee->r.param.path.matched_path)\n\t\tcandidate = ee->r.param.path.matched_path;\n\n\t/*\n\t * Check for domain transition preference if \"file execute\" matched.\n\t * If preference is given, make do_execve() fail if domain transition\n\t * has failed, for domain transition preference should be used with\n\t * destination domain defined.\n\t */\n\tif (ee->transition) {\n\t\tconst char *domainname = ee->transition->name;\n\t\treject_on_transition_failure = true;\n\t\tif (!strcmp(domainname, \"keep\"))\n\t\t\tgoto force_keep_domain;\n\t\tif (!strcmp(domainname, \"child\"))\n\t\t\tgoto force_child_domain;\n\t\tif (!strcmp(domainname, \"reset\"))\n\t\t\tgoto force_reset_domain;\n\t\tif (!strcmp(domainname, \"initialize\"))\n\t\t\tgoto force_initialize_domain;\n\t\tif (!strcmp(domainname, \"parent\")) {\n\t\t\tchar *cp;\n\t\t\tstrncpy(ee->tmp, old_domain->domainname->name,\n\t\t\t\tTOMOYO_EXEC_TMPSIZE - 1);\n\t\t\tcp = strrchr(ee->tmp, ' ');\n\t\t\tif (cp)\n\t\t\t\t*cp = '\\0';\n\t\t} else if (*domainname == '<')\n\t\t\tstrncpy(ee->tmp, domainname, TOMOYO_EXEC_TMPSIZE - 1);\n\t\telse\n\t\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t\t old_domain->domainname->name, domainname);\n\t\tgoto force_jump_domain;\n\t}\n\t/*\n\t * No domain transition preference specified.\n\t * Calculate domain to transit to.\n\t */\n\tswitch (tomoyo_transition_type(old_domain->ns, old_domain->domainname,\n\t\t\t\t       candidate)) {\n\tcase TOMOYO_TRANSITION_CONTROL_RESET:\nforce_reset_domain:\n\t\t/* Transit to the root of specified namespace. */\n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"<%s>\",\n\t\t\t candidate->name);\n\t\t/*\n\t\t * Make do_execve() fail if domain transition across namespaces\n\t\t * has failed.\n\t\t */\n\t\treject_on_transition_failure = true;\n\t\tbreak;\n\tcase TOMOYO_TRANSITION_CONTROL_INITIALIZE:\nforce_initialize_domain:\n\t\t/* Transit to the child of current namespace's root. */\n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t old_domain->ns->name, candidate->name);\n\t\tbreak;\n\tcase TOMOYO_TRANSITION_CONTROL_KEEP:\nforce_keep_domain:\n\t\t/* Keep current domain. */\n\t\tdomain = old_domain;\n\t\tbreak;\n\tdefault:\n\t\tif (old_domain == &tomoyo_kernel_domain &&\n\t\t    !tomoyo_policy_loaded) {\n\t\t\t/*\n\t\t\t * Needn't to transit from kernel domain before\n\t\t\t * starting /sbin/init. But transit from kernel domain\n\t\t\t * if executing initializers because they might start\n\t\t\t * before /sbin/init.\n\t\t\t */\n\t\t\tdomain = old_domain;\n\t\t\tbreak;\n\t\t}\nforce_child_domain:\n\t\t/* Normal domain transition. */\n\t\tsnprintf(ee->tmp, TOMOYO_EXEC_TMPSIZE - 1, \"%s %s\",\n\t\t\t old_domain->domainname->name, candidate->name);\n\t\tbreak;\n\t}\nforce_jump_domain:\n\tif (!domain)\n\t\tdomain = tomoyo_assign_domain(ee->tmp, true);\n\tif (domain)\n\t\tretval = 0;\n\telse if (reject_on_transition_failure) {\n\t\tprintk(KERN_WARNING \"ERROR: Domain '%s' not ready.\\n\",\n\t\t       ee->tmp);\n\t\tretval = -ENOMEM;\n\t} else if (ee->r.mode == TOMOYO_CONFIG_ENFORCING)\n\t\tretval = -ENOMEM;\n\telse {\n\t\tretval = 0;\n\t\tif (!old_domain->flags[TOMOYO_DIF_TRANSITION_FAILED]) {\n\t\t\told_domain->flags[TOMOYO_DIF_TRANSITION_FAILED] = true;\n\t\t\tee->r.granted = false;\n\t\t\ttomoyo_write_log(&ee->r, \"%s\", tomoyo_dif\n\t\t\t\t\t [TOMOYO_DIF_TRANSITION_FAILED]);\n\t\t\tprintk(KERN_WARNING\n\t\t\t       \"ERROR: Domain '%s' not defined.\\n\", ee->tmp);\n\t\t}\n\t}\n out:\n\tif (!domain)\n\t\tdomain = old_domain;\n\t/* Update reference count on \"struct tomoyo_domain_info\". */\n\tatomic_inc(&domain->users);\n\tbprm->cred->security = domain;\n\tkfree(exename.name);\n\tif (!retval) {\n\t\tee->r.domain = domain;\n\t\tretval = tomoyo_environ(ee);\n\t}\n\tkfree(ee->tmp);\n\tkfree(ee->dump.data);\n\tkfree(ee);\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tomoyo_read_lock",
          "args": [],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/common.h",
          "lines": "1096-1099",
          "snippet": "static inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}",
          "includes": [
            "#include <net/udp.h>",
            "#include <net/ipv6.h>",
            "#include <net/ip.h>",
            "#include <net/af_unix.h>",
            "#include <net/sock.h>",
            "#include <linux/un.h>",
            "#include <linux/in6.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/net.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/poll.h>",
            "#include <linux/cred.h>",
            "#include <linux/list.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/sched.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmod.h>",
            "#include <linux/file.h>",
            "#include <linux/mm.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/udp.h>\n#include <net/ipv6.h>\n#include <net/ip.h>\n#include <net/af_unix.h>\n#include <net/sock.h>\n#include <linux/un.h>\n#include <linux/in6.h>\n#include <linux/in.h>\n#include <linux/inet.h>\n#include <linux/net.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/poll.h>\n#include <linux/cred.h>\n#include <linux/list.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/sched.h>\n#include <linux/fs.h>\n#include <linux/kmod.h>\n#include <linux/file.h>\n#include <linux/mm.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n\nstatic inline int tomoyo_read_lock(void)\n{\n\treturn srcu_read_lock(&tomoyo_ss);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_bprm_check_security(struct linux_binprm *bprm)\n{\n\tstruct tomoyo_domain_info *domain = bprm->cred->security;\n\n\t/*\n\t * Execute permission is checked against pathname passed to do_execve()\n\t * using current domain.\n\t */\n\tif (!domain) {\n\t\tconst int idx = tomoyo_read_lock();\n\t\tconst int err = tomoyo_find_next_domain(bprm);\n\t\ttomoyo_read_unlock(idx);\n\t\treturn err;\n\t}\n\t/*\n\t * Read permission is checked against interpreters using next domain.\n\t */\n\treturn tomoyo_check_open_permission(domain, &bprm->file->f_path,\n\t\t\t\t\t    O_RDONLY);\n}"
  },
  {
    "function_name": "tomoyo_bprm_set_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "74-104",
    "snippet": "static int tomoyo_bprm_set_creds(struct linux_binprm *bprm)\n{\n\t/*\n\t * Do only if this function is called for the first time of an execve\n\t * operation.\n\t */\n\tif (bprm->called_set_creds)\n\t\treturn 0;\n#ifndef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER\n\t/*\n\t * Load policy if /sbin/tomoyo-init exists and /sbin/init is requested\n\t * for the first time.\n\t */\n\tif (!tomoyo_policy_loaded)\n\t\ttomoyo_load_policy(bprm->filename);\n#endif\n\t/*\n\t * Release reference to \"struct tomoyo_domain_info\" stored inside\n\t * \"bprm->cred->security\". New reference to \"struct tomoyo_domain_info\"\n\t * stored inside \"bprm->cred->security\" will be acquired later inside\n\t * tomoyo_find_next_domain().\n\t */\n\tatomic_dec(&((struct tomoyo_domain_info *)\n\t\t     bprm->cred->security)->users);\n\t/*\n\t * Tell tomoyo_bprm_check_security() is called for the first time of an\n\t * execve operation.\n\t */\n\tbprm->cred->security = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&((struct tomoyo_domain_info *)\n\t\t     bprm->cred->security)->users"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tomoyo_load_policy",
          "args": [
            "bprm->filename"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_load_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/load_policy.c",
          "lines": "84-108",
          "snippet": "void tomoyo_load_policy(const char *filename)\n{\n\tstatic bool done;\n\tchar *argv[2];\n\tchar *envp[3];\n\n\tif (tomoyo_policy_loaded || done)\n\t\treturn;\n\tif (!tomoyo_trigger)\n\t\ttomoyo_trigger = CONFIG_SECURITY_TOMOYO_ACTIVATION_TRIGGER;\n\tif (strcmp(filename, tomoyo_trigger))\n\t\treturn;\n\tif (!tomoyo_policy_loader_exists())\n\t\treturn;\n\tdone = true;\n\tprintk(KERN_INFO \"Calling %s to load policy. Please wait.\\n\",\n\t       tomoyo_loader);\n\targv[0] = (char *) tomoyo_loader;\n\targv[1] = NULL;\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\tcall_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\ttomoyo_check_profile();\n}",
          "includes": [
            "#include \"common.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n\nvoid tomoyo_load_policy(const char *filename)\n{\n\tstatic bool done;\n\tchar *argv[2];\n\tchar *envp[3];\n\n\tif (tomoyo_policy_loaded || done)\n\t\treturn;\n\tif (!tomoyo_trigger)\n\t\ttomoyo_trigger = CONFIG_SECURITY_TOMOYO_ACTIVATION_TRIGGER;\n\tif (strcmp(filename, tomoyo_trigger))\n\t\treturn;\n\tif (!tomoyo_policy_loader_exists())\n\t\treturn;\n\tdone = true;\n\tprintk(KERN_INFO \"Calling %s to load policy. Please wait.\\n\",\n\t       tomoyo_loader);\n\targv[0] = (char *) tomoyo_loader;\n\targv[1] = NULL;\n\tenvp[0] = \"HOME=/\";\n\tenvp[1] = \"PATH=/sbin:/bin:/usr/sbin:/usr/bin\";\n\tenvp[2] = NULL;\n\tcall_usermodehelper(argv[0], argv, envp, UMH_WAIT_PROC);\n\ttomoyo_check_profile();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_bprm_set_creds(struct linux_binprm *bprm)\n{\n\t/*\n\t * Do only if this function is called for the first time of an execve\n\t * operation.\n\t */\n\tif (bprm->called_set_creds)\n\t\treturn 0;\n#ifndef CONFIG_SECURITY_TOMOYO_OMIT_USERSPACE_LOADER\n\t/*\n\t * Load policy if /sbin/tomoyo-init exists and /sbin/init is requested\n\t * for the first time.\n\t */\n\tif (!tomoyo_policy_loaded)\n\t\ttomoyo_load_policy(bprm->filename);\n#endif\n\t/*\n\t * Release reference to \"struct tomoyo_domain_info\" stored inside\n\t * \"bprm->cred->security\". New reference to \"struct tomoyo_domain_info\"\n\t * stored inside \"bprm->cred->security\" will be acquired later inside\n\t * tomoyo_find_next_domain().\n\t */\n\tatomic_dec(&((struct tomoyo_domain_info *)\n\t\t     bprm->cred->security)->users);\n\t/*\n\t * Tell tomoyo_bprm_check_security() is called for the first time of an\n\t * execve operation.\n\t */\n\tbprm->cred->security = NULL;\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_cred_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "60-65",
    "snippet": "static void tomoyo_cred_free(struct cred *cred)\n{\n\tstruct tomoyo_domain_info *domain = cred->security;\n\tif (domain)\n\t\tatomic_dec(&domain->users);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&domain->users"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic void tomoyo_cred_free(struct cred *cred)\n{\n\tstruct tomoyo_domain_info *domain = cred->security;\n\tif (domain)\n\t\tatomic_dec(&domain->users);\n}"
  },
  {
    "function_name": "tomoyo_cred_transfer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "50-53",
    "snippet": "static void tomoyo_cred_transfer(struct cred *new, const struct cred *old)\n{\n\ttomoyo_cred_prepare(new, old, 0);\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tomoyo_cred_prepare",
          "args": [
            "new",
            "old",
            "0"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "tomoyo_cred_prepare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
          "lines": "34-42",
          "snippet": "static int tomoyo_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t       gfp_t gfp)\n{\n\tstruct tomoyo_domain_info *domain = old->security;\n\tnew->security = domain;\n\tif (domain)\n\t\tatomic_inc(&domain->users);\n\treturn 0;\n}",
          "includes": [
            "#include \"common.h\"",
            "#include <linux/lsm_hooks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t       gfp_t gfp)\n{\n\tstruct tomoyo_domain_info *domain = old->security;\n\tnew->security = domain;\n\tif (domain)\n\t\tatomic_inc(&domain->users);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic void tomoyo_cred_transfer(struct cred *new, const struct cred *old)\n{\n\ttomoyo_cred_prepare(new, old, 0);\n}"
  },
  {
    "function_name": "tomoyo_cred_prepare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "34-42",
    "snippet": "static int tomoyo_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t       gfp_t gfp)\n{\n\tstruct tomoyo_domain_info *domain = old->security;\n\tnew->security = domain;\n\tif (domain)\n\t\tatomic_inc(&domain->users);\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&domain->users"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_cred_prepare(struct cred *new, const struct cred *old,\n\t\t\t       gfp_t gfp)\n{\n\tstruct tomoyo_domain_info *domain = old->security;\n\tnew->security = domain;\n\tif (domain)\n\t\tatomic_inc(&domain->users);\n\treturn 0;\n}"
  },
  {
    "function_name": "tomoyo_cred_alloc_blank",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/tomoyo/tomoyo.c",
    "lines": "19-23",
    "snippet": "static int tomoyo_cred_alloc_blank(struct cred *new, gfp_t gfp)\n{\n\tnew->security = NULL;\n\treturn 0;\n}",
    "includes": [
      "#include \"common.h\"",
      "#include <linux/lsm_hooks.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"common.h\"\n#include <linux/lsm_hooks.h>\n\nstatic int tomoyo_cred_alloc_blank(struct cred *new, gfp_t gfp)\n{\n\tnew->security = NULL;\n\treturn 0;\n}"
  }
]