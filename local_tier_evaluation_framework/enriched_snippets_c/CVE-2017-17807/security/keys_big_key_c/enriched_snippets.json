[
  {
    "function_name": "big_key_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/big_key.c",
    "lines": "352-380",
    "snippet": "static int __init big_key_init(void)\n{\n\tint ret;\n\n\t/* init block cipher */\n\tbig_key_aead = crypto_alloc_aead(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_aead)) {\n\t\tret = PTR_ERR(big_key_aead);\n\t\tpr_err(\"Can't alloc crypto: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = crypto_aead_setauthsize(big_key_aead, ENC_AUTHTAG_SIZE);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't set crypto auth tag len: %d\\n\", ret);\n\t\tgoto free_aead;\n\t}\n\n\tret = register_key_type(&key_type_big_key);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't register type: %d\\n\", ret);\n\t\tgoto free_aead;\n\t}\n\n\treturn 0;\n\nfree_aead:\n\tcrypto_free_aead(big_key_aead);\n\treturn ret;\n}",
    "includes": [
      "#include <crypto/aead.h>",
      "#include <keys/big_key-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/random.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/err.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define ENC_AUTHTAG_SIZE 16"
    ],
    "globals_used": [
      "struct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n\t/* no ->update(); don't add it without changing big_key_crypt() nonce */\n};",
      "static const char big_key_alg_name[] = \"gcm(aes)\";",
      "static struct crypto_aead *big_key_aead;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_aead",
          "args": [
            "big_key_aead"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Can't register type: %d\\n\"",
            "ret"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_key_type",
          "args": [
            "&key_type_big_key"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_key_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "1149-1157",
          "snippet": "void unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(key_types_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(key_types_sem);\n\nvoid unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Can't set crypto auth tag len: %d\\n\"",
            "ret"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_aead_setauthsize",
          "args": [
            "big_key_aead",
            "ENC_AUTHTAG_SIZE"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Can't alloc crypto: %d\\n\"",
            "ret"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "big_key_aead"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "big_key_aead"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_aead",
          "args": [
            "big_key_alg_name",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/aead.h>\n#include <keys/big_key-type.h>\n#include <keys/user-type.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/err.h>\n#include <linux/shmem_fs.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n\n#define ENC_AUTHTAG_SIZE 16\n\nstruct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n\t/* no ->update(); don't add it without changing big_key_crypt() nonce */\n};\nstatic const char big_key_alg_name[] = \"gcm(aes)\";\nstatic struct crypto_aead *big_key_aead;\n\nstatic int __init big_key_init(void)\n{\n\tint ret;\n\n\t/* init block cipher */\n\tbig_key_aead = crypto_alloc_aead(big_key_alg_name, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(big_key_aead)) {\n\t\tret = PTR_ERR(big_key_aead);\n\t\tpr_err(\"Can't alloc crypto: %d\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = crypto_aead_setauthsize(big_key_aead, ENC_AUTHTAG_SIZE);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't set crypto auth tag len: %d\\n\", ret);\n\t\tgoto free_aead;\n\t}\n\n\tret = register_key_type(&key_type_big_key);\n\tif (ret < 0) {\n\t\tpr_err(\"Can't register type: %d\\n\", ret);\n\t\tgoto free_aead;\n\t}\n\n\treturn 0;\n\nfree_aead:\n\tcrypto_free_aead(big_key_aead);\n\treturn ret;\n}"
  },
  {
    "function_name": "big_key_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/big_key.c",
    "lines": "292-347",
    "snippet": "long big_key_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\tlong ret;\n\n\tif (!buffer || buflen < datalen)\n\t\treturn datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\t\tstruct file *file;\n\t\tu8 *data;\n\t\tu8 *enckey = (u8 *)key->payload.data[big_key_data];\n\t\tsize_t enclen = datalen + ENC_AUTHTAG_SIZE;\n\t\tloff_t pos = 0;\n\n\t\tdata = kmalloc(enclen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tfile = dentry_open(path, O_RDONLY, current_cred());\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* read file to kernel and decrypt */\n\t\tret = kernel_read(file, data, enclen, &pos);\n\t\tif (ret >= 0 && ret != enclen) {\n\t\t\tret = -EIO;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\tret = big_key_crypt(BIG_KEY_DEC, data, enclen, enckey);\n\t\tif (ret)\n\t\t\tgoto err_fput;\n\n\t\tret = datalen;\n\n\t\t/* copy decrypted data to user */\n\t\tif (copy_to_user(buffer, data, datalen) != 0)\n\t\t\tret = -EFAULT;\n\nerr_fput:\n\t\tfput(file);\nerror:\n\t\tkzfree(data);\n\t} else {\n\t\tret = datalen;\n\t\tif (copy_to_user(buffer, key->payload.data[big_key_data],\n\t\t\t\t datalen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <crypto/aead.h>",
      "#include <keys/big_key-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/random.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/err.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define ENC_AUTHTAG_SIZE 16",
      "#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "key->payload.data[big_key_data]",
            "datalen"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "data"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "data",
            "datalen"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "big_key_crypt",
          "args": [
            "BIG_KEY_DEC",
            "data",
            "enclen",
            "enckey"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "big_key_crypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/big_key.c",
          "lines": "94-130",
          "snippet": "static int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)\n{\n\tint ret;\n\tstruct scatterlist sgio;\n\tstruct aead_request *aead_req;\n\t/* We always use a zero nonce. The reason we can get away with this is\n\t * because we're using a different randomly generated key for every\n\t * different encryption. Notably, too, key_type_big_key doesn't define\n\t * an .update function, so there's no chance we'll wind up reusing the\n\t * key to encrypt updated data. Simply put: one key, one encryption.\n\t */\n\tu8 zero_nonce[crypto_aead_ivsize(big_key_aead)];\n\n\taead_req = aead_request_alloc(big_key_aead, GFP_KERNEL);\n\tif (!aead_req)\n\t\treturn -ENOMEM;\n\n\tmemset(zero_nonce, 0, sizeof(zero_nonce));\n\tsg_init_one(&sgio, data, datalen + (op == BIG_KEY_ENC ? ENC_AUTHTAG_SIZE : 0));\n\taead_request_set_crypt(aead_req, &sgio, &sgio, datalen, zero_nonce);\n\taead_request_set_callback(aead_req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\n\taead_request_set_ad(aead_req, 0);\n\n\tmutex_lock(&big_key_aead_lock);\n\tif (crypto_aead_setkey(big_key_aead, key, ENC_KEY_SIZE)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\tif (op == BIG_KEY_ENC)\n\t\tret = crypto_aead_encrypt(aead_req);\n\telse\n\t\tret = crypto_aead_decrypt(aead_req);\nerror:\n\tmutex_unlock(&big_key_aead_lock);\n\taead_request_free(aead_req);\n\treturn ret;\n}",
          "includes": [
            "#include <crypto/aead.h>",
            "#include <keys/big_key-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/random.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/err.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define ENC_AUTHTAG_SIZE 16",
            "#define ENC_KEY_SIZE 32"
          ],
          "globals_used": [
            "struct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n\t/* no ->update(); don't add it without changing big_key_crypt() nonce */\n};",
            "static struct crypto_aead *big_key_aead;",
            "static DEFINE_MUTEX(big_key_aead_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/aead.h>\n#include <keys/big_key-type.h>\n#include <keys/user-type.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/err.h>\n#include <linux/shmem_fs.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n\n#define ENC_AUTHTAG_SIZE 16\n#define ENC_KEY_SIZE 32\n\nstruct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n\t/* no ->update(); don't add it without changing big_key_crypt() nonce */\n};\nstatic struct crypto_aead *big_key_aead;\nstatic DEFINE_MUTEX(big_key_aead_lock);\n\nstatic int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)\n{\n\tint ret;\n\tstruct scatterlist sgio;\n\tstruct aead_request *aead_req;\n\t/* We always use a zero nonce. The reason we can get away with this is\n\t * because we're using a different randomly generated key for every\n\t * different encryption. Notably, too, key_type_big_key doesn't define\n\t * an .update function, so there's no chance we'll wind up reusing the\n\t * key to encrypt updated data. Simply put: one key, one encryption.\n\t */\n\tu8 zero_nonce[crypto_aead_ivsize(big_key_aead)];\n\n\taead_req = aead_request_alloc(big_key_aead, GFP_KERNEL);\n\tif (!aead_req)\n\t\treturn -ENOMEM;\n\n\tmemset(zero_nonce, 0, sizeof(zero_nonce));\n\tsg_init_one(&sgio, data, datalen + (op == BIG_KEY_ENC ? ENC_AUTHTAG_SIZE : 0));\n\taead_request_set_crypt(aead_req, &sgio, &sgio, datalen, zero_nonce);\n\taead_request_set_callback(aead_req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\n\taead_request_set_ad(aead_req, 0);\n\n\tmutex_lock(&big_key_aead_lock);\n\tif (crypto_aead_setkey(big_key_aead, key, ENC_KEY_SIZE)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\tif (op == BIG_KEY_ENC)\n\t\tret = crypto_aead_encrypt(aead_req);\n\telse\n\t\tret = crypto_aead_decrypt(aead_req);\nerror:\n\tmutex_unlock(&big_key_aead_lock);\n\taead_request_free(aead_req);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_read",
          "args": [
            "file",
            "data",
            "enclen",
            "&pos"
          ],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "integrity_kernel_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/iint.c",
          "lines": "184-200",
          "snippet": "int integrity_kernel_read(struct file *file, loff_t offset,\n\t\t\t  void *addr, unsigned long count)\n{\n\tmm_segment_t old_fs;\n\tchar __user *buf = (char __user *)addr;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tret = __vfs_read(file, buf, count, &offset);\n\tset_fs(old_fs);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/module.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/rbtree.h>\n#include <linux/spinlock.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n\nint integrity_kernel_read(struct file *file, loff_t offset,\n\t\t\t  void *addr, unsigned long count)\n{\n\tmm_segment_t old_fs;\n\tchar __user *buf = (char __user *)addr;\n\tssize_t ret;\n\n\tif (!(file->f_mode & FMODE_READ))\n\t\treturn -EBADF;\n\n\told_fs = get_fs();\n\tset_fs(get_ds());\n\tret = __vfs_read(file, buf, count, &offset);\n\tset_fs(old_fs);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dentry_open",
          "args": [
            "path",
            "O_RDONLY",
            "current_cred()"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "enclen",
            "GFP_KERNEL"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/aead.h>\n#include <keys/big_key-type.h>\n#include <keys/user-type.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/err.h>\n#include <linux/shmem_fs.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n\n#define ENC_AUTHTAG_SIZE 16\n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\nlong big_key_read(const struct key *key, char __user *buffer, size_t buflen)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\tlong ret;\n\n\tif (!buffer || buflen < datalen)\n\t\treturn datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\t\tstruct file *file;\n\t\tu8 *data;\n\t\tu8 *enckey = (u8 *)key->payload.data[big_key_data];\n\t\tsize_t enclen = datalen + ENC_AUTHTAG_SIZE;\n\t\tloff_t pos = 0;\n\n\t\tdata = kmalloc(enclen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tfile = dentry_open(path, O_RDONLY, current_cred());\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto error;\n\t\t}\n\n\t\t/* read file to kernel and decrypt */\n\t\tret = kernel_read(file, data, enclen, &pos);\n\t\tif (ret >= 0 && ret != enclen) {\n\t\t\tret = -EIO;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\tret = big_key_crypt(BIG_KEY_DEC, data, enclen, enckey);\n\t\tif (ret)\n\t\t\tgoto err_fput;\n\n\t\tret = datalen;\n\n\t\t/* copy decrypted data to user */\n\t\tif (copy_to_user(buffer, data, datalen) != 0)\n\t\t\tret = -EFAULT;\n\nerr_fput:\n\t\tfput(file);\nerror:\n\t\tkzfree(data);\n\t} else {\n\t\tret = datalen;\n\t\tif (copy_to_user(buffer, key->payload.data[big_key_data],\n\t\t\t\t datalen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "big_key_describe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/big_key.c",
    "lines": "276-286",
    "snippet": "void big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}",
    "includes": [
      "#include <crypto/aead.h>",
      "#include <keys/big_key-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/random.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/err.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\": %zu [%s]\"",
            "datalen",
            "datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_is_positive",
          "args": [
            "key"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "key->description"
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/aead.h>\n#include <keys/big_key-type.h>\n#include <keys/user-type.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/err.h>\n#include <linux/shmem_fs.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n\n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\nvoid big_key_describe(const struct key *key, struct seq_file *m)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tseq_puts(m, key->description);\n\n\tif (key_is_positive(key))\n\t\tseq_printf(m, \": %zu [%s]\",\n\t\t\t   datalen,\n\t\t\t   datalen > BIG_KEY_FILE_THRESHOLD ? \"file\" : \"buff\");\n}"
  },
  {
    "function_name": "big_key_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/big_key.c",
    "lines": "258-271",
    "snippet": "void big_key_destroy(struct key *key)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\t\tpath_put(path);\n\t\tpath->mnt = NULL;\n\t\tpath->dentry = NULL;\n\t}\n\tkzfree(key->payload.data[big_key_data]);\n\tkey->payload.data[big_key_data] = NULL;\n}",
    "includes": [
      "#include <crypto/aead.h>",
      "#include <keys/big_key-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/random.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/err.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "key->payload.data[big_key_data]"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "path"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/aead.h>\n#include <keys/big_key-type.h>\n#include <keys/user-type.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/err.h>\n#include <linux/shmem_fs.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n\n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\nvoid big_key_destroy(struct key *key)\n{\n\tsize_t datalen = (size_t)key->payload.data[big_key_len];\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\t\tpath_put(path);\n\t\tpath->mnt = NULL;\n\t\tpath->dentry = NULL;\n\t}\n\tkzfree(key->payload.data[big_key_data]);\n\tkey->payload.data[big_key_data] = NULL;\n}"
  },
  {
    "function_name": "big_key_revoke",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/big_key.c",
    "lines": "244-253",
    "snippet": "void big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\tif (key_is_positive(key) &&\n\t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}",
    "includes": [
      "#include <crypto/aead.h>",
      "#include <keys/big_key-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/random.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/err.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfs_truncate",
          "args": [
            "path",
            "0"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_is_positive",
          "args": [
            "key"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_payload_reserve",
          "args": [
            "key",
            "0"
          ],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "key_payload_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "370-401",
          "snippet": "int key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int key_quota_root_maxbytes = 25000000;",
            "unsigned int key_quota_maxbytes = 20000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nunsigned int key_quota_root_maxbytes = 25000000;\nunsigned int key_quota_maxbytes = 20000;\n\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <crypto/aead.h>\n#include <keys/big_key-type.h>\n#include <keys/user-type.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/err.h>\n#include <linux/shmem_fs.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n\n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\nvoid big_key_revoke(struct key *key)\n{\n\tstruct path *path = (struct path *)&key->payload.data[big_key_path];\n\n\t/* clear the quota */\n\tkey_payload_reserve(key, 0);\n\tif (key_is_positive(key) &&\n\t    (size_t)key->payload.data[big_key_len] > BIG_KEY_FILE_THRESHOLD)\n\t\tvfs_truncate(path, 0);\n}"
  },
  {
    "function_name": "big_key_free_preparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/big_key.c",
    "lines": "230-238",
    "snippet": "void big_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tif (prep->datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&prep->payload.data[big_key_path];\n\n\t\tpath_put(path);\n\t}\n\tkzfree(prep->payload.data[big_key_data]);\n}",
    "includes": [
      "#include <crypto/aead.h>",
      "#include <keys/big_key-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/random.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/err.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "prep->payload.data[big_key_data]"
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "path"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/aead.h>\n#include <keys/big_key-type.h>\n#include <keys/user-type.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/err.h>\n#include <linux/shmem_fs.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n\n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\nvoid big_key_free_preparse(struct key_preparsed_payload *prep)\n{\n\tif (prep->datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\tstruct path *path = (struct path *)&prep->payload.data[big_key_path];\n\n\t\tpath_put(path);\n\t}\n\tkzfree(prep->payload.data[big_key_data]);\n}"
  },
  {
    "function_name": "big_key_preparse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/big_key.c",
    "lines": "135-225",
    "snippet": "int big_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct path *path = (struct path *)&prep->payload.data[big_key_path];\n\tstruct file *file;\n\tu8 *enckey;\n\tu8 *data = NULL;\n\tssize_t written;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 1024 * 1024 || !prep->data)\n\t\tgoto error;\n\n\t/* Set an arbitrary quota */\n\tprep->quotalen = 16;\n\n\tprep->payload.data[big_key_len] = (void *)(unsigned long)datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\t/* Create a shmem file to store the data in.  This will permit the data\n\t\t * to be swapped out if needed.\n\t\t *\n\t\t * File content is stored encrypted with randomly generated key.\n\t\t */\n\t\tsize_t enclen = datalen + ENC_AUTHTAG_SIZE;\n\t\tloff_t pos = 0;\n\n\t\tdata = kmalloc(enclen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(data, prep->data, datalen);\n\n\t\t/* generate random key */\n\t\tenckey = kmalloc(ENC_KEY_SIZE, GFP_KERNEL);\n\t\tif (!enckey) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tret = get_random_bytes_wait(enckey, ENC_KEY_SIZE);\n\t\tif (unlikely(ret))\n\t\t\tgoto err_enckey;\n\n\t\t/* encrypt aligned data */\n\t\tret = big_key_crypt(BIG_KEY_ENC, data, datalen, enckey);\n\t\tif (ret)\n\t\t\tgoto err_enckey;\n\n\t\t/* save aligned data to file */\n\t\tfile = shmem_kernel_file_setup(\"\", enclen, 0);\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto err_enckey;\n\t\t}\n\n\t\twritten = kernel_write(file, data, enclen, &pos);\n\t\tif (written != enclen) {\n\t\t\tret = written;\n\t\t\tif (written >= 0)\n\t\t\t\tret = -ENOMEM;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\t/* Pin the mount and dentry to the key so that we can open it again\n\t\t * later\n\t\t */\n\t\tprep->payload.data[big_key_data] = enckey;\n\t\t*path = file->f_path;\n\t\tpath_get(path);\n\t\tfput(file);\n\t\tkzfree(data);\n\t} else {\n\t\t/* Just store the data in a buffer */\n\t\tvoid *data = kmalloc(datalen, GFP_KERNEL);\n\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tprep->payload.data[big_key_data] = data;\n\t\tmemcpy(data, prep->data, prep->datalen);\n\t}\n\treturn 0;\n\nerr_fput:\n\tfput(file);\nerr_enckey:\n\tkzfree(enckey);\nerror:\n\tkzfree(data);\n\treturn ret;\n}",
    "includes": [
      "#include <crypto/aead.h>",
      "#include <keys/big_key-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/random.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/err.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define ENC_AUTHTAG_SIZE 16",
      "#define ENC_KEY_SIZE 32",
      "#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "data"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "enckey"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "prep->data",
            "prep->datalen"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "datalen",
            "GFP_KERNEL"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "data"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "path_get",
          "args": [
            "path"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_write",
          "args": [
            "file",
            "data",
            "enclen",
            "&pos"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "shmem_kernel_file_setup",
          "args": [
            "\"\"",
            "enclen",
            "0"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "big_key_crypt",
          "args": [
            "BIG_KEY_ENC",
            "data",
            "datalen",
            "enckey"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "big_key_crypt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/big_key.c",
          "lines": "94-130",
          "snippet": "static int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)\n{\n\tint ret;\n\tstruct scatterlist sgio;\n\tstruct aead_request *aead_req;\n\t/* We always use a zero nonce. The reason we can get away with this is\n\t * because we're using a different randomly generated key for every\n\t * different encryption. Notably, too, key_type_big_key doesn't define\n\t * an .update function, so there's no chance we'll wind up reusing the\n\t * key to encrypt updated data. Simply put: one key, one encryption.\n\t */\n\tu8 zero_nonce[crypto_aead_ivsize(big_key_aead)];\n\n\taead_req = aead_request_alloc(big_key_aead, GFP_KERNEL);\n\tif (!aead_req)\n\t\treturn -ENOMEM;\n\n\tmemset(zero_nonce, 0, sizeof(zero_nonce));\n\tsg_init_one(&sgio, data, datalen + (op == BIG_KEY_ENC ? ENC_AUTHTAG_SIZE : 0));\n\taead_request_set_crypt(aead_req, &sgio, &sgio, datalen, zero_nonce);\n\taead_request_set_callback(aead_req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\n\taead_request_set_ad(aead_req, 0);\n\n\tmutex_lock(&big_key_aead_lock);\n\tif (crypto_aead_setkey(big_key_aead, key, ENC_KEY_SIZE)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\tif (op == BIG_KEY_ENC)\n\t\tret = crypto_aead_encrypt(aead_req);\n\telse\n\t\tret = crypto_aead_decrypt(aead_req);\nerror:\n\tmutex_unlock(&big_key_aead_lock);\n\taead_request_free(aead_req);\n\treturn ret;\n}",
          "includes": [
            "#include <crypto/aead.h>",
            "#include <keys/big_key-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/random.h>",
            "#include <linux/scatterlist.h>",
            "#include <linux/err.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/file.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define ENC_AUTHTAG_SIZE 16",
            "#define ENC_KEY_SIZE 32"
          ],
          "globals_used": [
            "struct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n\t/* no ->update(); don't add it without changing big_key_crypt() nonce */\n};",
            "static struct crypto_aead *big_key_aead;",
            "static DEFINE_MUTEX(big_key_aead_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <crypto/aead.h>\n#include <keys/big_key-type.h>\n#include <keys/user-type.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/err.h>\n#include <linux/shmem_fs.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n\n#define ENC_AUTHTAG_SIZE 16\n#define ENC_KEY_SIZE 32\n\nstruct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n\t/* no ->update(); don't add it without changing big_key_crypt() nonce */\n};\nstatic struct crypto_aead *big_key_aead;\nstatic DEFINE_MUTEX(big_key_aead_lock);\n\nstatic int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)\n{\n\tint ret;\n\tstruct scatterlist sgio;\n\tstruct aead_request *aead_req;\n\t/* We always use a zero nonce. The reason we can get away with this is\n\t * because we're using a different randomly generated key for every\n\t * different encryption. Notably, too, key_type_big_key doesn't define\n\t * an .update function, so there's no chance we'll wind up reusing the\n\t * key to encrypt updated data. Simply put: one key, one encryption.\n\t */\n\tu8 zero_nonce[crypto_aead_ivsize(big_key_aead)];\n\n\taead_req = aead_request_alloc(big_key_aead, GFP_KERNEL);\n\tif (!aead_req)\n\t\treturn -ENOMEM;\n\n\tmemset(zero_nonce, 0, sizeof(zero_nonce));\n\tsg_init_one(&sgio, data, datalen + (op == BIG_KEY_ENC ? ENC_AUTHTAG_SIZE : 0));\n\taead_request_set_crypt(aead_req, &sgio, &sgio, datalen, zero_nonce);\n\taead_request_set_callback(aead_req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\n\taead_request_set_ad(aead_req, 0);\n\n\tmutex_lock(&big_key_aead_lock);\n\tif (crypto_aead_setkey(big_key_aead, key, ENC_KEY_SIZE)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\tif (op == BIG_KEY_ENC)\n\t\tret = crypto_aead_encrypt(aead_req);\n\telse\n\t\tret = crypto_aead_decrypt(aead_req);\nerror:\n\tmutex_unlock(&big_key_aead_lock);\n\taead_request_free(aead_req);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_bytes_wait",
          "args": [
            "enckey",
            "ENC_KEY_SIZE"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "ENC_KEY_SIZE",
            "GFP_KERNEL"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "prep->data",
            "datalen"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "enclen",
            "GFP_KERNEL"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/aead.h>\n#include <keys/big_key-type.h>\n#include <keys/user-type.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/err.h>\n#include <linux/shmem_fs.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n\n#define ENC_AUTHTAG_SIZE 16\n#define ENC_KEY_SIZE 32\n#define BIG_KEY_FILE_THRESHOLD (sizeof(struct inode) + sizeof(struct dentry))\n\nint big_key_preparse(struct key_preparsed_payload *prep)\n{\n\tstruct path *path = (struct path *)&prep->payload.data[big_key_path];\n\tstruct file *file;\n\tu8 *enckey;\n\tu8 *data = NULL;\n\tssize_t written;\n\tsize_t datalen = prep->datalen;\n\tint ret;\n\n\tret = -EINVAL;\n\tif (datalen <= 0 || datalen > 1024 * 1024 || !prep->data)\n\t\tgoto error;\n\n\t/* Set an arbitrary quota */\n\tprep->quotalen = 16;\n\n\tprep->payload.data[big_key_len] = (void *)(unsigned long)datalen;\n\n\tif (datalen > BIG_KEY_FILE_THRESHOLD) {\n\t\t/* Create a shmem file to store the data in.  This will permit the data\n\t\t * to be swapped out if needed.\n\t\t *\n\t\t * File content is stored encrypted with randomly generated key.\n\t\t */\n\t\tsize_t enclen = datalen + ENC_AUTHTAG_SIZE;\n\t\tloff_t pos = 0;\n\n\t\tdata = kmalloc(enclen, GFP_KERNEL);\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\t\tmemcpy(data, prep->data, datalen);\n\n\t\t/* generate random key */\n\t\tenckey = kmalloc(ENC_KEY_SIZE, GFP_KERNEL);\n\t\tif (!enckey) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error;\n\t\t}\n\t\tret = get_random_bytes_wait(enckey, ENC_KEY_SIZE);\n\t\tif (unlikely(ret))\n\t\t\tgoto err_enckey;\n\n\t\t/* encrypt aligned data */\n\t\tret = big_key_crypt(BIG_KEY_ENC, data, datalen, enckey);\n\t\tif (ret)\n\t\t\tgoto err_enckey;\n\n\t\t/* save aligned data to file */\n\t\tfile = shmem_kernel_file_setup(\"\", enclen, 0);\n\t\tif (IS_ERR(file)) {\n\t\t\tret = PTR_ERR(file);\n\t\t\tgoto err_enckey;\n\t\t}\n\n\t\twritten = kernel_write(file, data, enclen, &pos);\n\t\tif (written != enclen) {\n\t\t\tret = written;\n\t\t\tif (written >= 0)\n\t\t\t\tret = -ENOMEM;\n\t\t\tgoto err_fput;\n\t\t}\n\n\t\t/* Pin the mount and dentry to the key so that we can open it again\n\t\t * later\n\t\t */\n\t\tprep->payload.data[big_key_data] = enckey;\n\t\t*path = file->f_path;\n\t\tpath_get(path);\n\t\tfput(file);\n\t\tkzfree(data);\n\t} else {\n\t\t/* Just store the data in a buffer */\n\t\tvoid *data = kmalloc(datalen, GFP_KERNEL);\n\n\t\tif (!data)\n\t\t\treturn -ENOMEM;\n\n\t\tprep->payload.data[big_key_data] = data;\n\t\tmemcpy(data, prep->data, prep->datalen);\n\t}\n\treturn 0;\n\nerr_fput:\n\tfput(file);\nerr_enckey:\n\tkzfree(enckey);\nerror:\n\tkzfree(data);\n\treturn ret;\n}"
  },
  {
    "function_name": "big_key_crypt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/big_key.c",
    "lines": "94-130",
    "snippet": "static int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)\n{\n\tint ret;\n\tstruct scatterlist sgio;\n\tstruct aead_request *aead_req;\n\t/* We always use a zero nonce. The reason we can get away with this is\n\t * because we're using a different randomly generated key for every\n\t * different encryption. Notably, too, key_type_big_key doesn't define\n\t * an .update function, so there's no chance we'll wind up reusing the\n\t * key to encrypt updated data. Simply put: one key, one encryption.\n\t */\n\tu8 zero_nonce[crypto_aead_ivsize(big_key_aead)];\n\n\taead_req = aead_request_alloc(big_key_aead, GFP_KERNEL);\n\tif (!aead_req)\n\t\treturn -ENOMEM;\n\n\tmemset(zero_nonce, 0, sizeof(zero_nonce));\n\tsg_init_one(&sgio, data, datalen + (op == BIG_KEY_ENC ? ENC_AUTHTAG_SIZE : 0));\n\taead_request_set_crypt(aead_req, &sgio, &sgio, datalen, zero_nonce);\n\taead_request_set_callback(aead_req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\n\taead_request_set_ad(aead_req, 0);\n\n\tmutex_lock(&big_key_aead_lock);\n\tif (crypto_aead_setkey(big_key_aead, key, ENC_KEY_SIZE)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\tif (op == BIG_KEY_ENC)\n\t\tret = crypto_aead_encrypt(aead_req);\n\telse\n\t\tret = crypto_aead_decrypt(aead_req);\nerror:\n\tmutex_unlock(&big_key_aead_lock);\n\taead_request_free(aead_req);\n\treturn ret;\n}",
    "includes": [
      "#include <crypto/aead.h>",
      "#include <keys/big_key-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/random.h>",
      "#include <linux/scatterlist.h>",
      "#include <linux/err.h>",
      "#include <linux/shmem_fs.h>",
      "#include <linux/file.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define ENC_AUTHTAG_SIZE 16",
      "#define ENC_KEY_SIZE 32"
    ],
    "globals_used": [
      "struct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n\t/* no ->update(); don't add it without changing big_key_crypt() nonce */\n};",
      "static struct crypto_aead *big_key_aead;",
      "static DEFINE_MUTEX(big_key_aead_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "aead_request_free",
          "args": [
            "aead_req"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&big_key_aead_lock"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_aead_decrypt",
          "args": [
            "aead_req"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_aead_encrypt",
          "args": [
            "aead_req"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_aead_setkey",
          "args": [
            "big_key_aead",
            "key",
            "ENC_KEY_SIZE"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&big_key_aead_lock"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aead_request_set_ad",
          "args": [
            "aead_req",
            "0"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aead_request_set_callback",
          "args": [
            "aead_req",
            "CRYPTO_TFM_REQ_MAY_SLEEP",
            "NULL",
            "NULL"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aead_request_set_crypt",
          "args": [
            "aead_req",
            "&sgio",
            "&sgio",
            "datalen",
            "zero_nonce"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sg_init_one",
          "args": [
            "&sgio",
            "data",
            "datalen + (op == BIG_KEY_ENC ? ENC_AUTHTAG_SIZE : 0)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "zero_nonce",
            "0",
            "sizeof(zero_nonce)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "aead_request_alloc",
          "args": [
            "big_key_aead",
            "GFP_KERNEL"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_aead_ivsize",
          "args": [
            "big_key_aead"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <crypto/aead.h>\n#include <keys/big_key-type.h>\n#include <keys/user-type.h>\n#include <linux/random.h>\n#include <linux/scatterlist.h>\n#include <linux/err.h>\n#include <linux/shmem_fs.h>\n#include <linux/file.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n\n#define ENC_AUTHTAG_SIZE 16\n#define ENC_KEY_SIZE 32\n\nstruct key_type key_type_big_key = {\n\t.name\t\t\t= \"big_key\",\n\t.preparse\t\t= big_key_preparse,\n\t.free_preparse\t\t= big_key_free_preparse,\n\t.instantiate\t\t= generic_key_instantiate,\n\t.revoke\t\t\t= big_key_revoke,\n\t.destroy\t\t= big_key_destroy,\n\t.describe\t\t= big_key_describe,\n\t.read\t\t\t= big_key_read,\n\t/* no ->update(); don't add it without changing big_key_crypt() nonce */\n};\nstatic struct crypto_aead *big_key_aead;\nstatic DEFINE_MUTEX(big_key_aead_lock);\n\nstatic int big_key_crypt(enum big_key_op op, u8 *data, size_t datalen, u8 *key)\n{\n\tint ret;\n\tstruct scatterlist sgio;\n\tstruct aead_request *aead_req;\n\t/* We always use a zero nonce. The reason we can get away with this is\n\t * because we're using a different randomly generated key for every\n\t * different encryption. Notably, too, key_type_big_key doesn't define\n\t * an .update function, so there's no chance we'll wind up reusing the\n\t * key to encrypt updated data. Simply put: one key, one encryption.\n\t */\n\tu8 zero_nonce[crypto_aead_ivsize(big_key_aead)];\n\n\taead_req = aead_request_alloc(big_key_aead, GFP_KERNEL);\n\tif (!aead_req)\n\t\treturn -ENOMEM;\n\n\tmemset(zero_nonce, 0, sizeof(zero_nonce));\n\tsg_init_one(&sgio, data, datalen + (op == BIG_KEY_ENC ? ENC_AUTHTAG_SIZE : 0));\n\taead_request_set_crypt(aead_req, &sgio, &sgio, datalen, zero_nonce);\n\taead_request_set_callback(aead_req, CRYPTO_TFM_REQ_MAY_SLEEP, NULL, NULL);\n\taead_request_set_ad(aead_req, 0);\n\n\tmutex_lock(&big_key_aead_lock);\n\tif (crypto_aead_setkey(big_key_aead, key, ENC_KEY_SIZE)) {\n\t\tret = -EAGAIN;\n\t\tgoto error;\n\t}\n\tif (op == BIG_KEY_ENC)\n\t\tret = crypto_aead_encrypt(aead_req);\n\telse\n\t\tret = crypto_aead_decrypt(aead_req);\nerror:\n\tmutex_unlock(&big_key_aead_lock);\n\taead_request_free(aead_req);\n\treturn ret;\n}"
  }
]