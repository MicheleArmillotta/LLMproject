[
  {
    "function_name": "ima_restore_measurement_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
    "lines": "323-436",
    "snippet": "int ima_restore_measurement_list(loff_t size, void *buf)\n{\n\tchar template_name[MAX_TEMPLATE_NAME_LEN];\n\n\tstruct ima_kexec_hdr *khdr = buf;\n\tstruct ima_field_data hdr[HDR__LAST] = {\n\t\t[HDR_PCR] = {.len = sizeof(u32)},\n\t\t[HDR_DIGEST] = {.len = TPM_DIGEST_SIZE},\n\t};\n\n\tvoid *bufp = buf + sizeof(*khdr);\n\tvoid *bufendp;\n\tstruct ima_template_entry *entry;\n\tstruct ima_template_desc *template_desc;\n\tDECLARE_BITMAP(hdr_mask, HDR__LAST);\n\tunsigned long count = 0;\n\tint ret = 0;\n\n\tif (!buf || size < sizeof(*khdr))\n\t\treturn 0;\n\n\tif (ima_canonical_fmt) {\n\t\tkhdr->version = le16_to_cpu(khdr->version);\n\t\tkhdr->count = le64_to_cpu(khdr->count);\n\t\tkhdr->buffer_size = le64_to_cpu(khdr->buffer_size);\n\t}\n\n\tif (khdr->version != 1) {\n\t\tpr_err(\"attempting to restore a incompatible measurement list\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (khdr->count > ULONG_MAX - 1) {\n\t\tpr_err(\"attempting to restore too many measurements\");\n\t\treturn -EINVAL;\n\t}\n\n\tbitmap_zero(hdr_mask, HDR__LAST);\n\tbitmap_set(hdr_mask, HDR_PCR, 1);\n\tbitmap_set(hdr_mask, HDR_DIGEST, 1);\n\n\t/*\n\t * ima kexec buffer prefix: version, buffer size, count\n\t * v1 format: pcr, digest, template-name-len, template-name,\n\t *\t      template-data-size, template-data\n\t */\n\tbufendp = buf + khdr->buffer_size;\n\twhile ((bufp < bufendp) && (count++ < khdr->count)) {\n\t\tint enforce_mask = ENFORCE_FIELDS;\n\n\t\tenforce_mask |= (count == khdr->count) ? ENFORCE_BUFEND : 0;\n\t\tret = ima_parse_buf(bufp, bufendp, &bufp, HDR__LAST, hdr, NULL,\n\t\t\t\t    hdr_mask, enforce_mask, \"entry header\");\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (hdr[HDR_TEMPLATE_NAME].len >= MAX_TEMPLATE_NAME_LEN) {\n\t\t\tpr_err(\"attempting to restore a template name \\\n\t\t\t\tthat is too long\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* template name is not null terminated */\n\t\tmemcpy(template_name, hdr[HDR_TEMPLATE_NAME].data,\n\t\t       hdr[HDR_TEMPLATE_NAME].len);\n\t\ttemplate_name[hdr[HDR_TEMPLATE_NAME].len] = 0;\n\n\t\tif (strcmp(template_name, \"ima\") == 0) {\n\t\t\tpr_err(\"attempting to restore an unsupported \\\n\t\t\t\ttemplate \\\"%s\\\" failed\\n\", template_name);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttemplate_desc = lookup_template_desc(template_name);\n\t\tif (!template_desc) {\n\t\t\ttemplate_desc = restore_template_fmt(template_name);\n\t\t\tif (!template_desc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Only the running system's template format is initialized\n\t\t * on boot.  As needed, initialize the other template formats.\n\t\t */\n\t\tret = template_desc_init_fields(template_desc->fmt,\n\t\t\t\t\t\t&(template_desc->fields),\n\t\t\t\t\t\t&(template_desc->num_fields));\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"attempting to restore the template fmt \\\"%s\\\" \\\n\t\t\t\tfailed\\n\", template_desc->fmt);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ima_restore_template_data(template_desc,\n\t\t\t\t\t\thdr[HDR_TEMPLATE_DATA].data,\n\t\t\t\t\t\thdr[HDR_TEMPLATE_DATA].len,\n\t\t\t\t\t\t&entry);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tmemcpy(entry->digest, hdr[HDR_DIGEST].data,\n\t\t       hdr[HDR_DIGEST].len);\n\t\tentry->pcr = !ima_canonical_fmt ? *(hdr[HDR_PCR].data) :\n\t\t\t     le32_to_cpu(*(hdr[HDR_PCR].data));\n\t\tret = ima_restore_measurement_entry(entry);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"ima_template_lib.h\"",
      "#include \"ima.h\"",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [
      "#define MAX_TEMPLATE_NAME_LEN 15"
    ],
    "globals_used": [
      "static struct ima_template_desc *lookup_template_desc(const char *name);",
      "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_restore_measurement_entry",
          "args": [
            "entry"
          ],
          "line": 430
        },
        "resolved": true,
        "details": {
          "function_name": "ima_restore_measurement_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_queue.c",
          "lines": "206-214",
          "snippet": "int ima_restore_measurement_entry(struct ima_template_entry *entry)\n{\n\tint result = 0;\n\n\tmutex_lock(&ima_extend_list_mutex);\n\tresult = ima_add_digest_entry(entry, 0);\n\tmutex_unlock(&ima_extend_list_mutex);\n\treturn result;\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/slab.h>",
            "#include <linux/rculist.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ima_extend_list_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/slab.h>\n#include <linux/rculist.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(ima_extend_list_mutex);\n\nint ima_restore_measurement_entry(struct ima_template_entry *entry)\n{\n\tint result = 0;\n\n\tmutex_lock(&ima_extend_list_mutex);\n\tresult = ima_add_digest_entry(entry, 0);\n\tmutex_unlock(&ima_extend_list_mutex);\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*(hdr[HDR_PCR].data)"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "entry->digest",
            "hdr[HDR_DIGEST].data",
            "hdr[HDR_DIGEST].len"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_restore_template_data",
          "args": [
            "template_desc",
            "hdr[HDR_TEMPLATE_DATA].data",
            "hdr[HDR_TEMPLATE_DATA].len",
            "&entry"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "ima_restore_template_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "275-320",
          "snippet": "static int ima_restore_template_data(struct ima_template_desc *template_desc,\n\t\t\t\t     void *template_data,\n\t\t\t\t     int template_data_size,\n\t\t\t\t     struct ima_template_entry **entry)\n{\n\tint ret = 0;\n\tint i;\n\n\t*entry = kzalloc(sizeof(**entry) +\n\t\t    template_desc->num_fields * sizeof(struct ima_field_data),\n\t\t    GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\tret = ima_parse_buf(template_data, template_data + template_data_size,\n\t\t\t    NULL, template_desc->num_fields,\n\t\t\t    (*entry)->template_data, NULL, NULL,\n\t\t\t    ENFORCE_FIELDS | ENFORCE_BUFEND, \"template data\");\n\tif (ret < 0) {\n\t\tkfree(*entry);\n\t\treturn ret;\n\t}\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_field_data *field_data = &(*entry)->template_data[i];\n\t\tu8 *data = field_data->data;\n\n\t\t(*entry)->template_data[i].data =\n\t\t\tkzalloc(field_data->len + 1, GFP_KERNEL);\n\t\tif (!(*entry)->template_data[i].data) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy((*entry)->template_data[i].data, data, field_data->len);\n\t\t(*entry)->template_data_len += sizeof(field_data->len);\n\t\t(*entry)->template_data_len += field_data->len;\n\t}\n\n\tif (ret < 0) {\n\t\tima_free_template_entry(*entry);\n\t\t*entry = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);\n\nstatic int ima_restore_template_data(struct ima_template_desc *template_desc,\n\t\t\t\t     void *template_data,\n\t\t\t\t     int template_data_size,\n\t\t\t\t     struct ima_template_entry **entry)\n{\n\tint ret = 0;\n\tint i;\n\n\t*entry = kzalloc(sizeof(**entry) +\n\t\t    template_desc->num_fields * sizeof(struct ima_field_data),\n\t\t    GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\tret = ima_parse_buf(template_data, template_data + template_data_size,\n\t\t\t    NULL, template_desc->num_fields,\n\t\t\t    (*entry)->template_data, NULL, NULL,\n\t\t\t    ENFORCE_FIELDS | ENFORCE_BUFEND, \"template data\");\n\tif (ret < 0) {\n\t\tkfree(*entry);\n\t\treturn ret;\n\t}\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_field_data *field_data = &(*entry)->template_data[i];\n\t\tu8 *data = field_data->data;\n\n\t\t(*entry)->template_data[i].data =\n\t\t\tkzalloc(field_data->len + 1, GFP_KERNEL);\n\t\tif (!(*entry)->template_data[i].data) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy((*entry)->template_data[i].data, data, field_data->len);\n\t\t(*entry)->template_data_len += sizeof(field_data->len);\n\t\t(*entry)->template_data_len += field_data->len;\n\t}\n\n\tif (ret < 0) {\n\t\tima_free_template_entry(*entry);\n\t\t*entry = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"attempting to restore the template fmt \\\"%s\\\" \\\n\t\t\t\tfailed\\n\"",
            "template_desc->fmt"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "template_desc_init_fields",
          "args": [
            "template_desc->fmt",
            "&(template_desc->fields)",
            "&(template_desc->num_fields)"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "template_desc_init_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "155-204",
          "snippet": "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields)\n{\n\tconst char *template_fmt_ptr;\n\tstruct ima_template_field *found_fields[IMA_TEMPLATE_NUM_FIELDS_MAX];\n\tint template_num_fields;\n\tint i, len;\n\n\tif (num_fields && *num_fields > 0) /* already initialized? */\n\t\treturn 0;\n\n\ttemplate_num_fields = template_fmt_size(template_fmt);\n\n\tif (template_num_fields > IMA_TEMPLATE_NUM_FIELDS_MAX) {\n\t\tpr_err(\"format string '%s' contains too many fields\\n\",\n\t\t       template_fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, template_fmt_ptr = template_fmt; i < template_num_fields;\n\t     i++, template_fmt_ptr += len + 1) {\n\t\tchar tmp_field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN + 1];\n\n\t\tlen = strchrnul(template_fmt_ptr, '|') - template_fmt_ptr;\n\t\tif (len == 0 || len > IMA_TEMPLATE_FIELD_ID_MAX_LEN) {\n\t\t\tpr_err(\"Invalid field with length %d\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(tmp_field_id, template_fmt_ptr, len);\n\t\ttmp_field_id[len] = '\\0';\n\t\tfound_fields[i] = lookup_template_field(tmp_field_id);\n\t\tif (!found_fields[i]) {\n\t\t\tpr_err(\"field '%s' not found\\n\", tmp_field_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (fields && num_fields) {\n\t\t*fields = kmalloc_array(i, sizeof(*fields), GFP_KERNEL);\n\t\tif (*fields == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(*fields, found_fields, i * sizeof(*fields));\n\t\t*num_fields = i;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);\n\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields)\n{\n\tconst char *template_fmt_ptr;\n\tstruct ima_template_field *found_fields[IMA_TEMPLATE_NUM_FIELDS_MAX];\n\tint template_num_fields;\n\tint i, len;\n\n\tif (num_fields && *num_fields > 0) /* already initialized? */\n\t\treturn 0;\n\n\ttemplate_num_fields = template_fmt_size(template_fmt);\n\n\tif (template_num_fields > IMA_TEMPLATE_NUM_FIELDS_MAX) {\n\t\tpr_err(\"format string '%s' contains too many fields\\n\",\n\t\t       template_fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, template_fmt_ptr = template_fmt; i < template_num_fields;\n\t     i++, template_fmt_ptr += len + 1) {\n\t\tchar tmp_field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN + 1];\n\n\t\tlen = strchrnul(template_fmt_ptr, '|') - template_fmt_ptr;\n\t\tif (len == 0 || len > IMA_TEMPLATE_FIELD_ID_MAX_LEN) {\n\t\t\tpr_err(\"Invalid field with length %d\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(tmp_field_id, template_fmt_ptr, len);\n\t\ttmp_field_id[len] = '\\0';\n\t\tfound_fields[i] = lookup_template_field(tmp_field_id);\n\t\tif (!found_fields[i]) {\n\t\t\tpr_err(\"field '%s' not found\\n\", tmp_field_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (fields && num_fields) {\n\t\t*fields = kmalloc_array(i, sizeof(*fields), GFP_KERNEL);\n\t\tif (*fields == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(*fields, found_fields, i * sizeof(*fields));\n\t\t*num_fields = i;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "restore_template_fmt",
          "args": [
            "template_name"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "restore_template_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "247-273",
          "snippet": "static struct ima_template_desc *restore_template_fmt(char *template_name)\n{\n\tstruct ima_template_desc *template_desc = NULL;\n\tint ret;\n\n\tret = template_desc_init_fields(template_name, NULL, NULL);\n\tif (ret < 0) {\n\t\tpr_err(\"attempting to initialize the template \\\"%s\\\" failed\\n\",\n\t\t\ttemplate_name);\n\t\tgoto out;\n\t}\n\n\ttemplate_desc = kzalloc(sizeof(*template_desc), GFP_KERNEL);\n\tif (!template_desc)\n\t\tgoto out;\n\n\ttemplate_desc->name = \"\";\n\ttemplate_desc->fmt = kstrdup(template_name, GFP_KERNEL);\n\tif (!template_desc->fmt)\n\t\tgoto out;\n\n\tspin_lock(&template_list);\n\tlist_add_tail_rcu(&template_desc->list, &defined_templates);\n\tspin_unlock(&template_list);\nout:\n\treturn template_desc;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(defined_templates);",
            "static DEFINE_SPINLOCK(template_list);",
            "static struct ima_template_desc *lookup_template_desc(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic LIST_HEAD(defined_templates);\nstatic DEFINE_SPINLOCK(template_list);\nstatic struct ima_template_desc *lookup_template_desc(const char *name);\n\nstatic struct ima_template_desc *restore_template_fmt(char *template_name)\n{\n\tstruct ima_template_desc *template_desc = NULL;\n\tint ret;\n\n\tret = template_desc_init_fields(template_name, NULL, NULL);\n\tif (ret < 0) {\n\t\tpr_err(\"attempting to initialize the template \\\"%s\\\" failed\\n\",\n\t\t\ttemplate_name);\n\t\tgoto out;\n\t}\n\n\ttemplate_desc = kzalloc(sizeof(*template_desc), GFP_KERNEL);\n\tif (!template_desc)\n\t\tgoto out;\n\n\ttemplate_desc->name = \"\";\n\ttemplate_desc->fmt = kstrdup(template_name, GFP_KERNEL);\n\tif (!template_desc->fmt)\n\t\tgoto out;\n\n\tspin_lock(&template_list);\n\tlist_add_tail_rcu(&template_desc->list, &defined_templates);\n\tspin_unlock(&template_list);\nout:\n\treturn template_desc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_template_desc",
          "args": [
            "template_name"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_template_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "111-126",
          "snippet": "static struct ima_template_desc *lookup_template_desc(const char *name)\n{\n\tstruct ima_template_desc *template_desc;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(template_desc, &defined_templates, list) {\n\t\tif ((strcmp(template_desc->name, name) == 0) ||\n\t\t    (strcmp(template_desc->fmt, name) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn found ? template_desc : NULL;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(defined_templates);",
            "static struct ima_template_desc *lookup_template_desc(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic LIST_HEAD(defined_templates);\nstatic struct ima_template_desc *lookup_template_desc(const char *name);\n\nstatic struct ima_template_desc *lookup_template_desc(const char *name)\n{\n\tstruct ima_template_desc *template_desc;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(template_desc, &defined_templates, list) {\n\t\tif ((strcmp(template_desc->name, name) == 0) ||\n\t\t    (strcmp(template_desc->fmt, name) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn found ? template_desc : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"attempting to restore an unsupported \\\n\t\t\t\ttemplate \\\"%s\\\" failed\\n\"",
            "template_name"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "template_name",
            "\"ima\""
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "template_name",
            "hdr[HDR_TEMPLATE_NAME].data",
            "hdr[HDR_TEMPLATE_NAME].len"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"attempting to restore a template name \\\n\t\t\t\tthat is too long\\n\""
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_parse_buf",
          "args": [
            "bufp",
            "bufendp",
            "&bufp",
            "HDR__LAST",
            "hdr",
            "NULL",
            "hdr_mask",
            "enforce_mask",
            "\"entry header\""
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "ima_parse_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "176-221",
          "snippet": "int ima_parse_buf(void *bufstartp, void *bufendp, void **bufcurp,\n\t\t  int maxfields, struct ima_field_data *fields, int *curfields,\n\t\t  unsigned long *len_mask, int enforce_mask, char *bufname)\n{\n\tvoid *bufp = bufstartp;\n\tint i;\n\n\tfor (i = 0; i < maxfields; i++) {\n\t\tif (len_mask == NULL || !test_bit(i, len_mask)) {\n\t\t\tif (bufp > (bufendp - sizeof(u32)))\n\t\t\t\tbreak;\n\n\t\t\tfields[i].len = *(u32 *)bufp;\n\t\t\tif (ima_canonical_fmt)\n\t\t\t\tfields[i].len = le32_to_cpu(fields[i].len);\n\n\t\t\tbufp += sizeof(u32);\n\t\t}\n\n\t\tif (bufp > (bufendp - fields[i].len))\n\t\t\tbreak;\n\n\t\tfields[i].data = bufp;\n\t\tbufp += fields[i].len;\n\t}\n\n\tif ((enforce_mask & ENFORCE_FIELDS) && i != maxfields) {\n\t\tpr_err(\"%s: nr of fields mismatch: expected: %d, current: %d\\n\",\n\t\t       bufname, maxfields, i);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((enforce_mask & ENFORCE_BUFEND) && bufp != bufendp) {\n\t\tpr_err(\"%s: buf end mismatch: expected: %p, current: %p\\n\",\n\t\t       bufname, bufendp, bufp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (curfields)\n\t\t*curfields = i;\n\n\tif (bufcurp)\n\t\t*bufcurp = bufp;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nint ima_parse_buf(void *bufstartp, void *bufendp, void **bufcurp,\n\t\t  int maxfields, struct ima_field_data *fields, int *curfields,\n\t\t  unsigned long *len_mask, int enforce_mask, char *bufname)\n{\n\tvoid *bufp = bufstartp;\n\tint i;\n\n\tfor (i = 0; i < maxfields; i++) {\n\t\tif (len_mask == NULL || !test_bit(i, len_mask)) {\n\t\t\tif (bufp > (bufendp - sizeof(u32)))\n\t\t\t\tbreak;\n\n\t\t\tfields[i].len = *(u32 *)bufp;\n\t\t\tif (ima_canonical_fmt)\n\t\t\t\tfields[i].len = le32_to_cpu(fields[i].len);\n\n\t\t\tbufp += sizeof(u32);\n\t\t}\n\n\t\tif (bufp > (bufendp - fields[i].len))\n\t\t\tbreak;\n\n\t\tfields[i].data = bufp;\n\t\tbufp += fields[i].len;\n\t}\n\n\tif ((enforce_mask & ENFORCE_FIELDS) && i != maxfields) {\n\t\tpr_err(\"%s: nr of fields mismatch: expected: %d, current: %d\\n\",\n\t\t       bufname, maxfields, i);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((enforce_mask & ENFORCE_BUFEND) && bufp != bufendp) {\n\t\tpr_err(\"%s: buf end mismatch: expected: %p, current: %p\\n\",\n\t\t       bufname, bufendp, bufp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (curfields)\n\t\t*curfields = i;\n\n\tif (bufcurp)\n\t\t*bufcurp = bufp;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_set",
          "args": [
            "hdr_mask",
            "HDR_DIGEST",
            "1"
          ],
          "line": 362
        },
        "resolved": true,
        "details": {
          "function_name": "ebitmap_set_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/ebitmap.c",
          "lines": "259-325",
          "snippet": "int ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* drop this node from the bitmap */\n\t\t\t\tif (!n->next) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this was the highest map\n\t\t\t\t\t * within the bitmap\n\t\t\t\t\t */\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t/* this node will be the highest map within the bitmap */\n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"ebitmap.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *ebitmap_node_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"ebitmap.h\"\n#include <net/netlabel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *ebitmap_node_cachep;\n\nint ebitmap_set_bit(struct ebitmap *e, unsigned long bit, int value)\n{\n\tstruct ebitmap_node *n, *prev, *new;\n\n\tprev = NULL;\n\tn = e->node;\n\twhile (n && n->startbit <= bit) {\n\t\tif ((n->startbit + EBITMAP_SIZE) > bit) {\n\t\t\tif (value) {\n\t\t\t\tebitmap_node_set_bit(n, bit);\n\t\t\t} else {\n\t\t\t\tunsigned int s;\n\n\t\t\t\tebitmap_node_clr_bit(n, bit);\n\n\t\t\t\ts = find_first_bit(n->maps, EBITMAP_SIZE);\n\t\t\t\tif (s < EBITMAP_SIZE)\n\t\t\t\t\treturn 0;\n\n\t\t\t\t/* drop this node from the bitmap */\n\t\t\t\tif (!n->next) {\n\t\t\t\t\t/*\n\t\t\t\t\t * this was the highest map\n\t\t\t\t\t * within the bitmap\n\t\t\t\t\t */\n\t\t\t\t\tif (prev)\n\t\t\t\t\t\te->highbit = prev->startbit\n\t\t\t\t\t\t\t     + EBITMAP_SIZE;\n\t\t\t\t\telse\n\t\t\t\t\t\te->highbit = 0;\n\t\t\t\t}\n\t\t\t\tif (prev)\n\t\t\t\t\tprev->next = n->next;\n\t\t\t\telse\n\t\t\t\t\te->node = n->next;\n\t\t\t\tkmem_cache_free(ebitmap_node_cachep, n);\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tprev = n;\n\t\tn = n->next;\n\t}\n\n\tif (!value)\n\t\treturn 0;\n\n\tnew = kmem_cache_zalloc(ebitmap_node_cachep, GFP_ATOMIC);\n\tif (!new)\n\t\treturn -ENOMEM;\n\n\tnew->startbit = bit - (bit % EBITMAP_SIZE);\n\tebitmap_node_set_bit(new, bit);\n\n\tif (!n)\n\t\t/* this node will be the highest map within the bitmap */\n\t\te->highbit = new->startbit + EBITMAP_SIZE;\n\n\tif (prev) {\n\t\tnew->next = prev->next;\n\t\tprev->next = new;\n\t} else {\n\t\tnew->next = e->node;\n\t\te->node = new;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmap_zero",
          "args": [
            "hdr_mask",
            "HDR__LAST"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"attempting to restore too many measurements\""
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"attempting to restore a incompatible measurement list\""
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "khdr->buffer_size"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le64_to_cpu",
          "args": [
            "khdr->count"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "khdr->version"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "DECLARE_BITMAP",
          "args": [
            "hdr_mask",
            "HDR__LAST"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\n#define MAX_TEMPLATE_NAME_LEN 15\n\nstatic struct ima_template_desc *lookup_template_desc(const char *name);\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);\n\nint ima_restore_measurement_list(loff_t size, void *buf)\n{\n\tchar template_name[MAX_TEMPLATE_NAME_LEN];\n\n\tstruct ima_kexec_hdr *khdr = buf;\n\tstruct ima_field_data hdr[HDR__LAST] = {\n\t\t[HDR_PCR] = {.len = sizeof(u32)},\n\t\t[HDR_DIGEST] = {.len = TPM_DIGEST_SIZE},\n\t};\n\n\tvoid *bufp = buf + sizeof(*khdr);\n\tvoid *bufendp;\n\tstruct ima_template_entry *entry;\n\tstruct ima_template_desc *template_desc;\n\tDECLARE_BITMAP(hdr_mask, HDR__LAST);\n\tunsigned long count = 0;\n\tint ret = 0;\n\n\tif (!buf || size < sizeof(*khdr))\n\t\treturn 0;\n\n\tif (ima_canonical_fmt) {\n\t\tkhdr->version = le16_to_cpu(khdr->version);\n\t\tkhdr->count = le64_to_cpu(khdr->count);\n\t\tkhdr->buffer_size = le64_to_cpu(khdr->buffer_size);\n\t}\n\n\tif (khdr->version != 1) {\n\t\tpr_err(\"attempting to restore a incompatible measurement list\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (khdr->count > ULONG_MAX - 1) {\n\t\tpr_err(\"attempting to restore too many measurements\");\n\t\treturn -EINVAL;\n\t}\n\n\tbitmap_zero(hdr_mask, HDR__LAST);\n\tbitmap_set(hdr_mask, HDR_PCR, 1);\n\tbitmap_set(hdr_mask, HDR_DIGEST, 1);\n\n\t/*\n\t * ima kexec buffer prefix: version, buffer size, count\n\t * v1 format: pcr, digest, template-name-len, template-name,\n\t *\t      template-data-size, template-data\n\t */\n\tbufendp = buf + khdr->buffer_size;\n\twhile ((bufp < bufendp) && (count++ < khdr->count)) {\n\t\tint enforce_mask = ENFORCE_FIELDS;\n\n\t\tenforce_mask |= (count == khdr->count) ? ENFORCE_BUFEND : 0;\n\t\tret = ima_parse_buf(bufp, bufendp, &bufp, HDR__LAST, hdr, NULL,\n\t\t\t\t    hdr_mask, enforce_mask, \"entry header\");\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tif (hdr[HDR_TEMPLATE_NAME].len >= MAX_TEMPLATE_NAME_LEN) {\n\t\t\tpr_err(\"attempting to restore a template name \\\n\t\t\t\tthat is too long\\n\");\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* template name is not null terminated */\n\t\tmemcpy(template_name, hdr[HDR_TEMPLATE_NAME].data,\n\t\t       hdr[HDR_TEMPLATE_NAME].len);\n\t\ttemplate_name[hdr[HDR_TEMPLATE_NAME].len] = 0;\n\n\t\tif (strcmp(template_name, \"ima\") == 0) {\n\t\t\tpr_err(\"attempting to restore an unsupported \\\n\t\t\t\ttemplate \\\"%s\\\" failed\\n\", template_name);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\ttemplate_desc = lookup_template_desc(template_name);\n\t\tif (!template_desc) {\n\t\t\ttemplate_desc = restore_template_fmt(template_name);\n\t\t\tif (!template_desc)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Only the running system's template format is initialized\n\t\t * on boot.  As needed, initialize the other template formats.\n\t\t */\n\t\tret = template_desc_init_fields(template_desc->fmt,\n\t\t\t\t\t\t&(template_desc->fields),\n\t\t\t\t\t\t&(template_desc->num_fields));\n\t\tif (ret < 0) {\n\t\t\tpr_err(\"attempting to restore the template fmt \\\"%s\\\" \\\n\t\t\t\tfailed\\n\", template_desc->fmt);\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tret = ima_restore_template_data(template_desc,\n\t\t\t\t\t\thdr[HDR_TEMPLATE_DATA].data,\n\t\t\t\t\t\thdr[HDR_TEMPLATE_DATA].len,\n\t\t\t\t\t\t&entry);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t\tmemcpy(entry->digest, hdr[HDR_DIGEST].data,\n\t\t       hdr[HDR_DIGEST].len);\n\t\tentry->pcr = !ima_canonical_fmt ? *(hdr[HDR_PCR].data) :\n\t\t\t     le32_to_cpu(*(hdr[HDR_PCR].data));\n\t\tret = ima_restore_measurement_entry(entry);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "ima_restore_template_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
    "lines": "275-320",
    "snippet": "static int ima_restore_template_data(struct ima_template_desc *template_desc,\n\t\t\t\t     void *template_data,\n\t\t\t\t     int template_data_size,\n\t\t\t\t     struct ima_template_entry **entry)\n{\n\tint ret = 0;\n\tint i;\n\n\t*entry = kzalloc(sizeof(**entry) +\n\t\t    template_desc->num_fields * sizeof(struct ima_field_data),\n\t\t    GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\tret = ima_parse_buf(template_data, template_data + template_data_size,\n\t\t\t    NULL, template_desc->num_fields,\n\t\t\t    (*entry)->template_data, NULL, NULL,\n\t\t\t    ENFORCE_FIELDS | ENFORCE_BUFEND, \"template data\");\n\tif (ret < 0) {\n\t\tkfree(*entry);\n\t\treturn ret;\n\t}\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_field_data *field_data = &(*entry)->template_data[i];\n\t\tu8 *data = field_data->data;\n\n\t\t(*entry)->template_data[i].data =\n\t\t\tkzalloc(field_data->len + 1, GFP_KERNEL);\n\t\tif (!(*entry)->template_data[i].data) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy((*entry)->template_data[i].data, data, field_data->len);\n\t\t(*entry)->template_data_len += sizeof(field_data->len);\n\t\t(*entry)->template_data_len += field_data->len;\n\t}\n\n\tif (ret < 0) {\n\t\tima_free_template_entry(*entry);\n\t\t*entry = NULL;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"ima_template_lib.h\"",
      "#include \"ima.h\"",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ima_free_template_entry",
          "args": [
            "*entry"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "ima_free_template_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_api.c",
          "lines": "27-35",
          "snippet": "void ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry);\n}",
          "includes": [
            "#include \"ima.h\"",
            "#include <linux/evm.h>",
            "#include <linux/xattr.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/slab.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima.h\"\n#include <linux/evm.h>\n#include <linux/xattr.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/slab.h>\n#include <linux/module.h>\n\nvoid ima_free_template_entry(struct ima_template_entry *entry)\n{\n\tint i;\n\n\tfor (i = 0; i < entry->template_desc->num_fields; i++)\n\t\tkfree(entry->template_data[i].data);\n\n\tkfree(entry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(*entry)->template_data[i].data",
            "data",
            "field_data->len"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "field_data->len + 1",
            "GFP_KERNEL"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "*entry"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ima_parse_buf",
          "args": [
            "template_data",
            "template_data + template_data_size",
            "NULL",
            "template_desc->num_fields",
            "(*entry)->template_data",
            "NULL",
            "NULL",
            "ENFORCE_FIELDS | ENFORCE_BUFEND",
            "\"template data\""
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "ima_parse_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template_lib.c",
          "lines": "176-221",
          "snippet": "int ima_parse_buf(void *bufstartp, void *bufendp, void **bufcurp,\n\t\t  int maxfields, struct ima_field_data *fields, int *curfields,\n\t\t  unsigned long *len_mask, int enforce_mask, char *bufname)\n{\n\tvoid *bufp = bufstartp;\n\tint i;\n\n\tfor (i = 0; i < maxfields; i++) {\n\t\tif (len_mask == NULL || !test_bit(i, len_mask)) {\n\t\t\tif (bufp > (bufendp - sizeof(u32)))\n\t\t\t\tbreak;\n\n\t\t\tfields[i].len = *(u32 *)bufp;\n\t\t\tif (ima_canonical_fmt)\n\t\t\t\tfields[i].len = le32_to_cpu(fields[i].len);\n\n\t\t\tbufp += sizeof(u32);\n\t\t}\n\n\t\tif (bufp > (bufendp - fields[i].len))\n\t\t\tbreak;\n\n\t\tfields[i].data = bufp;\n\t\tbufp += fields[i].len;\n\t}\n\n\tif ((enforce_mask & ENFORCE_FIELDS) && i != maxfields) {\n\t\tpr_err(\"%s: nr of fields mismatch: expected: %d, current: %d\\n\",\n\t\t       bufname, maxfields, i);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((enforce_mask & ENFORCE_BUFEND) && bufp != bufendp) {\n\t\tpr_err(\"%s: buf end mismatch: expected: %p, current: %p\\n\",\n\t\t       bufname, bufendp, bufp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (curfields)\n\t\t*curfields = i;\n\n\tif (bufcurp)\n\t\t*bufcurp = bufp;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ima_template_lib.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n\nint ima_parse_buf(void *bufstartp, void *bufendp, void **bufcurp,\n\t\t  int maxfields, struct ima_field_data *fields, int *curfields,\n\t\t  unsigned long *len_mask, int enforce_mask, char *bufname)\n{\n\tvoid *bufp = bufstartp;\n\tint i;\n\n\tfor (i = 0; i < maxfields; i++) {\n\t\tif (len_mask == NULL || !test_bit(i, len_mask)) {\n\t\t\tif (bufp > (bufendp - sizeof(u32)))\n\t\t\t\tbreak;\n\n\t\t\tfields[i].len = *(u32 *)bufp;\n\t\t\tif (ima_canonical_fmt)\n\t\t\t\tfields[i].len = le32_to_cpu(fields[i].len);\n\n\t\t\tbufp += sizeof(u32);\n\t\t}\n\n\t\tif (bufp > (bufendp - fields[i].len))\n\t\t\tbreak;\n\n\t\tfields[i].data = bufp;\n\t\tbufp += fields[i].len;\n\t}\n\n\tif ((enforce_mask & ENFORCE_FIELDS) && i != maxfields) {\n\t\tpr_err(\"%s: nr of fields mismatch: expected: %d, current: %d\\n\",\n\t\t       bufname, maxfields, i);\n\t\treturn -EINVAL;\n\t}\n\n\tif ((enforce_mask & ENFORCE_BUFEND) && bufp != bufendp) {\n\t\tpr_err(\"%s: buf end mismatch: expected: %p, current: %p\\n\",\n\t\t       bufname, bufendp, bufp);\n\t\treturn -EINVAL;\n\t}\n\n\tif (curfields)\n\t\t*curfields = i;\n\n\tif (bufcurp)\n\t\t*bufcurp = bufp;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(**entry) +\n\t\t    template_desc->num_fields * sizeof(struct ima_field_data)",
            "GFP_NOFS"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);\n\nstatic int ima_restore_template_data(struct ima_template_desc *template_desc,\n\t\t\t\t     void *template_data,\n\t\t\t\t     int template_data_size,\n\t\t\t\t     struct ima_template_entry **entry)\n{\n\tint ret = 0;\n\tint i;\n\n\t*entry = kzalloc(sizeof(**entry) +\n\t\t    template_desc->num_fields * sizeof(struct ima_field_data),\n\t\t    GFP_NOFS);\n\tif (!*entry)\n\t\treturn -ENOMEM;\n\n\tret = ima_parse_buf(template_data, template_data + template_data_size,\n\t\t\t    NULL, template_desc->num_fields,\n\t\t\t    (*entry)->template_data, NULL, NULL,\n\t\t\t    ENFORCE_FIELDS | ENFORCE_BUFEND, \"template data\");\n\tif (ret < 0) {\n\t\tkfree(*entry);\n\t\treturn ret;\n\t}\n\n\t(*entry)->template_desc = template_desc;\n\tfor (i = 0; i < template_desc->num_fields; i++) {\n\t\tstruct ima_field_data *field_data = &(*entry)->template_data[i];\n\t\tu8 *data = field_data->data;\n\n\t\t(*entry)->template_data[i].data =\n\t\t\tkzalloc(field_data->len + 1, GFP_KERNEL);\n\t\tif (!(*entry)->template_data[i].data) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\t\tmemcpy((*entry)->template_data[i].data, data, field_data->len);\n\t\t(*entry)->template_data_len += sizeof(field_data->len);\n\t\t(*entry)->template_data_len += field_data->len;\n\t}\n\n\tif (ret < 0) {\n\t\tima_free_template_entry(*entry);\n\t\t*entry = NULL;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "restore_template_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
    "lines": "247-273",
    "snippet": "static struct ima_template_desc *restore_template_fmt(char *template_name)\n{\n\tstruct ima_template_desc *template_desc = NULL;\n\tint ret;\n\n\tret = template_desc_init_fields(template_name, NULL, NULL);\n\tif (ret < 0) {\n\t\tpr_err(\"attempting to initialize the template \\\"%s\\\" failed\\n\",\n\t\t\ttemplate_name);\n\t\tgoto out;\n\t}\n\n\ttemplate_desc = kzalloc(sizeof(*template_desc), GFP_KERNEL);\n\tif (!template_desc)\n\t\tgoto out;\n\n\ttemplate_desc->name = \"\";\n\ttemplate_desc->fmt = kstrdup(template_name, GFP_KERNEL);\n\tif (!template_desc->fmt)\n\t\tgoto out;\n\n\tspin_lock(&template_list);\n\tlist_add_tail_rcu(&template_desc->list, &defined_templates);\n\tspin_unlock(&template_list);\nout:\n\treturn template_desc;\n}",
    "includes": [
      "#include \"ima_template_lib.h\"",
      "#include \"ima.h\"",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(defined_templates);",
      "static DEFINE_SPINLOCK(template_list);",
      "static struct ima_template_desc *lookup_template_desc(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&template_list"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&template_desc->list",
            "&defined_templates"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&template_list"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "template_name",
            "GFP_KERNEL"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*template_desc)",
            "GFP_KERNEL"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"attempting to initialize the template \\\"%s\\\" failed\\n\"",
            "template_name"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "template_desc_init_fields",
          "args": [
            "template_name",
            "NULL",
            "NULL"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "template_desc_init_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "155-204",
          "snippet": "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields)\n{\n\tconst char *template_fmt_ptr;\n\tstruct ima_template_field *found_fields[IMA_TEMPLATE_NUM_FIELDS_MAX];\n\tint template_num_fields;\n\tint i, len;\n\n\tif (num_fields && *num_fields > 0) /* already initialized? */\n\t\treturn 0;\n\n\ttemplate_num_fields = template_fmt_size(template_fmt);\n\n\tif (template_num_fields > IMA_TEMPLATE_NUM_FIELDS_MAX) {\n\t\tpr_err(\"format string '%s' contains too many fields\\n\",\n\t\t       template_fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, template_fmt_ptr = template_fmt; i < template_num_fields;\n\t     i++, template_fmt_ptr += len + 1) {\n\t\tchar tmp_field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN + 1];\n\n\t\tlen = strchrnul(template_fmt_ptr, '|') - template_fmt_ptr;\n\t\tif (len == 0 || len > IMA_TEMPLATE_FIELD_ID_MAX_LEN) {\n\t\t\tpr_err(\"Invalid field with length %d\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(tmp_field_id, template_fmt_ptr, len);\n\t\ttmp_field_id[len] = '\\0';\n\t\tfound_fields[i] = lookup_template_field(tmp_field_id);\n\t\tif (!found_fields[i]) {\n\t\t\tpr_err(\"field '%s' not found\\n\", tmp_field_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (fields && num_fields) {\n\t\t*fields = kmalloc_array(i, sizeof(*fields), GFP_KERNEL);\n\t\tif (*fields == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(*fields, found_fields, i * sizeof(*fields));\n\t\t*num_fields = i;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);\n\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields)\n{\n\tconst char *template_fmt_ptr;\n\tstruct ima_template_field *found_fields[IMA_TEMPLATE_NUM_FIELDS_MAX];\n\tint template_num_fields;\n\tint i, len;\n\n\tif (num_fields && *num_fields > 0) /* already initialized? */\n\t\treturn 0;\n\n\ttemplate_num_fields = template_fmt_size(template_fmt);\n\n\tif (template_num_fields > IMA_TEMPLATE_NUM_FIELDS_MAX) {\n\t\tpr_err(\"format string '%s' contains too many fields\\n\",\n\t\t       template_fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, template_fmt_ptr = template_fmt; i < template_num_fields;\n\t     i++, template_fmt_ptr += len + 1) {\n\t\tchar tmp_field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN + 1];\n\n\t\tlen = strchrnul(template_fmt_ptr, '|') - template_fmt_ptr;\n\t\tif (len == 0 || len > IMA_TEMPLATE_FIELD_ID_MAX_LEN) {\n\t\t\tpr_err(\"Invalid field with length %d\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(tmp_field_id, template_fmt_ptr, len);\n\t\ttmp_field_id[len] = '\\0';\n\t\tfound_fields[i] = lookup_template_field(tmp_field_id);\n\t\tif (!found_fields[i]) {\n\t\t\tpr_err(\"field '%s' not found\\n\", tmp_field_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (fields && num_fields) {\n\t\t*fields = kmalloc_array(i, sizeof(*fields), GFP_KERNEL);\n\t\tif (*fields == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(*fields, found_fields, i * sizeof(*fields));\n\t\t*num_fields = i;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic LIST_HEAD(defined_templates);\nstatic DEFINE_SPINLOCK(template_list);\nstatic struct ima_template_desc *lookup_template_desc(const char *name);\n\nstatic struct ima_template_desc *restore_template_fmt(char *template_name)\n{\n\tstruct ima_template_desc *template_desc = NULL;\n\tint ret;\n\n\tret = template_desc_init_fields(template_name, NULL, NULL);\n\tif (ret < 0) {\n\t\tpr_err(\"attempting to initialize the template \\\"%s\\\" failed\\n\",\n\t\t\ttemplate_name);\n\t\tgoto out;\n\t}\n\n\ttemplate_desc = kzalloc(sizeof(*template_desc), GFP_KERNEL);\n\tif (!template_desc)\n\t\tgoto out;\n\n\ttemplate_desc->name = \"\";\n\ttemplate_desc->fmt = kstrdup(template_name, GFP_KERNEL);\n\tif (!template_desc->fmt)\n\t\tgoto out;\n\n\tspin_lock(&template_list);\n\tlist_add_tail_rcu(&template_desc->list, &defined_templates);\n\tspin_unlock(&template_list);\nout:\n\treturn template_desc;\n}"
  },
  {
    "function_name": "ima_init_template",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
    "lines": "231-245",
    "snippet": "int __init ima_init_template(void)\n{\n\tstruct ima_template_desc *template = ima_template_desc_current();\n\tint result;\n\n\tresult = template_desc_init_fields(template->fmt,\n\t\t\t\t\t   &(template->fields),\n\t\t\t\t\t   &(template->num_fields));\n\tif (result < 0)\n\t\tpr_err(\"template %s init failed, result: %d\\n\",\n\t\t       (strlen(template->name) ?\n\t\t       template->name : template->fmt), result);\n\n\treturn result;\n}",
    "includes": [
      "#include \"ima_template_lib.h\"",
      "#include \"ima.h\"",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ima_template_desc *lookup_template_desc(const char *name);",
      "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"template %s init failed, result: %d\\n\"",
            "(strlen(template->name) ?\n\t\t       template->name : template->fmt)",
            "result"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "template->name"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "template_desc_init_fields",
          "args": [
            "template->fmt",
            "&(template->fields)",
            "&(template->num_fields)"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "template_desc_init_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "155-204",
          "snippet": "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields)\n{\n\tconst char *template_fmt_ptr;\n\tstruct ima_template_field *found_fields[IMA_TEMPLATE_NUM_FIELDS_MAX];\n\tint template_num_fields;\n\tint i, len;\n\n\tif (num_fields && *num_fields > 0) /* already initialized? */\n\t\treturn 0;\n\n\ttemplate_num_fields = template_fmt_size(template_fmt);\n\n\tif (template_num_fields > IMA_TEMPLATE_NUM_FIELDS_MAX) {\n\t\tpr_err(\"format string '%s' contains too many fields\\n\",\n\t\t       template_fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, template_fmt_ptr = template_fmt; i < template_num_fields;\n\t     i++, template_fmt_ptr += len + 1) {\n\t\tchar tmp_field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN + 1];\n\n\t\tlen = strchrnul(template_fmt_ptr, '|') - template_fmt_ptr;\n\t\tif (len == 0 || len > IMA_TEMPLATE_FIELD_ID_MAX_LEN) {\n\t\t\tpr_err(\"Invalid field with length %d\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(tmp_field_id, template_fmt_ptr, len);\n\t\ttmp_field_id[len] = '\\0';\n\t\tfound_fields[i] = lookup_template_field(tmp_field_id);\n\t\tif (!found_fields[i]) {\n\t\t\tpr_err(\"field '%s' not found\\n\", tmp_field_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (fields && num_fields) {\n\t\t*fields = kmalloc_array(i, sizeof(*fields), GFP_KERNEL);\n\t\tif (*fields == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(*fields, found_fields, i * sizeof(*fields));\n\t\t*num_fields = i;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);\n\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields)\n{\n\tconst char *template_fmt_ptr;\n\tstruct ima_template_field *found_fields[IMA_TEMPLATE_NUM_FIELDS_MAX];\n\tint template_num_fields;\n\tint i, len;\n\n\tif (num_fields && *num_fields > 0) /* already initialized? */\n\t\treturn 0;\n\n\ttemplate_num_fields = template_fmt_size(template_fmt);\n\n\tif (template_num_fields > IMA_TEMPLATE_NUM_FIELDS_MAX) {\n\t\tpr_err(\"format string '%s' contains too many fields\\n\",\n\t\t       template_fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, template_fmt_ptr = template_fmt; i < template_num_fields;\n\t     i++, template_fmt_ptr += len + 1) {\n\t\tchar tmp_field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN + 1];\n\n\t\tlen = strchrnul(template_fmt_ptr, '|') - template_fmt_ptr;\n\t\tif (len == 0 || len > IMA_TEMPLATE_FIELD_ID_MAX_LEN) {\n\t\t\tpr_err(\"Invalid field with length %d\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(tmp_field_id, template_fmt_ptr, len);\n\t\ttmp_field_id[len] = '\\0';\n\t\tfound_fields[i] = lookup_template_field(tmp_field_id);\n\t\tif (!found_fields[i]) {\n\t\t\tpr_err(\"field '%s' not found\\n\", tmp_field_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (fields && num_fields) {\n\t\t*fields = kmalloc_array(i, sizeof(*fields), GFP_KERNEL);\n\t\tif (*fields == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(*fields, found_fields, i * sizeof(*fields));\n\t\t*num_fields = i;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_template_desc_current",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "ima_template_desc_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "221-229",
          "snippet": "struct ima_template_desc *ima_template_desc_current(void)\n{\n\tif (!ima_template) {\n\t\tima_init_template_list();\n\t\tima_template =\n\t\t    lookup_template_desc(CONFIG_IMA_DEFAULT_TEMPLATE);\n\t}\n\treturn ima_template;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ima_template_desc *ima_template;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc *ima_template;\n\nstruct ima_template_desc *ima_template_desc_current(void)\n{\n\tif (!ima_template) {\n\t\tima_init_template_list();\n\t\tima_template =\n\t\t    lookup_template_desc(CONFIG_IMA_DEFAULT_TEMPLATE);\n\t}\n\treturn ima_template;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc *lookup_template_desc(const char *name);\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);\n\nint __init ima_init_template(void)\n{\n\tstruct ima_template_desc *template = ima_template_desc_current();\n\tint result;\n\n\tresult = template_desc_init_fields(template->fmt,\n\t\t\t\t\t   &(template->fields),\n\t\t\t\t\t   &(template->num_fields));\n\tif (result < 0)\n\t\tpr_err(\"template %s init failed, result: %d\\n\",\n\t\t       (strlen(template->name) ?\n\t\t       template->name : template->fmt), result);\n\n\treturn result;\n}"
  },
  {
    "function_name": "ima_template_desc_current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
    "lines": "221-229",
    "snippet": "struct ima_template_desc *ima_template_desc_current(void)\n{\n\tif (!ima_template) {\n\t\tima_init_template_list();\n\t\tima_template =\n\t\t    lookup_template_desc(CONFIG_IMA_DEFAULT_TEMPLATE);\n\t}\n\treturn ima_template;\n}",
    "includes": [
      "#include \"ima_template_lib.h\"",
      "#include \"ima.h\"",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ima_template_desc *ima_template;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lookup_template_desc",
          "args": [
            "CONFIG_IMA_DEFAULT_TEMPLATE"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_template_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "111-126",
          "snippet": "static struct ima_template_desc *lookup_template_desc(const char *name)\n{\n\tstruct ima_template_desc *template_desc;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(template_desc, &defined_templates, list) {\n\t\tif ((strcmp(template_desc->name, name) == 0) ||\n\t\t    (strcmp(template_desc->fmt, name) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn found ? template_desc : NULL;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(defined_templates);",
            "static struct ima_template_desc *lookup_template_desc(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic LIST_HEAD(defined_templates);\nstatic struct ima_template_desc *lookup_template_desc(const char *name);\n\nstatic struct ima_template_desc *lookup_template_desc(const char *name)\n{\n\tstruct ima_template_desc *template_desc;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(template_desc, &defined_templates, list) {\n\t\tif ((strcmp(template_desc->name, name) == 0) ||\n\t\t    (strcmp(template_desc->fmt, name) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn found ? template_desc : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_init_template_list",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "ima_init_template_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "206-219",
          "snippet": "void ima_init_template_list(void)\n{\n\tint i;\n\n\tif (!list_empty(&defined_templates))\n\t\treturn;\n\n\tspin_lock(&template_list);\n\tfor (i = 0; i < ARRAY_SIZE(builtin_templates); i++) {\n\t\tlist_add_tail_rcu(&builtin_templates[i].list,\n\t\t\t\t  &defined_templates);\n\t}\n\tspin_unlock(&template_list);\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ima_template_desc builtin_templates[] = {\n\t{.name = IMA_TEMPLATE_IMA_NAME, .fmt = IMA_TEMPLATE_IMA_FMT},\n\t{.name = \"ima-ng\", .fmt = \"d-ng|n-ng\"},\n\t{.name = \"ima-sig\", .fmt = \"d-ng|n-ng|sig\"},\n\t{.name = \"\", .fmt = \"\"},\t/* placeholder for a custom format */\n};",
            "static LIST_HEAD(defined_templates);",
            "static DEFINE_SPINLOCK(template_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc builtin_templates[] = {\n\t{.name = IMA_TEMPLATE_IMA_NAME, .fmt = IMA_TEMPLATE_IMA_FMT},\n\t{.name = \"ima-ng\", .fmt = \"d-ng|n-ng\"},\n\t{.name = \"ima-sig\", .fmt = \"d-ng|n-ng|sig\"},\n\t{.name = \"\", .fmt = \"\"},\t/* placeholder for a custom format */\n};\nstatic LIST_HEAD(defined_templates);\nstatic DEFINE_SPINLOCK(template_list);\n\nvoid ima_init_template_list(void)\n{\n\tint i;\n\n\tif (!list_empty(&defined_templates))\n\t\treturn;\n\n\tspin_lock(&template_list);\n\tfor (i = 0; i < ARRAY_SIZE(builtin_templates); i++) {\n\t\tlist_add_tail_rcu(&builtin_templates[i].list,\n\t\t\t\t  &defined_templates);\n\t}\n\tspin_unlock(&template_list);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc *ima_template;\n\nstruct ima_template_desc *ima_template_desc_current(void)\n{\n\tif (!ima_template) {\n\t\tima_init_template_list();\n\t\tima_template =\n\t\t    lookup_template_desc(CONFIG_IMA_DEFAULT_TEMPLATE);\n\t}\n\treturn ima_template;\n}"
  },
  {
    "function_name": "ima_init_template_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
    "lines": "206-219",
    "snippet": "void ima_init_template_list(void)\n{\n\tint i;\n\n\tif (!list_empty(&defined_templates))\n\t\treturn;\n\n\tspin_lock(&template_list);\n\tfor (i = 0; i < ARRAY_SIZE(builtin_templates); i++) {\n\t\tlist_add_tail_rcu(&builtin_templates[i].list,\n\t\t\t\t  &defined_templates);\n\t}\n\tspin_unlock(&template_list);\n}",
    "includes": [
      "#include \"ima_template_lib.h\"",
      "#include \"ima.h\"",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ima_template_desc builtin_templates[] = {\n\t{.name = IMA_TEMPLATE_IMA_NAME, .fmt = IMA_TEMPLATE_IMA_FMT},\n\t{.name = \"ima-ng\", .fmt = \"d-ng|n-ng\"},\n\t{.name = \"ima-sig\", .fmt = \"d-ng|n-ng|sig\"},\n\t{.name = \"\", .fmt = \"\"},\t/* placeholder for a custom format */\n};",
      "static LIST_HEAD(defined_templates);",
      "static DEFINE_SPINLOCK(template_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&template_list"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&builtin_templates[i].list",
            "&defined_templates"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "builtin_templates"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&template_list"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&defined_templates"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc builtin_templates[] = {\n\t{.name = IMA_TEMPLATE_IMA_NAME, .fmt = IMA_TEMPLATE_IMA_FMT},\n\t{.name = \"ima-ng\", .fmt = \"d-ng|n-ng\"},\n\t{.name = \"ima-sig\", .fmt = \"d-ng|n-ng|sig\"},\n\t{.name = \"\", .fmt = \"\"},\t/* placeholder for a custom format */\n};\nstatic LIST_HEAD(defined_templates);\nstatic DEFINE_SPINLOCK(template_list);\n\nvoid ima_init_template_list(void)\n{\n\tint i;\n\n\tif (!list_empty(&defined_templates))\n\t\treturn;\n\n\tspin_lock(&template_list);\n\tfor (i = 0; i < ARRAY_SIZE(builtin_templates); i++) {\n\t\tlist_add_tail_rcu(&builtin_templates[i].list,\n\t\t\t\t  &defined_templates);\n\t}\n\tspin_unlock(&template_list);\n}"
  },
  {
    "function_name": "template_desc_init_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
    "lines": "155-204",
    "snippet": "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields)\n{\n\tconst char *template_fmt_ptr;\n\tstruct ima_template_field *found_fields[IMA_TEMPLATE_NUM_FIELDS_MAX];\n\tint template_num_fields;\n\tint i, len;\n\n\tif (num_fields && *num_fields > 0) /* already initialized? */\n\t\treturn 0;\n\n\ttemplate_num_fields = template_fmt_size(template_fmt);\n\n\tif (template_num_fields > IMA_TEMPLATE_NUM_FIELDS_MAX) {\n\t\tpr_err(\"format string '%s' contains too many fields\\n\",\n\t\t       template_fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, template_fmt_ptr = template_fmt; i < template_num_fields;\n\t     i++, template_fmt_ptr += len + 1) {\n\t\tchar tmp_field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN + 1];\n\n\t\tlen = strchrnul(template_fmt_ptr, '|') - template_fmt_ptr;\n\t\tif (len == 0 || len > IMA_TEMPLATE_FIELD_ID_MAX_LEN) {\n\t\t\tpr_err(\"Invalid field with length %d\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(tmp_field_id, template_fmt_ptr, len);\n\t\ttmp_field_id[len] = '\\0';\n\t\tfound_fields[i] = lookup_template_field(tmp_field_id);\n\t\tif (!found_fields[i]) {\n\t\t\tpr_err(\"field '%s' not found\\n\", tmp_field_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (fields && num_fields) {\n\t\t*fields = kmalloc_array(i, sizeof(*fields), GFP_KERNEL);\n\t\tif (*fields == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(*fields, found_fields, i * sizeof(*fields));\n\t\t*num_fields = i;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"ima_template_lib.h\"",
      "#include \"ima.h\"",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "*fields",
            "found_fields",
            "i * sizeof(*fields)"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "i",
            "sizeof(*fields)",
            "GFP_KERNEL"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"field '%s' not found\\n\"",
            "tmp_field_id"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_template_field",
          "args": [
            "tmp_field_id"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_template_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "128-137",
          "snippet": "static struct ima_template_field *lookup_template_field(const char *field_id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(supported_fields); i++)\n\t\tif (strncmp(supported_fields[i].field_id, field_id,\n\t\t\t    IMA_TEMPLATE_FIELD_ID_MAX_LEN) == 0)\n\t\t\treturn &supported_fields[i];\n\treturn NULL;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ima_template_field supported_fields[] = {\n\t{.field_id = \"d\", .field_init = ima_eventdigest_init,\n\t .field_show = ima_show_template_digest},\n\t{.field_id = \"n\", .field_init = ima_eventname_init,\n\t .field_show = ima_show_template_string},\n\t{.field_id = \"d-ng\", .field_init = ima_eventdigest_ng_init,\n\t .field_show = ima_show_template_digest_ng},\n\t{.field_id = \"n-ng\", .field_init = ima_eventname_ng_init,\n\t .field_show = ima_show_template_string},\n\t{.field_id = \"sig\", .field_init = ima_eventsig_init,\n\t .field_show = ima_show_template_sig},\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_field supported_fields[] = {\n\t{.field_id = \"d\", .field_init = ima_eventdigest_init,\n\t .field_show = ima_show_template_digest},\n\t{.field_id = \"n\", .field_init = ima_eventname_init,\n\t .field_show = ima_show_template_string},\n\t{.field_id = \"d-ng\", .field_init = ima_eventdigest_ng_init,\n\t .field_show = ima_show_template_digest_ng},\n\t{.field_id = \"n-ng\", .field_init = ima_eventname_ng_init,\n\t .field_show = ima_show_template_string},\n\t{.field_id = \"sig\", .field_init = ima_eventsig_init,\n\t .field_show = ima_show_template_sig},\n};\n\nstatic struct ima_template_field *lookup_template_field(const char *field_id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(supported_fields); i++)\n\t\tif (strncmp(supported_fields[i].field_id, field_id,\n\t\t\t    IMA_TEMPLATE_FIELD_ID_MAX_LEN) == 0)\n\t\t\treturn &supported_fields[i];\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "tmp_field_id",
            "template_fmt_ptr",
            "len"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid field with length %d\\n\"",
            "len"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchrnul",
          "args": [
            "template_fmt_ptr",
            "'|'"
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"format string '%s' contains too many fields\\n\"",
            "template_fmt"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "template_fmt_size",
          "args": [
            "template_fmt"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "template_fmt_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "139-153",
          "snippet": "static int template_fmt_size(const char *template_fmt)\n{\n\tchar c;\n\tint template_fmt_len = strlen(template_fmt);\n\tint i = 0, j = 0;\n\n\twhile (i < template_fmt_len) {\n\t\tc = template_fmt[i];\n\t\tif (c == '|')\n\t\t\tj++;\n\t\ti++;\n\t}\n\n\treturn j + 1;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic int template_fmt_size(const char *template_fmt)\n{\n\tchar c;\n\tint template_fmt_len = strlen(template_fmt);\n\tint i = 0, j = 0;\n\n\twhile (i < template_fmt_len) {\n\t\tc = template_fmt[i];\n\t\tif (c == '|')\n\t\t\tj++;\n\t\ti++;\n\t}\n\n\treturn j + 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);\n\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields)\n{\n\tconst char *template_fmt_ptr;\n\tstruct ima_template_field *found_fields[IMA_TEMPLATE_NUM_FIELDS_MAX];\n\tint template_num_fields;\n\tint i, len;\n\n\tif (num_fields && *num_fields > 0) /* already initialized? */\n\t\treturn 0;\n\n\ttemplate_num_fields = template_fmt_size(template_fmt);\n\n\tif (template_num_fields > IMA_TEMPLATE_NUM_FIELDS_MAX) {\n\t\tpr_err(\"format string '%s' contains too many fields\\n\",\n\t\t       template_fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, template_fmt_ptr = template_fmt; i < template_num_fields;\n\t     i++, template_fmt_ptr += len + 1) {\n\t\tchar tmp_field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN + 1];\n\n\t\tlen = strchrnul(template_fmt_ptr, '|') - template_fmt_ptr;\n\t\tif (len == 0 || len > IMA_TEMPLATE_FIELD_ID_MAX_LEN) {\n\t\t\tpr_err(\"Invalid field with length %d\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(tmp_field_id, template_fmt_ptr, len);\n\t\ttmp_field_id[len] = '\\0';\n\t\tfound_fields[i] = lookup_template_field(tmp_field_id);\n\t\tif (!found_fields[i]) {\n\t\t\tpr_err(\"field '%s' not found\\n\", tmp_field_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (fields && num_fields) {\n\t\t*fields = kmalloc_array(i, sizeof(*fields), GFP_KERNEL);\n\t\tif (*fields == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(*fields, found_fields, i * sizeof(*fields));\n\t\t*num_fields = i;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "template_fmt_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
    "lines": "139-153",
    "snippet": "static int template_fmt_size(const char *template_fmt)\n{\n\tchar c;\n\tint template_fmt_len = strlen(template_fmt);\n\tint i = 0, j = 0;\n\n\twhile (i < template_fmt_len) {\n\t\tc = template_fmt[i];\n\t\tif (c == '|')\n\t\t\tj++;\n\t\ti++;\n\t}\n\n\treturn j + 1;\n}",
    "includes": [
      "#include \"ima_template_lib.h\"",
      "#include \"ima.h\"",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "template_fmt"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic int template_fmt_size(const char *template_fmt)\n{\n\tchar c;\n\tint template_fmt_len = strlen(template_fmt);\n\tint i = 0, j = 0;\n\n\twhile (i < template_fmt_len) {\n\t\tc = template_fmt[i];\n\t\tif (c == '|')\n\t\t\tj++;\n\t\ti++;\n\t}\n\n\treturn j + 1;\n}"
  },
  {
    "function_name": "lookup_template_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
    "lines": "128-137",
    "snippet": "static struct ima_template_field *lookup_template_field(const char *field_id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(supported_fields); i++)\n\t\tif (strncmp(supported_fields[i].field_id, field_id,\n\t\t\t    IMA_TEMPLATE_FIELD_ID_MAX_LEN) == 0)\n\t\t\treturn &supported_fields[i];\n\treturn NULL;\n}",
    "includes": [
      "#include \"ima_template_lib.h\"",
      "#include \"ima.h\"",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ima_template_field supported_fields[] = {\n\t{.field_id = \"d\", .field_init = ima_eventdigest_init,\n\t .field_show = ima_show_template_digest},\n\t{.field_id = \"n\", .field_init = ima_eventname_init,\n\t .field_show = ima_show_template_string},\n\t{.field_id = \"d-ng\", .field_init = ima_eventdigest_ng_init,\n\t .field_show = ima_show_template_digest_ng},\n\t{.field_id = \"n-ng\", .field_init = ima_eventname_ng_init,\n\t .field_show = ima_show_template_string},\n\t{.field_id = \"sig\", .field_init = ima_eventsig_init,\n\t .field_show = ima_show_template_sig},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "supported_fields[i].field_id",
            "field_id",
            "IMA_TEMPLATE_FIELD_ID_MAX_LEN"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "supported_fields"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_field supported_fields[] = {\n\t{.field_id = \"d\", .field_init = ima_eventdigest_init,\n\t .field_show = ima_show_template_digest},\n\t{.field_id = \"n\", .field_init = ima_eventname_init,\n\t .field_show = ima_show_template_string},\n\t{.field_id = \"d-ng\", .field_init = ima_eventdigest_ng_init,\n\t .field_show = ima_show_template_digest_ng},\n\t{.field_id = \"n-ng\", .field_init = ima_eventname_ng_init,\n\t .field_show = ima_show_template_string},\n\t{.field_id = \"sig\", .field_init = ima_eventsig_init,\n\t .field_show = ima_show_template_sig},\n};\n\nstatic struct ima_template_field *lookup_template_field(const char *field_id)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(supported_fields); i++)\n\t\tif (strncmp(supported_fields[i].field_id, field_id,\n\t\t\t    IMA_TEMPLATE_FIELD_ID_MAX_LEN) == 0)\n\t\t\treturn &supported_fields[i];\n\treturn NULL;\n}"
  },
  {
    "function_name": "lookup_template_desc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
    "lines": "111-126",
    "snippet": "static struct ima_template_desc *lookup_template_desc(const char *name)\n{\n\tstruct ima_template_desc *template_desc;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(template_desc, &defined_templates, list) {\n\t\tif ((strcmp(template_desc->name, name) == 0) ||\n\t\t    (strcmp(template_desc->fmt, name) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn found ? template_desc : NULL;\n}",
    "includes": [
      "#include \"ima_template_lib.h\"",
      "#include \"ima.h\"",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(defined_templates);",
      "static struct ima_template_desc *lookup_template_desc(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "template_desc->fmt",
            "name"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "template_desc->name",
            "name"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "template_desc",
            "&defined_templates",
            "list"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic LIST_HEAD(defined_templates);\nstatic struct ima_template_desc *lookup_template_desc(const char *name);\n\nstatic struct ima_template_desc *lookup_template_desc(const char *name)\n{\n\tstruct ima_template_desc *template_desc;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(template_desc, &defined_templates, list) {\n\t\tif ((strcmp(template_desc->name, name) == 0) ||\n\t\t    (strcmp(template_desc->fmt, name) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn found ? template_desc : NULL;\n}"
  },
  {
    "function_name": "ima_template_fmt_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
    "lines": "91-108",
    "snippet": "static int __init ima_template_fmt_setup(char *str)\n{\n\tint num_templates = ARRAY_SIZE(builtin_templates);\n\n\tif (ima_template)\n\t\treturn 1;\n\n\tif (template_desc_init_fields(str, NULL, NULL) < 0) {\n\t\tpr_err(\"format string '%s' not valid, using template %s\\n\",\n\t\t       str, CONFIG_IMA_DEFAULT_TEMPLATE);\n\t\treturn 1;\n\t}\n\n\tbuiltin_templates[num_templates - 1].fmt = str;\n\tima_template = builtin_templates + num_templates - 1;\n\n\treturn 1;\n}",
    "includes": [
      "#include \"ima_template_lib.h\"",
      "#include \"ima.h\"",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ima_template_desc builtin_templates[] = {\n\t{.name = IMA_TEMPLATE_IMA_NAME, .fmt = IMA_TEMPLATE_IMA_FMT},\n\t{.name = \"ima-ng\", .fmt = \"d-ng|n-ng\"},\n\t{.name = \"ima-sig\", .fmt = \"d-ng|n-ng|sig\"},\n\t{.name = \"\", .fmt = \"\"},\t/* placeholder for a custom format */\n};",
      "static struct ima_template_desc *ima_template;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"format string '%s' not valid, using template %s\\n\"",
            "str",
            "CONFIG_IMA_DEFAULT_TEMPLATE"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "template_desc_init_fields",
          "args": [
            "str",
            "NULL",
            "NULL"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "template_desc_init_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "155-204",
          "snippet": "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields)\n{\n\tconst char *template_fmt_ptr;\n\tstruct ima_template_field *found_fields[IMA_TEMPLATE_NUM_FIELDS_MAX];\n\tint template_num_fields;\n\tint i, len;\n\n\tif (num_fields && *num_fields > 0) /* already initialized? */\n\t\treturn 0;\n\n\ttemplate_num_fields = template_fmt_size(template_fmt);\n\n\tif (template_num_fields > IMA_TEMPLATE_NUM_FIELDS_MAX) {\n\t\tpr_err(\"format string '%s' contains too many fields\\n\",\n\t\t       template_fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, template_fmt_ptr = template_fmt; i < template_num_fields;\n\t     i++, template_fmt_ptr += len + 1) {\n\t\tchar tmp_field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN + 1];\n\n\t\tlen = strchrnul(template_fmt_ptr, '|') - template_fmt_ptr;\n\t\tif (len == 0 || len > IMA_TEMPLATE_FIELD_ID_MAX_LEN) {\n\t\t\tpr_err(\"Invalid field with length %d\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(tmp_field_id, template_fmt_ptr, len);\n\t\ttmp_field_id[len] = '\\0';\n\t\tfound_fields[i] = lookup_template_field(tmp_field_id);\n\t\tif (!found_fields[i]) {\n\t\t\tpr_err(\"field '%s' not found\\n\", tmp_field_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (fields && num_fields) {\n\t\t*fields = kmalloc_array(i, sizeof(*fields), GFP_KERNEL);\n\t\tif (*fields == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(*fields, found_fields, i * sizeof(*fields));\n\t\t*num_fields = i;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields);\n\nstatic int template_desc_init_fields(const char *template_fmt,\n\t\t\t\t     struct ima_template_field ***fields,\n\t\t\t\t     int *num_fields)\n{\n\tconst char *template_fmt_ptr;\n\tstruct ima_template_field *found_fields[IMA_TEMPLATE_NUM_FIELDS_MAX];\n\tint template_num_fields;\n\tint i, len;\n\n\tif (num_fields && *num_fields > 0) /* already initialized? */\n\t\treturn 0;\n\n\ttemplate_num_fields = template_fmt_size(template_fmt);\n\n\tif (template_num_fields > IMA_TEMPLATE_NUM_FIELDS_MAX) {\n\t\tpr_err(\"format string '%s' contains too many fields\\n\",\n\t\t       template_fmt);\n\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, template_fmt_ptr = template_fmt; i < template_num_fields;\n\t     i++, template_fmt_ptr += len + 1) {\n\t\tchar tmp_field_id[IMA_TEMPLATE_FIELD_ID_MAX_LEN + 1];\n\n\t\tlen = strchrnul(template_fmt_ptr, '|') - template_fmt_ptr;\n\t\tif (len == 0 || len > IMA_TEMPLATE_FIELD_ID_MAX_LEN) {\n\t\t\tpr_err(\"Invalid field with length %d\\n\", len);\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tmemcpy(tmp_field_id, template_fmt_ptr, len);\n\t\ttmp_field_id[len] = '\\0';\n\t\tfound_fields[i] = lookup_template_field(tmp_field_id);\n\t\tif (!found_fields[i]) {\n\t\t\tpr_err(\"field '%s' not found\\n\", tmp_field_id);\n\t\t\treturn -ENOENT;\n\t\t}\n\t}\n\n\tif (fields && num_fields) {\n\t\t*fields = kmalloc_array(i, sizeof(*fields), GFP_KERNEL);\n\t\tif (*fields == NULL)\n\t\t\treturn -ENOMEM;\n\n\t\tmemcpy(*fields, found_fields, i * sizeof(*fields));\n\t\t*num_fields = i;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "builtin_templates"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc builtin_templates[] = {\n\t{.name = IMA_TEMPLATE_IMA_NAME, .fmt = IMA_TEMPLATE_IMA_FMT},\n\t{.name = \"ima-ng\", .fmt = \"d-ng|n-ng\"},\n\t{.name = \"ima-sig\", .fmt = \"d-ng|n-ng|sig\"},\n\t{.name = \"\", .fmt = \"\"},\t/* placeholder for a custom format */\n};\nstatic struct ima_template_desc *ima_template;\n\nstatic int __init ima_template_fmt_setup(char *str)\n{\n\tint num_templates = ARRAY_SIZE(builtin_templates);\n\n\tif (ima_template)\n\t\treturn 1;\n\n\tif (template_desc_init_fields(str, NULL, NULL) < 0) {\n\t\tpr_err(\"format string '%s' not valid, using template %s\\n\",\n\t\t       str, CONFIG_IMA_DEFAULT_TEMPLATE);\n\t\treturn 1;\n\t}\n\n\tbuiltin_templates[num_templates - 1].fmt = str;\n\tima_template = builtin_templates + num_templates - 1;\n\n\treturn 1;\n}"
  },
  {
    "function_name": "ima_template_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
    "lines": "55-88",
    "snippet": "static int __init ima_template_setup(char *str)\n{\n\tstruct ima_template_desc *template_desc;\n\tint template_len = strlen(str);\n\n\tif (ima_template)\n\t\treturn 1;\n\n\tima_init_template_list();\n\n\t/*\n\t * Verify that a template with the supplied name exists.\n\t * If not, use CONFIG_IMA_DEFAULT_TEMPLATE.\n\t */\n\ttemplate_desc = lookup_template_desc(str);\n\tif (!template_desc) {\n\t\tpr_err(\"template %s not found, using %s\\n\",\n\t\t       str, CONFIG_IMA_DEFAULT_TEMPLATE);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Verify whether the current hash algorithm is supported\n\t * by the 'ima' template.\n\t */\n\tif (template_len == 3 && strcmp(str, IMA_TEMPLATE_IMA_NAME) == 0 &&\n\t    ima_hash_algo != HASH_ALGO_SHA1 && ima_hash_algo != HASH_ALGO_MD5) {\n\t\tpr_err(\"template does not support hash alg\\n\");\n\t\treturn 1;\n\t}\n\n\tima_template = template_desc;\n\treturn 1;\n}",
    "includes": [
      "#include \"ima_template_lib.h\"",
      "#include \"ima.h\"",
      "#include <linux/rculist.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ima_template_desc *ima_template;",
      "static struct ima_template_desc *lookup_template_desc(const char *name);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"template does not support hash alg\\n\""
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "IMA_TEMPLATE_IMA_NAME"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"template %s not found, using %s\\n\"",
            "str",
            "CONFIG_IMA_DEFAULT_TEMPLATE"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_template_desc",
          "args": [
            "str"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_template_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "111-126",
          "snippet": "static struct ima_template_desc *lookup_template_desc(const char *name)\n{\n\tstruct ima_template_desc *template_desc;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(template_desc, &defined_templates, list) {\n\t\tif ((strcmp(template_desc->name, name) == 0) ||\n\t\t    (strcmp(template_desc->fmt, name) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn found ? template_desc : NULL;\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(defined_templates);",
            "static struct ima_template_desc *lookup_template_desc(const char *name);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic LIST_HEAD(defined_templates);\nstatic struct ima_template_desc *lookup_template_desc(const char *name);\n\nstatic struct ima_template_desc *lookup_template_desc(const char *name)\n{\n\tstruct ima_template_desc *template_desc;\n\tint found = 0;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(template_desc, &defined_templates, list) {\n\t\tif ((strcmp(template_desc->name, name) == 0) ||\n\t\t    (strcmp(template_desc->fmt, name) == 0)) {\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn found ? template_desc : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ima_init_template_list",
          "args": [],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "ima_init_template_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/ima/ima_template.c",
          "lines": "206-219",
          "snippet": "void ima_init_template_list(void)\n{\n\tint i;\n\n\tif (!list_empty(&defined_templates))\n\t\treturn;\n\n\tspin_lock(&template_list);\n\tfor (i = 0; i < ARRAY_SIZE(builtin_templates); i++) {\n\t\tlist_add_tail_rcu(&builtin_templates[i].list,\n\t\t\t\t  &defined_templates);\n\t}\n\tspin_unlock(&template_list);\n}",
          "includes": [
            "#include \"ima_template_lib.h\"",
            "#include \"ima.h\"",
            "#include <linux/rculist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct ima_template_desc builtin_templates[] = {\n\t{.name = IMA_TEMPLATE_IMA_NAME, .fmt = IMA_TEMPLATE_IMA_FMT},\n\t{.name = \"ima-ng\", .fmt = \"d-ng|n-ng\"},\n\t{.name = \"ima-sig\", .fmt = \"d-ng|n-ng|sig\"},\n\t{.name = \"\", .fmt = \"\"},\t/* placeholder for a custom format */\n};",
            "static LIST_HEAD(defined_templates);",
            "static DEFINE_SPINLOCK(template_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc builtin_templates[] = {\n\t{.name = IMA_TEMPLATE_IMA_NAME, .fmt = IMA_TEMPLATE_IMA_FMT},\n\t{.name = \"ima-ng\", .fmt = \"d-ng|n-ng\"},\n\t{.name = \"ima-sig\", .fmt = \"d-ng|n-ng|sig\"},\n\t{.name = \"\", .fmt = \"\"},\t/* placeholder for a custom format */\n};\nstatic LIST_HEAD(defined_templates);\nstatic DEFINE_SPINLOCK(template_list);\n\nvoid ima_init_template_list(void)\n{\n\tint i;\n\n\tif (!list_empty(&defined_templates))\n\t\treturn;\n\n\tspin_lock(&template_list);\n\tfor (i = 0; i < ARRAY_SIZE(builtin_templates); i++) {\n\t\tlist_add_tail_rcu(&builtin_templates[i].list,\n\t\t\t\t  &defined_templates);\n\t}\n\tspin_unlock(&template_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"ima_template_lib.h\"\n#include \"ima.h\"\n#include <linux/rculist.h>\n\nstatic struct ima_template_desc *ima_template;\nstatic struct ima_template_desc *lookup_template_desc(const char *name);\n\nstatic int __init ima_template_setup(char *str)\n{\n\tstruct ima_template_desc *template_desc;\n\tint template_len = strlen(str);\n\n\tif (ima_template)\n\t\treturn 1;\n\n\tima_init_template_list();\n\n\t/*\n\t * Verify that a template with the supplied name exists.\n\t * If not, use CONFIG_IMA_DEFAULT_TEMPLATE.\n\t */\n\ttemplate_desc = lookup_template_desc(str);\n\tif (!template_desc) {\n\t\tpr_err(\"template %s not found, using %s\\n\",\n\t\t       str, CONFIG_IMA_DEFAULT_TEMPLATE);\n\t\treturn 1;\n\t}\n\n\t/*\n\t * Verify whether the current hash algorithm is supported\n\t * by the 'ima' template.\n\t */\n\tif (template_len == 3 && strcmp(str, IMA_TEMPLATE_IMA_NAME) == 0 &&\n\t    ima_hash_algo != HASH_ALGO_SHA1 && ima_hash_algo != HASH_ALGO_MD5) {\n\t\tpr_err(\"template does not support hash alg\\n\");\n\t\treturn 1;\n\t}\n\n\tima_template = template_desc;\n\treturn 1;\n}"
  }
]