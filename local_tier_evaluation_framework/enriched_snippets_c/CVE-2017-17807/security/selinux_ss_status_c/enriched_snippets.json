[
  {
    "function_name": "selinux_status_update_policyload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/status.c",
    "lines": "108-126",
    "snippet": "void selinux_status_update_policyload(int seqno)\n{\n\tstruct selinux_kernel_status   *status;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (selinux_status_page) {\n\t\tstatus = page_address(selinux_status_page);\n\n\t\tstatus->sequence++;\n\t\tsmp_wmb();\n\n\t\tstatus->policyload = seqno;\n\t\tstatus->deny_unknown = !security_get_allow_unknown();\n\n\t\tsmp_wmb();\n\t\tstatus->sequence++;\n\t}\n\tmutex_unlock(&selinux_status_lock);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"avc.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct page *selinux_status_page;",
      "static DEFINE_MUTEX(selinux_status_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&selinux_status_lock"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_get_allow_unknown",
          "args": [],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "security_get_allow_unknown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3099-3102",
          "snippet": "int security_get_allow_unknown(void)\n{\n\treturn policydb.allow_unknown;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nint security_get_allow_unknown(void)\n{\n\treturn policydb.allow_unknown;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "selinux_status_page"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&selinux_status_lock"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"avc.h\"\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\nstatic struct page *selinux_status_page;\nstatic DEFINE_MUTEX(selinux_status_lock);\n\nvoid selinux_status_update_policyload(int seqno)\n{\n\tstruct selinux_kernel_status   *status;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (selinux_status_page) {\n\t\tstatus = page_address(selinux_status_page);\n\n\t\tstatus->sequence++;\n\t\tsmp_wmb();\n\n\t\tstatus->policyload = seqno;\n\t\tstatus->deny_unknown = !security_get_allow_unknown();\n\n\t\tsmp_wmb();\n\t\tstatus->sequence++;\n\t}\n\tmutex_unlock(&selinux_status_lock);\n}"
  },
  {
    "function_name": "selinux_status_update_setenforce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/status.c",
    "lines": "83-100",
    "snippet": "void selinux_status_update_setenforce(int enforcing)\n{\n\tstruct selinux_kernel_status   *status;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (selinux_status_page) {\n\t\tstatus = page_address(selinux_status_page);\n\n\t\tstatus->sequence++;\n\t\tsmp_wmb();\n\n\t\tstatus->enforcing = enforcing;\n\n\t\tsmp_wmb();\n\t\tstatus->sequence++;\n\t}\n\tmutex_unlock(&selinux_status_lock);\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"avc.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct page *selinux_status_page;",
      "static DEFINE_MUTEX(selinux_status_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&selinux_status_lock"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "selinux_status_page"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&selinux_status_lock"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"avc.h\"\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\nstatic struct page *selinux_status_page;\nstatic DEFINE_MUTEX(selinux_status_lock);\n\nvoid selinux_status_update_setenforce(int enforcing)\n{\n\tstruct selinux_kernel_status   *status;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (selinux_status_page) {\n\t\tstatus = page_address(selinux_status_page);\n\n\t\tstatus->sequence++;\n\t\tsmp_wmb();\n\n\t\tstatus->enforcing = enforcing;\n\n\t\tsmp_wmb();\n\t\tstatus->sequence++;\n\t}\n\tmutex_unlock(&selinux_status_lock);\n}"
  },
  {
    "function_name": "selinux_kernel_status_page",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/status.c",
    "lines": "47-76",
    "snippet": "struct page *selinux_kernel_status_page(void)\n{\n\tstruct selinux_kernel_status   *status;\n\tstruct page\t\t       *result = NULL;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (!selinux_status_page) {\n\t\tselinux_status_page = alloc_page(GFP_KERNEL|__GFP_ZERO);\n\n\t\tif (selinux_status_page) {\n\t\t\tstatus = page_address(selinux_status_page);\n\n\t\t\tstatus->version = SELINUX_KERNEL_STATUS_VERSION;\n\t\t\tstatus->sequence = 0;\n\t\t\tstatus->enforcing = selinux_enforcing;\n\t\t\t/*\n\t\t\t * NOTE: the next policyload event shall set\n\t\t\t * a positive value on the status->policyload,\n\t\t\t * although it may not be 1, but never zero.\n\t\t\t * So, application can know it was updated.\n\t\t\t */\n\t\t\tstatus->policyload = 0;\n\t\t\tstatus->deny_unknown = !security_get_allow_unknown();\n\t\t}\n\t}\n\tresult = selinux_status_page;\n\tmutex_unlock(&selinux_status_lock);\n\n\treturn result;\n}",
    "includes": [
      "#include \"services.h\"",
      "#include \"avc.h\"",
      "#include <linux/mutex.h>",
      "#include <linux/mm.h>",
      "#include <linux/gfp.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct page *selinux_status_page;",
      "static DEFINE_MUTEX(selinux_status_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&selinux_status_lock"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_get_allow_unknown",
          "args": [],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "security_get_allow_unknown",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/services.c",
          "lines": "3099-3102",
          "snippet": "int security_get_allow_unknown(void)\n{\n\treturn policydb.allow_unknown;\n}",
          "includes": [
            "#include \"initial_sid_to_string.h\"",
            "#include \"audit.h\"",
            "#include \"ebitmap.h\"",
            "#include \"xfrm.h\"",
            "#include \"netlabel.h\"",
            "#include \"objsec.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"services.h\"",
            "#include \"sidtab.h\"",
            "#include \"policydb.h\"",
            "#include \"context.h\"",
            "#include \"security.h\"",
            "#include \"avc_ss.h\"",
            "#include \"avc.h\"",
            "#include \"flask.h\"",
            "#include <net/netlabel.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/flex_array.h>",
            "#include <linux/selinux.h>",
            "#include <linux/mutex.h>",
            "#include <linux/audit.h>",
            "#include <linux/sched.h>",
            "#include <linux/in.h>",
            "#include <linux/errno.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct policydb policydb;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"initial_sid_to_string.h\"\n#include \"audit.h\"\n#include \"ebitmap.h\"\n#include \"xfrm.h\"\n#include \"netlabel.h\"\n#include \"objsec.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"services.h\"\n#include \"sidtab.h\"\n#include \"policydb.h\"\n#include \"context.h\"\n#include \"security.h\"\n#include \"avc_ss.h\"\n#include \"avc.h\"\n#include \"flask.h\"\n#include <net/netlabel.h>\n#include <linux/vmalloc.h>\n#include <linux/flex_array.h>\n#include <linux/selinux.h>\n#include <linux/mutex.h>\n#include <linux/audit.h>\n#include <linux/sched.h>\n#include <linux/in.h>\n#include <linux/errno.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct policydb policydb;\n\nint security_get_allow_unknown(void)\n{\n\treturn policydb.allow_unknown;\n}"
        }
      },
      {
        "call_info": {
          "callee": "page_address",
          "args": [
            "selinux_status_page"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_page",
          "args": [
            "GFP_KERNEL|__GFP_ZERO"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&selinux_status_lock"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"services.h\"\n#include \"avc.h\"\n#include <linux/mutex.h>\n#include <linux/mm.h>\n#include <linux/gfp.h>\n#include <linux/kernel.h>\n\nstatic struct page *selinux_status_page;\nstatic DEFINE_MUTEX(selinux_status_lock);\n\nstruct page *selinux_kernel_status_page(void)\n{\n\tstruct selinux_kernel_status   *status;\n\tstruct page\t\t       *result = NULL;\n\n\tmutex_lock(&selinux_status_lock);\n\tif (!selinux_status_page) {\n\t\tselinux_status_page = alloc_page(GFP_KERNEL|__GFP_ZERO);\n\n\t\tif (selinux_status_page) {\n\t\t\tstatus = page_address(selinux_status_page);\n\n\t\t\tstatus->version = SELINUX_KERNEL_STATUS_VERSION;\n\t\t\tstatus->sequence = 0;\n\t\t\tstatus->enforcing = selinux_enforcing;\n\t\t\t/*\n\t\t\t * NOTE: the next policyload event shall set\n\t\t\t * a positive value on the status->policyload,\n\t\t\t * although it may not be 1, but never zero.\n\t\t\t * So, application can know it was updated.\n\t\t\t */\n\t\t\tstatus->policyload = 0;\n\t\t\tstatus->deny_unknown = !security_get_allow_unknown();\n\t\t}\n\t}\n\tresult = selinux_status_page;\n\tmutex_unlock(&selinux_status_lock);\n\n\treturn result;\n}"
  }
]