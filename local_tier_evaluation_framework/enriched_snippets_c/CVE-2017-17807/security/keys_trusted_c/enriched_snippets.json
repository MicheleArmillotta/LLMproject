[
  {
    "function_name": "cleanup_trusted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "1234-1238",
    "snippet": "static void __exit cleanup_trusted(void)\n{\n\ttrusted_shash_release();\n\tunregister_key_type(&key_type_trusted);\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct key_type key_type_trusted = {\n\t.name = \"trusted\",\n\t.instantiate = trusted_instantiate,\n\t.update = trusted_update,\n\t.destroy = trusted_destroy,\n\t.describe = user_describe,\n\t.read = trusted_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_key_type",
          "args": [
            "&key_type_trusted"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_key_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "1149-1157",
          "snippet": "void unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(key_types_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(key_types_sem);\n\nvoid unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trusted_shash_release",
          "args": [],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "trusted_shash_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "1187-1193",
          "snippet": "static void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *hashalg;",
            "static struct crypto_shash *hmacalg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nstatic void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstruct key_type key_type_trusted = {\n\t.name = \"trusted\",\n\t.instantiate = trusted_instantiate,\n\t.update = trusted_update,\n\t.destroy = trusted_destroy,\n\t.describe = user_describe,\n\t.read = trusted_read,\n};\n\nstatic void __exit cleanup_trusted(void)\n{\n\ttrusted_shash_release();\n\tunregister_key_type(&key_type_trusted);\n}"
  },
  {
    "function_name": "init_trusted",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "1221-1232",
    "snippet": "static int __init init_trusted(void)\n{\n\tint ret;\n\n\tret = trusted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = register_key_type(&key_type_trusted);\n\tif (ret < 0)\n\t\ttrusted_shash_release();\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct key_type key_type_trusted = {\n\t.name = \"trusted\",\n\t.instantiate = trusted_instantiate,\n\t.update = trusted_update,\n\t.destroy = trusted_destroy,\n\t.describe = user_describe,\n\t.read = trusted_read,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trusted_shash_release",
          "args": [],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "trusted_shash_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "1187-1193",
          "snippet": "static void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct crypto_shash *hashalg;",
            "static struct crypto_shash *hmacalg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nstatic void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_key_type",
          "args": [
            "&key_type_trusted"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_key_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "1149-1157",
          "snippet": "void unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(key_types_sem);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(key_types_sem);\n\nvoid unregister_key_type(struct key_type *ktype)\n{\n\tdown_write(&key_types_sem);\n\tlist_del_init(&ktype->link);\n\tdowngrade_write(&key_types_sem);\n\tkey_gc_keytype(ktype);\n\tpr_notice(\"Key type %s unregistered\\n\", ktype->name);\n\tup_read(&key_types_sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trusted_shash_alloc",
          "args": [],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "trusted_shash_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "1195-1219",
          "snippet": "static int __init trusted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hmac_alg[] = \"hmac(sha1)\";",
            "static const char hash_alg[] = \"sha1\";",
            "static struct crypto_shash *hashalg;",
            "static struct crypto_shash *hmacalg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic const char hash_alg[] = \"sha1\";\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nstatic int __init trusted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstruct key_type key_type_trusted = {\n\t.name = \"trusted\",\n\t.instantiate = trusted_instantiate,\n\t.update = trusted_update,\n\t.destroy = trusted_destroy,\n\t.describe = user_describe,\n\t.read = trusted_read,\n};\n\nstatic int __init init_trusted(void)\n{\n\tint ret;\n\n\tret = trusted_shash_alloc();\n\tif (ret < 0)\n\t\treturn ret;\n\tret = register_key_type(&key_type_trusted);\n\tif (ret < 0)\n\t\ttrusted_shash_release();\n\treturn ret;\n}"
  },
  {
    "function_name": "trusted_shash_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "1195-1219",
    "snippet": "static int __init trusted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char hmac_alg[] = \"hmac(sha1)\";",
      "static const char hash_alg[] = \"sha1\";",
      "static struct crypto_shash *hashalg;",
      "static struct crypto_shash *hmacalg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "hmacalg"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hashalg"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: could not allocate crypto %s\\n\"",
            "hash_alg"
          ],
          "line": 1208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hashalg"
          ],
          "line": 1207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "hash_alg",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hmacalg"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: could not allocate crypto %s\\n\"",
            "hmac_alg"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hmacalg"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_alloc_shash",
          "args": [
            "hmac_alg",
            "0",
            "CRYPTO_ALG_ASYNC"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic const char hash_alg[] = \"sha1\";\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nstatic int __init trusted_shash_alloc(void)\n{\n\tint ret;\n\n\thmacalg = crypto_alloc_shash(hmac_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hmacalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thmac_alg);\n\t\treturn PTR_ERR(hmacalg);\n\t}\n\n\thashalg = crypto_alloc_shash(hash_alg, 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(hashalg)) {\n\t\tpr_info(\"trusted_key: could not allocate crypto %s\\n\",\n\t\t\thash_alg);\n\t\tret = PTR_ERR(hashalg);\n\t\tgoto hashalg_fail;\n\t}\n\n\treturn 0;\n\nhashalg_fail:\n\tcrypto_free_shash(hmacalg);\n\treturn ret;\n}"
  },
  {
    "function_name": "trusted_shash_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "1187-1193",
    "snippet": "static void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct crypto_shash *hashalg;",
      "static struct crypto_shash *hmacalg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "hmacalg"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_free_shash",
          "args": [
            "hashalg"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct crypto_shash *hashalg;\nstatic struct crypto_shash *hmacalg;\n\nstatic void trusted_shash_release(void)\n{\n\tif (hashalg)\n\t\tcrypto_free_shash(hashalg);\n\tif (hmacalg)\n\t\tcrypto_free_shash(hmacalg);\n}"
  },
  {
    "function_name": "trusted_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "1171-1174",
    "snippet": "static void trusted_destroy(struct key *key)\n{\n\tkzfree(key->payload.data[0]);\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "key->payload.data[0]"
          ],
          "line": 1173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic void trusted_destroy(struct key *key)\n{\n\tkzfree(key->payload.data[0]);\n}"
  },
  {
    "function_name": "trusted_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "1139-1166",
    "snippet": "static long trusted_read(const struct key *key, char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tconst struct trusted_key_payload *p;\n\tchar *ascii_buf;\n\tchar *bufp;\n\tint i;\n\n\tp = dereference_key_locked(key);\n\tif (!p)\n\t\treturn -EINVAL;\n\n\tif (buffer && buflen >= 2 * p->blob_len) {\n\t\tascii_buf = kmalloc(2 * p->blob_len, GFP_KERNEL);\n\t\tif (!ascii_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tbufp = ascii_buf;\n\t\tfor (i = 0; i < p->blob_len; i++)\n\t\t\tbufp = hex_byte_pack(bufp, p->blob[i]);\n\t\tif (copy_to_user(buffer, ascii_buf, 2 * p->blob_len) != 0) {\n\t\t\tkzfree(ascii_buf);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkzfree(ascii_buf);\n\t}\n\treturn 2 * p->blob_len;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "ascii_buf"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "ascii_buf"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "buffer",
            "ascii_buf",
            "2 * p->blob_len"
          ],
          "line": 1159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex_byte_pack",
          "args": [
            "bufp",
            "p->blob[i]"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "2 * p->blob_len",
            "GFP_KERNEL"
          ],
          "line": 1152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dereference_key_locked",
          "args": [
            "key"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic long trusted_read(const struct key *key, char __user *buffer,\n\t\t\t size_t buflen)\n{\n\tconst struct trusted_key_payload *p;\n\tchar *ascii_buf;\n\tchar *bufp;\n\tint i;\n\n\tp = dereference_key_locked(key);\n\tif (!p)\n\t\treturn -EINVAL;\n\n\tif (buffer && buflen >= 2 * p->blob_len) {\n\t\tascii_buf = kmalloc(2 * p->blob_len, GFP_KERNEL);\n\t\tif (!ascii_buf)\n\t\t\treturn -ENOMEM;\n\n\t\tbufp = ascii_buf;\n\t\tfor (i = 0; i < p->blob_len; i++)\n\t\t\tbufp = hex_byte_pack(bufp, p->blob[i]);\n\t\tif (copy_to_user(buffer, ascii_buf, 2 * p->blob_len) != 0) {\n\t\t\tkzfree(ascii_buf);\n\t\t\treturn -EFAULT;\n\t\t}\n\t\tkzfree(ascii_buf);\n\t}\n\treturn 2 * p->blob_len;\n}"
  },
  {
    "function_name": "trusted_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "1060-1133",
    "snippet": "static int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\n\tif (key_is_negative(key))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\t/* copy old key values, and reseal with new pcrs */\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "new_o"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "datablob"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&p->rcu",
            "trusted_rcu_free"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_keypointer",
          "args": [
            "key",
            "new_p"
          ],
          "line": 1127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "new_p"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: pcrlock failed (%d)\\n\"",
            "ret"
          ],
          "line": 1122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcrlock",
          "args": [
            "new_o->pcrlock"
          ],
          "line": 1120
        },
        "resolved": true,
        "details": {
          "function_name": "pcrlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "378-389",
          "snippet": "static int pcrlock(const int pcrnum)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\n\tif (ret != SHA1_DIGEST_SIZE)\n\t\treturn ret;\n\treturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int pcrlock(const int pcrnum)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\n\tif (ret != SHA1_DIGEST_SIZE)\n\t\treturn ret;\n\treturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "new_p"
          ],
          "line": 1116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: key_seal failed (%d)\\n\"",
            "ret"
          ],
          "line": 1115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_seal",
          "args": [
            "new_p",
            "new_o"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "key_seal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "662-683",
          "snippet": "static int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\t/* include migratable flag at end of sealed key */\n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkseal failed (%d)\\n\", ret);\n\n\tkzfree(tb);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\t/* include migratable flag at end of sealed key */\n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkseal failed (%d)\\n\", ret);\n\n\tkzfree(tb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_payload",
          "args": [
            "new_p"
          ],
          "line": 1111
        },
        "resolved": true,
        "details": {
          "function_name": "dump_payload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "88-90",
          "snippet": "static inline void dump_payload(struct trusted_key_payload *p)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dump_payload(struct trusted_key_payload *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new_p->key",
            "p->key",
            "p->key_len"
          ],
          "line": 1109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "new_p"
          ],
          "line": 1102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "new_p"
          ],
          "line": 1096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datablob_parse",
          "args": [
            "datablob",
            "new_p",
            "new_o"
          ],
          "line": 1093
        },
        "resolved": true,
        "details": {
          "function_name": "datablob_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "856-913",
          "snippet": "static int datablob_parse(char *datablob, struct trusted_key_payload *p,\n\t\t\t  struct trusted_key_options *o)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t/* main command */\n\tc = strsep(&datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t/* first argument is key size */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t/* first argument is sealed blob */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\t/* all arguments are options */\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};\n\nstatic int datablob_parse(char *datablob, struct trusted_key_payload *p,\n\t\t\t  struct trusted_key_options *o)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t/* main command */\n\tc = strsep(&datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t/* first argument is key size */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t/* first argument is sealed blob */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\t/* all arguments are options */\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "datablob",
            "prep->data",
            "datalen"
          ],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trusted_payload_alloc",
          "args": [
            "key"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "trusted_payload_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "935-947",
          "snippet": "static struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof *p);\n\tif (ret < 0)\n\t\treturn p;\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (p)\n\t\tp->migratable = 1; /* migratable by default */\n\treturn p;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof *p);\n\tif (ret < 0)\n\t\treturn p;\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (p)\n\t\tp->migratable = 1; /* migratable by default */\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trusted_options_alloc",
          "args": [],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "trusted_options_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "915-933",
          "snippet": "static struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn NULL;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t/* set any non-zero defaults */\n\t\toptions->keytype = SRK_keytype;\n\n\t\tif (!tpm2)\n\t\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn NULL;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t/* set any non-zero defaults */\n\t\toptions->keytype = SRK_keytype;\n\n\t\tif (!tpm2)\n\t\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "datalen + 1",
            "GFP_KERNEL"
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_is_negative",
          "args": [
            "key"
          ],
          "line": 1069
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int trusted_update(struct key *key, struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *p;\n\tstruct trusted_key_payload *new_p;\n\tstruct trusted_key_options *new_o;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\n\tif (key_is_negative(key))\n\t\treturn -ENOKEY;\n\tp = key->payload.data[0];\n\tif (!p->migratable)\n\t\treturn -EPERM;\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tnew_o = trusted_options_alloc();\n\tif (!new_o) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tnew_p = trusted_payload_alloc(key);\n\tif (!new_p) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\tret = datablob_parse(datablob, new_p, new_o);\n\tif (ret != Opt_update) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\tif (!new_o->keyhandle) {\n\t\tret = -EINVAL;\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\n\t/* copy old key values, and reseal with new pcrs */\n\tnew_p->migratable = p->migratable;\n\tnew_p->key_len = p->key_len;\n\tmemcpy(new_p->key, p->key, p->key_len);\n\tdump_payload(p);\n\tdump_payload(new_p);\n\n\tret = key_seal(new_p, new_o);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tkzfree(new_p);\n\t\tgoto out;\n\t}\n\tif (new_o->pcrlock) {\n\t\tret = pcrlock(new_o->pcrlock);\n\t\tif (ret < 0) {\n\t\t\tpr_info(\"trusted_key: pcrlock failed (%d)\\n\", ret);\n\t\t\tkzfree(new_p);\n\t\t\tgoto out;\n\t\t}\n\t}\n\trcu_assign_keypointer(key, new_p);\n\tcall_rcu(&p->rcu, trusted_rcu_free);\nout:\n\tkzfree(datablob);\n\tkzfree(new_o);\n\treturn ret;\n}"
  },
  {
    "function_name": "trusted_rcu_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "1049-1055",
    "snippet": "static void trusted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct trusted_key_payload *p;\n\n\tp = container_of(rcu, struct trusted_key_payload, rcu);\n\tkzfree(p);\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "p"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structtrusted_key_payload",
            "rcu"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic void trusted_rcu_free(struct rcu_head *rcu)\n{\n\tstruct trusted_key_payload *p;\n\n\tp = container_of(rcu, struct trusted_key_payload, rcu);\n\tkzfree(p);\n}"
  },
  {
    "function_name": "trusted_instantiate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "958-1047",
    "snippet": "static int trusted_instantiate(struct key *key,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *payload = NULL;\n\tstruct trusted_key_options *options = NULL;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tint key_cmd;\n\tsize_t key_len;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\n\toptions = trusted_options_alloc();\n\tif (!options) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpayload = trusted_payload_alloc(key);\n\tif (!payload) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey_cmd = datablob_parse(datablob, payload, options);\n\tif (key_cmd < 0) {\n\t\tret = key_cmd;\n\t\tgoto out;\n\t}\n\n\tif (!options->keyhandle) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdump_payload(payload);\n\tdump_options(options);\n\n\tswitch (key_cmd) {\n\tcase Opt_load:\n\t\tif (tpm2)\n\t\t\tret = tpm_unseal_trusted(TPM_ANY_NUM, payload, options);\n\t\telse\n\t\t\tret = key_unseal(payload, options);\n\t\tdump_payload(payload);\n\t\tdump_options(options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_unseal failed (%d)\\n\", ret);\n\t\tbreak;\n\tcase Opt_new:\n\t\tkey_len = payload->key_len;\n\t\tret = tpm_get_random(TPM_ANY_NUM, payload->key, key_len);\n\t\tif (ret != key_len) {\n\t\t\tpr_info(\"trusted_key: key_create failed (%d)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (tpm2)\n\t\t\tret = tpm_seal_trusted(TPM_ANY_NUM, payload, options);\n\t\telse\n\t\t\tret = key_seal(payload, options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!ret && options->pcrlock)\n\t\tret = pcrlock(options->pcrlock);\nout:\n\tkzfree(datablob);\n\tkzfree(options);\n\tif (!ret)\n\t\trcu_assign_keypointer(key, payload);\n\telse\n\t\tkzfree(payload);\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "payload"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_keypointer",
          "args": [
            "key",
            "payload"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "options"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "datablob"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcrlock",
          "args": [
            "options->pcrlock"
          ],
          "line": 1038
        },
        "resolved": true,
        "details": {
          "function_name": "pcrlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "378-389",
          "snippet": "static int pcrlock(const int pcrnum)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\n\tif (ret != SHA1_DIGEST_SIZE)\n\t\treturn ret;\n\treturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int pcrlock(const int pcrnum)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\n\tif (ret != SHA1_DIGEST_SIZE)\n\t\treturn ret;\n\treturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: key_seal failed (%d)\\n\"",
            "ret"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_seal",
          "args": [
            "payload",
            "options"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "key_seal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "662-683",
          "snippet": "static int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\t/* include migratable flag at end of sealed key */\n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkseal failed (%d)\\n\", ret);\n\n\tkzfree(tb);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\t/* include migratable flag at end of sealed key */\n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkseal failed (%d)\\n\", ret);\n\n\tkzfree(tb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tpm_seal_trusted",
          "args": [
            "TPM_ANY_NUM",
            "payload",
            "options"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: key_create failed (%d)\\n\"",
            "ret"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_get_random",
          "args": [
            "TPM_ANY_NUM",
            "payload->key",
            "key_len"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: key_unseal failed (%d)\\n\"",
            "ret"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_options",
          "args": [
            "options"
          ],
          "line": 1015
        },
        "resolved": true,
        "details": {
          "function_name": "dump_options",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "84-86",
          "snippet": "static inline void dump_options(struct trusted_key_options *o)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dump_options(struct trusted_key_options *o)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_payload",
          "args": [
            "payload"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "dump_payload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "88-90",
          "snippet": "static inline void dump_payload(struct trusted_key_payload *p)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dump_payload(struct trusted_key_payload *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_unseal",
          "args": [
            "payload",
            "options"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "key_unseal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "688-708",
          "snippet": "static int key_unseal(struct trusted_key_payload *p,\n\t\t      struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = tpm_unseal(tb, o->keyhandle, o->keyauth, p->blob, p->blob_len,\n\t\t\t o->blobauth, p->key, &p->key_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkunseal failed (%d)\\n\", ret);\n\telse\n\t\t/* pull migratable flag out of sealed key */\n\t\tp->migratable = p->key[--p->key_len];\n\n\tkzfree(tb);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int key_unseal(struct trusted_key_payload *p,\n\t\t      struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = tpm_unseal(tb, o->keyhandle, o->keyauth, p->blob, p->blob_len,\n\t\t\t o->blobauth, p->key, &p->key_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkunseal failed (%d)\\n\", ret);\n\telse\n\t\t/* pull migratable flag out of sealed key */\n\t\tp->migratable = p->key[--p->key_len];\n\n\tkzfree(tb);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tpm_unseal_trusted",
          "args": [
            "TPM_ANY_NUM",
            "payload",
            "options"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "datablob_parse",
          "args": [
            "datablob",
            "payload",
            "options"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "datablob_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "856-913",
          "snippet": "static int datablob_parse(char *datablob, struct trusted_key_payload *p,\n\t\t\t  struct trusted_key_options *o)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t/* main command */\n\tc = strsep(&datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t/* first argument is key size */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t/* first argument is sealed blob */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\t/* all arguments are options */\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};\n\nstatic int datablob_parse(char *datablob, struct trusted_key_payload *p,\n\t\t\t  struct trusted_key_options *o)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t/* main command */\n\tc = strsep(&datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t/* first argument is key size */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t/* first argument is sealed blob */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\t/* all arguments are options */\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trusted_payload_alloc",
          "args": [
            "key"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "trusted_payload_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "935-947",
          "snippet": "static struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof *p);\n\tif (ret < 0)\n\t\treturn p;\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (p)\n\t\tp->migratable = 1; /* migratable by default */\n\treturn p;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof *p);\n\tif (ret < 0)\n\t\treturn p;\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (p)\n\t\tp->migratable = 1; /* migratable by default */\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trusted_options_alloc",
          "args": [],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "trusted_options_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "915-933",
          "snippet": "static struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn NULL;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t/* set any non-zero defaults */\n\t\toptions->keytype = SRK_keytype;\n\n\t\tif (!tpm2)\n\t\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn NULL;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t/* set any non-zero defaults */\n\t\toptions->keytype = SRK_keytype;\n\n\t\tif (!tpm2)\n\t\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "datablob",
            "prep->data",
            "datalen"
          ],
          "line": 980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "datalen + 1",
            "GFP_KERNEL"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_is_tpm2",
          "args": [
            "TPM_ANY_NUM"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int trusted_instantiate(struct key *key,\n\t\t\t       struct key_preparsed_payload *prep)\n{\n\tstruct trusted_key_payload *payload = NULL;\n\tstruct trusted_key_options *options = NULL;\n\tsize_t datalen = prep->datalen;\n\tchar *datablob;\n\tint ret = 0;\n\tint key_cmd;\n\tsize_t key_len;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\tif (datalen <= 0 || datalen > 32767 || !prep->data)\n\t\treturn -EINVAL;\n\n\tdatablob = kmalloc(datalen + 1, GFP_KERNEL);\n\tif (!datablob)\n\t\treturn -ENOMEM;\n\tmemcpy(datablob, prep->data, datalen);\n\tdatablob[datalen] = '\\0';\n\n\toptions = trusted_options_alloc();\n\tif (!options) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\tpayload = trusted_payload_alloc(key);\n\tif (!payload) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tkey_cmd = datablob_parse(datablob, payload, options);\n\tif (key_cmd < 0) {\n\t\tret = key_cmd;\n\t\tgoto out;\n\t}\n\n\tif (!options->keyhandle) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdump_payload(payload);\n\tdump_options(options);\n\n\tswitch (key_cmd) {\n\tcase Opt_load:\n\t\tif (tpm2)\n\t\t\tret = tpm_unseal_trusted(TPM_ANY_NUM, payload, options);\n\t\telse\n\t\t\tret = key_unseal(payload, options);\n\t\tdump_payload(payload);\n\t\tdump_options(options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_unseal failed (%d)\\n\", ret);\n\t\tbreak;\n\tcase Opt_new:\n\t\tkey_len = payload->key_len;\n\t\tret = tpm_get_random(TPM_ANY_NUM, payload->key, key_len);\n\t\tif (ret != key_len) {\n\t\t\tpr_info(\"trusted_key: key_create failed (%d)\\n\", ret);\n\t\t\tgoto out;\n\t\t}\n\t\tif (tpm2)\n\t\t\tret = tpm_seal_trusted(TPM_ANY_NUM, payload, options);\n\t\telse\n\t\t\tret = key_seal(payload, options);\n\t\tif (ret < 0)\n\t\t\tpr_info(\"trusted_key: key_seal failed (%d)\\n\", ret);\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tif (!ret && options->pcrlock)\n\t\tret = pcrlock(options->pcrlock);\nout:\n\tkzfree(datablob);\n\tkzfree(options);\n\tif (!ret)\n\t\trcu_assign_keypointer(key, payload);\n\telse\n\t\tkzfree(payload);\n\treturn ret;\n}"
  },
  {
    "function_name": "trusted_payload_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "935-947",
    "snippet": "static struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof *p);\n\tif (ret < 0)\n\t\treturn p;\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (p)\n\t\tp->migratable = 1; /* migratable by default */\n\treturn p;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof *p",
            "GFP_KERNEL"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_payload_reserve",
          "args": [
            "key",
            "sizeof *p"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "key_payload_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "370-401",
          "snippet": "int key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned int key_quota_root_maxbytes = 25000000;",
            "unsigned int key_quota_maxbytes = 20000;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nunsigned int key_quota_root_maxbytes = 25000000;\nunsigned int key_quota_maxbytes = 20000;\n\nint key_payload_reserve(struct key *key, size_t datalen)\n{\n\tint delta = (int)datalen - key->datalen;\n\tint ret = 0;\n\n\tkey_check(key);\n\n\t/* contemplate the quota adjustment */\n\tif (delta != 0 && test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {\n\t\tunsigned maxbytes = uid_eq(key->user->uid, GLOBAL_ROOT_UID) ?\n\t\t\tkey_quota_root_maxbytes : key_quota_maxbytes;\n\n\t\tspin_lock(&key->user->lock);\n\n\t\tif (delta > 0 &&\n\t\t    (key->user->qnbytes + delta >= maxbytes ||\n\t\t     key->user->qnbytes + delta < key->user->qnbytes)) {\n\t\t\tret = -EDQUOT;\n\t\t}\n\t\telse {\n\t\t\tkey->user->qnbytes += delta;\n\t\t\tkey->quotalen += delta;\n\t\t}\n\t\tspin_unlock(&key->user->lock);\n\t}\n\n\t/* change the recorded data length if that didn't generate an error */\n\tif (ret == 0)\n\t\tkey->datalen = datalen;\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct trusted_key_payload *trusted_payload_alloc(struct key *key)\n{\n\tstruct trusted_key_payload *p = NULL;\n\tint ret;\n\n\tret = key_payload_reserve(key, sizeof *p);\n\tif (ret < 0)\n\t\treturn p;\n\tp = kzalloc(sizeof *p, GFP_KERNEL);\n\tif (p)\n\t\tp->migratable = 1; /* migratable by default */\n\treturn p;\n}"
  },
  {
    "function_name": "trusted_options_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "915-933",
    "snippet": "static struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn NULL;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t/* set any non-zero defaults */\n\t\toptions->keytype = SRK_keytype;\n\n\t\tif (!tpm2)\n\t\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof *options",
            "GFP_KERNEL"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_is_tpm2",
          "args": [
            "TPM_ANY_NUM"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct trusted_key_options *trusted_options_alloc(void)\n{\n\tstruct trusted_key_options *options;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn NULL;\n\n\toptions = kzalloc(sizeof *options, GFP_KERNEL);\n\tif (options) {\n\t\t/* set any non-zero defaults */\n\t\toptions->keytype = SRK_keytype;\n\n\t\tif (!tpm2)\n\t\t\toptions->keyhandle = SRKHANDLE;\n\t}\n\treturn options;\n}"
  },
  {
    "function_name": "datablob_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "856-913",
    "snippet": "static int datablob_parse(char *datablob, struct trusted_key_payload *p,\n\t\t\t  struct trusted_key_options *o)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t/* main command */\n\tc = strsep(&datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t/* first argument is key size */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t/* first argument is sealed blob */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\t/* all arguments are options */\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "getoptions",
          "args": [
            "datablob",
            "p",
            "o"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "getoptions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "737-848",
          "snippet": "static int getoptions(char *c, struct trusted_key_payload *pay,\n\t\t      struct trusted_key_options *opt)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p = c;\n\tint token;\n\tint res;\n\tunsigned long handle;\n\tunsigned long lock;\n\tunsigned long token_mask = 0;\n\tunsigned int digest_len;\n\tint i;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\topt->hash = tpm2 ? HASH_ALGO_SHA256 : HASH_ALGO_SHA1;\n\n\twhile ((p = strsep(&c, \" \\t\"))) {\n\t\tif (*p == '\\0' || *p == ' ' || *p == '\\t')\n\t\t\tcontinue;\n\t\ttoken = match_token(p, key_tokens, args);\n\t\tif (test_and_set_bit(token, &token_mask))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (token) {\n\t\tcase Opt_pcrinfo:\n\t\t\topt->pcrinfo_len = strlen(args[0].from) / 2;\n\t\t\tif (opt->pcrinfo_len > MAX_PCRINFO_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->pcrinfo, args[0].from,\n\t\t\t\t      opt->pcrinfo_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_keyhandle:\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->keytype = SEAL_keytype;\n\t\t\topt->keyhandle = handle;\n\t\t\tbreak;\n\t\tcase Opt_keyauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->keyauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_blobauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->blobauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_migratable:\n\t\t\tif (*args[0].from == '0')\n\t\t\t\tpay->migratable = 0;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_pcrlock:\n\t\t\tres = kstrtoul(args[0].from, 10, &lock);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->pcrlock = lock;\n\t\t\tbreak;\n\t\tcase Opt_hash:\n\t\t\tif (test_bit(Opt_policydigest, &token_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tfor (i = 0; i < HASH_ALGO__LAST; i++) {\n\t\t\t\tif (!strcmp(args[0].from, hash_algo_name[i])) {\n\t\t\t\t\topt->hash = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == HASH_ALGO__LAST)\n\t\t\t\treturn -EINVAL;\n\t\t\tif  (!tpm2 && i != HASH_ALGO_SHA1) {\n\t\t\t\tpr_info(\"trusted_key: TPM 1.x only supports SHA-1.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_policydigest:\n\t\t\tdigest_len = hash_digest_size[opt->hash];\n\t\t\tif (!tpm2 || strlen(args[0].from) != (2 * digest_len))\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->policydigest, args[0].from,\n\t\t\t\t      digest_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policydigest_len = digest_len;\n\t\t\tbreak;\n\t\tcase Opt_policyhandle:\n\t\t\tif (!tpm2)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policyhandle = handle;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};\n\nstatic int getoptions(char *c, struct trusted_key_payload *pay,\n\t\t      struct trusted_key_options *opt)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p = c;\n\tint token;\n\tint res;\n\tunsigned long handle;\n\tunsigned long lock;\n\tunsigned long token_mask = 0;\n\tunsigned int digest_len;\n\tint i;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\topt->hash = tpm2 ? HASH_ALGO_SHA256 : HASH_ALGO_SHA1;\n\n\twhile ((p = strsep(&c, \" \\t\"))) {\n\t\tif (*p == '\\0' || *p == ' ' || *p == '\\t')\n\t\t\tcontinue;\n\t\ttoken = match_token(p, key_tokens, args);\n\t\tif (test_and_set_bit(token, &token_mask))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (token) {\n\t\tcase Opt_pcrinfo:\n\t\t\topt->pcrinfo_len = strlen(args[0].from) / 2;\n\t\t\tif (opt->pcrinfo_len > MAX_PCRINFO_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->pcrinfo, args[0].from,\n\t\t\t\t      opt->pcrinfo_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_keyhandle:\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->keytype = SEAL_keytype;\n\t\t\topt->keyhandle = handle;\n\t\t\tbreak;\n\t\tcase Opt_keyauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->keyauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_blobauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->blobauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_migratable:\n\t\t\tif (*args[0].from == '0')\n\t\t\t\tpay->migratable = 0;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_pcrlock:\n\t\t\tres = kstrtoul(args[0].from, 10, &lock);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->pcrlock = lock;\n\t\t\tbreak;\n\t\tcase Opt_hash:\n\t\t\tif (test_bit(Opt_policydigest, &token_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tfor (i = 0; i < HASH_ALGO__LAST; i++) {\n\t\t\t\tif (!strcmp(args[0].from, hash_algo_name[i])) {\n\t\t\t\t\topt->hash = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == HASH_ALGO__LAST)\n\t\t\t\treturn -EINVAL;\n\t\t\tif  (!tpm2 && i != HASH_ALGO_SHA1) {\n\t\t\t\tpr_info(\"trusted_key: TPM 1.x only supports SHA-1.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_policydigest:\n\t\t\tdigest_len = hash_digest_size[opt->hash];\n\t\t\tif (!tpm2 || strlen(args[0].from) != (2 * digest_len))\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->policydigest, args[0].from,\n\t\t\t\t      digest_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policydigest_len = digest_len;\n\t\t\tbreak;\n\t\tcase Opt_policyhandle:\n\t\t\tif (!tpm2)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policyhandle = handle;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hex2bin",
          "args": [
            "p->blob",
            "c",
            "p->blob_len"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "c"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&datablob",
            "\" \\t\""
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtol",
          "args": [
            "c",
            "10",
            "&keylen"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&datablob",
            "\" \\t\""
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "c",
            "key_tokens",
            "args"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&datablob",
            "\" \\t\""
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};\n\nstatic int datablob_parse(char *datablob, struct trusted_key_payload *p,\n\t\t\t  struct trusted_key_options *o)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tlong keylen;\n\tint ret = -EINVAL;\n\tint key_cmd;\n\tchar *c;\n\n\t/* main command */\n\tc = strsep(&datablob, \" \\t\");\n\tif (!c)\n\t\treturn -EINVAL;\n\tkey_cmd = match_token(c, key_tokens, args);\n\tswitch (key_cmd) {\n\tcase Opt_new:\n\t\t/* first argument is key size */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tret = kstrtol(c, 10, &keylen);\n\t\tif (ret < 0 || keylen < MIN_KEY_SIZE || keylen > MAX_KEY_SIZE)\n\t\t\treturn -EINVAL;\n\t\tp->key_len = keylen;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_new;\n\t\tbreak;\n\tcase Opt_load:\n\t\t/* first argument is sealed blob */\n\t\tc = strsep(&datablob, \" \\t\");\n\t\tif (!c)\n\t\t\treturn -EINVAL;\n\t\tp->blob_len = strlen(c) / 2;\n\t\tif (p->blob_len > MAX_BLOB_SIZE)\n\t\t\treturn -EINVAL;\n\t\tret = hex2bin(p->blob, c, p->blob_len);\n\t\tif (ret < 0)\n\t\t\treturn -EINVAL;\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_load;\n\t\tbreak;\n\tcase Opt_update:\n\t\t/* all arguments are options */\n\t\tret = getoptions(datablob, p, o);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tret = Opt_update;\n\t\tbreak;\n\tcase Opt_err:\n\t\treturn -EINVAL;\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "getoptions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "737-848",
    "snippet": "static int getoptions(char *c, struct trusted_key_payload *pay,\n\t\t      struct trusted_key_options *opt)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p = c;\n\tint token;\n\tint res;\n\tunsigned long handle;\n\tunsigned long lock;\n\tunsigned long token_mask = 0;\n\tunsigned int digest_len;\n\tint i;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\topt->hash = tpm2 ? HASH_ALGO_SHA256 : HASH_ALGO_SHA1;\n\n\twhile ((p = strsep(&c, \" \\t\"))) {\n\t\tif (*p == '\\0' || *p == ' ' || *p == '\\t')\n\t\t\tcontinue;\n\t\ttoken = match_token(p, key_tokens, args);\n\t\tif (test_and_set_bit(token, &token_mask))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (token) {\n\t\tcase Opt_pcrinfo:\n\t\t\topt->pcrinfo_len = strlen(args[0].from) / 2;\n\t\t\tif (opt->pcrinfo_len > MAX_PCRINFO_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->pcrinfo, args[0].from,\n\t\t\t\t      opt->pcrinfo_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_keyhandle:\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->keytype = SEAL_keytype;\n\t\t\topt->keyhandle = handle;\n\t\t\tbreak;\n\t\tcase Opt_keyauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->keyauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_blobauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->blobauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_migratable:\n\t\t\tif (*args[0].from == '0')\n\t\t\t\tpay->migratable = 0;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_pcrlock:\n\t\t\tres = kstrtoul(args[0].from, 10, &lock);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->pcrlock = lock;\n\t\t\tbreak;\n\t\tcase Opt_hash:\n\t\t\tif (test_bit(Opt_policydigest, &token_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tfor (i = 0; i < HASH_ALGO__LAST; i++) {\n\t\t\t\tif (!strcmp(args[0].from, hash_algo_name[i])) {\n\t\t\t\t\topt->hash = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == HASH_ALGO__LAST)\n\t\t\t\treturn -EINVAL;\n\t\t\tif  (!tpm2 && i != HASH_ALGO_SHA1) {\n\t\t\t\tpr_info(\"trusted_key: TPM 1.x only supports SHA-1.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_policydigest:\n\t\t\tdigest_len = hash_digest_size[opt->hash];\n\t\t\tif (!tpm2 || strlen(args[0].from) != (2 * digest_len))\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->policydigest, args[0].from,\n\t\t\t\t      digest_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policydigest_len = digest_len;\n\t\t\tbreak;\n\t\tcase Opt_policyhandle:\n\t\t\tif (!tpm2)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policyhandle = handle;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "args[0].from",
            "16",
            "&handle"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex2bin",
          "args": [
            "opt->policydigest",
            "args[0].from",
            "digest_len"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "args[0].from"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: TPM 1.x only supports SHA-1.\\n\""
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "args[0].from",
            "hash_algo_name[i]"
          ],
          "line": 813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_bit",
          "args": [
            "Opt_policydigest",
            "&token_mask"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "args[0].from",
            "10",
            "&lock"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex2bin",
          "args": [
            "opt->blobauth",
            "args[0].from",
            "SHA1_DIGEST_SIZE"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "args[0].from"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex2bin",
          "args": [
            "opt->keyauth",
            "args[0].from",
            "SHA1_DIGEST_SIZE"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "args[0].from"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "args[0].from",
            "16",
            "&handle"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hex2bin",
          "args": [
            "opt->pcrinfo",
            "args[0].from",
            "opt->pcrinfo_len"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "args[0].from"
          ],
          "line": 766
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_and_set_bit",
          "args": [
            "token",
            "&token_mask"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_token",
          "args": [
            "p",
            "key_tokens",
            "args"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&c",
            "\" \\t\""
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_is_tpm2",
          "args": [
            "TPM_ANY_NUM"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const match_table_t key_tokens = {\n\t{Opt_new, \"new\"},\n\t{Opt_load, \"load\"},\n\t{Opt_update, \"update\"},\n\t{Opt_keyhandle, \"keyhandle=%s\"},\n\t{Opt_keyauth, \"keyauth=%s\"},\n\t{Opt_blobauth, \"blobauth=%s\"},\n\t{Opt_pcrinfo, \"pcrinfo=%s\"},\n\t{Opt_pcrlock, \"pcrlock=%s\"},\n\t{Opt_migratable, \"migratable=%s\"},\n\t{Opt_hash, \"hash=%s\"},\n\t{Opt_policydigest, \"policydigest=%s\"},\n\t{Opt_policyhandle, \"policyhandle=%s\"},\n\t{Opt_err, NULL}\n};\n\nstatic int getoptions(char *c, struct trusted_key_payload *pay,\n\t\t      struct trusted_key_options *opt)\n{\n\tsubstring_t args[MAX_OPT_ARGS];\n\tchar *p = c;\n\tint token;\n\tint res;\n\tunsigned long handle;\n\tunsigned long lock;\n\tunsigned long token_mask = 0;\n\tunsigned int digest_len;\n\tint i;\n\tint tpm2;\n\n\ttpm2 = tpm_is_tpm2(TPM_ANY_NUM);\n\tif (tpm2 < 0)\n\t\treturn tpm2;\n\n\topt->hash = tpm2 ? HASH_ALGO_SHA256 : HASH_ALGO_SHA1;\n\n\twhile ((p = strsep(&c, \" \\t\"))) {\n\t\tif (*p == '\\0' || *p == ' ' || *p == '\\t')\n\t\t\tcontinue;\n\t\ttoken = match_token(p, key_tokens, args);\n\t\tif (test_and_set_bit(token, &token_mask))\n\t\t\treturn -EINVAL;\n\n\t\tswitch (token) {\n\t\tcase Opt_pcrinfo:\n\t\t\topt->pcrinfo_len = strlen(args[0].from) / 2;\n\t\t\tif (opt->pcrinfo_len > MAX_PCRINFO_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->pcrinfo, args[0].from,\n\t\t\t\t      opt->pcrinfo_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_keyhandle:\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->keytype = SEAL_keytype;\n\t\t\topt->keyhandle = handle;\n\t\t\tbreak;\n\t\tcase Opt_keyauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->keyauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_blobauth:\n\t\t\tif (strlen(args[0].from) != 2 * SHA1_DIGEST_SIZE)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->blobauth, args[0].from,\n\t\t\t\t      SHA1_DIGEST_SIZE);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_migratable:\n\t\t\tif (*args[0].from == '0')\n\t\t\t\tpay->migratable = 0;\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase Opt_pcrlock:\n\t\t\tres = kstrtoul(args[0].from, 10, &lock);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->pcrlock = lock;\n\t\t\tbreak;\n\t\tcase Opt_hash:\n\t\t\tif (test_bit(Opt_policydigest, &token_mask))\n\t\t\t\treturn -EINVAL;\n\t\t\tfor (i = 0; i < HASH_ALGO__LAST; i++) {\n\t\t\t\tif (!strcmp(args[0].from, hash_algo_name[i])) {\n\t\t\t\t\topt->hash = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == HASH_ALGO__LAST)\n\t\t\t\treturn -EINVAL;\n\t\t\tif  (!tpm2 && i != HASH_ALGO_SHA1) {\n\t\t\t\tpr_info(\"trusted_key: TPM 1.x only supports SHA-1.\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase Opt_policydigest:\n\t\t\tdigest_len = hash_digest_size[opt->hash];\n\t\t\tif (!tpm2 || strlen(args[0].from) != (2 * digest_len))\n\t\t\t\treturn -EINVAL;\n\t\t\tres = hex2bin(opt->policydigest, args[0].from,\n\t\t\t\t      digest_len);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policydigest_len = digest_len;\n\t\t\tbreak;\n\t\tcase Opt_policyhandle:\n\t\t\tif (!tpm2)\n\t\t\t\treturn -EINVAL;\n\t\t\tres = kstrtoul(args[0].from, 16, &handle);\n\t\t\tif (res < 0)\n\t\t\t\treturn -EINVAL;\n\t\t\topt->policyhandle = handle;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "key_unseal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "688-708",
    "snippet": "static int key_unseal(struct trusted_key_payload *p,\n\t\t      struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = tpm_unseal(tb, o->keyhandle, o->keyauth, p->blob, p->blob_len,\n\t\t\t o->blobauth, p->key, &p->key_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkunseal failed (%d)\\n\", ret);\n\telse\n\t\t/* pull migratable flag out of sealed key */\n\t\tp->migratable = p->key[--p->key_len];\n\n\tkzfree(tb);\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "tb"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: srkunseal failed (%d)\\n\"",
            "ret"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_unseal",
          "args": [
            "tb",
            "o->keyhandle",
            "o->keyauth",
            "p->blob",
            "p->blob_len",
            "o->blobauth",
            "p->key",
            "&p->key_len"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "tpm_unseal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "574-657",
          "snippet": "static int tpm_unseal(struct tpm_buf *tb,\n\t\t      uint32_t keyhandle, const unsigned char *keyauth,\n\t\t      const unsigned char *blob, int bloblen,\n\t\t      const unsigned char *blobauth,\n\t\t      unsigned char *data, unsigned int *datalen)\n{\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char enonce1[TPM_NONCE_SIZE];\n\tunsigned char enonce2[TPM_NONCE_SIZE];\n\tunsigned char authdata1[SHA1_DIGEST_SIZE];\n\tunsigned char authdata2[SHA1_DIGEST_SIZE];\n\tuint32_t authhandle1 = 0;\n\tuint32_t authhandle2 = 0;\n\tunsigned char cont = 0;\n\tuint32_t ordinal;\n\tuint32_t keyhndl;\n\tint ret;\n\n\t/* sessions for unsealing key and data */\n\tret = oiap(tb, &authhandle1, enonce1);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = oiap(tb, &authhandle2, enonce2);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tordinal = htonl(TPM_ORD_UNSEAL);\n\tkeyhndl = htonl(SRKHANDLE);\n\tret = tpm_get_random(TPM_ANY_NUM, nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE) {\n\t\tpr_info(\"trusted_key: tpm_get_random failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = TSS_authhmac(authdata1, keyauth, TPM_NONCE_SIZE,\n\t\t\t   enonce1, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = TSS_authhmac(authdata2, blobauth, TPM_NONCE_SIZE,\n\t\t\t   enonce2, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* build and send TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH2_COMMAND);\n\tstore32(tb, TPM_UNSEAL_SIZE + bloblen);\n\tstore32(tb, TPM_ORD_UNSEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, blob, bloblen);\n\tstore32(tb, authhandle1);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata1, SHA1_DIGEST_SIZE);\n\tstore32(tb, authhandle2);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata2, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: authhmac failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*datalen = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tret = TSS_checkhmac2(tb->data, ordinal, nonceodd,\n\t\t\t     keyauth, SHA1_DIGEST_SIZE,\n\t\t\t     blobauth, SHA1_DIGEST_SIZE,\n\t\t\t     sizeof(uint32_t), TPM_DATA_OFFSET,\n\t\t\t     *datalen, TPM_DATA_OFFSET + sizeof(uint32_t), 0,\n\t\t\t     0);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: TSS_checkhmac2 failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(data, tb->data + TPM_DATA_OFFSET + sizeof(uint32_t), *datalen);\n\treturn 0;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int tpm_unseal(struct tpm_buf *tb,\n\t\t      uint32_t keyhandle, const unsigned char *keyauth,\n\t\t      const unsigned char *blob, int bloblen,\n\t\t      const unsigned char *blobauth,\n\t\t      unsigned char *data, unsigned int *datalen)\n{\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char enonce1[TPM_NONCE_SIZE];\n\tunsigned char enonce2[TPM_NONCE_SIZE];\n\tunsigned char authdata1[SHA1_DIGEST_SIZE];\n\tunsigned char authdata2[SHA1_DIGEST_SIZE];\n\tuint32_t authhandle1 = 0;\n\tuint32_t authhandle2 = 0;\n\tunsigned char cont = 0;\n\tuint32_t ordinal;\n\tuint32_t keyhndl;\n\tint ret;\n\n\t/* sessions for unsealing key and data */\n\tret = oiap(tb, &authhandle1, enonce1);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = oiap(tb, &authhandle2, enonce2);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tordinal = htonl(TPM_ORD_UNSEAL);\n\tkeyhndl = htonl(SRKHANDLE);\n\tret = tpm_get_random(TPM_ANY_NUM, nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE) {\n\t\tpr_info(\"trusted_key: tpm_get_random failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = TSS_authhmac(authdata1, keyauth, TPM_NONCE_SIZE,\n\t\t\t   enonce1, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = TSS_authhmac(authdata2, blobauth, TPM_NONCE_SIZE,\n\t\t\t   enonce2, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* build and send TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH2_COMMAND);\n\tstore32(tb, TPM_UNSEAL_SIZE + bloblen);\n\tstore32(tb, TPM_ORD_UNSEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, blob, bloblen);\n\tstore32(tb, authhandle1);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata1, SHA1_DIGEST_SIZE);\n\tstore32(tb, authhandle2);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata2, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: authhmac failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*datalen = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tret = TSS_checkhmac2(tb->data, ordinal, nonceodd,\n\t\t\t     keyauth, SHA1_DIGEST_SIZE,\n\t\t\t     blobauth, SHA1_DIGEST_SIZE,\n\t\t\t     sizeof(uint32_t), TPM_DATA_OFFSET,\n\t\t\t     *datalen, TPM_DATA_OFFSET + sizeof(uint32_t), 0,\n\t\t\t     0);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: TSS_checkhmac2 failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(data, tb->data + TPM_DATA_OFFSET + sizeof(uint32_t), *datalen);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof *tb",
            "GFP_KERNEL"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int key_unseal(struct trusted_key_payload *p,\n\t\t      struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\tret = tpm_unseal(tb, o->keyhandle, o->keyauth, p->blob, p->blob_len,\n\t\t\t o->blobauth, p->key, &p->key_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkunseal failed (%d)\\n\", ret);\n\telse\n\t\t/* pull migratable flag out of sealed key */\n\t\tp->migratable = p->key[--p->key_len];\n\n\tkzfree(tb);\n\treturn ret;\n}"
  },
  {
    "function_name": "key_seal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "662-683",
    "snippet": "static int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\t/* include migratable flag at end of sealed key */\n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkseal failed (%d)\\n\", ret);\n\n\tkzfree(tb);\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "tb"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: srkseal failed (%d)\\n\"",
            "ret"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_seal",
          "args": [
            "tb",
            "o->keytype",
            "o->keyhandle",
            "o->keyauth",
            "p->key",
            "p->key_len + 1",
            "p->blob",
            "&p->blob_len",
            "o->blobauth",
            "o->pcrinfo",
            "o->pcrinfo_len"
          ],
          "line": 675
        },
        "resolved": true,
        "details": {
          "function_name": "tpm_seal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "459-569",
          "snippet": "static int tpm_seal(struct tpm_buf *tb, uint16_t keytype,\n\t\t    uint32_t keyhandle, const unsigned char *keyauth,\n\t\t    const unsigned char *data, uint32_t datalen,\n\t\t    unsigned char *blob, uint32_t *bloblen,\n\t\t    const unsigned char *blobauth,\n\t\t    const unsigned char *pcrinfo, uint32_t pcrinfosize)\n{\n\tstruct osapsess sess;\n\tstruct tpm_digests *td;\n\tunsigned char cont;\n\tuint32_t ordinal;\n\tuint32_t pcrsize;\n\tuint32_t datsize;\n\tint sealinfosize;\n\tint encdatasize;\n\tint storedsize;\n\tint ret;\n\tint i;\n\n\t/* alloc some work space for all the hashes */\n\ttd = kmalloc(sizeof *td, GFP_KERNEL);\n\tif (!td)\n\t\treturn -ENOMEM;\n\n\t/* get session for sealing key */\n\tret = osap(tb, &sess, keyauth, keytype, keyhandle);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_sess(&sess);\n\n\t/* calculate encrypted authorization value */\n\tmemcpy(td->xorwork, sess.secret, SHA1_DIGEST_SIZE);\n\tmemcpy(td->xorwork + SHA1_DIGEST_SIZE, sess.enonce, SHA1_DIGEST_SIZE);\n\tret = TSS_sha1(td->xorwork, SHA1_DIGEST_SIZE * 2, td->xorhash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = tpm_get_random(TPM_ANY_NUM, td->nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\tgoto out;\n\tordinal = htonl(TPM_ORD_SEAL);\n\tdatsize = htonl(datalen);\n\tpcrsize = htonl(pcrinfosize);\n\tcont = 0;\n\n\t/* encrypt data authorization key */\n\tfor (i = 0; i < SHA1_DIGEST_SIZE; ++i)\n\t\ttd->encauth[i] = td->xorhash[i] ^ blobauth[i];\n\n\t/* calculate authorization HMAC value */\n\tif (pcrinfosize == 0) {\n\t\t/* no pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   sizeof(uint32_t), &datsize, datalen, data, 0,\n\t\t\t\t   0);\n\t} else {\n\t\t/* pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   pcrinfosize, pcrinfo, sizeof(uint32_t),\n\t\t\t\t   &datsize, datalen, data, 0, 0);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* build and send the TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH1_COMMAND);\n\tstore32(tb, TPM_SEAL_SIZE + pcrinfosize + datalen);\n\tstore32(tb, TPM_ORD_SEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, td->encauth, SHA1_DIGEST_SIZE);\n\tstore32(tb, pcrinfosize);\n\tstorebytes(tb, pcrinfo, pcrinfosize);\n\tstore32(tb, datalen);\n\tstorebytes(tb, data, datalen);\n\tstore32(tb, sess.handle);\n\tstorebytes(tb, td->nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, td->pubauth, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* calculate the size of the returned Blob */\n\tsealinfosize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t));\n\tencdatasize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t     sizeof(uint32_t) + sealinfosize);\n\tstoredsize = sizeof(uint32_t) + sizeof(uint32_t) + sealinfosize +\n\t    sizeof(uint32_t) + encdatasize;\n\n\t/* check the HMAC in the response */\n\tret = TSS_checkhmac1(tb->data, ordinal, td->nonceodd, sess.secret,\n\t\t\t     SHA1_DIGEST_SIZE, storedsize, TPM_DATA_OFFSET, 0,\n\t\t\t     0);\n\n\t/* copy the returned blob to caller */\n\tif (!ret) {\n\t\tmemcpy(blob, tb->data + TPM_DATA_OFFSET, storedsize);\n\t\t*bloblen = storedsize;\n\t}\nout:\n\tkzfree(td);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int tpm_seal(struct tpm_buf *tb, uint16_t keytype,\n\t\t    uint32_t keyhandle, const unsigned char *keyauth,\n\t\t    const unsigned char *data, uint32_t datalen,\n\t\t    unsigned char *blob, uint32_t *bloblen,\n\t\t    const unsigned char *blobauth,\n\t\t    const unsigned char *pcrinfo, uint32_t pcrinfosize)\n{\n\tstruct osapsess sess;\n\tstruct tpm_digests *td;\n\tunsigned char cont;\n\tuint32_t ordinal;\n\tuint32_t pcrsize;\n\tuint32_t datsize;\n\tint sealinfosize;\n\tint encdatasize;\n\tint storedsize;\n\tint ret;\n\tint i;\n\n\t/* alloc some work space for all the hashes */\n\ttd = kmalloc(sizeof *td, GFP_KERNEL);\n\tif (!td)\n\t\treturn -ENOMEM;\n\n\t/* get session for sealing key */\n\tret = osap(tb, &sess, keyauth, keytype, keyhandle);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_sess(&sess);\n\n\t/* calculate encrypted authorization value */\n\tmemcpy(td->xorwork, sess.secret, SHA1_DIGEST_SIZE);\n\tmemcpy(td->xorwork + SHA1_DIGEST_SIZE, sess.enonce, SHA1_DIGEST_SIZE);\n\tret = TSS_sha1(td->xorwork, SHA1_DIGEST_SIZE * 2, td->xorhash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = tpm_get_random(TPM_ANY_NUM, td->nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\tgoto out;\n\tordinal = htonl(TPM_ORD_SEAL);\n\tdatsize = htonl(datalen);\n\tpcrsize = htonl(pcrinfosize);\n\tcont = 0;\n\n\t/* encrypt data authorization key */\n\tfor (i = 0; i < SHA1_DIGEST_SIZE; ++i)\n\t\ttd->encauth[i] = td->xorhash[i] ^ blobauth[i];\n\n\t/* calculate authorization HMAC value */\n\tif (pcrinfosize == 0) {\n\t\t/* no pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   sizeof(uint32_t), &datsize, datalen, data, 0,\n\t\t\t\t   0);\n\t} else {\n\t\t/* pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   pcrinfosize, pcrinfo, sizeof(uint32_t),\n\t\t\t\t   &datsize, datalen, data, 0, 0);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* build and send the TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH1_COMMAND);\n\tstore32(tb, TPM_SEAL_SIZE + pcrinfosize + datalen);\n\tstore32(tb, TPM_ORD_SEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, td->encauth, SHA1_DIGEST_SIZE);\n\tstore32(tb, pcrinfosize);\n\tstorebytes(tb, pcrinfo, pcrinfosize);\n\tstore32(tb, datalen);\n\tstorebytes(tb, data, datalen);\n\tstore32(tb, sess.handle);\n\tstorebytes(tb, td->nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, td->pubauth, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* calculate the size of the returned Blob */\n\tsealinfosize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t));\n\tencdatasize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t     sizeof(uint32_t) + sealinfosize);\n\tstoredsize = sizeof(uint32_t) + sizeof(uint32_t) + sealinfosize +\n\t    sizeof(uint32_t) + encdatasize;\n\n\t/* check the HMAC in the response */\n\tret = TSS_checkhmac1(tb->data, ordinal, td->nonceodd, sess.secret,\n\t\t\t     SHA1_DIGEST_SIZE, storedsize, TPM_DATA_OFFSET, 0,\n\t\t\t     0);\n\n\t/* copy the returned blob to caller */\n\tif (!ret) {\n\t\tmemcpy(blob, tb->data + TPM_DATA_OFFSET, storedsize);\n\t\t*bloblen = storedsize;\n\t}\nout:\n\tkzfree(td);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof *tb",
            "GFP_KERNEL"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int key_seal(struct trusted_key_payload *p,\n\t\t    struct trusted_key_options *o)\n{\n\tstruct tpm_buf *tb;\n\tint ret;\n\n\ttb = kzalloc(sizeof *tb, GFP_KERNEL);\n\tif (!tb)\n\t\treturn -ENOMEM;\n\n\t/* include migratable flag at end of sealed key */\n\tp->key[p->key_len] = p->migratable;\n\n\tret = tpm_seal(tb, o->keytype, o->keyhandle, o->keyauth,\n\t\t       p->key, p->key_len + 1, p->blob, &p->blob_len,\n\t\t       o->blobauth, o->pcrinfo, o->pcrinfo_len);\n\tif (ret < 0)\n\t\tpr_info(\"trusted_key: srkseal failed (%d)\\n\", ret);\n\n\tkzfree(tb);\n\treturn ret;\n}"
  },
  {
    "function_name": "tpm_unseal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "574-657",
    "snippet": "static int tpm_unseal(struct tpm_buf *tb,\n\t\t      uint32_t keyhandle, const unsigned char *keyauth,\n\t\t      const unsigned char *blob, int bloblen,\n\t\t      const unsigned char *blobauth,\n\t\t      unsigned char *data, unsigned int *datalen)\n{\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char enonce1[TPM_NONCE_SIZE];\n\tunsigned char enonce2[TPM_NONCE_SIZE];\n\tunsigned char authdata1[SHA1_DIGEST_SIZE];\n\tunsigned char authdata2[SHA1_DIGEST_SIZE];\n\tuint32_t authhandle1 = 0;\n\tuint32_t authhandle2 = 0;\n\tunsigned char cont = 0;\n\tuint32_t ordinal;\n\tuint32_t keyhndl;\n\tint ret;\n\n\t/* sessions for unsealing key and data */\n\tret = oiap(tb, &authhandle1, enonce1);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = oiap(tb, &authhandle2, enonce2);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tordinal = htonl(TPM_ORD_UNSEAL);\n\tkeyhndl = htonl(SRKHANDLE);\n\tret = tpm_get_random(TPM_ANY_NUM, nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE) {\n\t\tpr_info(\"trusted_key: tpm_get_random failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = TSS_authhmac(authdata1, keyauth, TPM_NONCE_SIZE,\n\t\t\t   enonce1, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = TSS_authhmac(authdata2, blobauth, TPM_NONCE_SIZE,\n\t\t\t   enonce2, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* build and send TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH2_COMMAND);\n\tstore32(tb, TPM_UNSEAL_SIZE + bloblen);\n\tstore32(tb, TPM_ORD_UNSEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, blob, bloblen);\n\tstore32(tb, authhandle1);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata1, SHA1_DIGEST_SIZE);\n\tstore32(tb, authhandle2);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata2, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: authhmac failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*datalen = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tret = TSS_checkhmac2(tb->data, ordinal, nonceodd,\n\t\t\t     keyauth, SHA1_DIGEST_SIZE,\n\t\t\t     blobauth, SHA1_DIGEST_SIZE,\n\t\t\t     sizeof(uint32_t), TPM_DATA_OFFSET,\n\t\t\t     *datalen, TPM_DATA_OFFSET + sizeof(uint32_t), 0,\n\t\t\t     0);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: TSS_checkhmac2 failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(data, tb->data + TPM_DATA_OFFSET + sizeof(uint32_t), *datalen);\n\treturn 0;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "data",
            "tb->data + TPM_DATA_OFFSET + sizeof(uint32_t)",
            "*datalen"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: TSS_checkhmac2 failed (%d)\\n\"",
            "ret"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSS_checkhmac2",
          "args": [
            "tb->data",
            "ordinal",
            "nonceodd",
            "keyauth",
            "SHA1_DIGEST_SIZE",
            "blobauth",
            "SHA1_DIGEST_SIZE",
            "sizeof(uint32_t)",
            "TPM_DATA_OFFSET",
            "*datalen",
            "TPM_DATA_OFFSET + sizeof(uint32_t)",
            "0",
            "0"
          ],
          "line": 645
        },
        "resolved": true,
        "details": {
          "function_name": "TSS_checkhmac2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "256-352",
          "snippet": "static int TSS_checkhmac2(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key1,\n\t\t\t  unsigned int keylen1,\n\t\t\t  const unsigned char *key2,\n\t\t\t  unsigned int keylen2, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce1;\n\tunsigned char *continueflag1;\n\tunsigned char *authdata1;\n\tunsigned char *enonce2;\n\tunsigned char *continueflag2;\n\tunsigned char *authdata2;\n\tunsigned char testhmac1[SHA1_DIGEST_SIZE];\n\tunsigned char testhmac2[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH2_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata1 = buffer + bufsize - (SHA1_DIGEST_SIZE + 1\n\t\t\t+ SHA1_DIGEST_SIZE + SHA1_DIGEST_SIZE);\n\tauthdata2 = buffer + bufsize - (SHA1_DIGEST_SIZE);\n\tcontinueflag1 = authdata1 - 1;\n\tcontinueflag2 = authdata2 - 1;\n\tenonce1 = continueflag1 - TPM_NONCE_SIZE;\n\tenonce2 = continueflag2 - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen2);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac1, key1, keylen1, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce1,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag1, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac1, authdata1, SHA1_DIGEST_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = TSS_rawhmac(testhmac2, key2, keylen2, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce2,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag2, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hash_alg[] = \"sha1\";",
            "static struct crypto_shash *hashalg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hash_alg[] = \"sha1\";\nstatic struct crypto_shash *hashalg;\n\nstatic int TSS_checkhmac2(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key1,\n\t\t\t  unsigned int keylen1,\n\t\t\t  const unsigned char *key2,\n\t\t\t  unsigned int keylen2, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce1;\n\tunsigned char *continueflag1;\n\tunsigned char *authdata1;\n\tunsigned char *enonce2;\n\tunsigned char *continueflag2;\n\tunsigned char *authdata2;\n\tunsigned char testhmac1[SHA1_DIGEST_SIZE];\n\tunsigned char testhmac2[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH2_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata1 = buffer + bufsize - (SHA1_DIGEST_SIZE + 1\n\t\t\t+ SHA1_DIGEST_SIZE + SHA1_DIGEST_SIZE);\n\tauthdata2 = buffer + bufsize - (SHA1_DIGEST_SIZE);\n\tcontinueflag1 = authdata1 - 1;\n\tcontinueflag2 = authdata2 - 1;\n\tenonce1 = continueflag1 - TPM_NONCE_SIZE;\n\tenonce2 = continueflag2 - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen2);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac1, key1, keylen1, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce1,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag1, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac1, authdata1, SHA1_DIGEST_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = TSS_rawhmac(testhmac2, key2, keylen2, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce2,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag2, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOAD32",
          "args": [
            "tb->data",
            "TPM_DATA_OFFSET"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: authhmac failed (%d)\\n\"",
            "ret"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trusted_tpm_send",
          "args": [
            "TPM_ANY_NUM",
            "tb->data",
            "MAX_BUF_SIZE"
          ],
          "line": 638
        },
        "resolved": true,
        "details": {
          "function_name": "trusted_tpm_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "358-370",
          "snippet": "static int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storebytes",
          "args": [
            "tb",
            "authdata2",
            "SHA1_DIGEST_SIZE"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "storebytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "118-123",
          "snippet": "static inline void storebytes(struct tpm_buf *buf, const unsigned char *in,\n\t\t\t      const int len)\n{\n\tmemcpy(buf->data + buf->len, in, len);\n\tbuf->len += len;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void storebytes(struct tpm_buf *buf, const unsigned char *in,\n\t\t\t      const int len)\n{\n\tmemcpy(buf->data + buf->len, in, len);\n\tbuf->len += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store8",
          "args": [
            "tb",
            "cont"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "store8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "101-104",
          "snippet": "static inline void store8(struct tpm_buf *buf, const unsigned char value)\n{\n\tbuf->data[buf->len++] = value;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void store8(struct tpm_buf *buf, const unsigned char value)\n{\n\tbuf->data[buf->len++] = value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store32",
          "args": [
            "tb",
            "authhandle2"
          ],
          "line": 633
        },
        "resolved": true,
        "details": {
          "function_name": "store32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "112-116",
          "snippet": "static inline void store32(struct tpm_buf *buf, const uint32_t value)\n{\n\t*(uint32_t *) & buf->data[buf->len] = htonl(value);\n\tbuf->len += sizeof value;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void store32(struct tpm_buf *buf, const uint32_t value)\n{\n\t*(uint32_t *) & buf->data[buf->len] = htonl(value);\n\tbuf->len += sizeof value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store16",
          "args": [
            "tb",
            "TPM_TAG_RQU_AUTH2_COMMAND"
          ],
          "line": 624
        },
        "resolved": true,
        "details": {
          "function_name": "store16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "106-110",
          "snippet": "static inline void store16(struct tpm_buf *buf, const uint16_t value)\n{\n\t*(uint16_t *) & buf->data[buf->len] = htons(value);\n\tbuf->len += sizeof value;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void store16(struct tpm_buf *buf, const uint16_t value)\n{\n\t*(uint16_t *) & buf->data[buf->len] = htons(value);\n\tbuf->len += sizeof value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_BUF",
          "args": [
            "tb"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSS_authhmac",
          "args": [
            "authdata2",
            "blobauth",
            "TPM_NONCE_SIZE",
            "enonce2",
            "nonceodd",
            "cont",
            "sizeof(uint32_t)",
            "&ordinal",
            "bloblen",
            "blob",
            "0",
            "0"
          ],
          "line": 616
        },
        "resolved": true,
        "details": {
          "function_name": "TSS_authhmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "124-170",
          "snippet": "static int TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned char h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hash_alg[] = \"sha1\";",
            "static struct crypto_shash *hashalg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hash_alg[] = \"sha1\";\nstatic struct crypto_shash *hashalg;\n\nstatic int TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned char h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: tpm_get_random failed (%d)\\n\"",
            "ret"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_get_random",
          "args": [
            "TPM_ANY_NUM",
            "nonceodd",
            "TPM_NONCE_SIZE"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "SRKHANDLE"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "TPM_ORD_UNSEAL"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: oiap failed (%d)\\n\"",
            "ret"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "oiap",
          "args": [
            "tb",
            "&authhandle2",
            "enonce2"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "oiap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "429-445",
          "snippet": "static int oiap(struct tpm_buf *tb, uint32_t *handle, unsigned char *nonce)\n{\n\tint ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OIAP_SIZE);\n\tstore32(tb, TPM_ORD_OIAP);\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(nonce, &tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)],\n\t       TPM_NONCE_SIZE);\n\treturn 0;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int oiap(struct tpm_buf *tb, uint32_t *handle, unsigned char *nonce)\n{\n\tint ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OIAP_SIZE);\n\tstore32(tb, TPM_ORD_OIAP);\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(nonce, &tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)],\n\t       TPM_NONCE_SIZE);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: oiap failed (%d)\\n\"",
            "ret"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int tpm_unseal(struct tpm_buf *tb,\n\t\t      uint32_t keyhandle, const unsigned char *keyauth,\n\t\t      const unsigned char *blob, int bloblen,\n\t\t      const unsigned char *blobauth,\n\t\t      unsigned char *data, unsigned int *datalen)\n{\n\tunsigned char nonceodd[TPM_NONCE_SIZE];\n\tunsigned char enonce1[TPM_NONCE_SIZE];\n\tunsigned char enonce2[TPM_NONCE_SIZE];\n\tunsigned char authdata1[SHA1_DIGEST_SIZE];\n\tunsigned char authdata2[SHA1_DIGEST_SIZE];\n\tuint32_t authhandle1 = 0;\n\tuint32_t authhandle2 = 0;\n\tunsigned char cont = 0;\n\tuint32_t ordinal;\n\tuint32_t keyhndl;\n\tint ret;\n\n\t/* sessions for unsealing key and data */\n\tret = oiap(tb, &authhandle1, enonce1);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = oiap(tb, &authhandle2, enonce2);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: oiap failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\tordinal = htonl(TPM_ORD_UNSEAL);\n\tkeyhndl = htonl(SRKHANDLE);\n\tret = tpm_get_random(TPM_ANY_NUM, nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE) {\n\t\tpr_info(\"trusted_key: tpm_get_random failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tret = TSS_authhmac(authdata1, keyauth, TPM_NONCE_SIZE,\n\t\t\t   enonce1, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\tret = TSS_authhmac(authdata2, blobauth, TPM_NONCE_SIZE,\n\t\t\t   enonce2, nonceodd, cont, sizeof(uint32_t),\n\t\t\t   &ordinal, bloblen, blob, 0, 0);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t/* build and send TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH2_COMMAND);\n\tstore32(tb, TPM_UNSEAL_SIZE + bloblen);\n\tstore32(tb, TPM_ORD_UNSEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, blob, bloblen);\n\tstore32(tb, authhandle1);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata1, SHA1_DIGEST_SIZE);\n\tstore32(tb, authhandle2);\n\tstorebytes(tb, nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, authdata2, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: authhmac failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\n\t*datalen = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tret = TSS_checkhmac2(tb->data, ordinal, nonceodd,\n\t\t\t     keyauth, SHA1_DIGEST_SIZE,\n\t\t\t     blobauth, SHA1_DIGEST_SIZE,\n\t\t\t     sizeof(uint32_t), TPM_DATA_OFFSET,\n\t\t\t     *datalen, TPM_DATA_OFFSET + sizeof(uint32_t), 0,\n\t\t\t     0);\n\tif (ret < 0) {\n\t\tpr_info(\"trusted_key: TSS_checkhmac2 failed (%d)\\n\", ret);\n\t\treturn ret;\n\t}\n\tmemcpy(data, tb->data + TPM_DATA_OFFSET + sizeof(uint32_t), *datalen);\n\treturn 0;\n}"
  },
  {
    "function_name": "tpm_seal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "459-569",
    "snippet": "static int tpm_seal(struct tpm_buf *tb, uint16_t keytype,\n\t\t    uint32_t keyhandle, const unsigned char *keyauth,\n\t\t    const unsigned char *data, uint32_t datalen,\n\t\t    unsigned char *blob, uint32_t *bloblen,\n\t\t    const unsigned char *blobauth,\n\t\t    const unsigned char *pcrinfo, uint32_t pcrinfosize)\n{\n\tstruct osapsess sess;\n\tstruct tpm_digests *td;\n\tunsigned char cont;\n\tuint32_t ordinal;\n\tuint32_t pcrsize;\n\tuint32_t datsize;\n\tint sealinfosize;\n\tint encdatasize;\n\tint storedsize;\n\tint ret;\n\tint i;\n\n\t/* alloc some work space for all the hashes */\n\ttd = kmalloc(sizeof *td, GFP_KERNEL);\n\tif (!td)\n\t\treturn -ENOMEM;\n\n\t/* get session for sealing key */\n\tret = osap(tb, &sess, keyauth, keytype, keyhandle);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_sess(&sess);\n\n\t/* calculate encrypted authorization value */\n\tmemcpy(td->xorwork, sess.secret, SHA1_DIGEST_SIZE);\n\tmemcpy(td->xorwork + SHA1_DIGEST_SIZE, sess.enonce, SHA1_DIGEST_SIZE);\n\tret = TSS_sha1(td->xorwork, SHA1_DIGEST_SIZE * 2, td->xorhash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = tpm_get_random(TPM_ANY_NUM, td->nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\tgoto out;\n\tordinal = htonl(TPM_ORD_SEAL);\n\tdatsize = htonl(datalen);\n\tpcrsize = htonl(pcrinfosize);\n\tcont = 0;\n\n\t/* encrypt data authorization key */\n\tfor (i = 0; i < SHA1_DIGEST_SIZE; ++i)\n\t\ttd->encauth[i] = td->xorhash[i] ^ blobauth[i];\n\n\t/* calculate authorization HMAC value */\n\tif (pcrinfosize == 0) {\n\t\t/* no pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   sizeof(uint32_t), &datsize, datalen, data, 0,\n\t\t\t\t   0);\n\t} else {\n\t\t/* pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   pcrinfosize, pcrinfo, sizeof(uint32_t),\n\t\t\t\t   &datsize, datalen, data, 0, 0);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* build and send the TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH1_COMMAND);\n\tstore32(tb, TPM_SEAL_SIZE + pcrinfosize + datalen);\n\tstore32(tb, TPM_ORD_SEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, td->encauth, SHA1_DIGEST_SIZE);\n\tstore32(tb, pcrinfosize);\n\tstorebytes(tb, pcrinfo, pcrinfosize);\n\tstore32(tb, datalen);\n\tstorebytes(tb, data, datalen);\n\tstore32(tb, sess.handle);\n\tstorebytes(tb, td->nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, td->pubauth, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* calculate the size of the returned Blob */\n\tsealinfosize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t));\n\tencdatasize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t     sizeof(uint32_t) + sealinfosize);\n\tstoredsize = sizeof(uint32_t) + sizeof(uint32_t) + sealinfosize +\n\t    sizeof(uint32_t) + encdatasize;\n\n\t/* check the HMAC in the response */\n\tret = TSS_checkhmac1(tb->data, ordinal, td->nonceodd, sess.secret,\n\t\t\t     SHA1_DIGEST_SIZE, storedsize, TPM_DATA_OFFSET, 0,\n\t\t\t     0);\n\n\t/* copy the returned blob to caller */\n\tif (!ret) {\n\t\tmemcpy(blob, tb->data + TPM_DATA_OFFSET, storedsize);\n\t\t*bloblen = storedsize;\n\t}\nout:\n\tkzfree(td);\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "td"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "blob",
            "tb->data + TPM_DATA_OFFSET",
            "storedsize"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSS_checkhmac1",
          "args": [
            "tb->data",
            "ordinal",
            "td->nonceodd",
            "sess.secret",
            "SHA1_DIGEST_SIZE",
            "storedsize",
            "TPM_DATA_OFFSET",
            "0",
            "0"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "TSS_checkhmac1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "175-251",
          "snippet": "static int TSS_checkhmac1(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key,\n\t\t\t  unsigned int keylen, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce;\n\tunsigned char *continueflag;\n\tunsigned char *authdata;\n\tunsigned char testhmac[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH1_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata = buffer + bufsize - SHA1_DIGEST_SIZE;\n\tcontinueflag = authdata - 1;\n\tenonce = continueflag - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac, key, keylen, SHA1_DIGEST_SIZE, paramdigest,\n\t\t\t  TPM_NONCE_SIZE, enonce, TPM_NONCE_SIZE, ononce,\n\t\t\t  1, continueflag, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hash_alg[] = \"sha1\";",
            "static struct crypto_shash *hashalg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hash_alg[] = \"sha1\";\nstatic struct crypto_shash *hashalg;\n\nstatic int TSS_checkhmac1(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key,\n\t\t\t  unsigned int keylen, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce;\n\tunsigned char *continueflag;\n\tunsigned char *authdata;\n\tunsigned char testhmac[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH1_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata = buffer + bufsize - SHA1_DIGEST_SIZE;\n\tcontinueflag = authdata - 1;\n\tenonce = continueflag - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac, key, keylen, SHA1_DIGEST_SIZE, paramdigest,\n\t\t\t  TPM_NONCE_SIZE, enonce, TPM_NONCE_SIZE, ononce,\n\t\t\t  1, continueflag, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOAD32",
          "args": [
            "tb->data",
            "TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t     sizeof(uint32_t) + sealinfosize"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD32",
          "args": [
            "tb->data",
            "TPM_DATA_OFFSET + sizeof(uint32_t)"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trusted_tpm_send",
          "args": [
            "TPM_ANY_NUM",
            "tb->data",
            "MAX_BUF_SIZE"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "trusted_tpm_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "358-370",
          "snippet": "static int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storebytes",
          "args": [
            "tb",
            "td->pubauth",
            "SHA1_DIGEST_SIZE"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "storebytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "118-123",
          "snippet": "static inline void storebytes(struct tpm_buf *buf, const unsigned char *in,\n\t\t\t      const int len)\n{\n\tmemcpy(buf->data + buf->len, in, len);\n\tbuf->len += len;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void storebytes(struct tpm_buf *buf, const unsigned char *in,\n\t\t\t      const int len)\n{\n\tmemcpy(buf->data + buf->len, in, len);\n\tbuf->len += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store8",
          "args": [
            "tb",
            "cont"
          ],
          "line": 542
        },
        "resolved": true,
        "details": {
          "function_name": "store8",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "101-104",
          "snippet": "static inline void store8(struct tpm_buf *buf, const unsigned char value)\n{\n\tbuf->data[buf->len++] = value;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void store8(struct tpm_buf *buf, const unsigned char value)\n{\n\tbuf->data[buf->len++] = value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store32",
          "args": [
            "tb",
            "sess.handle"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "store32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "112-116",
          "snippet": "static inline void store32(struct tpm_buf *buf, const uint32_t value)\n{\n\t*(uint32_t *) & buf->data[buf->len] = htonl(value);\n\tbuf->len += sizeof value;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void store32(struct tpm_buf *buf, const uint32_t value)\n{\n\t*(uint32_t *) & buf->data[buf->len] = htonl(value);\n\tbuf->len += sizeof value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store16",
          "args": [
            "tb",
            "TPM_TAG_RQU_AUTH1_COMMAND"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "store16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "106-110",
          "snippet": "static inline void store16(struct tpm_buf *buf, const uint16_t value)\n{\n\t*(uint16_t *) & buf->data[buf->len] = htons(value);\n\tbuf->len += sizeof value;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void store16(struct tpm_buf *buf, const uint16_t value)\n{\n\t*(uint16_t *) & buf->data[buf->len] = htons(value);\n\tbuf->len += sizeof value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_BUF",
          "args": [
            "tb"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSS_authhmac",
          "args": [
            "td->pubauth",
            "sess.secret",
            "SHA1_DIGEST_SIZE",
            "sess.enonce",
            "td->nonceodd",
            "cont",
            "sizeof(uint32_t)",
            "&ordinal",
            "SHA1_DIGEST_SIZE",
            "td->encauth",
            "sizeof(uint32_t)",
            "&pcrsize",
            "pcrinfosize",
            "pcrinfo",
            "sizeof(uint32_t)",
            "&datsize",
            "datalen",
            "data",
            "0",
            "0"
          ],
          "line": 519
        },
        "resolved": true,
        "details": {
          "function_name": "TSS_authhmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "124-170",
          "snippet": "static int TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned char h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hash_alg[] = \"sha1\";",
            "static struct crypto_shash *hashalg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hash_alg[] = \"sha1\";\nstatic struct crypto_shash *hashalg;\n\nstatic int TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned char h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "pcrinfosize"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "datalen"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "htonl",
          "args": [
            "TPM_ORD_SEAL"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_get_random",
          "args": [
            "TPM_ANY_NUM",
            "td->nonceodd",
            "TPM_NONCE_SIZE"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSS_sha1",
          "args": [
            "td->xorwork",
            "SHA1_DIGEST_SIZE * 2",
            "td->xorhash"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "TSS_sha1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "60-75",
          "snippet": "static int TSS_sha1(const unsigned char *data, unsigned int datalen,\n\t\t    unsigned char *digest)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);\n\tkzfree(sdesc);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hash_alg[] = \"sha1\";",
            "static struct crypto_shash *hashalg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hash_alg[] = \"sha1\";\nstatic struct crypto_shash *hashalg;\n\nstatic int TSS_sha1(const unsigned char *data, unsigned int datalen,\n\t\t    unsigned char *digest)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);\n\tkzfree(sdesc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "td->xorwork + SHA1_DIGEST_SIZE",
            "sess.enonce",
            "SHA1_DIGEST_SIZE"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "td->xorwork",
            "sess.secret",
            "SHA1_DIGEST_SIZE"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_sess",
          "args": [
            "&sess"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "dump_sess",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "92-94",
          "snippet": "static inline void dump_sess(struct osapsess *s)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dump_sess(struct osapsess *s)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "osap",
          "args": [
            "tb",
            "&sess",
            "keyauth",
            "keytype",
            "keyhandle"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "osap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "394-424",
          "snippet": "static int osap(struct tpm_buf *tb, struct osapsess *s,\n\t\tconst unsigned char *key, uint16_t type, uint32_t handle)\n{\n\tunsigned char enonce[TPM_NONCE_SIZE];\n\tunsigned char ononce[TPM_NONCE_SIZE];\n\tint ret;\n\n\tret = tpm_get_random(TPM_ANY_NUM, ononce, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\treturn ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OSAP_SIZE);\n\tstore32(tb, TPM_ORD_OSAP);\n\tstore16(tb, type);\n\tstore32(tb, handle);\n\tstorebytes(tb, ononce, TPM_NONCE_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts->handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(s->enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]),\n\t       TPM_NONCE_SIZE);\n\tmemcpy(enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t\t  TPM_NONCE_SIZE]), TPM_NONCE_SIZE);\n\treturn TSS_rawhmac(s->secret, key, SHA1_DIGEST_SIZE, TPM_NONCE_SIZE,\n\t\t\t   enonce, TPM_NONCE_SIZE, ononce, 0, 0);\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int osap(struct tpm_buf *tb, struct osapsess *s,\n\t\tconst unsigned char *key, uint16_t type, uint32_t handle)\n{\n\tunsigned char enonce[TPM_NONCE_SIZE];\n\tunsigned char ononce[TPM_NONCE_SIZE];\n\tint ret;\n\n\tret = tpm_get_random(TPM_ANY_NUM, ononce, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\treturn ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OSAP_SIZE);\n\tstore32(tb, TPM_ORD_OSAP);\n\tstore16(tb, type);\n\tstore32(tb, handle);\n\tstorebytes(tb, ononce, TPM_NONCE_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts->handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(s->enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]),\n\t       TPM_NONCE_SIZE);\n\tmemcpy(enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t\t  TPM_NONCE_SIZE]), TPM_NONCE_SIZE);\n\treturn TSS_rawhmac(s->secret, key, SHA1_DIGEST_SIZE, TPM_NONCE_SIZE,\n\t\t\t   enonce, TPM_NONCE_SIZE, ononce, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof *td",
            "GFP_KERNEL"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int tpm_seal(struct tpm_buf *tb, uint16_t keytype,\n\t\t    uint32_t keyhandle, const unsigned char *keyauth,\n\t\t    const unsigned char *data, uint32_t datalen,\n\t\t    unsigned char *blob, uint32_t *bloblen,\n\t\t    const unsigned char *blobauth,\n\t\t    const unsigned char *pcrinfo, uint32_t pcrinfosize)\n{\n\tstruct osapsess sess;\n\tstruct tpm_digests *td;\n\tunsigned char cont;\n\tuint32_t ordinal;\n\tuint32_t pcrsize;\n\tuint32_t datsize;\n\tint sealinfosize;\n\tint encdatasize;\n\tint storedsize;\n\tint ret;\n\tint i;\n\n\t/* alloc some work space for all the hashes */\n\ttd = kmalloc(sizeof *td, GFP_KERNEL);\n\tif (!td)\n\t\treturn -ENOMEM;\n\n\t/* get session for sealing key */\n\tret = osap(tb, &sess, keyauth, keytype, keyhandle);\n\tif (ret < 0)\n\t\tgoto out;\n\tdump_sess(&sess);\n\n\t/* calculate encrypted authorization value */\n\tmemcpy(td->xorwork, sess.secret, SHA1_DIGEST_SIZE);\n\tmemcpy(td->xorwork + SHA1_DIGEST_SIZE, sess.enonce, SHA1_DIGEST_SIZE);\n\tret = TSS_sha1(td->xorwork, SHA1_DIGEST_SIZE * 2, td->xorhash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = tpm_get_random(TPM_ANY_NUM, td->nonceodd, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\tgoto out;\n\tordinal = htonl(TPM_ORD_SEAL);\n\tdatsize = htonl(datalen);\n\tpcrsize = htonl(pcrinfosize);\n\tcont = 0;\n\n\t/* encrypt data authorization key */\n\tfor (i = 0; i < SHA1_DIGEST_SIZE; ++i)\n\t\ttd->encauth[i] = td->xorhash[i] ^ blobauth[i];\n\n\t/* calculate authorization HMAC value */\n\tif (pcrinfosize == 0) {\n\t\t/* no pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   sizeof(uint32_t), &datsize, datalen, data, 0,\n\t\t\t\t   0);\n\t} else {\n\t\t/* pcr info specified */\n\t\tret = TSS_authhmac(td->pubauth, sess.secret, SHA1_DIGEST_SIZE,\n\t\t\t\t   sess.enonce, td->nonceodd, cont,\n\t\t\t\t   sizeof(uint32_t), &ordinal, SHA1_DIGEST_SIZE,\n\t\t\t\t   td->encauth, sizeof(uint32_t), &pcrsize,\n\t\t\t\t   pcrinfosize, pcrinfo, sizeof(uint32_t),\n\t\t\t\t   &datsize, datalen, data, 0, 0);\n\t}\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* build and send the TPM request packet */\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_AUTH1_COMMAND);\n\tstore32(tb, TPM_SEAL_SIZE + pcrinfosize + datalen);\n\tstore32(tb, TPM_ORD_SEAL);\n\tstore32(tb, keyhandle);\n\tstorebytes(tb, td->encauth, SHA1_DIGEST_SIZE);\n\tstore32(tb, pcrinfosize);\n\tstorebytes(tb, pcrinfo, pcrinfosize);\n\tstore32(tb, datalen);\n\tstorebytes(tb, data, datalen);\n\tstore32(tb, sess.handle);\n\tstorebytes(tb, td->nonceodd, TPM_NONCE_SIZE);\n\tstore8(tb, cont);\n\tstorebytes(tb, td->pubauth, SHA1_DIGEST_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\tgoto out;\n\n\t/* calculate the size of the returned Blob */\n\tsealinfosize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t));\n\tencdatasize = LOAD32(tb->data, TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t     sizeof(uint32_t) + sealinfosize);\n\tstoredsize = sizeof(uint32_t) + sizeof(uint32_t) + sealinfosize +\n\t    sizeof(uint32_t) + encdatasize;\n\n\t/* check the HMAC in the response */\n\tret = TSS_checkhmac1(tb->data, ordinal, td->nonceodd, sess.secret,\n\t\t\t     SHA1_DIGEST_SIZE, storedsize, TPM_DATA_OFFSET, 0,\n\t\t\t     0);\n\n\t/* copy the returned blob to caller */\n\tif (!ret) {\n\t\tmemcpy(blob, tb->data + TPM_DATA_OFFSET, storedsize);\n\t\t*bloblen = storedsize;\n\t}\nout:\n\tkzfree(td);\n\treturn ret;\n}"
  },
  {
    "function_name": "oiap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "429-445",
    "snippet": "static int oiap(struct tpm_buf *tb, uint32_t *handle, unsigned char *nonce)\n{\n\tint ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OIAP_SIZE);\n\tstore32(tb, TPM_ORD_OIAP);\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(nonce, &tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)],\n\t       TPM_NONCE_SIZE);\n\treturn 0;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "nonce",
            "&tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]",
            "TPM_NONCE_SIZE"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD32",
          "args": [
            "tb->data",
            "TPM_DATA_OFFSET"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trusted_tpm_send",
          "args": [
            "TPM_ANY_NUM",
            "tb->data",
            "MAX_BUF_SIZE"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "trusted_tpm_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "358-370",
          "snippet": "static int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store32",
          "args": [
            "tb",
            "TPM_ORD_OIAP"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "store32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "112-116",
          "snippet": "static inline void store32(struct tpm_buf *buf, const uint32_t value)\n{\n\t*(uint32_t *) & buf->data[buf->len] = htonl(value);\n\tbuf->len += sizeof value;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void store32(struct tpm_buf *buf, const uint32_t value)\n{\n\t*(uint32_t *) & buf->data[buf->len] = htonl(value);\n\tbuf->len += sizeof value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store16",
          "args": [
            "tb",
            "TPM_TAG_RQU_COMMAND"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "store16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "106-110",
          "snippet": "static inline void store16(struct tpm_buf *buf, const uint16_t value)\n{\n\t*(uint16_t *) & buf->data[buf->len] = htons(value);\n\tbuf->len += sizeof value;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void store16(struct tpm_buf *buf, const uint16_t value)\n{\n\t*(uint16_t *) & buf->data[buf->len] = htons(value);\n\tbuf->len += sizeof value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_BUF",
          "args": [
            "tb"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int oiap(struct tpm_buf *tb, uint32_t *handle, unsigned char *nonce)\n{\n\tint ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OIAP_SIZE);\n\tstore32(tb, TPM_ORD_OIAP);\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\t*handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(nonce, &tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)],\n\t       TPM_NONCE_SIZE);\n\treturn 0;\n}"
  },
  {
    "function_name": "osap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "394-424",
    "snippet": "static int osap(struct tpm_buf *tb, struct osapsess *s,\n\t\tconst unsigned char *key, uint16_t type, uint32_t handle)\n{\n\tunsigned char enonce[TPM_NONCE_SIZE];\n\tunsigned char ononce[TPM_NONCE_SIZE];\n\tint ret;\n\n\tret = tpm_get_random(TPM_ANY_NUM, ononce, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\treturn ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OSAP_SIZE);\n\tstore32(tb, TPM_ORD_OSAP);\n\tstore16(tb, type);\n\tstore32(tb, handle);\n\tstorebytes(tb, ononce, TPM_NONCE_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts->handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(s->enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]),\n\t       TPM_NONCE_SIZE);\n\tmemcpy(enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t\t  TPM_NONCE_SIZE]), TPM_NONCE_SIZE);\n\treturn TSS_rawhmac(s->secret, key, SHA1_DIGEST_SIZE, TPM_NONCE_SIZE,\n\t\t\t   enonce, TPM_NONCE_SIZE, ononce, 0, 0);\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "TSS_rawhmac",
          "args": [
            "s->secret",
            "key",
            "SHA1_DIGEST_SIZE",
            "TPM_NONCE_SIZE",
            "enonce",
            "TPM_NONCE_SIZE",
            "ononce",
            "0",
            "0"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "TSS_rawhmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "77-119",
          "snippet": "static int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hmac_alg[] = \"hmac(sha1)\";",
            "static struct crypto_shash *hmacalg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic struct crypto_shash *hmacalg;\n\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "enonce",
            "&(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t\t  TPM_NONCE_SIZE])",
            "TPM_NONCE_SIZE"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->enonce",
            "&(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)])",
            "TPM_NONCE_SIZE"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD32",
          "args": [
            "tb->data",
            "TPM_DATA_OFFSET"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trusted_tpm_send",
          "args": [
            "TPM_ANY_NUM",
            "tb->data",
            "MAX_BUF_SIZE"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "trusted_tpm_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "358-370",
          "snippet": "static int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "storebytes",
          "args": [
            "tb",
            "ononce",
            "TPM_NONCE_SIZE"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "storebytes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "118-123",
          "snippet": "static inline void storebytes(struct tpm_buf *buf, const unsigned char *in,\n\t\t\t      const int len)\n{\n\tmemcpy(buf->data + buf->len, in, len);\n\tbuf->len += len;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void storebytes(struct tpm_buf *buf, const unsigned char *in,\n\t\t\t      const int len)\n{\n\tmemcpy(buf->data + buf->len, in, len);\n\tbuf->len += len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store32",
          "args": [
            "tb",
            "handle"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "store32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "112-116",
          "snippet": "static inline void store32(struct tpm_buf *buf, const uint32_t value)\n{\n\t*(uint32_t *) & buf->data[buf->len] = htonl(value);\n\tbuf->len += sizeof value;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void store32(struct tpm_buf *buf, const uint32_t value)\n{\n\t*(uint32_t *) & buf->data[buf->len] = htonl(value);\n\tbuf->len += sizeof value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "store16",
          "args": [
            "tb",
            "type"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "store16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "106-110",
          "snippet": "static inline void store16(struct tpm_buf *buf, const uint16_t value)\n{\n\t*(uint16_t *) & buf->data[buf->len] = htons(value);\n\tbuf->len += sizeof value;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void store16(struct tpm_buf *buf, const uint16_t value)\n{\n\t*(uint16_t *) & buf->data[buf->len] = htons(value);\n\tbuf->len += sizeof value;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_BUF",
          "args": [
            "tb"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_get_random",
          "args": [
            "TPM_ANY_NUM",
            "ononce",
            "TPM_NONCE_SIZE"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int osap(struct tpm_buf *tb, struct osapsess *s,\n\t\tconst unsigned char *key, uint16_t type, uint32_t handle)\n{\n\tunsigned char enonce[TPM_NONCE_SIZE];\n\tunsigned char ononce[TPM_NONCE_SIZE];\n\tint ret;\n\n\tret = tpm_get_random(TPM_ANY_NUM, ononce, TPM_NONCE_SIZE);\n\tif (ret != TPM_NONCE_SIZE)\n\t\treturn ret;\n\n\tINIT_BUF(tb);\n\tstore16(tb, TPM_TAG_RQU_COMMAND);\n\tstore32(tb, TPM_OSAP_SIZE);\n\tstore32(tb, TPM_ORD_OSAP);\n\tstore16(tb, type);\n\tstore32(tb, handle);\n\tstorebytes(tb, ononce, TPM_NONCE_SIZE);\n\n\tret = trusted_tpm_send(TPM_ANY_NUM, tb->data, MAX_BUF_SIZE);\n\tif (ret < 0)\n\t\treturn ret;\n\n\ts->handle = LOAD32(tb->data, TPM_DATA_OFFSET);\n\tmemcpy(s->enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t)]),\n\t       TPM_NONCE_SIZE);\n\tmemcpy(enonce, &(tb->data[TPM_DATA_OFFSET + sizeof(uint32_t) +\n\t\t\t\t  TPM_NONCE_SIZE]), TPM_NONCE_SIZE);\n\treturn TSS_rawhmac(s->secret, key, SHA1_DIGEST_SIZE, TPM_NONCE_SIZE,\n\t\t\t   enonce, TPM_NONCE_SIZE, ononce, 0, 0);\n}"
  },
  {
    "function_name": "pcrlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "378-389",
    "snippet": "static int pcrlock(const int pcrnum)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\n\tif (ret != SHA1_DIGEST_SIZE)\n\t\treturn ret;\n\treturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tpm_pcr_extend",
          "args": [
            "TPM_ANY_NUM",
            "pcrnum",
            "hash"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tpm_get_random",
          "args": [
            "TPM_ANY_NUM",
            "hash",
            "SHA1_DIGEST_SIZE"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "policy_admin_capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/policy.c",
          "lines": "660-669",
          "snippet": "bool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}",
          "includes": [
            "#include \"include/resource.h\"",
            "#include \"include/policy_unpack.h\"",
            "#include \"include/policy_ns.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/path.h\"",
            "#include \"include/match.h\"",
            "#include \"include/ipc.h\"",
            "#include \"include/file.h\"",
            "#include \"include/context.h\"",
            "#include \"include/capability.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/user_namespace.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cred.h>",
            "#include <linux/string.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/resource.h\"\n#include \"include/policy_unpack.h\"\n#include \"include/policy_ns.h\"\n#include \"include/policy.h\"\n#include \"include/path.h\"\n#include \"include/match.h\"\n#include \"include/ipc.h\"\n#include \"include/file.h\"\n#include \"include/context.h\"\n#include \"include/capability.h\"\n#include \"include/apparmor.h\"\n#include <linux/user_namespace.h>\n#include <linux/rculist.h>\n#include <linux/cred.h>\n#include <linux/string.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n\nbool policy_admin_capable(struct aa_ns *ns)\n{\n\tstruct user_namespace *user_ns = current_user_ns();\n\tbool capable = ns_capable(user_ns, CAP_MAC_ADMIN);\n\n\tAA_DEBUG(\"cap_mac_admin? %d\\n\", capable);\n\tAA_DEBUG(\"policy locked? %d\\n\", aa_g_lock_policy);\n\n\treturn policy_view_capable(ns) && capable && !aa_g_lock_policy;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int pcrlock(const int pcrnum)\n{\n\tunsigned char hash[SHA1_DIGEST_SIZE];\n\tint ret;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tret = tpm_get_random(TPM_ANY_NUM, hash, SHA1_DIGEST_SIZE);\n\tif (ret != SHA1_DIGEST_SIZE)\n\t\treturn ret;\n\treturn tpm_pcr_extend(TPM_ANY_NUM, pcrnum, hash) ? -EINVAL : 0;\n}"
  },
  {
    "function_name": "trusted_tpm_send",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "358-370",
    "snippet": "static int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_tpm_buf",
          "args": [
            "cmd"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "dump_tpm_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.h",
          "lines": "96-98",
          "snippet": "static inline void dump_tpm_buf(unsigned char *buf)\n{\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void dump_tpm_buf(unsigned char *buf)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "tpm_send",
          "args": [
            "chip_num",
            "cmd",
            "buflen"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "trusted_tpm_send",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "358-370",
          "snippet": "static int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic int trusted_tpm_send(const u32 chip_num, unsigned char *cmd,\n\t\t\t    size_t buflen)\n{\n\tint rc;\n\n\tdump_tpm_buf(cmd);\n\trc = tpm_send(chip_num, cmd, buflen);\n\tdump_tpm_buf(cmd);\n\tif (rc > 0)\n\t\t/* Can't return positive return codes values to keyctl */\n\t\trc = -EPERM;\n\treturn rc;\n}"
  },
  {
    "function_name": "TSS_checkhmac2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "256-352",
    "snippet": "static int TSS_checkhmac2(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key1,\n\t\t\t  unsigned int keylen1,\n\t\t\t  const unsigned char *key2,\n\t\t\t  unsigned int keylen2, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce1;\n\tunsigned char *continueflag1;\n\tunsigned char *authdata1;\n\tunsigned char *enonce2;\n\tunsigned char *continueflag2;\n\tunsigned char *authdata2;\n\tunsigned char testhmac1[SHA1_DIGEST_SIZE];\n\tunsigned char testhmac2[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH2_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata1 = buffer + bufsize - (SHA1_DIGEST_SIZE + 1\n\t\t\t+ SHA1_DIGEST_SIZE + SHA1_DIGEST_SIZE);\n\tauthdata2 = buffer + bufsize - (SHA1_DIGEST_SIZE);\n\tcontinueflag1 = authdata1 - 1;\n\tcontinueflag2 = authdata2 - 1;\n\tenonce1 = continueflag1 - TPM_NONCE_SIZE;\n\tenonce2 = continueflag2 - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen2);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac1, key1, keylen1, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce1,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag1, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac1, authdata1, SHA1_DIGEST_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = TSS_rawhmac(testhmac2, key2, keylen2, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce2,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag2, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char hash_alg[] = \"sha1\";",
      "static struct crypto_shash *hashalg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "sdesc"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "testhmac2",
            "authdata2",
            "SHA1_DIGEST_SIZE"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSS_rawhmac",
          "args": [
            "testhmac2",
            "key2",
            "keylen2",
            "SHA1_DIGEST_SIZE",
            "paramdigest",
            "TPM_NONCE_SIZE",
            "enonce2",
            "TPM_NONCE_SIZE",
            "ononce",
            "1",
            "continueflag2",
            "0",
            "0"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "TSS_rawhmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "77-119",
          "snippet": "static int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hmac_alg[] = \"hmac(sha1)\";",
            "static struct crypto_shash *hmacalg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic struct crypto_shash *hmacalg;\n\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "testhmac1",
            "authdata1",
            "SHA1_DIGEST_SIZE"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "&sdesc->shash",
            "paramdigest"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "argp"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&sdesc->shash",
            "buffer + dpos",
            "dlen"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "unsignedint"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "unsignedint"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "argp",
            "keylen2"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&sdesc->shash",
            "(const u8 *)&ordinal",
            "sizeof ordinal"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&sdesc->shash",
            "(const u8 *)&result",
            "sizeof result"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "&sdesc->shash"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sdesc"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: can't alloc %s\\n\"",
            "hash_alg"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sdesc"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sdesc",
          "args": [
            "hashalg"
          ],
          "line": 300
        },
        "resolved": true,
        "details": {
          "function_name": "init_sdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "46-58",
          "snippet": "static struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOAD32N",
          "args": [
            "buffer",
            "TPM_RETURN_OFFSET"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD16",
          "args": [
            "buffer",
            "0"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD32",
          "args": [
            "buffer",
            "TPM_SIZE_OFFSET"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hash_alg[] = \"sha1\";\nstatic struct crypto_shash *hashalg;\n\nstatic int TSS_checkhmac2(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key1,\n\t\t\t  unsigned int keylen1,\n\t\t\t  const unsigned char *key2,\n\t\t\t  unsigned int keylen2, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce1;\n\tunsigned char *continueflag1;\n\tunsigned char *authdata1;\n\tunsigned char *enonce2;\n\tunsigned char *continueflag2;\n\tunsigned char *authdata2;\n\tunsigned char testhmac1[SHA1_DIGEST_SIZE];\n\tunsigned char testhmac2[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH2_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata1 = buffer + bufsize - (SHA1_DIGEST_SIZE + 1\n\t\t\t+ SHA1_DIGEST_SIZE + SHA1_DIGEST_SIZE);\n\tauthdata2 = buffer + bufsize - (SHA1_DIGEST_SIZE);\n\tcontinueflag1 = authdata1 - 1;\n\tcontinueflag2 = authdata2 - 1;\n\tenonce1 = continueflag1 - TPM_NONCE_SIZE;\n\tenonce2 = continueflag2 - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen2);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac1, key1, keylen1, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce1,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag1, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac1, authdata1, SHA1_DIGEST_SIZE)) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = TSS_rawhmac(testhmac2, key2, keylen2, SHA1_DIGEST_SIZE,\n\t\t\t  paramdigest, TPM_NONCE_SIZE, enonce2,\n\t\t\t  TPM_NONCE_SIZE, ononce, 1, continueflag2, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\tif (memcmp(testhmac2, authdata2, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}"
  },
  {
    "function_name": "TSS_checkhmac1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "175-251",
    "snippet": "static int TSS_checkhmac1(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key,\n\t\t\t  unsigned int keylen, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce;\n\tunsigned char *continueflag;\n\tunsigned char *authdata;\n\tunsigned char testhmac[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH1_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata = buffer + bufsize - SHA1_DIGEST_SIZE;\n\tcontinueflag = authdata - 1;\n\tenonce = continueflag - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac, key, keylen, SHA1_DIGEST_SIZE, paramdigest,\n\t\t\t  TPM_NONCE_SIZE, enonce, TPM_NONCE_SIZE, ononce,\n\t\t\t  1, continueflag, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char hash_alg[] = \"sha1\";",
      "static struct crypto_shash *hashalg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "sdesc"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "testhmac",
            "authdata",
            "SHA1_DIGEST_SIZE"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSS_rawhmac",
          "args": [
            "testhmac",
            "key",
            "keylen",
            "SHA1_DIGEST_SIZE",
            "paramdigest",
            "TPM_NONCE_SIZE",
            "enonce",
            "TPM_NONCE_SIZE",
            "ononce",
            "1",
            "continueflag",
            "0",
            "0"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "TSS_rawhmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "77-119",
          "snippet": "static int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hmac_alg[] = \"hmac(sha1)\";",
            "static struct crypto_shash *hmacalg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic struct crypto_shash *hmacalg;\n\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "&sdesc->shash",
            "paramdigest"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "argp"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&sdesc->shash",
            "buffer + dpos",
            "dlen"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "unsignedint"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "unsignedint"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "argp",
            "keylen"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&sdesc->shash",
            "(const u8 *)&ordinal",
            "sizeof ordinal"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&sdesc->shash",
            "(const u8 *)&result",
            "sizeof result"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "&sdesc->shash"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sdesc"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: can't alloc %s\\n\"",
            "hash_alg"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sdesc"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sdesc",
          "args": [
            "hashalg"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "init_sdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "46-58",
          "snippet": "static struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LOAD32N",
          "args": [
            "buffer",
            "TPM_RETURN_OFFSET"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD16",
          "args": [
            "buffer",
            "0"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD32",
          "args": [
            "buffer",
            "TPM_SIZE_OFFSET"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hash_alg[] = \"sha1\";\nstatic struct crypto_shash *hashalg;\n\nstatic int TSS_checkhmac1(unsigned char *buffer,\n\t\t\t  const uint32_t command,\n\t\t\t  const unsigned char *ononce,\n\t\t\t  const unsigned char *key,\n\t\t\t  unsigned int keylen, ...)\n{\n\tuint32_t bufsize;\n\tuint16_t tag;\n\tuint32_t ordinal;\n\tuint32_t result;\n\tunsigned char *enonce;\n\tunsigned char *continueflag;\n\tunsigned char *authdata;\n\tunsigned char testhmac[SHA1_DIGEST_SIZE];\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned int dpos;\n\tva_list argp;\n\tint ret;\n\n\tbufsize = LOAD32(buffer, TPM_SIZE_OFFSET);\n\ttag = LOAD16(buffer, 0);\n\tordinal = command;\n\tresult = LOAD32N(buffer, TPM_RETURN_OFFSET);\n\tif (tag == TPM_TAG_RSP_COMMAND)\n\t\treturn 0;\n\tif (tag != TPM_TAG_RSP_AUTH1_COMMAND)\n\t\treturn -EINVAL;\n\tauthdata = buffer + bufsize - SHA1_DIGEST_SIZE;\n\tcontinueflag = authdata - 1;\n\tenonce = continueflag - TPM_NONCE_SIZE;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&result,\n\t\t\t\t  sizeof result);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_update(&sdesc->shash, (const u8 *)&ordinal,\n\t\t\t\t  sizeof ordinal);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdpos = va_arg(argp, unsigned int);\n\t\tret = crypto_shash_update(&sdesc->shash, buffer + dpos, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tret = TSS_rawhmac(testhmac, key, keylen, SHA1_DIGEST_SIZE, paramdigest,\n\t\t\t  TPM_NONCE_SIZE, enonce, TPM_NONCE_SIZE, ononce,\n\t\t\t  1, continueflag, 0, 0);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tif (memcmp(testhmac, authdata, SHA1_DIGEST_SIZE))\n\t\tret = -EINVAL;\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}"
  },
  {
    "function_name": "TSS_authhmac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "124-170",
    "snippet": "static int TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned char h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char hash_alg[] = \"sha1\";",
      "static struct crypto_shash *hashalg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "sdesc"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "TSS_rawhmac",
          "args": [
            "digest",
            "key",
            "keylen",
            "SHA1_DIGEST_SIZE",
            "paramdigest",
            "TPM_NONCE_SIZE",
            "h1",
            "TPM_NONCE_SIZE",
            "h2",
            "1",
            "&c",
            "0",
            "0"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "TSS_rawhmac",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "77-119",
          "snippet": "static int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char hmac_alg[] = \"hmac(sha1)\";",
            "static struct crypto_shash *hmacalg;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic struct crypto_shash *hmacalg;\n\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "&sdesc->shash",
            "paramdigest"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "argp"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&sdesc->shash",
            "data",
            "dlen"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "unsignedchar *"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "unsignedint"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "argp",
            "h3"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "&sdesc->shash"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sdesc"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: can't alloc %s\\n\"",
            "hash_alg"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sdesc"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sdesc",
          "args": [
            "hashalg"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "init_sdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "46-58",
          "snippet": "static struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hash_alg[] = \"sha1\";\nstatic struct crypto_shash *hashalg;\n\nstatic int TSS_authhmac(unsigned char *digest, const unsigned char *key,\n\t\t\tunsigned int keylen, unsigned char *h1,\n\t\t\tunsigned char *h2, unsigned char h3, ...)\n{\n\tunsigned char paramdigest[SHA1_DIGEST_SIZE];\n\tstruct sdesc *sdesc;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tunsigned char c;\n\tint ret;\n\tva_list argp;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tc = h3;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\tva_start(argp, h3);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (!data) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, paramdigest);\n\tif (!ret)\n\t\tret = TSS_rawhmac(digest, key, keylen, SHA1_DIGEST_SIZE,\n\t\t\t\t  paramdigest, TPM_NONCE_SIZE, h1,\n\t\t\t\t  TPM_NONCE_SIZE, h2, 1, &c, 0, 0);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}"
  },
  {
    "function_name": "TSS_rawhmac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "77-119",
    "snippet": "static int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char hmac_alg[] = \"hmac(sha1)\";",
      "static struct crypto_shash *hmacalg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "sdesc"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_final",
          "args": [
            "&sdesc->shash",
            "digest"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "argp"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_update",
          "args": [
            "&sdesc->shash",
            "data",
            "dlen"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "unsignedchar *"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_arg",
          "args": [
            "argp",
            "unsignedint"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "argp",
            "keylen"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_init",
          "args": [
            "&sdesc->shash"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_setkey",
          "args": [
            "hmacalg",
            "key",
            "keylen"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sdesc"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: can't alloc %s\\n\"",
            "hmac_alg"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sdesc"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sdesc",
          "args": [
            "hmacalg"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "init_sdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "46-58",
          "snippet": "static struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hmac_alg[] = \"hmac(sha1)\";\nstatic struct crypto_shash *hmacalg;\n\nstatic int TSS_rawhmac(unsigned char *digest, const unsigned char *key,\n\t\t       unsigned int keylen, ...)\n{\n\tstruct sdesc *sdesc;\n\tva_list argp;\n\tunsigned int dlen;\n\tunsigned char *data;\n\tint ret;\n\n\tsdesc = init_sdesc(hmacalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hmac_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_setkey(hmacalg, key, keylen);\n\tif (ret < 0)\n\t\tgoto out;\n\tret = crypto_shash_init(&sdesc->shash);\n\tif (ret < 0)\n\t\tgoto out;\n\n\tva_start(argp, keylen);\n\tfor (;;) {\n\t\tdlen = va_arg(argp, unsigned int);\n\t\tif (dlen == 0)\n\t\t\tbreak;\n\t\tdata = va_arg(argp, unsigned char *);\n\t\tif (data == NULL) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t\tret = crypto_shash_update(&sdesc->shash, data, dlen);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t}\n\tva_end(argp);\n\tif (!ret)\n\t\tret = crypto_shash_final(&sdesc->shash, digest);\nout:\n\tkzfree(sdesc);\n\treturn ret;\n}"
  },
  {
    "function_name": "TSS_sha1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "60-75",
    "snippet": "static int TSS_sha1(const unsigned char *data, unsigned int datalen,\n\t\t    unsigned char *digest)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);\n\tkzfree(sdesc);\n\treturn ret;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char hash_alg[] = \"sha1\";",
      "static struct crypto_shash *hashalg;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzfree",
          "args": [
            "sdesc"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_digest",
          "args": [
            "&sdesc->shash",
            "data",
            "datalen",
            "digest"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "sdesc"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"trusted_key: can't alloc %s\\n\"",
            "hash_alg"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "sdesc"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_sdesc",
          "args": [
            "hashalg"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "init_sdesc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
          "lines": "46-58",
          "snippet": "static struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}",
          "includes": [
            "#include \"trusted.h\"",
            "#include <linux/tpm_command.h>",
            "#include <linux/tpm.h>",
            "#include <linux/capability.h>",
            "#include <crypto/sha.h>",
            "#include <crypto/hash.h>",
            "#include <linux/crypto.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/key-type.h>",
            "#include <keys/trusted-type.h>",
            "#include <keys/user-type.h>",
            "#include <linux/err.h>",
            "#include <linux/string.h>",
            "#include <linux/parser.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <crypto/hash_info.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic const char hash_alg[] = \"sha1\";\nstatic struct crypto_shash *hashalg;\n\nstatic int TSS_sha1(const unsigned char *data, unsigned int datalen,\n\t\t    unsigned char *digest)\n{\n\tstruct sdesc *sdesc;\n\tint ret;\n\n\tsdesc = init_sdesc(hashalg);\n\tif (IS_ERR(sdesc)) {\n\t\tpr_info(\"trusted_key: can't alloc %s\\n\", hash_alg);\n\t\treturn PTR_ERR(sdesc);\n\t}\n\n\tret = crypto_shash_digest(&sdesc->shash, data, datalen, digest);\n\tkzfree(sdesc);\n\treturn ret;\n}"
  },
  {
    "function_name": "init_sdesc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/trusted.c",
    "lines": "46-58",
    "snippet": "static struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}",
    "includes": [
      "#include \"trusted.h\"",
      "#include <linux/tpm_command.h>",
      "#include <linux/tpm.h>",
      "#include <linux/capability.h>",
      "#include <crypto/sha.h>",
      "#include <crypto/hash.h>",
      "#include <linux/crypto.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/key-type.h>",
      "#include <keys/trusted-type.h>",
      "#include <keys/user-type.h>",
      "#include <linux/err.h>",
      "#include <linux/string.h>",
      "#include <linux/parser.h>",
      "#include <linux/slab.h>",
      "#include <linux/init.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <crypto/hash_info.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "crypto_shash_descsize",
          "args": [
            "alg"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trusted.h\"\n#include <linux/tpm_command.h>\n#include <linux/tpm.h>\n#include <linux/capability.h>\n#include <crypto/sha.h>\n#include <crypto/hash.h>\n#include <linux/crypto.h>\n#include <linux/rcupdate.h>\n#include <linux/key-type.h>\n#include <keys/trusted-type.h>\n#include <keys/user-type.h>\n#include <linux/err.h>\n#include <linux/string.h>\n#include <linux/parser.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <crypto/hash_info.h>\n\nstatic struct sdesc *init_sdesc(struct crypto_shash *alg)\n{\n\tstruct sdesc *sdesc;\n\tint size;\n\n\tsize = sizeof(struct shash_desc) + crypto_shash_descsize(alg);\n\tsdesc = kmalloc(size, GFP_KERNEL);\n\tif (!sdesc)\n\t\treturn ERR_PTR(-ENOMEM);\n\tsdesc->shash.tfm = alg;\n\tsdesc->shash.flags = 0x0;\n\treturn sdesc;\n}"
  }
]