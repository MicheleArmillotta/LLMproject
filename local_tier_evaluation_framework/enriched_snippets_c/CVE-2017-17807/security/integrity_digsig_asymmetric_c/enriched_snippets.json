[
  {
    "function_name": "asymmetric_verify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/digsig_asymmetric.c",
    "lines": "82-117",
    "snippet": "int asymmetric_verify(struct key *keyring, const char *sig,\n\t\t      int siglen, const char *data, int datalen)\n{\n\tstruct public_key_signature pks;\n\tstruct signature_v2_hdr *hdr = (struct signature_v2_hdr *)sig;\n\tstruct key *key;\n\tint ret = -ENOMEM;\n\n\tif (siglen <= sizeof(*hdr))\n\t\treturn -EBADMSG;\n\n\tsiglen -= sizeof(*hdr);\n\n\tif (siglen != be16_to_cpu(hdr->sig_size))\n\t\treturn -EBADMSG;\n\n\tif (hdr->hash_algo >= HASH_ALGO__LAST)\n\t\treturn -ENOPKG;\n\n\tkey = request_asymmetric_key(keyring, be32_to_cpu(hdr->keyid));\n\tif (IS_ERR(key))\n\t\treturn PTR_ERR(key);\n\n\tmemset(&pks, 0, sizeof(pks));\n\n\tpks.pkey_algo = \"rsa\";\n\tpks.hash_algo = hash_algo_name[hdr->hash_algo];\n\tpks.digest = (u8 *)data;\n\tpks.digest_size = datalen;\n\tpks.s = hdr->sig;\n\tpks.s_size = siglen;\n\tret = verify_signature(key, &pks);\n\tkey_put(key);\n\tpr_debug(\"%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}",
    "includes": [
      "#include \"integrity.h\"",
      "#include <keys/system_keyring.h>",
      "#include <keys/asymmetric-type.h>",
      "#include <crypto/hash_info.h>",
      "#include <crypto/public_key.h>",
      "#include <linux/key-type.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s() = %d\\n\"",
            "__func__",
            "ret"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "key"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "key_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/key.c",
          "lines": "633-641",
          "snippet": "void key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/err.h>",
            "#include <linux/random.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/poison.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/err.h>\n#include <linux/random.h>\n#include <linux/workqueue.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/poison.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nvoid key_put(struct key *key)\n{\n\tif (key) {\n\t\tkey_check(key);\n\n\t\tif (refcount_dec_and_test(&key->usage))\n\t\t\tschedule_work(&key_gc_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "verify_signature",
          "args": [
            "key",
            "&pks"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&pks",
            "0",
            "sizeof(pks)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_asymmetric_key",
          "args": [
            "keyring",
            "be32_to_cpu(hdr->keyid)"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "request_asymmetric_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/digsig_asymmetric.c",
          "lines": "28-80",
          "snippet": "static struct key *request_asymmetric_key(struct key *keyring, uint32_t keyid)\n{\n\tstruct key *key;\n\tchar name[12];\n\n\tsprintf(name, \"id:%08x\", keyid);\n\n\tpr_debug(\"key search: \\\"%s\\\"\\n\", name);\n\n\tkey = get_ima_blacklist_keyring();\n\tif (key) {\n\t\tkey_ref_t kref;\n\n\t\tkref = keyring_search(make_key_ref(key, 1),\n\t\t\t\t     &key_type_asymmetric, name);\n\t\tif (!IS_ERR(kref)) {\n\t\t\tpr_err(\"Key '%s' is in ima_blacklist_keyring\\n\", name);\n\t\t\treturn ERR_PTR(-EKEYREJECTED);\n\t\t}\n\t}\n\n\tif (keyring) {\n\t\t/* search in specific keyring */\n\t\tkey_ref_t kref;\n\n\t\tkref = keyring_search(make_key_ref(keyring, 1),\n\t\t\t\t      &key_type_asymmetric, name);\n\t\tif (IS_ERR(kref))\n\t\t\tkey = ERR_CAST(kref);\n\t\telse\n\t\t\tkey = key_ref_to_ptr(kref);\n\t} else {\n\t\tkey = request_key(&key_type_asymmetric, name, NULL);\n\t}\n\n\tif (IS_ERR(key)) {\n\t\tpr_err_ratelimited(\"Request for unknown key '%s' err %ld\\n\",\n\t\t\t\t   name, PTR_ERR(key));\n\t\tswitch (PTR_ERR(key)) {\n\t\t\t/* Hide some search errors */\n\t\tcase -EACCES:\n\t\tcase -ENOTDIR:\n\t\tcase -EAGAIN:\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\tdefault:\n\t\t\treturn key;\n\t\t}\n\t}\n\n\tpr_debug(\"%s() = 0 [%x]\\n\", __func__, key_serial(key));\n\n\treturn key;\n}",
          "includes": [
            "#include \"integrity.h\"",
            "#include <keys/system_keyring.h>",
            "#include <keys/asymmetric-type.h>",
            "#include <crypto/hash_info.h>",
            "#include <crypto/public_key.h>",
            "#include <linux/key-type.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/err.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"integrity.h\"\n#include <keys/system_keyring.h>\n#include <keys/asymmetric-type.h>\n#include <crypto/hash_info.h>\n#include <crypto/public_key.h>\n#include <linux/key-type.h>\n#include <linux/ratelimit.h>\n#include <linux/err.h>\n\nstatic struct key *request_asymmetric_key(struct key *keyring, uint32_t keyid)\n{\n\tstruct key *key;\n\tchar name[12];\n\n\tsprintf(name, \"id:%08x\", keyid);\n\n\tpr_debug(\"key search: \\\"%s\\\"\\n\", name);\n\n\tkey = get_ima_blacklist_keyring();\n\tif (key) {\n\t\tkey_ref_t kref;\n\n\t\tkref = keyring_search(make_key_ref(key, 1),\n\t\t\t\t     &key_type_asymmetric, name);\n\t\tif (!IS_ERR(kref)) {\n\t\t\tpr_err(\"Key '%s' is in ima_blacklist_keyring\\n\", name);\n\t\t\treturn ERR_PTR(-EKEYREJECTED);\n\t\t}\n\t}\n\n\tif (keyring) {\n\t\t/* search in specific keyring */\n\t\tkey_ref_t kref;\n\n\t\tkref = keyring_search(make_key_ref(keyring, 1),\n\t\t\t\t      &key_type_asymmetric, name);\n\t\tif (IS_ERR(kref))\n\t\t\tkey = ERR_CAST(kref);\n\t\telse\n\t\t\tkey = key_ref_to_ptr(kref);\n\t} else {\n\t\tkey = request_key(&key_type_asymmetric, name, NULL);\n\t}\n\n\tif (IS_ERR(key)) {\n\t\tpr_err_ratelimited(\"Request for unknown key '%s' err %ld\\n\",\n\t\t\t\t   name, PTR_ERR(key));\n\t\tswitch (PTR_ERR(key)) {\n\t\t\t/* Hide some search errors */\n\t\tcase -EACCES:\n\t\tcase -ENOTDIR:\n\t\tcase -EAGAIN:\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\tdefault:\n\t\t\treturn key;\n\t\t}\n\t}\n\n\tpr_debug(\"%s() = 0 [%x]\\n\", __func__, key_serial(key));\n\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "be32_to_cpu",
          "args": [
            "hdr->keyid"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "be16_to_cpu",
          "args": [
            "hdr->sig_size"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"integrity.h\"\n#include <keys/system_keyring.h>\n#include <keys/asymmetric-type.h>\n#include <crypto/hash_info.h>\n#include <crypto/public_key.h>\n#include <linux/key-type.h>\n#include <linux/ratelimit.h>\n#include <linux/err.h>\n\nint asymmetric_verify(struct key *keyring, const char *sig,\n\t\t      int siglen, const char *data, int datalen)\n{\n\tstruct public_key_signature pks;\n\tstruct signature_v2_hdr *hdr = (struct signature_v2_hdr *)sig;\n\tstruct key *key;\n\tint ret = -ENOMEM;\n\n\tif (siglen <= sizeof(*hdr))\n\t\treturn -EBADMSG;\n\n\tsiglen -= sizeof(*hdr);\n\n\tif (siglen != be16_to_cpu(hdr->sig_size))\n\t\treturn -EBADMSG;\n\n\tif (hdr->hash_algo >= HASH_ALGO__LAST)\n\t\treturn -ENOPKG;\n\n\tkey = request_asymmetric_key(keyring, be32_to_cpu(hdr->keyid));\n\tif (IS_ERR(key))\n\t\treturn PTR_ERR(key);\n\n\tmemset(&pks, 0, sizeof(pks));\n\n\tpks.pkey_algo = \"rsa\";\n\tpks.hash_algo = hash_algo_name[hdr->hash_algo];\n\tpks.digest = (u8 *)data;\n\tpks.digest_size = datalen;\n\tpks.s = hdr->sig;\n\tpks.s_size = siglen;\n\tret = verify_signature(key, &pks);\n\tkey_put(key);\n\tpr_debug(\"%s() = %d\\n\", __func__, ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "request_asymmetric_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/integrity/digsig_asymmetric.c",
    "lines": "28-80",
    "snippet": "static struct key *request_asymmetric_key(struct key *keyring, uint32_t keyid)\n{\n\tstruct key *key;\n\tchar name[12];\n\n\tsprintf(name, \"id:%08x\", keyid);\n\n\tpr_debug(\"key search: \\\"%s\\\"\\n\", name);\n\n\tkey = get_ima_blacklist_keyring();\n\tif (key) {\n\t\tkey_ref_t kref;\n\n\t\tkref = keyring_search(make_key_ref(key, 1),\n\t\t\t\t     &key_type_asymmetric, name);\n\t\tif (!IS_ERR(kref)) {\n\t\t\tpr_err(\"Key '%s' is in ima_blacklist_keyring\\n\", name);\n\t\t\treturn ERR_PTR(-EKEYREJECTED);\n\t\t}\n\t}\n\n\tif (keyring) {\n\t\t/* search in specific keyring */\n\t\tkey_ref_t kref;\n\n\t\tkref = keyring_search(make_key_ref(keyring, 1),\n\t\t\t\t      &key_type_asymmetric, name);\n\t\tif (IS_ERR(kref))\n\t\t\tkey = ERR_CAST(kref);\n\t\telse\n\t\t\tkey = key_ref_to_ptr(kref);\n\t} else {\n\t\tkey = request_key(&key_type_asymmetric, name, NULL);\n\t}\n\n\tif (IS_ERR(key)) {\n\t\tpr_err_ratelimited(\"Request for unknown key '%s' err %ld\\n\",\n\t\t\t\t   name, PTR_ERR(key));\n\t\tswitch (PTR_ERR(key)) {\n\t\t\t/* Hide some search errors */\n\t\tcase -EACCES:\n\t\tcase -ENOTDIR:\n\t\tcase -EAGAIN:\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\tdefault:\n\t\t\treturn key;\n\t\t}\n\t}\n\n\tpr_debug(\"%s() = 0 [%x]\\n\", __func__, key_serial(key));\n\n\treturn key;\n}",
    "includes": [
      "#include \"integrity.h\"",
      "#include <keys/system_keyring.h>",
      "#include <keys/asymmetric-type.h>",
      "#include <crypto/hash_info.h>",
      "#include <crypto/public_key.h>",
      "#include <linux/key-type.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/err.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s() = 0 [%x]\\n\"",
            "__func__",
            "key_serial(key)"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_serial",
          "args": [
            "key"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOKEY"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err_ratelimited",
          "args": [
            "\"Request for unknown key '%s' err %ld\\n\"",
            "name",
            "PTR_ERR(key)"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "request_key",
          "args": [
            "&key_type_asymmetric",
            "name",
            "NULL"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "request_key_auth_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/request_key_auth.c",
          "lines": "84-104",
          "snippet": "static long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <keys/user-type.h>",
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/err.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void request_key_auth_revoke(struct key *);",
            "static void request_key_auth_destroy(struct key *);",
            "static long request_key_auth_read(const struct key *, char __user *, size_t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <keys/user-type.h>\n#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/err.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void request_key_auth_revoke(struct key *);\nstatic void request_key_auth_destroy(struct key *);\nstatic long request_key_auth_read(const struct key *, char __user *, size_t);\n\nstatic long request_key_auth_read(const struct key *key,\n\t\t\t\t  char __user *buffer, size_t buflen)\n{\n\tstruct request_key_auth *rka = key->payload.data[0];\n\tsize_t datalen;\n\tlong ret;\n\n\tdatalen = rka->callout_len;\n\tret = datalen;\n\n\t/* we can return the data as is */\n\tif (buffer && buflen > 0) {\n\t\tif (buflen > datalen)\n\t\t\tbuflen = datalen;\n\n\t\tif (copy_to_user(buffer, rka->callout_info, buflen) != 0)\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_ref_to_ptr",
          "args": [
            "kref"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_CAST",
          "args": [
            "kref"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kref"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "keyring_search",
          "args": [
            "make_key_ref(keyring, 1)",
            "&key_type_asymmetric",
            "name"
          ],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "keyring_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/keys/keyring.c",
          "lines": "917-944",
          "snippet": "key_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include <linux/uaccess.h>",
            "#include <linux/assoc_array_priv.h>",
            "#include <keys/user-type.h>",
            "#include <keys/keyring-type.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void keyring_revoke(struct key *keyring);",
            "static void keyring_destroy(struct key *keyring);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include <linux/uaccess.h>\n#include <linux/assoc_array_priv.h>\n#include <keys/user-type.h>\n#include <keys/keyring-type.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n#include <linux/module.h>\n\nstatic void keyring_revoke(struct key *keyring);\nstatic void keyring_destroy(struct key *keyring);\n\nkey_ref_t keyring_search(key_ref_t keyring,\n\t\t\t struct key_type *type,\n\t\t\t const char *description)\n{\n\tstruct keyring_search_context ctx = {\n\t\t.index_key.type\t\t= type,\n\t\t.index_key.description\t= description,\n\t\t.cred\t\t\t= current_cred(),\n\t\t.match_data.cmp\t\t= key_default_cmp,\n\t\t.match_data.raw_data\t= description,\n\t\t.match_data.lookup_type\t= KEYRING_SEARCH_LOOKUP_DIRECT,\n\t\t.flags\t\t\t= KEYRING_SEARCH_DO_STATE_CHECK,\n\t};\n\tkey_ref_t key;\n\tint ret;\n\n\tif (type->match_preparse) {\n\t\tret = type->match_preparse(&ctx.match_data);\n\t\tif (ret < 0)\n\t\t\treturn ERR_PTR(ret);\n\t}\n\n\tkey = keyring_search_aux(keyring, &ctx);\n\n\tif (type->match_free)\n\t\ttype->match_free(&ctx.match_data);\n\treturn key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "keyring",
            "1"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EKEYREJECTED"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Key '%s' is in ima_blacklist_keyring\\n\"",
            "name"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "kref"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "make_key_ref",
          "args": [
            "key",
            "1"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_ima_blacklist_keyring",
          "args": [],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"key search: \\\"%s\\\"\\n\"",
            "name"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "name",
            "\"id:%08x\"",
            "keyid"
          ],
          "line": 33
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"integrity.h\"\n#include <keys/system_keyring.h>\n#include <keys/asymmetric-type.h>\n#include <crypto/hash_info.h>\n#include <crypto/public_key.h>\n#include <linux/key-type.h>\n#include <linux/ratelimit.h>\n#include <linux/err.h>\n\nstatic struct key *request_asymmetric_key(struct key *keyring, uint32_t keyid)\n{\n\tstruct key *key;\n\tchar name[12];\n\n\tsprintf(name, \"id:%08x\", keyid);\n\n\tpr_debug(\"key search: \\\"%s\\\"\\n\", name);\n\n\tkey = get_ima_blacklist_keyring();\n\tif (key) {\n\t\tkey_ref_t kref;\n\n\t\tkref = keyring_search(make_key_ref(key, 1),\n\t\t\t\t     &key_type_asymmetric, name);\n\t\tif (!IS_ERR(kref)) {\n\t\t\tpr_err(\"Key '%s' is in ima_blacklist_keyring\\n\", name);\n\t\t\treturn ERR_PTR(-EKEYREJECTED);\n\t\t}\n\t}\n\n\tif (keyring) {\n\t\t/* search in specific keyring */\n\t\tkey_ref_t kref;\n\n\t\tkref = keyring_search(make_key_ref(keyring, 1),\n\t\t\t\t      &key_type_asymmetric, name);\n\t\tif (IS_ERR(kref))\n\t\t\tkey = ERR_CAST(kref);\n\t\telse\n\t\t\tkey = key_ref_to_ptr(kref);\n\t} else {\n\t\tkey = request_key(&key_type_asymmetric, name, NULL);\n\t}\n\n\tif (IS_ERR(key)) {\n\t\tpr_err_ratelimited(\"Request for unknown key '%s' err %ld\\n\",\n\t\t\t\t   name, PTR_ERR(key));\n\t\tswitch (PTR_ERR(key)) {\n\t\t\t/* Hide some search errors */\n\t\tcase -EACCES:\n\t\tcase -ENOTDIR:\n\t\tcase -EAGAIN:\n\t\t\treturn ERR_PTR(-ENOKEY);\n\t\tdefault:\n\t\t\treturn key;\n\t\t}\n\t}\n\n\tpr_debug(\"%s() = 0 [%x]\\n\", __func__, key_serial(key));\n\n\treturn key;\n}"
  }
]