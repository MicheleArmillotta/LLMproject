[
  {
    "function_name": "avtab_cache_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "668-672",
    "snippet": "void avtab_cache_destroy(void)\n{\n\tkmem_cache_destroy(avtab_node_cachep);\n\tkmem_cache_destroy(avtab_xperms_cachep);\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *avtab_node_cachep;",
      "static struct kmem_cache *avtab_xperms_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "avtab_xperms_cachep"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_destroy",
          "args": [
            "avtab_node_cachep"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *avtab_node_cachep;\nstatic struct kmem_cache *avtab_xperms_cachep;\n\nvoid avtab_cache_destroy(void)\n{\n\tkmem_cache_destroy(avtab_node_cachep);\n\tkmem_cache_destroy(avtab_xperms_cachep);\n}"
  },
  {
    "function_name": "avtab_cache_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "658-666",
    "snippet": "void avtab_cache_init(void)\n{\n\tavtab_node_cachep = kmem_cache_create(\"avtab_node\",\n\t\t\t\t\t      sizeof(struct avtab_node),\n\t\t\t\t\t      0, SLAB_PANIC, NULL);\n\tavtab_xperms_cachep = kmem_cache_create(\"avtab_extended_perms\",\n\t\t\t\t\t\tsizeof(struct avtab_extended_perms),\n\t\t\t\t\t\t0, SLAB_PANIC, NULL);\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *avtab_node_cachep;",
      "static struct kmem_cache *avtab_xperms_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"avtab_extended_perms\"",
            "sizeof(struct avtab_extended_perms)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"avtab_node\"",
            "sizeof(struct avtab_node)",
            "0",
            "SLAB_PANIC",
            "NULL"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *avtab_node_cachep;\nstatic struct kmem_cache *avtab_xperms_cachep;\n\nvoid avtab_cache_init(void)\n{\n\tavtab_node_cachep = kmem_cache_create(\"avtab_node\",\n\t\t\t\t\t      sizeof(struct avtab_node),\n\t\t\t\t\t      0, SLAB_PANIC, NULL);\n\tavtab_xperms_cachep = kmem_cache_create(\"avtab_extended_perms\",\n\t\t\t\t\t\tsizeof(struct avtab_extended_perms),\n\t\t\t\t\t\t0, SLAB_PANIC, NULL);\n}"
  },
  {
    "function_name": "avtab_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "635-657",
    "snippet": "int avtab_write(struct policydb *p, struct avtab *a, void *fp)\n{\n\tunsigned int i;\n\tint rc = 0;\n\tstruct avtab_node *cur;\n\t__le32 buf[1];\n\n\tbuf[0] = cpu_to_le32(a->nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < a->nslot; i++) {\n\t\tfor (cur = flex_array_get_ptr(a->htable, i); cur;\n\t\t     cur = cur->next) {\n\t\t\trc = avtab_write_item(p, cur, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avtab_write_item",
          "args": [
            "p",
            "cur",
            "fp"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_write_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "600-633",
          "snippet": "int avtab_write_item(struct policydb *p, struct avtab_node *cur, void *fp)\n{\n\t__le16 buf16[4];\n\t__le32 buf32[ARRAY_SIZE(cur->datum.u.xperms->perms.p)];\n\tint rc;\n\tunsigned int i;\n\n\tbuf16[0] = cpu_to_le16(cur->key.source_type);\n\tbuf16[1] = cpu_to_le16(cur->key.target_type);\n\tbuf16[2] = cpu_to_le16(cur->key.target_class);\n\tbuf16[3] = cpu_to_le16(cur->key.specified);\n\trc = put_entry(buf16, sizeof(u16), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cur->key.specified & AVTAB_XPERMS) {\n\t\trc = put_entry(&cur->datum.u.xperms->specified, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = put_entry(&cur->datum.u.xperms->driver, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (i = 0; i < ARRAY_SIZE(cur->datum.u.xperms->perms.p); i++)\n\t\t\tbuf32[i] = cpu_to_le32(cur->datum.u.xperms->perms.p[i]);\n\t\trc = put_entry(buf32, sizeof(u32),\n\t\t\t\tARRAY_SIZE(cur->datum.u.xperms->perms.p), fp);\n\t} else {\n\t\tbuf32[0] = cpu_to_le32(cur->datum.u.data);\n\t\trc = put_entry(buf32, sizeof(u32), 1, fp);\n\t}\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_write_item(struct policydb *p, struct avtab_node *cur, void *fp)\n{\n\t__le16 buf16[4];\n\t__le32 buf32[ARRAY_SIZE(cur->datum.u.xperms->perms.p)];\n\tint rc;\n\tunsigned int i;\n\n\tbuf16[0] = cpu_to_le16(cur->key.source_type);\n\tbuf16[1] = cpu_to_le16(cur->key.target_type);\n\tbuf16[2] = cpu_to_le16(cur->key.target_class);\n\tbuf16[3] = cpu_to_le16(cur->key.specified);\n\trc = put_entry(buf16, sizeof(u16), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cur->key.specified & AVTAB_XPERMS) {\n\t\trc = put_entry(&cur->datum.u.xperms->specified, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = put_entry(&cur->datum.u.xperms->driver, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (i = 0; i < ARRAY_SIZE(cur->datum.u.xperms->perms.p); i++)\n\t\t\tbuf32[i] = cpu_to_le32(cur->datum.u.xperms->perms.p[i]);\n\t\trc = put_entry(buf32, sizeof(u32),\n\t\t\t\tARRAY_SIZE(cur->datum.u.xperms->perms.p), fp);\n\t} else {\n\t\tbuf32[0] = cpu_to_le32(cur->datum.u.data);\n\t\trc = put_entry(buf32, sizeof(u32), 1, fp);\n\t}\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flex_array_get_ptr",
          "args": [
            "a->htable",
            "i"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf",
            "sizeof(u32)",
            "1",
            "fp"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "a->nel"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_write(struct policydb *p, struct avtab *a, void *fp)\n{\n\tunsigned int i;\n\tint rc = 0;\n\tstruct avtab_node *cur;\n\t__le32 buf[1];\n\n\tbuf[0] = cpu_to_le32(a->nel);\n\trc = put_entry(buf, sizeof(u32), 1, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tfor (i = 0; i < a->nslot; i++) {\n\t\tfor (cur = flex_array_get_ptr(a->htable, i); cur;\n\t\t     cur = cur->next) {\n\t\t\trc = avtab_write_item(p, cur, fp);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "avtab_write_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "600-633",
    "snippet": "int avtab_write_item(struct policydb *p, struct avtab_node *cur, void *fp)\n{\n\t__le16 buf16[4];\n\t__le32 buf32[ARRAY_SIZE(cur->datum.u.xperms->perms.p)];\n\tint rc;\n\tunsigned int i;\n\n\tbuf16[0] = cpu_to_le16(cur->key.source_type);\n\tbuf16[1] = cpu_to_le16(cur->key.target_type);\n\tbuf16[2] = cpu_to_le16(cur->key.target_class);\n\tbuf16[3] = cpu_to_le16(cur->key.specified);\n\trc = put_entry(buf16, sizeof(u16), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cur->key.specified & AVTAB_XPERMS) {\n\t\trc = put_entry(&cur->datum.u.xperms->specified, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = put_entry(&cur->datum.u.xperms->driver, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (i = 0; i < ARRAY_SIZE(cur->datum.u.xperms->perms.p); i++)\n\t\t\tbuf32[i] = cpu_to_le32(cur->datum.u.xperms->perms.p[i]);\n\t\trc = put_entry(buf32, sizeof(u32),\n\t\t\t\tARRAY_SIZE(cur->datum.u.xperms->perms.p), fp);\n\t} else {\n\t\tbuf32[0] = cpu_to_le32(cur->datum.u.data);\n\t\trc = put_entry(buf32, sizeof(u32), 1, fp);\n\t}\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_entry",
          "args": [
            "buf32",
            "sizeof(u32)",
            "1",
            "fp"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "put_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "359-368",
          "snippet": "static inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int put_entry(const void *buf, size_t bytes, int num, struct policy_file *fp)\n{\n\tsize_t len = bytes * num;\n\n\tmemcpy(fp->data, buf, len);\n\tfp->data += len;\n\tfp->len -= len;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cur->datum.u.data"
          ],
          "line": 627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cur->datum.u.xperms->perms.p"
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le32",
          "args": [
            "cur->datum.u.xperms->perms.p[i]"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cur->datum.u.xperms->perms.p"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "cur->key.specified"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "cur->key.target_class"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "cur->key.target_type"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_le16",
          "args": [
            "cur->key.source_type"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "cur->datum.u.xperms->perms.p"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_write_item(struct policydb *p, struct avtab_node *cur, void *fp)\n{\n\t__le16 buf16[4];\n\t__le32 buf32[ARRAY_SIZE(cur->datum.u.xperms->perms.p)];\n\tint rc;\n\tunsigned int i;\n\n\tbuf16[0] = cpu_to_le16(cur->key.source_type);\n\tbuf16[1] = cpu_to_le16(cur->key.target_type);\n\tbuf16[2] = cpu_to_le16(cur->key.target_class);\n\tbuf16[3] = cpu_to_le16(cur->key.specified);\n\trc = put_entry(buf16, sizeof(u16), 4, fp);\n\tif (rc)\n\t\treturn rc;\n\n\tif (cur->key.specified & AVTAB_XPERMS) {\n\t\trc = put_entry(&cur->datum.u.xperms->specified, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\trc = put_entry(&cur->datum.u.xperms->driver, sizeof(u8), 1, fp);\n\t\tif (rc)\n\t\t\treturn rc;\n\t\tfor (i = 0; i < ARRAY_SIZE(cur->datum.u.xperms->perms.p); i++)\n\t\t\tbuf32[i] = cpu_to_le32(cur->datum.u.xperms->perms.p[i]);\n\t\trc = put_entry(buf32, sizeof(u32),\n\t\t\t\tARRAY_SIZE(cur->datum.u.xperms->perms.p), fp);\n\t} else {\n\t\tbuf32[0] = cpu_to_le32(cur->datum.u.data);\n\t\trc = put_entry(buf32, sizeof(u32), 1, fp);\n\t}\n\tif (rc)\n\t\treturn rc;\n\treturn 0;\n}"
  },
  {
    "function_name": "avtab_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "556-598",
    "snippet": "int avtab_read(struct avtab *a, void *fp, struct policydb *pol)\n{\n\tint rc;\n\t__le32 buf[1];\n\tu32 nel, i;\n\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: truncated table\\n\");\n\t\tgoto bad;\n\t}\n\tnel = le32_to_cpu(buf[0]);\n\tif (!nel) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: table is empty\\n\");\n\t\trc = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\trc = avtab_alloc(a, nel);\n\tif (rc)\n\t\tgoto bad;\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = avtab_read_item(a, fp, pol, avtab_insertf, NULL);\n\t\tif (rc) {\n\t\t\tif (rc == -ENOMEM)\n\t\t\t\tprintk(KERN_ERR \"SELinux: avtab: out of memory\\n\");\n\t\t\telse if (rc == -EEXIST)\n\t\t\t\tprintk(KERN_ERR \"SELinux: avtab: duplicate entry\\n\");\n\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\trc = 0;\nout:\n\treturn rc;\n\nbad:\n\tavtab_destroy(a);\n\tgoto out;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avtab_destroy",
          "args": [
            "a"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "279-302",
          "snippet": "void avtab_destroy(struct avtab *h)\n{\n\tint i;\n\tstruct avtab_node *cur, *temp;\n\n\tif (!h || !h->htable)\n\t\treturn;\n\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tif (temp->key.specified & AVTAB_XPERMS)\n\t\t\t\tkmem_cache_free(avtab_xperms_cachep,\n\t\t\t\t\t\ttemp->datum.u.xperms);\n\t\t\tkmem_cache_free(avtab_node_cachep, temp);\n\t\t}\n\t}\n\tflex_array_free(h->htable);\n\th->htable = NULL;\n\th->nslot = 0;\n\th->mask = 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avtab_node_cachep;",
            "static struct kmem_cache *avtab_xperms_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *avtab_node_cachep;\nstatic struct kmem_cache *avtab_xperms_cachep;\n\nvoid avtab_destroy(struct avtab *h)\n{\n\tint i;\n\tstruct avtab_node *cur, *temp;\n\n\tif (!h || !h->htable)\n\t\treturn;\n\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tif (temp->key.specified & AVTAB_XPERMS)\n\t\t\t\tkmem_cache_free(avtab_xperms_cachep,\n\t\t\t\t\t\ttemp->datum.u.xperms);\n\t\t\tkmem_cache_free(avtab_node_cachep, temp);\n\t\t}\n\t}\n\tflex_array_free(h->htable);\n\th->htable = NULL;\n\th->nslot = 0;\n\th->mask = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: duplicate entry\\n\""
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: out of memory\\n\""
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avtab_read_item",
          "args": [
            "a",
            "fp",
            "pol",
            "avtab_insertf",
            "NULL"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_read_item",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "389-548",
          "snippet": "int avtab_read_item(struct avtab *a, void *fp, struct policydb *pol,\n\t\t    int (*insertf)(struct avtab *a, struct avtab_key *k,\n\t\t\t\t   struct avtab_datum *d, void *p),\n\t\t    void *p)\n{\n\t__le16 buf16[4];\n\tu16 enabled;\n\tu32 items, items2, val, vers = pol->policyvers;\n\tstruct avtab_key key;\n\tstruct avtab_datum datum;\n\tstruct avtab_extended_perms xperms;\n\t__le32 buf32[ARRAY_SIZE(xperms.perms.p)];\n\tint i, rc;\n\tunsigned set;\n\n\tmemset(&key, 0, sizeof(struct avtab_key));\n\tmemset(&datum, 0, sizeof(struct avtab_datum));\n\n\tif (vers < POLICYDB_VERSION_AVTAB) {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems2 = le32_to_cpu(buf32[0]);\n\t\tif (items2 > ARRAY_SIZE(buf32)) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry overflow\\n\");\n\t\t\treturn -EINVAL;\n\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*items2);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems = 0;\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.source_type = (u16)val;\n\t\tif (key.source_type != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated source type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_type = (u16)val;\n\t\tif (key.target_type != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated target type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_class = (u16)val;\n\t\tif (key.target_class != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated target class\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tenabled = (val & AVTAB_ENABLED_OLD) ? AVTAB_ENABLED : 0;\n\n\t\tif (!(val & (AVTAB_AV | AVTAB_TYPE))) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: null entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((val & AVTAB_AV) &&\n\t\t    (val & AVTAB_TYPE)) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry has both access vectors and types\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val & AVTAB_XPERMS) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry has extended permissions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\t\tif (val & spec_order[i]) {\n\t\t\t\tkey.specified = spec_order[i] | enabled;\n\t\t\t\tdatum.u.data = le32_to_cpu(buf32[items++]);\n\t\t\t\trc = insertf(a, &key, &datum, p);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (items != items2) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry only had %d items, expected %d\\n\", items2, items);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\trc = next_entry(buf16, fp, sizeof(u16)*4);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\treturn rc;\n\t}\n\n\titems = 0;\n\tkey.source_type = le16_to_cpu(buf16[items++]);\n\tkey.target_type = le16_to_cpu(buf16[items++]);\n\tkey.target_class = le16_to_cpu(buf16[items++]);\n\tkey.specified = le16_to_cpu(buf16[items++]);\n\n\tif (!policydb_type_isvalid(pol, key.source_type) ||\n\t    !policydb_type_isvalid(pol, key.target_type) ||\n\t    !policydb_class_isvalid(pol, key.target_class)) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: invalid type or class\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tset = 0;\n\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\tif (key.specified & spec_order[i])\n\t\t\tset++;\n\t}\n\tif (!set || set > 1) {\n\t\tprintk(KERN_ERR \"SELinux:  avtab:  more than one specifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((vers < POLICYDB_VERSION_XPERMS_IOCTL) &&\n\t\t\t(key.specified & AVTAB_XPERMS)) {\n\t\tprintk(KERN_ERR \"SELinux:  avtab:  policy version %u does not \"\n\t\t\t\t\"support extended permissions rules and one \"\n\t\t\t\t\"was specified\\n\", vers);\n\t\treturn -EINVAL;\n\t} else if (key.specified & AVTAB_XPERMS) {\n\t\tmemset(&xperms, 0, sizeof(struct avtab_extended_perms));\n\t\trc = next_entry(&xperms.specified, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(&xperms.driver, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*ARRAY_SIZE(xperms.perms.p));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms.perms.p); i++)\n\t\t\txperms.perms.p[i] = le32_to_cpu(buf32[i]);\n\t\tdatum.u.xperms = &xperms;\n\t} else {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tdatum.u.data = le32_to_cpu(*buf32);\n\t}\n\tif ((key.specified & AVTAB_TYPE) &&\n\t    !policydb_type_isvalid(pol, datum.u.data)) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: invalid type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn insertf(a, &key, &datum, p);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static uint16_t spec_order[] = {\n\tAVTAB_ALLOWED,\n\tAVTAB_AUDITDENY,\n\tAVTAB_AUDITALLOW,\n\tAVTAB_TRANSITION,\n\tAVTAB_CHANGE,\n\tAVTAB_MEMBER,\n\tAVTAB_XPERMS_ALLOWED,\n\tAVTAB_XPERMS_AUDITALLOW,\n\tAVTAB_XPERMS_DONTAUDIT\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic uint16_t spec_order[] = {\n\tAVTAB_ALLOWED,\n\tAVTAB_AUDITDENY,\n\tAVTAB_AUDITALLOW,\n\tAVTAB_TRANSITION,\n\tAVTAB_CHANGE,\n\tAVTAB_MEMBER,\n\tAVTAB_XPERMS_ALLOWED,\n\tAVTAB_XPERMS_AUDITALLOW,\n\tAVTAB_XPERMS_DONTAUDIT\n};\n\nint avtab_read_item(struct avtab *a, void *fp, struct policydb *pol,\n\t\t    int (*insertf)(struct avtab *a, struct avtab_key *k,\n\t\t\t\t   struct avtab_datum *d, void *p),\n\t\t    void *p)\n{\n\t__le16 buf16[4];\n\tu16 enabled;\n\tu32 items, items2, val, vers = pol->policyvers;\n\tstruct avtab_key key;\n\tstruct avtab_datum datum;\n\tstruct avtab_extended_perms xperms;\n\t__le32 buf32[ARRAY_SIZE(xperms.perms.p)];\n\tint i, rc;\n\tunsigned set;\n\n\tmemset(&key, 0, sizeof(struct avtab_key));\n\tmemset(&datum, 0, sizeof(struct avtab_datum));\n\n\tif (vers < POLICYDB_VERSION_AVTAB) {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems2 = le32_to_cpu(buf32[0]);\n\t\tif (items2 > ARRAY_SIZE(buf32)) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry overflow\\n\");\n\t\t\treturn -EINVAL;\n\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*items2);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems = 0;\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.source_type = (u16)val;\n\t\tif (key.source_type != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated source type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_type = (u16)val;\n\t\tif (key.target_type != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated target type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_class = (u16)val;\n\t\tif (key.target_class != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated target class\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tenabled = (val & AVTAB_ENABLED_OLD) ? AVTAB_ENABLED : 0;\n\n\t\tif (!(val & (AVTAB_AV | AVTAB_TYPE))) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: null entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((val & AVTAB_AV) &&\n\t\t    (val & AVTAB_TYPE)) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry has both access vectors and types\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val & AVTAB_XPERMS) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry has extended permissions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\t\tif (val & spec_order[i]) {\n\t\t\t\tkey.specified = spec_order[i] | enabled;\n\t\t\t\tdatum.u.data = le32_to_cpu(buf32[items++]);\n\t\t\t\trc = insertf(a, &key, &datum, p);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (items != items2) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry only had %d items, expected %d\\n\", items2, items);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\trc = next_entry(buf16, fp, sizeof(u16)*4);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\treturn rc;\n\t}\n\n\titems = 0;\n\tkey.source_type = le16_to_cpu(buf16[items++]);\n\tkey.target_type = le16_to_cpu(buf16[items++]);\n\tkey.target_class = le16_to_cpu(buf16[items++]);\n\tkey.specified = le16_to_cpu(buf16[items++]);\n\n\tif (!policydb_type_isvalid(pol, key.source_type) ||\n\t    !policydb_type_isvalid(pol, key.target_type) ||\n\t    !policydb_class_isvalid(pol, key.target_class)) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: invalid type or class\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tset = 0;\n\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\tif (key.specified & spec_order[i])\n\t\t\tset++;\n\t}\n\tif (!set || set > 1) {\n\t\tprintk(KERN_ERR \"SELinux:  avtab:  more than one specifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((vers < POLICYDB_VERSION_XPERMS_IOCTL) &&\n\t\t\t(key.specified & AVTAB_XPERMS)) {\n\t\tprintk(KERN_ERR \"SELinux:  avtab:  policy version %u does not \"\n\t\t\t\t\"support extended permissions rules and one \"\n\t\t\t\t\"was specified\\n\", vers);\n\t\treturn -EINVAL;\n\t} else if (key.specified & AVTAB_XPERMS) {\n\t\tmemset(&xperms, 0, sizeof(struct avtab_extended_perms));\n\t\trc = next_entry(&xperms.specified, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(&xperms.driver, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*ARRAY_SIZE(xperms.perms.p));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms.perms.p); i++)\n\t\t\txperms.perms.p[i] = le32_to_cpu(buf32[i]);\n\t\tdatum.u.xperms = &xperms;\n\t} else {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tdatum.u.data = le32_to_cpu(*buf32);\n\t}\n\tif ((key.specified & AVTAB_TYPE) &&\n\t    !policydb_type_isvalid(pol, datum.u.data)) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: invalid type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn insertf(a, &key, &datum, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "avtab_alloc",
          "args": [
            "a",
            "nel"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "311-344",
          "snippet": "int avtab_alloc(struct avtab *h, u32 nrules)\n{\n\tu32 mask = 0;\n\tu32 shift = 0;\n\tu32 work = nrules;\n\tu32 nslot = 0;\n\n\tif (nrules == 0)\n\t\tgoto avtab_alloc_out;\n\n\twhile (work) {\n\t\twork  = work >> 1;\n\t\tshift++;\n\t}\n\tif (shift > 2)\n\t\tshift = shift - 2;\n\tnslot = 1 << shift;\n\tif (nslot > MAX_AVTAB_HASH_BUCKETS)\n\t\tnslot = MAX_AVTAB_HASH_BUCKETS;\n\tmask = nslot - 1;\n\n\th->htable = flex_array_alloc(sizeof(struct avtab_node *), nslot,\n\t\t\t\t     GFP_KERNEL | __GFP_ZERO);\n\tif (!h->htable)\n\t\treturn -ENOMEM;\n\n avtab_alloc_out:\n\th->nel = 0;\n\th->nslot = nslot;\n\th->mask = mask;\n\tprintk(KERN_DEBUG \"SELinux: %d avtab hash slots, %d rules.\\n\",\n\t       h->nslot, nrules);\n\treturn 0;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_alloc(struct avtab *h, u32 nrules)\n{\n\tu32 mask = 0;\n\tu32 shift = 0;\n\tu32 work = nrules;\n\tu32 nslot = 0;\n\n\tif (nrules == 0)\n\t\tgoto avtab_alloc_out;\n\n\twhile (work) {\n\t\twork  = work >> 1;\n\t\tshift++;\n\t}\n\tif (shift > 2)\n\t\tshift = shift - 2;\n\tnslot = 1 << shift;\n\tif (nslot > MAX_AVTAB_HASH_BUCKETS)\n\t\tnslot = MAX_AVTAB_HASH_BUCKETS;\n\tmask = nslot - 1;\n\n\th->htable = flex_array_alloc(sizeof(struct avtab_node *), nslot,\n\t\t\t\t     GFP_KERNEL | __GFP_ZERO);\n\tif (!h->htable)\n\t\treturn -ENOMEM;\n\n avtab_alloc_out:\n\th->nel = 0;\n\th->nslot = nslot;\n\th->mask = mask;\n\tprintk(KERN_DEBUG \"SELinux: %d avtab hash slots, %d rules.\\n\",\n\t       h->nslot, nrules);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: table is empty\\n\""
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf[0]"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: truncated table\\n\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf",
            "fp",
            "sizeof(u32)"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_read(struct avtab *a, void *fp, struct policydb *pol)\n{\n\tint rc;\n\t__le32 buf[1];\n\tu32 nel, i;\n\n\n\trc = next_entry(buf, fp, sizeof(u32));\n\tif (rc < 0) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: truncated table\\n\");\n\t\tgoto bad;\n\t}\n\tnel = le32_to_cpu(buf[0]);\n\tif (!nel) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: table is empty\\n\");\n\t\trc = -EINVAL;\n\t\tgoto bad;\n\t}\n\n\trc = avtab_alloc(a, nel);\n\tif (rc)\n\t\tgoto bad;\n\n\tfor (i = 0; i < nel; i++) {\n\t\trc = avtab_read_item(a, fp, pol, avtab_insertf, NULL);\n\t\tif (rc) {\n\t\t\tif (rc == -ENOMEM)\n\t\t\t\tprintk(KERN_ERR \"SELinux: avtab: out of memory\\n\");\n\t\t\telse if (rc == -EEXIST)\n\t\t\t\tprintk(KERN_ERR \"SELinux: avtab: duplicate entry\\n\");\n\n\t\t\tgoto bad;\n\t\t}\n\t}\n\n\trc = 0;\nout:\n\treturn rc;\n\nbad:\n\tavtab_destroy(a);\n\tgoto out;\n}"
  },
  {
    "function_name": "avtab_insertf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "550-554",
    "snippet": "static int avtab_insertf(struct avtab *a, struct avtab_key *k,\n\t\t\t struct avtab_datum *d, void *p)\n{\n\treturn avtab_insert(a, k, d);\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avtab_insert",
          "args": [
            "a",
            "k",
            "d"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_insert_nonunique",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "152-181",
          "snippet": "struct avtab_node *\navtab_insert_nonunique(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum)\n{\n\tint hvalue;\n\tstruct avtab_node *prev, *cur;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->htable)\n\t\treturn NULL;\n\thvalue = avtab_hash(key, h->mask);\n\tfor (prev = NULL, cur = flex_array_get_ptr(h->htable, hvalue);\n\t     cur;\n\t     prev = cur, cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\tbreak;\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn avtab_insert_node(h, hvalue, prev, cur, key, datum);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct avtab_node *\navtab_insert_nonunique(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum)\n{\n\tint hvalue;\n\tstruct avtab_node *prev, *cur;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->htable)\n\t\treturn NULL;\n\thvalue = avtab_hash(key, h->mask);\n\tfor (prev = NULL, cur = flex_array_get_ptr(h->htable, hvalue);\n\t     cur;\n\t     prev = cur, cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\tbreak;\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn avtab_insert_node(h, hvalue, prev, cur, key, datum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int avtab_insertf(struct avtab *a, struct avtab_key *k,\n\t\t\t struct avtab_datum *d, void *p)\n{\n\treturn avtab_insert(a, k, d);\n}"
  },
  {
    "function_name": "avtab_read_item",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "389-548",
    "snippet": "int avtab_read_item(struct avtab *a, void *fp, struct policydb *pol,\n\t\t    int (*insertf)(struct avtab *a, struct avtab_key *k,\n\t\t\t\t   struct avtab_datum *d, void *p),\n\t\t    void *p)\n{\n\t__le16 buf16[4];\n\tu16 enabled;\n\tu32 items, items2, val, vers = pol->policyvers;\n\tstruct avtab_key key;\n\tstruct avtab_datum datum;\n\tstruct avtab_extended_perms xperms;\n\t__le32 buf32[ARRAY_SIZE(xperms.perms.p)];\n\tint i, rc;\n\tunsigned set;\n\n\tmemset(&key, 0, sizeof(struct avtab_key));\n\tmemset(&datum, 0, sizeof(struct avtab_datum));\n\n\tif (vers < POLICYDB_VERSION_AVTAB) {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems2 = le32_to_cpu(buf32[0]);\n\t\tif (items2 > ARRAY_SIZE(buf32)) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry overflow\\n\");\n\t\t\treturn -EINVAL;\n\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*items2);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems = 0;\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.source_type = (u16)val;\n\t\tif (key.source_type != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated source type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_type = (u16)val;\n\t\tif (key.target_type != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated target type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_class = (u16)val;\n\t\tif (key.target_class != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated target class\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tenabled = (val & AVTAB_ENABLED_OLD) ? AVTAB_ENABLED : 0;\n\n\t\tif (!(val & (AVTAB_AV | AVTAB_TYPE))) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: null entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((val & AVTAB_AV) &&\n\t\t    (val & AVTAB_TYPE)) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry has both access vectors and types\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val & AVTAB_XPERMS) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry has extended permissions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\t\tif (val & spec_order[i]) {\n\t\t\t\tkey.specified = spec_order[i] | enabled;\n\t\t\t\tdatum.u.data = le32_to_cpu(buf32[items++]);\n\t\t\t\trc = insertf(a, &key, &datum, p);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (items != items2) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry only had %d items, expected %d\\n\", items2, items);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\trc = next_entry(buf16, fp, sizeof(u16)*4);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\treturn rc;\n\t}\n\n\titems = 0;\n\tkey.source_type = le16_to_cpu(buf16[items++]);\n\tkey.target_type = le16_to_cpu(buf16[items++]);\n\tkey.target_class = le16_to_cpu(buf16[items++]);\n\tkey.specified = le16_to_cpu(buf16[items++]);\n\n\tif (!policydb_type_isvalid(pol, key.source_type) ||\n\t    !policydb_type_isvalid(pol, key.target_type) ||\n\t    !policydb_class_isvalid(pol, key.target_class)) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: invalid type or class\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tset = 0;\n\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\tif (key.specified & spec_order[i])\n\t\t\tset++;\n\t}\n\tif (!set || set > 1) {\n\t\tprintk(KERN_ERR \"SELinux:  avtab:  more than one specifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((vers < POLICYDB_VERSION_XPERMS_IOCTL) &&\n\t\t\t(key.specified & AVTAB_XPERMS)) {\n\t\tprintk(KERN_ERR \"SELinux:  avtab:  policy version %u does not \"\n\t\t\t\t\"support extended permissions rules and one \"\n\t\t\t\t\"was specified\\n\", vers);\n\t\treturn -EINVAL;\n\t} else if (key.specified & AVTAB_XPERMS) {\n\t\tmemset(&xperms, 0, sizeof(struct avtab_extended_perms));\n\t\trc = next_entry(&xperms.specified, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(&xperms.driver, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*ARRAY_SIZE(xperms.perms.p));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms.perms.p); i++)\n\t\t\txperms.perms.p[i] = le32_to_cpu(buf32[i]);\n\t\tdatum.u.xperms = &xperms;\n\t} else {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tdatum.u.data = le32_to_cpu(*buf32);\n\t}\n\tif ((key.specified & AVTAB_TYPE) &&\n\t    !policydb_type_isvalid(pol, datum.u.data)) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: invalid type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn insertf(a, &key, &datum, p);\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static uint16_t spec_order[] = {\n\tAVTAB_ALLOWED,\n\tAVTAB_AUDITDENY,\n\tAVTAB_AUDITALLOW,\n\tAVTAB_TRANSITION,\n\tAVTAB_CHANGE,\n\tAVTAB_MEMBER,\n\tAVTAB_XPERMS_ALLOWED,\n\tAVTAB_XPERMS_AUDITALLOW,\n\tAVTAB_XPERMS_DONTAUDIT\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "insertf",
          "args": [
            "a",
            "&key",
            "&datum",
            "p"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_insertf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "550-554",
          "snippet": "static int avtab_insertf(struct avtab *a, struct avtab_key *k,\n\t\t\t struct avtab_datum *d, void *p)\n{\n\treturn avtab_insert(a, k, d);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int avtab_insertf(struct avtab *a, struct avtab_key *k,\n\t\t\t struct avtab_datum *d, void *p)\n{\n\treturn avtab_insert(a, k, d);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: invalid type\\n\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policydb_type_isvalid",
          "args": [
            "pol",
            "datum.u.data"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_type_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "939-944",
          "snippet": "int policydb_type_isvalid(struct policydb *p, unsigned int type)\n{\n\tif (!type || type > p->p_types.nprim)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_type_isvalid(struct policydb *p, unsigned int type)\n{\n\tif (!type || type > p->p_types.nprim)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "*buf32"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: truncated entry\\n\""
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_entry",
          "args": [
            "buf32",
            "fp",
            "sizeof(u32)"
          ],
          "line": 535
        },
        "resolved": true,
        "details": {
          "function_name": "next_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.h",
          "lines": "348-357",
          "snippet": "static inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}",
          "includes": [
            "#include \"constraint.h\"",
            "#include \"context.h\"",
            "#include \"mls_types.h\"",
            "#include \"ebitmap.h\"",
            "#include \"sidtab.h\"",
            "#include \"avtab.h\"",
            "#include \"symtab.h\"",
            "#include <linux/flex_array.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"constraint.h\"\n#include \"context.h\"\n#include \"mls_types.h\"\n#include \"ebitmap.h\"\n#include \"sidtab.h\"\n#include \"avtab.h\"\n#include \"symtab.h\"\n#include <linux/flex_array.h>\n\nstatic inline int next_entry(void *buf, struct policy_file *fp, size_t bytes)\n{\n\tif (bytes > fp->len)\n\t\treturn -EINVAL;\n\n\tmemcpy(buf, fp->data, bytes);\n\tfp->data += bytes;\n\tfp->len -= bytes;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf32[i]"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "xperms.perms.p"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: truncated entry\\n\""
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "xperms.perms.p"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: truncated entry\\n\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: truncated entry\\n\""
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&xperms",
            "0",
            "sizeof(struct avtab_extended_perms)"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  avtab:  policy version %u does not \"\n\t\t\t\t\"support extended permissions rules and one \"\n\t\t\t\t\"was specified\\n\"",
            "vers"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "aa_label_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/apparmor/label.c",
          "lines": "1803-1809",
          "snippet": "void aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}",
          "includes": [
            "#include \"include/secid.h\"",
            "#include \"include/policy.h\"",
            "#include \"include/label.h\"",
            "#include \"include/context.h\"",
            "#include \"include/apparmor.h\"",
            "#include <linux/sort.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"include/secid.h\"\n#include \"include/policy.h\"\n#include \"include/label.h\"\n#include \"include/context.h\"\n#include \"include/apparmor.h\"\n#include <linux/sort.h>\n#include <linux/seq_file.h>\n#include <linux/audit.h>\n\nvoid aa_label_printk(struct aa_label *label, gfp_t gfp)\n{\n\tstruct aa_ns *ns = aa_get_current_ns();\n\n\taa_label_xprintk(ns, label, FLAG_VIEW_SUBNS, gfp);\n\taa_put_ns(ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux:  avtab:  more than one specifier\\n\""
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "spec_order"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: invalid type or class\\n\""
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "policydb_class_isvalid",
          "args": [
            "pol",
            "key.target_class"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "policydb_class_isvalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/policydb.c",
          "lines": "925-930",
          "snippet": "int policydb_class_isvalid(struct policydb *p, unsigned int class)\n{\n\tif (!class || class > p->p_classes.nprim)\n\t\treturn 0;\n\treturn 1;\n}",
          "includes": [
            "#include \"services.h\"",
            "#include \"mls.h\"",
            "#include \"conditional.h\"",
            "#include \"policydb.h\"",
            "#include \"security.h\"",
            "#include <linux/flex_array.h>",
            "#include <linux/audit.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"services.h\"\n#include \"mls.h\"\n#include \"conditional.h\"\n#include \"policydb.h\"\n#include \"security.h\"\n#include <linux/flex_array.h>\n#include <linux/audit.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n\nint policydb_class_isvalid(struct policydb *p, unsigned int class)\n{\n\tif (!class || class > p->p_classes.nprim)\n\t\treturn 0;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "buf16[items++]"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "buf16[items++]"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "buf16[items++]"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le16_to_cpu",
          "args": [
            "buf16[items++]"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: truncated entry\\n\""
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: entry only had %d items, expected %d\\n\"",
            "items2",
            "items"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf32[items++]"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "spec_order"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: entry has extended permissions\\n\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: entry has both access vectors and types\\n\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: null entry\\n\""
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf32[items++]"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: truncated target class\\n\""
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf32[items++]"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: truncated target type\\n\""
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf32[items++]"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: truncated source type\\n\""
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf32[items++]"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: truncated entry\\n\""
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: entry overflow\\n\""
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "buf32"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "le32_to_cpu",
          "args": [
            "buf32[0]"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"SELinux: avtab: truncated entry\\n\""
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&datum",
            "0",
            "sizeof(struct avtab_datum)"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&key",
            "0",
            "sizeof(struct avtab_key)"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "xperms.perms.p"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic uint16_t spec_order[] = {\n\tAVTAB_ALLOWED,\n\tAVTAB_AUDITDENY,\n\tAVTAB_AUDITALLOW,\n\tAVTAB_TRANSITION,\n\tAVTAB_CHANGE,\n\tAVTAB_MEMBER,\n\tAVTAB_XPERMS_ALLOWED,\n\tAVTAB_XPERMS_AUDITALLOW,\n\tAVTAB_XPERMS_DONTAUDIT\n};\n\nint avtab_read_item(struct avtab *a, void *fp, struct policydb *pol,\n\t\t    int (*insertf)(struct avtab *a, struct avtab_key *k,\n\t\t\t\t   struct avtab_datum *d, void *p),\n\t\t    void *p)\n{\n\t__le16 buf16[4];\n\tu16 enabled;\n\tu32 items, items2, val, vers = pol->policyvers;\n\tstruct avtab_key key;\n\tstruct avtab_datum datum;\n\tstruct avtab_extended_perms xperms;\n\t__le32 buf32[ARRAY_SIZE(xperms.perms.p)];\n\tint i, rc;\n\tunsigned set;\n\n\tmemset(&key, 0, sizeof(struct avtab_key));\n\tmemset(&datum, 0, sizeof(struct avtab_datum));\n\n\tif (vers < POLICYDB_VERSION_AVTAB) {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems2 = le32_to_cpu(buf32[0]);\n\t\tif (items2 > ARRAY_SIZE(buf32)) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry overflow\\n\");\n\t\t\treturn -EINVAL;\n\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*items2);\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\titems = 0;\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.source_type = (u16)val;\n\t\tif (key.source_type != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated source type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_type = (u16)val;\n\t\tif (key.target_type != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated target type\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tkey.target_class = (u16)val;\n\t\tif (key.target_class != val) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated target class\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tval = le32_to_cpu(buf32[items++]);\n\t\tenabled = (val & AVTAB_ENABLED_OLD) ? AVTAB_ENABLED : 0;\n\n\t\tif (!(val & (AVTAB_AV | AVTAB_TYPE))) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: null entry\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif ((val & AVTAB_AV) &&\n\t\t    (val & AVTAB_TYPE)) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry has both access vectors and types\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (val & AVTAB_XPERMS) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry has extended permissions\\n\");\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\t\tif (val & spec_order[i]) {\n\t\t\t\tkey.specified = spec_order[i] | enabled;\n\t\t\t\tdatum.u.data = le32_to_cpu(buf32[items++]);\n\t\t\t\trc = insertf(a, &key, &datum, p);\n\t\t\t\tif (rc)\n\t\t\t\t\treturn rc;\n\t\t\t}\n\t\t}\n\n\t\tif (items != items2) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: entry only had %d items, expected %d\\n\", items2, items);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\treturn 0;\n\t}\n\n\trc = next_entry(buf16, fp, sizeof(u16)*4);\n\tif (rc) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\treturn rc;\n\t}\n\n\titems = 0;\n\tkey.source_type = le16_to_cpu(buf16[items++]);\n\tkey.target_type = le16_to_cpu(buf16[items++]);\n\tkey.target_class = le16_to_cpu(buf16[items++]);\n\tkey.specified = le16_to_cpu(buf16[items++]);\n\n\tif (!policydb_type_isvalid(pol, key.source_type) ||\n\t    !policydb_type_isvalid(pol, key.target_type) ||\n\t    !policydb_class_isvalid(pol, key.target_class)) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: invalid type or class\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tset = 0;\n\tfor (i = 0; i < ARRAY_SIZE(spec_order); i++) {\n\t\tif (key.specified & spec_order[i])\n\t\t\tset++;\n\t}\n\tif (!set || set > 1) {\n\t\tprintk(KERN_ERR \"SELinux:  avtab:  more than one specifier\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif ((vers < POLICYDB_VERSION_XPERMS_IOCTL) &&\n\t\t\t(key.specified & AVTAB_XPERMS)) {\n\t\tprintk(KERN_ERR \"SELinux:  avtab:  policy version %u does not \"\n\t\t\t\t\"support extended permissions rules and one \"\n\t\t\t\t\"was specified\\n\", vers);\n\t\treturn -EINVAL;\n\t} else if (key.specified & AVTAB_XPERMS) {\n\t\tmemset(&xperms, 0, sizeof(struct avtab_extended_perms));\n\t\trc = next_entry(&xperms.specified, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(&xperms.driver, fp, sizeof(u8));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\trc = next_entry(buf32, fp, sizeof(u32)*ARRAY_SIZE(xperms.perms.p));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(xperms.perms.p); i++)\n\t\t\txperms.perms.p[i] = le32_to_cpu(buf32[i]);\n\t\tdatum.u.xperms = &xperms;\n\t} else {\n\t\trc = next_entry(buf32, fp, sizeof(u32));\n\t\tif (rc) {\n\t\t\tprintk(KERN_ERR \"SELinux: avtab: truncated entry\\n\");\n\t\t\treturn rc;\n\t\t}\n\t\tdatum.u.data = le32_to_cpu(*buf32);\n\t}\n\tif ((key.specified & AVTAB_TYPE) &&\n\t    !policydb_type_isvalid(pol, datum.u.data)) {\n\t\tprintk(KERN_ERR \"SELinux: avtab: invalid type\\n\");\n\t\treturn -EINVAL;\n\t}\n\treturn insertf(a, &key, &datum, p);\n}"
  },
  {
    "function_name": "avtab_hash_eval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "346-375",
    "snippet": "void avtab_hash_eval(struct avtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += chain_len * chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\"",
            "tag",
            "h->nel",
            "slots_used",
            "h->nslot",
            "max_chain_len",
            "chain2_len_sum"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get_ptr",
          "args": [
            "h->htable",
            "i"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid avtab_hash_eval(struct avtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += chain_len * chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}"
  },
  {
    "function_name": "avtab_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "311-344",
    "snippet": "int avtab_alloc(struct avtab *h, u32 nrules)\n{\n\tu32 mask = 0;\n\tu32 shift = 0;\n\tu32 work = nrules;\n\tu32 nslot = 0;\n\n\tif (nrules == 0)\n\t\tgoto avtab_alloc_out;\n\n\twhile (work) {\n\t\twork  = work >> 1;\n\t\tshift++;\n\t}\n\tif (shift > 2)\n\t\tshift = shift - 2;\n\tnslot = 1 << shift;\n\tif (nslot > MAX_AVTAB_HASH_BUCKETS)\n\t\tnslot = MAX_AVTAB_HASH_BUCKETS;\n\tmask = nslot - 1;\n\n\th->htable = flex_array_alloc(sizeof(struct avtab_node *), nslot,\n\t\t\t\t     GFP_KERNEL | __GFP_ZERO);\n\tif (!h->htable)\n\t\treturn -ENOMEM;\n\n avtab_alloc_out:\n\th->nel = 0;\n\th->nslot = nslot;\n\th->mask = mask;\n\tprintk(KERN_DEBUG \"SELinux: %d avtab hash slots, %d rules.\\n\",\n\t       h->nslot, nrules);\n\treturn 0;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"SELinux: %d avtab hash slots, %d rules.\\n\"",
            "h->nslot",
            "nrules"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_alloc",
          "args": [
            "sizeof(struct avtab_node *)",
            "nslot",
            "GFP_KERNEL | __GFP_ZERO"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_alloc(struct avtab *h, u32 nrules)\n{\n\tu32 mask = 0;\n\tu32 shift = 0;\n\tu32 work = nrules;\n\tu32 nslot = 0;\n\n\tif (nrules == 0)\n\t\tgoto avtab_alloc_out;\n\n\twhile (work) {\n\t\twork  = work >> 1;\n\t\tshift++;\n\t}\n\tif (shift > 2)\n\t\tshift = shift - 2;\n\tnslot = 1 << shift;\n\tif (nslot > MAX_AVTAB_HASH_BUCKETS)\n\t\tnslot = MAX_AVTAB_HASH_BUCKETS;\n\tmask = nslot - 1;\n\n\th->htable = flex_array_alloc(sizeof(struct avtab_node *), nslot,\n\t\t\t\t     GFP_KERNEL | __GFP_ZERO);\n\tif (!h->htable)\n\t\treturn -ENOMEM;\n\n avtab_alloc_out:\n\th->nel = 0;\n\th->nslot = nslot;\n\th->mask = mask;\n\tprintk(KERN_DEBUG \"SELinux: %d avtab hash slots, %d rules.\\n\",\n\t       h->nslot, nrules);\n\treturn 0;\n}"
  },
  {
    "function_name": "avtab_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "304-309",
    "snippet": "int avtab_init(struct avtab *h)\n{\n\th->htable = NULL;\n\th->nel = 0;\n\treturn 0;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nint avtab_init(struct avtab *h)\n{\n\th->htable = NULL;\n\th->nel = 0;\n\treturn 0;\n}"
  },
  {
    "function_name": "avtab_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "279-302",
    "snippet": "void avtab_destroy(struct avtab *h)\n{\n\tint i;\n\tstruct avtab_node *cur, *temp;\n\n\tif (!h || !h->htable)\n\t\treturn;\n\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tif (temp->key.specified & AVTAB_XPERMS)\n\t\t\t\tkmem_cache_free(avtab_xperms_cachep,\n\t\t\t\t\t\ttemp->datum.u.xperms);\n\t\t\tkmem_cache_free(avtab_node_cachep, temp);\n\t\t}\n\t}\n\tflex_array_free(h->htable);\n\th->htable = NULL;\n\th->nslot = 0;\n\th->mask = 0;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *avtab_node_cachep;",
      "static struct kmem_cache *avtab_xperms_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "flex_array_free",
          "args": [
            "h->htable"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avtab_node_cachep",
            "temp"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avtab_xperms_cachep",
            "temp->datum.u.xperms"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get_ptr",
          "args": [
            "h->htable",
            "i"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *avtab_node_cachep;\nstatic struct kmem_cache *avtab_xperms_cachep;\n\nvoid avtab_destroy(struct avtab *h)\n{\n\tint i;\n\tstruct avtab_node *cur, *temp;\n\n\tif (!h || !h->htable)\n\t\treturn;\n\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\twhile (cur) {\n\t\t\ttemp = cur;\n\t\t\tcur = cur->next;\n\t\t\tif (temp->key.specified & AVTAB_XPERMS)\n\t\t\t\tkmem_cache_free(avtab_xperms_cachep,\n\t\t\t\t\t\ttemp->datum.u.xperms);\n\t\t\tkmem_cache_free(avtab_node_cachep, temp);\n\t\t}\n\t}\n\tflex_array_free(h->htable);\n\th->htable = NULL;\n\th->nslot = 0;\n\th->mask = 0;\n}"
  },
  {
    "function_name": "avtab_search_node_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "250-277",
    "snippet": "struct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct avtab_node*\navtab_search_node_next(struct avtab_node *node, int specified)\n{\n\tstruct avtab_node *cur;\n\n\tif (!node)\n\t\treturn NULL;\n\n\tspecified &= ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\tfor (cur = node->next; cur; cur = cur->next) {\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (node->key.source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (node->key.source_type == cur->key.source_type &&\n\t\t    node->key.target_type == cur->key.target_type &&\n\t\t    node->key.target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "avtab_search_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "218-248",
    "snippet": "struct avtab_node*\navtab_search_node(struct avtab *h, struct avtab_key *key)\n{\n\tint hvalue;\n\tstruct avtab_node *cur;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->htable)\n\t\treturn NULL;\n\n\thvalue = avtab_hash(key, h->mask);\n\tfor (cur = flex_array_get_ptr(h->htable, hvalue); cur;\n\t     cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flex_array_get_ptr",
          "args": [
            "h->htable",
            "hvalue"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avtab_hash",
          "args": [
            "key",
            "h->mask"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_hash_eval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "346-375",
          "snippet": "void avtab_hash_eval(struct avtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += chain_len * chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid avtab_hash_eval(struct avtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += chain_len * chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct avtab_node*\navtab_search_node(struct avtab *h, struct avtab_key *key)\n{\n\tint hvalue;\n\tstruct avtab_node *cur;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->htable)\n\t\treturn NULL;\n\n\thvalue = avtab_hash(key, h->mask);\n\tfor (cur = flex_array_get_ptr(h->htable, hvalue); cur;\n\t     cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn cur;\n\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "avtab_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "183-213",
    "snippet": "struct avtab_datum *avtab_search(struct avtab *h, struct avtab_key *key)\n{\n\tint hvalue;\n\tstruct avtab_node *cur;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->htable)\n\t\treturn NULL;\n\n\thvalue = avtab_hash(key, h->mask);\n\tfor (cur = flex_array_get_ptr(h->htable, hvalue); cur;\n\t     cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn &cur->datum;\n\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flex_array_get_ptr",
          "args": [
            "h->htable",
            "hvalue"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avtab_hash",
          "args": [
            "key",
            "h->mask"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_hash_eval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "346-375",
          "snippet": "void avtab_hash_eval(struct avtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += chain_len * chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid avtab_hash_eval(struct avtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += chain_len * chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct avtab_datum *avtab_search(struct avtab *h, struct avtab_key *key)\n{\n\tint hvalue;\n\tstruct avtab_node *cur;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->htable)\n\t\treturn NULL;\n\n\thvalue = avtab_hash(key, h->mask);\n\tfor (cur = flex_array_get_ptr(h->htable, hvalue); cur;\n\t     cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\treturn &cur->datum;\n\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "avtab_insert_nonunique",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "152-181",
    "snippet": "struct avtab_node *\navtab_insert_nonunique(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum)\n{\n\tint hvalue;\n\tstruct avtab_node *prev, *cur;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->htable)\n\t\treturn NULL;\n\thvalue = avtab_hash(key, h->mask);\n\tfor (prev = NULL, cur = flex_array_get_ptr(h->htable, hvalue);\n\t     cur;\n\t     prev = cur, cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\tbreak;\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn avtab_insert_node(h, hvalue, prev, cur, key, datum);\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avtab_insert_node",
          "args": [
            "h",
            "hvalue",
            "prev",
            "cur",
            "key",
            "datum"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_insert_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "68-106",
          "snippet": "static struct avtab_node*\navtab_insert_node(struct avtab *h, int hvalue,\n\t\t  struct avtab_node *prev, struct avtab_node *cur,\n\t\t  struct avtab_key *key, struct avtab_datum *datum)\n{\n\tstruct avtab_node *newnode;\n\tstruct avtab_extended_perms *xperms;\n\tnewnode = kmem_cache_zalloc(avtab_node_cachep, GFP_KERNEL);\n\tif (newnode == NULL)\n\t\treturn NULL;\n\tnewnode->key = *key;\n\n\tif (key->specified & AVTAB_XPERMS) {\n\t\txperms = kmem_cache_zalloc(avtab_xperms_cachep, GFP_KERNEL);\n\t\tif (xperms == NULL) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t\t*xperms = *(datum->u.xperms);\n\t\tnewnode->datum.u.xperms = xperms;\n\t} else {\n\t\tnewnode->datum.u.data = datum->u.data;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = flex_array_get_ptr(h->htable, hvalue);\n\t\tif (flex_array_put_ptr(h->htable, hvalue, newnode,\n\t\t\t\t       GFP_KERNEL|__GFP_ZERO)) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\th->nel++;\n\treturn newnode;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avtab_node_cachep;",
            "static struct kmem_cache *avtab_xperms_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *avtab_node_cachep;\nstatic struct kmem_cache *avtab_xperms_cachep;\n\nstatic struct avtab_node*\navtab_insert_node(struct avtab *h, int hvalue,\n\t\t  struct avtab_node *prev, struct avtab_node *cur,\n\t\t  struct avtab_key *key, struct avtab_datum *datum)\n{\n\tstruct avtab_node *newnode;\n\tstruct avtab_extended_perms *xperms;\n\tnewnode = kmem_cache_zalloc(avtab_node_cachep, GFP_KERNEL);\n\tif (newnode == NULL)\n\t\treturn NULL;\n\tnewnode->key = *key;\n\n\tif (key->specified & AVTAB_XPERMS) {\n\t\txperms = kmem_cache_zalloc(avtab_xperms_cachep, GFP_KERNEL);\n\t\tif (xperms == NULL) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t\t*xperms = *(datum->u.xperms);\n\t\tnewnode->datum.u.xperms = xperms;\n\t} else {\n\t\tnewnode->datum.u.data = datum->u.data;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = flex_array_get_ptr(h->htable, hvalue);\n\t\tif (flex_array_put_ptr(h->htable, hvalue, newnode,\n\t\t\t\t       GFP_KERNEL|__GFP_ZERO)) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\th->nel++;\n\treturn newnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flex_array_get_ptr",
          "args": [
            "h->htable",
            "hvalue"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avtab_hash",
          "args": [
            "key",
            "h->mask"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_hash_eval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "346-375",
          "snippet": "void avtab_hash_eval(struct avtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += chain_len * chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid avtab_hash_eval(struct avtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += chain_len * chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstruct avtab_node *\navtab_insert_nonunique(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum)\n{\n\tint hvalue;\n\tstruct avtab_node *prev, *cur;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->htable)\n\t\treturn NULL;\n\thvalue = avtab_hash(key, h->mask);\n\tfor (prev = NULL, cur = flex_array_get_ptr(h->htable, hvalue);\n\t     cur;\n\t     prev = cur, cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified))\n\t\t\tbreak;\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\treturn avtab_insert_node(h, hvalue, prev, cur, key, datum);\n}"
  },
  {
    "function_name": "avtab_insert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "108-146",
    "snippet": "static int avtab_insert(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum)\n{\n\tint hvalue;\n\tstruct avtab_node *prev, *cur, *newnode;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->htable)\n\t\treturn -EINVAL;\n\n\thvalue = avtab_hash(key, h->mask);\n\tfor (prev = NULL, cur = flex_array_get_ptr(h->htable, hvalue);\n\t     cur;\n\t     prev = cur, cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified)) {\n\t\t\t/* extended perms may not be unique */\n\t\t\tif (specified & AVTAB_XPERMS)\n\t\t\t\tbreak;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\n\tnewnode = avtab_insert_node(h, hvalue, prev, cur, key, datum);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "avtab_insert_node",
          "args": [
            "h",
            "hvalue",
            "prev",
            "cur",
            "key",
            "datum"
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_insert_node",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "68-106",
          "snippet": "static struct avtab_node*\navtab_insert_node(struct avtab *h, int hvalue,\n\t\t  struct avtab_node *prev, struct avtab_node *cur,\n\t\t  struct avtab_key *key, struct avtab_datum *datum)\n{\n\tstruct avtab_node *newnode;\n\tstruct avtab_extended_perms *xperms;\n\tnewnode = kmem_cache_zalloc(avtab_node_cachep, GFP_KERNEL);\n\tif (newnode == NULL)\n\t\treturn NULL;\n\tnewnode->key = *key;\n\n\tif (key->specified & AVTAB_XPERMS) {\n\t\txperms = kmem_cache_zalloc(avtab_xperms_cachep, GFP_KERNEL);\n\t\tif (xperms == NULL) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t\t*xperms = *(datum->u.xperms);\n\t\tnewnode->datum.u.xperms = xperms;\n\t} else {\n\t\tnewnode->datum.u.data = datum->u.data;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = flex_array_get_ptr(h->htable, hvalue);\n\t\tif (flex_array_put_ptr(h->htable, hvalue, newnode,\n\t\t\t\t       GFP_KERNEL|__GFP_ZERO)) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\th->nel++;\n\treturn newnode;\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *avtab_node_cachep;",
            "static struct kmem_cache *avtab_xperms_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *avtab_node_cachep;\nstatic struct kmem_cache *avtab_xperms_cachep;\n\nstatic struct avtab_node*\navtab_insert_node(struct avtab *h, int hvalue,\n\t\t  struct avtab_node *prev, struct avtab_node *cur,\n\t\t  struct avtab_key *key, struct avtab_datum *datum)\n{\n\tstruct avtab_node *newnode;\n\tstruct avtab_extended_perms *xperms;\n\tnewnode = kmem_cache_zalloc(avtab_node_cachep, GFP_KERNEL);\n\tif (newnode == NULL)\n\t\treturn NULL;\n\tnewnode->key = *key;\n\n\tif (key->specified & AVTAB_XPERMS) {\n\t\txperms = kmem_cache_zalloc(avtab_xperms_cachep, GFP_KERNEL);\n\t\tif (xperms == NULL) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t\t*xperms = *(datum->u.xperms);\n\t\tnewnode->datum.u.xperms = xperms;\n\t} else {\n\t\tnewnode->datum.u.data = datum->u.data;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = flex_array_get_ptr(h->htable, hvalue);\n\t\tif (flex_array_put_ptr(h->htable, hvalue, newnode,\n\t\t\t\t       GFP_KERNEL|__GFP_ZERO)) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\th->nel++;\n\treturn newnode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "flex_array_get_ptr",
          "args": [
            "h->htable",
            "hvalue"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "avtab_hash",
          "args": [
            "key",
            "h->mask"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "avtab_hash_eval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
          "lines": "346-375",
          "snippet": "void avtab_hash_eval(struct avtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += chain_len * chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}",
          "includes": [
            "#include \"policydb.h\"",
            "#include \"avtab.h\"",
            "#include <linux/errno.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nvoid avtab_hash_eval(struct avtab *h, char *tag)\n{\n\tint i, chain_len, slots_used, max_chain_len;\n\tunsigned long long chain2_len_sum;\n\tstruct avtab_node *cur;\n\n\tslots_used = 0;\n\tmax_chain_len = 0;\n\tchain2_len_sum = 0;\n\tfor (i = 0; i < h->nslot; i++) {\n\t\tcur = flex_array_get_ptr(h->htable, i);\n\t\tif (cur) {\n\t\t\tslots_used++;\n\t\t\tchain_len = 0;\n\t\t\twhile (cur) {\n\t\t\t\tchain_len++;\n\t\t\t\tcur = cur->next;\n\t\t\t}\n\n\t\t\tif (chain_len > max_chain_len)\n\t\t\t\tmax_chain_len = chain_len;\n\t\t\tchain2_len_sum += chain_len * chain_len;\n\t\t}\n\t}\n\n\tprintk(KERN_DEBUG \"SELinux: %s:  %d entries and %d/%d buckets used, \"\n\t       \"longest chain length %d sum of chain length^2 %llu\\n\",\n\t       tag, h->nel, slots_used, h->nslot, max_chain_len,\n\t       chain2_len_sum);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic int avtab_insert(struct avtab *h, struct avtab_key *key, struct avtab_datum *datum)\n{\n\tint hvalue;\n\tstruct avtab_node *prev, *cur, *newnode;\n\tu16 specified = key->specified & ~(AVTAB_ENABLED|AVTAB_ENABLED_OLD);\n\n\tif (!h || !h->htable)\n\t\treturn -EINVAL;\n\n\thvalue = avtab_hash(key, h->mask);\n\tfor (prev = NULL, cur = flex_array_get_ptr(h->htable, hvalue);\n\t     cur;\n\t     prev = cur, cur = cur->next) {\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class == cur->key.target_class &&\n\t\t    (specified & cur->key.specified)) {\n\t\t\t/* extended perms may not be unique */\n\t\t\tif (specified & AVTAB_XPERMS)\n\t\t\t\tbreak;\n\t\t\treturn -EEXIST;\n\t\t}\n\t\tif (key->source_type < cur->key.source_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type < cur->key.target_type)\n\t\t\tbreak;\n\t\tif (key->source_type == cur->key.source_type &&\n\t\t    key->target_type == cur->key.target_type &&\n\t\t    key->target_class < cur->key.target_class)\n\t\t\tbreak;\n\t}\n\n\tnewnode = avtab_insert_node(h, hvalue, prev, cur, key, datum);\n\tif (!newnode)\n\t\treturn -ENOMEM;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "avtab_insert_node",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "68-106",
    "snippet": "static struct avtab_node*\navtab_insert_node(struct avtab *h, int hvalue,\n\t\t  struct avtab_node *prev, struct avtab_node *cur,\n\t\t  struct avtab_key *key, struct avtab_datum *datum)\n{\n\tstruct avtab_node *newnode;\n\tstruct avtab_extended_perms *xperms;\n\tnewnode = kmem_cache_zalloc(avtab_node_cachep, GFP_KERNEL);\n\tif (newnode == NULL)\n\t\treturn NULL;\n\tnewnode->key = *key;\n\n\tif (key->specified & AVTAB_XPERMS) {\n\t\txperms = kmem_cache_zalloc(avtab_xperms_cachep, GFP_KERNEL);\n\t\tif (xperms == NULL) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t\t*xperms = *(datum->u.xperms);\n\t\tnewnode->datum.u.xperms = xperms;\n\t} else {\n\t\tnewnode->datum.u.data = datum->u.data;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = flex_array_get_ptr(h->htable, hvalue);\n\t\tif (flex_array_put_ptr(h->htable, hvalue, newnode,\n\t\t\t\t       GFP_KERNEL|__GFP_ZERO)) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\th->nel++;\n\treturn newnode;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *avtab_node_cachep;",
      "static struct kmem_cache *avtab_xperms_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avtab_node_cachep",
            "newnode"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_put_ptr",
          "args": [
            "h->htable",
            "hvalue",
            "newnode",
            "GFP_KERNEL|__GFP_ZERO"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flex_array_get_ptr",
          "args": [
            "h->htable",
            "hvalue"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "avtab_node_cachep",
            "newnode"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "avtab_xperms_cachep",
            "GFP_KERNEL"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "avtab_node_cachep",
            "GFP_KERNEL"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic struct kmem_cache *avtab_node_cachep;\nstatic struct kmem_cache *avtab_xperms_cachep;\n\nstatic struct avtab_node*\navtab_insert_node(struct avtab *h, int hvalue,\n\t\t  struct avtab_node *prev, struct avtab_node *cur,\n\t\t  struct avtab_key *key, struct avtab_datum *datum)\n{\n\tstruct avtab_node *newnode;\n\tstruct avtab_extended_perms *xperms;\n\tnewnode = kmem_cache_zalloc(avtab_node_cachep, GFP_KERNEL);\n\tif (newnode == NULL)\n\t\treturn NULL;\n\tnewnode->key = *key;\n\n\tif (key->specified & AVTAB_XPERMS) {\n\t\txperms = kmem_cache_zalloc(avtab_xperms_cachep, GFP_KERNEL);\n\t\tif (xperms == NULL) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t\t*xperms = *(datum->u.xperms);\n\t\tnewnode->datum.u.xperms = xperms;\n\t} else {\n\t\tnewnode->datum.u.data = datum->u.data;\n\t}\n\n\tif (prev) {\n\t\tnewnode->next = prev->next;\n\t\tprev->next = newnode;\n\t} else {\n\t\tnewnode->next = flex_array_get_ptr(h->htable, hvalue);\n\t\tif (flex_array_put_ptr(h->htable, hvalue, newnode,\n\t\t\t\t       GFP_KERNEL|__GFP_ZERO)) {\n\t\t\tkmem_cache_free(avtab_node_cachep, newnode);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\th->nel++;\n\treturn newnode;\n}"
  },
  {
    "function_name": "avtab_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/selinux/ss/avtab.c",
    "lines": "32-66",
    "snippet": "static inline int avtab_hash(struct avtab_key *keyp, u32 mask)\n{\n\tstatic const u32 c1 = 0xcc9e2d51;\n\tstatic const u32 c2 = 0x1b873593;\n\tstatic const u32 r1 = 15;\n\tstatic const u32 r2 = 13;\n\tstatic const u32 m  = 5;\n\tstatic const u32 n  = 0xe6546b64;\n\n\tu32 hash = 0;\n\n#define mix(input) { \\\n\tu32 v = input; \\\n\tv *= c1; \\\n\tv = (v << r1) | (v >> (32 - r1)); \\\n\tv *= c2; \\\n\thash ^= v; \\\n\thash = (hash << r2) | (hash >> (32 - r2)); \\\n\thash = hash * m + n; \\\n}\n\n\tmix(keyp->target_class);\n\tmix(keyp->target_type);\n\tmix(keyp->source_type);\n\n#undef mix\n\n\thash ^= hash >> 16;\n\thash *= 0x85ebca6b;\n\thash ^= hash >> 13;\n\thash *= 0xc2b2ae35;\n\thash ^= hash >> 16;\n\n\treturn hash & mask;\n}",
    "includes": [
      "#include \"policydb.h\"",
      "#include \"avtab.h\"",
      "#include <linux/errno.h>",
      "#include <linux/slab.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mix",
          "args": [
            "keyp->source_type"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "warn_setuid_and_fcaps_mixed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2017-17807/repo/security/commoncap.c",
          "lines": "45-54",
          "snippet": "static void warn_setuid_and_fcaps_mixed(const char *fname)\n{\n\tstatic int warned;\n\tif (!warned) {\n\t\tprintk(KERN_INFO \"warning: `%s' has both setuid-root and\"\n\t\t\t\" effective capabilities. Therefore not raising all\"\n\t\t\t\" capabilities.\\n\", fname);\n\t\twarned = 1;\n\t}\n}",
          "includes": [
            "#include <linux/personality.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/securebits.h>",
            "#include <linux/prctl.h>",
            "#include <linux/sched.h>",
            "#include <linux/mount.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/xattr.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/netlink.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/swap.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mman.h>",
            "#include <linux/mm.h>",
            "#include <linux/file.h>",
            "#include <linux/lsm_hooks.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/personality.h>\n#include <linux/binfmts.h>\n#include <linux/user_namespace.h>\n#include <linux/securebits.h>\n#include <linux/prctl.h>\n#include <linux/sched.h>\n#include <linux/mount.h>\n#include <linux/hugetlb.h>\n#include <linux/xattr.h>\n#include <linux/ptrace.h>\n#include <linux/netlink.h>\n#include <linux/skbuff.h>\n#include <linux/swap.h>\n#include <linux/pagemap.h>\n#include <linux/mman.h>\n#include <linux/mm.h>\n#include <linux/file.h>\n#include <linux/lsm_hooks.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/audit.h>\n#include <linux/capability.h>\n\nstatic void warn_setuid_and_fcaps_mixed(const char *fname)\n{\n\tstatic int warned;\n\tif (!warned) {\n\t\tprintk(KERN_INFO \"warning: `%s' has both setuid-root and\"\n\t\t\t\" effective capabilities. Therefore not raising all\"\n\t\t\t\" capabilities.\\n\", fname);\n\t\twarned = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"policydb.h\"\n#include \"avtab.h\"\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n\nstatic inline int avtab_hash(struct avtab_key *keyp, u32 mask)\n{\n\tstatic const u32 c1 = 0xcc9e2d51;\n\tstatic const u32 c2 = 0x1b873593;\n\tstatic const u32 r1 = 15;\n\tstatic const u32 r2 = 13;\n\tstatic const u32 m  = 5;\n\tstatic const u32 n  = 0xe6546b64;\n\n\tu32 hash = 0;\n\n#define mix(input) { \\\n\tu32 v = input; \\\n\tv *= c1; \\\n\tv = (v << r1) | (v >> (32 - r1)); \\\n\tv *= c2; \\\n\thash ^= v; \\\n\thash = (hash << r2) | (hash >> (32 - r2)); \\\n\thash = hash * m + n; \\\n}\n\n\tmix(keyp->target_class);\n\tmix(keyp->target_type);\n\tmix(keyp->source_type);\n\n#undef mix\n\n\thash ^= hash >> 16;\n\thash *= 0x85ebca6b;\n\thash ^= hash >> 13;\n\thash *= 0xc2b2ae35;\n\thash ^= hash >> 16;\n\n\treturn hash & mask;\n}"
  }
]