[
  {
    "function_name": "setup_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_seccomp.c",
    "lines": "137-174",
    "snippet": "void setup_seccomp(bool enable_syslog)\n{\n    scmp_filter_ctx ctx;\n\n#ifdef SCMP_ACT_KILL_PROCESS\n    ctx = seccomp_init(SCMP_ACT_KILL_PROCESS);\n    /* Handle a newer libseccomp but an older kernel */\n    if (!ctx && errno == EOPNOTSUPP) {\n        ctx = seccomp_init(SCMP_ACT_TRAP);\n    }\n#else\n    ctx = seccomp_init(SCMP_ACT_TRAP);\n#endif\n    if (!ctx) {\n        fuse_log(FUSE_LOG_ERR, \"seccomp_init() failed\\n\");\n        exit(1);\n    }\n\n    add_whitelist(ctx, syscall_whitelist, G_N_ELEMENTS(syscall_whitelist));\n    if (enable_syslog) {\n        add_whitelist(ctx, syscall_whitelist_syslog,\n                      G_N_ELEMENTS(syscall_whitelist_syslog));\n    }\n\n    /* libvhost-user calls this for post-copy migration, we don't need it */\n    if (seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS),\n                         SCMP_SYS(userfaultfd), 0) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"seccomp_rule_add userfaultfd failed\\n\");\n        exit(1);\n    }\n\n    if (seccomp_load(ctx) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"seccomp_load() failed\\n\");\n        exit(1);\n    }\n\n    seccomp_release(ctx);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <seccomp.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include \"fuse_log.h\"",
      "#include \"fuse_i.h\"",
      "#include \"passthrough_seccomp.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const int syscall_whitelist[] = {\n    /* TODO ireg sem*() syscalls */\n    SCMP_SYS(brk),\n    SCMP_SYS(capget), /* For CAP_FSETID */\n    SCMP_SYS(capset),\n    SCMP_SYS(clock_gettime),\n    SCMP_SYS(clone),\n#ifdef __NR_clone3\n    SCMP_SYS(clone3),\n#endif\n    SCMP_SYS(close),\n    SCMP_SYS(copy_file_range),\n    SCMP_SYS(dup),\n    SCMP_SYS(eventfd2),\n    SCMP_SYS(exit),\n    SCMP_SYS(exit_group),\n    SCMP_SYS(fallocate),\n    SCMP_SYS(fchdir),\n    SCMP_SYS(fchmod),\n    SCMP_SYS(fchmodat),\n    SCMP_SYS(fchownat),\n    SCMP_SYS(fcntl),\n    SCMP_SYS(fdatasync),\n    SCMP_SYS(fgetxattr),\n    SCMP_SYS(flistxattr),\n    SCMP_SYS(flock),\n    SCMP_SYS(fremovexattr),\n    SCMP_SYS(fsetxattr),\n    SCMP_SYS(fstat),\n    SCMP_SYS(fstatfs),\n    SCMP_SYS(fsync),\n    SCMP_SYS(ftruncate),\n    SCMP_SYS(futex),\n    SCMP_SYS(getdents),\n    SCMP_SYS(getdents64),\n    SCMP_SYS(getegid),\n    SCMP_SYS(geteuid),\n    SCMP_SYS(getpid),\n    SCMP_SYS(gettid),\n    SCMP_SYS(gettimeofday),\n    SCMP_SYS(getxattr),\n    SCMP_SYS(linkat),\n    SCMP_SYS(listxattr),\n    SCMP_SYS(lseek),\n    SCMP_SYS(madvise),\n    SCMP_SYS(mkdirat),\n    SCMP_SYS(mknodat),\n    SCMP_SYS(mmap),\n    SCMP_SYS(mprotect),\n    SCMP_SYS(mremap),\n    SCMP_SYS(munmap),\n    SCMP_SYS(newfstatat),\n    SCMP_SYS(open),\n    SCMP_SYS(openat),\n    SCMP_SYS(ppoll),\n    SCMP_SYS(prctl), /* TODO restrict to just PR_SET_NAME? */\n    SCMP_SYS(preadv),\n    SCMP_SYS(pread64),\n    SCMP_SYS(pwritev),\n    SCMP_SYS(pwrite64),\n    SCMP_SYS(read),\n    SCMP_SYS(readlinkat),\n    SCMP_SYS(recvmsg),\n    SCMP_SYS(renameat),\n    SCMP_SYS(renameat2),\n    SCMP_SYS(removexattr),\n    SCMP_SYS(rt_sigaction),\n    SCMP_SYS(rt_sigprocmask),\n    SCMP_SYS(rt_sigreturn),\n    SCMP_SYS(sched_getattr),\n    SCMP_SYS(sched_setattr),\n    SCMP_SYS(sendmsg),\n    SCMP_SYS(setresgid),\n    SCMP_SYS(setresuid),\n#ifdef __NR_setresgid32\n    SCMP_SYS(setresgid32),\n#endif\n#ifdef __NR_setresuid32\n    SCMP_SYS(setresuid32),\n#endif\n    SCMP_SYS(set_robust_list),\n    SCMP_SYS(setxattr),\n    SCMP_SYS(symlinkat),\n    SCMP_SYS(time), /* Rarely needed, except on static builds */\n    SCMP_SYS(tgkill),\n    SCMP_SYS(unlinkat),\n    SCMP_SYS(unshare),\n    SCMP_SYS(utimensat),\n    SCMP_SYS(write),\n    SCMP_SYS(writev),\n};",
      "static const int syscall_whitelist_syslog[] = {\n    SCMP_SYS(sendto),\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seccomp_release",
          "args": [
            "ctx"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"seccomp_load() failed\\n\""
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_load",
          "args": [
            "ctx"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ERRNO(ENOSYS)",
            "SCMP_SYS(userfaultfd)",
            "0"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_SYS",
          "args": [
            "userfaultfd"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCMP_ACT_ERRNO",
          "args": [
            "ENOSYS"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_whitelist",
          "args": [
            "ctx",
            "syscall_whitelist_syslog",
            "G_N_ELEMENTS(syscall_whitelist_syslog)"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "add_whitelist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_seccomp.c",
          "lines": "124-135",
          "snippet": "static void add_whitelist(scmp_filter_ctx ctx, const int syscalls[], size_t len)\n{\n    size_t i;\n\n    for (i = 0; i < len; i++) {\n        if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, syscalls[i], 0) != 0) {\n            fuse_log(FUSE_LOG_ERR, \"seccomp_rule_add syscall %d failed\\n\",\n                     syscalls[i]);\n            exit(1);\n        }\n    }\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <seccomp.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include \"fuse_log.h\"",
            "#include \"fuse_i.h\"",
            "#include \"passthrough_seccomp.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <seccomp.h>\n#include <glib.h>\n#include <errno.h>\n#include \"fuse_log.h\"\n#include \"fuse_i.h\"\n#include \"passthrough_seccomp.h\"\n#include \"qemu/osdep.h\"\n\nstatic void add_whitelist(scmp_filter_ctx ctx, const int syscalls[], size_t len)\n{\n    size_t i;\n\n    for (i = 0; i < len; i++) {\n        if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, syscalls[i], 0) != 0) {\n            fuse_log(FUSE_LOG_ERR, \"seccomp_rule_add syscall %d failed\\n\",\n                     syscalls[i]);\n            exit(1);\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "syscall_whitelist_syslog"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "G_N_ELEMENTS",
          "args": [
            "syscall_whitelist"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_init",
          "args": [
            "SCMP_ACT_TRAP"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_init",
          "args": [
            "SCMP_ACT_TRAP"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seccomp_init",
          "args": [
            "SCMP_ACT_KILL_PROCESS"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <seccomp.h>\n#include <glib.h>\n#include <errno.h>\n#include \"fuse_log.h\"\n#include \"fuse_i.h\"\n#include \"passthrough_seccomp.h\"\n#include \"qemu/osdep.h\"\n\nstatic const int syscall_whitelist[] = {\n    /* TODO ireg sem*() syscalls */\n    SCMP_SYS(brk),\n    SCMP_SYS(capget), /* For CAP_FSETID */\n    SCMP_SYS(capset),\n    SCMP_SYS(clock_gettime),\n    SCMP_SYS(clone),\n#ifdef __NR_clone3\n    SCMP_SYS(clone3),\n#endif\n    SCMP_SYS(close),\n    SCMP_SYS(copy_file_range),\n    SCMP_SYS(dup),\n    SCMP_SYS(eventfd2),\n    SCMP_SYS(exit),\n    SCMP_SYS(exit_group),\n    SCMP_SYS(fallocate),\n    SCMP_SYS(fchdir),\n    SCMP_SYS(fchmod),\n    SCMP_SYS(fchmodat),\n    SCMP_SYS(fchownat),\n    SCMP_SYS(fcntl),\n    SCMP_SYS(fdatasync),\n    SCMP_SYS(fgetxattr),\n    SCMP_SYS(flistxattr),\n    SCMP_SYS(flock),\n    SCMP_SYS(fremovexattr),\n    SCMP_SYS(fsetxattr),\n    SCMP_SYS(fstat),\n    SCMP_SYS(fstatfs),\n    SCMP_SYS(fsync),\n    SCMP_SYS(ftruncate),\n    SCMP_SYS(futex),\n    SCMP_SYS(getdents),\n    SCMP_SYS(getdents64),\n    SCMP_SYS(getegid),\n    SCMP_SYS(geteuid),\n    SCMP_SYS(getpid),\n    SCMP_SYS(gettid),\n    SCMP_SYS(gettimeofday),\n    SCMP_SYS(getxattr),\n    SCMP_SYS(linkat),\n    SCMP_SYS(listxattr),\n    SCMP_SYS(lseek),\n    SCMP_SYS(madvise),\n    SCMP_SYS(mkdirat),\n    SCMP_SYS(mknodat),\n    SCMP_SYS(mmap),\n    SCMP_SYS(mprotect),\n    SCMP_SYS(mremap),\n    SCMP_SYS(munmap),\n    SCMP_SYS(newfstatat),\n    SCMP_SYS(open),\n    SCMP_SYS(openat),\n    SCMP_SYS(ppoll),\n    SCMP_SYS(prctl), /* TODO restrict to just PR_SET_NAME? */\n    SCMP_SYS(preadv),\n    SCMP_SYS(pread64),\n    SCMP_SYS(pwritev),\n    SCMP_SYS(pwrite64),\n    SCMP_SYS(read),\n    SCMP_SYS(readlinkat),\n    SCMP_SYS(recvmsg),\n    SCMP_SYS(renameat),\n    SCMP_SYS(renameat2),\n    SCMP_SYS(removexattr),\n    SCMP_SYS(rt_sigaction),\n    SCMP_SYS(rt_sigprocmask),\n    SCMP_SYS(rt_sigreturn),\n    SCMP_SYS(sched_getattr),\n    SCMP_SYS(sched_setattr),\n    SCMP_SYS(sendmsg),\n    SCMP_SYS(setresgid),\n    SCMP_SYS(setresuid),\n#ifdef __NR_setresgid32\n    SCMP_SYS(setresgid32),\n#endif\n#ifdef __NR_setresuid32\n    SCMP_SYS(setresuid32),\n#endif\n    SCMP_SYS(set_robust_list),\n    SCMP_SYS(setxattr),\n    SCMP_SYS(symlinkat),\n    SCMP_SYS(time), /* Rarely needed, except on static builds */\n    SCMP_SYS(tgkill),\n    SCMP_SYS(unlinkat),\n    SCMP_SYS(unshare),\n    SCMP_SYS(utimensat),\n    SCMP_SYS(write),\n    SCMP_SYS(writev),\n};\nstatic const int syscall_whitelist_syslog[] = {\n    SCMP_SYS(sendto),\n};\n\nvoid setup_seccomp(bool enable_syslog)\n{\n    scmp_filter_ctx ctx;\n\n#ifdef SCMP_ACT_KILL_PROCESS\n    ctx = seccomp_init(SCMP_ACT_KILL_PROCESS);\n    /* Handle a newer libseccomp but an older kernel */\n    if (!ctx && errno == EOPNOTSUPP) {\n        ctx = seccomp_init(SCMP_ACT_TRAP);\n    }\n#else\n    ctx = seccomp_init(SCMP_ACT_TRAP);\n#endif\n    if (!ctx) {\n        fuse_log(FUSE_LOG_ERR, \"seccomp_init() failed\\n\");\n        exit(1);\n    }\n\n    add_whitelist(ctx, syscall_whitelist, G_N_ELEMENTS(syscall_whitelist));\n    if (enable_syslog) {\n        add_whitelist(ctx, syscall_whitelist_syslog,\n                      G_N_ELEMENTS(syscall_whitelist_syslog));\n    }\n\n    /* libvhost-user calls this for post-copy migration, we don't need it */\n    if (seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS),\n                         SCMP_SYS(userfaultfd), 0) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"seccomp_rule_add userfaultfd failed\\n\");\n        exit(1);\n    }\n\n    if (seccomp_load(ctx) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"seccomp_load() failed\\n\");\n        exit(1);\n    }\n\n    seccomp_release(ctx);\n}"
  },
  {
    "function_name": "add_whitelist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_seccomp.c",
    "lines": "124-135",
    "snippet": "static void add_whitelist(scmp_filter_ctx ctx, const int syscalls[], size_t len)\n{\n    size_t i;\n\n    for (i = 0; i < len; i++) {\n        if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, syscalls[i], 0) != 0) {\n            fuse_log(FUSE_LOG_ERR, \"seccomp_rule_add syscall %d failed\\n\",\n                     syscalls[i]);\n            exit(1);\n        }\n    }\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <seccomp.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include \"fuse_log.h\"",
      "#include \"fuse_i.h\"",
      "#include \"passthrough_seccomp.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"seccomp_rule_add syscall %d failed\\n\"",
            "syscalls[i]"
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seccomp_rule_add",
          "args": [
            "ctx",
            "SCMP_ACT_ALLOW",
            "syscalls[i]",
            "0"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <seccomp.h>\n#include <glib.h>\n#include <errno.h>\n#include \"fuse_log.h\"\n#include \"fuse_i.h\"\n#include \"passthrough_seccomp.h\"\n#include \"qemu/osdep.h\"\n\nstatic void add_whitelist(scmp_filter_ctx ctx, const int syscalls[], size_t len)\n{\n    size_t i;\n\n    for (i = 0; i < len; i++) {\n        if (seccomp_rule_add(ctx, SCMP_ACT_ALLOW, syscalls[i], 0) != 0) {\n            fuse_log(FUSE_LOG_ERR, \"seccomp_rule_add syscall %d failed\\n\",\n                     syscalls[i]);\n            exit(1);\n        }\n    }\n}"
  }
]