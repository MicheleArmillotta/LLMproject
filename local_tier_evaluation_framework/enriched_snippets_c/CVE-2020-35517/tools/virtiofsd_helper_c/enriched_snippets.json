[
  {
    "function_name": "fuse_parse_conn_info_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/helper.c",
    "lines": "386-400",
    "snippet": "struct fuse_conn_info_opts *fuse_parse_conn_info_opts(struct fuse_args *args)\n{\n    struct fuse_conn_info_opts *opts;\n\n    opts = calloc(1, sizeof(struct fuse_conn_info_opts));\n    if (opts == NULL) {\n        fuse_log(FUSE_LOG_ERR, \"calloc failed\\n\");\n        return NULL;\n    }\n    if (fuse_opt_parse(args, opts, conn_info_opt_spec, NULL) == -1) {\n        free(opts);\n        return NULL;\n    }\n    return opts;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fuse_opt conn_info_opt_spec[] = {\n    CONN_OPTION(\"max_write=%u\", max_write, 0),\n    CONN_OPTION(\"max_write=\", set_max_write, 1),\n    CONN_OPTION(\"max_readahead=%u\", max_readahead, 0),\n    CONN_OPTION(\"max_readahead=\", set_max_readahead, 1),\n    CONN_OPTION(\"max_background=%u\", max_background, 0),\n    CONN_OPTION(\"max_background=\", set_max_background, 1),\n    CONN_OPTION(\"congestion_threshold=%u\", congestion_threshold, 0),\n    CONN_OPTION(\"congestion_threshold=\", set_congestion_threshold, 1),\n    CONN_OPTION(\"sync_read\", sync_read, 1),\n    CONN_OPTION(\"async_read\", async_read, 1),\n    CONN_OPTION(\"atomic_o_trunc\", atomic_o_trunc, 1),\n    CONN_OPTION(\"no_remote_lock\", no_remote_posix_lock, 1),\n    CONN_OPTION(\"no_remote_lock\", no_remote_flock, 1),\n    CONN_OPTION(\"no_remote_flock\", no_remote_flock, 1),\n    CONN_OPTION(\"no_remote_posix_lock\", no_remote_posix_lock, 1),\n    CONN_OPTION(\"splice_write\", splice_write, 1),\n    CONN_OPTION(\"no_splice_write\", no_splice_write, 1),\n    CONN_OPTION(\"splice_move\", splice_move, 1),\n    CONN_OPTION(\"no_splice_move\", no_splice_move, 1),\n    CONN_OPTION(\"splice_read\", splice_read, 1),\n    CONN_OPTION(\"no_splice_read\", no_splice_read, 1),\n    CONN_OPTION(\"auto_inval_data\", auto_inval_data, 1),\n    CONN_OPTION(\"no_auto_inval_data\", no_auto_inval_data, 1),\n    CONN_OPTION(\"readdirplus=no\", no_readdirplus, 1),\n    CONN_OPTION(\"readdirplus=yes\", no_readdirplus, 0),\n    CONN_OPTION(\"readdirplus=yes\", no_readdirplus_auto, 1),\n    CONN_OPTION(\"readdirplus=auto\", no_readdirplus, 0),\n    CONN_OPTION(\"readdirplus=auto\", no_readdirplus_auto, 0),\n    CONN_OPTION(\"async_dio\", async_dio, 1),\n    CONN_OPTION(\"no_async_dio\", no_async_dio, 1),\n    CONN_OPTION(\"writeback_cache\", writeback_cache, 1),\n    CONN_OPTION(\"no_writeback_cache\", no_writeback_cache, 1),\n    CONN_OPTION(\"time_gran=%u\", time_gran, 0),\n    CONN_OPTION(\"time_gran=\", set_time_gran, 1),\n    FUSE_OPT_END\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "opts"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_opt_parse",
          "args": [
            "args",
            "opts",
            "conn_info_opt_spec",
            "NULL"
          ],
          "line": 395
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_opt_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_opt.c",
          "lines": "424-450",
          "snippet": "int fuse_opt_parse(struct fuse_args *args, void *data,\n                   const struct fuse_opt opts[], fuse_opt_proc_t proc)\n{\n    int res;\n    struct fuse_opt_context ctx = {\n        .data = data,\n        .opt = opts,\n        .proc = proc,\n    };\n\n    if (!args || !args->argv || !args->argc) {\n        return 0;\n    }\n\n    ctx.argc = args->argc;\n    ctx.argv = args->argv;\n\n    res = opt_parse(&ctx);\n    if (res != -1) {\n        struct fuse_args tmp = *args;\n        *args = ctx.outargs;\n        ctx.outargs = tmp;\n    }\n    free(ctx.opts);\n    fuse_opt_free_args(&ctx.outargs);\n    return res;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"fuse_misc.h\"",
            "#include \"fuse_i.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"fuse_misc.h\"\n#include \"fuse_i.h\"\n#include \"fuse_opt.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_opt_parse(struct fuse_args *args, void *data,\n                   const struct fuse_opt opts[], fuse_opt_proc_t proc)\n{\n    int res;\n    struct fuse_opt_context ctx = {\n        .data = data,\n        .opt = opts,\n        .proc = proc,\n    };\n\n    if (!args || !args->argv || !args->argc) {\n        return 0;\n    }\n\n    ctx.argc = args->argc;\n    ctx.argv = args->argv;\n\n    res = opt_parse(&ctx);\n    if (res != -1) {\n        struct fuse_args tmp = *args;\n        *args = ctx.outargs;\n        ctx.outargs = tmp;\n    }\n    free(ctx.opts);\n    fuse_opt_free_args(&ctx.outargs);\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"calloc failed\\n\""
          ],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(struct fuse_conn_info_opts)"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <limits.h>\n#include <errno.h>\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic const struct fuse_opt conn_info_opt_spec[] = {\n    CONN_OPTION(\"max_write=%u\", max_write, 0),\n    CONN_OPTION(\"max_write=\", set_max_write, 1),\n    CONN_OPTION(\"max_readahead=%u\", max_readahead, 0),\n    CONN_OPTION(\"max_readahead=\", set_max_readahead, 1),\n    CONN_OPTION(\"max_background=%u\", max_background, 0),\n    CONN_OPTION(\"max_background=\", set_max_background, 1),\n    CONN_OPTION(\"congestion_threshold=%u\", congestion_threshold, 0),\n    CONN_OPTION(\"congestion_threshold=\", set_congestion_threshold, 1),\n    CONN_OPTION(\"sync_read\", sync_read, 1),\n    CONN_OPTION(\"async_read\", async_read, 1),\n    CONN_OPTION(\"atomic_o_trunc\", atomic_o_trunc, 1),\n    CONN_OPTION(\"no_remote_lock\", no_remote_posix_lock, 1),\n    CONN_OPTION(\"no_remote_lock\", no_remote_flock, 1),\n    CONN_OPTION(\"no_remote_flock\", no_remote_flock, 1),\n    CONN_OPTION(\"no_remote_posix_lock\", no_remote_posix_lock, 1),\n    CONN_OPTION(\"splice_write\", splice_write, 1),\n    CONN_OPTION(\"no_splice_write\", no_splice_write, 1),\n    CONN_OPTION(\"splice_move\", splice_move, 1),\n    CONN_OPTION(\"no_splice_move\", no_splice_move, 1),\n    CONN_OPTION(\"splice_read\", splice_read, 1),\n    CONN_OPTION(\"no_splice_read\", no_splice_read, 1),\n    CONN_OPTION(\"auto_inval_data\", auto_inval_data, 1),\n    CONN_OPTION(\"no_auto_inval_data\", no_auto_inval_data, 1),\n    CONN_OPTION(\"readdirplus=no\", no_readdirplus, 1),\n    CONN_OPTION(\"readdirplus=yes\", no_readdirplus, 0),\n    CONN_OPTION(\"readdirplus=yes\", no_readdirplus_auto, 1),\n    CONN_OPTION(\"readdirplus=auto\", no_readdirplus, 0),\n    CONN_OPTION(\"readdirplus=auto\", no_readdirplus_auto, 0),\n    CONN_OPTION(\"async_dio\", async_dio, 1),\n    CONN_OPTION(\"no_async_dio\", no_async_dio, 1),\n    CONN_OPTION(\"writeback_cache\", writeback_cache, 1),\n    CONN_OPTION(\"no_writeback_cache\", no_writeback_cache, 1),\n    CONN_OPTION(\"time_gran=%u\", time_gran, 0),\n    CONN_OPTION(\"time_gran=\", set_time_gran, 1),\n    FUSE_OPT_END\n};\n\nstruct fuse_conn_info_opts *fuse_parse_conn_info_opts(struct fuse_args *args)\n{\n    struct fuse_conn_info_opts *opts;\n\n    opts = calloc(1, sizeof(struct fuse_conn_info_opts));\n    if (opts == NULL) {\n        fuse_log(FUSE_LOG_ERR, \"calloc failed\\n\");\n        return NULL;\n    }\n    if (fuse_opt_parse(args, opts, conn_info_opt_spec, NULL) == -1) {\n        free(opts);\n        return NULL;\n    }\n    return opts;\n}"
  },
  {
    "function_name": "fuse_apply_conn_info_opts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/helper.c",
    "lines": "332-384",
    "snippet": "void fuse_apply_conn_info_opts(struct fuse_conn_info_opts *opts,\n                               struct fuse_conn_info *conn)\n{\n    if (opts->set_max_write) {\n        conn->max_write = opts->max_write;\n    }\n    if (opts->set_max_background) {\n        conn->max_background = opts->max_background;\n    }\n    if (opts->set_congestion_threshold) {\n        conn->congestion_threshold = opts->congestion_threshold;\n    }\n    if (opts->set_time_gran) {\n        conn->time_gran = opts->time_gran;\n    }\n    if (opts->set_max_readahead) {\n        conn->max_readahead = opts->max_readahead;\n    }\n\n#define LL_ENABLE(cond, cap) \\\n    if (cond)                \\\n        conn->want |= (cap)\n#define LL_DISABLE(cond, cap) \\\n    if (cond)                 \\\n        conn->want &= ~(cap)\n\n    LL_ENABLE(opts->splice_read, FUSE_CAP_SPLICE_READ);\n    LL_DISABLE(opts->no_splice_read, FUSE_CAP_SPLICE_READ);\n\n    LL_ENABLE(opts->splice_write, FUSE_CAP_SPLICE_WRITE);\n    LL_DISABLE(opts->no_splice_write, FUSE_CAP_SPLICE_WRITE);\n\n    LL_ENABLE(opts->splice_move, FUSE_CAP_SPLICE_MOVE);\n    LL_DISABLE(opts->no_splice_move, FUSE_CAP_SPLICE_MOVE);\n\n    LL_ENABLE(opts->auto_inval_data, FUSE_CAP_AUTO_INVAL_DATA);\n    LL_DISABLE(opts->no_auto_inval_data, FUSE_CAP_AUTO_INVAL_DATA);\n\n    LL_DISABLE(opts->no_readdirplus, FUSE_CAP_READDIRPLUS);\n    LL_DISABLE(opts->no_readdirplus_auto, FUSE_CAP_READDIRPLUS_AUTO);\n\n    LL_ENABLE(opts->async_dio, FUSE_CAP_ASYNC_DIO);\n    LL_DISABLE(opts->no_async_dio, FUSE_CAP_ASYNC_DIO);\n\n    LL_ENABLE(opts->writeback_cache, FUSE_CAP_WRITEBACK_CACHE);\n    LL_DISABLE(opts->no_writeback_cache, FUSE_CAP_WRITEBACK_CACHE);\n\n    LL_ENABLE(opts->async_read, FUSE_CAP_ASYNC_READ);\n    LL_DISABLE(opts->sync_read, FUSE_CAP_ASYNC_READ);\n\n    LL_DISABLE(opts->no_remote_posix_lock, FUSE_CAP_POSIX_LOCKS);\n    LL_DISABLE(opts->no_remote_flock, FUSE_CAP_FLOCK_LOCKS);\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LL_DISABLE",
          "args": [
            "opts->no_remote_flock",
            "FUSE_CAP_FLOCK_LOCKS"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_DISABLE",
          "args": [
            "opts->no_remote_posix_lock",
            "FUSE_CAP_POSIX_LOCKS"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_DISABLE",
          "args": [
            "opts->sync_read",
            "FUSE_CAP_ASYNC_READ"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_ENABLE",
          "args": [
            "opts->async_read",
            "FUSE_CAP_ASYNC_READ"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_DISABLE",
          "args": [
            "opts->no_writeback_cache",
            "FUSE_CAP_WRITEBACK_CACHE"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_ENABLE",
          "args": [
            "opts->writeback_cache",
            "FUSE_CAP_WRITEBACK_CACHE"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_DISABLE",
          "args": [
            "opts->no_async_dio",
            "FUSE_CAP_ASYNC_DIO"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_ENABLE",
          "args": [
            "opts->async_dio",
            "FUSE_CAP_ASYNC_DIO"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_DISABLE",
          "args": [
            "opts->no_readdirplus_auto",
            "FUSE_CAP_READDIRPLUS_AUTO"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_DISABLE",
          "args": [
            "opts->no_readdirplus",
            "FUSE_CAP_READDIRPLUS"
          ],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_DISABLE",
          "args": [
            "opts->no_auto_inval_data",
            "FUSE_CAP_AUTO_INVAL_DATA"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_ENABLE",
          "args": [
            "opts->auto_inval_data",
            "FUSE_CAP_AUTO_INVAL_DATA"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_DISABLE",
          "args": [
            "opts->no_splice_move",
            "FUSE_CAP_SPLICE_MOVE"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_ENABLE",
          "args": [
            "opts->splice_move",
            "FUSE_CAP_SPLICE_MOVE"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_DISABLE",
          "args": [
            "opts->no_splice_write",
            "FUSE_CAP_SPLICE_WRITE"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_ENABLE",
          "args": [
            "opts->splice_write",
            "FUSE_CAP_SPLICE_WRITE"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_DISABLE",
          "args": [
            "opts->no_splice_read",
            "FUSE_CAP_SPLICE_READ"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LL_ENABLE",
          "args": [
            "opts->splice_read",
            "FUSE_CAP_SPLICE_READ"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <limits.h>\n#include <errno.h>\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_apply_conn_info_opts(struct fuse_conn_info_opts *opts,\n                               struct fuse_conn_info *conn)\n{\n    if (opts->set_max_write) {\n        conn->max_write = opts->max_write;\n    }\n    if (opts->set_max_background) {\n        conn->max_background = opts->max_background;\n    }\n    if (opts->set_congestion_threshold) {\n        conn->congestion_threshold = opts->congestion_threshold;\n    }\n    if (opts->set_time_gran) {\n        conn->time_gran = opts->time_gran;\n    }\n    if (opts->set_max_readahead) {\n        conn->max_readahead = opts->max_readahead;\n    }\n\n#define LL_ENABLE(cond, cap) \\\n    if (cond)                \\\n        conn->want |= (cap)\n#define LL_DISABLE(cond, cap) \\\n    if (cond)                 \\\n        conn->want &= ~(cap)\n\n    LL_ENABLE(opts->splice_read, FUSE_CAP_SPLICE_READ);\n    LL_DISABLE(opts->no_splice_read, FUSE_CAP_SPLICE_READ);\n\n    LL_ENABLE(opts->splice_write, FUSE_CAP_SPLICE_WRITE);\n    LL_DISABLE(opts->no_splice_write, FUSE_CAP_SPLICE_WRITE);\n\n    LL_ENABLE(opts->splice_move, FUSE_CAP_SPLICE_MOVE);\n    LL_DISABLE(opts->no_splice_move, FUSE_CAP_SPLICE_MOVE);\n\n    LL_ENABLE(opts->auto_inval_data, FUSE_CAP_AUTO_INVAL_DATA);\n    LL_DISABLE(opts->no_auto_inval_data, FUSE_CAP_AUTO_INVAL_DATA);\n\n    LL_DISABLE(opts->no_readdirplus, FUSE_CAP_READDIRPLUS);\n    LL_DISABLE(opts->no_readdirplus_auto, FUSE_CAP_READDIRPLUS_AUTO);\n\n    LL_ENABLE(opts->async_dio, FUSE_CAP_ASYNC_DIO);\n    LL_DISABLE(opts->no_async_dio, FUSE_CAP_ASYNC_DIO);\n\n    LL_ENABLE(opts->writeback_cache, FUSE_CAP_WRITEBACK_CACHE);\n    LL_DISABLE(opts->no_writeback_cache, FUSE_CAP_WRITEBACK_CACHE);\n\n    LL_ENABLE(opts->async_read, FUSE_CAP_ASYNC_READ);\n    LL_DISABLE(opts->sync_read, FUSE_CAP_ASYNC_READ);\n\n    LL_DISABLE(opts->no_remote_posix_lock, FUSE_CAP_POSIX_LOCKS);\n    LL_DISABLE(opts->no_remote_flock, FUSE_CAP_FLOCK_LOCKS);\n}"
  },
  {
    "function_name": "fuse_daemonize",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/helper.c",
    "lines": "261-330",
    "snippet": "int fuse_daemonize(int foreground)\n{\n    int ret = 0, rett;\n    if (!foreground) {\n        int nullfd;\n        int waiter[2];\n        char completed;\n\n        if (pipe(waiter)) {\n            fuse_log(FUSE_LOG_ERR, \"fuse_daemonize: pipe: %s\\n\",\n                     strerror(errno));\n            return -1;\n        }\n\n        /*\n         * demonize current process by forking it and killing the\n         * parent.  This makes current process as a child of 'init'.\n         */\n        switch (fork()) {\n        case -1:\n            fuse_log(FUSE_LOG_ERR, \"fuse_daemonize: fork: %s\\n\",\n                     strerror(errno));\n            return -1;\n        case 0:\n            break;\n        default:\n            _exit(read(waiter[0], &completed,\n                       sizeof(completed) != sizeof(completed)));\n        }\n\n        if (setsid() == -1) {\n            fuse_log(FUSE_LOG_ERR, \"fuse_daemonize: setsid: %s\\n\",\n                     strerror(errno));\n            return -1;\n        }\n\n        ret = chdir(\"/\");\n\n        nullfd = open(\"/dev/null\", O_RDWR, 0);\n        if (nullfd != -1) {\n            rett = dup2(nullfd, 0);\n            if (!ret) {\n                ret = rett;\n            }\n            rett = dup2(nullfd, 1);\n            if (!ret) {\n                ret = rett;\n            }\n            rett = dup2(nullfd, 2);\n            if (!ret) {\n                ret = rett;\n            }\n            if (nullfd > 2) {\n                close(nullfd);\n            }\n        }\n\n        /* Propagate completion of daemon initialization */\n        completed = 1;\n        rett = write(waiter[1], &completed, sizeof(completed));\n        if (!ret) {\n            ret = rett;\n        }\n        close(waiter[0]);\n        close(waiter[1]);\n    } else {\n        ret = chdir(\"/\");\n    }\n    return ret;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "waiter[1]"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "waiter[1]",
            "&completed",
            "sizeof(completed)"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "do_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "1134-1166",
          "snippet": "static void do_write(fuse_req_t req, fuse_ino_t nodeid,\n                     struct fuse_mbuf_iter *iter)\n{\n    struct fuse_write_in *arg;\n    struct fuse_file_info fi;\n    const char *param;\n\n    arg = fuse_mbuf_iter_advance(iter, sizeof(*arg));\n    if (!arg) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    param = fuse_mbuf_iter_advance(iter, arg->size);\n    if (!param) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    memset(&fi, 0, sizeof(fi));\n    fi.fh = arg->fh;\n    fi.writepage = (arg->write_flags & FUSE_WRITE_CACHE) != 0;\n    fi.kill_priv = !!(arg->write_flags & FUSE_WRITE_KILL_PRIV);\n\n    fi.lock_owner = arg->lock_owner;\n    fi.flags = arg->flags;\n\n    if (req->se->op.write) {\n        req->se->op.write(req, nodeid, param, arg->size, arg->offset, &fi);\n    } else {\n        fuse_reply_err(req, ENOSYS);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic void do_write(fuse_req_t req, fuse_ino_t nodeid,\n                     struct fuse_mbuf_iter *iter)\n{\n    struct fuse_write_in *arg;\n    struct fuse_file_info fi;\n    const char *param;\n\n    arg = fuse_mbuf_iter_advance(iter, sizeof(*arg));\n    if (!arg) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    param = fuse_mbuf_iter_advance(iter, arg->size);\n    if (!param) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    memset(&fi, 0, sizeof(fi));\n    fi.fh = arg->fh;\n    fi.writepage = (arg->write_flags & FUSE_WRITE_CACHE) != 0;\n    fi.kill_priv = !!(arg->write_flags & FUSE_WRITE_KILL_PRIV);\n\n    fi.lock_owner = arg->lock_owner;\n    fi.flags = arg->flags;\n\n    if (req->se->op.write) {\n        req->se->op.write(req, nodeid, param, arg->size, arg->offset, &fi);\n    } else {\n        fuse_reply_err(req, ENOSYS);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "nullfd",
            "2"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "nullfd",
            "1"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "nullfd",
            "0"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_RDWR",
            "0"
          ],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "lo_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1786-1820",
          "snippet": "static void lo_open(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)\n{\n    int fd;\n    ssize_t fh;\n    char buf[64];\n    struct lo_data *lo = lo_data(req);\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_open(ino=%\" PRIu64 \", flags=%d)\\n\", ino,\n             fi->flags);\n\n    update_open_flags(lo->writeback, lo->allow_direct_io, fi);\n\n    sprintf(buf, \"%i\", lo_fd(req, ino));\n    fd = openat(lo->proc_self_fd, buf, fi->flags & ~O_NOFOLLOW);\n    if (fd == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    fh = lo_add_fd_mapping(req, fd);\n    pthread_mutex_unlock(&lo->mutex);\n    if (fh == -1) {\n        close(fd);\n        fuse_reply_err(req, ENOMEM);\n        return;\n    }\n\n    fi->fh = fh;\n    if (lo->cache == CACHE_NONE) {\n        fi->direct_io = 1;\n    } else if (lo->cache == CACHE_ALWAYS) {\n        fi->keep_cache = 1;\n    }\n    fuse_reply_open(req, fi);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_open(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)\n{\n    int fd;\n    ssize_t fh;\n    char buf[64];\n    struct lo_data *lo = lo_data(req);\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_open(ino=%\" PRIu64 \", flags=%d)\\n\", ino,\n             fi->flags);\n\n    update_open_flags(lo->writeback, lo->allow_direct_io, fi);\n\n    sprintf(buf, \"%i\", lo_fd(req, ino));\n    fd = openat(lo->proc_self_fd, buf, fi->flags & ~O_NOFOLLOW);\n    if (fd == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    fh = lo_add_fd_mapping(req, fd);\n    pthread_mutex_unlock(&lo->mutex);\n    if (fh == -1) {\n        close(fd);\n        fuse_reply_err(req, ENOMEM);\n        return;\n    }\n\n    fi->fh = fh;\n    if (lo->cache == CACHE_NONE) {\n        fi->direct_io = 1;\n    } else if (lo->cache == CACHE_ALWAYS) {\n        fi->keep_cache = 1;\n    }\n    fuse_reply_open(req, fi);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chdir",
          "args": [
            "\"/\""
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"fuse_daemonize: setsid: %s\\n\"",
            "strerror(errno)"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setsid",
          "args": [],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_exit",
          "args": [
            "read(waiter[0], &completed,\n                       sizeof(completed) != sizeof(completed))"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "waiter[0]",
            "&completed",
            "sizeof(completed) != sizeof(completed)"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "do_readdirplus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "1343-1363",
          "snippet": "static void do_readdirplus(fuse_req_t req, fuse_ino_t nodeid,\n                           struct fuse_mbuf_iter *iter)\n{\n    struct fuse_read_in *arg;\n    struct fuse_file_info fi;\n\n    arg = fuse_mbuf_iter_advance(iter, sizeof(*arg));\n    if (!arg) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    memset(&fi, 0, sizeof(fi));\n    fi.fh = arg->fh;\n\n    if (req->se->op.readdirplus) {\n        req->se->op.readdirplus(req, nodeid, arg->size, arg->offset, &fi);\n    } else {\n        fuse_reply_err(req, ENOSYS);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic void do_readdirplus(fuse_req_t req, fuse_ino_t nodeid,\n                           struct fuse_mbuf_iter *iter)\n{\n    struct fuse_read_in *arg;\n    struct fuse_file_info fi;\n\n    arg = fuse_mbuf_iter_advance(iter, sizeof(*arg));\n    if (!arg) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    memset(&fi, 0, sizeof(fi));\n    fi.fh = arg->fh;\n\n    if (req->se->op.readdirplus) {\n        req->se->op.readdirplus(req, nodeid, arg->size, arg->offset, &fi);\n    } else {\n        fuse_reply_err(req, ENOSYS);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pipe",
          "args": [
            "waiter"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <limits.h>\n#include <errno.h>\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_daemonize(int foreground)\n{\n    int ret = 0, rett;\n    if (!foreground) {\n        int nullfd;\n        int waiter[2];\n        char completed;\n\n        if (pipe(waiter)) {\n            fuse_log(FUSE_LOG_ERR, \"fuse_daemonize: pipe: %s\\n\",\n                     strerror(errno));\n            return -1;\n        }\n\n        /*\n         * demonize current process by forking it and killing the\n         * parent.  This makes current process as a child of 'init'.\n         */\n        switch (fork()) {\n        case -1:\n            fuse_log(FUSE_LOG_ERR, \"fuse_daemonize: fork: %s\\n\",\n                     strerror(errno));\n            return -1;\n        case 0:\n            break;\n        default:\n            _exit(read(waiter[0], &completed,\n                       sizeof(completed) != sizeof(completed)));\n        }\n\n        if (setsid() == -1) {\n            fuse_log(FUSE_LOG_ERR, \"fuse_daemonize: setsid: %s\\n\",\n                     strerror(errno));\n            return -1;\n        }\n\n        ret = chdir(\"/\");\n\n        nullfd = open(\"/dev/null\", O_RDWR, 0);\n        if (nullfd != -1) {\n            rett = dup2(nullfd, 0);\n            if (!ret) {\n                ret = rett;\n            }\n            rett = dup2(nullfd, 1);\n            if (!ret) {\n                ret = rett;\n            }\n            rett = dup2(nullfd, 2);\n            if (!ret) {\n                ret = rett;\n            }\n            if (nullfd > 2) {\n                close(nullfd);\n            }\n        }\n\n        /* Propagate completion of daemon initialization */\n        completed = 1;\n        rett = write(waiter[1], &completed, sizeof(completed));\n        if (!ret) {\n            ret = rett;\n        }\n        close(waiter[0]);\n        close(waiter[1]);\n    } else {\n        ret = chdir(\"/\");\n    }\n    return ret;\n}"
  },
  {
    "function_name": "fuse_parse_cmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/helper.c",
    "lines": "244-258",
    "snippet": "int fuse_parse_cmdline(struct fuse_args *args, struct fuse_cmdline_opts *opts)\n{\n    memset(opts, 0, sizeof(struct fuse_cmdline_opts));\n\n    opts->max_idle_threads = 10;\n    opts->rlimit_nofile = get_default_rlimit_nofile();\n    opts->foreground = 1;\n\n    if (fuse_opt_parse(args, opts, fuse_helper_opts, fuse_helper_opt_proc) ==\n        -1) {\n        return -1;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fuse_opt fuse_helper_opts[] = {\n    FUSE_HELPER_OPT(\"-h\", show_help),\n    FUSE_HELPER_OPT(\"--help\", show_help),\n    FUSE_HELPER_OPT(\"-V\", show_version),\n    FUSE_HELPER_OPT(\"--version\", show_version),\n    FUSE_HELPER_OPT(\"--print-capabilities\", print_capabilities),\n    FUSE_HELPER_OPT(\"-d\", debug),\n    FUSE_HELPER_OPT(\"debug\", debug),\n    FUSE_HELPER_OPT(\"-d\", foreground),\n    FUSE_HELPER_OPT(\"debug\", foreground),\n    FUSE_OPT_KEY(\"-d\", FUSE_OPT_KEY_KEEP),\n    FUSE_OPT_KEY(\"debug\", FUSE_OPT_KEY_KEEP),\n    FUSE_HELPER_OPT(\"-f\", foreground),\n    FUSE_HELPER_OPT_VALUE(\"--daemonize\", foreground, 0),\n    FUSE_HELPER_OPT(\"fsname=\", nodefault_subtype),\n    FUSE_OPT_KEY(\"fsname=\", FUSE_OPT_KEY_KEEP),\n    FUSE_HELPER_OPT(\"subtype=\", nodefault_subtype),\n    FUSE_OPT_KEY(\"subtype=\", FUSE_OPT_KEY_KEEP),\n    FUSE_HELPER_OPT(\"max_idle_threads=%u\", max_idle_threads),\n    FUSE_HELPER_OPT(\"--rlimit-nofile=%lu\", rlimit_nofile),\n    FUSE_HELPER_OPT(\"--syslog\", syslog),\n    FUSE_HELPER_OPT_VALUE(\"log_level=debug\", log_level, FUSE_LOG_DEBUG),\n    FUSE_HELPER_OPT_VALUE(\"log_level=info\", log_level, FUSE_LOG_INFO),\n    FUSE_HELPER_OPT_VALUE(\"log_level=warn\", log_level, FUSE_LOG_WARNING),\n    FUSE_HELPER_OPT_VALUE(\"log_level=err\", log_level, FUSE_LOG_ERR),\n    FUSE_OPT_END\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_opt_parse",
          "args": [
            "args",
            "opts",
            "fuse_helper_opts",
            "fuse_helper_opt_proc"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_opt_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_opt.c",
          "lines": "424-450",
          "snippet": "int fuse_opt_parse(struct fuse_args *args, void *data,\n                   const struct fuse_opt opts[], fuse_opt_proc_t proc)\n{\n    int res;\n    struct fuse_opt_context ctx = {\n        .data = data,\n        .opt = opts,\n        .proc = proc,\n    };\n\n    if (!args || !args->argv || !args->argc) {\n        return 0;\n    }\n\n    ctx.argc = args->argc;\n    ctx.argv = args->argv;\n\n    res = opt_parse(&ctx);\n    if (res != -1) {\n        struct fuse_args tmp = *args;\n        *args = ctx.outargs;\n        ctx.outargs = tmp;\n    }\n    free(ctx.opts);\n    fuse_opt_free_args(&ctx.outargs);\n    return res;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"fuse_misc.h\"",
            "#include \"fuse_i.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"fuse_misc.h\"\n#include \"fuse_i.h\"\n#include \"fuse_opt.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_opt_parse(struct fuse_args *args, void *data,\n                   const struct fuse_opt opts[], fuse_opt_proc_t proc)\n{\n    int res;\n    struct fuse_opt_context ctx = {\n        .data = data,\n        .opt = opts,\n        .proc = proc,\n    };\n\n    if (!args || !args->argv || !args->argc) {\n        return 0;\n    }\n\n    ctx.argc = args->argc;\n    ctx.argv = args->argv;\n\n    res = opt_parse(&ctx);\n    if (res != -1) {\n        struct fuse_args tmp = *args;\n        *args = ctx.outargs;\n        ctx.outargs = tmp;\n    }\n    free(ctx.opts);\n    fuse_opt_free_args(&ctx.outargs);\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_default_rlimit_nofile",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "get_default_rlimit_nofile",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/helper.c",
          "lines": "205-242",
          "snippet": "static unsigned long get_default_rlimit_nofile(void)\n{\n    g_autofree gchar *file_max_str = NULL;\n    const rlim_t reserved_fds = 16384; /* leave at least this many fds free */\n    rlim_t max_fds = 1000000; /* our default RLIMIT_NOFILE target */\n    rlim_t file_max;\n    struct rlimit rlim;\n\n    /*\n     * Reduce max_fds below the system-wide maximum, if necessary.  This\n     * ensures there are fds available for other processes so we don't\n     * cause resource exhaustion.\n     */\n    if (!g_file_get_contents(\"/proc/sys/fs/file-max\", &file_max_str,\n                             NULL, NULL)) {\n        fuse_log(FUSE_LOG_ERR, \"can't read /proc/sys/fs/file-max\\n\");\n        exit(1);\n    }\n    file_max = g_ascii_strtoull(file_max_str, NULL, 10);\n    if (file_max < 2 * reserved_fds) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"The fs.file-max sysctl is too low (%lu) to allow a \"\n                 \"reasonable number of open files.\\n\",\n                 (unsigned long)file_max);\n        exit(1);\n    }\n    max_fds = MIN(file_max - reserved_fds, max_fds);\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"getrlimit(RLIMIT_NOFILE): %m\\n\");\n        exit(1);\n    }\n\n    if (rlim.rlim_cur >= max_fds) {\n        return 0; /* we have more fds available than required! */\n    }\n    return max_fds;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <limits.h>\n#include <errno.h>\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic unsigned long get_default_rlimit_nofile(void)\n{\n    g_autofree gchar *file_max_str = NULL;\n    const rlim_t reserved_fds = 16384; /* leave at least this many fds free */\n    rlim_t max_fds = 1000000; /* our default RLIMIT_NOFILE target */\n    rlim_t file_max;\n    struct rlimit rlim;\n\n    /*\n     * Reduce max_fds below the system-wide maximum, if necessary.  This\n     * ensures there are fds available for other processes so we don't\n     * cause resource exhaustion.\n     */\n    if (!g_file_get_contents(\"/proc/sys/fs/file-max\", &file_max_str,\n                             NULL, NULL)) {\n        fuse_log(FUSE_LOG_ERR, \"can't read /proc/sys/fs/file-max\\n\");\n        exit(1);\n    }\n    file_max = g_ascii_strtoull(file_max_str, NULL, 10);\n    if (file_max < 2 * reserved_fds) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"The fs.file-max sysctl is too low (%lu) to allow a \"\n                 \"reasonable number of open files.\\n\",\n                 (unsigned long)file_max);\n        exit(1);\n    }\n    max_fds = MIN(file_max - reserved_fds, max_fds);\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"getrlimit(RLIMIT_NOFILE): %m\\n\");\n        exit(1);\n    }\n\n    if (rlim.rlim_cur >= max_fds) {\n        return 0; /* we have more fds available than required! */\n    }\n    return max_fds;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "opts",
            "0",
            "sizeof(struct fuse_cmdline_opts)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <limits.h>\n#include <errno.h>\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic const struct fuse_opt fuse_helper_opts[] = {\n    FUSE_HELPER_OPT(\"-h\", show_help),\n    FUSE_HELPER_OPT(\"--help\", show_help),\n    FUSE_HELPER_OPT(\"-V\", show_version),\n    FUSE_HELPER_OPT(\"--version\", show_version),\n    FUSE_HELPER_OPT(\"--print-capabilities\", print_capabilities),\n    FUSE_HELPER_OPT(\"-d\", debug),\n    FUSE_HELPER_OPT(\"debug\", debug),\n    FUSE_HELPER_OPT(\"-d\", foreground),\n    FUSE_HELPER_OPT(\"debug\", foreground),\n    FUSE_OPT_KEY(\"-d\", FUSE_OPT_KEY_KEEP),\n    FUSE_OPT_KEY(\"debug\", FUSE_OPT_KEY_KEEP),\n    FUSE_HELPER_OPT(\"-f\", foreground),\n    FUSE_HELPER_OPT_VALUE(\"--daemonize\", foreground, 0),\n    FUSE_HELPER_OPT(\"fsname=\", nodefault_subtype),\n    FUSE_OPT_KEY(\"fsname=\", FUSE_OPT_KEY_KEEP),\n    FUSE_HELPER_OPT(\"subtype=\", nodefault_subtype),\n    FUSE_OPT_KEY(\"subtype=\", FUSE_OPT_KEY_KEEP),\n    FUSE_HELPER_OPT(\"max_idle_threads=%u\", max_idle_threads),\n    FUSE_HELPER_OPT(\"--rlimit-nofile=%lu\", rlimit_nofile),\n    FUSE_HELPER_OPT(\"--syslog\", syslog),\n    FUSE_HELPER_OPT_VALUE(\"log_level=debug\", log_level, FUSE_LOG_DEBUG),\n    FUSE_HELPER_OPT_VALUE(\"log_level=info\", log_level, FUSE_LOG_INFO),\n    FUSE_HELPER_OPT_VALUE(\"log_level=warn\", log_level, FUSE_LOG_WARNING),\n    FUSE_HELPER_OPT_VALUE(\"log_level=err\", log_level, FUSE_LOG_ERR),\n    FUSE_OPT_END\n};\n\nint fuse_parse_cmdline(struct fuse_args *args, struct fuse_cmdline_opts *opts)\n{\n    memset(opts, 0, sizeof(struct fuse_cmdline_opts));\n\n    opts->max_idle_threads = 10;\n    opts->rlimit_nofile = get_default_rlimit_nofile();\n    opts->foreground = 1;\n\n    if (fuse_opt_parse(args, opts, fuse_helper_opts, fuse_helper_opt_proc) ==\n        -1) {\n        return -1;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "get_default_rlimit_nofile",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/helper.c",
    "lines": "205-242",
    "snippet": "static unsigned long get_default_rlimit_nofile(void)\n{\n    g_autofree gchar *file_max_str = NULL;\n    const rlim_t reserved_fds = 16384; /* leave at least this many fds free */\n    rlim_t max_fds = 1000000; /* our default RLIMIT_NOFILE target */\n    rlim_t file_max;\n    struct rlimit rlim;\n\n    /*\n     * Reduce max_fds below the system-wide maximum, if necessary.  This\n     * ensures there are fds available for other processes so we don't\n     * cause resource exhaustion.\n     */\n    if (!g_file_get_contents(\"/proc/sys/fs/file-max\", &file_max_str,\n                             NULL, NULL)) {\n        fuse_log(FUSE_LOG_ERR, \"can't read /proc/sys/fs/file-max\\n\");\n        exit(1);\n    }\n    file_max = g_ascii_strtoull(file_max_str, NULL, 10);\n    if (file_max < 2 * reserved_fds) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"The fs.file-max sysctl is too low (%lu) to allow a \"\n                 \"reasonable number of open files.\\n\",\n                 (unsigned long)file_max);\n        exit(1);\n    }\n    max_fds = MIN(file_max - reserved_fds, max_fds);\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"getrlimit(RLIMIT_NOFILE): %m\\n\");\n        exit(1);\n    }\n\n    if (rlim.rlim_cur >= max_fds) {\n        return 0; /* we have more fds available than required! */\n    }\n    return max_fds;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 235
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"getrlimit(RLIMIT_NOFILE): %m\\n\""
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrlimit",
          "args": [
            "RLIMIT_NOFILE",
            "&rlim"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "file_max - reserved_fds",
            "max_fds"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_ascii_strtoull",
          "args": [
            "file_max_str",
            "NULL",
            "10"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_file_get_contents",
          "args": [
            "\"/proc/sys/fs/file-max\"",
            "&file_max_str",
            "NULL",
            "NULL"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <limits.h>\n#include <errno.h>\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic unsigned long get_default_rlimit_nofile(void)\n{\n    g_autofree gchar *file_max_str = NULL;\n    const rlim_t reserved_fds = 16384; /* leave at least this many fds free */\n    rlim_t max_fds = 1000000; /* our default RLIMIT_NOFILE target */\n    rlim_t file_max;\n    struct rlimit rlim;\n\n    /*\n     * Reduce max_fds below the system-wide maximum, if necessary.  This\n     * ensures there are fds available for other processes so we don't\n     * cause resource exhaustion.\n     */\n    if (!g_file_get_contents(\"/proc/sys/fs/file-max\", &file_max_str,\n                             NULL, NULL)) {\n        fuse_log(FUSE_LOG_ERR, \"can't read /proc/sys/fs/file-max\\n\");\n        exit(1);\n    }\n    file_max = g_ascii_strtoull(file_max_str, NULL, 10);\n    if (file_max < 2 * reserved_fds) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"The fs.file-max sysctl is too low (%lu) to allow a \"\n                 \"reasonable number of open files.\\n\",\n                 (unsigned long)file_max);\n        exit(1);\n    }\n    max_fds = MIN(file_max - reserved_fds, max_fds);\n\n    if (getrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"getrlimit(RLIMIT_NOFILE): %m\\n\");\n        exit(1);\n    }\n\n    if (rlim.rlim_cur >= max_fds) {\n        return 0; /* we have more fds available than required! */\n    }\n    return max_fds;\n}"
  },
  {
    "function_name": "fuse_helper_opt_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/helper.c",
    "lines": "188-203",
    "snippet": "static int fuse_helper_opt_proc(void *data, const char *arg, int key,\n                                struct fuse_args *outargs)\n{\n    (void)data;\n    (void)outargs;\n\n    switch (key) {\n    case FUSE_OPT_KEY_NONOPT:\n        fuse_log(FUSE_LOG_ERR, \"fuse: invalid argument `%s'\\n\", arg);\n        return -1;\n\n    default:\n        /* Pass through unknown options */\n        return 1;\n    }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"fuse: invalid argument `%s'\\n\"",
            "arg"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <limits.h>\n#include <errno.h>\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic int fuse_helper_opt_proc(void *data, const char *arg, int key,\n                                struct fuse_args *outargs)\n{\n    (void)data;\n    (void)outargs;\n\n    switch (key) {\n    case FUSE_OPT_KEY_NONOPT:\n        fuse_log(FUSE_LOG_ERR, \"fuse: invalid argument `%s'\\n\", arg);\n        return -1;\n\n    default:\n        /* Pass through unknown options */\n        return 1;\n    }\n}"
  },
  {
    "function_name": "fuse_cmdline_help",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/helper.c",
    "lines": "142-186",
    "snippet": "void fuse_cmdline_help(void)\n{\n    printf(\"    -h   --help                print help\\n\"\n           \"    -V   --version             print version\\n\"\n           \"    --print-capabilities       print vhost-user.json\\n\"\n           \"    -d   -o debug              enable debug output (implies -f)\\n\"\n           \"    --syslog                   log to syslog (default stderr)\\n\"\n           \"    -f                         foreground operation\\n\"\n           \"    --daemonize                run in background\\n\"\n           \"    -o cache=<mode>            cache mode. could be one of \\\"auto, \"\n           \"always, none\\\"\\n\"\n           \"                               default: auto\\n\"\n           \"    -o flock|no_flock          enable/disable flock\\n\"\n           \"                               default: no_flock\\n\"\n           \"    -o log_level=<level>       log level, default to \\\"info\\\"\\n\"\n           \"                               level could be one of \\\"debug, \"\n           \"info, warn, err\\\"\\n\"\n           \"    -o max_idle_threads        the maximum number of idle worker \"\n           \"threads\\n\"\n           \"                               allowed (default: 10)\\n\"\n           \"    -o posix_lock|no_posix_lock\\n\"\n           \"                               enable/disable remote posix lock\\n\"\n           \"                               default: posix_lock\\n\"\n           \"    -o readdirplus|no_readdirplus\\n\"\n           \"                               enable/disable readirplus\\n\"\n           \"                               default: readdirplus except with \"\n           \"cache=none\\n\"\n           \"    -o timeout=<number>        I/O timeout (seconds)\\n\"\n           \"                               default: depends on cache= option.\\n\"\n           \"    -o writeback|no_writeback  enable/disable writeback cache\\n\"\n           \"                               default: no_writeback\\n\"\n           \"    -o xattr|no_xattr          enable/disable xattr\\n\"\n           \"                               default: no_xattr\\n\"\n           \"    -o modcaps=CAPLIST         Modify the list of capabilities\\n\"\n           \"                               e.g. -o modcaps=+sys_admin:-chown\\n\"\n           \"    --rlimit-nofile=<num>      set maximum number of file descriptors\\n\"\n           \"                               (0 leaves rlimit unchanged)\\n\"\n           \"                               default: min(1000000, fs.file-max - 16384)\\n\"\n           \"                                        if the current rlimit is lower\\n\"\n           \"    -o allow_direct_io|no_allow_direct_io\\n\"\n           \"                               retain/discard O_DIRECT flags passed down\\n\"\n           \"                               to virtiofsd from guest applications.\\n\"\n           \"                               default: no_allow_direct_io\\n\"\n           );\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <sys/resource.h>",
      "#include <sys/time.h>",
      "#include <sys/param.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <limits.h>",
      "#include <errno.h>",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    -h   --help                print help\\n\"\n           \"    -V   --version             print version\\n\"\n           \"    --print-capabilities       print vhost-user.json\\n\"\n           \"    -d   -o debug              enable debug output (implies -f)\\n\"\n           \"    --syslog                   log to syslog (default stderr)\\n\"\n           \"    -f                         foreground operation\\n\"\n           \"    --daemonize                run in background\\n\"\n           \"    -o cache=<mode>            cache mode. could be one of \\\"auto, \"\n           \"always, none\\\"\\n\"\n           \"                               default: auto\\n\"\n           \"    -o flock|no_flock          enable/disable flock\\n\"\n           \"                               default: no_flock\\n\"\n           \"    -o log_level=<level>       log level, default to \\\"info\\\"\\n\"\n           \"                               level could be one of \\\"debug, \"\n           \"info, warn, err\\\"\\n\"\n           \"    -o max_idle_threads        the maximum number of idle worker \"\n           \"threads\\n\"\n           \"                               allowed (default: 10)\\n\"\n           \"    -o posix_lock|no_posix_lock\\n\"\n           \"                               enable/disable remote posix lock\\n\"\n           \"                               default: posix_lock\\n\"\n           \"    -o readdirplus|no_readdirplus\\n\"\n           \"                               enable/disable readirplus\\n\"\n           \"                               default: readdirplus except with \"\n           \"cache=none\\n\"\n           \"    -o timeout=<number>        I/O timeout (seconds)\\n\"\n           \"                               default: depends on cache= option.\\n\"\n           \"    -o writeback|no_writeback  enable/disable writeback cache\\n\"\n           \"                               default: no_writeback\\n\"\n           \"    -o xattr|no_xattr          enable/disable xattr\\n\"\n           \"                               default: no_xattr\\n\"\n           \"    -o modcaps=CAPLIST         Modify the list of capabilities\\n\"\n           \"                               e.g. -o modcaps=+sys_admin:-chown\\n\"\n           \"    --rlimit-nofile=<num>      set maximum number of file descriptors\\n\"\n           \"                               (0 leaves rlimit unchanged)\\n\"\n           \"                               default: min(1000000, fs.file-max - 16384)\\n\"\n           \"                                        if the current rlimit is lower\\n\"\n           \"    -o allow_direct_io|no_allow_direct_io\\n\"\n           \"                               retain/discard O_DIRECT flags passed down\\n\"\n           \"                               to virtiofsd from guest applications.\\n\"\n           \"                               default: no_allow_direct_io\\n\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <limits.h>\n#include <errno.h>\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_cmdline_help(void)\n{\n    printf(\"    -h   --help                print help\\n\"\n           \"    -V   --version             print version\\n\"\n           \"    --print-capabilities       print vhost-user.json\\n\"\n           \"    -d   -o debug              enable debug output (implies -f)\\n\"\n           \"    --syslog                   log to syslog (default stderr)\\n\"\n           \"    -f                         foreground operation\\n\"\n           \"    --daemonize                run in background\\n\"\n           \"    -o cache=<mode>            cache mode. could be one of \\\"auto, \"\n           \"always, none\\\"\\n\"\n           \"                               default: auto\\n\"\n           \"    -o flock|no_flock          enable/disable flock\\n\"\n           \"                               default: no_flock\\n\"\n           \"    -o log_level=<level>       log level, default to \\\"info\\\"\\n\"\n           \"                               level could be one of \\\"debug, \"\n           \"info, warn, err\\\"\\n\"\n           \"    -o max_idle_threads        the maximum number of idle worker \"\n           \"threads\\n\"\n           \"                               allowed (default: 10)\\n\"\n           \"    -o posix_lock|no_posix_lock\\n\"\n           \"                               enable/disable remote posix lock\\n\"\n           \"                               default: posix_lock\\n\"\n           \"    -o readdirplus|no_readdirplus\\n\"\n           \"                               enable/disable readirplus\\n\"\n           \"                               default: readdirplus except with \"\n           \"cache=none\\n\"\n           \"    -o timeout=<number>        I/O timeout (seconds)\\n\"\n           \"                               default: depends on cache= option.\\n\"\n           \"    -o writeback|no_writeback  enable/disable writeback cache\\n\"\n           \"                               default: no_writeback\\n\"\n           \"    -o xattr|no_xattr          enable/disable xattr\\n\"\n           \"                               default: no_xattr\\n\"\n           \"    -o modcaps=CAPLIST         Modify the list of capabilities\\n\"\n           \"                               e.g. -o modcaps=+sys_admin:-chown\\n\"\n           \"    --rlimit-nofile=<num>      set maximum number of file descriptors\\n\"\n           \"                               (0 leaves rlimit unchanged)\\n\"\n           \"                               default: min(1000000, fs.file-max - 16384)\\n\"\n           \"                                        if the current rlimit is lower\\n\"\n           \"    -o allow_direct_io|no_allow_direct_io\\n\"\n           \"                               retain/discard O_DIRECT flags passed down\\n\"\n           \"                               to virtiofsd from guest applications.\\n\"\n           \"                               default: no_allow_direct_io\\n\"\n           );\n}"
  }
]