[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2824-2978",
    "snippet": "int main(int argc, char *argv[])\n{\n    struct fuse_args args = FUSE_ARGS_INIT(argc, argv);\n    struct fuse_session *se;\n    struct fuse_cmdline_opts opts;\n    struct lo_data lo = {\n        .debug = 0,\n        .writeback = 0,\n        .posix_lock = 0,\n        .allow_direct_io = 0,\n        .proc_self_fd = -1,\n    };\n    struct lo_map_elem *root_elem;\n    int ret = -1;\n\n    /* Don't mask creation mode, kernel already did that */\n    umask(0);\n\n    qemu_init_exec_dir(argv[0]);\n\n    pthread_mutex_init(&lo.mutex, NULL);\n    lo.inodes = g_hash_table_new(lo_key_hash, lo_key_equal);\n    lo.root.fd = -1;\n    lo.root.fuse_ino = FUSE_ROOT_ID;\n    lo.cache = CACHE_AUTO;\n\n    /*\n     * Set up the ino map like this:\n     * [0] Reserved (will not be used)\n     * [1] Root inode\n     */\n    lo_map_init(&lo.ino_map);\n    lo_map_reserve(&lo.ino_map, 0)->in_use = false;\n    root_elem = lo_map_reserve(&lo.ino_map, lo.root.fuse_ino);\n    root_elem->inode = &lo.root;\n\n    lo_map_init(&lo.dirp_map);\n    lo_map_init(&lo.fd_map);\n\n    if (fuse_parse_cmdline(&args, &opts) != 0) {\n        goto err_out1;\n    }\n    fuse_set_log_func(log_func);\n    use_syslog = opts.syslog;\n    if (use_syslog) {\n        openlog(\"virtiofsd\", LOG_PID, LOG_DAEMON);\n    }\n\n    if (opts.show_help) {\n        printf(\"usage: %s [options]\\n\\n\", argv[0]);\n        fuse_cmdline_help();\n        printf(\"    -o source=PATH             shared directory tree\\n\");\n        fuse_lowlevel_help();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.show_version) {\n        fuse_lowlevel_version();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.print_capabilities) {\n        print_capabilities();\n        ret = 0;\n        goto err_out1;\n    }\n\n    if (fuse_opt_parse(&args, &lo, lo_opts, NULL) == -1) {\n        goto err_out1;\n    }\n\n    /*\n     * log_level is 0 if not configured via cmd options (0 is LOG_EMERG,\n     * and we don't use this log level).\n     */\n    if (opts.log_level != 0) {\n        current_log_level = opts.log_level;\n    }\n    lo.debug = opts.debug;\n    if (lo.debug) {\n        current_log_level = FUSE_LOG_DEBUG;\n    }\n    if (lo.source) {\n        struct stat stat;\n        int res;\n\n        res = lstat(lo.source, &stat);\n        if (res == -1) {\n            fuse_log(FUSE_LOG_ERR, \"failed to stat source (\\\"%s\\\"): %m\\n\",\n                     lo.source);\n            exit(1);\n        }\n        if (!S_ISDIR(stat.st_mode)) {\n            fuse_log(FUSE_LOG_ERR, \"source is not a directory\\n\");\n            exit(1);\n        }\n    } else {\n        lo.source = strdup(\"/\");\n    }\n    if (!lo.timeout_set) {\n        switch (lo.cache) {\n        case CACHE_NONE:\n            lo.timeout = 0.0;\n            break;\n\n        case CACHE_AUTO:\n            lo.timeout = 1.0;\n            break;\n\n        case CACHE_ALWAYS:\n            lo.timeout = 86400.0;\n            break;\n        }\n    } else if (lo.timeout < 0) {\n        fuse_log(FUSE_LOG_ERR, \"timeout is negative (%lf)\\n\", lo.timeout);\n        exit(1);\n    }\n\n    se = fuse_session_new(&args, &lo_oper, sizeof(lo_oper), &lo);\n    if (se == NULL) {\n        goto err_out1;\n    }\n\n    if (fuse_set_signal_handlers(se) != 0) {\n        goto err_out2;\n    }\n\n    if (fuse_session_mount(se) != 0) {\n        goto err_out3;\n    }\n\n    fuse_daemonize(opts.foreground);\n\n    setup_nofile_rlimit(opts.rlimit_nofile);\n\n    /* Must be before sandbox since it wants /proc */\n    setup_capng();\n\n    setup_sandbox(&lo, se, opts.syslog);\n\n    setup_root(&lo, &lo.root);\n    /* Block until ctrl+c or fusermount -u */\n    ret = virtio_loop(se);\n\n    fuse_session_unmount(se);\n    cleanup_capng();\nerr_out3:\n    fuse_remove_signal_handlers(se);\nerr_out2:\n    fuse_session_destroy(se);\nerr_out1:\n    fuse_opt_free_args(&args);\n\n    fuse_lo_data_cleanup(&lo);\n\n    return ret ? 1 : 0;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct fuse_opt lo_opts[] = {\n    { \"writeback\", offsetof(struct lo_data, writeback), 1 },\n    { \"no_writeback\", offsetof(struct lo_data, writeback), 0 },\n    { \"source=%s\", offsetof(struct lo_data, source), 0 },\n    { \"flock\", offsetof(struct lo_data, flock), 1 },\n    { \"no_flock\", offsetof(struct lo_data, flock), 0 },\n    { \"posix_lock\", offsetof(struct lo_data, posix_lock), 1 },\n    { \"no_posix_lock\", offsetof(struct lo_data, posix_lock), 0 },\n    { \"xattr\", offsetof(struct lo_data, xattr), 1 },\n    { \"no_xattr\", offsetof(struct lo_data, xattr), 0 },\n    { \"modcaps=%s\", offsetof(struct lo_data, modcaps), 0 },\n    { \"timeout=%lf\", offsetof(struct lo_data, timeout), 0 },\n    { \"timeout=\", offsetof(struct lo_data, timeout_set), 1 },\n    { \"cache=none\", offsetof(struct lo_data, cache), CACHE_NONE },\n    { \"cache=auto\", offsetof(struct lo_data, cache), CACHE_AUTO },\n    { \"cache=always\", offsetof(struct lo_data, cache), CACHE_ALWAYS },\n    { \"readdirplus\", offsetof(struct lo_data, readdirplus_set), 1 },\n    { \"no_readdirplus\", offsetof(struct lo_data, readdirplus_clear), 1 },\n    { \"allow_direct_io\", offsetof(struct lo_data, allow_direct_io), 1 },\n    { \"no_allow_direct_io\", offsetof(struct lo_data, allow_direct_io), 0 },\n    FUSE_OPT_END\n};",
      "static bool use_syslog = false;",
      "static int current_log_level;",
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);",
      "static struct fuse_lowlevel_ops lo_oper = {\n    .init = lo_init,\n    .lookup = lo_lookup,\n    .mkdir = lo_mkdir,\n    .mknod = lo_mknod,\n    .symlink = lo_symlink,\n    .link = lo_link,\n    .unlink = lo_unlink,\n    .rmdir = lo_rmdir,\n    .rename = lo_rename,\n    .forget = lo_forget,\n    .forget_multi = lo_forget_multi,\n    .getattr = lo_getattr,\n    .setattr = lo_setattr,\n    .readlink = lo_readlink,\n    .opendir = lo_opendir,\n    .readdir = lo_readdir,\n    .readdirplus = lo_readdirplus,\n    .releasedir = lo_releasedir,\n    .fsyncdir = lo_fsyncdir,\n    .create = lo_create,\n    .getlk = lo_getlk,\n    .setlk = lo_setlk,\n    .open = lo_open,\n    .release = lo_release,\n    .flush = lo_flush,\n    .fsync = lo_fsync,\n    .read = lo_read,\n    .write_buf = lo_write_buf,\n    .statfs = lo_statfs,\n    .fallocate = lo_fallocate,\n    .flock = lo_flock,\n    .getxattr = lo_getxattr,\n    .listxattr = lo_listxattr,\n    .setxattr = lo_setxattr,\n    .removexattr = lo_removexattr,\n#ifdef HAVE_COPY_FILE_RANGE\n    .copy_file_range = lo_copy_file_range,\n#endif\n    .lseek = lo_lseek,\n    .destroy = lo_destroy,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_lo_data_cleanup",
          "args": [
            "&lo"
          ],
          "line": 2975
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_opt_free_args",
          "args": [
            "&args"
          ],
          "line": 2973
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_opt_free_args",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_opt.c",
          "lines": "34-48",
          "snippet": "void fuse_opt_free_args(struct fuse_args *args)\n{\n    if (args) {\n        if (args->argv && args->allocated) {\n            int i;\n            for (i = 0; i < args->argc; i++) {\n                free(args->argv[i]);\n            }\n            free(args->argv);\n        }\n        args->argc = 0;\n        args->argv = NULL;\n        args->allocated = 0;\n    }\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"fuse_misc.h\"",
            "#include \"fuse_i.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"fuse_misc.h\"\n#include \"fuse_i.h\"\n#include \"fuse_opt.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_opt_free_args(struct fuse_args *args)\n{\n    if (args) {\n        if (args->argv && args->allocated) {\n            int i;\n            for (i = 0; i < args->argc; i++) {\n                free(args->argv[i]);\n            }\n            free(args->argv);\n        }\n        args->argc = 0;\n        args->argv = NULL;\n        args->allocated = 0;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_session_destroy",
          "args": [
            "se"
          ],
          "line": 2971
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2552-2574",
          "snippet": "void fuse_session_destroy(struct fuse_session *se)\n{\n    if (se->got_init && !se->got_destroy) {\n        if (se->op.destroy) {\n            se->op.destroy(se->userdata);\n        }\n    }\n    pthread_rwlock_destroy(&se->init_rwlock);\n    pthread_mutex_destroy(&se->lock);\n    free(se->cuse_data);\n    if (se->fd != -1) {\n        close(se->fd);\n    }\n\n    if (fuse_lowlevel_is_virtio(se)) {\n        virtio_session_close(se);\n    }\n\n    free(se->vu_socket_path);\n    se->vu_socket_path = NULL;\n\n    free(se);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_session_destroy(struct fuse_session *se)\n{\n    if (se->got_init && !se->got_destroy) {\n        if (se->op.destroy) {\n            se->op.destroy(se->userdata);\n        }\n    }\n    pthread_rwlock_destroy(&se->init_rwlock);\n    pthread_mutex_destroy(&se->lock);\n    free(se->cuse_data);\n    if (se->fd != -1) {\n        close(se->fd);\n    }\n\n    if (fuse_lowlevel_is_virtio(se)) {\n        virtio_session_close(se);\n    }\n\n    free(se->vu_socket_path);\n    se->vu_socket_path = NULL;\n\n    free(se);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_remove_signal_handlers",
          "args": [
            "se"
          ],
          "line": 2969
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_remove_signal_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_signals.c",
          "lines": "85-98",
          "snippet": "void fuse_remove_signal_handlers(struct fuse_session *se)\n{\n    if (fuse_instance != se) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"fuse: fuse_remove_signal_handlers: unknown session\\n\");\n    } else {\n        fuse_instance = NULL;\n    }\n\n    set_one_signal_handler(SIGHUP, exit_handler, 1);\n    set_one_signal_handler(SIGINT, exit_handler, 1);\n    set_one_signal_handler(SIGTERM, exit_handler, 1);\n    set_one_signal_handler(SIGPIPE, do_nothing, 1);\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fuse_session *fuse_instance;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct fuse_session *fuse_instance;\n\nvoid fuse_remove_signal_handlers(struct fuse_session *se)\n{\n    if (fuse_instance != se) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"fuse: fuse_remove_signal_handlers: unknown session\\n\");\n    } else {\n        fuse_instance = NULL;\n    }\n\n    set_one_signal_handler(SIGHUP, exit_handler, 1);\n    set_one_signal_handler(SIGINT, exit_handler, 1);\n    set_one_signal_handler(SIGTERM, exit_handler, 1);\n    set_one_signal_handler(SIGPIPE, do_nothing, 1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cleanup_capng",
          "args": [],
          "line": 2967
        },
        "resolved": true,
        "details": {
          "function_name": "cleanup_capng",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2511-2516",
          "snippet": "static void cleanup_capng(void)\n{\n    free(cap.saved);\n    cap.saved = NULL;\n    pthread_mutex_destroy(&cap.mutex);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\n\nstatic void cleanup_capng(void)\n{\n    free(cap.saved);\n    cap.saved = NULL;\n    pthread_mutex_destroy(&cap.mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_session_unmount",
          "args": [
            "se"
          ],
          "line": 2966
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_unmount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2671-2673",
          "snippet": "void fuse_session_unmount(struct fuse_session *se)\n{\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_session_unmount(struct fuse_session *se)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "virtio_loop",
          "args": [
            "se"
          ],
          "line": 2964
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_loop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "787-849",
          "snippet": "int virtio_loop(struct fuse_session *se)\n{\n    fuse_log(FUSE_LOG_INFO, \"%s: Entry\\n\", __func__);\n\n    while (!fuse_session_exited(se)) {\n        struct pollfd pf[1];\n        bool ok;\n        int ret;\n        pf[0].fd = se->vu_socketfd;\n        pf[0].events = POLLIN;\n        pf[0].revents = 0;\n\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Waiting for VU event\\n\", __func__);\n        int poll_res = ppoll(pf, 1, NULL, NULL);\n\n        if (poll_res == -1) {\n            if (errno == EINTR) {\n                fuse_log(FUSE_LOG_INFO, \"%s: ppoll interrupted, going around\\n\",\n                         __func__);\n                continue;\n            }\n            fuse_log(FUSE_LOG_ERR, \"virtio_loop ppoll: %m\\n\");\n            break;\n        }\n        assert(poll_res == 1);\n        if (pf[0].revents & (POLLERR | POLLHUP | POLLNVAL)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Unexpected poll revents %x\\n\", __func__,\n                     pf[0].revents);\n            break;\n        }\n        assert(pf[0].revents & POLLIN);\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Got VU event\\n\", __func__);\n        /* Mutual exclusion with fv_queue_thread() */\n        ret = pthread_rwlock_wrlock(&se->virtio_dev->vu_dispatch_rwlock);\n        assert(ret == 0); /* there is no possible error case */\n\n        ok = vu_dispatch(&se->virtio_dev->dev);\n\n        pthread_rwlock_unlock(&se->virtio_dev->vu_dispatch_rwlock);\n\n        if (!ok) {\n            fuse_log(FUSE_LOG_ERR, \"%s: vu_dispatch failed\\n\", __func__);\n            break;\n        }\n    }\n\n    /*\n     * Make sure all fv_queue_thread()s quit on exit, as we're about to\n     * free virtio dev and fuse session, no one should access them anymore.\n     */\n    for (int i = 0; i < se->virtio_dev->nqueues; i++) {\n        if (!se->virtio_dev->qi[i]) {\n            continue;\n        }\n\n        fuse_log(FUSE_LOG_INFO, \"%s: Stopping queue %d thread\\n\", __func__, i);\n        fv_queue_cleanup_thread(se->virtio_dev, i);\n    }\n\n    fuse_log(FUSE_LOG_INFO, \"%s: Exit\\n\", __func__);\n\n    return 0;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nint virtio_loop(struct fuse_session *se)\n{\n    fuse_log(FUSE_LOG_INFO, \"%s: Entry\\n\", __func__);\n\n    while (!fuse_session_exited(se)) {\n        struct pollfd pf[1];\n        bool ok;\n        int ret;\n        pf[0].fd = se->vu_socketfd;\n        pf[0].events = POLLIN;\n        pf[0].revents = 0;\n\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Waiting for VU event\\n\", __func__);\n        int poll_res = ppoll(pf, 1, NULL, NULL);\n\n        if (poll_res == -1) {\n            if (errno == EINTR) {\n                fuse_log(FUSE_LOG_INFO, \"%s: ppoll interrupted, going around\\n\",\n                         __func__);\n                continue;\n            }\n            fuse_log(FUSE_LOG_ERR, \"virtio_loop ppoll: %m\\n\");\n            break;\n        }\n        assert(poll_res == 1);\n        if (pf[0].revents & (POLLERR | POLLHUP | POLLNVAL)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Unexpected poll revents %x\\n\", __func__,\n                     pf[0].revents);\n            break;\n        }\n        assert(pf[0].revents & POLLIN);\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Got VU event\\n\", __func__);\n        /* Mutual exclusion with fv_queue_thread() */\n        ret = pthread_rwlock_wrlock(&se->virtio_dev->vu_dispatch_rwlock);\n        assert(ret == 0); /* there is no possible error case */\n\n        ok = vu_dispatch(&se->virtio_dev->dev);\n\n        pthread_rwlock_unlock(&se->virtio_dev->vu_dispatch_rwlock);\n\n        if (!ok) {\n            fuse_log(FUSE_LOG_ERR, \"%s: vu_dispatch failed\\n\", __func__);\n            break;\n        }\n    }\n\n    /*\n     * Make sure all fv_queue_thread()s quit on exit, as we're about to\n     * free virtio dev and fuse session, no one should access them anymore.\n     */\n    for (int i = 0; i < se->virtio_dev->nqueues; i++) {\n        if (!se->virtio_dev->qi[i]) {\n            continue;\n        }\n\n        fuse_log(FUSE_LOG_INFO, \"%s: Stopping queue %d thread\\n\", __func__, i);\n        fv_queue_cleanup_thread(se->virtio_dev, i);\n    }\n\n    fuse_log(FUSE_LOG_INFO, \"%s: Exit\\n\", __func__);\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_root",
          "args": [
            "&lo",
            "&lo.root"
          ],
          "line": 2962
        },
        "resolved": true,
        "details": {
          "function_name": "setup_root",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2764-2787",
          "snippet": "static void setup_root(struct lo_data *lo, struct lo_inode *root)\n{\n    int fd, res;\n    struct stat stat;\n\n    fd = open(\"/\", O_PATH);\n    if (fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", lo->source);\n        exit(1);\n    }\n\n    res = fstatat(fd, \"\", &stat, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"fstatat(%s): %m\\n\", lo->source);\n        exit(1);\n    }\n\n    root->filetype = S_IFDIR;\n    root->fd = fd;\n    root->key.ino = stat.st_ino;\n    root->key.dev = stat.st_dev;\n    root->nlookup = 2;\n    g_atomic_int_set(&root->refcount, 2);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void setup_root(struct lo_data *lo, struct lo_inode *root)\n{\n    int fd, res;\n    struct stat stat;\n\n    fd = open(\"/\", O_PATH);\n    if (fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", lo->source);\n        exit(1);\n    }\n\n    res = fstatat(fd, \"\", &stat, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"fstatat(%s): %m\\n\", lo->source);\n        exit(1);\n    }\n\n    root->filetype = S_IFDIR;\n    root->fd = fd;\n    root->key.ino = stat.st_ino;\n    root->key.dev = stat.st_dev;\n    root->nlookup = 2;\n    g_atomic_int_set(&root->refcount, 2);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_sandbox",
          "args": [
            "&lo",
            "se",
            "opts.syslog"
          ],
          "line": 2960
        },
        "resolved": true,
        "details": {
          "function_name": "setup_sandbox",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2679-2686",
          "snippet": "static void setup_sandbox(struct lo_data *lo, struct fuse_session *se,\n                          bool enable_syslog)\n{\n    setup_namespaces(lo, se);\n    setup_mounts(lo->source);\n    setup_seccomp(enable_syslog);\n    setup_capabilities(g_strdup(lo->modcaps));\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void setup_sandbox(struct lo_data *lo, struct fuse_session *se,\n                          bool enable_syslog)\n{\n    setup_namespaces(lo, se);\n    setup_mounts(lo->source);\n    setup_seccomp(enable_syslog);\n    setup_capabilities(g_strdup(lo->modcaps));\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_capng",
          "args": [],
          "line": 2958
        },
        "resolved": true,
        "details": {
          "function_name": "setup_capng",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2494-2509",
          "snippet": "static void setup_capng(void)\n{\n    /* Note this accesses /proc so has to happen before the sandbox */\n    if (capng_get_caps_process()) {\n        fuse_log(FUSE_LOG_ERR, \"capng_get_caps_process\\n\");\n        exit(1);\n    }\n    pthread_mutex_init(&cap.mutex, NULL);\n    pthread_mutex_lock(&cap.mutex);\n    cap.saved = capng_save_state();\n    if (!cap.saved) {\n        fuse_log(FUSE_LOG_ERR, \"capng_save_state\\n\");\n        exit(1);\n    }\n    pthread_mutex_unlock(&cap.mutex);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);",
            "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\n\nstatic void setup_capng(void)\n{\n    /* Note this accesses /proc so has to happen before the sandbox */\n    if (capng_get_caps_process()) {\n        fuse_log(FUSE_LOG_ERR, \"capng_get_caps_process\\n\");\n        exit(1);\n    }\n    pthread_mutex_init(&cap.mutex, NULL);\n    pthread_mutex_lock(&cap.mutex);\n    cap.saved = capng_save_state();\n    if (!cap.saved) {\n        fuse_log(FUSE_LOG_ERR, \"capng_save_state\\n\");\n        exit(1);\n    }\n    pthread_mutex_unlock(&cap.mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_nofile_rlimit",
          "args": [
            "opts.rlimit_nofile"
          ],
          "line": 2955
        },
        "resolved": true,
        "details": {
          "function_name": "setup_nofile_rlimit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2689-2709",
          "snippet": "static void setup_nofile_rlimit(unsigned long rlimit_nofile)\n{\n    struct rlimit rlim = {\n        .rlim_cur = rlimit_nofile,\n        .rlim_max = rlimit_nofile,\n    };\n\n    if (rlimit_nofile == 0) {\n        return; /* nothing to do */\n    }\n\n    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        /* Ignore SELinux denials */\n        if (errno == EPERM) {\n            return;\n        }\n\n        fuse_log(FUSE_LOG_ERR, \"setrlimit(RLIMIT_NOFILE): %m\\n\");\n        exit(1);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void setup_nofile_rlimit(unsigned long rlimit_nofile)\n{\n    struct rlimit rlim = {\n        .rlim_cur = rlimit_nofile,\n        .rlim_max = rlimit_nofile,\n    };\n\n    if (rlimit_nofile == 0) {\n        return; /* nothing to do */\n    }\n\n    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        /* Ignore SELinux denials */\n        if (errno == EPERM) {\n            return;\n        }\n\n        fuse_log(FUSE_LOG_ERR, \"setrlimit(RLIMIT_NOFILE): %m\\n\");\n        exit(1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_daemonize",
          "args": [
            "opts.foreground"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_daemonize",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/helper.c",
          "lines": "261-330",
          "snippet": "int fuse_daemonize(int foreground)\n{\n    int ret = 0, rett;\n    if (!foreground) {\n        int nullfd;\n        int waiter[2];\n        char completed;\n\n        if (pipe(waiter)) {\n            fuse_log(FUSE_LOG_ERR, \"fuse_daemonize: pipe: %s\\n\",\n                     strerror(errno));\n            return -1;\n        }\n\n        /*\n         * demonize current process by forking it and killing the\n         * parent.  This makes current process as a child of 'init'.\n         */\n        switch (fork()) {\n        case -1:\n            fuse_log(FUSE_LOG_ERR, \"fuse_daemonize: fork: %s\\n\",\n                     strerror(errno));\n            return -1;\n        case 0:\n            break;\n        default:\n            _exit(read(waiter[0], &completed,\n                       sizeof(completed) != sizeof(completed)));\n        }\n\n        if (setsid() == -1) {\n            fuse_log(FUSE_LOG_ERR, \"fuse_daemonize: setsid: %s\\n\",\n                     strerror(errno));\n            return -1;\n        }\n\n        ret = chdir(\"/\");\n\n        nullfd = open(\"/dev/null\", O_RDWR, 0);\n        if (nullfd != -1) {\n            rett = dup2(nullfd, 0);\n            if (!ret) {\n                ret = rett;\n            }\n            rett = dup2(nullfd, 1);\n            if (!ret) {\n                ret = rett;\n            }\n            rett = dup2(nullfd, 2);\n            if (!ret) {\n                ret = rett;\n            }\n            if (nullfd > 2) {\n                close(nullfd);\n            }\n        }\n\n        /* Propagate completion of daemon initialization */\n        completed = 1;\n        rett = write(waiter[1], &completed, sizeof(completed));\n        if (!ret) {\n            ret = rett;\n        }\n        close(waiter[0]);\n        close(waiter[1]);\n    } else {\n        ret = chdir(\"/\");\n    }\n    return ret;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <limits.h>\n#include <errno.h>\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_daemonize(int foreground)\n{\n    int ret = 0, rett;\n    if (!foreground) {\n        int nullfd;\n        int waiter[2];\n        char completed;\n\n        if (pipe(waiter)) {\n            fuse_log(FUSE_LOG_ERR, \"fuse_daemonize: pipe: %s\\n\",\n                     strerror(errno));\n            return -1;\n        }\n\n        /*\n         * demonize current process by forking it and killing the\n         * parent.  This makes current process as a child of 'init'.\n         */\n        switch (fork()) {\n        case -1:\n            fuse_log(FUSE_LOG_ERR, \"fuse_daemonize: fork: %s\\n\",\n                     strerror(errno));\n            return -1;\n        case 0:\n            break;\n        default:\n            _exit(read(waiter[0], &completed,\n                       sizeof(completed) != sizeof(completed)));\n        }\n\n        if (setsid() == -1) {\n            fuse_log(FUSE_LOG_ERR, \"fuse_daemonize: setsid: %s\\n\",\n                     strerror(errno));\n            return -1;\n        }\n\n        ret = chdir(\"/\");\n\n        nullfd = open(\"/dev/null\", O_RDWR, 0);\n        if (nullfd != -1) {\n            rett = dup2(nullfd, 0);\n            if (!ret) {\n                ret = rett;\n            }\n            rett = dup2(nullfd, 1);\n            if (!ret) {\n                ret = rett;\n            }\n            rett = dup2(nullfd, 2);\n            if (!ret) {\n                ret = rett;\n            }\n            if (nullfd > 2) {\n                close(nullfd);\n            }\n        }\n\n        /* Propagate completion of daemon initialization */\n        completed = 1;\n        rett = write(waiter[1], &completed, sizeof(completed));\n        if (!ret) {\n            ret = rett;\n        }\n        close(waiter[0]);\n        close(waiter[1]);\n    } else {\n        ret = chdir(\"/\");\n    }\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_session_mount",
          "args": [
            "se"
          ],
          "line": 2949
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_mount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2661-2664",
          "snippet": "int fuse_session_mount(struct fuse_session *se)\n{\n    return virtio_session_mount(se);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_mount(struct fuse_session *se)\n{\n    return virtio_session_mount(se);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_set_signal_handlers",
          "args": [
            "se"
          ],
          "line": 2945
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_set_signal_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_signals.c",
          "lines": "65-83",
          "snippet": "int fuse_set_signal_handlers(struct fuse_session *se)\n{\n    /*\n     * If we used SIG_IGN instead of the do_nothing function,\n     * then we would be unable to tell if we set SIG_IGN (and\n     * thus should reset to SIG_DFL in fuse_remove_signal_handlers)\n     * or if it was already set to SIG_IGN (and should be left\n     * untouched.\n     */\n    if (set_one_signal_handler(SIGHUP, exit_handler, 0) == -1 ||\n        set_one_signal_handler(SIGINT, exit_handler, 0) == -1 ||\n        set_one_signal_handler(SIGTERM, exit_handler, 0) == -1 ||\n        set_one_signal_handler(SIGPIPE, do_nothing, 0) == -1) {\n        return -1;\n    }\n\n    fuse_instance = se;\n    return 0;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <signal.h>",
            "#include <errno.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct fuse_session *fuse_instance;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <signal.h>\n#include <errno.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct fuse_session *fuse_instance;\n\nint fuse_set_signal_handlers(struct fuse_session *se)\n{\n    /*\n     * If we used SIG_IGN instead of the do_nothing function,\n     * then we would be unable to tell if we set SIG_IGN (and\n     * thus should reset to SIG_DFL in fuse_remove_signal_handlers)\n     * or if it was already set to SIG_IGN (and should be left\n     * untouched.\n     */\n    if (set_one_signal_handler(SIGHUP, exit_handler, 0) == -1 ||\n        set_one_signal_handler(SIGINT, exit_handler, 0) == -1 ||\n        set_one_signal_handler(SIGTERM, exit_handler, 0) == -1 ||\n        set_one_signal_handler(SIGPIPE, do_nothing, 0) == -1) {\n        return -1;\n    }\n\n    fuse_instance = se;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_session_new",
          "args": [
            "&args",
            "&lo_oper",
            "sizeof(lo_oper)",
            "&lo"
          ],
          "line": 2940
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_new",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2577-2659",
          "snippet": "struct fuse_session *fuse_session_new(struct fuse_args *args,\n                                      const struct fuse_lowlevel_ops *op,\n                                      size_t op_size, void *userdata)\n{\n    struct fuse_session *se;\n\n    if (sizeof(struct fuse_lowlevel_ops) < op_size) {\n        fuse_log(\n            FUSE_LOG_ERR,\n            \"fuse: warning: library too old, some operations may not work\\n\");\n        op_size = sizeof(struct fuse_lowlevel_ops);\n    }\n\n    if (args->argc == 0) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"fuse: empty argv passed to fuse_session_new().\\n\");\n        return NULL;\n    }\n\n    se = (struct fuse_session *)calloc(1, sizeof(struct fuse_session));\n    if (se == NULL) {\n        fuse_log(FUSE_LOG_ERR, \"fuse: failed to allocate fuse object\\n\");\n        goto out1;\n    }\n    se->fd = -1;\n    se->vu_listen_fd = -1;\n    se->thread_pool_size = THREAD_POOL_SIZE;\n    se->conn.max_write = UINT_MAX;\n    se->conn.max_readahead = UINT_MAX;\n\n    /* Parse options */\n    if (fuse_opt_parse(args, se, fuse_ll_opts, NULL) == -1) {\n        goto out2;\n    }\n    if (args->argc == 1 && args->argv[0][0] == '-') {\n        fuse_log(FUSE_LOG_ERR,\n                 \"fuse: warning: argv[0] looks like an option, but \"\n                 \"will be ignored\\n\");\n    } else if (args->argc != 1) {\n        int i;\n        fuse_log(FUSE_LOG_ERR, \"fuse: unknown option(s): `\");\n        for (i = 1; i < args->argc - 1; i++) {\n            fuse_log(FUSE_LOG_ERR, \"%s \", args->argv[i]);\n        }\n        fuse_log(FUSE_LOG_ERR, \"%s'\\n\", args->argv[i]);\n        goto out4;\n    }\n\n    if (!se->vu_socket_path && se->vu_listen_fd < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fuse: missing --socket-path or --fd option\\n\");\n        goto out4;\n    }\n    if (se->vu_socket_path && se->vu_listen_fd >= 0) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"fuse: --socket-path and --fd cannot be given together\\n\");\n        goto out4;\n    }\n    if (se->vu_socket_group && !se->vu_socket_path) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"fuse: --socket-group can only be used with --socket-path\\n\");\n        goto out4;\n    }\n\n    se->bufsize = FUSE_MAX_MAX_PAGES * getpagesize() + FUSE_BUFFER_HEADER_SIZE;\n\n    list_init_req(&se->list);\n    list_init_req(&se->interrupts);\n    fuse_mutex_init(&se->lock);\n    pthread_rwlock_init(&se->init_rwlock, NULL);\n\n    memcpy(&se->op, op, op_size);\n    se->owner = getuid();\n    se->userdata = userdata;\n\n    return se;\n\nout4:\n    fuse_opt_free_args(args);\nout2:\n    free(se);\nout1:\n    return NULL;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [
            "#define THREAD_POOL_SIZE 64"
          ],
          "globals_used": [
            "static const struct fuse_opt fuse_ll_opts[] = {\n    LL_OPTION(\"debug\", debug, 1),\n    LL_OPTION(\"-d\", debug, 1),\n    LL_OPTION(\"--debug\", debug, 1),\n    LL_OPTION(\"allow_root\", deny_others, 1),\n    LL_OPTION(\"--socket-path=%s\", vu_socket_path, 0),\n    LL_OPTION(\"--socket-group=%s\", vu_socket_group, 0),\n    LL_OPTION(\"--fd=%d\", vu_listen_fd, 0),\n    LL_OPTION(\"--thread-pool-size=%d\", thread_pool_size, 0),\n    FUSE_OPT_END\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\n#define THREAD_POOL_SIZE 64\n\nstatic const struct fuse_opt fuse_ll_opts[] = {\n    LL_OPTION(\"debug\", debug, 1),\n    LL_OPTION(\"-d\", debug, 1),\n    LL_OPTION(\"--debug\", debug, 1),\n    LL_OPTION(\"allow_root\", deny_others, 1),\n    LL_OPTION(\"--socket-path=%s\", vu_socket_path, 0),\n    LL_OPTION(\"--socket-group=%s\", vu_socket_group, 0),\n    LL_OPTION(\"--fd=%d\", vu_listen_fd, 0),\n    LL_OPTION(\"--thread-pool-size=%d\", thread_pool_size, 0),\n    FUSE_OPT_END\n};\n\nstruct fuse_session *fuse_session_new(struct fuse_args *args,\n                                      const struct fuse_lowlevel_ops *op,\n                                      size_t op_size, void *userdata)\n{\n    struct fuse_session *se;\n\n    if (sizeof(struct fuse_lowlevel_ops) < op_size) {\n        fuse_log(\n            FUSE_LOG_ERR,\n            \"fuse: warning: library too old, some operations may not work\\n\");\n        op_size = sizeof(struct fuse_lowlevel_ops);\n    }\n\n    if (args->argc == 0) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"fuse: empty argv passed to fuse_session_new().\\n\");\n        return NULL;\n    }\n\n    se = (struct fuse_session *)calloc(1, sizeof(struct fuse_session));\n    if (se == NULL) {\n        fuse_log(FUSE_LOG_ERR, \"fuse: failed to allocate fuse object\\n\");\n        goto out1;\n    }\n    se->fd = -1;\n    se->vu_listen_fd = -1;\n    se->thread_pool_size = THREAD_POOL_SIZE;\n    se->conn.max_write = UINT_MAX;\n    se->conn.max_readahead = UINT_MAX;\n\n    /* Parse options */\n    if (fuse_opt_parse(args, se, fuse_ll_opts, NULL) == -1) {\n        goto out2;\n    }\n    if (args->argc == 1 && args->argv[0][0] == '-') {\n        fuse_log(FUSE_LOG_ERR,\n                 \"fuse: warning: argv[0] looks like an option, but \"\n                 \"will be ignored\\n\");\n    } else if (args->argc != 1) {\n        int i;\n        fuse_log(FUSE_LOG_ERR, \"fuse: unknown option(s): `\");\n        for (i = 1; i < args->argc - 1; i++) {\n            fuse_log(FUSE_LOG_ERR, \"%s \", args->argv[i]);\n        }\n        fuse_log(FUSE_LOG_ERR, \"%s'\\n\", args->argv[i]);\n        goto out4;\n    }\n\n    if (!se->vu_socket_path && se->vu_listen_fd < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fuse: missing --socket-path or --fd option\\n\");\n        goto out4;\n    }\n    if (se->vu_socket_path && se->vu_listen_fd >= 0) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"fuse: --socket-path and --fd cannot be given together\\n\");\n        goto out4;\n    }\n    if (se->vu_socket_group && !se->vu_socket_path) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"fuse: --socket-group can only be used with --socket-path\\n\");\n        goto out4;\n    }\n\n    se->bufsize = FUSE_MAX_MAX_PAGES * getpagesize() + FUSE_BUFFER_HEADER_SIZE;\n\n    list_init_req(&se->list);\n    list_init_req(&se->interrupts);\n    fuse_mutex_init(&se->lock);\n    pthread_rwlock_init(&se->init_rwlock, NULL);\n\n    memcpy(&se->op, op, op_size);\n    se->owner = getuid();\n    se->userdata = userdata;\n\n    return se;\n\nout4:\n    fuse_opt_free_args(args);\nout2:\n    free(se);\nout1:\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2937
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"timeout is negative (%lf)\\n\"",
            "lo.timeout"
          ],
          "line": 2936
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"/\""
          ],
          "line": 2919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stat.st_mode"
          ],
          "line": 2914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lstat",
          "args": [
            "lo.source",
            "&stat"
          ],
          "line": 2908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_opt_parse",
          "args": [
            "&args",
            "&lo",
            "lo_opts",
            "NULL"
          ],
          "line": 2889
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_opt_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_opt.c",
          "lines": "424-450",
          "snippet": "int fuse_opt_parse(struct fuse_args *args, void *data,\n                   const struct fuse_opt opts[], fuse_opt_proc_t proc)\n{\n    int res;\n    struct fuse_opt_context ctx = {\n        .data = data,\n        .opt = opts,\n        .proc = proc,\n    };\n\n    if (!args || !args->argv || !args->argc) {\n        return 0;\n    }\n\n    ctx.argc = args->argc;\n    ctx.argv = args->argv;\n\n    res = opt_parse(&ctx);\n    if (res != -1) {\n        struct fuse_args tmp = *args;\n        *args = ctx.outargs;\n        ctx.outargs = tmp;\n    }\n    free(ctx.opts);\n    fuse_opt_free_args(&ctx.outargs);\n    return res;\n}",
          "includes": [
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <assert.h>",
            "#include \"fuse_misc.h\"",
            "#include \"fuse_i.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <assert.h>\n#include \"fuse_misc.h\"\n#include \"fuse_i.h\"\n#include \"fuse_opt.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_opt_parse(struct fuse_args *args, void *data,\n                   const struct fuse_opt opts[], fuse_opt_proc_t proc)\n{\n    int res;\n    struct fuse_opt_context ctx = {\n        .data = data,\n        .opt = opts,\n        .proc = proc,\n    };\n\n    if (!args || !args->argv || !args->argc) {\n        return 0;\n    }\n\n    ctx.argc = args->argc;\n    ctx.argv = args->argv;\n\n    res = opt_parse(&ctx);\n    if (res != -1) {\n        struct fuse_args tmp = *args;\n        *args = ctx.outargs;\n        ctx.outargs = tmp;\n    }\n    free(ctx.opts);\n    fuse_opt_free_args(&ctx.outargs);\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_capabilities",
          "args": [],
          "line": 2884
        },
        "resolved": true,
        "details": {
          "function_name": "print_capabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2372-2377",
          "snippet": "static void print_capabilities(void)\n{\n    printf(\"{\\n\");\n    printf(\"  \\\"type\\\": \\\"fs\\\"\\n\");\n    printf(\"}\\n\");\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void print_capabilities(void)\n{\n    printf(\"{\\n\");\n    printf(\"  \\\"type\\\": \\\"fs\\\"\\n\");\n    printf(\"}\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lowlevel_version",
          "args": [],
          "line": 2880
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lowlevel_version",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2532-2536",
          "snippet": "void fuse_lowlevel_version(void)\n{\n    printf(\"using FUSE kernel interface version %i.%i\\n\", FUSE_KERNEL_VERSION,\n           FUSE_KERNEL_MINOR_VERSION);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_lowlevel_version(void)\n{\n    printf(\"using FUSE kernel interface version %i.%i\\n\", FUSE_KERNEL_VERSION,\n           FUSE_KERNEL_MINOR_VERSION);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_lowlevel_help",
          "args": [],
          "line": 2876
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lowlevel_help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2538-2550",
          "snippet": "void fuse_lowlevel_help(void)\n{\n    /*\n     * These are not all options, but the ones that are\n     * potentially of interest to an end-user\n     */\n    printf(\n        \"    -o allow_root              allow access by root\\n\"\n        \"    --socket-path=PATH         path for the vhost-user socket\\n\"\n        \"    --fd=FDNUM                 fd number of vhost-user socket\\n\"\n        \"    --thread-pool-size=NUM     thread pool size limit (default %d)\\n\",\n        THREAD_POOL_SIZE);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [
            "#define THREAD_POOL_SIZE 64"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\n#define THREAD_POOL_SIZE 64\n\nvoid fuse_lowlevel_help(void)\n{\n    /*\n     * These are not all options, but the ones that are\n     * potentially of interest to an end-user\n     */\n    printf(\n        \"    -o allow_root              allow access by root\\n\"\n        \"    --socket-path=PATH         path for the vhost-user socket\\n\"\n        \"    --fd=FDNUM                 fd number of vhost-user socket\\n\"\n        \"    --thread-pool-size=NUM     thread pool size limit (default %d)\\n\",\n        THREAD_POOL_SIZE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"    -o source=PATH             shared directory tree\\n\""
          ],
          "line": 2875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_cmdline_help",
          "args": [],
          "line": 2874
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_cmdline_help",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/helper.c",
          "lines": "142-186",
          "snippet": "void fuse_cmdline_help(void)\n{\n    printf(\"    -h   --help                print help\\n\"\n           \"    -V   --version             print version\\n\"\n           \"    --print-capabilities       print vhost-user.json\\n\"\n           \"    -d   -o debug              enable debug output (implies -f)\\n\"\n           \"    --syslog                   log to syslog (default stderr)\\n\"\n           \"    -f                         foreground operation\\n\"\n           \"    --daemonize                run in background\\n\"\n           \"    -o cache=<mode>            cache mode. could be one of \\\"auto, \"\n           \"always, none\\\"\\n\"\n           \"                               default: auto\\n\"\n           \"    -o flock|no_flock          enable/disable flock\\n\"\n           \"                               default: no_flock\\n\"\n           \"    -o log_level=<level>       log level, default to \\\"info\\\"\\n\"\n           \"                               level could be one of \\\"debug, \"\n           \"info, warn, err\\\"\\n\"\n           \"    -o max_idle_threads        the maximum number of idle worker \"\n           \"threads\\n\"\n           \"                               allowed (default: 10)\\n\"\n           \"    -o posix_lock|no_posix_lock\\n\"\n           \"                               enable/disable remote posix lock\\n\"\n           \"                               default: posix_lock\\n\"\n           \"    -o readdirplus|no_readdirplus\\n\"\n           \"                               enable/disable readirplus\\n\"\n           \"                               default: readdirplus except with \"\n           \"cache=none\\n\"\n           \"    -o timeout=<number>        I/O timeout (seconds)\\n\"\n           \"                               default: depends on cache= option.\\n\"\n           \"    -o writeback|no_writeback  enable/disable writeback cache\\n\"\n           \"                               default: no_writeback\\n\"\n           \"    -o xattr|no_xattr          enable/disable xattr\\n\"\n           \"                               default: no_xattr\\n\"\n           \"    -o modcaps=CAPLIST         Modify the list of capabilities\\n\"\n           \"                               e.g. -o modcaps=+sys_admin:-chown\\n\"\n           \"    --rlimit-nofile=<num>      set maximum number of file descriptors\\n\"\n           \"                               (0 leaves rlimit unchanged)\\n\"\n           \"                               default: min(1000000, fs.file-max - 16384)\\n\"\n           \"                                        if the current rlimit is lower\\n\"\n           \"    -o allow_direct_io|no_allow_direct_io\\n\"\n           \"                               retain/discard O_DIRECT flags passed down\\n\"\n           \"                               to virtiofsd from guest applications.\\n\"\n           \"                               default: no_allow_direct_io\\n\"\n           );\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <limits.h>\n#include <errno.h>\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_cmdline_help(void)\n{\n    printf(\"    -h   --help                print help\\n\"\n           \"    -V   --version             print version\\n\"\n           \"    --print-capabilities       print vhost-user.json\\n\"\n           \"    -d   -o debug              enable debug output (implies -f)\\n\"\n           \"    --syslog                   log to syslog (default stderr)\\n\"\n           \"    -f                         foreground operation\\n\"\n           \"    --daemonize                run in background\\n\"\n           \"    -o cache=<mode>            cache mode. could be one of \\\"auto, \"\n           \"always, none\\\"\\n\"\n           \"                               default: auto\\n\"\n           \"    -o flock|no_flock          enable/disable flock\\n\"\n           \"                               default: no_flock\\n\"\n           \"    -o log_level=<level>       log level, default to \\\"info\\\"\\n\"\n           \"                               level could be one of \\\"debug, \"\n           \"info, warn, err\\\"\\n\"\n           \"    -o max_idle_threads        the maximum number of idle worker \"\n           \"threads\\n\"\n           \"                               allowed (default: 10)\\n\"\n           \"    -o posix_lock|no_posix_lock\\n\"\n           \"                               enable/disable remote posix lock\\n\"\n           \"                               default: posix_lock\\n\"\n           \"    -o readdirplus|no_readdirplus\\n\"\n           \"                               enable/disable readirplus\\n\"\n           \"                               default: readdirplus except with \"\n           \"cache=none\\n\"\n           \"    -o timeout=<number>        I/O timeout (seconds)\\n\"\n           \"                               default: depends on cache= option.\\n\"\n           \"    -o writeback|no_writeback  enable/disable writeback cache\\n\"\n           \"                               default: no_writeback\\n\"\n           \"    -o xattr|no_xattr          enable/disable xattr\\n\"\n           \"                               default: no_xattr\\n\"\n           \"    -o modcaps=CAPLIST         Modify the list of capabilities\\n\"\n           \"                               e.g. -o modcaps=+sys_admin:-chown\\n\"\n           \"    --rlimit-nofile=<num>      set maximum number of file descriptors\\n\"\n           \"                               (0 leaves rlimit unchanged)\\n\"\n           \"                               default: min(1000000, fs.file-max - 16384)\\n\"\n           \"                                        if the current rlimit is lower\\n\"\n           \"    -o allow_direct_io|no_allow_direct_io\\n\"\n           \"                               retain/discard O_DIRECT flags passed down\\n\"\n           \"                               to virtiofsd from guest applications.\\n\"\n           \"                               default: no_allow_direct_io\\n\"\n           );\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"usage: %s [options]\\n\\n\"",
            "argv[0]"
          ],
          "line": 2873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openlog",
          "args": [
            "\"virtiofsd\"",
            "LOG_PID",
            "LOG_DAEMON"
          ],
          "line": 2869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_set_log_func",
          "args": [
            "log_func"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_set_log_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "25-32",
          "snippet": "void fuse_set_log_func(fuse_log_func_t func)\n{\n    if (!func) {\n        func = default_log_func;\n    }\n\n    log_func = func;\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_set_log_func(fuse_log_func_t func)\n{\n    if (!func) {\n        func = default_log_func;\n    }\n\n    log_func = func;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_parse_cmdline",
          "args": [
            "&args",
            "&opts"
          ],
          "line": 2863
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_parse_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/helper.c",
          "lines": "244-258",
          "snippet": "int fuse_parse_cmdline(struct fuse_args *args, struct fuse_cmdline_opts *opts)\n{\n    memset(opts, 0, sizeof(struct fuse_cmdline_opts));\n\n    opts->max_idle_threads = 10;\n    opts->rlimit_nofile = get_default_rlimit_nofile();\n    opts->foreground = 1;\n\n    if (fuse_opt_parse(args, opts, fuse_helper_opts, fuse_helper_opt_proc) ==\n        -1) {\n        return -1;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/resource.h>",
            "#include <sys/time.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <limits.h>",
            "#include <errno.h>",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct fuse_opt fuse_helper_opts[] = {\n    FUSE_HELPER_OPT(\"-h\", show_help),\n    FUSE_HELPER_OPT(\"--help\", show_help),\n    FUSE_HELPER_OPT(\"-V\", show_version),\n    FUSE_HELPER_OPT(\"--version\", show_version),\n    FUSE_HELPER_OPT(\"--print-capabilities\", print_capabilities),\n    FUSE_HELPER_OPT(\"-d\", debug),\n    FUSE_HELPER_OPT(\"debug\", debug),\n    FUSE_HELPER_OPT(\"-d\", foreground),\n    FUSE_HELPER_OPT(\"debug\", foreground),\n    FUSE_OPT_KEY(\"-d\", FUSE_OPT_KEY_KEEP),\n    FUSE_OPT_KEY(\"debug\", FUSE_OPT_KEY_KEEP),\n    FUSE_HELPER_OPT(\"-f\", foreground),\n    FUSE_HELPER_OPT_VALUE(\"--daemonize\", foreground, 0),\n    FUSE_HELPER_OPT(\"fsname=\", nodefault_subtype),\n    FUSE_OPT_KEY(\"fsname=\", FUSE_OPT_KEY_KEEP),\n    FUSE_HELPER_OPT(\"subtype=\", nodefault_subtype),\n    FUSE_OPT_KEY(\"subtype=\", FUSE_OPT_KEY_KEEP),\n    FUSE_HELPER_OPT(\"max_idle_threads=%u\", max_idle_threads),\n    FUSE_HELPER_OPT(\"--rlimit-nofile=%lu\", rlimit_nofile),\n    FUSE_HELPER_OPT(\"--syslog\", syslog),\n    FUSE_HELPER_OPT_VALUE(\"log_level=debug\", log_level, FUSE_LOG_DEBUG),\n    FUSE_HELPER_OPT_VALUE(\"log_level=info\", log_level, FUSE_LOG_INFO),\n    FUSE_HELPER_OPT_VALUE(\"log_level=warn\", log_level, FUSE_LOG_WARNING),\n    FUSE_HELPER_OPT_VALUE(\"log_level=err\", log_level, FUSE_LOG_ERR),\n    FUSE_OPT_END\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/resource.h>\n#include <sys/time.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <limits.h>\n#include <errno.h>\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic const struct fuse_opt fuse_helper_opts[] = {\n    FUSE_HELPER_OPT(\"-h\", show_help),\n    FUSE_HELPER_OPT(\"--help\", show_help),\n    FUSE_HELPER_OPT(\"-V\", show_version),\n    FUSE_HELPER_OPT(\"--version\", show_version),\n    FUSE_HELPER_OPT(\"--print-capabilities\", print_capabilities),\n    FUSE_HELPER_OPT(\"-d\", debug),\n    FUSE_HELPER_OPT(\"debug\", debug),\n    FUSE_HELPER_OPT(\"-d\", foreground),\n    FUSE_HELPER_OPT(\"debug\", foreground),\n    FUSE_OPT_KEY(\"-d\", FUSE_OPT_KEY_KEEP),\n    FUSE_OPT_KEY(\"debug\", FUSE_OPT_KEY_KEEP),\n    FUSE_HELPER_OPT(\"-f\", foreground),\n    FUSE_HELPER_OPT_VALUE(\"--daemonize\", foreground, 0),\n    FUSE_HELPER_OPT(\"fsname=\", nodefault_subtype),\n    FUSE_OPT_KEY(\"fsname=\", FUSE_OPT_KEY_KEEP),\n    FUSE_HELPER_OPT(\"subtype=\", nodefault_subtype),\n    FUSE_OPT_KEY(\"subtype=\", FUSE_OPT_KEY_KEEP),\n    FUSE_HELPER_OPT(\"max_idle_threads=%u\", max_idle_threads),\n    FUSE_HELPER_OPT(\"--rlimit-nofile=%lu\", rlimit_nofile),\n    FUSE_HELPER_OPT(\"--syslog\", syslog),\n    FUSE_HELPER_OPT_VALUE(\"log_level=debug\", log_level, FUSE_LOG_DEBUG),\n    FUSE_HELPER_OPT_VALUE(\"log_level=info\", log_level, FUSE_LOG_INFO),\n    FUSE_HELPER_OPT_VALUE(\"log_level=warn\", log_level, FUSE_LOG_WARNING),\n    FUSE_HELPER_OPT_VALUE(\"log_level=err\", log_level, FUSE_LOG_ERR),\n    FUSE_OPT_END\n};\n\nint fuse_parse_cmdline(struct fuse_args *args, struct fuse_cmdline_opts *opts)\n{\n    memset(opts, 0, sizeof(struct fuse_cmdline_opts));\n\n    opts->max_idle_threads = 10;\n    opts->rlimit_nofile = get_default_rlimit_nofile();\n    opts->foreground = 1;\n\n    if (fuse_opt_parse(args, opts, fuse_helper_opts, fuse_helper_opt_proc) ==\n        -1) {\n        return -1;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_map_init",
          "args": [
            "&lo.fd_map"
          ],
          "line": 2861
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "339-344",
          "snippet": "static void lo_map_init(struct lo_map *map)\n{\n    map->elems = NULL;\n    map->nelems = 0;\n    map->freelist = -1;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_map_init(struct lo_map *map)\n{\n    map->elems = NULL;\n    map->nelems = 0;\n    map->freelist = -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_map_reserve",
          "args": [
            "&lo.ino_map",
            "lo.root.fuse_ino"
          ],
          "line": 2857
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "393-412",
          "snippet": "static struct lo_map_elem *lo_map_reserve(struct lo_map *map, size_t key)\n{\n    ssize_t *prev;\n\n    if (!lo_map_grow(map, key + 1)) {\n        return NULL;\n    }\n\n    for (prev = &map->freelist; *prev != -1;\n         prev = &map->elems[*prev].freelist) {\n        if (*prev == key) {\n            struct lo_map_elem *elem = &map->elems[key];\n\n            *prev = elem->freelist;\n            elem->in_use = true;\n            return elem;\n        }\n    }\n    return NULL;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_map_elem *lo_map_reserve(struct lo_map *map, size_t key)\n{\n    ssize_t *prev;\n\n    if (!lo_map_grow(map, key + 1)) {\n        return NULL;\n    }\n\n    for (prev = &map->freelist; *prev != -1;\n         prev = &map->elems[*prev].freelist) {\n        if (*prev == key) {\n            struct lo_map_elem *elem = &map->elems[key];\n\n            *prev = elem->freelist;\n            elem->in_use = true;\n            return elem;\n        }\n    }\n    return NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_hash_table_new",
          "args": [
            "lo_key_hash",
            "lo_key_equal"
          ],
          "line": 2845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_init",
          "args": [
            "&lo.mutex",
            "NULL"
          ],
          "line": 2844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemu_init_exec_dir",
          "args": [
            "argv[0]"
          ],
          "line": 2842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "0"
          ],
          "line": 2840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FUSE_ARGS_INIT",
          "args": [
            "argc",
            "argv"
          ],
          "line": 2826
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic const struct fuse_opt lo_opts[] = {\n    { \"writeback\", offsetof(struct lo_data, writeback), 1 },\n    { \"no_writeback\", offsetof(struct lo_data, writeback), 0 },\n    { \"source=%s\", offsetof(struct lo_data, source), 0 },\n    { \"flock\", offsetof(struct lo_data, flock), 1 },\n    { \"no_flock\", offsetof(struct lo_data, flock), 0 },\n    { \"posix_lock\", offsetof(struct lo_data, posix_lock), 1 },\n    { \"no_posix_lock\", offsetof(struct lo_data, posix_lock), 0 },\n    { \"xattr\", offsetof(struct lo_data, xattr), 1 },\n    { \"no_xattr\", offsetof(struct lo_data, xattr), 0 },\n    { \"modcaps=%s\", offsetof(struct lo_data, modcaps), 0 },\n    { \"timeout=%lf\", offsetof(struct lo_data, timeout), 0 },\n    { \"timeout=\", offsetof(struct lo_data, timeout_set), 1 },\n    { \"cache=none\", offsetof(struct lo_data, cache), CACHE_NONE },\n    { \"cache=auto\", offsetof(struct lo_data, cache), CACHE_AUTO },\n    { \"cache=always\", offsetof(struct lo_data, cache), CACHE_ALWAYS },\n    { \"readdirplus\", offsetof(struct lo_data, readdirplus_set), 1 },\n    { \"no_readdirplus\", offsetof(struct lo_data, readdirplus_clear), 1 },\n    { \"allow_direct_io\", offsetof(struct lo_data, allow_direct_io), 1 },\n    { \"no_allow_direct_io\", offsetof(struct lo_data, allow_direct_io), 0 },\n    FUSE_OPT_END\n};\nstatic bool use_syslog = false;\nstatic int current_log_level;\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\nstatic struct fuse_lowlevel_ops lo_oper = {\n    .init = lo_init,\n    .lookup = lo_lookup,\n    .mkdir = lo_mkdir,\n    .mknod = lo_mknod,\n    .symlink = lo_symlink,\n    .link = lo_link,\n    .unlink = lo_unlink,\n    .rmdir = lo_rmdir,\n    .rename = lo_rename,\n    .forget = lo_forget,\n    .forget_multi = lo_forget_multi,\n    .getattr = lo_getattr,\n    .setattr = lo_setattr,\n    .readlink = lo_readlink,\n    .opendir = lo_opendir,\n    .readdir = lo_readdir,\n    .readdirplus = lo_readdirplus,\n    .releasedir = lo_releasedir,\n    .fsyncdir = lo_fsyncdir,\n    .create = lo_create,\n    .getlk = lo_getlk,\n    .setlk = lo_setlk,\n    .open = lo_open,\n    .release = lo_release,\n    .flush = lo_flush,\n    .fsync = lo_fsync,\n    .read = lo_read,\n    .write_buf = lo_write_buf,\n    .statfs = lo_statfs,\n    .fallocate = lo_fallocate,\n    .flock = lo_flock,\n    .getxattr = lo_getxattr,\n    .listxattr = lo_listxattr,\n    .setxattr = lo_setxattr,\n    .removexattr = lo_removexattr,\n#ifdef HAVE_COPY_FILE_RANGE\n    .copy_file_range = lo_copy_file_range,\n#endif\n    .lseek = lo_lseek,\n    .destroy = lo_destroy,\n};\n\nint main(int argc, char *argv[])\n{\n    struct fuse_args args = FUSE_ARGS_INIT(argc, argv);\n    struct fuse_session *se;\n    struct fuse_cmdline_opts opts;\n    struct lo_data lo = {\n        .debug = 0,\n        .writeback = 0,\n        .posix_lock = 0,\n        .allow_direct_io = 0,\n        .proc_self_fd = -1,\n    };\n    struct lo_map_elem *root_elem;\n    int ret = -1;\n\n    /* Don't mask creation mode, kernel already did that */\n    umask(0);\n\n    qemu_init_exec_dir(argv[0]);\n\n    pthread_mutex_init(&lo.mutex, NULL);\n    lo.inodes = g_hash_table_new(lo_key_hash, lo_key_equal);\n    lo.root.fd = -1;\n    lo.root.fuse_ino = FUSE_ROOT_ID;\n    lo.cache = CACHE_AUTO;\n\n    /*\n     * Set up the ino map like this:\n     * [0] Reserved (will not be used)\n     * [1] Root inode\n     */\n    lo_map_init(&lo.ino_map);\n    lo_map_reserve(&lo.ino_map, 0)->in_use = false;\n    root_elem = lo_map_reserve(&lo.ino_map, lo.root.fuse_ino);\n    root_elem->inode = &lo.root;\n\n    lo_map_init(&lo.dirp_map);\n    lo_map_init(&lo.fd_map);\n\n    if (fuse_parse_cmdline(&args, &opts) != 0) {\n        goto err_out1;\n    }\n    fuse_set_log_func(log_func);\n    use_syslog = opts.syslog;\n    if (use_syslog) {\n        openlog(\"virtiofsd\", LOG_PID, LOG_DAEMON);\n    }\n\n    if (opts.show_help) {\n        printf(\"usage: %s [options]\\n\\n\", argv[0]);\n        fuse_cmdline_help();\n        printf(\"    -o source=PATH             shared directory tree\\n\");\n        fuse_lowlevel_help();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.show_version) {\n        fuse_lowlevel_version();\n        ret = 0;\n        goto err_out1;\n    } else if (opts.print_capabilities) {\n        print_capabilities();\n        ret = 0;\n        goto err_out1;\n    }\n\n    if (fuse_opt_parse(&args, &lo, lo_opts, NULL) == -1) {\n        goto err_out1;\n    }\n\n    /*\n     * log_level is 0 if not configured via cmd options (0 is LOG_EMERG,\n     * and we don't use this log level).\n     */\n    if (opts.log_level != 0) {\n        current_log_level = opts.log_level;\n    }\n    lo.debug = opts.debug;\n    if (lo.debug) {\n        current_log_level = FUSE_LOG_DEBUG;\n    }\n    if (lo.source) {\n        struct stat stat;\n        int res;\n\n        res = lstat(lo.source, &stat);\n        if (res == -1) {\n            fuse_log(FUSE_LOG_ERR, \"failed to stat source (\\\"%s\\\"): %m\\n\",\n                     lo.source);\n            exit(1);\n        }\n        if (!S_ISDIR(stat.st_mode)) {\n            fuse_log(FUSE_LOG_ERR, \"source is not a directory\\n\");\n            exit(1);\n        }\n    } else {\n        lo.source = strdup(\"/\");\n    }\n    if (!lo.timeout_set) {\n        switch (lo.cache) {\n        case CACHE_NONE:\n            lo.timeout = 0.0;\n            break;\n\n        case CACHE_AUTO:\n            lo.timeout = 1.0;\n            break;\n\n        case CACHE_ALWAYS:\n            lo.timeout = 86400.0;\n            break;\n        }\n    } else if (lo.timeout < 0) {\n        fuse_log(FUSE_LOG_ERR, \"timeout is negative (%lf)\\n\", lo.timeout);\n        exit(1);\n    }\n\n    se = fuse_session_new(&args, &lo_oper, sizeof(lo_oper), &lo);\n    if (se == NULL) {\n        goto err_out1;\n    }\n\n    if (fuse_set_signal_handlers(se) != 0) {\n        goto err_out2;\n    }\n\n    if (fuse_session_mount(se) != 0) {\n        goto err_out3;\n    }\n\n    fuse_daemonize(opts.foreground);\n\n    setup_nofile_rlimit(opts.rlimit_nofile);\n\n    /* Must be before sandbox since it wants /proc */\n    setup_capng();\n\n    setup_sandbox(&lo, se, opts.syslog);\n\n    setup_root(&lo, &lo.root);\n    /* Block until ctrl+c or fusermount -u */\n    ret = virtio_loop(se);\n\n    fuse_session_unmount(se);\n    cleanup_capng();\nerr_out3:\n    fuse_remove_signal_handlers(se);\nerr_out2:\n    fuse_session_destroy(se);\nerr_out1:\n    fuse_opt_free_args(&args);\n\n    fuse_lo_data_cleanup(&lo);\n\n    return ret ? 1 : 0;\n}"
  },
  {
    "function_name": "fuse_lo_data_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2804-2822",
    "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "lo->source"
          ],
          "line": 2821
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "lo->root.fd"
          ],
          "line": 2818
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_map_destroy",
          "args": [
            "&lo->ino_map"
          ],
          "line": 2811
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "346-349",
          "snippet": "static void lo_map_destroy(struct lo_map *map)\n{\n    free(map->elems);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_map_destroy(struct lo_map *map)\n{\n    free(map->elems);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_hash_table_destroy",
          "args": [
            "lo->inodes"
          ],
          "line": 2807
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
  },
  {
    "function_name": "lo_key_equal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2796-2802",
    "snippet": "static gboolean lo_key_equal(gconstpointer a, gconstpointer b)\n{\n    const struct lo_key *la = a;\n    const struct lo_key *lb = b;\n\n    return la->ino == lb->ino && la->dev == lb->dev;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic gboolean lo_key_equal(gconstpointer a, gconstpointer b)\n{\n    const struct lo_key *la = a;\n    const struct lo_key *lb = b;\n\n    return la->ino == lb->ino && la->dev == lb->dev;\n}"
  },
  {
    "function_name": "lo_key_hash",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2789-2794",
    "snippet": "static guint lo_key_hash(gconstpointer key)\n{\n    const struct lo_key *lkey = key;\n\n    return (guint)lkey->ino + (guint)lkey->dev;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic guint lo_key_hash(gconstpointer key)\n{\n    const struct lo_key *lkey = key;\n\n    return (guint)lkey->ino + (guint)lkey->dev;\n}"
  },
  {
    "function_name": "setup_root",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2764-2787",
    "snippet": "static void setup_root(struct lo_data *lo, struct lo_inode *root)\n{\n    int fd, res;\n    struct stat stat;\n\n    fd = open(\"/\", O_PATH);\n    if (fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", lo->source);\n        exit(1);\n    }\n\n    res = fstatat(fd, \"\", &stat, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"fstatat(%s): %m\\n\", lo->source);\n        exit(1);\n    }\n\n    root->filetype = S_IFDIR;\n    root->fd = fd;\n    root->key.ino = stat.st_ino;\n    root->key.dev = stat.st_dev;\n    root->nlookup = 2;\n    g_atomic_int_set(&root->refcount, 2);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_atomic_int_set",
          "args": [
            "&root->refcount",
            "2"
          ],
          "line": 2786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2778
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"fstatat(%s): %m\\n\"",
            "lo->source"
          ],
          "line": 2777
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fstatat",
          "args": [
            "fd",
            "\"\"",
            "&stat",
            "AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW"
          ],
          "line": 2775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/\"",
            "O_PATH"
          ],
          "line": 2769
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "443-450",
          "snippet": "int fuse_reply_open(fuse_req_t req, const struct fuse_file_info *f)\n{\n    struct fuse_open_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    fill_open(&arg, f);\n    return send_reply_ok(req, &arg, sizeof(arg));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_open(fuse_req_t req, const struct fuse_file_info *f)\n{\n    struct fuse_open_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    fill_open(&arg, f);\n    return send_reply_ok(req, &arg, sizeof(arg));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void setup_root(struct lo_data *lo, struct lo_inode *root)\n{\n    int fd, res;\n    struct stat stat;\n\n    fd = open(\"/\", O_PATH);\n    if (fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", lo->source);\n        exit(1);\n    }\n\n    res = fstatat(fd, \"\", &stat, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"fstatat(%s): %m\\n\", lo->source);\n        exit(1);\n    }\n\n    root->filetype = S_IFDIR;\n    root->fd = fd;\n    root->key.ino = stat.st_ino;\n    root->key.dev = stat.st_dev;\n    root->nlookup = 2;\n    g_atomic_int_set(&root->refcount, 2);\n}"
  },
  {
    "function_name": "log_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2711-2762",
    "snippet": "static void log_func(enum fuse_log_level level, const char *fmt, va_list ap)\n{\n    g_autofree char *localfmt = NULL;\n\n    if (current_log_level < level) {\n        return;\n    }\n\n    if (current_log_level == FUSE_LOG_DEBUG) {\n        if (!use_syslog) {\n            localfmt = g_strdup_printf(\"[%\" PRId64 \"] [ID: %08ld] %s\",\n                                       get_clock(), syscall(__NR_gettid), fmt);\n        } else {\n            localfmt = g_strdup_printf(\"[ID: %08ld] %s\", syscall(__NR_gettid),\n                                       fmt);\n        }\n        fmt = localfmt;\n    }\n\n    if (use_syslog) {\n        int priority = LOG_ERR;\n        switch (level) {\n        case FUSE_LOG_EMERG:\n            priority = LOG_EMERG;\n            break;\n        case FUSE_LOG_ALERT:\n            priority = LOG_ALERT;\n            break;\n        case FUSE_LOG_CRIT:\n            priority = LOG_CRIT;\n            break;\n        case FUSE_LOG_ERR:\n            priority = LOG_ERR;\n            break;\n        case FUSE_LOG_WARNING:\n            priority = LOG_WARNING;\n            break;\n        case FUSE_LOG_NOTICE:\n            priority = LOG_NOTICE;\n            break;\n        case FUSE_LOG_INFO:\n            priority = LOG_INFO;\n            break;\n        case FUSE_LOG_DEBUG:\n            priority = LOG_DEBUG;\n            break;\n        }\n        vsyslog(priority, fmt, ap);\n    } else {\n        vfprintf(stderr, fmt, ap);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool use_syslog = false;",
      "static int current_log_level;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vfprintf",
          "args": [
            "stderr",
            "fmt",
            "ap"
          ],
          "line": 2760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsyslog",
          "args": [
            "priority",
            "fmt",
            "ap"
          ],
          "line": 2758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[ID: %08ld] %s\"",
            "syscall(__NR_gettid)",
            "fmt"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_gettid"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"[%\" PRId64 \"] [ID: %08ld] %s\"",
            "get_clock()",
            "syscall(__NR_gettid)",
            "fmt"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_gettid"
          ],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_clock",
          "args": [],
          "line": 2722
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic bool use_syslog = false;\nstatic int current_log_level;\n\nstatic void log_func(enum fuse_log_level level, const char *fmt, va_list ap)\n{\n    g_autofree char *localfmt = NULL;\n\n    if (current_log_level < level) {\n        return;\n    }\n\n    if (current_log_level == FUSE_LOG_DEBUG) {\n        if (!use_syslog) {\n            localfmt = g_strdup_printf(\"[%\" PRId64 \"] [ID: %08ld] %s\",\n                                       get_clock(), syscall(__NR_gettid), fmt);\n        } else {\n            localfmt = g_strdup_printf(\"[ID: %08ld] %s\", syscall(__NR_gettid),\n                                       fmt);\n        }\n        fmt = localfmt;\n    }\n\n    if (use_syslog) {\n        int priority = LOG_ERR;\n        switch (level) {\n        case FUSE_LOG_EMERG:\n            priority = LOG_EMERG;\n            break;\n        case FUSE_LOG_ALERT:\n            priority = LOG_ALERT;\n            break;\n        case FUSE_LOG_CRIT:\n            priority = LOG_CRIT;\n            break;\n        case FUSE_LOG_ERR:\n            priority = LOG_ERR;\n            break;\n        case FUSE_LOG_WARNING:\n            priority = LOG_WARNING;\n            break;\n        case FUSE_LOG_NOTICE:\n            priority = LOG_NOTICE;\n            break;\n        case FUSE_LOG_INFO:\n            priority = LOG_INFO;\n            break;\n        case FUSE_LOG_DEBUG:\n            priority = LOG_DEBUG;\n            break;\n        }\n        vsyslog(priority, fmt, ap);\n    } else {\n        vfprintf(stderr, fmt, ap);\n    }\n}"
  },
  {
    "function_name": "setup_nofile_rlimit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2689-2709",
    "snippet": "static void setup_nofile_rlimit(unsigned long rlimit_nofile)\n{\n    struct rlimit rlim = {\n        .rlim_cur = rlimit_nofile,\n        .rlim_max = rlimit_nofile,\n    };\n\n    if (rlimit_nofile == 0) {\n        return; /* nothing to do */\n    }\n\n    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        /* Ignore SELinux denials */\n        if (errno == EPERM) {\n            return;\n        }\n\n        fuse_log(FUSE_LOG_ERR, \"setrlimit(RLIMIT_NOFILE): %m\\n\");\n        exit(1);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2707
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"setrlimit(RLIMIT_NOFILE): %m\\n\""
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setrlimit",
          "args": [
            "RLIMIT_NOFILE",
            "&rlim"
          ],
          "line": 2700
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void setup_nofile_rlimit(unsigned long rlimit_nofile)\n{\n    struct rlimit rlim = {\n        .rlim_cur = rlimit_nofile,\n        .rlim_max = rlimit_nofile,\n    };\n\n    if (rlimit_nofile == 0) {\n        return; /* nothing to do */\n    }\n\n    if (setrlimit(RLIMIT_NOFILE, &rlim) < 0) {\n        /* Ignore SELinux denials */\n        if (errno == EPERM) {\n            return;\n        }\n\n        fuse_log(FUSE_LOG_ERR, \"setrlimit(RLIMIT_NOFILE): %m\\n\");\n        exit(1);\n    }\n}"
  },
  {
    "function_name": "setup_sandbox",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2679-2686",
    "snippet": "static void setup_sandbox(struct lo_data *lo, struct fuse_session *se,\n                          bool enable_syslog)\n{\n    setup_namespaces(lo, se);\n    setup_mounts(lo->source);\n    setup_seccomp(enable_syslog);\n    setup_capabilities(g_strdup(lo->modcaps));\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "setup_capabilities",
          "args": [
            "g_strdup(lo->modcaps)"
          ],
          "line": 2685
        },
        "resolved": true,
        "details": {
          "function_name": "setup_capabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2584-2673",
          "snippet": "static void setup_capabilities(char *modcaps_in)\n{\n    char *modcaps = modcaps_in;\n    pthread_mutex_lock(&cap.mutex);\n    capng_restore_state(&cap.saved);\n\n    /*\n     * Whitelist file system-related capabilities that are needed for a file\n     * server to act like root.  Drop everything else like networking and\n     * sysadmin capabilities.\n     *\n     * Exclusions:\n     * 1. CAP_LINUX_IMMUTABLE is not included because it's only used via ioctl\n     *    and we don't support that.\n     * 2. CAP_MAC_OVERRIDE is not included because it only seems to be\n     *    used by the Smack LSM.  Omit it until there is demand for it.\n     */\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    if (capng_updatev(CAPNG_ADD, CAPNG_PERMITTED | CAPNG_EFFECTIVE,\n            CAP_CHOWN,\n            CAP_DAC_OVERRIDE,\n            CAP_FOWNER,\n            CAP_FSETID,\n            CAP_SETGID,\n            CAP_SETUID,\n            CAP_MKNOD,\n            CAP_SETFCAP,\n            -1)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_updatev failed\\n\", __func__);\n        exit(1);\n    }\n\n    /*\n     * The modcaps option is a colon separated list of caps,\n     * each preceded by either + or -.\n     */\n    while (modcaps) {\n        capng_act_t action;\n        int cap;\n\n        char *next = strchr(modcaps, ':');\n        if (next) {\n            *next = '\\0';\n            next++;\n        }\n\n        switch (modcaps[0]) {\n        case '+':\n            action = CAPNG_ADD;\n            break;\n\n        case '-':\n            action = CAPNG_DROP;\n            break;\n\n        default:\n            fuse_log(FUSE_LOG_ERR,\n                     \"%s: Expecting '+'/'-' in modcaps but found '%c'\\n\",\n                     __func__, modcaps[0]);\n            exit(1);\n        }\n        cap = capng_name_to_capability(modcaps + 1);\n        if (cap < 0) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Unknown capability '%s'\\n\", __func__,\n                     modcaps);\n            exit(1);\n        }\n        if (capng_update(action, CAPNG_PERMITTED | CAPNG_EFFECTIVE, cap)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: capng_update failed for '%s'\\n\",\n                     __func__, modcaps);\n            exit(1);\n        }\n\n        modcaps = next;\n    }\n    g_free(modcaps_in);\n\n    if (capng_apply(CAPNG_SELECT_BOTH)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_apply failed\\n\", __func__);\n        exit(1);\n    }\n\n    cap.saved = capng_save_state();\n    if (!cap.saved) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_save_state failed\\n\", __func__);\n        exit(1);\n    }\n    pthread_mutex_unlock(&cap.mutex);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);",
            "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\n\nstatic void setup_capabilities(char *modcaps_in)\n{\n    char *modcaps = modcaps_in;\n    pthread_mutex_lock(&cap.mutex);\n    capng_restore_state(&cap.saved);\n\n    /*\n     * Whitelist file system-related capabilities that are needed for a file\n     * server to act like root.  Drop everything else like networking and\n     * sysadmin capabilities.\n     *\n     * Exclusions:\n     * 1. CAP_LINUX_IMMUTABLE is not included because it's only used via ioctl\n     *    and we don't support that.\n     * 2. CAP_MAC_OVERRIDE is not included because it only seems to be\n     *    used by the Smack LSM.  Omit it until there is demand for it.\n     */\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    if (capng_updatev(CAPNG_ADD, CAPNG_PERMITTED | CAPNG_EFFECTIVE,\n            CAP_CHOWN,\n            CAP_DAC_OVERRIDE,\n            CAP_FOWNER,\n            CAP_FSETID,\n            CAP_SETGID,\n            CAP_SETUID,\n            CAP_MKNOD,\n            CAP_SETFCAP,\n            -1)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_updatev failed\\n\", __func__);\n        exit(1);\n    }\n\n    /*\n     * The modcaps option is a colon separated list of caps,\n     * each preceded by either + or -.\n     */\n    while (modcaps) {\n        capng_act_t action;\n        int cap;\n\n        char *next = strchr(modcaps, ':');\n        if (next) {\n            *next = '\\0';\n            next++;\n        }\n\n        switch (modcaps[0]) {\n        case '+':\n            action = CAPNG_ADD;\n            break;\n\n        case '-':\n            action = CAPNG_DROP;\n            break;\n\n        default:\n            fuse_log(FUSE_LOG_ERR,\n                     \"%s: Expecting '+'/'-' in modcaps but found '%c'\\n\",\n                     __func__, modcaps[0]);\n            exit(1);\n        }\n        cap = capng_name_to_capability(modcaps + 1);\n        if (cap < 0) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Unknown capability '%s'\\n\", __func__,\n                     modcaps);\n            exit(1);\n        }\n        if (capng_update(action, CAPNG_PERMITTED | CAPNG_EFFECTIVE, cap)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: capng_update failed for '%s'\\n\",\n                     __func__, modcaps);\n            exit(1);\n        }\n\n        modcaps = next;\n    }\n    g_free(modcaps_in);\n\n    if (capng_apply(CAPNG_SELECT_BOTH)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_apply failed\\n\", __func__);\n        exit(1);\n    }\n\n    cap.saved = capng_save_state();\n    if (!cap.saved) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_save_state failed\\n\", __func__);\n        exit(1);\n    }\n    pthread_mutex_unlock(&cap.mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "lo->modcaps"
          ],
          "line": 2685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_seccomp",
          "args": [
            "enable_syslog"
          ],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "setup_seccomp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_seccomp.c",
          "lines": "137-174",
          "snippet": "void setup_seccomp(bool enable_syslog)\n{\n    scmp_filter_ctx ctx;\n\n#ifdef SCMP_ACT_KILL_PROCESS\n    ctx = seccomp_init(SCMP_ACT_KILL_PROCESS);\n    /* Handle a newer libseccomp but an older kernel */\n    if (!ctx && errno == EOPNOTSUPP) {\n        ctx = seccomp_init(SCMP_ACT_TRAP);\n    }\n#else\n    ctx = seccomp_init(SCMP_ACT_TRAP);\n#endif\n    if (!ctx) {\n        fuse_log(FUSE_LOG_ERR, \"seccomp_init() failed\\n\");\n        exit(1);\n    }\n\n    add_whitelist(ctx, syscall_whitelist, G_N_ELEMENTS(syscall_whitelist));\n    if (enable_syslog) {\n        add_whitelist(ctx, syscall_whitelist_syslog,\n                      G_N_ELEMENTS(syscall_whitelist_syslog));\n    }\n\n    /* libvhost-user calls this for post-copy migration, we don't need it */\n    if (seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS),\n                         SCMP_SYS(userfaultfd), 0) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"seccomp_rule_add userfaultfd failed\\n\");\n        exit(1);\n    }\n\n    if (seccomp_load(ctx) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"seccomp_load() failed\\n\");\n        exit(1);\n    }\n\n    seccomp_release(ctx);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <seccomp.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include \"fuse_log.h\"",
            "#include \"fuse_i.h\"",
            "#include \"passthrough_seccomp.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static const int syscall_whitelist[] = {\n    /* TODO ireg sem*() syscalls */\n    SCMP_SYS(brk),\n    SCMP_SYS(capget), /* For CAP_FSETID */\n    SCMP_SYS(capset),\n    SCMP_SYS(clock_gettime),\n    SCMP_SYS(clone),\n#ifdef __NR_clone3\n    SCMP_SYS(clone3),\n#endif\n    SCMP_SYS(close),\n    SCMP_SYS(copy_file_range),\n    SCMP_SYS(dup),\n    SCMP_SYS(eventfd2),\n    SCMP_SYS(exit),\n    SCMP_SYS(exit_group),\n    SCMP_SYS(fallocate),\n    SCMP_SYS(fchdir),\n    SCMP_SYS(fchmod),\n    SCMP_SYS(fchmodat),\n    SCMP_SYS(fchownat),\n    SCMP_SYS(fcntl),\n    SCMP_SYS(fdatasync),\n    SCMP_SYS(fgetxattr),\n    SCMP_SYS(flistxattr),\n    SCMP_SYS(flock),\n    SCMP_SYS(fremovexattr),\n    SCMP_SYS(fsetxattr),\n    SCMP_SYS(fstat),\n    SCMP_SYS(fstatfs),\n    SCMP_SYS(fsync),\n    SCMP_SYS(ftruncate),\n    SCMP_SYS(futex),\n    SCMP_SYS(getdents),\n    SCMP_SYS(getdents64),\n    SCMP_SYS(getegid),\n    SCMP_SYS(geteuid),\n    SCMP_SYS(getpid),\n    SCMP_SYS(gettid),\n    SCMP_SYS(gettimeofday),\n    SCMP_SYS(getxattr),\n    SCMP_SYS(linkat),\n    SCMP_SYS(listxattr),\n    SCMP_SYS(lseek),\n    SCMP_SYS(madvise),\n    SCMP_SYS(mkdirat),\n    SCMP_SYS(mknodat),\n    SCMP_SYS(mmap),\n    SCMP_SYS(mprotect),\n    SCMP_SYS(mremap),\n    SCMP_SYS(munmap),\n    SCMP_SYS(newfstatat),\n    SCMP_SYS(open),\n    SCMP_SYS(openat),\n    SCMP_SYS(ppoll),\n    SCMP_SYS(prctl), /* TODO restrict to just PR_SET_NAME? */\n    SCMP_SYS(preadv),\n    SCMP_SYS(pread64),\n    SCMP_SYS(pwritev),\n    SCMP_SYS(pwrite64),\n    SCMP_SYS(read),\n    SCMP_SYS(readlinkat),\n    SCMP_SYS(recvmsg),\n    SCMP_SYS(renameat),\n    SCMP_SYS(renameat2),\n    SCMP_SYS(removexattr),\n    SCMP_SYS(rt_sigaction),\n    SCMP_SYS(rt_sigprocmask),\n    SCMP_SYS(rt_sigreturn),\n    SCMP_SYS(sched_getattr),\n    SCMP_SYS(sched_setattr),\n    SCMP_SYS(sendmsg),\n    SCMP_SYS(setresgid),\n    SCMP_SYS(setresuid),\n#ifdef __NR_setresgid32\n    SCMP_SYS(setresgid32),\n#endif\n#ifdef __NR_setresuid32\n    SCMP_SYS(setresuid32),\n#endif\n    SCMP_SYS(set_robust_list),\n    SCMP_SYS(setxattr),\n    SCMP_SYS(symlinkat),\n    SCMP_SYS(time), /* Rarely needed, except on static builds */\n    SCMP_SYS(tgkill),\n    SCMP_SYS(unlinkat),\n    SCMP_SYS(unshare),\n    SCMP_SYS(utimensat),\n    SCMP_SYS(write),\n    SCMP_SYS(writev),\n};",
            "static const int syscall_whitelist_syslog[] = {\n    SCMP_SYS(sendto),\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <seccomp.h>\n#include <glib.h>\n#include <errno.h>\n#include \"fuse_log.h\"\n#include \"fuse_i.h\"\n#include \"passthrough_seccomp.h\"\n#include \"qemu/osdep.h\"\n\nstatic const int syscall_whitelist[] = {\n    /* TODO ireg sem*() syscalls */\n    SCMP_SYS(brk),\n    SCMP_SYS(capget), /* For CAP_FSETID */\n    SCMP_SYS(capset),\n    SCMP_SYS(clock_gettime),\n    SCMP_SYS(clone),\n#ifdef __NR_clone3\n    SCMP_SYS(clone3),\n#endif\n    SCMP_SYS(close),\n    SCMP_SYS(copy_file_range),\n    SCMP_SYS(dup),\n    SCMP_SYS(eventfd2),\n    SCMP_SYS(exit),\n    SCMP_SYS(exit_group),\n    SCMP_SYS(fallocate),\n    SCMP_SYS(fchdir),\n    SCMP_SYS(fchmod),\n    SCMP_SYS(fchmodat),\n    SCMP_SYS(fchownat),\n    SCMP_SYS(fcntl),\n    SCMP_SYS(fdatasync),\n    SCMP_SYS(fgetxattr),\n    SCMP_SYS(flistxattr),\n    SCMP_SYS(flock),\n    SCMP_SYS(fremovexattr),\n    SCMP_SYS(fsetxattr),\n    SCMP_SYS(fstat),\n    SCMP_SYS(fstatfs),\n    SCMP_SYS(fsync),\n    SCMP_SYS(ftruncate),\n    SCMP_SYS(futex),\n    SCMP_SYS(getdents),\n    SCMP_SYS(getdents64),\n    SCMP_SYS(getegid),\n    SCMP_SYS(geteuid),\n    SCMP_SYS(getpid),\n    SCMP_SYS(gettid),\n    SCMP_SYS(gettimeofday),\n    SCMP_SYS(getxattr),\n    SCMP_SYS(linkat),\n    SCMP_SYS(listxattr),\n    SCMP_SYS(lseek),\n    SCMP_SYS(madvise),\n    SCMP_SYS(mkdirat),\n    SCMP_SYS(mknodat),\n    SCMP_SYS(mmap),\n    SCMP_SYS(mprotect),\n    SCMP_SYS(mremap),\n    SCMP_SYS(munmap),\n    SCMP_SYS(newfstatat),\n    SCMP_SYS(open),\n    SCMP_SYS(openat),\n    SCMP_SYS(ppoll),\n    SCMP_SYS(prctl), /* TODO restrict to just PR_SET_NAME? */\n    SCMP_SYS(preadv),\n    SCMP_SYS(pread64),\n    SCMP_SYS(pwritev),\n    SCMP_SYS(pwrite64),\n    SCMP_SYS(read),\n    SCMP_SYS(readlinkat),\n    SCMP_SYS(recvmsg),\n    SCMP_SYS(renameat),\n    SCMP_SYS(renameat2),\n    SCMP_SYS(removexattr),\n    SCMP_SYS(rt_sigaction),\n    SCMP_SYS(rt_sigprocmask),\n    SCMP_SYS(rt_sigreturn),\n    SCMP_SYS(sched_getattr),\n    SCMP_SYS(sched_setattr),\n    SCMP_SYS(sendmsg),\n    SCMP_SYS(setresgid),\n    SCMP_SYS(setresuid),\n#ifdef __NR_setresgid32\n    SCMP_SYS(setresgid32),\n#endif\n#ifdef __NR_setresuid32\n    SCMP_SYS(setresuid32),\n#endif\n    SCMP_SYS(set_robust_list),\n    SCMP_SYS(setxattr),\n    SCMP_SYS(symlinkat),\n    SCMP_SYS(time), /* Rarely needed, except on static builds */\n    SCMP_SYS(tgkill),\n    SCMP_SYS(unlinkat),\n    SCMP_SYS(unshare),\n    SCMP_SYS(utimensat),\n    SCMP_SYS(write),\n    SCMP_SYS(writev),\n};\nstatic const int syscall_whitelist_syslog[] = {\n    SCMP_SYS(sendto),\n};\n\nvoid setup_seccomp(bool enable_syslog)\n{\n    scmp_filter_ctx ctx;\n\n#ifdef SCMP_ACT_KILL_PROCESS\n    ctx = seccomp_init(SCMP_ACT_KILL_PROCESS);\n    /* Handle a newer libseccomp but an older kernel */\n    if (!ctx && errno == EOPNOTSUPP) {\n        ctx = seccomp_init(SCMP_ACT_TRAP);\n    }\n#else\n    ctx = seccomp_init(SCMP_ACT_TRAP);\n#endif\n    if (!ctx) {\n        fuse_log(FUSE_LOG_ERR, \"seccomp_init() failed\\n\");\n        exit(1);\n    }\n\n    add_whitelist(ctx, syscall_whitelist, G_N_ELEMENTS(syscall_whitelist));\n    if (enable_syslog) {\n        add_whitelist(ctx, syscall_whitelist_syslog,\n                      G_N_ELEMENTS(syscall_whitelist_syslog));\n    }\n\n    /* libvhost-user calls this for post-copy migration, we don't need it */\n    if (seccomp_rule_add(ctx, SCMP_ACT_ERRNO(ENOSYS),\n                         SCMP_SYS(userfaultfd), 0) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"seccomp_rule_add userfaultfd failed\\n\");\n        exit(1);\n    }\n\n    if (seccomp_load(ctx) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"seccomp_load() failed\\n\");\n        exit(1);\n    }\n\n    seccomp_release(ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_mounts",
          "args": [
            "lo->source"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "setup_mounts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2523-2578",
          "snippet": "static void setup_mounts(const char *source)\n{\n    int oldroot;\n    int newroot;\n\n    if (mount(source, source, NULL, MS_BIND | MS_REC, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(%s, %s, MS_BIND): %m\\n\", source, source);\n        exit(1);\n    }\n\n    /* This magic is based on lxc's lxc_pivot_root() */\n    oldroot = open(\"/\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n    if (oldroot < 0) {\n        fuse_log(FUSE_LOG_ERR, \"open(/): %m\\n\");\n        exit(1);\n    }\n\n    newroot = open(source, O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n    if (newroot < 0) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s): %m\\n\", source);\n        exit(1);\n    }\n\n    if (fchdir(newroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(newroot): %m\\n\");\n        exit(1);\n    }\n\n    if (syscall(__NR_pivot_root, \".\", \".\") < 0) {\n        fuse_log(FUSE_LOG_ERR, \"pivot_root(., .): %m\\n\");\n        exit(1);\n    }\n\n    if (fchdir(oldroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(oldroot): %m\\n\");\n        exit(1);\n    }\n\n    if (mount(\"\", \".\", \"\", MS_SLAVE | MS_REC, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(., MS_SLAVE | MS_REC): %m\\n\");\n        exit(1);\n    }\n\n    if (umount2(\".\", MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(., MNT_DETACH): %m\\n\");\n        exit(1);\n    }\n\n    if (fchdir(newroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(newroot): %m\\n\");\n        exit(1);\n    }\n\n    close(newroot);\n    close(oldroot);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void setup_mounts(const char *source)\n{\n    int oldroot;\n    int newroot;\n\n    if (mount(source, source, NULL, MS_BIND | MS_REC, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(%s, %s, MS_BIND): %m\\n\", source, source);\n        exit(1);\n    }\n\n    /* This magic is based on lxc's lxc_pivot_root() */\n    oldroot = open(\"/\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n    if (oldroot < 0) {\n        fuse_log(FUSE_LOG_ERR, \"open(/): %m\\n\");\n        exit(1);\n    }\n\n    newroot = open(source, O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n    if (newroot < 0) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s): %m\\n\", source);\n        exit(1);\n    }\n\n    if (fchdir(newroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(newroot): %m\\n\");\n        exit(1);\n    }\n\n    if (syscall(__NR_pivot_root, \".\", \".\") < 0) {\n        fuse_log(FUSE_LOG_ERR, \"pivot_root(., .): %m\\n\");\n        exit(1);\n    }\n\n    if (fchdir(oldroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(oldroot): %m\\n\");\n        exit(1);\n    }\n\n    if (mount(\"\", \".\", \"\", MS_SLAVE | MS_REC, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(., MS_SLAVE | MS_REC): %m\\n\");\n        exit(1);\n    }\n\n    if (umount2(\".\", MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(., MNT_DETACH): %m\\n\");\n        exit(1);\n    }\n\n    if (fchdir(newroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(newroot): %m\\n\");\n        exit(1);\n    }\n\n    close(newroot);\n    close(oldroot);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_namespaces",
          "args": [
            "lo",
            "se"
          ],
          "line": 2682
        },
        "resolved": true,
        "details": {
          "function_name": "setup_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2393-2488",
          "snippet": "static void setup_namespaces(struct lo_data *lo, struct fuse_session *se)\n{\n    pid_t child;\n    char template[] = \"virtiofsd-XXXXXX\";\n    char *tmpdir;\n\n    /*\n     * Create a new pid namespace for *child* processes.  We'll have to\n     * fork in order to enter the new pid namespace.  A new mount namespace\n     * is also needed so that we can remount /proc for the new pid\n     * namespace.\n     *\n     * Our UNIX domain sockets have been created.  Now we can move to\n     * an empty network namespace to prevent TCP/IP and other network\n     * activity in case this process is compromised.\n     */\n    if (unshare(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWPID | CLONE_NEWNS): %m\\n\");\n        exit(1);\n    }\n\n    child = fork();\n    if (child < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fork() failed: %m\\n\");\n        exit(1);\n    }\n    if (child > 0) {\n        pid_t waited;\n        int wstatus;\n\n        setup_wait_parent_capabilities();\n\n        /* The parent waits for the child */\n        do {\n            waited = waitpid(child, &wstatus, 0);\n        } while (waited < 0 && errno == EINTR && !se->exited);\n\n        /* We were terminated by a signal, see fuse_signals.c */\n        if (se->exited) {\n            exit(0);\n        }\n\n        if (WIFEXITED(wstatus)) {\n            exit(WEXITSTATUS(wstatus));\n        }\n\n        exit(1);\n    }\n\n    /* Send us SIGTERM when the parent thread terminates, see prctl(2) */\n    prctl(PR_SET_PDEATHSIG, SIGTERM);\n\n    /*\n     * If the mounts have shared propagation then we want to opt out so our\n     * mount changes don't affect the parent mount namespace.\n     */\n    if (mount(NULL, \"/\", NULL, MS_REC | MS_SLAVE, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/, MS_REC|MS_SLAVE): %m\\n\");\n        exit(1);\n    }\n\n    /* The child must remount /proc to use the new pid namespace */\n    if (mount(\"proc\", \"/proc\", \"proc\",\n              MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc): %m\\n\");\n        exit(1);\n    }\n\n    tmpdir = mkdtemp(template);\n    if (!tmpdir) {\n        fuse_log(FUSE_LOG_ERR, \"tmpdir(%s): %m\\n\", template);\n        exit(1);\n    }\n\n    if (mount(\"/proc/self/fd\", tmpdir, NULL, MS_BIND, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, %s, MS_BIND): %m\\n\",\n                 tmpdir);\n        exit(1);\n    }\n\n    /* Now we can get our /proc/self/fd directory file descriptor */\n    lo->proc_self_fd = open(tmpdir, O_PATH);\n    if (lo->proc_self_fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (umount2(tmpdir, MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(%s, MNT_DETACH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (rmdir(tmpdir) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"rmdir(%s): %m\\n\", tmpdir);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void setup_namespaces(struct lo_data *lo, struct fuse_session *se)\n{\n    pid_t child;\n    char template[] = \"virtiofsd-XXXXXX\";\n    char *tmpdir;\n\n    /*\n     * Create a new pid namespace for *child* processes.  We'll have to\n     * fork in order to enter the new pid namespace.  A new mount namespace\n     * is also needed so that we can remount /proc for the new pid\n     * namespace.\n     *\n     * Our UNIX domain sockets have been created.  Now we can move to\n     * an empty network namespace to prevent TCP/IP and other network\n     * activity in case this process is compromised.\n     */\n    if (unshare(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWPID | CLONE_NEWNS): %m\\n\");\n        exit(1);\n    }\n\n    child = fork();\n    if (child < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fork() failed: %m\\n\");\n        exit(1);\n    }\n    if (child > 0) {\n        pid_t waited;\n        int wstatus;\n\n        setup_wait_parent_capabilities();\n\n        /* The parent waits for the child */\n        do {\n            waited = waitpid(child, &wstatus, 0);\n        } while (waited < 0 && errno == EINTR && !se->exited);\n\n        /* We were terminated by a signal, see fuse_signals.c */\n        if (se->exited) {\n            exit(0);\n        }\n\n        if (WIFEXITED(wstatus)) {\n            exit(WEXITSTATUS(wstatus));\n        }\n\n        exit(1);\n    }\n\n    /* Send us SIGTERM when the parent thread terminates, see prctl(2) */\n    prctl(PR_SET_PDEATHSIG, SIGTERM);\n\n    /*\n     * If the mounts have shared propagation then we want to opt out so our\n     * mount changes don't affect the parent mount namespace.\n     */\n    if (mount(NULL, \"/\", NULL, MS_REC | MS_SLAVE, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/, MS_REC|MS_SLAVE): %m\\n\");\n        exit(1);\n    }\n\n    /* The child must remount /proc to use the new pid namespace */\n    if (mount(\"proc\", \"/proc\", \"proc\",\n              MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc): %m\\n\");\n        exit(1);\n    }\n\n    tmpdir = mkdtemp(template);\n    if (!tmpdir) {\n        fuse_log(FUSE_LOG_ERR, \"tmpdir(%s): %m\\n\", template);\n        exit(1);\n    }\n\n    if (mount(\"/proc/self/fd\", tmpdir, NULL, MS_BIND, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, %s, MS_BIND): %m\\n\",\n                 tmpdir);\n        exit(1);\n    }\n\n    /* Now we can get our /proc/self/fd directory file descriptor */\n    lo->proc_self_fd = open(tmpdir, O_PATH);\n    if (lo->proc_self_fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (umount2(tmpdir, MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(%s, MNT_DETACH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (rmdir(tmpdir) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"rmdir(%s): %m\\n\", tmpdir);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void setup_sandbox(struct lo_data *lo, struct fuse_session *se,\n                          bool enable_syslog)\n{\n    setup_namespaces(lo, se);\n    setup_mounts(lo->source);\n    setup_seccomp(enable_syslog);\n    setup_capabilities(g_strdup(lo->modcaps));\n}"
  },
  {
    "function_name": "setup_capabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2584-2673",
    "snippet": "static void setup_capabilities(char *modcaps_in)\n{\n    char *modcaps = modcaps_in;\n    pthread_mutex_lock(&cap.mutex);\n    capng_restore_state(&cap.saved);\n\n    /*\n     * Whitelist file system-related capabilities that are needed for a file\n     * server to act like root.  Drop everything else like networking and\n     * sysadmin capabilities.\n     *\n     * Exclusions:\n     * 1. CAP_LINUX_IMMUTABLE is not included because it's only used via ioctl\n     *    and we don't support that.\n     * 2. CAP_MAC_OVERRIDE is not included because it only seems to be\n     *    used by the Smack LSM.  Omit it until there is demand for it.\n     */\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    if (capng_updatev(CAPNG_ADD, CAPNG_PERMITTED | CAPNG_EFFECTIVE,\n            CAP_CHOWN,\n            CAP_DAC_OVERRIDE,\n            CAP_FOWNER,\n            CAP_FSETID,\n            CAP_SETGID,\n            CAP_SETUID,\n            CAP_MKNOD,\n            CAP_SETFCAP,\n            -1)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_updatev failed\\n\", __func__);\n        exit(1);\n    }\n\n    /*\n     * The modcaps option is a colon separated list of caps,\n     * each preceded by either + or -.\n     */\n    while (modcaps) {\n        capng_act_t action;\n        int cap;\n\n        char *next = strchr(modcaps, ':');\n        if (next) {\n            *next = '\\0';\n            next++;\n        }\n\n        switch (modcaps[0]) {\n        case '+':\n            action = CAPNG_ADD;\n            break;\n\n        case '-':\n            action = CAPNG_DROP;\n            break;\n\n        default:\n            fuse_log(FUSE_LOG_ERR,\n                     \"%s: Expecting '+'/'-' in modcaps but found '%c'\\n\",\n                     __func__, modcaps[0]);\n            exit(1);\n        }\n        cap = capng_name_to_capability(modcaps + 1);\n        if (cap < 0) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Unknown capability '%s'\\n\", __func__,\n                     modcaps);\n            exit(1);\n        }\n        if (capng_update(action, CAPNG_PERMITTED | CAPNG_EFFECTIVE, cap)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: capng_update failed for '%s'\\n\",\n                     __func__, modcaps);\n            exit(1);\n        }\n\n        modcaps = next;\n    }\n    g_free(modcaps_in);\n\n    if (capng_apply(CAPNG_SELECT_BOTH)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_apply failed\\n\", __func__);\n        exit(1);\n    }\n\n    cap.saved = capng_save_state();\n    if (!cap.saved) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_save_state failed\\n\", __func__);\n        exit(1);\n    }\n    pthread_mutex_unlock(&cap.mutex);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);",
      "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&cap.mutex"
          ],
          "line": 2672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"%s: capng_save_state failed\\n\"",
            "__func__"
          ],
          "line": 2669
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capng_save_state",
          "args": [],
          "line": 2667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_apply",
          "args": [
            "CAPNG_SELECT_BOTH"
          ],
          "line": 2662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_free",
          "args": [
            "modcaps_in"
          ],
          "line": 2660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_update",
          "args": [
            "action",
            "CAPNG_PERMITTED | CAPNG_EFFECTIVE",
            "cap"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_name_to_capability",
          "args": [
            "modcaps + 1"
          ],
          "line": 2646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "modcaps",
            "':'"
          ],
          "line": 2625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_updatev",
          "args": [
            "CAPNG_ADD",
            "CAPNG_PERMITTED | CAPNG_EFFECTIVE",
            "CAP_CHOWN",
            "CAP_DAC_OVERRIDE",
            "CAP_FOWNER",
            "CAP_FSETID",
            "CAP_SETGID",
            "CAP_SETUID",
            "CAP_MKNOD",
            "CAP_SETFCAP",
            "-1"
          ],
          "line": 2603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_clear",
          "args": [
            "CAPNG_SELECT_BOTH"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_setpid",
          "args": [
            "syscall(SYS_gettid)"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_gettid"
          ],
          "line": 2601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_restore_state",
          "args": [
            "&cap.saved"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&cap.mutex"
          ],
          "line": 2587
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\n\nstatic void setup_capabilities(char *modcaps_in)\n{\n    char *modcaps = modcaps_in;\n    pthread_mutex_lock(&cap.mutex);\n    capng_restore_state(&cap.saved);\n\n    /*\n     * Whitelist file system-related capabilities that are needed for a file\n     * server to act like root.  Drop everything else like networking and\n     * sysadmin capabilities.\n     *\n     * Exclusions:\n     * 1. CAP_LINUX_IMMUTABLE is not included because it's only used via ioctl\n     *    and we don't support that.\n     * 2. CAP_MAC_OVERRIDE is not included because it only seems to be\n     *    used by the Smack LSM.  Omit it until there is demand for it.\n     */\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    if (capng_updatev(CAPNG_ADD, CAPNG_PERMITTED | CAPNG_EFFECTIVE,\n            CAP_CHOWN,\n            CAP_DAC_OVERRIDE,\n            CAP_FOWNER,\n            CAP_FSETID,\n            CAP_SETGID,\n            CAP_SETUID,\n            CAP_MKNOD,\n            CAP_SETFCAP,\n            -1)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_updatev failed\\n\", __func__);\n        exit(1);\n    }\n\n    /*\n     * The modcaps option is a colon separated list of caps,\n     * each preceded by either + or -.\n     */\n    while (modcaps) {\n        capng_act_t action;\n        int cap;\n\n        char *next = strchr(modcaps, ':');\n        if (next) {\n            *next = '\\0';\n            next++;\n        }\n\n        switch (modcaps[0]) {\n        case '+':\n            action = CAPNG_ADD;\n            break;\n\n        case '-':\n            action = CAPNG_DROP;\n            break;\n\n        default:\n            fuse_log(FUSE_LOG_ERR,\n                     \"%s: Expecting '+'/'-' in modcaps but found '%c'\\n\",\n                     __func__, modcaps[0]);\n            exit(1);\n        }\n        cap = capng_name_to_capability(modcaps + 1);\n        if (cap < 0) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Unknown capability '%s'\\n\", __func__,\n                     modcaps);\n            exit(1);\n        }\n        if (capng_update(action, CAPNG_PERMITTED | CAPNG_EFFECTIVE, cap)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: capng_update failed for '%s'\\n\",\n                     __func__, modcaps);\n            exit(1);\n        }\n\n        modcaps = next;\n    }\n    g_free(modcaps_in);\n\n    if (capng_apply(CAPNG_SELECT_BOTH)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_apply failed\\n\", __func__);\n        exit(1);\n    }\n\n    cap.saved = capng_save_state();\n    if (!cap.saved) {\n        fuse_log(FUSE_LOG_ERR, \"%s: capng_save_state failed\\n\", __func__);\n        exit(1);\n    }\n    pthread_mutex_unlock(&cap.mutex);\n}"
  },
  {
    "function_name": "setup_mounts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2523-2578",
    "snippet": "static void setup_mounts(const char *source)\n{\n    int oldroot;\n    int newroot;\n\n    if (mount(source, source, NULL, MS_BIND | MS_REC, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(%s, %s, MS_BIND): %m\\n\", source, source);\n        exit(1);\n    }\n\n    /* This magic is based on lxc's lxc_pivot_root() */\n    oldroot = open(\"/\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n    if (oldroot < 0) {\n        fuse_log(FUSE_LOG_ERR, \"open(/): %m\\n\");\n        exit(1);\n    }\n\n    newroot = open(source, O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n    if (newroot < 0) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s): %m\\n\", source);\n        exit(1);\n    }\n\n    if (fchdir(newroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(newroot): %m\\n\");\n        exit(1);\n    }\n\n    if (syscall(__NR_pivot_root, \".\", \".\") < 0) {\n        fuse_log(FUSE_LOG_ERR, \"pivot_root(., .): %m\\n\");\n        exit(1);\n    }\n\n    if (fchdir(oldroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(oldroot): %m\\n\");\n        exit(1);\n    }\n\n    if (mount(\"\", \".\", \"\", MS_SLAVE | MS_REC, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(., MS_SLAVE | MS_REC): %m\\n\");\n        exit(1);\n    }\n\n    if (umount2(\".\", MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(., MNT_DETACH): %m\\n\");\n        exit(1);\n    }\n\n    if (fchdir(newroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(newroot): %m\\n\");\n        exit(1);\n    }\n\n    close(newroot);\n    close(oldroot);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "oldroot"
          ],
          "line": 2577
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2573
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"fchdir(newroot): %m\\n\""
          ],
          "line": 2572
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "newroot"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "\".\"",
            "MNT_DETACH"
          ],
          "line": 2566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"\"",
            "\".\"",
            "\"\"",
            "MS_SLAVE | MS_REC",
            "NULL"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "oldroot"
          ],
          "line": 2556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "__NR_pivot_root",
            "\".\"",
            "\".\""
          ],
          "line": 2551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "newroot"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "source",
            "O_DIRECTORY | O_RDONLY | O_CLOEXEC"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "443-450",
          "snippet": "int fuse_reply_open(fuse_req_t req, const struct fuse_file_info *f)\n{\n    struct fuse_open_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    fill_open(&arg, f);\n    return send_reply_ok(req, &arg, sizeof(arg));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_open(fuse_req_t req, const struct fuse_file_info *f)\n{\n    struct fuse_open_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    fill_open(&arg, f);\n    return send_reply_ok(req, &arg, sizeof(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "source",
            "source",
            "NULL",
            "MS_BIND | MS_REC",
            "NULL"
          ],
          "line": 2528
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void setup_mounts(const char *source)\n{\n    int oldroot;\n    int newroot;\n\n    if (mount(source, source, NULL, MS_BIND | MS_REC, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(%s, %s, MS_BIND): %m\\n\", source, source);\n        exit(1);\n    }\n\n    /* This magic is based on lxc's lxc_pivot_root() */\n    oldroot = open(\"/\", O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n    if (oldroot < 0) {\n        fuse_log(FUSE_LOG_ERR, \"open(/): %m\\n\");\n        exit(1);\n    }\n\n    newroot = open(source, O_DIRECTORY | O_RDONLY | O_CLOEXEC);\n    if (newroot < 0) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s): %m\\n\", source);\n        exit(1);\n    }\n\n    if (fchdir(newroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(newroot): %m\\n\");\n        exit(1);\n    }\n\n    if (syscall(__NR_pivot_root, \".\", \".\") < 0) {\n        fuse_log(FUSE_LOG_ERR, \"pivot_root(., .): %m\\n\");\n        exit(1);\n    }\n\n    if (fchdir(oldroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(oldroot): %m\\n\");\n        exit(1);\n    }\n\n    if (mount(\"\", \".\", \"\", MS_SLAVE | MS_REC, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(., MS_SLAVE | MS_REC): %m\\n\");\n        exit(1);\n    }\n\n    if (umount2(\".\", MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(., MNT_DETACH): %m\\n\");\n        exit(1);\n    }\n\n    if (fchdir(newroot) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fchdir(newroot): %m\\n\");\n        exit(1);\n    }\n\n    close(newroot);\n    close(oldroot);\n}"
  },
  {
    "function_name": "cleanup_capng",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2511-2516",
    "snippet": "static void cleanup_capng(void)\n{\n    free(cap.saved);\n    cap.saved = NULL;\n    pthread_mutex_destroy(&cap.mutex);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_mutex_destroy",
          "args": [
            "&cap.mutex"
          ],
          "line": 2515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "cap.saved"
          ],
          "line": 2513
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\n\nstatic void cleanup_capng(void)\n{\n    free(cap.saved);\n    cap.saved = NULL;\n    pthread_mutex_destroy(&cap.mutex);\n}"
  },
  {
    "function_name": "setup_capng",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2494-2509",
    "snippet": "static void setup_capng(void)\n{\n    /* Note this accesses /proc so has to happen before the sandbox */\n    if (capng_get_caps_process()) {\n        fuse_log(FUSE_LOG_ERR, \"capng_get_caps_process\\n\");\n        exit(1);\n    }\n    pthread_mutex_init(&cap.mutex, NULL);\n    pthread_mutex_lock(&cap.mutex);\n    cap.saved = capng_save_state();\n    if (!cap.saved) {\n        fuse_log(FUSE_LOG_ERR, \"capng_save_state\\n\");\n        exit(1);\n    }\n    pthread_mutex_unlock(&cap.mutex);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);",
      "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&cap.mutex"
          ],
          "line": 2508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2506
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"capng_save_state\\n\""
          ],
          "line": 2505
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capng_save_state",
          "args": [],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&cap.mutex"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_init",
          "args": [
            "&cap.mutex",
            "NULL"
          ],
          "line": 2501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_get_caps_process",
          "args": [],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\n\nstatic void setup_capng(void)\n{\n    /* Note this accesses /proc so has to happen before the sandbox */\n    if (capng_get_caps_process()) {\n        fuse_log(FUSE_LOG_ERR, \"capng_get_caps_process\\n\");\n        exit(1);\n    }\n    pthread_mutex_init(&cap.mutex, NULL);\n    pthread_mutex_lock(&cap.mutex);\n    cap.saved = capng_save_state();\n    if (!cap.saved) {\n        fuse_log(FUSE_LOG_ERR, \"capng_save_state\\n\");\n        exit(1);\n    }\n    pthread_mutex_unlock(&cap.mutex);\n}"
  },
  {
    "function_name": "setup_namespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2393-2488",
    "snippet": "static void setup_namespaces(struct lo_data *lo, struct fuse_session *se)\n{\n    pid_t child;\n    char template[] = \"virtiofsd-XXXXXX\";\n    char *tmpdir;\n\n    /*\n     * Create a new pid namespace for *child* processes.  We'll have to\n     * fork in order to enter the new pid namespace.  A new mount namespace\n     * is also needed so that we can remount /proc for the new pid\n     * namespace.\n     *\n     * Our UNIX domain sockets have been created.  Now we can move to\n     * an empty network namespace to prevent TCP/IP and other network\n     * activity in case this process is compromised.\n     */\n    if (unshare(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWPID | CLONE_NEWNS): %m\\n\");\n        exit(1);\n    }\n\n    child = fork();\n    if (child < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fork() failed: %m\\n\");\n        exit(1);\n    }\n    if (child > 0) {\n        pid_t waited;\n        int wstatus;\n\n        setup_wait_parent_capabilities();\n\n        /* The parent waits for the child */\n        do {\n            waited = waitpid(child, &wstatus, 0);\n        } while (waited < 0 && errno == EINTR && !se->exited);\n\n        /* We were terminated by a signal, see fuse_signals.c */\n        if (se->exited) {\n            exit(0);\n        }\n\n        if (WIFEXITED(wstatus)) {\n            exit(WEXITSTATUS(wstatus));\n        }\n\n        exit(1);\n    }\n\n    /* Send us SIGTERM when the parent thread terminates, see prctl(2) */\n    prctl(PR_SET_PDEATHSIG, SIGTERM);\n\n    /*\n     * If the mounts have shared propagation then we want to opt out so our\n     * mount changes don't affect the parent mount namespace.\n     */\n    if (mount(NULL, \"/\", NULL, MS_REC | MS_SLAVE, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/, MS_REC|MS_SLAVE): %m\\n\");\n        exit(1);\n    }\n\n    /* The child must remount /proc to use the new pid namespace */\n    if (mount(\"proc\", \"/proc\", \"proc\",\n              MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc): %m\\n\");\n        exit(1);\n    }\n\n    tmpdir = mkdtemp(template);\n    if (!tmpdir) {\n        fuse_log(FUSE_LOG_ERR, \"tmpdir(%s): %m\\n\", template);\n        exit(1);\n    }\n\n    if (mount(\"/proc/self/fd\", tmpdir, NULL, MS_BIND, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, %s, MS_BIND): %m\\n\",\n                 tmpdir);\n        exit(1);\n    }\n\n    /* Now we can get our /proc/self/fd directory file descriptor */\n    lo->proc_self_fd = open(tmpdir, O_PATH);\n    if (lo->proc_self_fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (umount2(tmpdir, MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(%s, MNT_DETACH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (rmdir(tmpdir) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"rmdir(%s): %m\\n\", tmpdir);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"rmdir(%s): %m\\n\"",
            "tmpdir"
          ],
          "line": 2486
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rmdir",
          "args": [
            "tmpdir"
          ],
          "line": 2485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 2482
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "umount2",
          "args": [
            "tmpdir",
            "MNT_DETACH"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "tmpdir",
            "O_PATH"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "443-450",
          "snippet": "int fuse_reply_open(fuse_req_t req, const struct fuse_file_info *f)\n{\n    struct fuse_open_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    fill_open(&arg, f);\n    return send_reply_ok(req, &arg, sizeof(arg));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_open(fuse_req_t req, const struct fuse_file_info *f)\n{\n    struct fuse_open_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    fill_open(&arg, f);\n    return send_reply_ok(req, &arg, sizeof(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"/proc/self/fd\"",
            "tmpdir",
            "NULL",
            "MS_BIND",
            "NULL"
          ],
          "line": 2467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdtemp",
          "args": [
            "template"
          ],
          "line": 2461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "\"proc\"",
            "\"/proc\"",
            "\"proc\"",
            "MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME",
            "NULL"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mount",
          "args": [
            "NULL",
            "\"/\"",
            "NULL",
            "MS_REC | MS_SLAVE",
            "NULL"
          ],
          "line": 2449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prctl",
          "args": [
            "PR_SET_PDEATHSIG",
            "SIGTERM"
          ],
          "line": 2443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WEXITSTATUS",
          "args": [
            "wstatus"
          ],
          "line": 2436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WIFEXITED",
          "args": [
            "wstatus"
          ],
          "line": 2435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "child",
            "&wstatus",
            "0"
          ],
          "line": 2427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setup_wait_parent_capabilities",
          "args": [],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "setup_wait_parent_capabilities",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2383-2388",
          "snippet": "static void setup_wait_parent_capabilities(void)\n{\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    capng_apply(CAPNG_SELECT_BOTH);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void setup_wait_parent_capabilities(void)\n{\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    capng_apply(CAPNG_SELECT_BOTH);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void setup_namespaces(struct lo_data *lo, struct fuse_session *se)\n{\n    pid_t child;\n    char template[] = \"virtiofsd-XXXXXX\";\n    char *tmpdir;\n\n    /*\n     * Create a new pid namespace for *child* processes.  We'll have to\n     * fork in order to enter the new pid namespace.  A new mount namespace\n     * is also needed so that we can remount /proc for the new pid\n     * namespace.\n     *\n     * Our UNIX domain sockets have been created.  Now we can move to\n     * an empty network namespace to prevent TCP/IP and other network\n     * activity in case this process is compromised.\n     */\n    if (unshare(CLONE_NEWPID | CLONE_NEWNS | CLONE_NEWNET) != 0) {\n        fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_NEWPID | CLONE_NEWNS): %m\\n\");\n        exit(1);\n    }\n\n    child = fork();\n    if (child < 0) {\n        fuse_log(FUSE_LOG_ERR, \"fork() failed: %m\\n\");\n        exit(1);\n    }\n    if (child > 0) {\n        pid_t waited;\n        int wstatus;\n\n        setup_wait_parent_capabilities();\n\n        /* The parent waits for the child */\n        do {\n            waited = waitpid(child, &wstatus, 0);\n        } while (waited < 0 && errno == EINTR && !se->exited);\n\n        /* We were terminated by a signal, see fuse_signals.c */\n        if (se->exited) {\n            exit(0);\n        }\n\n        if (WIFEXITED(wstatus)) {\n            exit(WEXITSTATUS(wstatus));\n        }\n\n        exit(1);\n    }\n\n    /* Send us SIGTERM when the parent thread terminates, see prctl(2) */\n    prctl(PR_SET_PDEATHSIG, SIGTERM);\n\n    /*\n     * If the mounts have shared propagation then we want to opt out so our\n     * mount changes don't affect the parent mount namespace.\n     */\n    if (mount(NULL, \"/\", NULL, MS_REC | MS_SLAVE, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/, MS_REC|MS_SLAVE): %m\\n\");\n        exit(1);\n    }\n\n    /* The child must remount /proc to use the new pid namespace */\n    if (mount(\"proc\", \"/proc\", \"proc\",\n              MS_NODEV | MS_NOEXEC | MS_NOSUID | MS_RELATIME, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc): %m\\n\");\n        exit(1);\n    }\n\n    tmpdir = mkdtemp(template);\n    if (!tmpdir) {\n        fuse_log(FUSE_LOG_ERR, \"tmpdir(%s): %m\\n\", template);\n        exit(1);\n    }\n\n    if (mount(\"/proc/self/fd\", tmpdir, NULL, MS_BIND, NULL) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"mount(/proc/self/fd, %s, MS_BIND): %m\\n\",\n                 tmpdir);\n        exit(1);\n    }\n\n    /* Now we can get our /proc/self/fd directory file descriptor */\n    lo->proc_self_fd = open(tmpdir, O_PATH);\n    if (lo->proc_self_fd == -1) {\n        fuse_log(FUSE_LOG_ERR, \"open(%s, O_PATH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (umount2(tmpdir, MNT_DETACH) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"umount2(%s, MNT_DETACH): %m\\n\", tmpdir);\n        exit(1);\n    }\n\n    if (rmdir(tmpdir) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"rmdir(%s): %m\\n\", tmpdir);\n    }\n}"
  },
  {
    "function_name": "setup_wait_parent_capabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2383-2388",
    "snippet": "static void setup_wait_parent_capabilities(void)\n{\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    capng_apply(CAPNG_SELECT_BOTH);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capng_apply",
          "args": [
            "CAPNG_SELECT_BOTH"
          ],
          "line": 2387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_clear",
          "args": [
            "CAPNG_SELECT_BOTH"
          ],
          "line": 2386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_setpid",
          "args": [
            "syscall(SYS_gettid)"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_gettid"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void setup_wait_parent_capabilities(void)\n{\n    capng_setpid(syscall(SYS_gettid));\n    capng_clear(CAPNG_SELECT_BOTH);\n    capng_apply(CAPNG_SELECT_BOTH);\n}"
  },
  {
    "function_name": "print_capabilities",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2372-2377",
    "snippet": "static void print_capabilities(void)\n{\n    printf(\"{\\n\");\n    printf(\"  \\\"type\\\": \\\"fs\\\"\\n\");\n    printf(\"}\\n\");\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"}\\n\""
          ],
          "line": 2376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"  \\\"type\\\": \\\"fs\\\"\\n\""
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"{\\n\""
          ],
          "line": 2374
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void print_capabilities(void)\n{\n    printf(\"{\\n\");\n    printf(\"  \\\"type\\\": \\\"fs\\\"\\n\");\n    printf(\"}\\n\");\n}"
  },
  {
    "function_name": "lo_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2308-2326",
    "snippet": "static void lo_destroy(void *userdata)\n{\n    struct lo_data *lo = (struct lo_data *)userdata;\n\n    pthread_mutex_lock(&lo->mutex);\n    while (true) {\n        GHashTableIter iter;\n        gpointer key, value;\n\n        g_hash_table_iter_init(&iter, lo->inodes);\n        if (!g_hash_table_iter_next(&iter, &key, &value)) {\n            break;\n        }\n\n        struct lo_inode *inode = value;\n        unref_inode(lo, inode, inode->nlookup);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unref_inode",
          "args": [
            "lo",
            "inode",
            "inode->nlookup"
          ],
          "line": 2323
        },
        "resolved": true,
        "details": {
          "function_name": "unref_inode_lolocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1210-1220",
          "snippet": "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_hash_table_iter_next",
          "args": [
            "&iter",
            "&key",
            "&value"
          ],
          "line": 2318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_hash_table_iter_init",
          "args": [
            "&iter",
            "lo->inodes"
          ],
          "line": 2317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 2312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_destroy(void *userdata)\n{\n    struct lo_data *lo = (struct lo_data *)userdata;\n\n    pthread_mutex_lock(&lo->mutex);\n    while (true) {\n        GHashTableIter iter;\n        gpointer key, value;\n\n        g_hash_table_iter_init(&iter, lo->inodes);\n        if (!g_hash_table_iter_next(&iter, &key, &value)) {\n            break;\n        }\n\n        struct lo_inode *inode = value;\n        unref_inode(lo, inode, inode->nlookup);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n}"
  },
  {
    "function_name": "lo_lseek",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2294-2306",
    "snippet": "static void lo_lseek(fuse_req_t req, fuse_ino_t ino, off_t off, int whence,\n                     struct fuse_file_info *fi)\n{\n    off_t res;\n\n    (void)ino;\n    res = lseek(lo_fi_fd(req, fi), off, whence);\n    if (res != -1) {\n        fuse_reply_lseek(req, res);\n    } else {\n        fuse_reply_err(req, errno);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "errno"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_lseek",
          "args": [
            "req",
            "res"
          ],
          "line": 2302
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_lseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "706-714",
          "snippet": "int fuse_reply_lseek(fuse_req_t req, off_t off)\n{\n    struct fuse_lseek_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    arg.offset = off;\n\n    return send_reply_ok(req, &arg, sizeof(arg));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_lseek(fuse_req_t req, off_t off)\n{\n    struct fuse_lseek_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    arg.offset = off;\n\n    return send_reply_ok(req, &arg, sizeof(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "lo_fi_fd(req, fi)",
            "off",
            "whence"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "do_lseek",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "1858-1877",
          "snippet": "static void do_lseek(fuse_req_t req, fuse_ino_t nodeid,\n                     struct fuse_mbuf_iter *iter)\n{\n    struct fuse_lseek_in *arg;\n    struct fuse_file_info fi;\n\n    arg = fuse_mbuf_iter_advance(iter, sizeof(*arg));\n    if (!arg) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n    memset(&fi, 0, sizeof(fi));\n    fi.fh = arg->fh;\n\n    if (req->se->op.lseek) {\n        req->se->op.lseek(req, nodeid, arg->offset, arg->whence, &fi);\n    } else {\n        fuse_reply_err(req, ENOSYS);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic void do_lseek(fuse_req_t req, fuse_ino_t nodeid,\n                     struct fuse_mbuf_iter *iter)\n{\n    struct fuse_lseek_in *arg;\n    struct fuse_file_info fi;\n\n    arg = fuse_mbuf_iter_advance(iter, sizeof(*arg));\n    if (!arg) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n    memset(&fi, 0, sizeof(fi));\n    fi.fh = arg->fh;\n\n    if (req->se->op.lseek) {\n        req->se->op.lseek(req, nodeid, arg->offset, arg->whence, &fi);\n    } else {\n        fuse_reply_err(req, ENOSYS);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_fi_fd",
          "args": [
            "req",
            "fi"
          ],
          "line": 2300
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fi_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "598-612",
          "snippet": "static int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_lseek(fuse_req_t req, fuse_ino_t ino, off_t off, int whence,\n                     struct fuse_file_info *fi)\n{\n    off_t res;\n\n    (void)ino;\n    res = lseek(lo_fi_fd(req, fi), off, whence);\n    if (res != -1) {\n        fuse_reply_lseek(req, res);\n    } else {\n        fuse_reply_err(req, errno);\n    }\n}"
  },
  {
    "function_name": "lo_copy_file_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2268-2291",
    "snippet": "static void lo_copy_file_range(fuse_req_t req, fuse_ino_t ino_in, off_t off_in,\n                               struct fuse_file_info *fi_in, fuse_ino_t ino_out,\n                               off_t off_out, struct fuse_file_info *fi_out,\n                               size_t len, int flags)\n{\n    int in_fd, out_fd;\n    ssize_t res;\n\n    in_fd = lo_fi_fd(req, fi_in);\n    out_fd = lo_fi_fd(req, fi_out);\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_copy_file_range(ino=%\" PRIu64 \"/fd=%d, \"\n             \"off=%lu, ino=%\" PRIu64 \"/fd=%d, \"\n             \"off=%lu, size=%zd, flags=0x%x)\\n\",\n             ino_in, in_fd, off_in, ino_out, out_fd, off_out, len, flags);\n\n    res = copy_file_range(in_fd, &off_in, out_fd, &off_out, len, flags);\n    if (res < 0) {\n        fuse_reply_err(req, errno);\n    } else {\n        fuse_reply_write(req, res);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_write",
          "args": [
            "req",
            "res"
          ],
          "line": 2289
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "452-460",
          "snippet": "int fuse_reply_write(fuse_req_t req, size_t count)\n{\n    struct fuse_write_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    arg.size = count;\n\n    return send_reply_ok(req, &arg, sizeof(arg));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_write(fuse_req_t req, size_t count)\n{\n    struct fuse_write_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    arg.size = count;\n\n    return send_reply_ok(req, &arg, sizeof(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "errno"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_file_range",
          "args": [
            "in_fd",
            "&off_in",
            "out_fd",
            "&off_out",
            "len",
            "flags"
          ],
          "line": 2285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_copy_file_range(ino=%\" PRIu64 \"/fd=%d, \"\n             \"off=%lu, ino=%\" PRIu64 \"/fd=%d, \"\n             \"off=%lu, size=%zd, flags=0x%x)\\n\"",
            "ino_in",
            "in_fd",
            "off_in",
            "ino_out",
            "out_fd",
            "off_out",
            "len",
            "flags"
          ],
          "line": 2279
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_fi_fd",
          "args": [
            "req",
            "fi_out"
          ],
          "line": 2277
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fi_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "598-612",
          "snippet": "static int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_copy_file_range(fuse_req_t req, fuse_ino_t ino_in, off_t off_in,\n                               struct fuse_file_info *fi_in, fuse_ino_t ino_out,\n                               off_t off_out, struct fuse_file_info *fi_out,\n                               size_t len, int flags)\n{\n    int in_fd, out_fd;\n    ssize_t res;\n\n    in_fd = lo_fi_fd(req, fi_in);\n    out_fd = lo_fi_fd(req, fi_out);\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_copy_file_range(ino=%\" PRIu64 \"/fd=%d, \"\n             \"off=%lu, ino=%\" PRIu64 \"/fd=%d, \"\n             \"off=%lu, size=%zd, flags=0x%x)\\n\",\n             ino_in, in_fd, off_in, ino_out, out_fd, off_out, len, flags);\n\n    res = copy_file_range(in_fd, &off_in, out_fd, &off_out, len, flags);\n    if (res < 0) {\n        fuse_reply_err(req, errno);\n    } else {\n        fuse_reply_write(req, res);\n    }\n}"
  },
  {
    "function_name": "lo_removexattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2218-2265",
    "snippet": "static void lo_removexattr(fuse_req_t req, fuse_ino_t ino, const char *name)\n{\n    char procname[64];\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_removexattr(ino=%\" PRIu64 \", name=%s)\\n\", ino,\n             name);\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            saverr = errno;\n            goto out;\n        }\n        ret = fremovexattr(fd, name);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = removexattr(procname, name);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    saverr = ret == -1 ? errno : 0;\n\nout:\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "saverr"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&inode"
          ],
          "line": 2263
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 2260
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fchdir(lo->root.fd) == 0"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "lo->root.fd"
          ],
          "line": 2253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "removexattr",
          "args": [
            "procname",
            "name"
          ],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fchdir(lo->proc_self_fd) == 0"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "lo->proc_self_fd"
          ],
          "line": 2251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fremovexattr",
          "args": [
            "fd",
            "name"
          ],
          "line": 2248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "lo->proc_self_fd",
            "procname",
            "O_RDONLY"
          ],
          "line": 2243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->filetype"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->filetype"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "procname",
            "\"%i\"",
            "inode->fd"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_removexattr(ino=%\" PRIu64 \", name=%s)\\n\"",
            "ino",
            "name"
          ],
          "line": 2238
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 2234
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "ino"
          ],
          "line": 2227
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_removexattr(fuse_req_t req, fuse_ino_t ino, const char *name)\n{\n    char procname[64];\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_removexattr(ino=%\" PRIu64 \", name=%s)\\n\", ino,\n             name);\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            saverr = errno;\n            goto out;\n        }\n        ret = fremovexattr(fd, name);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = removexattr(procname, name);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    saverr = ret == -1 ? errno : 0;\n\nout:\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}"
  },
  {
    "function_name": "lo_setxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2168-2216",
    "snippet": "static void lo_setxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                        const char *value, size_t size, int flags)\n{\n    char procname[64];\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_setxattr(ino=%\" PRIu64\n             \", name=%s value=%s size=%zd)\\n\", ino, name, value, size);\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            saverr = errno;\n            goto out;\n        }\n        ret = fsetxattr(fd, name, value, size, flags);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = setxattr(procname, name, value, size, flags);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    saverr = ret == -1 ? errno : 0;\n\nout:\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "saverr"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&inode"
          ],
          "line": 2214
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fchdir(lo->root.fd) == 0"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "lo->root.fd"
          ],
          "line": 2204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setxattr",
          "args": [
            "procname",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 2203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fchdir(lo->proc_self_fd) == 0"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "lo->proc_self_fd"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fsetxattr",
          "args": [
            "fd",
            "name",
            "value",
            "size",
            "flags"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "lo->proc_self_fd",
            "procname",
            "O_RDONLY"
          ],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->filetype"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->filetype"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "procname",
            "\"%i\"",
            "inode->fd"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_setxattr(ino=%\" PRIu64\n             \", name=%s value=%s size=%zd)\\n\"",
            "ino",
            "name",
            "value",
            "size"
          ],
          "line": 2189
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 2185
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "ino"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_setxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                        const char *value, size_t size, int flags)\n{\n    char procname[64];\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_setxattr(ino=%\" PRIu64\n             \", name=%s value=%s size=%zd)\\n\", ino, name, value, size);\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            saverr = errno;\n            goto out;\n        }\n        ret = fsetxattr(fd, name, value, size, flags);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = setxattr(procname, name, value, size, flags);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    saverr = ret == -1 ? errno : 0;\n\nout:\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}"
  },
  {
    "function_name": "lo_listxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2094-2166",
    "snippet": "static void lo_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)\n{\n    struct lo_data *lo = lo_data(req);\n    char *value = NULL;\n    char procname[64];\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_listxattr(ino=%\" PRIu64 \", size=%zd)\\n\", ino,\n             size);\n\n    if (size) {\n        value = malloc(size);\n        if (!value) {\n            goto out_err;\n        }\n    }\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            goto out_err;\n        }\n        ret = flistxattr(fd, value, size);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = listxattr(procname, value, size);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    if (ret == -1) {\n        goto out_err;\n    }\n    if (size) {\n        saverr = 0;\n        if (ret == 0) {\n            goto out;\n        }\n        fuse_reply_buf(req, value, ret);\n    } else {\n        fuse_reply_xattr(req, ret);\n    }\nout_free:\n    free(value);\n\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\nout:\n    fuse_reply_err(req, saverr);\n    goto out_free;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "saverr"
          ],
          "line": 2164
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&inode"
          ],
          "line": 2158
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "value"
          ],
          "line": 2152
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_xattr",
          "args": [
            "req",
            "ret"
          ],
          "line": 2149
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "535-543",
          "snippet": "int fuse_reply_xattr(fuse_req_t req, size_t count)\n{\n    struct fuse_getxattr_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    arg.size = count;\n\n    return send_reply_ok(req, &arg, sizeof(arg));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_xattr(fuse_req_t req, size_t count)\n{\n    struct fuse_getxattr_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    arg.size = count;\n\n    return send_reply_ok(req, &arg, sizeof(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_buf",
          "args": [
            "req",
            "value",
            "ret"
          ],
          "line": 2147
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "462-465",
          "snippet": "int fuse_reply_buf(fuse_req_t req, const char *buf, size_t size)\n{\n    return send_reply_ok(req, buf, size);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_buf(fuse_req_t req, const char *buf, size_t size)\n{\n    return send_reply_ok(req, buf, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fchdir(lo->root.fd) == 0"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "lo->root.fd"
          ],
          "line": 2136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "listxattr",
          "args": [
            "procname",
            "value",
            "size"
          ],
          "line": 2135
        },
        "resolved": true,
        "details": {
          "function_name": "lo_listxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2094-2166",
          "snippet": "static void lo_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)\n{\n    struct lo_data *lo = lo_data(req);\n    char *value = NULL;\n    char procname[64];\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_listxattr(ino=%\" PRIu64 \", size=%zd)\\n\", ino,\n             size);\n\n    if (size) {\n        value = malloc(size);\n        if (!value) {\n            goto out_err;\n        }\n    }\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            goto out_err;\n        }\n        ret = flistxattr(fd, value, size);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = listxattr(procname, value, size);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    if (ret == -1) {\n        goto out_err;\n    }\n    if (size) {\n        saverr = 0;\n        if (ret == 0) {\n            goto out;\n        }\n        fuse_reply_buf(req, value, ret);\n    } else {\n        fuse_reply_xattr(req, ret);\n    }\nout_free:\n    free(value);\n\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\nout:\n    fuse_reply_err(req, saverr);\n    goto out_free;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fchdir(lo->proc_self_fd) == 0"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "lo->proc_self_fd"
          ],
          "line": 2134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flistxattr",
          "args": [
            "fd",
            "value",
            "size"
          ],
          "line": 2131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "lo->proc_self_fd",
            "procname",
            "O_RDONLY"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->filetype"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->filetype"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "procname",
            "\"%i\"",
            "inode->fd"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size"
          ],
          "line": 2119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_listxattr(ino=%\" PRIu64 \", size=%zd)\\n\"",
            "ino",
            "size"
          ],
          "line": 2115
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 2111
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "ino"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_listxattr(fuse_req_t req, fuse_ino_t ino, size_t size)\n{\n    struct lo_data *lo = lo_data(req);\n    char *value = NULL;\n    char procname[64];\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_listxattr(ino=%\" PRIu64 \", size=%zd)\\n\", ino,\n             size);\n\n    if (size) {\n        value = malloc(size);\n        if (!value) {\n            goto out_err;\n        }\n    }\n\n    sprintf(procname, \"%i\", inode->fd);\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            goto out_err;\n        }\n        ret = flistxattr(fd, value, size);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = listxattr(procname, value, size);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    if (ret == -1) {\n        goto out_err;\n    }\n    if (size) {\n        saverr = 0;\n        if (ret == 0) {\n            goto out;\n        }\n        fuse_reply_buf(req, value, ret);\n    } else {\n        fuse_reply_xattr(req, ret);\n    }\nout_free:\n    free(value);\n\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\nout:\n    fuse_reply_err(req, saverr);\n    goto out_free;\n}"
  },
  {
    "function_name": "lo_getxattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2013-2092",
    "snippet": "static void lo_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                        size_t size)\n{\n    struct lo_data *lo = lo_data(req);\n    char *value = NULL;\n    char procname[64];\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_getxattr(ino=%\" PRIu64 \", name=%s size=%zd)\\n\",\n             ino, name, size);\n\n    if (size) {\n        value = malloc(size);\n        if (!value) {\n            goto out_err;\n        }\n    }\n\n    sprintf(procname, \"%i\", inode->fd);\n    /*\n     * It is not safe to open() non-regular/non-dir files in file server\n     * unless O_PATH is used, so use that method for regular files/dir\n     * only (as it seems giving less performance overhead).\n     * Otherwise, call fchdir() to avoid open().\n     */\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            goto out_err;\n        }\n        ret = fgetxattr(fd, name, value, size);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = getxattr(procname, name, value, size);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    if (ret == -1) {\n        goto out_err;\n    }\n    if (size) {\n        saverr = 0;\n        if (ret == 0) {\n            goto out;\n        }\n        fuse_reply_buf(req, value, ret);\n    } else {\n        fuse_reply_xattr(req, ret);\n    }\nout_free:\n    free(value);\n\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\nout:\n    fuse_reply_err(req, saverr);\n    goto out_free;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "saverr"
          ],
          "line": 2090
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&inode"
          ],
          "line": 2084
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "value"
          ],
          "line": 2078
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_xattr",
          "args": [
            "req",
            "ret"
          ],
          "line": 2075
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_xattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "535-543",
          "snippet": "int fuse_reply_xattr(fuse_req_t req, size_t count)\n{\n    struct fuse_getxattr_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    arg.size = count;\n\n    return send_reply_ok(req, &arg, sizeof(arg));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_xattr(fuse_req_t req, size_t count)\n{\n    struct fuse_getxattr_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    arg.size = count;\n\n    return send_reply_ok(req, &arg, sizeof(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_buf",
          "args": [
            "req",
            "value",
            "ret"
          ],
          "line": 2073
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "462-465",
          "snippet": "int fuse_reply_buf(fuse_req_t req, const char *buf, size_t size)\n{\n    return send_reply_ok(req, buf, size);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_buf(fuse_req_t req, const char *buf, size_t size)\n{\n    return send_reply_ok(req, buf, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fchdir(lo->root.fd) == 0"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "lo->root.fd"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getxattr",
          "args": [
            "procname",
            "name",
            "value",
            "size"
          ],
          "line": 2061
        },
        "resolved": true,
        "details": {
          "function_name": "lo_getxattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2013-2092",
          "snippet": "static void lo_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                        size_t size)\n{\n    struct lo_data *lo = lo_data(req);\n    char *value = NULL;\n    char procname[64];\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_getxattr(ino=%\" PRIu64 \", name=%s size=%zd)\\n\",\n             ino, name, size);\n\n    if (size) {\n        value = malloc(size);\n        if (!value) {\n            goto out_err;\n        }\n    }\n\n    sprintf(procname, \"%i\", inode->fd);\n    /*\n     * It is not safe to open() non-regular/non-dir files in file server\n     * unless O_PATH is used, so use that method for regular files/dir\n     * only (as it seems giving less performance overhead).\n     * Otherwise, call fchdir() to avoid open().\n     */\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            goto out_err;\n        }\n        ret = fgetxattr(fd, name, value, size);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = getxattr(procname, name, value, size);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    if (ret == -1) {\n        goto out_err;\n    }\n    if (size) {\n        saverr = 0;\n        if (ret == 0) {\n            goto out;\n        }\n        fuse_reply_buf(req, value, ret);\n    } else {\n        fuse_reply_xattr(req, ret);\n    }\nout_free:\n    free(value);\n\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\nout:\n    fuse_reply_err(req, saverr);\n    goto out_free;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fchdir(lo->proc_self_fd) == 0"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchdir",
          "args": [
            "lo->proc_self_fd"
          ],
          "line": 2060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgetxattr",
          "args": [
            "fd",
            "name",
            "value",
            "size"
          ],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "lo->proc_self_fd",
            "procname",
            "O_RDONLY"
          ],
          "line": 2053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "inode->filetype"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "inode->filetype"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "procname",
            "\"%i\"",
            "inode->fd"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "size"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_getxattr(ino=%\" PRIu64 \", name=%s size=%zd)\\n\"",
            "ino",
            "name",
            "size"
          ],
          "line": 2035
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "ino"
          ],
          "line": 2024
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_getxattr(fuse_req_t req, fuse_ino_t ino, const char *name,\n                        size_t size)\n{\n    struct lo_data *lo = lo_data(req);\n    char *value = NULL;\n    char procname[64];\n    struct lo_inode *inode;\n    ssize_t ret;\n    int saverr;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = ENOSYS;\n    if (!lo_data(req)->xattr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_getxattr(ino=%\" PRIu64 \", name=%s size=%zd)\\n\",\n             ino, name, size);\n\n    if (size) {\n        value = malloc(size);\n        if (!value) {\n            goto out_err;\n        }\n    }\n\n    sprintf(procname, \"%i\", inode->fd);\n    /*\n     * It is not safe to open() non-regular/non-dir files in file server\n     * unless O_PATH is used, so use that method for regular files/dir\n     * only (as it seems giving less performance overhead).\n     * Otherwise, call fchdir() to avoid open().\n     */\n    if (S_ISREG(inode->filetype) || S_ISDIR(inode->filetype)) {\n        fd = openat(lo->proc_self_fd, procname, O_RDONLY);\n        if (fd < 0) {\n            goto out_err;\n        }\n        ret = fgetxattr(fd, name, value, size);\n    } else {\n        /* fchdir should not fail here */\n        assert(fchdir(lo->proc_self_fd) == 0);\n        ret = getxattr(procname, name, value, size);\n        assert(fchdir(lo->root.fd) == 0);\n    }\n\n    if (ret == -1) {\n        goto out_err;\n    }\n    if (size) {\n        saverr = 0;\n        if (ret == 0) {\n            goto out;\n        }\n        fuse_reply_buf(req, value, ret);\n    } else {\n        fuse_reply_xattr(req, ret);\n    }\nout_free:\n    free(value);\n\n    if (fd >= 0) {\n        close(fd);\n    }\n\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\nout:\n    fuse_reply_err(req, saverr);\n    goto out_free;\n}"
  },
  {
    "function_name": "lo_flock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "2002-2011",
    "snippet": "static void lo_flock(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,\n                     int op)\n{\n    int res;\n    (void)ino;\n\n    res = flock(lo_fi_fd(req, fi), op);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "res == -1 ? errno : 0"
          ],
          "line": 2010
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flock",
          "args": [
            "lo_fi_fd(req, fi)",
            "op"
          ],
          "line": 2008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fi_fd",
          "args": [
            "req",
            "fi"
          ],
          "line": 2008
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fi_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "598-612",
          "snippet": "static int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_flock(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,\n                     int op)\n{\n    int res;\n    (void)ino;\n\n    res = flock(lo_fi_fd(req, fi), op);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}"
  },
  {
    "function_name": "lo_fallocate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1978-2000",
    "snippet": "static void lo_fallocate(fuse_req_t req, fuse_ino_t ino, int mode, off_t offset,\n                         off_t length, struct fuse_file_info *fi)\n{\n    int err = EOPNOTSUPP;\n    (void)ino;\n\n#ifdef CONFIG_FALLOCATE\n    err = fallocate(lo_fi_fd(req, fi), mode, offset, length);\n    if (err < 0) {\n        err = errno;\n    }\n\n#elif defined(CONFIG_POSIX_FALLOCATE)\n    if (mode) {\n        fuse_reply_err(req, EOPNOTSUPP);\n        return;\n    }\n\n    err = posix_fallocate(lo_fi_fd(req, fi), offset, length);\n#endif\n\n    fuse_reply_err(req, err);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "err"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posix_fallocate",
          "args": [
            "lo_fi_fd(req, fi)",
            "offset",
            "length"
          ],
          "line": 1996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fi_fd",
          "args": [
            "req",
            "fi"
          ],
          "line": 1996
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fi_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "598-612",
          "snippet": "static int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fallocate",
          "args": [
            "lo_fi_fd(req, fi)",
            "mode",
            "offset",
            "length"
          ],
          "line": 1985
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_fallocate(fuse_req_t req, fuse_ino_t ino, int mode, off_t offset,\n                         off_t length, struct fuse_file_info *fi)\n{\n    int err = EOPNOTSUPP;\n    (void)ino;\n\n#ifdef CONFIG_FALLOCATE\n    err = fallocate(lo_fi_fd(req, fi), mode, offset, length);\n    if (err < 0) {\n        err = errno;\n    }\n\n#elif defined(CONFIG_POSIX_FALLOCATE)\n    if (mode) {\n        fuse_reply_err(req, EOPNOTSUPP);\n        return;\n    }\n\n    err = posix_fallocate(lo_fi_fd(req, fi), offset, length);\n#endif\n\n    fuse_reply_err(req, err);\n}"
  },
  {
    "function_name": "lo_statfs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1965-1976",
    "snippet": "static void lo_statfs(fuse_req_t req, fuse_ino_t ino)\n{\n    int res;\n    struct statvfs stbuf;\n\n    res = fstatvfs(lo_fd(req, ino), &stbuf);\n    if (res == -1) {\n        fuse_reply_err(req, errno);\n    } else {\n        fuse_reply_statfs(req, &stbuf);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_statfs",
          "args": [
            "req",
            "&stbuf"
          ],
          "line": 1974
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_statfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "524-533",
          "snippet": "int fuse_reply_statfs(fuse_req_t req, const struct statvfs *stbuf)\n{\n    struct fuse_statfs_out arg;\n    size_t size = sizeof(arg);\n\n    memset(&arg, 0, sizeof(arg));\n    convert_statfs(stbuf, &arg.st);\n\n    return send_reply_ok(req, &arg, size);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_statfs(fuse_req_t req, const struct statvfs *stbuf)\n{\n    struct fuse_statfs_out arg;\n    size_t size = sizeof(arg);\n\n    memset(&arg, 0, sizeof(arg));\n    convert_statfs(stbuf, &arg.st);\n\n    return send_reply_ok(req, &arg, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "errno"
          ],
          "line": 1972
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fstatvfs",
          "args": [
            "lo_fd(req, ino)",
            "&stbuf"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fd",
          "args": [
            "req",
            "ino"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "527-539",
          "snippet": "static int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_statfs(fuse_req_t req, fuse_ino_t ino)\n{\n    int res;\n    struct statvfs stbuf;\n\n    res = fstatvfs(lo_fd(req, ino), &stbuf);\n    if (res == -1) {\n        fuse_reply_err(req, errno);\n    } else {\n        fuse_reply_statfs(req, &stbuf);\n    }\n}"
  },
  {
    "function_name": "lo_write_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1921-1963",
    "snippet": "static void lo_write_buf(fuse_req_t req, fuse_ino_t ino,\n                         struct fuse_bufvec *in_buf, off_t off,\n                         struct fuse_file_info *fi)\n{\n    (void)ino;\n    ssize_t res;\n    struct fuse_bufvec out_buf = FUSE_BUFVEC_INIT(fuse_buf_size(in_buf));\n    bool cap_fsetid_dropped = false;\n\n    out_buf.buf[0].flags = FUSE_BUF_IS_FD | FUSE_BUF_FD_SEEK;\n    out_buf.buf[0].fd = lo_fi_fd(req, fi);\n    out_buf.buf[0].pos = off;\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_write_buf(ino=%\" PRIu64 \", size=%zd, off=%lu)\\n\", ino,\n             out_buf.buf[0].size, (unsigned long)off);\n\n    /*\n     * If kill_priv is set, drop CAP_FSETID which should lead to kernel\n     * clearing setuid/setgid on file.\n     */\n    if (fi->kill_priv) {\n        res = drop_effective_cap(\"FSETID\", &cap_fsetid_dropped);\n        if (res != 0) {\n            fuse_reply_err(req, res);\n            return;\n        }\n    }\n\n    res = fuse_buf_copy(&out_buf, in_buf);\n    if (res < 0) {\n        fuse_reply_err(req, -res);\n    } else {\n        fuse_reply_write(req, (size_t)res);\n    }\n\n    if (cap_fsetid_dropped) {\n        res = gain_effective_cap(\"FSETID\");\n        if (res) {\n            fuse_log(FUSE_LOG_ERR, \"Failed to gain CAP_FSETID\\n\");\n        }\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"Failed to gain CAP_FSETID\\n\""
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gain_effective_cap",
          "args": [
            "\"FSETID\""
          ],
          "line": 1958
        },
        "resolved": true,
        "details": {
          "function_name": "gain_effective_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "303-337",
          "snippet": "static int gain_effective_cap(const char *cap_name)\n{\n    int cap;\n    int ret = 0;\n\n    cap = capng_name_to_capability(cap_name);\n    if (cap < 0) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_name_to_capability(%s) failed:%s\\n\",\n                 cap_name, strerror(errno));\n        goto out;\n    }\n\n    if (load_capng()) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"load_capng() failed\\n\");\n        goto out;\n    }\n\n    if (capng_update(CAPNG_ADD, CAPNG_EFFECTIVE, cap)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_update(ADD,) failed\\n\");\n        goto out;\n    }\n\n    if (capng_apply(CAPNG_SELECT_CAPS)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"gain:capng_apply() failed\\n\");\n        goto out;\n    }\n    ret = 0;\n\nout:\n    return ret;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);",
            "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\n\nstatic int gain_effective_cap(const char *cap_name)\n{\n    int cap;\n    int ret = 0;\n\n    cap = capng_name_to_capability(cap_name);\n    if (cap < 0) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_name_to_capability(%s) failed:%s\\n\",\n                 cap_name, strerror(errno));\n        goto out;\n    }\n\n    if (load_capng()) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"load_capng() failed\\n\");\n        goto out;\n    }\n\n    if (capng_update(CAPNG_ADD, CAPNG_EFFECTIVE, cap)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_update(ADD,) failed\\n\");\n        goto out;\n    }\n\n    if (capng_apply(CAPNG_SELECT_CAPS)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"gain:capng_apply() failed\\n\");\n        goto out;\n    }\n    ret = 0;\n\nout:\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_write",
          "args": [
            "req",
            "(size_t)res"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "452-460",
          "snippet": "int fuse_reply_write(fuse_req_t req, size_t count)\n{\n    struct fuse_write_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    arg.size = count;\n\n    return send_reply_ok(req, &arg, sizeof(arg));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_write(fuse_req_t req, size_t count)\n{\n    struct fuse_write_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    arg.size = count;\n\n    return send_reply_ok(req, &arg, sizeof(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "-res"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_buf_copy",
          "args": [
            "&out_buf",
            "in_buf"
          ],
          "line": 1950
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_buf_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "262-323",
          "snippet": "ssize_t fuse_buf_copy(struct fuse_bufvec *dstv, struct fuse_bufvec *srcv)\n{\n    size_t copied = 0, i;\n\n    if (dstv == srcv) {\n        return fuse_buf_size(dstv);\n    }\n\n    /*\n     * use writev to improve bandwidth when all the\n     * src buffers already mapped by the daemon\n     * process\n     */\n    for (i = 0; i < srcv->count; i++) {\n        if (srcv->buf[i].flags & FUSE_BUF_IS_FD) {\n            break;\n        }\n    }\n    if ((i == srcv->count) && (dstv->count == 1) &&\n        (dstv->idx == 0) &&\n        (dstv->buf[0].flags & FUSE_BUF_IS_FD)) {\n        dstv->buf[0].pos += dstv->off;\n        return fuse_buf_writev(&dstv->buf[0], srcv);\n    }\n\n    for (;;) {\n        const struct fuse_buf *src = fuse_bufvec_current(srcv);\n        const struct fuse_buf *dst = fuse_bufvec_current(dstv);\n        size_t src_len;\n        size_t dst_len;\n        size_t len;\n        ssize_t res;\n\n        if (src == NULL || dst == NULL) {\n            break;\n        }\n\n        src_len = src->size - srcv->off;\n        dst_len = dst->size - dstv->off;\n        len = min_size(src_len, dst_len);\n\n        res = fuse_buf_copy_one(dst, dstv->off, src, srcv->off, len);\n        if (res < 0) {\n            if (!copied) {\n                return res;\n            }\n            break;\n        }\n        copied += res;\n\n        if (!fuse_bufvec_advance(srcv, res) ||\n            !fuse_bufvec_advance(dstv, res)) {\n            break;\n        }\n\n        if (res < len) {\n            break;\n        }\n    }\n\n    return copied;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nssize_t fuse_buf_copy(struct fuse_bufvec *dstv, struct fuse_bufvec *srcv)\n{\n    size_t copied = 0, i;\n\n    if (dstv == srcv) {\n        return fuse_buf_size(dstv);\n    }\n\n    /*\n     * use writev to improve bandwidth when all the\n     * src buffers already mapped by the daemon\n     * process\n     */\n    for (i = 0; i < srcv->count; i++) {\n        if (srcv->buf[i].flags & FUSE_BUF_IS_FD) {\n            break;\n        }\n    }\n    if ((i == srcv->count) && (dstv->count == 1) &&\n        (dstv->idx == 0) &&\n        (dstv->buf[0].flags & FUSE_BUF_IS_FD)) {\n        dstv->buf[0].pos += dstv->off;\n        return fuse_buf_writev(&dstv->buf[0], srcv);\n    }\n\n    for (;;) {\n        const struct fuse_buf *src = fuse_bufvec_current(srcv);\n        const struct fuse_buf *dst = fuse_bufvec_current(dstv);\n        size_t src_len;\n        size_t dst_len;\n        size_t len;\n        ssize_t res;\n\n        if (src == NULL || dst == NULL) {\n            break;\n        }\n\n        src_len = src->size - srcv->off;\n        dst_len = dst->size - dstv->off;\n        len = min_size(src_len, dst_len);\n\n        res = fuse_buf_copy_one(dst, dstv->off, src, srcv->off, len);\n        if (res < 0) {\n            if (!copied) {\n                return res;\n            }\n            break;\n        }\n        copied += res;\n\n        if (!fuse_bufvec_advance(srcv, res) ||\n            !fuse_bufvec_advance(dstv, res)) {\n            break;\n        }\n\n        if (res < len) {\n            break;\n        }\n    }\n\n    return copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_effective_cap",
          "args": [
            "\"FSETID\"",
            "&cap_fsetid_dropped"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "drop_effective_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "258-301",
          "snippet": "static int drop_effective_cap(const char *cap_name, bool *cap_dropped)\n{\n    int cap, ret;\n\n    cap = capng_name_to_capability(cap_name);\n    if (cap < 0) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_name_to_capability(%s) failed:%s\\n\",\n                 cap_name, strerror(errno));\n        goto out;\n    }\n\n    if (load_capng()) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"load_capng() failed\\n\");\n        goto out;\n    }\n\n    /* We dont have this capability in effective set already. */\n    if (!capng_have_capability(CAPNG_EFFECTIVE, cap)) {\n        ret = 0;\n        goto out;\n    }\n\n    if (capng_update(CAPNG_DROP, CAPNG_EFFECTIVE, cap)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_update(DROP,) failed\\n\");\n        goto out;\n    }\n\n    if (capng_apply(CAPNG_SELECT_CAPS)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"drop:capng_apply() failed\\n\");\n        goto out;\n    }\n\n    ret = 0;\n    if (cap_dropped) {\n        *cap_dropped = true;\n    }\n\nout:\n    return ret;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);",
            "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\n\nstatic int drop_effective_cap(const char *cap_name, bool *cap_dropped)\n{\n    int cap, ret;\n\n    cap = capng_name_to_capability(cap_name);\n    if (cap < 0) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_name_to_capability(%s) failed:%s\\n\",\n                 cap_name, strerror(errno));\n        goto out;\n    }\n\n    if (load_capng()) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"load_capng() failed\\n\");\n        goto out;\n    }\n\n    /* We dont have this capability in effective set already. */\n    if (!capng_have_capability(CAPNG_EFFECTIVE, cap)) {\n        ret = 0;\n        goto out;\n    }\n\n    if (capng_update(CAPNG_DROP, CAPNG_EFFECTIVE, cap)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_update(DROP,) failed\\n\");\n        goto out;\n    }\n\n    if (capng_apply(CAPNG_SELECT_CAPS)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"drop:capng_apply() failed\\n\");\n        goto out;\n    }\n\n    ret = 0;\n    if (cap_dropped) {\n        *cap_dropped = true;\n    }\n\nout:\n    return ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_fi_fd",
          "args": [
            "req",
            "fi"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fi_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "598-612",
          "snippet": "static int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_BUFVEC_INIT",
          "args": [
            "fuse_buf_size(in_buf)"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_buf_size",
          "args": [
            "in_buf"
          ],
          "line": 1927
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_buf_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "21-35",
          "snippet": "size_t fuse_buf_size(const struct fuse_bufvec *bufv)\n{\n    size_t i;\n    size_t size = 0;\n\n    for (i = 0; i < bufv->count; i++) {\n        if (bufv->buf[i].size == SIZE_MAX) {\n            size = SIZE_MAX;\n        } else {\n            size += bufv->buf[i].size;\n        }\n    }\n\n    return size;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nsize_t fuse_buf_size(const struct fuse_bufvec *bufv)\n{\n    size_t i;\n    size_t size = 0;\n\n    for (i = 0; i < bufv->count; i++) {\n        if (bufv->buf[i].size == SIZE_MAX) {\n            size = SIZE_MAX;\n        } else {\n            size += bufv->buf[i].size;\n        }\n    }\n\n    return size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_write_buf(fuse_req_t req, fuse_ino_t ino,\n                         struct fuse_bufvec *in_buf, off_t off,\n                         struct fuse_file_info *fi)\n{\n    (void)ino;\n    ssize_t res;\n    struct fuse_bufvec out_buf = FUSE_BUFVEC_INIT(fuse_buf_size(in_buf));\n    bool cap_fsetid_dropped = false;\n\n    out_buf.buf[0].flags = FUSE_BUF_IS_FD | FUSE_BUF_FD_SEEK;\n    out_buf.buf[0].fd = lo_fi_fd(req, fi);\n    out_buf.buf[0].pos = off;\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_write_buf(ino=%\" PRIu64 \", size=%zd, off=%lu)\\n\", ino,\n             out_buf.buf[0].size, (unsigned long)off);\n\n    /*\n     * If kill_priv is set, drop CAP_FSETID which should lead to kernel\n     * clearing setuid/setgid on file.\n     */\n    if (fi->kill_priv) {\n        res = drop_effective_cap(\"FSETID\", &cap_fsetid_dropped);\n        if (res != 0) {\n            fuse_reply_err(req, res);\n            return;\n        }\n    }\n\n    res = fuse_buf_copy(&out_buf, in_buf);\n    if (res < 0) {\n        fuse_reply_err(req, -res);\n    } else {\n        fuse_reply_write(req, (size_t)res);\n    }\n\n    if (cap_fsetid_dropped) {\n        res = gain_effective_cap(\"FSETID\");\n        if (res) {\n            fuse_log(FUSE_LOG_ERR, \"Failed to gain CAP_FSETID\\n\");\n        }\n    }\n}"
  },
  {
    "function_name": "lo_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1904-1919",
    "snippet": "static void lo_read(fuse_req_t req, fuse_ino_t ino, size_t size, off_t offset,\n                    struct fuse_file_info *fi)\n{\n    struct fuse_bufvec buf = FUSE_BUFVEC_INIT(size);\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_read(ino=%\" PRIu64 \", size=%zd, \"\n             \"off=%lu)\\n\",\n             ino, size, (unsigned long)offset);\n\n    buf.buf[0].flags = FUSE_BUF_IS_FD | FUSE_BUF_FD_SEEK;\n    buf.buf[0].fd = lo_fi_fd(req, fi);\n    buf.buf[0].pos = offset;\n\n    fuse_reply_data(req, &buf);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_data",
          "args": [
            "req",
            "&buf"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "504-522",
          "snippet": "int fuse_reply_data(fuse_req_t req, struct fuse_bufvec *bufv)\n{\n    struct iovec iov[2];\n    struct fuse_out_header out = {\n        .unique = req->unique,\n    };\n    int res;\n\n    iov[0].iov_base = &out;\n    iov[0].iov_len = sizeof(struct fuse_out_header);\n\n    res = fuse_send_data_iov(req->se, req->ch, iov, 1, bufv);\n    if (res <= 0) {\n        fuse_free_req(req);\n        return res;\n    } else {\n        return fuse_reply_err(req, res);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_data(fuse_req_t req, struct fuse_bufvec *bufv)\n{\n    struct iovec iov[2];\n    struct fuse_out_header out = {\n        .unique = req->unique,\n    };\n    int res;\n\n    iov[0].iov_base = &out;\n    iov[0].iov_len = sizeof(struct fuse_out_header);\n\n    res = fuse_send_data_iov(req->se, req->ch, iov, 1, bufv);\n    if (res <= 0) {\n        fuse_free_req(req);\n        return res;\n    } else {\n        return fuse_reply_err(req, res);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_fi_fd",
          "args": [
            "req",
            "fi"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fi_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "598-612",
          "snippet": "static int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_read(ino=%\" PRIu64 \", size=%zd, \"\n             \"off=%lu)\\n\"",
            "ino",
            "size",
            "(unsigned long)offset"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FUSE_BUFVEC_INIT",
          "args": [
            "size"
          ],
          "line": 1907
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_read(fuse_req_t req, fuse_ino_t ino, size_t size, off_t offset,\n                    struct fuse_file_info *fi)\n{\n    struct fuse_bufvec buf = FUSE_BUFVEC_INIT(size);\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_read(ino=%\" PRIu64 \", size=%zd, \"\n             \"off=%lu)\\n\",\n             ino, size, (unsigned long)offset);\n\n    buf.buf[0].flags = FUSE_BUF_IS_FD | FUSE_BUF_FD_SEEK;\n    buf.buf[0].fd = lo_fi_fd(req, fi);\n    buf.buf[0].pos = offset;\n\n    fuse_reply_data(req, &buf);\n}"
  },
  {
    "function_name": "lo_fsync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1866-1902",
    "snippet": "static void lo_fsync(fuse_req_t req, fuse_ino_t ino, int datasync,\n                     struct fuse_file_info *fi)\n{\n    int res;\n    int fd;\n    char *buf;\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_fsync(ino=%\" PRIu64 \", fi=0x%p)\\n\", ino,\n             (void *)fi);\n\n    if (!fi) {\n        struct lo_data *lo = lo_data(req);\n\n        res = asprintf(&buf, \"%i\", lo_fd(req, ino));\n        if (res == -1) {\n            return (void)fuse_reply_err(req, errno);\n        }\n\n        fd = openat(lo->proc_self_fd, buf, O_RDWR);\n        free(buf);\n        if (fd == -1) {\n            return (void)fuse_reply_err(req, errno);\n        }\n    } else {\n        fd = lo_fi_fd(req, fi);\n    }\n\n    if (datasync) {\n        res = fdatasync(fd);\n    } else {\n        res = fsync(fd);\n    }\n    if (!fi) {\n        close(fd);\n    }\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "res == -1 ? errno : 0"
          ],
          "line": 1901
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1899
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsync",
          "args": [
            "fd"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdatasync",
          "args": [
            "fd"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fi_fd",
          "args": [
            "req",
            "fi"
          ],
          "line": 1890
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fi_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "598-612",
          "snippet": "static int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 1885
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "lo->proc_self_fd",
            "buf",
            "O_RDWR"
          ],
          "line": 1884
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "asprintf",
          "args": [
            "&buf",
            "\"%i\"",
            "lo_fd(req, ino)"
          ],
          "line": 1879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fd",
          "args": [
            "req",
            "ino"
          ],
          "line": 1879
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "527-539",
          "snippet": "static int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1877
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_fsync(ino=%\" PRIu64 \", fi=0x%p)\\n\"",
            "ino",
            "(void *)fi"
          ],
          "line": 1873
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_fsync(fuse_req_t req, fuse_ino_t ino, int datasync,\n                     struct fuse_file_info *fi)\n{\n    int res;\n    int fd;\n    char *buf;\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_fsync(ino=%\" PRIu64 \", fi=0x%p)\\n\", ino,\n             (void *)fi);\n\n    if (!fi) {\n        struct lo_data *lo = lo_data(req);\n\n        res = asprintf(&buf, \"%i\", lo_fd(req, ino));\n        if (res == -1) {\n            return (void)fuse_reply_err(req, errno);\n        }\n\n        fd = openat(lo->proc_self_fd, buf, O_RDWR);\n        free(buf);\n        if (fd == -1) {\n            return (void)fuse_reply_err(req, errno);\n        }\n    } else {\n        fd = lo_fi_fd(req, fi);\n    }\n\n    if (datasync) {\n        res = fdatasync(fd);\n    } else {\n        res = fsync(fd);\n    }\n    if (!fi) {\n        close(fd);\n    }\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}"
  },
  {
    "function_name": "lo_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1844-1864",
    "snippet": "static void lo_flush(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)\n{\n    int res;\n    (void)ino;\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    /* An fd is going away. Cleanup associated posix locks */\n    pthread_mutex_lock(&inode->plock_mutex);\n    g_hash_table_remove(inode->posix_locks, GUINT_TO_POINTER(fi->lock_owner));\n    pthread_mutex_unlock(&inode->plock_mutex);\n\n    res = close(dup(lo_fi_fd(req, fi)));\n    lo_inode_put(lo_data(req), &inode);\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "res == -1 ? errno : 0"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo_data(req)",
            "&inode"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1862
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "dup(lo_fi_fd(req, fi))"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup",
          "args": [
            "lo_fi_fd(req, fi)"
          ],
          "line": 1861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fi_fd",
          "args": [
            "req",
            "fi"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fi_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "598-612",
          "snippet": "static int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&inode->plock_mutex"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_hash_table_remove",
          "args": [
            "inode->posix_locks",
            "GUINT_TO_POINTER(fi->lock_owner)"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUINT_TO_POINTER",
          "args": [
            "fi->lock_owner"
          ],
          "line": 1858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&inode->plock_mutex"
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "ino"
          ],
          "line": 1850
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_flush(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)\n{\n    int res;\n    (void)ino;\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    /* An fd is going away. Cleanup associated posix locks */\n    pthread_mutex_lock(&inode->plock_mutex);\n    g_hash_table_remove(inode->posix_locks, GUINT_TO_POINTER(fi->lock_owner));\n    pthread_mutex_unlock(&inode->plock_mutex);\n\n    res = close(dup(lo_fi_fd(req, fi)));\n    lo_inode_put(lo_data(req), &inode);\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}"
  },
  {
    "function_name": "lo_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1822-1842",
    "snippet": "static void lo_release(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n    int fd = -1;\n\n    (void)ino;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    if (elem) {\n        fd = elem->fd;\n        elem = NULL;\n        lo_map_remove(&lo->fd_map, fi->fh);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    close(fd);\n    fuse_reply_err(req, 0);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "0"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_map_remove",
          "args": [
            "&lo->fd_map",
            "fi->fh"
          ],
          "line": 1836
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "425-442",
          "snippet": "static void lo_map_remove(struct lo_map *map, size_t key)\n{\n    struct lo_map_elem *elem;\n\n    if (key >= map->nelems) {\n        return;\n    }\n\n    elem = &map->elems[key];\n    if (!elem->in_use) {\n        return;\n    }\n\n    elem->in_use = false;\n\n    elem->freelist = map->freelist;\n    map->freelist = key;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_map_remove(struct lo_map *map, size_t key)\n{\n    struct lo_map_elem *elem;\n\n    if (key >= map->nelems) {\n        return;\n    }\n\n    elem = &map->elems[key];\n    if (!elem->in_use) {\n        return;\n    }\n\n    elem->in_use = false;\n\n    elem->freelist = map->freelist;\n    map->freelist = key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_map_get",
          "args": [
            "&lo->fd_map",
            "fi->fh"
          ],
          "line": 1832
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "414-423",
          "snippet": "static struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1825
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_release(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n    int fd = -1;\n\n    (void)ino;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    if (elem) {\n        fd = elem->fd;\n        elem = NULL;\n        lo_map_remove(&lo->fd_map, fi->fh);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    close(fd);\n    fuse_reply_err(req, 0);\n}"
  },
  {
    "function_name": "lo_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1786-1820",
    "snippet": "static void lo_open(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)\n{\n    int fd;\n    ssize_t fh;\n    char buf[64];\n    struct lo_data *lo = lo_data(req);\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_open(ino=%\" PRIu64 \", flags=%d)\\n\", ino,\n             fi->flags);\n\n    update_open_flags(lo->writeback, lo->allow_direct_io, fi);\n\n    sprintf(buf, \"%i\", lo_fd(req, ino));\n    fd = openat(lo->proc_self_fd, buf, fi->flags & ~O_NOFOLLOW);\n    if (fd == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    fh = lo_add_fd_mapping(req, fd);\n    pthread_mutex_unlock(&lo->mutex);\n    if (fh == -1) {\n        close(fd);\n        fuse_reply_err(req, ENOMEM);\n        return;\n    }\n\n    fi->fh = fh;\n    if (lo->cache == CACHE_NONE) {\n        fi->direct_io = 1;\n    } else if (lo->cache == CACHE_ALWAYS) {\n        fi->keep_cache = 1;\n    }\n    fuse_reply_open(req, fi);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_open",
          "args": [
            "req",
            "fi"
          ],
          "line": 1819
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "443-450",
          "snippet": "int fuse_reply_open(fuse_req_t req, const struct fuse_file_info *f)\n{\n    struct fuse_open_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    fill_open(&arg, f);\n    return send_reply_ok(req, &arg, sizeof(arg));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_open(fuse_req_t req, const struct fuse_file_info *f)\n{\n    struct fuse_open_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    fill_open(&arg, f);\n    return send_reply_ok(req, &arg, sizeof(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "ENOMEM"
          ],
          "line": 1809
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_add_fd_mapping",
          "args": [
            "req",
            "fd"
          ],
          "line": 1805
        },
        "resolved": true,
        "details": {
          "function_name": "lo_add_fd_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "445-456",
          "snippet": "static ssize_t lo_add_fd_mapping(fuse_req_t req, int fd)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->fd_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->fd = fd;\n    return elem - lo_data(req)->fd_map.elems;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t lo_add_fd_mapping(fuse_req_t req, int fd)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->fd_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->fd = fd;\n    return elem - lo_data(req)->fd_map.elems;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "lo->proc_self_fd",
            "buf",
            "fi->flags & ~O_NOFOLLOW"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%i\"",
            "lo_fd(req, ino)"
          ],
          "line": 1798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fd",
          "args": [
            "req",
            "ino"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "527-539",
          "snippet": "static int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_open_flags",
          "args": [
            "lo->writeback",
            "lo->allow_direct_io",
            "fi"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "update_open_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1522-1555",
          "snippet": "static void update_open_flags(int writeback, int allow_direct_io,\n                              struct fuse_file_info *fi)\n{\n    /*\n     * With writeback cache, kernel may send read requests even\n     * when userspace opened write-only\n     */\n    if (writeback && (fi->flags & O_ACCMODE) == O_WRONLY) {\n        fi->flags &= ~O_ACCMODE;\n        fi->flags |= O_RDWR;\n    }\n\n    /*\n     * With writeback cache, O_APPEND is handled by the kernel.\n     * This breaks atomicity (since the file may change in the\n     * underlying filesystem, so that the kernel's idea of the\n     * end of the file isn't accurate anymore). In this example,\n     * we just accept that. A more rigorous filesystem may want\n     * to return an error here\n     */\n    if (writeback && (fi->flags & O_APPEND)) {\n        fi->flags &= ~O_APPEND;\n    }\n\n    /*\n     * O_DIRECT in guest should not necessarily mean bypassing page\n     * cache on host as well. Therefore, we discard it by default\n     * ('-o no_allow_direct_io'). If somebody needs that behavior,\n     * the '-o allow_direct_io' option should be set.\n     */\n    if (!allow_direct_io) {\n        fi->flags &= ~O_DIRECT;\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void update_open_flags(int writeback, int allow_direct_io,\n                              struct fuse_file_info *fi)\n{\n    /*\n     * With writeback cache, kernel may send read requests even\n     * when userspace opened write-only\n     */\n    if (writeback && (fi->flags & O_ACCMODE) == O_WRONLY) {\n        fi->flags &= ~O_ACCMODE;\n        fi->flags |= O_RDWR;\n    }\n\n    /*\n     * With writeback cache, O_APPEND is handled by the kernel.\n     * This breaks atomicity (since the file may change in the\n     * underlying filesystem, so that the kernel's idea of the\n     * end of the file isn't accurate anymore). In this example,\n     * we just accept that. A more rigorous filesystem may want\n     * to return an error here\n     */\n    if (writeback && (fi->flags & O_APPEND)) {\n        fi->flags &= ~O_APPEND;\n    }\n\n    /*\n     * O_DIRECT in guest should not necessarily mean bypassing page\n     * cache on host as well. Therefore, we discard it by default\n     * ('-o no_allow_direct_io'). If somebody needs that behavior,\n     * the '-o allow_direct_io' option should be set.\n     */\n    if (!allow_direct_io) {\n        fi->flags &= ~O_DIRECT;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_open(ino=%\" PRIu64 \", flags=%d)\\n\"",
            "ino",
            "fi->flags"
          ],
          "line": 1793
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_open(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi)\n{\n    int fd;\n    ssize_t fh;\n    char buf[64];\n    struct lo_data *lo = lo_data(req);\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_open(ino=%\" PRIu64 \", flags=%d)\\n\", ino,\n             fi->flags);\n\n    update_open_flags(lo->writeback, lo->allow_direct_io, fi);\n\n    sprintf(buf, \"%i\", lo_fd(req, ino));\n    fd = openat(lo->proc_self_fd, buf, fi->flags & ~O_NOFOLLOW);\n    if (fd == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    fh = lo_add_fd_mapping(req, fd);\n    pthread_mutex_unlock(&lo->mutex);\n    if (fh == -1) {\n        close(fd);\n        fuse_reply_err(req, ENOMEM);\n        return;\n    }\n\n    fi->fh = fh;\n    if (lo->cache == CACHE_NONE) {\n        fi->direct_io = 1;\n    } else if (lo->cache == CACHE_ALWAYS) {\n        fi->keep_cache = 1;\n    }\n    fuse_reply_open(req, fi);\n}"
  },
  {
    "function_name": "lo_fsyncdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1759-1784",
    "snippet": "static void lo_fsyncdir(fuse_req_t req, fuse_ino_t ino, int datasync,\n                        struct fuse_file_info *fi)\n{\n    int res;\n    struct lo_dirp *d;\n    int fd;\n\n    (void)ino;\n\n    d = lo_dirp(req, fi);\n    if (!d) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    fd = dirfd(d->dp);\n    if (datasync) {\n        res = fdatasync(fd);\n    } else {\n        res = fsync(fd);\n    }\n\n    lo_dirp_put(&d);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "res == -1 ? errno : 0"
          ],
          "line": 1783
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_dirp_put",
          "args": [
            "&d"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "lo_dirp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1283-1296",
          "snippet": "static void lo_dirp_put(struct lo_dirp **dp)\n{\n    struct lo_dirp *d = *dp;\n\n    if (!d) {\n        return;\n    }\n    *dp = NULL;\n\n    if (g_atomic_int_dec_and_test(&d->refcount)) {\n        closedir(d->dp);\n        free(d);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_dirp_put(struct lo_dirp **dp)\n{\n    struct lo_dirp *d = *dp;\n\n    if (!d) {\n        return;\n    }\n    *dp = NULL;\n\n    if (g_atomic_int_dec_and_test(&d->refcount)) {\n        closedir(d->dp);\n        free(d);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fsync",
          "args": [
            "fd"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdatasync",
          "args": [
            "fd"
          ],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dirfd",
          "args": [
            "d->dp"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_dirp",
          "args": [
            "req",
            "fi"
          ],
          "line": 1768
        },
        "resolved": true,
        "details": {
          "function_name": "lo_dirp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1299-1315",
          "snippet": "static struct lo_dirp *lo_dirp(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->dirp_map, fi->fh);\n    if (elem) {\n        g_atomic_int_inc(&elem->dirp->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->dirp;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_dirp *lo_dirp(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->dirp_map, fi->fh);\n    if (elem) {\n        g_atomic_int_inc(&elem->dirp->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->dirp;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_fsyncdir(fuse_req_t req, fuse_ino_t ino, int datasync,\n                        struct fuse_file_info *fi)\n{\n    int res;\n    struct lo_dirp *d;\n    int fd;\n\n    (void)ino;\n\n    d = lo_dirp(req, fi);\n    if (!d) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    fd = dirfd(d->dp);\n    if (datasync) {\n        res = fdatasync(fd);\n    } else {\n        res = fsync(fd);\n    }\n\n    lo_dirp_put(&d);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n}"
  },
  {
    "function_name": "lo_setlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1710-1757",
    "snippet": "static void lo_setlk(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,\n                     struct flock *lock, int sleep)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    struct lo_inode_plock *plock;\n    int ret, saverr = 0;\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_setlk(ino=%\" PRIu64 \", flags=%d)\"\n             \" cmd=%d pid=%d owner=0x%lx sleep=%d l_whence=%d\"\n             \" l_start=0x%lx l_len=0x%lx\\n\",\n             ino, fi->flags, lock->l_type, lock->l_pid, fi->lock_owner, sleep,\n             lock->l_whence, lock->l_start, lock->l_len);\n\n    if (sleep) {\n        fuse_reply_err(req, EOPNOTSUPP);\n        return;\n    }\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    pthread_mutex_lock(&inode->plock_mutex);\n    plock =\n        lookup_create_plock_ctx(lo, inode, fi->lock_owner, lock->l_pid, &ret);\n\n    if (!plock) {\n        saverr = ret;\n        goto out;\n    }\n\n    /* TODO: Is it alright to modify flock? */\n    lock->l_pid = 0;\n    ret = fcntl(plock->fd, F_OFD_SETLK, lock);\n    if (ret == -1) {\n        saverr = errno;\n    }\n\nout:\n    pthread_mutex_unlock(&inode->plock_mutex);\n    lo_inode_put(lo, &inode);\n\n    fuse_reply_err(req, saverr);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "saverr"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&inode"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&inode->plock_mutex"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "plock->fd",
            "F_OFD_SETLK",
            "lock"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_create_plock_ctx",
          "args": [
            "lo",
            "inode",
            "fi->lock_owner",
            "lock->l_pid",
            "&ret"
          ],
          "line": 1738
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_create_plock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1625-1663",
          "snippet": "static struct lo_inode_plock *lookup_create_plock_ctx(struct lo_data *lo,\n                                                      struct lo_inode *inode,\n                                                      uint64_t lock_owner,\n                                                      pid_t pid, int *err)\n{\n    struct lo_inode_plock *plock;\n    char procname[64];\n    int fd;\n\n    plock =\n        g_hash_table_lookup(inode->posix_locks, GUINT_TO_POINTER(lock_owner));\n\n    if (plock) {\n        return plock;\n    }\n\n    plock = malloc(sizeof(struct lo_inode_plock));\n    if (!plock) {\n        *err = ENOMEM;\n        return NULL;\n    }\n\n    /* Open another instance of file which can be used for ofd locks. */\n    sprintf(procname, \"%i\", inode->fd);\n\n    /* TODO: What if file is not writable? */\n    fd = openat(lo->proc_self_fd, procname, O_RDWR);\n    if (fd == -1) {\n        *err = errno;\n        free(plock);\n        return NULL;\n    }\n\n    plock->lock_owner = lock_owner;\n    plock->fd = fd;\n    g_hash_table_insert(inode->posix_locks, GUINT_TO_POINTER(plock->lock_owner),\n                        plock);\n    return plock;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode_plock *lookup_create_plock_ctx(struct lo_data *lo,\n                                                      struct lo_inode *inode,\n                                                      uint64_t lock_owner,\n                                                      pid_t pid, int *err)\n{\n    struct lo_inode_plock *plock;\n    char procname[64];\n    int fd;\n\n    plock =\n        g_hash_table_lookup(inode->posix_locks, GUINT_TO_POINTER(lock_owner));\n\n    if (plock) {\n        return plock;\n    }\n\n    plock = malloc(sizeof(struct lo_inode_plock));\n    if (!plock) {\n        *err = ENOMEM;\n        return NULL;\n    }\n\n    /* Open another instance of file which can be used for ofd locks. */\n    sprintf(procname, \"%i\", inode->fd);\n\n    /* TODO: What if file is not writable? */\n    fd = openat(lo->proc_self_fd, procname, O_RDWR);\n    if (fd == -1) {\n        *err = errno;\n        free(plock);\n        return NULL;\n    }\n\n    plock->lock_owner = lock_owner;\n    plock->fd = fd;\n    g_hash_table_insert(inode->posix_locks, GUINT_TO_POINTER(plock->lock_owner),\n                        plock);\n    return plock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&inode->plock_mutex"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "ino"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_setlk(ino=%\" PRIu64 \", flags=%d)\"\n             \" cmd=%d pid=%d owner=0x%lx sleep=%d l_whence=%d\"\n             \" l_start=0x%lx l_len=0x%lx\\n\"",
            "ino",
            "fi->flags",
            "lock->l_type",
            "lock->l_pid",
            "fi->lock_owner",
            "sleep",
            "lock->l_whence",
            "lock->l_start",
            "lock->l_len"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_setlk(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,\n                     struct flock *lock, int sleep)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    struct lo_inode_plock *plock;\n    int ret, saverr = 0;\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_setlk(ino=%\" PRIu64 \", flags=%d)\"\n             \" cmd=%d pid=%d owner=0x%lx sleep=%d l_whence=%d\"\n             \" l_start=0x%lx l_len=0x%lx\\n\",\n             ino, fi->flags, lock->l_type, lock->l_pid, fi->lock_owner, sleep,\n             lock->l_whence, lock->l_start, lock->l_len);\n\n    if (sleep) {\n        fuse_reply_err(req, EOPNOTSUPP);\n        return;\n    }\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    pthread_mutex_lock(&inode->plock_mutex);\n    plock =\n        lookup_create_plock_ctx(lo, inode, fi->lock_owner, lock->l_pid, &ret);\n\n    if (!plock) {\n        saverr = ret;\n        goto out;\n    }\n\n    /* TODO: Is it alright to modify flock? */\n    lock->l_pid = 0;\n    ret = fcntl(plock->fd, F_OFD_SETLK, lock);\n    if (ret == -1) {\n        saverr = errno;\n    }\n\nout:\n    pthread_mutex_unlock(&inode->plock_mutex);\n    lo_inode_put(lo, &inode);\n\n    fuse_reply_err(req, saverr);\n}"
  },
  {
    "function_name": "lo_getlk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1665-1708",
    "snippet": "static void lo_getlk(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,\n                     struct flock *lock)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    struct lo_inode_plock *plock;\n    int ret, saverr = 0;\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_getlk(ino=%\" PRIu64 \", flags=%d)\"\n             \" owner=0x%lx, l_type=%d l_start=0x%lx\"\n             \" l_len=0x%lx\\n\",\n             ino, fi->flags, fi->lock_owner, lock->l_type, lock->l_start,\n             lock->l_len);\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    pthread_mutex_lock(&inode->plock_mutex);\n    plock =\n        lookup_create_plock_ctx(lo, inode, fi->lock_owner, lock->l_pid, &ret);\n    if (!plock) {\n        saverr = ret;\n        goto out;\n    }\n\n    ret = fcntl(plock->fd, F_OFD_GETLK, lock);\n    if (ret == -1) {\n        saverr = errno;\n    }\n\nout:\n    pthread_mutex_unlock(&inode->plock_mutex);\n    lo_inode_put(lo, &inode);\n\n    if (saverr) {\n        fuse_reply_err(req, saverr);\n    } else {\n        fuse_reply_lock(req, lock);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_lock",
          "args": [
            "req",
            "lock"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "545-561",
          "snippet": "int fuse_reply_lock(fuse_req_t req, const struct flock *lock)\n{\n    struct fuse_lk_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    arg.lk.type = lock->l_type;\n    if (lock->l_type != F_UNLCK) {\n        arg.lk.start = lock->l_start;\n        if (lock->l_len == 0) {\n            arg.lk.end = OFFSET_MAX;\n        } else {\n            arg.lk.end = lock->l_start + lock->l_len - 1;\n        }\n    }\n    arg.lk.pid = lock->l_pid;\n    return send_reply_ok(req, &arg, sizeof(arg));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [
            "#define OFFSET_MAX 0x7fffffffffffffffLL"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\n#define OFFSET_MAX 0x7fffffffffffffffLL\n\nint fuse_reply_lock(fuse_req_t req, const struct flock *lock)\n{\n    struct fuse_lk_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    arg.lk.type = lock->l_type;\n    if (lock->l_type != F_UNLCK) {\n        arg.lk.start = lock->l_start;\n        if (lock->l_len == 0) {\n            arg.lk.end = OFFSET_MAX;\n        } else {\n            arg.lk.end = lock->l_start + lock->l_len - 1;\n        }\n    }\n    arg.lk.pid = lock->l_pid;\n    return send_reply_ok(req, &arg, sizeof(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "saverr"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&inode"
          ],
          "line": 1701
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&inode->plock_mutex"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "plock->fd",
            "F_OFD_GETLK",
            "lock"
          ],
          "line": 1694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_create_plock_ctx",
          "args": [
            "lo",
            "inode",
            "fi->lock_owner",
            "lock->l_pid",
            "&ret"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_create_plock_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1625-1663",
          "snippet": "static struct lo_inode_plock *lookup_create_plock_ctx(struct lo_data *lo,\n                                                      struct lo_inode *inode,\n                                                      uint64_t lock_owner,\n                                                      pid_t pid, int *err)\n{\n    struct lo_inode_plock *plock;\n    char procname[64];\n    int fd;\n\n    plock =\n        g_hash_table_lookup(inode->posix_locks, GUINT_TO_POINTER(lock_owner));\n\n    if (plock) {\n        return plock;\n    }\n\n    plock = malloc(sizeof(struct lo_inode_plock));\n    if (!plock) {\n        *err = ENOMEM;\n        return NULL;\n    }\n\n    /* Open another instance of file which can be used for ofd locks. */\n    sprintf(procname, \"%i\", inode->fd);\n\n    /* TODO: What if file is not writable? */\n    fd = openat(lo->proc_self_fd, procname, O_RDWR);\n    if (fd == -1) {\n        *err = errno;\n        free(plock);\n        return NULL;\n    }\n\n    plock->lock_owner = lock_owner;\n    plock->fd = fd;\n    g_hash_table_insert(inode->posix_locks, GUINT_TO_POINTER(plock->lock_owner),\n                        plock);\n    return plock;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode_plock *lookup_create_plock_ctx(struct lo_data *lo,\n                                                      struct lo_inode *inode,\n                                                      uint64_t lock_owner,\n                                                      pid_t pid, int *err)\n{\n    struct lo_inode_plock *plock;\n    char procname[64];\n    int fd;\n\n    plock =\n        g_hash_table_lookup(inode->posix_locks, GUINT_TO_POINTER(lock_owner));\n\n    if (plock) {\n        return plock;\n    }\n\n    plock = malloc(sizeof(struct lo_inode_plock));\n    if (!plock) {\n        *err = ENOMEM;\n        return NULL;\n    }\n\n    /* Open another instance of file which can be used for ofd locks. */\n    sprintf(procname, \"%i\", inode->fd);\n\n    /* TODO: What if file is not writable? */\n    fd = openat(lo->proc_self_fd, procname, O_RDWR);\n    if (fd == -1) {\n        *err = errno;\n        free(plock);\n        return NULL;\n    }\n\n    plock->lock_owner = lock_owner;\n    plock->fd = fd;\n    g_hash_table_insert(inode->posix_locks, GUINT_TO_POINTER(plock->lock_owner),\n                        plock);\n    return plock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&inode->plock_mutex"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "ino"
          ],
          "line": 1680
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_getlk(ino=%\" PRIu64 \", flags=%d)\"\n             \" owner=0x%lx, l_type=%d l_start=0x%lx\"\n             \" l_len=0x%lx\\n\"",
            "ino",
            "fi->flags",
            "fi->lock_owner",
            "lock->l_type",
            "lock->l_start",
            "lock->l_len"
          ],
          "line": 1673
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1668
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_getlk(fuse_req_t req, fuse_ino_t ino, struct fuse_file_info *fi,\n                     struct flock *lock)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    struct lo_inode_plock *plock;\n    int ret, saverr = 0;\n\n    fuse_log(FUSE_LOG_DEBUG,\n             \"lo_getlk(ino=%\" PRIu64 \", flags=%d)\"\n             \" owner=0x%lx, l_type=%d l_start=0x%lx\"\n             \" l_len=0x%lx\\n\",\n             ino, fi->flags, fi->lock_owner, lock->l_type, lock->l_start,\n             lock->l_len);\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    pthread_mutex_lock(&inode->plock_mutex);\n    plock =\n        lookup_create_plock_ctx(lo, inode, fi->lock_owner, lock->l_pid, &ret);\n    if (!plock) {\n        saverr = ret;\n        goto out;\n    }\n\n    ret = fcntl(plock->fd, F_OFD_GETLK, lock);\n    if (ret == -1) {\n        saverr = errno;\n    }\n\nout:\n    pthread_mutex_unlock(&inode->plock_mutex);\n    lo_inode_put(lo, &inode);\n\n    if (saverr) {\n        fuse_reply_err(req, saverr);\n    } else {\n        fuse_reply_lock(req, lock);\n    }\n}"
  },
  {
    "function_name": "lookup_create_plock_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1625-1663",
    "snippet": "static struct lo_inode_plock *lookup_create_plock_ctx(struct lo_data *lo,\n                                                      struct lo_inode *inode,\n                                                      uint64_t lock_owner,\n                                                      pid_t pid, int *err)\n{\n    struct lo_inode_plock *plock;\n    char procname[64];\n    int fd;\n\n    plock =\n        g_hash_table_lookup(inode->posix_locks, GUINT_TO_POINTER(lock_owner));\n\n    if (plock) {\n        return plock;\n    }\n\n    plock = malloc(sizeof(struct lo_inode_plock));\n    if (!plock) {\n        *err = ENOMEM;\n        return NULL;\n    }\n\n    /* Open another instance of file which can be used for ofd locks. */\n    sprintf(procname, \"%i\", inode->fd);\n\n    /* TODO: What if file is not writable? */\n    fd = openat(lo->proc_self_fd, procname, O_RDWR);\n    if (fd == -1) {\n        *err = errno;\n        free(plock);\n        return NULL;\n    }\n\n    plock->lock_owner = lock_owner;\n    plock->fd = fd;\n    g_hash_table_insert(inode->posix_locks, GUINT_TO_POINTER(plock->lock_owner),\n                        plock);\n    return plock;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_hash_table_insert",
          "args": [
            "inode->posix_locks",
            "GUINT_TO_POINTER(plock->lock_owner)",
            "plock"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUINT_TO_POINTER",
          "args": [
            "plock->lock_owner"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "plock"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "lo->proc_self_fd",
            "procname",
            "O_RDWR"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "procname",
            "\"%i\"",
            "inode->fd"
          ],
          "line": 1648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct lo_inode_plock)"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_hash_table_lookup",
          "args": [
            "inode->posix_locks",
            "GUINT_TO_POINTER(lock_owner)"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "GUINT_TO_POINTER",
          "args": [
            "lock_owner"
          ],
          "line": 1635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode_plock *lookup_create_plock_ctx(struct lo_data *lo,\n                                                      struct lo_inode *inode,\n                                                      uint64_t lock_owner,\n                                                      pid_t pid, int *err)\n{\n    struct lo_inode_plock *plock;\n    char procname[64];\n    int fd;\n\n    plock =\n        g_hash_table_lookup(inode->posix_locks, GUINT_TO_POINTER(lock_owner));\n\n    if (plock) {\n        return plock;\n    }\n\n    plock = malloc(sizeof(struct lo_inode_plock));\n    if (!plock) {\n        *err = ENOMEM;\n        return NULL;\n    }\n\n    /* Open another instance of file which can be used for ofd locks. */\n    sprintf(procname, \"%i\", inode->fd);\n\n    /* TODO: What if file is not writable? */\n    fd = openat(lo->proc_self_fd, procname, O_RDWR);\n    if (fd == -1) {\n        *err = errno;\n        free(plock);\n        return NULL;\n    }\n\n    plock->lock_owner = lock_owner;\n    plock->fd = fd;\n    g_hash_table_insert(inode->posix_locks, GUINT_TO_POINTER(plock->lock_owner),\n                        plock);\n    return plock;\n}"
  },
  {
    "function_name": "lo_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1557-1622",
    "snippet": "static void lo_create(fuse_req_t req, fuse_ino_t parent, const char *name,\n                      mode_t mode, struct fuse_file_info *fi)\n{\n    int fd;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *parent_inode;\n    struct fuse_entry_param e;\n    int err;\n    struct lo_cred old = {};\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_create(parent=%\" PRIu64 \", name=%s)\\n\", parent,\n             name);\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    parent_inode = lo_inode(req, parent);\n    if (!parent_inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    err = lo_change_cred(req, &old);\n    if (err) {\n        goto out;\n    }\n\n    update_open_flags(lo->writeback, lo->allow_direct_io, fi);\n\n    fd = openat(parent_inode->fd, name, (fi->flags | O_CREAT) & ~O_NOFOLLOW,\n                mode);\n    err = fd == -1 ? errno : 0;\n    lo_restore_cred(&old);\n\n    if (!err) {\n        ssize_t fh;\n\n        pthread_mutex_lock(&lo->mutex);\n        fh = lo_add_fd_mapping(req, fd);\n        pthread_mutex_unlock(&lo->mutex);\n        if (fh == -1) {\n            close(fd);\n            err = ENOMEM;\n            goto out;\n        }\n\n        fi->fh = fh;\n        err = lo_do_lookup(req, parent, name, &e);\n    }\n    if (lo->cache == CACHE_NONE) {\n        fi->direct_io = 1;\n    } else if (lo->cache == CACHE_ALWAYS) {\n        fi->keep_cache = 1;\n    }\n\nout:\n    lo_inode_put(lo, &parent_inode);\n\n    if (err) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_create(req, &e, fi);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_create",
          "args": [
            "req",
            "&e",
            "fi"
          ],
          "line": 1620
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "410-422",
          "snippet": "int fuse_reply_create(fuse_req_t req, const struct fuse_entry_param *e,\n                      const struct fuse_file_info *f)\n{\n    char buf[sizeof(struct fuse_entry_out) + sizeof(struct fuse_open_out)];\n    size_t entrysize = sizeof(struct fuse_entry_out);\n    struct fuse_entry_out *earg = (struct fuse_entry_out *)buf;\n    struct fuse_open_out *oarg = (struct fuse_open_out *)(buf + entrysize);\n\n    memset(buf, 0, sizeof(buf));\n    fill_entry(earg, e);\n    fill_open(oarg, f);\n    return send_reply_ok(req, buf, entrysize + sizeof(struct fuse_open_out));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_create(fuse_req_t req, const struct fuse_entry_param *e,\n                      const struct fuse_file_info *f)\n{\n    char buf[sizeof(struct fuse_entry_out) + sizeof(struct fuse_open_out)];\n    size_t entrysize = sizeof(struct fuse_entry_out);\n    struct fuse_entry_out *earg = (struct fuse_entry_out *)buf;\n    struct fuse_open_out *oarg = (struct fuse_open_out *)(buf + entrysize);\n\n    memset(buf, 0, sizeof(buf));\n    fill_entry(earg, e);\n    fill_open(oarg, f);\n    return send_reply_ok(req, buf, entrysize + sizeof(struct fuse_open_out));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "err"
          ],
          "line": 1618
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&parent_inode"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_do_lookup",
          "args": [
            "req",
            "parent",
            "name",
            "&e"
          ],
          "line": 1606
        },
        "resolved": true,
        "details": {
          "function_name": "lo_do_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "758-844",
          "snippet": "static int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,\n                        struct fuse_entry_param *e)\n{\n    int newfd;\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode = NULL;\n    struct lo_inode *dir = lo_inode(req, parent);\n\n    /*\n     * name_to_handle_at() and open_by_handle_at() can reach here with fuse\n     * mount point in guest, but we don't have its inode info in the\n     * ino_map.\n     */\n    if (!dir) {\n        return ENOENT;\n    }\n\n    memset(e, 0, sizeof(*e));\n    e->attr_timeout = lo->timeout;\n    e->entry_timeout = lo->timeout;\n\n    /* Do not allow escaping root directory */\n    if (dir == &lo->root && strcmp(name, \"..\") == 0) {\n        name = \".\";\n    }\n\n    newfd = openat(dir->fd, name, O_PATH | O_NOFOLLOW);\n    if (newfd == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(newfd, \"\", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    inode = lo_find(lo, &e->attr);\n    if (inode) {\n        close(newfd);\n    } else {\n        inode = calloc(1, sizeof(struct lo_inode));\n        if (!inode) {\n            goto out_err;\n        }\n\n        /* cache only filetype */\n        inode->filetype = (e->attr.st_mode & S_IFMT);\n\n        /*\n         * One for the caller and one for nlookup (released in\n         * unref_inode_lolocked())\n         */\n        g_atomic_int_set(&inode->refcount, 2);\n\n        inode->nlookup = 1;\n        inode->fd = newfd;\n        inode->key.ino = e->attr.st_ino;\n        inode->key.dev = e->attr.st_dev;\n        pthread_mutex_init(&inode->plock_mutex, NULL);\n        inode->posix_locks = g_hash_table_new_full(\n            g_direct_hash, g_direct_equal, NULL, posix_locks_value_destroy);\n\n        pthread_mutex_lock(&lo->mutex);\n        inode->fuse_ino = lo_add_inode_mapping(req, inode);\n        g_hash_table_insert(lo->inodes, &inode->key, inode);\n        pthread_mutex_unlock(&lo->mutex);\n    }\n    e->ino = inode->fuse_ino;\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e->ino);\n\n    return 0;\n\nout_err:\n    saverr = errno;\n    if (newfd != -1) {\n        close(newfd);\n    }\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n    return saverr;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,\n                        struct fuse_entry_param *e)\n{\n    int newfd;\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode = NULL;\n    struct lo_inode *dir = lo_inode(req, parent);\n\n    /*\n     * name_to_handle_at() and open_by_handle_at() can reach here with fuse\n     * mount point in guest, but we don't have its inode info in the\n     * ino_map.\n     */\n    if (!dir) {\n        return ENOENT;\n    }\n\n    memset(e, 0, sizeof(*e));\n    e->attr_timeout = lo->timeout;\n    e->entry_timeout = lo->timeout;\n\n    /* Do not allow escaping root directory */\n    if (dir == &lo->root && strcmp(name, \"..\") == 0) {\n        name = \".\";\n    }\n\n    newfd = openat(dir->fd, name, O_PATH | O_NOFOLLOW);\n    if (newfd == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(newfd, \"\", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    inode = lo_find(lo, &e->attr);\n    if (inode) {\n        close(newfd);\n    } else {\n        inode = calloc(1, sizeof(struct lo_inode));\n        if (!inode) {\n            goto out_err;\n        }\n\n        /* cache only filetype */\n        inode->filetype = (e->attr.st_mode & S_IFMT);\n\n        /*\n         * One for the caller and one for nlookup (released in\n         * unref_inode_lolocked())\n         */\n        g_atomic_int_set(&inode->refcount, 2);\n\n        inode->nlookup = 1;\n        inode->fd = newfd;\n        inode->key.ino = e->attr.st_ino;\n        inode->key.dev = e->attr.st_dev;\n        pthread_mutex_init(&inode->plock_mutex, NULL);\n        inode->posix_locks = g_hash_table_new_full(\n            g_direct_hash, g_direct_equal, NULL, posix_locks_value_destroy);\n\n        pthread_mutex_lock(&lo->mutex);\n        inode->fuse_ino = lo_add_inode_mapping(req, inode);\n        g_hash_table_insert(lo->inodes, &inode->key, inode);\n        pthread_mutex_unlock(&lo->mutex);\n    }\n    e->ino = inode->fuse_ino;\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e->ino);\n\n    return 0;\n\nout_err:\n    saverr = errno;\n    if (newfd != -1) {\n        close(newfd);\n    }\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n    return saverr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_add_fd_mapping",
          "args": [
            "req",
            "fd"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "lo_add_fd_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "445-456",
          "snippet": "static ssize_t lo_add_fd_mapping(fuse_req_t req, int fd)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->fd_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->fd = fd;\n    return elem - lo_data(req)->fd_map.elems;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t lo_add_fd_mapping(fuse_req_t req, int fd)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->fd_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->fd = fd;\n    return elem - lo_data(req)->fd_map.elems;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_restore_cred",
          "args": [
            "&old"
          ],
          "line": 1591
        },
        "resolved": true,
        "details": {
          "function_name": "lo_restore_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "917-932",
          "snippet": "static void lo_restore_cred(struct lo_cred *old)\n{\n    int res;\n\n    res = syscall(OURSYS_setresuid, -1, old->euid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"seteuid(%u): %m\\n\", old->euid);\n        exit(1);\n    }\n\n    res = syscall(OURSYS_setresgid, -1, old->egid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"setegid(%u): %m\\n\", old->egid);\n        exit(1);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [
            "#define OURSYS_setresuid SYS_setresuid",
            "#define OURSYS_setresuid SYS_setresuid32",
            "#define OURSYS_setresgid SYS_setresgid",
            "#define OURSYS_setresgid SYS_setresgid32"
          ],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\n#define OURSYS_setresuid SYS_setresuid\n#define OURSYS_setresuid SYS_setresuid32\n#define OURSYS_setresgid SYS_setresgid\n#define OURSYS_setresgid SYS_setresgid32\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_restore_cred(struct lo_cred *old)\n{\n    int res;\n\n    res = syscall(OURSYS_setresuid, -1, old->euid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"seteuid(%u): %m\\n\", old->euid);\n        exit(1);\n    }\n\n    res = syscall(OURSYS_setresgid, -1, old->egid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"setegid(%u): %m\\n\", old->egid);\n        exit(1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "parent_inode->fd",
            "name",
            "(fi->flags | O_CREAT) & ~O_NOFOLLOW",
            "mode"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_open_flags",
          "args": [
            "lo->writeback",
            "lo->allow_direct_io",
            "fi"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "update_open_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1522-1555",
          "snippet": "static void update_open_flags(int writeback, int allow_direct_io,\n                              struct fuse_file_info *fi)\n{\n    /*\n     * With writeback cache, kernel may send read requests even\n     * when userspace opened write-only\n     */\n    if (writeback && (fi->flags & O_ACCMODE) == O_WRONLY) {\n        fi->flags &= ~O_ACCMODE;\n        fi->flags |= O_RDWR;\n    }\n\n    /*\n     * With writeback cache, O_APPEND is handled by the kernel.\n     * This breaks atomicity (since the file may change in the\n     * underlying filesystem, so that the kernel's idea of the\n     * end of the file isn't accurate anymore). In this example,\n     * we just accept that. A more rigorous filesystem may want\n     * to return an error here\n     */\n    if (writeback && (fi->flags & O_APPEND)) {\n        fi->flags &= ~O_APPEND;\n    }\n\n    /*\n     * O_DIRECT in guest should not necessarily mean bypassing page\n     * cache on host as well. Therefore, we discard it by default\n     * ('-o no_allow_direct_io'). If somebody needs that behavior,\n     * the '-o allow_direct_io' option should be set.\n     */\n    if (!allow_direct_io) {\n        fi->flags &= ~O_DIRECT;\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void update_open_flags(int writeback, int allow_direct_io,\n                              struct fuse_file_info *fi)\n{\n    /*\n     * With writeback cache, kernel may send read requests even\n     * when userspace opened write-only\n     */\n    if (writeback && (fi->flags & O_ACCMODE) == O_WRONLY) {\n        fi->flags &= ~O_ACCMODE;\n        fi->flags |= O_RDWR;\n    }\n\n    /*\n     * With writeback cache, O_APPEND is handled by the kernel.\n     * This breaks atomicity (since the file may change in the\n     * underlying filesystem, so that the kernel's idea of the\n     * end of the file isn't accurate anymore). In this example,\n     * we just accept that. A more rigorous filesystem may want\n     * to return an error here\n     */\n    if (writeback && (fi->flags & O_APPEND)) {\n        fi->flags &= ~O_APPEND;\n    }\n\n    /*\n     * O_DIRECT in guest should not necessarily mean bypassing page\n     * cache on host as well. Therefore, we discard it by default\n     * ('-o no_allow_direct_io'). If somebody needs that behavior,\n     * the '-o allow_direct_io' option should be set.\n     */\n    if (!allow_direct_io) {\n        fi->flags &= ~O_DIRECT;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_change_cred",
          "args": [
            "req",
            "&old"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "lo_change_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "893-914",
          "snippet": "static int lo_change_cred(fuse_req_t req, struct lo_cred *old)\n{\n    int res;\n\n    old->euid = geteuid();\n    old->egid = getegid();\n\n    res = syscall(OURSYS_setresgid, -1, fuse_req_ctx(req)->gid, -1);\n    if (res == -1) {\n        return errno;\n    }\n\n    res = syscall(OURSYS_setresuid, -1, fuse_req_ctx(req)->uid, -1);\n    if (res == -1) {\n        int errno_save = errno;\n\n        syscall(OURSYS_setresgid, -1, old->egid, -1);\n        return errno_save;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [
            "#define OURSYS_setresuid SYS_setresuid",
            "#define OURSYS_setresuid SYS_setresuid32",
            "#define OURSYS_setresgid SYS_setresgid",
            "#define OURSYS_setresgid SYS_setresgid32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\n#define OURSYS_setresuid SYS_setresuid\n#define OURSYS_setresuid SYS_setresuid32\n#define OURSYS_setresgid SYS_setresgid\n#define OURSYS_setresgid SYS_setresgid32\n\nstatic int lo_change_cred(fuse_req_t req, struct lo_cred *old)\n{\n    int res;\n\n    old->euid = geteuid();\n    old->egid = getegid();\n\n    res = syscall(OURSYS_setresgid, -1, fuse_req_ctx(req)->gid, -1);\n    if (res == -1) {\n        return errno;\n    }\n\n    res = syscall(OURSYS_setresuid, -1, fuse_req_ctx(req)->uid, -1);\n    if (res == -1) {\n        int errno_save = errno;\n\n        syscall(OURSYS_setresgid, -1, old->egid, -1);\n        return errno_save;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "parent"
          ],
          "line": 1575
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_safe_path_component",
          "args": [
            "name"
          ],
          "line": 1570
        },
        "resolved": true,
        "details": {
          "function_name": "is_safe_path_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "208-215",
          "snippet": "static int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_create(parent=%\" PRIu64 \", name=%s)\\n\"",
            "parent",
            "name"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1561
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_create(fuse_req_t req, fuse_ino_t parent, const char *name,\n                      mode_t mode, struct fuse_file_info *fi)\n{\n    int fd;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *parent_inode;\n    struct fuse_entry_param e;\n    int err;\n    struct lo_cred old = {};\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_create(parent=%\" PRIu64 \", name=%s)\\n\", parent,\n             name);\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    parent_inode = lo_inode(req, parent);\n    if (!parent_inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    err = lo_change_cred(req, &old);\n    if (err) {\n        goto out;\n    }\n\n    update_open_flags(lo->writeback, lo->allow_direct_io, fi);\n\n    fd = openat(parent_inode->fd, name, (fi->flags | O_CREAT) & ~O_NOFOLLOW,\n                mode);\n    err = fd == -1 ? errno : 0;\n    lo_restore_cred(&old);\n\n    if (!err) {\n        ssize_t fh;\n\n        pthread_mutex_lock(&lo->mutex);\n        fh = lo_add_fd_mapping(req, fd);\n        pthread_mutex_unlock(&lo->mutex);\n        if (fh == -1) {\n            close(fd);\n            err = ENOMEM;\n            goto out;\n        }\n\n        fi->fh = fh;\n        err = lo_do_lookup(req, parent, name, &e);\n    }\n    if (lo->cache == CACHE_NONE) {\n        fi->direct_io = 1;\n    } else if (lo->cache == CACHE_ALWAYS) {\n        fi->keep_cache = 1;\n    }\n\nout:\n    lo_inode_put(lo, &parent_inode);\n\n    if (err) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_create(req, &e, fi);\n    }\n}"
  },
  {
    "function_name": "update_open_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1522-1555",
    "snippet": "static void update_open_flags(int writeback, int allow_direct_io,\n                              struct fuse_file_info *fi)\n{\n    /*\n     * With writeback cache, kernel may send read requests even\n     * when userspace opened write-only\n     */\n    if (writeback && (fi->flags & O_ACCMODE) == O_WRONLY) {\n        fi->flags &= ~O_ACCMODE;\n        fi->flags |= O_RDWR;\n    }\n\n    /*\n     * With writeback cache, O_APPEND is handled by the kernel.\n     * This breaks atomicity (since the file may change in the\n     * underlying filesystem, so that the kernel's idea of the\n     * end of the file isn't accurate anymore). In this example,\n     * we just accept that. A more rigorous filesystem may want\n     * to return an error here\n     */\n    if (writeback && (fi->flags & O_APPEND)) {\n        fi->flags &= ~O_APPEND;\n    }\n\n    /*\n     * O_DIRECT in guest should not necessarily mean bypassing page\n     * cache on host as well. Therefore, we discard it by default\n     * ('-o no_allow_direct_io'). If somebody needs that behavior,\n     * the '-o allow_direct_io' option should be set.\n     */\n    if (!allow_direct_io) {\n        fi->flags &= ~O_DIRECT;\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void update_open_flags(int writeback, int allow_direct_io,\n                              struct fuse_file_info *fi)\n{\n    /*\n     * With writeback cache, kernel may send read requests even\n     * when userspace opened write-only\n     */\n    if (writeback && (fi->flags & O_ACCMODE) == O_WRONLY) {\n        fi->flags &= ~O_ACCMODE;\n        fi->flags |= O_RDWR;\n    }\n\n    /*\n     * With writeback cache, O_APPEND is handled by the kernel.\n     * This breaks atomicity (since the file may change in the\n     * underlying filesystem, so that the kernel's idea of the\n     * end of the file isn't accurate anymore). In this example,\n     * we just accept that. A more rigorous filesystem may want\n     * to return an error here\n     */\n    if (writeback && (fi->flags & O_APPEND)) {\n        fi->flags &= ~O_APPEND;\n    }\n\n    /*\n     * O_DIRECT in guest should not necessarily mean bypassing page\n     * cache on host as well. Therefore, we discard it by default\n     * ('-o no_allow_direct_io'). If somebody needs that behavior,\n     * the '-o allow_direct_io' option should be set.\n     */\n    if (!allow_direct_io) {\n        fi->flags &= ~O_DIRECT;\n    }\n}"
  },
  {
    "function_name": "lo_releasedir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1496-1520",
    "snippet": "static void lo_releasedir(fuse_req_t req, fuse_ino_t ino,\n                          struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n    struct lo_dirp *d;\n\n    (void)ino;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->dirp_map, fi->fh);\n    if (!elem) {\n        pthread_mutex_unlock(&lo->mutex);\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    d = elem->dirp;\n    lo_map_remove(&lo->dirp_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    lo_dirp_put(&d); /* paired with lo_opendir() */\n\n    fuse_reply_err(req, 0);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "0"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_dirp_put",
          "args": [
            "&d"
          ],
          "line": 1517
        },
        "resolved": true,
        "details": {
          "function_name": "lo_dirp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1283-1296",
          "snippet": "static void lo_dirp_put(struct lo_dirp **dp)\n{\n    struct lo_dirp *d = *dp;\n\n    if (!d) {\n        return;\n    }\n    *dp = NULL;\n\n    if (g_atomic_int_dec_and_test(&d->refcount)) {\n        closedir(d->dp);\n        free(d);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_dirp_put(struct lo_dirp **dp)\n{\n    struct lo_dirp *d = *dp;\n\n    if (!d) {\n        return;\n    }\n    *dp = NULL;\n\n    if (g_atomic_int_dec_and_test(&d->refcount)) {\n        closedir(d->dp);\n        free(d);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_map_remove",
          "args": [
            "&lo->dirp_map",
            "fi->fh"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "425-442",
          "snippet": "static void lo_map_remove(struct lo_map *map, size_t key)\n{\n    struct lo_map_elem *elem;\n\n    if (key >= map->nelems) {\n        return;\n    }\n\n    elem = &map->elems[key];\n    if (!elem->in_use) {\n        return;\n    }\n\n    elem->in_use = false;\n\n    elem->freelist = map->freelist;\n    map->freelist = key;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_map_remove(struct lo_map *map, size_t key)\n{\n    struct lo_map_elem *elem;\n\n    if (key >= map->nelems) {\n        return;\n    }\n\n    elem = &map->elems[key];\n    if (!elem->in_use) {\n        return;\n    }\n\n    elem->in_use = false;\n\n    elem->freelist = map->freelist;\n    map->freelist = key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_map_get",
          "args": [
            "&lo->dirp_map",
            "fi->fh"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "414-423",
          "snippet": "static struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_releasedir(fuse_req_t req, fuse_ino_t ino,\n                          struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n    struct lo_dirp *d;\n\n    (void)ino;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->dirp_map, fi->fh);\n    if (!elem) {\n        pthread_mutex_unlock(&lo->mutex);\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    d = elem->dirp;\n    lo_map_remove(&lo->dirp_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    lo_dirp_put(&d); /* paired with lo_opendir() */\n\n    fuse_reply_err(req, 0);\n}"
  },
  {
    "function_name": "lo_readdirplus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1490-1494",
    "snippet": "static void lo_readdirplus(fuse_req_t req, fuse_ino_t ino, size_t size,\n                           off_t offset, struct fuse_file_info *fi)\n{\n    lo_do_readdir(req, ino, size, offset, fi, 1);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_do_readdir",
          "args": [
            "req",
            "ino",
            "size",
            "offset",
            "fi",
            "1"
          ],
          "line": 1493
        },
        "resolved": true,
        "details": {
          "function_name": "lo_do_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1373-1482",
          "snippet": "static void lo_do_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                          off_t offset, struct fuse_file_info *fi, int plus)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_dirp *d = NULL;\n    struct lo_inode *dinode;\n    char *buf = NULL;\n    char *p;\n    size_t rem = size;\n    int err = EBADF;\n\n    dinode = lo_inode(req, ino);\n    if (!dinode) {\n        goto error;\n    }\n\n    d = lo_dirp(req, fi);\n    if (!d) {\n        goto error;\n    }\n\n    err = ENOMEM;\n    buf = calloc(1, size);\n    if (!buf) {\n        goto error;\n    }\n    p = buf;\n\n    if (offset != d->offset) {\n        seekdir(d->dp, offset);\n        d->entry = NULL;\n        d->offset = offset;\n    }\n    while (1) {\n        size_t entsize;\n        off_t nextoff;\n        const char *name;\n\n        if (!d->entry) {\n            errno = 0;\n            d->entry = readdir(d->dp);\n            if (!d->entry) {\n                if (errno) { /* Error */\n                    err = errno;\n                    goto error;\n                } else { /* End of stream */\n                    break;\n                }\n            }\n        }\n        nextoff = d->entry->d_off;\n        name = d->entry->d_name;\n\n        fuse_ino_t entry_ino = 0;\n        struct fuse_entry_param e = (struct fuse_entry_param){\n            .attr.st_ino = d->entry->d_ino,\n            .attr.st_mode = d->entry->d_type << 12,\n        };\n\n        /* Hide root's parent directory */\n        if (dinode == &lo->root && strcmp(name, \"..\") == 0) {\n            e.attr.st_ino = lo->root.key.ino;\n            e.attr.st_mode = DT_DIR << 12;\n        }\n\n        if (plus) {\n            if (!is_dot_or_dotdot(name)) {\n                err = lo_do_lookup(req, ino, name, &e);\n                if (err) {\n                    goto error;\n                }\n                entry_ino = e.ino;\n            }\n\n            entsize = fuse_add_direntry_plus(req, p, rem, name, &e, nextoff);\n        } else {\n            entsize = fuse_add_direntry(req, p, rem, name, &e.attr, nextoff);\n        }\n        if (entsize > rem) {\n            if (entry_ino != 0) {\n                lo_forget_one(req, entry_ino, 1);\n            }\n            break;\n        }\n\n        p += entsize;\n        rem -= entsize;\n\n        d->entry = NULL;\n        d->offset = nextoff;\n    }\n\n    err = 0;\nerror:\n    lo_dirp_put(&d);\n    lo_inode_put(lo, &dinode);\n\n    /*\n     * If there's an error, we can only signal it if we haven't stored\n     * any entries yet - otherwise we'd end up with wrong lookup\n     * counts for the entries that are already in the buffer. So we\n     * return what we've collected until that point.\n     */\n    if (err && rem == size) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_buf(req, buf, size - rem);\n    }\n    free(buf);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_do_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                          off_t offset, struct fuse_file_info *fi, int plus)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_dirp *d = NULL;\n    struct lo_inode *dinode;\n    char *buf = NULL;\n    char *p;\n    size_t rem = size;\n    int err = EBADF;\n\n    dinode = lo_inode(req, ino);\n    if (!dinode) {\n        goto error;\n    }\n\n    d = lo_dirp(req, fi);\n    if (!d) {\n        goto error;\n    }\n\n    err = ENOMEM;\n    buf = calloc(1, size);\n    if (!buf) {\n        goto error;\n    }\n    p = buf;\n\n    if (offset != d->offset) {\n        seekdir(d->dp, offset);\n        d->entry = NULL;\n        d->offset = offset;\n    }\n    while (1) {\n        size_t entsize;\n        off_t nextoff;\n        const char *name;\n\n        if (!d->entry) {\n            errno = 0;\n            d->entry = readdir(d->dp);\n            if (!d->entry) {\n                if (errno) { /* Error */\n                    err = errno;\n                    goto error;\n                } else { /* End of stream */\n                    break;\n                }\n            }\n        }\n        nextoff = d->entry->d_off;\n        name = d->entry->d_name;\n\n        fuse_ino_t entry_ino = 0;\n        struct fuse_entry_param e = (struct fuse_entry_param){\n            .attr.st_ino = d->entry->d_ino,\n            .attr.st_mode = d->entry->d_type << 12,\n        };\n\n        /* Hide root's parent directory */\n        if (dinode == &lo->root && strcmp(name, \"..\") == 0) {\n            e.attr.st_ino = lo->root.key.ino;\n            e.attr.st_mode = DT_DIR << 12;\n        }\n\n        if (plus) {\n            if (!is_dot_or_dotdot(name)) {\n                err = lo_do_lookup(req, ino, name, &e);\n                if (err) {\n                    goto error;\n                }\n                entry_ino = e.ino;\n            }\n\n            entsize = fuse_add_direntry_plus(req, p, rem, name, &e, nextoff);\n        } else {\n            entsize = fuse_add_direntry(req, p, rem, name, &e.attr, nextoff);\n        }\n        if (entsize > rem) {\n            if (entry_ino != 0) {\n                lo_forget_one(req, entry_ino, 1);\n            }\n            break;\n        }\n\n        p += entsize;\n        rem -= entsize;\n\n        d->entry = NULL;\n        d->offset = nextoff;\n    }\n\n    err = 0;\nerror:\n    lo_dirp_put(&d);\n    lo_inode_put(lo, &dinode);\n\n    /*\n     * If there's an error, we can only signal it if we haven't stored\n     * any entries yet - otherwise we'd end up with wrong lookup\n     * counts for the entries that are already in the buffer. So we\n     * return what we've collected until that point.\n     */\n    if (err && rem == size) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_buf(req, buf, size - rem);\n    }\n    free(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_readdirplus(fuse_req_t req, fuse_ino_t ino, size_t size,\n                           off_t offset, struct fuse_file_info *fi)\n{\n    lo_do_readdir(req, ino, size, offset, fi, 1);\n}"
  },
  {
    "function_name": "lo_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1484-1488",
    "snippet": "static void lo_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                       off_t offset, struct fuse_file_info *fi)\n{\n    lo_do_readdir(req, ino, size, offset, fi, 0);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_do_readdir",
          "args": [
            "req",
            "ino",
            "size",
            "offset",
            "fi",
            "0"
          ],
          "line": 1487
        },
        "resolved": true,
        "details": {
          "function_name": "lo_do_readdir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1373-1482",
          "snippet": "static void lo_do_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                          off_t offset, struct fuse_file_info *fi, int plus)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_dirp *d = NULL;\n    struct lo_inode *dinode;\n    char *buf = NULL;\n    char *p;\n    size_t rem = size;\n    int err = EBADF;\n\n    dinode = lo_inode(req, ino);\n    if (!dinode) {\n        goto error;\n    }\n\n    d = lo_dirp(req, fi);\n    if (!d) {\n        goto error;\n    }\n\n    err = ENOMEM;\n    buf = calloc(1, size);\n    if (!buf) {\n        goto error;\n    }\n    p = buf;\n\n    if (offset != d->offset) {\n        seekdir(d->dp, offset);\n        d->entry = NULL;\n        d->offset = offset;\n    }\n    while (1) {\n        size_t entsize;\n        off_t nextoff;\n        const char *name;\n\n        if (!d->entry) {\n            errno = 0;\n            d->entry = readdir(d->dp);\n            if (!d->entry) {\n                if (errno) { /* Error */\n                    err = errno;\n                    goto error;\n                } else { /* End of stream */\n                    break;\n                }\n            }\n        }\n        nextoff = d->entry->d_off;\n        name = d->entry->d_name;\n\n        fuse_ino_t entry_ino = 0;\n        struct fuse_entry_param e = (struct fuse_entry_param){\n            .attr.st_ino = d->entry->d_ino,\n            .attr.st_mode = d->entry->d_type << 12,\n        };\n\n        /* Hide root's parent directory */\n        if (dinode == &lo->root && strcmp(name, \"..\") == 0) {\n            e.attr.st_ino = lo->root.key.ino;\n            e.attr.st_mode = DT_DIR << 12;\n        }\n\n        if (plus) {\n            if (!is_dot_or_dotdot(name)) {\n                err = lo_do_lookup(req, ino, name, &e);\n                if (err) {\n                    goto error;\n                }\n                entry_ino = e.ino;\n            }\n\n            entsize = fuse_add_direntry_plus(req, p, rem, name, &e, nextoff);\n        } else {\n            entsize = fuse_add_direntry(req, p, rem, name, &e.attr, nextoff);\n        }\n        if (entsize > rem) {\n            if (entry_ino != 0) {\n                lo_forget_one(req, entry_ino, 1);\n            }\n            break;\n        }\n\n        p += entsize;\n        rem -= entsize;\n\n        d->entry = NULL;\n        d->offset = nextoff;\n    }\n\n    err = 0;\nerror:\n    lo_dirp_put(&d);\n    lo_inode_put(lo, &dinode);\n\n    /*\n     * If there's an error, we can only signal it if we haven't stored\n     * any entries yet - otherwise we'd end up with wrong lookup\n     * counts for the entries that are already in the buffer. So we\n     * return what we've collected until that point.\n     */\n    if (err && rem == size) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_buf(req, buf, size - rem);\n    }\n    free(buf);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_do_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                          off_t offset, struct fuse_file_info *fi, int plus)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_dirp *d = NULL;\n    struct lo_inode *dinode;\n    char *buf = NULL;\n    char *p;\n    size_t rem = size;\n    int err = EBADF;\n\n    dinode = lo_inode(req, ino);\n    if (!dinode) {\n        goto error;\n    }\n\n    d = lo_dirp(req, fi);\n    if (!d) {\n        goto error;\n    }\n\n    err = ENOMEM;\n    buf = calloc(1, size);\n    if (!buf) {\n        goto error;\n    }\n    p = buf;\n\n    if (offset != d->offset) {\n        seekdir(d->dp, offset);\n        d->entry = NULL;\n        d->offset = offset;\n    }\n    while (1) {\n        size_t entsize;\n        off_t nextoff;\n        const char *name;\n\n        if (!d->entry) {\n            errno = 0;\n            d->entry = readdir(d->dp);\n            if (!d->entry) {\n                if (errno) { /* Error */\n                    err = errno;\n                    goto error;\n                } else { /* End of stream */\n                    break;\n                }\n            }\n        }\n        nextoff = d->entry->d_off;\n        name = d->entry->d_name;\n\n        fuse_ino_t entry_ino = 0;\n        struct fuse_entry_param e = (struct fuse_entry_param){\n            .attr.st_ino = d->entry->d_ino,\n            .attr.st_mode = d->entry->d_type << 12,\n        };\n\n        /* Hide root's parent directory */\n        if (dinode == &lo->root && strcmp(name, \"..\") == 0) {\n            e.attr.st_ino = lo->root.key.ino;\n            e.attr.st_mode = DT_DIR << 12;\n        }\n\n        if (plus) {\n            if (!is_dot_or_dotdot(name)) {\n                err = lo_do_lookup(req, ino, name, &e);\n                if (err) {\n                    goto error;\n                }\n                entry_ino = e.ino;\n            }\n\n            entsize = fuse_add_direntry_plus(req, p, rem, name, &e, nextoff);\n        } else {\n            entsize = fuse_add_direntry(req, p, rem, name, &e.attr, nextoff);\n        }\n        if (entsize > rem) {\n            if (entry_ino != 0) {\n                lo_forget_one(req, entry_ino, 1);\n            }\n            break;\n        }\n\n        p += entsize;\n        rem -= entsize;\n\n        d->entry = NULL;\n        d->offset = nextoff;\n    }\n\n    err = 0;\nerror:\n    lo_dirp_put(&d);\n    lo_inode_put(lo, &dinode);\n\n    /*\n     * If there's an error, we can only signal it if we haven't stored\n     * any entries yet - otherwise we'd end up with wrong lookup\n     * counts for the entries that are already in the buffer. So we\n     * return what we've collected until that point.\n     */\n    if (err && rem == size) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_buf(req, buf, size - rem);\n    }\n    free(buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                       off_t offset, struct fuse_file_info *fi)\n{\n    lo_do_readdir(req, ino, size, offset, fi, 0);\n}"
  },
  {
    "function_name": "lo_do_readdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1373-1482",
    "snippet": "static void lo_do_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                          off_t offset, struct fuse_file_info *fi, int plus)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_dirp *d = NULL;\n    struct lo_inode *dinode;\n    char *buf = NULL;\n    char *p;\n    size_t rem = size;\n    int err = EBADF;\n\n    dinode = lo_inode(req, ino);\n    if (!dinode) {\n        goto error;\n    }\n\n    d = lo_dirp(req, fi);\n    if (!d) {\n        goto error;\n    }\n\n    err = ENOMEM;\n    buf = calloc(1, size);\n    if (!buf) {\n        goto error;\n    }\n    p = buf;\n\n    if (offset != d->offset) {\n        seekdir(d->dp, offset);\n        d->entry = NULL;\n        d->offset = offset;\n    }\n    while (1) {\n        size_t entsize;\n        off_t nextoff;\n        const char *name;\n\n        if (!d->entry) {\n            errno = 0;\n            d->entry = readdir(d->dp);\n            if (!d->entry) {\n                if (errno) { /* Error */\n                    err = errno;\n                    goto error;\n                } else { /* End of stream */\n                    break;\n                }\n            }\n        }\n        nextoff = d->entry->d_off;\n        name = d->entry->d_name;\n\n        fuse_ino_t entry_ino = 0;\n        struct fuse_entry_param e = (struct fuse_entry_param){\n            .attr.st_ino = d->entry->d_ino,\n            .attr.st_mode = d->entry->d_type << 12,\n        };\n\n        /* Hide root's parent directory */\n        if (dinode == &lo->root && strcmp(name, \"..\") == 0) {\n            e.attr.st_ino = lo->root.key.ino;\n            e.attr.st_mode = DT_DIR << 12;\n        }\n\n        if (plus) {\n            if (!is_dot_or_dotdot(name)) {\n                err = lo_do_lookup(req, ino, name, &e);\n                if (err) {\n                    goto error;\n                }\n                entry_ino = e.ino;\n            }\n\n            entsize = fuse_add_direntry_plus(req, p, rem, name, &e, nextoff);\n        } else {\n            entsize = fuse_add_direntry(req, p, rem, name, &e.attr, nextoff);\n        }\n        if (entsize > rem) {\n            if (entry_ino != 0) {\n                lo_forget_one(req, entry_ino, 1);\n            }\n            break;\n        }\n\n        p += entsize;\n        rem -= entsize;\n\n        d->entry = NULL;\n        d->offset = nextoff;\n    }\n\n    err = 0;\nerror:\n    lo_dirp_put(&d);\n    lo_inode_put(lo, &dinode);\n\n    /*\n     * If there's an error, we can only signal it if we haven't stored\n     * any entries yet - otherwise we'd end up with wrong lookup\n     * counts for the entries that are already in the buffer. So we\n     * return what we've collected until that point.\n     */\n    if (err && rem == size) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_buf(req, buf, size - rem);\n    }\n    free(buf);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "buf"
          ],
          "line": 1481
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_buf",
          "args": [
            "req",
            "buf",
            "size - rem"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "462-465",
          "snippet": "int fuse_reply_buf(fuse_req_t req, const char *buf, size_t size)\n{\n    return send_reply_ok(req, buf, size);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_buf(fuse_req_t req, const char *buf, size_t size)\n{\n    return send_reply_ok(req, buf, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "err"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&dinode"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_dirp_put",
          "args": [
            "&d"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "lo_dirp_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1283-1296",
          "snippet": "static void lo_dirp_put(struct lo_dirp **dp)\n{\n    struct lo_dirp *d = *dp;\n\n    if (!d) {\n        return;\n    }\n    *dp = NULL;\n\n    if (g_atomic_int_dec_and_test(&d->refcount)) {\n        closedir(d->dp);\n        free(d);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_dirp_put(struct lo_dirp **dp)\n{\n    struct lo_dirp *d = *dp;\n\n    if (!d) {\n        return;\n    }\n    *dp = NULL;\n\n    if (g_atomic_int_dec_and_test(&d->refcount)) {\n        closedir(d->dp);\n        free(d);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_forget_one",
          "args": [
            "req",
            "entry_ino",
            "1"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "lo_forget_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1222-1238",
          "snippet": "static void lo_forget_one(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        return;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  forget %lli %lli -%lli\\n\",\n             (unsigned long long)ino, (unsigned long long)inode->nlookup,\n             (unsigned long long)nlookup);\n\n    unref_inode_lolocked(lo, inode, nlookup);\n    lo_inode_put(lo, &inode);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_forget_one(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        return;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  forget %lli %lli -%lli\\n\",\n             (unsigned long long)ino, (unsigned long long)inode->nlookup,\n             (unsigned long long)nlookup);\n\n    unref_inode_lolocked(lo, inode, nlookup);\n    lo_inode_put(lo, &inode);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_add_direntry",
          "args": [
            "req",
            "p",
            "rem",
            "name",
            "&e.attr",
            "nextoff"
          ],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_add_direntry_plus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "350-381",
          "snippet": "size_t fuse_add_direntry_plus(fuse_req_t req, char *buf, size_t bufsize,\n                              const char *name,\n                              const struct fuse_entry_param *e, off_t off)\n{\n    (void)req;\n    size_t namelen;\n    size_t entlen;\n    size_t entlen_padded;\n\n    namelen = strlen(name);\n    entlen = FUSE_NAME_OFFSET_DIRENTPLUS + namelen;\n    entlen_padded = FUSE_DIRENT_ALIGN(entlen);\n    if ((buf == NULL) || (entlen_padded > bufsize)) {\n        return entlen_padded;\n    }\n\n    struct fuse_direntplus *dp = (struct fuse_direntplus *)buf;\n    memset(&dp->entry_out, 0, sizeof(dp->entry_out));\n    fill_entry(&dp->entry_out, e);\n\n    struct fuse_dirent *dirent = &dp->dirent;\n    *dirent = (struct fuse_dirent){\n        .ino = e->attr.st_ino,\n        .off = off,\n        .namelen = namelen,\n        .type = (e->attr.st_mode & S_IFMT) >> 12,\n    };\n    memcpy(dirent->name, name, namelen);\n    memset(dirent->name + namelen, 0, entlen_padded - entlen);\n\n    return entlen_padded;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nsize_t fuse_add_direntry_plus(fuse_req_t req, char *buf, size_t bufsize,\n                              const char *name,\n                              const struct fuse_entry_param *e, off_t off)\n{\n    (void)req;\n    size_t namelen;\n    size_t entlen;\n    size_t entlen_padded;\n\n    namelen = strlen(name);\n    entlen = FUSE_NAME_OFFSET_DIRENTPLUS + namelen;\n    entlen_padded = FUSE_DIRENT_ALIGN(entlen);\n    if ((buf == NULL) || (entlen_padded > bufsize)) {\n        return entlen_padded;\n    }\n\n    struct fuse_direntplus *dp = (struct fuse_direntplus *)buf;\n    memset(&dp->entry_out, 0, sizeof(dp->entry_out));\n    fill_entry(&dp->entry_out, e);\n\n    struct fuse_dirent *dirent = &dp->dirent;\n    *dirent = (struct fuse_dirent){\n        .ino = e->attr.st_ino,\n        .off = off,\n        .namelen = namelen,\n        .type = (e->attr.st_mode & S_IFMT) >> 12,\n    };\n    memcpy(dirent->name, name, namelen);\n    memset(dirent->name + namelen, 0, entlen_padded - entlen);\n\n    return entlen_padded;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_do_lookup",
          "args": [
            "req",
            "ino",
            "name",
            "&e"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "lo_do_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "758-844",
          "snippet": "static int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,\n                        struct fuse_entry_param *e)\n{\n    int newfd;\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode = NULL;\n    struct lo_inode *dir = lo_inode(req, parent);\n\n    /*\n     * name_to_handle_at() and open_by_handle_at() can reach here with fuse\n     * mount point in guest, but we don't have its inode info in the\n     * ino_map.\n     */\n    if (!dir) {\n        return ENOENT;\n    }\n\n    memset(e, 0, sizeof(*e));\n    e->attr_timeout = lo->timeout;\n    e->entry_timeout = lo->timeout;\n\n    /* Do not allow escaping root directory */\n    if (dir == &lo->root && strcmp(name, \"..\") == 0) {\n        name = \".\";\n    }\n\n    newfd = openat(dir->fd, name, O_PATH | O_NOFOLLOW);\n    if (newfd == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(newfd, \"\", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    inode = lo_find(lo, &e->attr);\n    if (inode) {\n        close(newfd);\n    } else {\n        inode = calloc(1, sizeof(struct lo_inode));\n        if (!inode) {\n            goto out_err;\n        }\n\n        /* cache only filetype */\n        inode->filetype = (e->attr.st_mode & S_IFMT);\n\n        /*\n         * One for the caller and one for nlookup (released in\n         * unref_inode_lolocked())\n         */\n        g_atomic_int_set(&inode->refcount, 2);\n\n        inode->nlookup = 1;\n        inode->fd = newfd;\n        inode->key.ino = e->attr.st_ino;\n        inode->key.dev = e->attr.st_dev;\n        pthread_mutex_init(&inode->plock_mutex, NULL);\n        inode->posix_locks = g_hash_table_new_full(\n            g_direct_hash, g_direct_equal, NULL, posix_locks_value_destroy);\n\n        pthread_mutex_lock(&lo->mutex);\n        inode->fuse_ino = lo_add_inode_mapping(req, inode);\n        g_hash_table_insert(lo->inodes, &inode->key, inode);\n        pthread_mutex_unlock(&lo->mutex);\n    }\n    e->ino = inode->fuse_ino;\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e->ino);\n\n    return 0;\n\nout_err:\n    saverr = errno;\n    if (newfd != -1) {\n        close(newfd);\n    }\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n    return saverr;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,\n                        struct fuse_entry_param *e)\n{\n    int newfd;\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode = NULL;\n    struct lo_inode *dir = lo_inode(req, parent);\n\n    /*\n     * name_to_handle_at() and open_by_handle_at() can reach here with fuse\n     * mount point in guest, but we don't have its inode info in the\n     * ino_map.\n     */\n    if (!dir) {\n        return ENOENT;\n    }\n\n    memset(e, 0, sizeof(*e));\n    e->attr_timeout = lo->timeout;\n    e->entry_timeout = lo->timeout;\n\n    /* Do not allow escaping root directory */\n    if (dir == &lo->root && strcmp(name, \"..\") == 0) {\n        name = \".\";\n    }\n\n    newfd = openat(dir->fd, name, O_PATH | O_NOFOLLOW);\n    if (newfd == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(newfd, \"\", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    inode = lo_find(lo, &e->attr);\n    if (inode) {\n        close(newfd);\n    } else {\n        inode = calloc(1, sizeof(struct lo_inode));\n        if (!inode) {\n            goto out_err;\n        }\n\n        /* cache only filetype */\n        inode->filetype = (e->attr.st_mode & S_IFMT);\n\n        /*\n         * One for the caller and one for nlookup (released in\n         * unref_inode_lolocked())\n         */\n        g_atomic_int_set(&inode->refcount, 2);\n\n        inode->nlookup = 1;\n        inode->fd = newfd;\n        inode->key.ino = e->attr.st_ino;\n        inode->key.dev = e->attr.st_dev;\n        pthread_mutex_init(&inode->plock_mutex, NULL);\n        inode->posix_locks = g_hash_table_new_full(\n            g_direct_hash, g_direct_equal, NULL, posix_locks_value_destroy);\n\n        pthread_mutex_lock(&lo->mutex);\n        inode->fuse_ino = lo_add_inode_mapping(req, inode);\n        g_hash_table_insert(lo->inodes, &inode->key, inode);\n        pthread_mutex_unlock(&lo->mutex);\n    }\n    e->ino = inode->fuse_ino;\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e->ino);\n\n    return 0;\n\nout_err:\n    saverr = errno;\n    if (newfd != -1) {\n        close(newfd);\n    }\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n    return saverr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_dot_or_dotdot",
          "args": [
            "name"
          ],
          "line": 1439
        },
        "resolved": true,
        "details": {
          "function_name": "is_dot_or_dotdot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "201-205",
          "snippet": "static int is_dot_or_dotdot(const char *name)\n{\n    return name[0] == '.' &&\n           (name[1] == '\\0' || (name[1] == '.' && name[2] == '\\0'));\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int is_dot_or_dotdot(const char *name)\n{\n    return name[0] == '.' &&\n           (name[1] == '\\0' || (name[1] == '.' && name[2] == '\\0'));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"..\""
          ],
          "line": 1433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "d->dp"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "seekdir",
          "args": [
            "d->dp",
            "offset"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "size"
          ],
          "line": 1395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_dirp",
          "args": [
            "req",
            "fi"
          ],
          "line": 1389
        },
        "resolved": true,
        "details": {
          "function_name": "lo_dirp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1299-1315",
          "snippet": "static struct lo_dirp *lo_dirp(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->dirp_map, fi->fh);\n    if (elem) {\n        g_atomic_int_inc(&elem->dirp->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->dirp;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_dirp *lo_dirp(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->dirp_map, fi->fh);\n    if (elem) {\n        g_atomic_int_inc(&elem->dirp->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->dirp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "ino"
          ],
          "line": 1384
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_do_readdir(fuse_req_t req, fuse_ino_t ino, size_t size,\n                          off_t offset, struct fuse_file_info *fi, int plus)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_dirp *d = NULL;\n    struct lo_inode *dinode;\n    char *buf = NULL;\n    char *p;\n    size_t rem = size;\n    int err = EBADF;\n\n    dinode = lo_inode(req, ino);\n    if (!dinode) {\n        goto error;\n    }\n\n    d = lo_dirp(req, fi);\n    if (!d) {\n        goto error;\n    }\n\n    err = ENOMEM;\n    buf = calloc(1, size);\n    if (!buf) {\n        goto error;\n    }\n    p = buf;\n\n    if (offset != d->offset) {\n        seekdir(d->dp, offset);\n        d->entry = NULL;\n        d->offset = offset;\n    }\n    while (1) {\n        size_t entsize;\n        off_t nextoff;\n        const char *name;\n\n        if (!d->entry) {\n            errno = 0;\n            d->entry = readdir(d->dp);\n            if (!d->entry) {\n                if (errno) { /* Error */\n                    err = errno;\n                    goto error;\n                } else { /* End of stream */\n                    break;\n                }\n            }\n        }\n        nextoff = d->entry->d_off;\n        name = d->entry->d_name;\n\n        fuse_ino_t entry_ino = 0;\n        struct fuse_entry_param e = (struct fuse_entry_param){\n            .attr.st_ino = d->entry->d_ino,\n            .attr.st_mode = d->entry->d_type << 12,\n        };\n\n        /* Hide root's parent directory */\n        if (dinode == &lo->root && strcmp(name, \"..\") == 0) {\n            e.attr.st_ino = lo->root.key.ino;\n            e.attr.st_mode = DT_DIR << 12;\n        }\n\n        if (plus) {\n            if (!is_dot_or_dotdot(name)) {\n                err = lo_do_lookup(req, ino, name, &e);\n                if (err) {\n                    goto error;\n                }\n                entry_ino = e.ino;\n            }\n\n            entsize = fuse_add_direntry_plus(req, p, rem, name, &e, nextoff);\n        } else {\n            entsize = fuse_add_direntry(req, p, rem, name, &e.attr, nextoff);\n        }\n        if (entsize > rem) {\n            if (entry_ino != 0) {\n                lo_forget_one(req, entry_ino, 1);\n            }\n            break;\n        }\n\n        p += entsize;\n        rem -= entsize;\n\n        d->entry = NULL;\n        d->offset = nextoff;\n    }\n\n    err = 0;\nerror:\n    lo_dirp_put(&d);\n    lo_inode_put(lo, &dinode);\n\n    /*\n     * If there's an error, we can only signal it if we haven't stored\n     * any entries yet - otherwise we'd end up with wrong lookup\n     * counts for the entries that are already in the buffer. So we\n     * return what we've collected until that point.\n     */\n    if (err && rem == size) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_buf(req, buf, size - rem);\n    }\n    free(buf);\n}"
  },
  {
    "function_name": "lo_opendir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1317-1371",
    "snippet": "static void lo_opendir(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    int error = ENOMEM;\n    struct lo_data *lo = lo_data(req);\n    struct lo_dirp *d;\n    int fd;\n    ssize_t fh;\n\n    d = calloc(1, sizeof(struct lo_dirp));\n    if (d == NULL) {\n        goto out_err;\n    }\n\n    fd = openat(lo_fd(req, ino), \".\", O_RDONLY);\n    if (fd == -1) {\n        goto out_errno;\n    }\n\n    d->dp = fdopendir(fd);\n    if (d->dp == NULL) {\n        goto out_errno;\n    }\n\n    d->offset = 0;\n    d->entry = NULL;\n\n    g_atomic_int_set(&d->refcount, 1); /* paired with lo_releasedir() */\n    pthread_mutex_lock(&lo->mutex);\n    fh = lo_add_dirp_mapping(req, d);\n    pthread_mutex_unlock(&lo->mutex);\n    if (fh == -1) {\n        goto out_err;\n    }\n\n    fi->fh = fh;\n    if (lo->cache == CACHE_ALWAYS) {\n        fi->cache_readdir = 1;\n    }\n    fuse_reply_open(req, fi);\n    return;\n\nout_errno:\n    error = errno;\nout_err:\n    if (d) {\n        if (d->dp) {\n            closedir(d->dp);\n        } else if (fd != -1) {\n            close(fd);\n        }\n        free(d);\n    }\n    fuse_reply_err(req, error);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "error"
          ],
          "line": 1370
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "d"
          ],
          "line": 1368
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d->dp"
          ],
          "line": 1364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_reply_open",
          "args": [
            "req",
            "fi"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "443-450",
          "snippet": "int fuse_reply_open(fuse_req_t req, const struct fuse_file_info *f)\n{\n    struct fuse_open_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    fill_open(&arg, f);\n    return send_reply_ok(req, &arg, sizeof(arg));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_open(fuse_req_t req, const struct fuse_file_info *f)\n{\n    struct fuse_open_out arg;\n\n    memset(&arg, 0, sizeof(arg));\n    fill_open(&arg, f);\n    return send_reply_ok(req, &arg, sizeof(arg));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_add_dirp_mapping",
          "args": [
            "req",
            "d"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "lo_add_dirp_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "459-470",
          "snippet": "static ssize_t lo_add_dirp_mapping(fuse_req_t req, struct lo_dirp *dirp)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->dirp_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->dirp = dirp;\n    return elem - lo_data(req)->dirp_map.elems;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t lo_add_dirp_mapping(fuse_req_t req, struct lo_dirp *dirp)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->dirp_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->dirp = dirp;\n    return elem - lo_data(req)->dirp_map.elems;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_set",
          "args": [
            "&d->refcount",
            "1"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdopendir",
          "args": [
            "fd"
          ],
          "line": 1336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "lo_fd(req, ino)",
            "\".\"",
            "O_RDONLY"
          ],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fd",
          "args": [
            "req",
            "ino"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "527-539",
          "snippet": "static int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(struct lo_dirp)"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1321
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_opendir(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    int error = ENOMEM;\n    struct lo_data *lo = lo_data(req);\n    struct lo_dirp *d;\n    int fd;\n    ssize_t fh;\n\n    d = calloc(1, sizeof(struct lo_dirp));\n    if (d == NULL) {\n        goto out_err;\n    }\n\n    fd = openat(lo_fd(req, ino), \".\", O_RDONLY);\n    if (fd == -1) {\n        goto out_errno;\n    }\n\n    d->dp = fdopendir(fd);\n    if (d->dp == NULL) {\n        goto out_errno;\n    }\n\n    d->offset = 0;\n    d->entry = NULL;\n\n    g_atomic_int_set(&d->refcount, 1); /* paired with lo_releasedir() */\n    pthread_mutex_lock(&lo->mutex);\n    fh = lo_add_dirp_mapping(req, d);\n    pthread_mutex_unlock(&lo->mutex);\n    if (fh == -1) {\n        goto out_err;\n    }\n\n    fi->fh = fh;\n    if (lo->cache == CACHE_ALWAYS) {\n        fi->cache_readdir = 1;\n    }\n    fuse_reply_open(req, fi);\n    return;\n\nout_errno:\n    error = errno;\nout_err:\n    if (d) {\n        if (d->dp) {\n            closedir(d->dp);\n        } else if (fd != -1) {\n            close(fd);\n        }\n        free(d);\n    }\n    fuse_reply_err(req, error);\n}"
  },
  {
    "function_name": "lo_dirp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1299-1315",
    "snippet": "static struct lo_dirp *lo_dirp(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->dirp_map, fi->fh);\n    if (elem) {\n        g_atomic_int_inc(&elem->dirp->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->dirp;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_inc",
          "args": [
            "&elem->dirp->refcount"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_map_get",
          "args": [
            "&lo->dirp_map",
            "fi->fh"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "414-423",
          "snippet": "static struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_dirp *lo_dirp(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->dirp_map, fi->fh);\n    if (elem) {\n        g_atomic_int_inc(&elem->dirp->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->dirp;\n}"
  },
  {
    "function_name": "lo_dirp_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1283-1296",
    "snippet": "static void lo_dirp_put(struct lo_dirp **dp)\n{\n    struct lo_dirp *d = *dp;\n\n    if (!d) {\n        return;\n    }\n    *dp = NULL;\n\n    if (g_atomic_int_dec_and_test(&d->refcount)) {\n        closedir(d->dp);\n        free(d);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "d"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "d->dp"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_dec_and_test",
          "args": [
            "&d->refcount"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_dirp_put(struct lo_dirp **dp)\n{\n    struct lo_dirp *d = *dp;\n\n    if (!d) {\n        return;\n    }\n    *dp = NULL;\n\n    if (g_atomic_int_dec_and_test(&d->refcount)) {\n        closedir(d->dp);\n        free(d);\n    }\n}"
  },
  {
    "function_name": "lo_readlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1257-1274",
    "snippet": "static void lo_readlink(fuse_req_t req, fuse_ino_t ino)\n{\n    char buf[PATH_MAX + 1];\n    int res;\n\n    res = readlinkat(lo_fd(req, ino), \"\", buf, sizeof(buf));\n    if (res == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    if (res == sizeof(buf)) {\n        return (void)fuse_reply_err(req, ENAMETOOLONG);\n    }\n\n    buf[res] = '\\0';\n\n    fuse_reply_readlink(req, buf);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_readlink",
          "args": [
            "req",
            "buf"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_readlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "438-441",
          "snippet": "int fuse_reply_readlink(fuse_req_t req, const char *linkname)\n{\n    return send_reply_ok(req, linkname, strlen(linkname));\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_readlink(fuse_req_t req, const char *linkname)\n{\n    return send_reply_ok(req, linkname, strlen(linkname));\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "ENAMETOOLONG"
          ],
          "line": 1268
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "readlinkat",
          "args": [
            "lo_fd(req, ino)",
            "\"\"",
            "buf",
            "sizeof(buf)"
          ],
          "line": 1262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fd",
          "args": [
            "req",
            "ino"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "527-539",
          "snippet": "static int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_readlink(fuse_req_t req, fuse_ino_t ino)\n{\n    char buf[PATH_MAX + 1];\n    int res;\n\n    res = readlinkat(lo_fd(req, ino), \"\", buf, sizeof(buf));\n    if (res == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    if (res == sizeof(buf)) {\n        return (void)fuse_reply_err(req, ENAMETOOLONG);\n    }\n\n    buf[res] = '\\0';\n\n    fuse_reply_readlink(req, buf);\n}"
  },
  {
    "function_name": "lo_forget_multi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1246-1255",
    "snippet": "static void lo_forget_multi(fuse_req_t req, size_t count,\n                            struct fuse_forget_data *forgets)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        lo_forget_one(req, forgets[i].ino, forgets[i].nlookup);\n    }\n    fuse_reply_none(req);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_none",
          "args": [
            "req"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_none",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "304-307",
          "snippet": "void fuse_reply_none(fuse_req_t req)\n{\n    fuse_free_req(req);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_reply_none(fuse_req_t req)\n{\n    fuse_free_req(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_forget_one",
          "args": [
            "req",
            "forgets[i].ino",
            "forgets[i].nlookup"
          ],
          "line": 1252
        },
        "resolved": true,
        "details": {
          "function_name": "lo_forget_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1222-1238",
          "snippet": "static void lo_forget_one(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        return;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  forget %lli %lli -%lli\\n\",\n             (unsigned long long)ino, (unsigned long long)inode->nlookup,\n             (unsigned long long)nlookup);\n\n    unref_inode_lolocked(lo, inode, nlookup);\n    lo_inode_put(lo, &inode);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_forget_one(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        return;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  forget %lli %lli -%lli\\n\",\n             (unsigned long long)ino, (unsigned long long)inode->nlookup,\n             (unsigned long long)nlookup);\n\n    unref_inode_lolocked(lo, inode, nlookup);\n    lo_inode_put(lo, &inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_forget_multi(fuse_req_t req, size_t count,\n                            struct fuse_forget_data *forgets)\n{\n    int i;\n\n    for (i = 0; i < count; i++) {\n        lo_forget_one(req, forgets[i].ino, forgets[i].nlookup);\n    }\n    fuse_reply_none(req);\n}"
  },
  {
    "function_name": "lo_forget",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1240-1244",
    "snippet": "static void lo_forget(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    lo_forget_one(req, ino, nlookup);\n    fuse_reply_none(req);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_none",
          "args": [
            "req"
          ],
          "line": 1243
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_none",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "304-307",
          "snippet": "void fuse_reply_none(fuse_req_t req)\n{\n    fuse_free_req(req);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_reply_none(fuse_req_t req)\n{\n    fuse_free_req(req);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_forget_one",
          "args": [
            "req",
            "ino",
            "nlookup"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "lo_forget_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1222-1238",
          "snippet": "static void lo_forget_one(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        return;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  forget %lli %lli -%lli\\n\",\n             (unsigned long long)ino, (unsigned long long)inode->nlookup,\n             (unsigned long long)nlookup);\n\n    unref_inode_lolocked(lo, inode, nlookup);\n    lo_inode_put(lo, &inode);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_forget_one(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        return;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  forget %lli %lli -%lli\\n\",\n             (unsigned long long)ino, (unsigned long long)inode->nlookup,\n             (unsigned long long)nlookup);\n\n    unref_inode_lolocked(lo, inode, nlookup);\n    lo_inode_put(lo, &inode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_forget(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    lo_forget_one(req, ino, nlookup);\n    fuse_reply_none(req);\n}"
  },
  {
    "function_name": "lo_forget_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1222-1238",
    "snippet": "static void lo_forget_one(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        return;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  forget %lli %lli -%lli\\n\",\n             (unsigned long long)ino, (unsigned long long)inode->nlookup,\n             (unsigned long long)nlookup);\n\n    unref_inode_lolocked(lo, inode, nlookup);\n    lo_inode_put(lo, &inode);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&inode"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unref_inode_lolocked",
          "args": [
            "lo",
            "inode",
            "nlookup"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "unref_inode_lolocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1210-1220",
          "snippet": "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"  forget %lli %lli -%lli\\n\"",
            "(unsigned long long)ino",
            "(unsigned long long)inode->nlookup",
            "(unsigned long long)nlookup"
          ],
          "line": 1232
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "ino"
          ],
          "line": 1227
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1224
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_forget_one(fuse_req_t req, fuse_ino_t ino, uint64_t nlookup)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        return;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  forget %lli %lli -%lli\\n\",\n             (unsigned long long)ino, (unsigned long long)inode->nlookup,\n             (unsigned long long)nlookup);\n\n    unref_inode_lolocked(lo, inode, nlookup);\n    lo_inode_put(lo, &inode);\n}"
  },
  {
    "function_name": "unref_inode_lolocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1210-1220",
    "snippet": "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unref_inode",
          "args": [
            "lo",
            "inode",
            "n"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "unref_inode_lolocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1210-1220",
          "snippet": "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}"
  },
  {
    "function_name": "unref_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1188-1208",
    "snippet": "static void unref_inode(struct lo_data *lo, struct lo_inode *inode, uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    assert(inode->nlookup >= n);\n    inode->nlookup -= n;\n    if (!inode->nlookup) {\n        lo_map_remove(&lo->ino_map, inode->fuse_ino);\n        g_hash_table_remove(lo->inodes, &inode->key);\n        if (g_hash_table_size(inode->posix_locks)) {\n            fuse_log(FUSE_LOG_WARNING, \"Hash table is not empty\\n\");\n        }\n        g_hash_table_destroy(inode->posix_locks);\n        pthread_mutex_destroy(&inode->plock_mutex);\n\n        /* Drop our refcount from lo_do_lookup() */\n        lo_inode_put(lo, &inode);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&inode"
          ],
          "line": 1206
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_destroy",
          "args": [
            "&inode->plock_mutex"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_hash_table_destroy",
          "args": [
            "inode->posix_locks"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_WARNING",
            "\"Hash table is not empty\\n\""
          ],
          "line": 1200
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_hash_table_size",
          "args": [
            "inode->posix_locks"
          ],
          "line": 1199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_hash_table_remove",
          "args": [
            "lo->inodes",
            "&inode->key"
          ],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_map_remove",
          "args": [
            "&lo->ino_map",
            "inode->fuse_ino"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "425-442",
          "snippet": "static void lo_map_remove(struct lo_map *map, size_t key)\n{\n    struct lo_map_elem *elem;\n\n    if (key >= map->nelems) {\n        return;\n    }\n\n    elem = &map->elems[key];\n    if (!elem->in_use) {\n        return;\n    }\n\n    elem->in_use = false;\n\n    elem->freelist = map->freelist;\n    map->freelist = key;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_map_remove(struct lo_map *map, size_t key)\n{\n    struct lo_map_elem *elem;\n\n    if (key >= map->nelems) {\n        return;\n    }\n\n    elem = &map->elems[key];\n    if (!elem->in_use) {\n        return;\n    }\n\n    elem->in_use = false;\n\n    elem->freelist = map->freelist;\n    map->freelist = key;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "inode->nlookup >= n"
          ],
          "line": 1194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void unref_inode(struct lo_data *lo, struct lo_inode *inode, uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    assert(inode->nlookup >= n);\n    inode->nlookup -= n;\n    if (!inode->nlookup) {\n        lo_map_remove(&lo->ino_map, inode->fuse_ino);\n        g_hash_table_remove(lo->inodes, &inode->key);\n        if (g_hash_table_size(inode->posix_locks)) {\n            fuse_log(FUSE_LOG_WARNING, \"Hash table is not empty\\n\");\n        }\n        g_hash_table_destroy(inode->posix_locks);\n        pthread_mutex_destroy(&inode->plock_mutex);\n\n        /* Drop our refcount from lo_do_lookup() */\n        lo_inode_put(lo, &inode);\n    }\n}"
  },
  {
    "function_name": "lo_unlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1163-1185",
    "snippet": "static void lo_unlink(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n    int res;\n    struct lo_inode *inode;\n    struct lo_data *lo = lo_data(req);\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    inode = lookup_name(req, parent, name);\n    if (!inode) {\n        fuse_reply_err(req, EIO);\n        return;\n    }\n\n    res = unlinkat(lo_fd(req, parent), name, 0);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n    unref_inode_lolocked(lo, inode, 1);\n    lo_inode_put(lo, &inode);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&inode"
          ],
          "line": 1184
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unref_inode_lolocked",
          "args": [
            "lo",
            "inode",
            "1"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "unref_inode_lolocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1210-1220",
          "snippet": "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "res == -1 ? errno : 0"
          ],
          "line": 1182
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlinkat",
          "args": [
            "lo_fd(req, parent)",
            "name",
            "0"
          ],
          "line": 1180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fd",
          "args": [
            "req",
            "parent"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "527-539",
          "snippet": "static int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_name",
          "args": [
            "req",
            "parent",
            "name"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1066-1079",
          "snippet": "static struct lo_inode *lookup_name(fuse_req_t req, fuse_ino_t parent,\n                                    const char *name)\n{\n    int res;\n    struct stat attr;\n\n    res = fstatat(lo_fd(req, parent), name, &attr,\n                  AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return NULL;\n    }\n\n    return lo_find(lo_data(req), &attr);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lookup_name(fuse_req_t req, fuse_ino_t parent,\n                                    const char *name)\n{\n    int res;\n    struct stat attr;\n\n    res = fstatat(lo_fd(req, parent), name, &attr,\n                  AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return NULL;\n    }\n\n    return lo_find(lo_data(req), &attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_safe_path_component",
          "args": [
            "name"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "is_safe_path_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "208-215",
          "snippet": "static int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_unlink(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n    int res;\n    struct lo_inode *inode;\n    struct lo_data *lo = lo_data(req);\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    inode = lookup_name(req, parent, name);\n    if (!inode) {\n        fuse_reply_err(req, EIO);\n        return;\n    }\n\n    res = unlinkat(lo_fd(req, parent), name, 0);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n    unref_inode_lolocked(lo, inode, 1);\n    lo_inode_put(lo, &inode);\n}"
  },
  {
    "function_name": "lo_rename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1105-1161",
    "snippet": "static void lo_rename(fuse_req_t req, fuse_ino_t parent, const char *name,\n                      fuse_ino_t newparent, const char *newname,\n                      unsigned int flags)\n{\n    int res;\n    struct lo_inode *parent_inode;\n    struct lo_inode *newparent_inode;\n    struct lo_inode *oldinode = NULL;\n    struct lo_inode *newinode = NULL;\n    struct lo_data *lo = lo_data(req);\n\n    if (!is_safe_path_component(name) || !is_safe_path_component(newname)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    parent_inode = lo_inode(req, parent);\n    newparent_inode = lo_inode(req, newparent);\n    if (!parent_inode || !newparent_inode) {\n        fuse_reply_err(req, EBADF);\n        goto out;\n    }\n\n    oldinode = lookup_name(req, parent, name);\n    newinode = lookup_name(req, newparent, newname);\n\n    if (!oldinode) {\n        fuse_reply_err(req, EIO);\n        goto out;\n    }\n\n    if (flags) {\n#ifndef SYS_renameat2\n        fuse_reply_err(req, EINVAL);\n#else\n        res = syscall(SYS_renameat2, parent_inode->fd, name,\n                        newparent_inode->fd, newname, flags);\n        if (res == -1 && errno == ENOSYS) {\n            fuse_reply_err(req, EINVAL);\n        } else {\n            fuse_reply_err(req, res == -1 ? errno : 0);\n        }\n#endif\n        goto out;\n    }\n\n    res = renameat(parent_inode->fd, name, newparent_inode->fd, newname);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\nout:\n    unref_inode_lolocked(lo, oldinode, 1);\n    unref_inode_lolocked(lo, newinode, 1);\n    lo_inode_put(lo, &oldinode);\n    lo_inode_put(lo, &newinode);\n    lo_inode_put(lo, &parent_inode);\n    lo_inode_put(lo, &newparent_inode);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&newparent_inode"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unref_inode_lolocked",
          "args": [
            "lo",
            "newinode",
            "1"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "unref_inode_lolocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1210-1220",
          "snippet": "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "res == -1 ? errno : 0"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "renameat",
          "args": [
            "parent_inode->fd",
            "name",
            "newparent_inode->fd",
            "newname"
          ],
          "line": 1151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_renameat2",
            "parent_inode->fd",
            "name",
            "newparent_inode->fd",
            "newname",
            "flags"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lookup_name",
          "args": [
            "req",
            "newparent",
            "newname"
          ],
          "line": 1129
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1066-1079",
          "snippet": "static struct lo_inode *lookup_name(fuse_req_t req, fuse_ino_t parent,\n                                    const char *name)\n{\n    int res;\n    struct stat attr;\n\n    res = fstatat(lo_fd(req, parent), name, &attr,\n                  AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return NULL;\n    }\n\n    return lo_find(lo_data(req), &attr);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lookup_name(fuse_req_t req, fuse_ino_t parent,\n                                    const char *name)\n{\n    int res;\n    struct stat attr;\n\n    res = fstatat(lo_fd(req, parent), name, &attr,\n                  AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return NULL;\n    }\n\n    return lo_find(lo_data(req), &attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "newparent"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_safe_path_component",
          "args": [
            "newname"
          ],
          "line": 1116
        },
        "resolved": true,
        "details": {
          "function_name": "is_safe_path_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "208-215",
          "snippet": "static int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1114
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_rename(fuse_req_t req, fuse_ino_t parent, const char *name,\n                      fuse_ino_t newparent, const char *newname,\n                      unsigned int flags)\n{\n    int res;\n    struct lo_inode *parent_inode;\n    struct lo_inode *newparent_inode;\n    struct lo_inode *oldinode = NULL;\n    struct lo_inode *newinode = NULL;\n    struct lo_data *lo = lo_data(req);\n\n    if (!is_safe_path_component(name) || !is_safe_path_component(newname)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    parent_inode = lo_inode(req, parent);\n    newparent_inode = lo_inode(req, newparent);\n    if (!parent_inode || !newparent_inode) {\n        fuse_reply_err(req, EBADF);\n        goto out;\n    }\n\n    oldinode = lookup_name(req, parent, name);\n    newinode = lookup_name(req, newparent, newname);\n\n    if (!oldinode) {\n        fuse_reply_err(req, EIO);\n        goto out;\n    }\n\n    if (flags) {\n#ifndef SYS_renameat2\n        fuse_reply_err(req, EINVAL);\n#else\n        res = syscall(SYS_renameat2, parent_inode->fd, name,\n                        newparent_inode->fd, newname, flags);\n        if (res == -1 && errno == ENOSYS) {\n            fuse_reply_err(req, EINVAL);\n        } else {\n            fuse_reply_err(req, res == -1 ? errno : 0);\n        }\n#endif\n        goto out;\n    }\n\n    res = renameat(parent_inode->fd, name, newparent_inode->fd, newname);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\nout:\n    unref_inode_lolocked(lo, oldinode, 1);\n    unref_inode_lolocked(lo, newinode, 1);\n    lo_inode_put(lo, &oldinode);\n    lo_inode_put(lo, &newinode);\n    lo_inode_put(lo, &parent_inode);\n    lo_inode_put(lo, &newparent_inode);\n}"
  },
  {
    "function_name": "lo_rmdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1081-1103",
    "snippet": "static void lo_rmdir(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n    int res;\n    struct lo_inode *inode;\n    struct lo_data *lo = lo_data(req);\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    inode = lookup_name(req, parent, name);\n    if (!inode) {\n        fuse_reply_err(req, EIO);\n        return;\n    }\n\n    res = unlinkat(lo_fd(req, parent), name, AT_REMOVEDIR);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n    unref_inode_lolocked(lo, inode, 1);\n    lo_inode_put(lo, &inode);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&inode"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "unref_inode_lolocked",
          "args": [
            "lo",
            "inode",
            "1"
          ],
          "line": 1101
        },
        "resolved": true,
        "details": {
          "function_name": "unref_inode_lolocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1210-1220",
          "snippet": "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n)\n{\n    if (!inode) {\n        return;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    unref_inode(lo, inode, n);\n    pthread_mutex_unlock(&lo->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "res == -1 ? errno : 0"
          ],
          "line": 1100
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlinkat",
          "args": [
            "lo_fd(req, parent)",
            "name",
            "AT_REMOVEDIR"
          ],
          "line": 1098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fd",
          "args": [
            "req",
            "parent"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "527-539",
          "snippet": "static int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lookup_name",
          "args": [
            "req",
            "parent",
            "name"
          ],
          "line": 1092
        },
        "resolved": true,
        "details": {
          "function_name": "lookup_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "1066-1079",
          "snippet": "static struct lo_inode *lookup_name(fuse_req_t req, fuse_ino_t parent,\n                                    const char *name)\n{\n    int res;\n    struct stat attr;\n\n    res = fstatat(lo_fd(req, parent), name, &attr,\n                  AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return NULL;\n    }\n\n    return lo_find(lo_data(req), &attr);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lookup_name(fuse_req_t req, fuse_ino_t parent,\n                                    const char *name)\n{\n    int res;\n    struct stat attr;\n\n    res = fstatat(lo_fd(req, parent), name, &attr,\n                  AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return NULL;\n    }\n\n    return lo_find(lo_data(req), &attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_safe_path_component",
          "args": [
            "name"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "is_safe_path_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "208-215",
          "snippet": "static int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_rmdir(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n    int res;\n    struct lo_inode *inode;\n    struct lo_data *lo = lo_data(req);\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    inode = lookup_name(req, parent, name);\n    if (!inode) {\n        fuse_reply_err(req, EIO);\n        return;\n    }\n\n    res = unlinkat(lo_fd(req, parent), name, AT_REMOVEDIR);\n\n    fuse_reply_err(req, res == -1 ? errno : 0);\n    unref_inode_lolocked(lo, inode, 1);\n    lo_inode_put(lo, &inode);\n}"
  },
  {
    "function_name": "lookup_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1066-1079",
    "snippet": "static struct lo_inode *lookup_name(fuse_req_t req, fuse_ino_t parent,\n                                    const char *name)\n{\n    int res;\n    struct stat attr;\n\n    res = fstatat(lo_fd(req, parent), name, &attr,\n                  AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return NULL;\n    }\n\n    return lo_find(lo_data(req), &attr);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_find",
          "args": [
            "lo_data(req)",
            "&attr"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "lo_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "721-739",
          "snippet": "static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)\n{\n    struct lo_inode *p;\n    struct lo_key key = {\n        .ino = st->st_ino,\n        .dev = st->st_dev,\n    };\n\n    pthread_mutex_lock(&lo->mutex);\n    p = g_hash_table_lookup(lo->inodes, &key);\n    if (p) {\n        assert(p->nlookup > 0);\n        p->nlookup++;\n        g_atomic_int_inc(&p->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    return p;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_find(struct lo_data *lo, struct stat *st);\n\nstatic struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)\n{\n    struct lo_inode *p;\n    struct lo_key key = {\n        .ino = st->st_ino,\n        .dev = st->st_dev,\n    };\n\n    pthread_mutex_lock(&lo->mutex);\n    p = g_hash_table_lookup(lo->inodes, &key);\n    if (p) {\n        assert(p->nlookup > 0);\n        p->nlookup++;\n        g_atomic_int_inc(&p->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    return p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1078
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fstatat",
          "args": [
            "lo_fd(req, parent)",
            "name",
            "&attr",
            "AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fd",
          "args": [
            "req",
            "parent"
          ],
          "line": 1072
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "527-539",
          "snippet": "static int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lookup_name(fuse_req_t req, fuse_ino_t parent,\n                                    const char *name)\n{\n    int res;\n    struct stat attr;\n\n    res = fstatat(lo_fd(req, parent), name, &attr,\n                  AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return NULL;\n    }\n\n    return lo_find(lo_data(req), &attr);\n}"
  },
  {
    "function_name": "lo_link",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1006-1063",
    "snippet": "static void lo_link(fuse_req_t req, fuse_ino_t ino, fuse_ino_t parent,\n                    const char *name)\n{\n    int res;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *parent_inode;\n    struct lo_inode *inode;\n    struct fuse_entry_param e;\n    char procname[64];\n    int saverr;\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    parent_inode = lo_inode(req, parent);\n    inode = lo_inode(req, ino);\n    if (!parent_inode || !inode) {\n        errno = EBADF;\n        goto out_err;\n    }\n\n    memset(&e, 0, sizeof(struct fuse_entry_param));\n    e.attr_timeout = lo->timeout;\n    e.entry_timeout = lo->timeout;\n\n    sprintf(procname, \"%i\", inode->fd);\n    res = linkat(lo->proc_self_fd, procname, parent_inode->fd, name,\n                 AT_SYMLINK_FOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(inode->fd, \"\", &e.attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    inode->nlookup++;\n    pthread_mutex_unlock(&lo->mutex);\n    e.ino = inode->fuse_ino;\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &parent_inode);\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\n    lo_inode_put(lo, &parent_inode);\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "saverr"
          ],
          "line": 1062
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&inode"
          ],
          "line": 1061
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_entry",
          "args": [
            "req",
            "&e"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "400-408",
          "snippet": "int fuse_reply_entry(fuse_req_t req, const struct fuse_entry_param *e)\n{\n    struct fuse_entry_out arg;\n    size_t size = sizeof(arg);\n\n    memset(&arg, 0, sizeof(arg));\n    fill_entry(&arg, e);\n    return send_reply_ok(req, &arg, size);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_entry(fuse_req_t req, const struct fuse_entry_param *e)\n{\n    struct fuse_entry_out arg;\n    size_t size = sizeof(arg);\n\n    memset(&arg, 0, sizeof(arg));\n    fill_entry(&arg, e);\n    return send_reply_ok(req, &arg, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"  %lli/%s -> %lli\\n\"",
            "(unsigned long long)parent",
            "name",
            "(unsigned long long)e.ino"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 1045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fstatat",
          "args": [
            "inode->fd",
            "\"\"",
            "&e.attr",
            "AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW"
          ],
          "line": 1040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "linkat",
          "args": [
            "lo->proc_self_fd",
            "procname",
            "parent_inode->fd",
            "name",
            "AT_SYMLINK_FOLLOW"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "procname",
            "\"%i\"",
            "inode->fd"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&e",
            "0",
            "sizeof(struct fuse_entry_param)"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "ino"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_safe_path_component",
          "args": [
            "name"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "is_safe_path_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "208-215",
          "snippet": "static int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_link(fuse_req_t req, fuse_ino_t ino, fuse_ino_t parent,\n                    const char *name)\n{\n    int res;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *parent_inode;\n    struct lo_inode *inode;\n    struct fuse_entry_param e;\n    char procname[64];\n    int saverr;\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    parent_inode = lo_inode(req, parent);\n    inode = lo_inode(req, ino);\n    if (!parent_inode || !inode) {\n        errno = EBADF;\n        goto out_err;\n    }\n\n    memset(&e, 0, sizeof(struct fuse_entry_param));\n    e.attr_timeout = lo->timeout;\n    e.entry_timeout = lo->timeout;\n\n    sprintf(procname, \"%i\", inode->fd);\n    res = linkat(lo->proc_self_fd, procname, parent_inode->fd, name,\n                 AT_SYMLINK_FOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(inode->fd, \"\", &e.attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    pthread_mutex_lock(&lo->mutex);\n    inode->nlookup++;\n    pthread_mutex_unlock(&lo->mutex);\n    e.ino = inode->fuse_ino;\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &parent_inode);\n    lo_inode_put(lo, &inode);\n    return;\n\nout_err:\n    saverr = errno;\n    lo_inode_put(lo, &parent_inode);\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}"
  },
  {
    "function_name": "lo_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "1000-1004",
    "snippet": "static void lo_symlink(fuse_req_t req, const char *link, fuse_ino_t parent,\n                       const char *name)\n{\n    lo_mknod_symlink(req, parent, name, S_IFLNK, 0, link);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_mknod_symlink",
          "args": [
            "req",
            "parent",
            "name",
            "S_IFLNK",
            "0",
            "link"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "lo_mknod_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "934-986",
          "snippet": "static void lo_mknod_symlink(fuse_req_t req, fuse_ino_t parent,\n                             const char *name, mode_t mode, dev_t rdev,\n                             const char *link)\n{\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *dir;\n    struct fuse_entry_param e;\n    struct lo_cred old = {};\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    dir = lo_inode(req, parent);\n    if (!dir) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = lo_change_cred(req, &old);\n    if (saverr) {\n        goto out;\n    }\n\n    res = mknod_wrapper(dir->fd, name, link, mode, rdev);\n\n    saverr = errno;\n\n    lo_restore_cred(&old);\n\n    if (res == -1) {\n        goto out;\n    }\n\n    saverr = lo_do_lookup(req, parent, name, &e);\n    if (saverr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &dir);\n    return;\n\nout:\n    lo_inode_put(lo, &dir);\n    fuse_reply_err(req, saverr);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_mknod_symlink(fuse_req_t req, fuse_ino_t parent,\n                             const char *name, mode_t mode, dev_t rdev,\n                             const char *link)\n{\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *dir;\n    struct fuse_entry_param e;\n    struct lo_cred old = {};\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    dir = lo_inode(req, parent);\n    if (!dir) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = lo_change_cred(req, &old);\n    if (saverr) {\n        goto out;\n    }\n\n    res = mknod_wrapper(dir->fd, name, link, mode, rdev);\n\n    saverr = errno;\n\n    lo_restore_cred(&old);\n\n    if (res == -1) {\n        goto out;\n    }\n\n    saverr = lo_do_lookup(req, parent, name, &e);\n    if (saverr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &dir);\n    return;\n\nout:\n    lo_inode_put(lo, &dir);\n    fuse_reply_err(req, saverr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_symlink(fuse_req_t req, const char *link, fuse_ino_t parent,\n                       const char *name)\n{\n    lo_mknod_symlink(req, parent, name, S_IFLNK, 0, link);\n}"
  },
  {
    "function_name": "lo_mkdir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "994-998",
    "snippet": "static void lo_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name,\n                     mode_t mode)\n{\n    lo_mknod_symlink(req, parent, name, S_IFDIR | mode, 0, NULL);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_mknod_symlink",
          "args": [
            "req",
            "parent",
            "name",
            "S_IFDIR | mode",
            "0",
            "NULL"
          ],
          "line": 997
        },
        "resolved": true,
        "details": {
          "function_name": "lo_mknod_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "934-986",
          "snippet": "static void lo_mknod_symlink(fuse_req_t req, fuse_ino_t parent,\n                             const char *name, mode_t mode, dev_t rdev,\n                             const char *link)\n{\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *dir;\n    struct fuse_entry_param e;\n    struct lo_cred old = {};\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    dir = lo_inode(req, parent);\n    if (!dir) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = lo_change_cred(req, &old);\n    if (saverr) {\n        goto out;\n    }\n\n    res = mknod_wrapper(dir->fd, name, link, mode, rdev);\n\n    saverr = errno;\n\n    lo_restore_cred(&old);\n\n    if (res == -1) {\n        goto out;\n    }\n\n    saverr = lo_do_lookup(req, parent, name, &e);\n    if (saverr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &dir);\n    return;\n\nout:\n    lo_inode_put(lo, &dir);\n    fuse_reply_err(req, saverr);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_mknod_symlink(fuse_req_t req, fuse_ino_t parent,\n                             const char *name, mode_t mode, dev_t rdev,\n                             const char *link)\n{\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *dir;\n    struct fuse_entry_param e;\n    struct lo_cred old = {};\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    dir = lo_inode(req, parent);\n    if (!dir) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = lo_change_cred(req, &old);\n    if (saverr) {\n        goto out;\n    }\n\n    res = mknod_wrapper(dir->fd, name, link, mode, rdev);\n\n    saverr = errno;\n\n    lo_restore_cred(&old);\n\n    if (res == -1) {\n        goto out;\n    }\n\n    saverr = lo_do_lookup(req, parent, name, &e);\n    if (saverr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &dir);\n    return;\n\nout:\n    lo_inode_put(lo, &dir);\n    fuse_reply_err(req, saverr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_mkdir(fuse_req_t req, fuse_ino_t parent, const char *name,\n                     mode_t mode)\n{\n    lo_mknod_symlink(req, parent, name, S_IFDIR | mode, 0, NULL);\n}"
  },
  {
    "function_name": "lo_mknod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "988-992",
    "snippet": "static void lo_mknod(fuse_req_t req, fuse_ino_t parent, const char *name,\n                     mode_t mode, dev_t rdev)\n{\n    lo_mknod_symlink(req, parent, name, mode, rdev, NULL);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_mknod_symlink",
          "args": [
            "req",
            "parent",
            "name",
            "mode",
            "rdev",
            "NULL"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "lo_mknod_symlink",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "934-986",
          "snippet": "static void lo_mknod_symlink(fuse_req_t req, fuse_ino_t parent,\n                             const char *name, mode_t mode, dev_t rdev,\n                             const char *link)\n{\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *dir;\n    struct fuse_entry_param e;\n    struct lo_cred old = {};\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    dir = lo_inode(req, parent);\n    if (!dir) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = lo_change_cred(req, &old);\n    if (saverr) {\n        goto out;\n    }\n\n    res = mknod_wrapper(dir->fd, name, link, mode, rdev);\n\n    saverr = errno;\n\n    lo_restore_cred(&old);\n\n    if (res == -1) {\n        goto out;\n    }\n\n    saverr = lo_do_lookup(req, parent, name, &e);\n    if (saverr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &dir);\n    return;\n\nout:\n    lo_inode_put(lo, &dir);\n    fuse_reply_err(req, saverr);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_mknod_symlink(fuse_req_t req, fuse_ino_t parent,\n                             const char *name, mode_t mode, dev_t rdev,\n                             const char *link)\n{\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *dir;\n    struct fuse_entry_param e;\n    struct lo_cred old = {};\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    dir = lo_inode(req, parent);\n    if (!dir) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = lo_change_cred(req, &old);\n    if (saverr) {\n        goto out;\n    }\n\n    res = mknod_wrapper(dir->fd, name, link, mode, rdev);\n\n    saverr = errno;\n\n    lo_restore_cred(&old);\n\n    if (res == -1) {\n        goto out;\n    }\n\n    saverr = lo_do_lookup(req, parent, name, &e);\n    if (saverr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &dir);\n    return;\n\nout:\n    lo_inode_put(lo, &dir);\n    fuse_reply_err(req, saverr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_mknod(fuse_req_t req, fuse_ino_t parent, const char *name,\n                     mode_t mode, dev_t rdev)\n{\n    lo_mknod_symlink(req, parent, name, mode, rdev, NULL);\n}"
  },
  {
    "function_name": "lo_mknod_symlink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "934-986",
    "snippet": "static void lo_mknod_symlink(fuse_req_t req, fuse_ino_t parent,\n                             const char *name, mode_t mode, dev_t rdev,\n                             const char *link)\n{\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *dir;\n    struct fuse_entry_param e;\n    struct lo_cred old = {};\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    dir = lo_inode(req, parent);\n    if (!dir) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = lo_change_cred(req, &old);\n    if (saverr) {\n        goto out;\n    }\n\n    res = mknod_wrapper(dir->fd, name, link, mode, rdev);\n\n    saverr = errno;\n\n    lo_restore_cred(&old);\n\n    if (res == -1) {\n        goto out;\n    }\n\n    saverr = lo_do_lookup(req, parent, name, &e);\n    if (saverr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &dir);\n    return;\n\nout:\n    lo_inode_put(lo, &dir);\n    fuse_reply_err(req, saverr);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "saverr"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&dir"
          ],
          "line": 984
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_entry",
          "args": [
            "req",
            "&e"
          ],
          "line": 979
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "400-408",
          "snippet": "int fuse_reply_entry(fuse_req_t req, const struct fuse_entry_param *e)\n{\n    struct fuse_entry_out arg;\n    size_t size = sizeof(arg);\n\n    memset(&arg, 0, sizeof(arg));\n    fill_entry(&arg, e);\n    return send_reply_ok(req, &arg, size);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_entry(fuse_req_t req, const struct fuse_entry_param *e)\n{\n    struct fuse_entry_out arg;\n    size_t size = sizeof(arg);\n\n    memset(&arg, 0, sizeof(arg));\n    fill_entry(&arg, e);\n    return send_reply_ok(req, &arg, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"  %lli/%s -> %lli\\n\"",
            "(unsigned long long)parent",
            "name",
            "(unsigned long long)e.ino"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_do_lookup",
          "args": [
            "req",
            "parent",
            "name",
            "&e"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "lo_do_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "758-844",
          "snippet": "static int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,\n                        struct fuse_entry_param *e)\n{\n    int newfd;\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode = NULL;\n    struct lo_inode *dir = lo_inode(req, parent);\n\n    /*\n     * name_to_handle_at() and open_by_handle_at() can reach here with fuse\n     * mount point in guest, but we don't have its inode info in the\n     * ino_map.\n     */\n    if (!dir) {\n        return ENOENT;\n    }\n\n    memset(e, 0, sizeof(*e));\n    e->attr_timeout = lo->timeout;\n    e->entry_timeout = lo->timeout;\n\n    /* Do not allow escaping root directory */\n    if (dir == &lo->root && strcmp(name, \"..\") == 0) {\n        name = \".\";\n    }\n\n    newfd = openat(dir->fd, name, O_PATH | O_NOFOLLOW);\n    if (newfd == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(newfd, \"\", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    inode = lo_find(lo, &e->attr);\n    if (inode) {\n        close(newfd);\n    } else {\n        inode = calloc(1, sizeof(struct lo_inode));\n        if (!inode) {\n            goto out_err;\n        }\n\n        /* cache only filetype */\n        inode->filetype = (e->attr.st_mode & S_IFMT);\n\n        /*\n         * One for the caller and one for nlookup (released in\n         * unref_inode_lolocked())\n         */\n        g_atomic_int_set(&inode->refcount, 2);\n\n        inode->nlookup = 1;\n        inode->fd = newfd;\n        inode->key.ino = e->attr.st_ino;\n        inode->key.dev = e->attr.st_dev;\n        pthread_mutex_init(&inode->plock_mutex, NULL);\n        inode->posix_locks = g_hash_table_new_full(\n            g_direct_hash, g_direct_equal, NULL, posix_locks_value_destroy);\n\n        pthread_mutex_lock(&lo->mutex);\n        inode->fuse_ino = lo_add_inode_mapping(req, inode);\n        g_hash_table_insert(lo->inodes, &inode->key, inode);\n        pthread_mutex_unlock(&lo->mutex);\n    }\n    e->ino = inode->fuse_ino;\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e->ino);\n\n    return 0;\n\nout_err:\n    saverr = errno;\n    if (newfd != -1) {\n        close(newfd);\n    }\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n    return saverr;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,\n                        struct fuse_entry_param *e)\n{\n    int newfd;\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode = NULL;\n    struct lo_inode *dir = lo_inode(req, parent);\n\n    /*\n     * name_to_handle_at() and open_by_handle_at() can reach here with fuse\n     * mount point in guest, but we don't have its inode info in the\n     * ino_map.\n     */\n    if (!dir) {\n        return ENOENT;\n    }\n\n    memset(e, 0, sizeof(*e));\n    e->attr_timeout = lo->timeout;\n    e->entry_timeout = lo->timeout;\n\n    /* Do not allow escaping root directory */\n    if (dir == &lo->root && strcmp(name, \"..\") == 0) {\n        name = \".\";\n    }\n\n    newfd = openat(dir->fd, name, O_PATH | O_NOFOLLOW);\n    if (newfd == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(newfd, \"\", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    inode = lo_find(lo, &e->attr);\n    if (inode) {\n        close(newfd);\n    } else {\n        inode = calloc(1, sizeof(struct lo_inode));\n        if (!inode) {\n            goto out_err;\n        }\n\n        /* cache only filetype */\n        inode->filetype = (e->attr.st_mode & S_IFMT);\n\n        /*\n         * One for the caller and one for nlookup (released in\n         * unref_inode_lolocked())\n         */\n        g_atomic_int_set(&inode->refcount, 2);\n\n        inode->nlookup = 1;\n        inode->fd = newfd;\n        inode->key.ino = e->attr.st_ino;\n        inode->key.dev = e->attr.st_dev;\n        pthread_mutex_init(&inode->plock_mutex, NULL);\n        inode->posix_locks = g_hash_table_new_full(\n            g_direct_hash, g_direct_equal, NULL, posix_locks_value_destroy);\n\n        pthread_mutex_lock(&lo->mutex);\n        inode->fuse_ino = lo_add_inode_mapping(req, inode);\n        g_hash_table_insert(lo->inodes, &inode->key, inode);\n        pthread_mutex_unlock(&lo->mutex);\n    }\n    e->ino = inode->fuse_ino;\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e->ino);\n\n    return 0;\n\nout_err:\n    saverr = errno;\n    if (newfd != -1) {\n        close(newfd);\n    }\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n    return saverr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_restore_cred",
          "args": [
            "&old"
          ],
          "line": 965
        },
        "resolved": true,
        "details": {
          "function_name": "lo_restore_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "917-932",
          "snippet": "static void lo_restore_cred(struct lo_cred *old)\n{\n    int res;\n\n    res = syscall(OURSYS_setresuid, -1, old->euid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"seteuid(%u): %m\\n\", old->euid);\n        exit(1);\n    }\n\n    res = syscall(OURSYS_setresgid, -1, old->egid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"setegid(%u): %m\\n\", old->egid);\n        exit(1);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [
            "#define OURSYS_setresuid SYS_setresuid",
            "#define OURSYS_setresuid SYS_setresuid32",
            "#define OURSYS_setresgid SYS_setresgid",
            "#define OURSYS_setresgid SYS_setresgid32"
          ],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\n#define OURSYS_setresuid SYS_setresuid\n#define OURSYS_setresuid SYS_setresuid32\n#define OURSYS_setresgid SYS_setresgid\n#define OURSYS_setresgid SYS_setresgid32\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_restore_cred(struct lo_cred *old)\n{\n    int res;\n\n    res = syscall(OURSYS_setresuid, -1, old->euid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"seteuid(%u): %m\\n\", old->euid);\n        exit(1);\n    }\n\n    res = syscall(OURSYS_setresgid, -1, old->egid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"setegid(%u): %m\\n\", old->egid);\n        exit(1);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "mknod_wrapper",
          "args": [
            "dir->fd",
            "name",
            "link",
            "mode",
            "rdev"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "mknod_wrapper",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_helpers.h",
          "lines": "30-51",
          "snippet": "static int mknod_wrapper(int dirfd, const char *path, const char *link,\n                         int mode, dev_t rdev)\n{\n    int res;\n\n    if (S_ISREG(mode)) {\n        res = openat(dirfd, path, O_CREAT | O_EXCL | O_WRONLY, mode);\n        if (res >= 0) {\n            res = close(res);\n        }\n    } else if (S_ISDIR(mode)) {\n        res = mkdirat(dirfd, path, mode);\n    } else if (S_ISLNK(mode) && link != NULL) {\n        res = symlinkat(link, dirfd, path);\n    } else if (S_ISFIFO(mode)) {\n        res = mkfifoat(dirfd, path, mode);\n    } else {\n        res = mknodat(dirfd, path, mode, rdev);\n    }\n\n    return res;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static int mknod_wrapper(int dirfd, const char *path, const char *link,\n                         int mode, dev_t rdev)\n{\n    int res;\n\n    if (S_ISREG(mode)) {\n        res = openat(dirfd, path, O_CREAT | O_EXCL | O_WRONLY, mode);\n        if (res >= 0) {\n            res = close(res);\n        }\n    } else if (S_ISDIR(mode)) {\n        res = mkdirat(dirfd, path, mode);\n    } else if (S_ISLNK(mode) && link != NULL) {\n        res = symlinkat(link, dirfd, path);\n    } else if (S_ISFIFO(mode)) {\n        res = mkfifoat(dirfd, path, mode);\n    } else {\n        res = mknodat(dirfd, path, mode, rdev);\n    }\n\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_change_cred",
          "args": [
            "req",
            "&old"
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "lo_change_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "893-914",
          "snippet": "static int lo_change_cred(fuse_req_t req, struct lo_cred *old)\n{\n    int res;\n\n    old->euid = geteuid();\n    old->egid = getegid();\n\n    res = syscall(OURSYS_setresgid, -1, fuse_req_ctx(req)->gid, -1);\n    if (res == -1) {\n        return errno;\n    }\n\n    res = syscall(OURSYS_setresuid, -1, fuse_req_ctx(req)->uid, -1);\n    if (res == -1) {\n        int errno_save = errno;\n\n        syscall(OURSYS_setresgid, -1, old->egid, -1);\n        return errno_save;\n    }\n\n    return 0;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [
            "#define OURSYS_setresuid SYS_setresuid",
            "#define OURSYS_setresuid SYS_setresuid32",
            "#define OURSYS_setresgid SYS_setresgid",
            "#define OURSYS_setresgid SYS_setresgid32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\n#define OURSYS_setresuid SYS_setresuid\n#define OURSYS_setresuid SYS_setresuid32\n#define OURSYS_setresgid SYS_setresgid\n#define OURSYS_setresgid SYS_setresgid32\n\nstatic int lo_change_cred(fuse_req_t req, struct lo_cred *old)\n{\n    int res;\n\n    old->euid = geteuid();\n    old->egid = getegid();\n\n    res = syscall(OURSYS_setresgid, -1, fuse_req_ctx(req)->gid, -1);\n    if (res == -1) {\n        return errno;\n    }\n\n    res = syscall(OURSYS_setresuid, -1, fuse_req_ctx(req)->uid, -1);\n    if (res == -1) {\n        int errno_save = errno;\n\n        syscall(OURSYS_setresgid, -1, old->egid, -1);\n        return errno_save;\n    }\n\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "parent"
          ],
          "line": 950
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_safe_path_component",
          "args": [
            "name"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "is_safe_path_component",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "208-215",
          "snippet": "static int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 940
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_mknod_symlink(fuse_req_t req, fuse_ino_t parent,\n                             const char *name, mode_t mode, dev_t rdev,\n                             const char *link)\n{\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *dir;\n    struct fuse_entry_param e;\n    struct lo_cred old = {};\n\n    if (!is_safe_path_component(name)) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    dir = lo_inode(req, parent);\n    if (!dir) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    saverr = lo_change_cred(req, &old);\n    if (saverr) {\n        goto out;\n    }\n\n    res = mknod_wrapper(dir->fd, name, link, mode, rdev);\n\n    saverr = errno;\n\n    lo_restore_cred(&old);\n\n    if (res == -1) {\n        goto out;\n    }\n\n    saverr = lo_do_lookup(req, parent, name, &e);\n    if (saverr) {\n        goto out;\n    }\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e.ino);\n\n    fuse_reply_entry(req, &e);\n    lo_inode_put(lo, &dir);\n    return;\n\nout:\n    lo_inode_put(lo, &dir);\n    fuse_reply_err(req, saverr);\n}"
  },
  {
    "function_name": "lo_restore_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "917-932",
    "snippet": "static void lo_restore_cred(struct lo_cred *old)\n{\n    int res;\n\n    res = syscall(OURSYS_setresuid, -1, old->euid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"seteuid(%u): %m\\n\", old->euid);\n        exit(1);\n    }\n\n    res = syscall(OURSYS_setresgid, -1, old->egid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"setegid(%u): %m\\n\", old->egid);\n        exit(1);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [
      "#define OURSYS_setresuid SYS_setresuid",
      "#define OURSYS_setresuid SYS_setresuid32",
      "#define OURSYS_setresgid SYS_setresgid",
      "#define OURSYS_setresgid SYS_setresgid32"
    ],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"setegid(%u): %m\\n\"",
            "old->egid"
          ],
          "line": 929
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "OURSYS_setresgid",
            "-1",
            "old->egid",
            "-1"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "OURSYS_setresuid",
            "-1",
            "old->euid",
            "-1"
          ],
          "line": 921
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\n#define OURSYS_setresuid SYS_setresuid\n#define OURSYS_setresuid SYS_setresuid32\n#define OURSYS_setresgid SYS_setresgid\n#define OURSYS_setresgid SYS_setresgid32\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_restore_cred(struct lo_cred *old)\n{\n    int res;\n\n    res = syscall(OURSYS_setresuid, -1, old->euid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"seteuid(%u): %m\\n\", old->euid);\n        exit(1);\n    }\n\n    res = syscall(OURSYS_setresgid, -1, old->egid, -1);\n    if (res == -1) {\n        fuse_log(FUSE_LOG_ERR, \"setegid(%u): %m\\n\", old->egid);\n        exit(1);\n    }\n}"
  },
  {
    "function_name": "lo_change_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "893-914",
    "snippet": "static int lo_change_cred(fuse_req_t req, struct lo_cred *old)\n{\n    int res;\n\n    old->euid = geteuid();\n    old->egid = getegid();\n\n    res = syscall(OURSYS_setresgid, -1, fuse_req_ctx(req)->gid, -1);\n    if (res == -1) {\n        return errno;\n    }\n\n    res = syscall(OURSYS_setresuid, -1, fuse_req_ctx(req)->uid, -1);\n    if (res == -1) {\n        int errno_save = errno;\n\n        syscall(OURSYS_setresgid, -1, old->egid, -1);\n        return errno_save;\n    }\n\n    return 0;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [
      "#define OURSYS_setresuid SYS_setresuid",
      "#define OURSYS_setresuid SYS_setresuid32",
      "#define OURSYS_setresgid SYS_setresgid",
      "#define OURSYS_setresgid SYS_setresgid32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "OURSYS_setresgid",
            "-1",
            "old->egid",
            "-1"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "OURSYS_setresuid",
            "-1",
            "fuse_req_ctx(req)->uid",
            "-1"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_req_ctx",
          "args": [
            "req"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_req_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2285-2288",
          "snippet": "const struct fuse_ctx *fuse_req_ctx(fuse_req_t req)\n{\n    return &req->ctx;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nconst struct fuse_ctx *fuse_req_ctx(fuse_req_t req)\n{\n    return &req->ctx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "OURSYS_setresgid",
            "-1",
            "fuse_req_ctx(req)->gid",
            "-1"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getegid",
          "args": [],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "geteuid",
          "args": [],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\n#define OURSYS_setresuid SYS_setresuid\n#define OURSYS_setresuid SYS_setresuid32\n#define OURSYS_setresgid SYS_setresgid\n#define OURSYS_setresgid SYS_setresgid32\n\nstatic int lo_change_cred(fuse_req_t req, struct lo_cred *old)\n{\n    int res;\n\n    old->euid = geteuid();\n    old->egid = getegid();\n\n    res = syscall(OURSYS_setresgid, -1, fuse_req_ctx(req)->gid, -1);\n    if (res == -1) {\n        return errno;\n    }\n\n    res = syscall(OURSYS_setresuid, -1, fuse_req_ctx(req)->uid, -1);\n    if (res == -1) {\n        int errno_save = errno;\n\n        syscall(OURSYS_setresgid, -1, old->egid, -1);\n        return errno_save;\n    }\n\n    return 0;\n}"
  },
  {
    "function_name": "lo_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "846-869",
    "snippet": "static void lo_lookup(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n    struct fuse_entry_param e;\n    int err;\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_lookup(parent=%\" PRIu64 \", name=%s)\\n\", parent,\n             name);\n\n    /*\n     * Don't use is_safe_path_component(), allow \".\" and \"..\" for NFS export\n     * support.\n     */\n    if (strchr(name, '/')) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    err = lo_do_lookup(req, parent, name, &e);\n    if (err) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_entry(req, &e);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_entry",
          "args": [
            "req",
            "&e"
          ],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_entry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "400-408",
          "snippet": "int fuse_reply_entry(fuse_req_t req, const struct fuse_entry_param *e)\n{\n    struct fuse_entry_out arg;\n    size_t size = sizeof(arg);\n\n    memset(&arg, 0, sizeof(arg));\n    fill_entry(&arg, e);\n    return send_reply_ok(req, &arg, size);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_entry(fuse_req_t req, const struct fuse_entry_param *e)\n{\n    struct fuse_entry_out arg;\n    size_t size = sizeof(arg);\n\n    memset(&arg, 0, sizeof(arg));\n    fill_entry(&arg, e);\n    return send_reply_ok(req, &arg, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "err"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_do_lookup",
          "args": [
            "req",
            "parent",
            "name",
            "&e"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "lo_do_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "758-844",
          "snippet": "static int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,\n                        struct fuse_entry_param *e)\n{\n    int newfd;\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode = NULL;\n    struct lo_inode *dir = lo_inode(req, parent);\n\n    /*\n     * name_to_handle_at() and open_by_handle_at() can reach here with fuse\n     * mount point in guest, but we don't have its inode info in the\n     * ino_map.\n     */\n    if (!dir) {\n        return ENOENT;\n    }\n\n    memset(e, 0, sizeof(*e));\n    e->attr_timeout = lo->timeout;\n    e->entry_timeout = lo->timeout;\n\n    /* Do not allow escaping root directory */\n    if (dir == &lo->root && strcmp(name, \"..\") == 0) {\n        name = \".\";\n    }\n\n    newfd = openat(dir->fd, name, O_PATH | O_NOFOLLOW);\n    if (newfd == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(newfd, \"\", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    inode = lo_find(lo, &e->attr);\n    if (inode) {\n        close(newfd);\n    } else {\n        inode = calloc(1, sizeof(struct lo_inode));\n        if (!inode) {\n            goto out_err;\n        }\n\n        /* cache only filetype */\n        inode->filetype = (e->attr.st_mode & S_IFMT);\n\n        /*\n         * One for the caller and one for nlookup (released in\n         * unref_inode_lolocked())\n         */\n        g_atomic_int_set(&inode->refcount, 2);\n\n        inode->nlookup = 1;\n        inode->fd = newfd;\n        inode->key.ino = e->attr.st_ino;\n        inode->key.dev = e->attr.st_dev;\n        pthread_mutex_init(&inode->plock_mutex, NULL);\n        inode->posix_locks = g_hash_table_new_full(\n            g_direct_hash, g_direct_equal, NULL, posix_locks_value_destroy);\n\n        pthread_mutex_lock(&lo->mutex);\n        inode->fuse_ino = lo_add_inode_mapping(req, inode);\n        g_hash_table_insert(lo->inodes, &inode->key, inode);\n        pthread_mutex_unlock(&lo->mutex);\n    }\n    e->ino = inode->fuse_ino;\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e->ino);\n\n    return 0;\n\nout_err:\n    saverr = errno;\n    if (newfd != -1) {\n        close(newfd);\n    }\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n    return saverr;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,\n                        struct fuse_entry_param *e)\n{\n    int newfd;\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode = NULL;\n    struct lo_inode *dir = lo_inode(req, parent);\n\n    /*\n     * name_to_handle_at() and open_by_handle_at() can reach here with fuse\n     * mount point in guest, but we don't have its inode info in the\n     * ino_map.\n     */\n    if (!dir) {\n        return ENOENT;\n    }\n\n    memset(e, 0, sizeof(*e));\n    e->attr_timeout = lo->timeout;\n    e->entry_timeout = lo->timeout;\n\n    /* Do not allow escaping root directory */\n    if (dir == &lo->root && strcmp(name, \"..\") == 0) {\n        name = \".\";\n    }\n\n    newfd = openat(dir->fd, name, O_PATH | O_NOFOLLOW);\n    if (newfd == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(newfd, \"\", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    inode = lo_find(lo, &e->attr);\n    if (inode) {\n        close(newfd);\n    } else {\n        inode = calloc(1, sizeof(struct lo_inode));\n        if (!inode) {\n            goto out_err;\n        }\n\n        /* cache only filetype */\n        inode->filetype = (e->attr.st_mode & S_IFMT);\n\n        /*\n         * One for the caller and one for nlookup (released in\n         * unref_inode_lolocked())\n         */\n        g_atomic_int_set(&inode->refcount, 2);\n\n        inode->nlookup = 1;\n        inode->fd = newfd;\n        inode->key.ino = e->attr.st_ino;\n        inode->key.dev = e->attr.st_dev;\n        pthread_mutex_init(&inode->plock_mutex, NULL);\n        inode->posix_locks = g_hash_table_new_full(\n            g_direct_hash, g_direct_equal, NULL, posix_locks_value_destroy);\n\n        pthread_mutex_lock(&lo->mutex);\n        inode->fuse_ino = lo_add_inode_mapping(req, inode);\n        g_hash_table_insert(lo->inodes, &inode->key, inode);\n        pthread_mutex_unlock(&lo->mutex);\n    }\n    e->ino = inode->fuse_ino;\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e->ino);\n\n    return 0;\n\nout_err:\n    saverr = errno;\n    if (newfd != -1) {\n        close(newfd);\n    }\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n    return saverr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "name",
            "'/'"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_lookup(parent=%\" PRIu64 \", name=%s)\\n\"",
            "parent",
            "name"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_lookup(fuse_req_t req, fuse_ino_t parent, const char *name)\n{\n    struct fuse_entry_param e;\n    int err;\n\n    fuse_log(FUSE_LOG_DEBUG, \"lo_lookup(parent=%\" PRIu64 \", name=%s)\\n\", parent,\n             name);\n\n    /*\n     * Don't use is_safe_path_component(), allow \".\" and \"..\" for NFS export\n     * support.\n     */\n    if (strchr(name, '/')) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    err = lo_do_lookup(req, parent, name, &e);\n    if (err) {\n        fuse_reply_err(req, err);\n    } else {\n        fuse_reply_entry(req, &e);\n    }\n}"
  },
  {
    "function_name": "lo_do_lookup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "758-844",
    "snippet": "static int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,\n                        struct fuse_entry_param *e)\n{\n    int newfd;\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode = NULL;\n    struct lo_inode *dir = lo_inode(req, parent);\n\n    /*\n     * name_to_handle_at() and open_by_handle_at() can reach here with fuse\n     * mount point in guest, but we don't have its inode info in the\n     * ino_map.\n     */\n    if (!dir) {\n        return ENOENT;\n    }\n\n    memset(e, 0, sizeof(*e));\n    e->attr_timeout = lo->timeout;\n    e->entry_timeout = lo->timeout;\n\n    /* Do not allow escaping root directory */\n    if (dir == &lo->root && strcmp(name, \"..\") == 0) {\n        name = \".\";\n    }\n\n    newfd = openat(dir->fd, name, O_PATH | O_NOFOLLOW);\n    if (newfd == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(newfd, \"\", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    inode = lo_find(lo, &e->attr);\n    if (inode) {\n        close(newfd);\n    } else {\n        inode = calloc(1, sizeof(struct lo_inode));\n        if (!inode) {\n            goto out_err;\n        }\n\n        /* cache only filetype */\n        inode->filetype = (e->attr.st_mode & S_IFMT);\n\n        /*\n         * One for the caller and one for nlookup (released in\n         * unref_inode_lolocked())\n         */\n        g_atomic_int_set(&inode->refcount, 2);\n\n        inode->nlookup = 1;\n        inode->fd = newfd;\n        inode->key.ino = e->attr.st_ino;\n        inode->key.dev = e->attr.st_dev;\n        pthread_mutex_init(&inode->plock_mutex, NULL);\n        inode->posix_locks = g_hash_table_new_full(\n            g_direct_hash, g_direct_equal, NULL, posix_locks_value_destroy);\n\n        pthread_mutex_lock(&lo->mutex);\n        inode->fuse_ino = lo_add_inode_mapping(req, inode);\n        g_hash_table_insert(lo->inodes, &inode->key, inode);\n        pthread_mutex_unlock(&lo->mutex);\n    }\n    e->ino = inode->fuse_ino;\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e->ino);\n\n    return 0;\n\nout_err:\n    saverr = errno;\n    if (newfd != -1) {\n        close(newfd);\n    }\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n    return saverr;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&dir"
          ],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "newfd"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"  %lli/%s -> %lli\\n\"",
            "(unsigned long long)parent",
            "name",
            "(unsigned long long)e->ino"
          ],
          "line": 831
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_hash_table_insert",
          "args": [
            "lo->inodes",
            "&inode->key",
            "inode"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_add_inode_mapping",
          "args": [
            "req",
            "inode"
          ],
          "line": 823
        },
        "resolved": true,
        "details": {
          "function_name": "lo_add_inode_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "473-484",
          "snippet": "static ssize_t lo_add_inode_mapping(fuse_req_t req, struct lo_inode *inode)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->ino_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->inode = inode;\n    return elem - lo_data(req)->ino_map.elems;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t lo_add_inode_mapping(fuse_req_t req, struct lo_inode *inode)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->ino_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->inode = inode;\n    return elem - lo_data(req)->ino_map.elems;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_hash_table_new_full",
          "args": [
            "g_direct_hash",
            "g_direct_equal",
            "NULL",
            "posix_locks_value_destroy"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_init",
          "args": [
            "&inode->plock_mutex",
            "NULL"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_set",
          "args": [
            "&inode->refcount",
            "2"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "1",
            "sizeof(struct lo_inode)"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_find",
          "args": [
            "lo",
            "&e->attr"
          ],
          "line": 796
        },
        "resolved": true,
        "details": {
          "function_name": "lo_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "721-739",
          "snippet": "static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)\n{\n    struct lo_inode *p;\n    struct lo_key key = {\n        .ino = st->st_ino,\n        .dev = st->st_dev,\n    };\n\n    pthread_mutex_lock(&lo->mutex);\n    p = g_hash_table_lookup(lo->inodes, &key);\n    if (p) {\n        assert(p->nlookup > 0);\n        p->nlookup++;\n        g_atomic_int_inc(&p->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    return p;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_find(struct lo_data *lo, struct stat *st);\n\nstatic struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)\n{\n    struct lo_inode *p;\n    struct lo_key key = {\n        .ino = st->st_ino,\n        .dev = st->st_dev,\n    };\n\n    pthread_mutex_lock(&lo->mutex);\n    p = g_hash_table_lookup(lo->inodes, &key);\n    if (p) {\n        assert(p->nlookup > 0);\n        p->nlookup++;\n        g_atomic_int_inc(&p->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    return p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fstatat",
          "args": [
            "newfd",
            "\"\"",
            "&e->attr",
            "AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "dir->fd",
            "name",
            "O_PATH | O_NOFOLLOW"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "name",
            "\"..\""
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "e",
            "0",
            "sizeof(*e)"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "parent"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic int lo_do_lookup(fuse_req_t req, fuse_ino_t parent, const char *name,\n                        struct fuse_entry_param *e)\n{\n    int newfd;\n    int res;\n    int saverr;\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode = NULL;\n    struct lo_inode *dir = lo_inode(req, parent);\n\n    /*\n     * name_to_handle_at() and open_by_handle_at() can reach here with fuse\n     * mount point in guest, but we don't have its inode info in the\n     * ino_map.\n     */\n    if (!dir) {\n        return ENOENT;\n    }\n\n    memset(e, 0, sizeof(*e));\n    e->attr_timeout = lo->timeout;\n    e->entry_timeout = lo->timeout;\n\n    /* Do not allow escaping root directory */\n    if (dir == &lo->root && strcmp(name, \"..\") == 0) {\n        name = \".\";\n    }\n\n    newfd = openat(dir->fd, name, O_PATH | O_NOFOLLOW);\n    if (newfd == -1) {\n        goto out_err;\n    }\n\n    res = fstatat(newfd, \"\", &e->attr, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        goto out_err;\n    }\n\n    inode = lo_find(lo, &e->attr);\n    if (inode) {\n        close(newfd);\n    } else {\n        inode = calloc(1, sizeof(struct lo_inode));\n        if (!inode) {\n            goto out_err;\n        }\n\n        /* cache only filetype */\n        inode->filetype = (e->attr.st_mode & S_IFMT);\n\n        /*\n         * One for the caller and one for nlookup (released in\n         * unref_inode_lolocked())\n         */\n        g_atomic_int_set(&inode->refcount, 2);\n\n        inode->nlookup = 1;\n        inode->fd = newfd;\n        inode->key.ino = e->attr.st_ino;\n        inode->key.dev = e->attr.st_dev;\n        pthread_mutex_init(&inode->plock_mutex, NULL);\n        inode->posix_locks = g_hash_table_new_full(\n            g_direct_hash, g_direct_equal, NULL, posix_locks_value_destroy);\n\n        pthread_mutex_lock(&lo->mutex);\n        inode->fuse_ino = lo_add_inode_mapping(req, inode);\n        g_hash_table_insert(lo->inodes, &inode->key, inode);\n        pthread_mutex_unlock(&lo->mutex);\n    }\n    e->ino = inode->fuse_ino;\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n\n    fuse_log(FUSE_LOG_DEBUG, \"  %lli/%s -> %lli\\n\", (unsigned long long)parent,\n             name, (unsigned long long)e->ino);\n\n    return 0;\n\nout_err:\n    saverr = errno;\n    if (newfd != -1) {\n        close(newfd);\n    }\n    lo_inode_put(lo, &inode);\n    lo_inode_put(lo, &dir);\n    return saverr;\n}"
  },
  {
    "function_name": "posix_locks_value_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "742-752",
    "snippet": "static void posix_locks_value_destroy(gpointer data)\n{\n    struct lo_inode_plock *plock = data;\n\n    /*\n     * We had used open() for locks and had only one fd. So\n     * closing this fd should release all OFD locks.\n     */\n    close(plock->fd);\n    free(plock);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "plock"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "plock->fd"
          ],
          "line": 750
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void posix_locks_value_destroy(gpointer data)\n{\n    struct lo_inode_plock *plock = data;\n\n    /*\n     * We had used open() for locks and had only one fd. So\n     * closing this fd should release all OFD locks.\n     */\n    close(plock->fd);\n    free(plock);\n}"
  },
  {
    "function_name": "lo_find",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "721-739",
    "snippet": "static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)\n{\n    struct lo_inode *p;\n    struct lo_key key = {\n        .ino = st->st_ino,\n        .dev = st->st_dev,\n    };\n\n    pthread_mutex_lock(&lo->mutex);\n    p = g_hash_table_lookup(lo->inodes, &key);\n    if (p) {\n        assert(p->nlookup > 0);\n        p->nlookup++;\n        g_atomic_int_inc(&p->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    return p;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct lo_inode *lo_find(struct lo_data *lo, struct stat *st);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_inc",
          "args": [
            "&p->refcount"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "p->nlookup > 0"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_hash_table_lookup",
          "args": [
            "lo->inodes",
            "&key"
          ],
          "line": 730
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_find(struct lo_data *lo, struct stat *st);\n\nstatic struct lo_inode *lo_find(struct lo_data *lo, struct stat *st)\n{\n    struct lo_inode *p;\n    struct lo_key key = {\n        .ino = st->st_ino,\n        .dev = st->st_dev,\n    };\n\n    pthread_mutex_lock(&lo->mutex);\n    p = g_hash_table_lookup(lo->inodes, &key);\n    if (p) {\n        assert(p->nlookup > 0);\n        p->nlookup++;\n        g_atomic_int_inc(&p->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    return p;\n}"
  },
  {
    "function_name": "lo_setattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "614-719",
    "snippet": "static void lo_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr,\n                       int valid, struct fuse_file_info *fi)\n{\n    int saverr;\n    char procname[64];\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    int ifd;\n    int res;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    ifd = inode->fd;\n\n    /* If fi->fh is invalid we'll report EBADF later */\n    if (fi) {\n        fd = lo_fi_fd(req, fi);\n    }\n\n    if (valid & FUSE_SET_ATTR_MODE) {\n        if (fi) {\n            res = fchmod(fd, attr->st_mode);\n        } else {\n            sprintf(procname, \"%i\", ifd);\n            res = fchmodat(lo->proc_self_fd, procname, attr->st_mode, 0);\n        }\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    if (valid & (FUSE_SET_ATTR_UID | FUSE_SET_ATTR_GID)) {\n        uid_t uid = (valid & FUSE_SET_ATTR_UID) ? attr->st_uid : (uid_t)-1;\n        gid_t gid = (valid & FUSE_SET_ATTR_GID) ? attr->st_gid : (gid_t)-1;\n\n        res = fchownat(ifd, \"\", uid, gid, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    if (valid & FUSE_SET_ATTR_SIZE) {\n        int truncfd;\n\n        if (fi) {\n            truncfd = fd;\n        } else {\n            sprintf(procname, \"%i\", ifd);\n            truncfd = openat(lo->proc_self_fd, procname, O_RDWR);\n            if (truncfd < 0) {\n                goto out_err;\n            }\n        }\n\n        res = ftruncate(truncfd, attr->st_size);\n        if (!fi) {\n            saverr = errno;\n            close(truncfd);\n            errno = saverr;\n        }\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    if (valid & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) {\n        struct timespec tv[2];\n\n        tv[0].tv_sec = 0;\n        tv[1].tv_sec = 0;\n        tv[0].tv_nsec = UTIME_OMIT;\n        tv[1].tv_nsec = UTIME_OMIT;\n\n        if (valid & FUSE_SET_ATTR_ATIME_NOW) {\n            tv[0].tv_nsec = UTIME_NOW;\n        } else if (valid & FUSE_SET_ATTR_ATIME) {\n            tv[0] = attr->st_atim;\n        }\n\n        if (valid & FUSE_SET_ATTR_MTIME_NOW) {\n            tv[1].tv_nsec = UTIME_NOW;\n        } else if (valid & FUSE_SET_ATTR_MTIME) {\n            tv[1] = attr->st_mtim;\n        }\n\n        if (fi) {\n            res = futimens(fd, tv);\n        } else {\n            sprintf(procname, \"%i\", inode->fd);\n            res = utimensat(lo->proc_self_fd, procname, tv, 0);\n        }\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    lo_inode_put(lo, &inode);\n\n    return lo_getattr(req, ino, fi);\n\nout_err:\n    saverr = errno;\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "saverr"
          ],
          "line": 718
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo",
            "&inode"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_getattr",
          "args": [
            "req",
            "ino",
            "fi"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "lo_getattr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "580-596",
          "snippet": "static void lo_getattr(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    int res;\n    struct stat buf;\n    struct lo_data *lo = lo_data(req);\n\n    (void)fi;\n\n    res =\n        fstatat(lo_fd(req, ino), \"\", &buf, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    fuse_reply_attr(req, &buf, lo->timeout);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_getattr(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    int res;\n    struct stat buf;\n    struct lo_data *lo = lo_data(req);\n\n    (void)fi;\n\n    res =\n        fstatat(lo_fd(req, ino), \"\", &buf, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    fuse_reply_attr(req, &buf, lo->timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "utimensat",
          "args": [
            "lo->proc_self_fd",
            "procname",
            "tv",
            "0"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "procname",
            "\"%i\"",
            "inode->fd"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "futimens",
          "args": [
            "fd",
            "tv"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "truncfd"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ftruncate",
          "args": [
            "truncfd",
            "attr->st_size"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "lo->proc_self_fd",
            "procname",
            "O_RDWR"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "procname",
            "\"%i\"",
            "ifd"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchownat",
          "args": [
            "ifd",
            "\"\"",
            "uid",
            "gid",
            "AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmodat",
          "args": [
            "lo->proc_self_fd",
            "procname",
            "attr->st_mode",
            "0"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "procname",
            "\"%i\"",
            "ifd"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fchmod",
          "args": [
            "fd",
            "attr->st_mode"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fi_fd",
          "args": [
            "req",
            "fi"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fi_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "598-612",
          "snippet": "static int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "ino"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_setattr(fuse_req_t req, fuse_ino_t ino, struct stat *attr,\n                       int valid, struct fuse_file_info *fi)\n{\n    int saverr;\n    char procname[64];\n    struct lo_data *lo = lo_data(req);\n    struct lo_inode *inode;\n    int ifd;\n    int res;\n    int fd = -1;\n\n    inode = lo_inode(req, ino);\n    if (!inode) {\n        fuse_reply_err(req, EBADF);\n        return;\n    }\n\n    ifd = inode->fd;\n\n    /* If fi->fh is invalid we'll report EBADF later */\n    if (fi) {\n        fd = lo_fi_fd(req, fi);\n    }\n\n    if (valid & FUSE_SET_ATTR_MODE) {\n        if (fi) {\n            res = fchmod(fd, attr->st_mode);\n        } else {\n            sprintf(procname, \"%i\", ifd);\n            res = fchmodat(lo->proc_self_fd, procname, attr->st_mode, 0);\n        }\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    if (valid & (FUSE_SET_ATTR_UID | FUSE_SET_ATTR_GID)) {\n        uid_t uid = (valid & FUSE_SET_ATTR_UID) ? attr->st_uid : (uid_t)-1;\n        gid_t gid = (valid & FUSE_SET_ATTR_GID) ? attr->st_gid : (gid_t)-1;\n\n        res = fchownat(ifd, \"\", uid, gid, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    if (valid & FUSE_SET_ATTR_SIZE) {\n        int truncfd;\n\n        if (fi) {\n            truncfd = fd;\n        } else {\n            sprintf(procname, \"%i\", ifd);\n            truncfd = openat(lo->proc_self_fd, procname, O_RDWR);\n            if (truncfd < 0) {\n                goto out_err;\n            }\n        }\n\n        res = ftruncate(truncfd, attr->st_size);\n        if (!fi) {\n            saverr = errno;\n            close(truncfd);\n            errno = saverr;\n        }\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    if (valid & (FUSE_SET_ATTR_ATIME | FUSE_SET_ATTR_MTIME)) {\n        struct timespec tv[2];\n\n        tv[0].tv_sec = 0;\n        tv[1].tv_sec = 0;\n        tv[0].tv_nsec = UTIME_OMIT;\n        tv[1].tv_nsec = UTIME_OMIT;\n\n        if (valid & FUSE_SET_ATTR_ATIME_NOW) {\n            tv[0].tv_nsec = UTIME_NOW;\n        } else if (valid & FUSE_SET_ATTR_ATIME) {\n            tv[0] = attr->st_atim;\n        }\n\n        if (valid & FUSE_SET_ATTR_MTIME_NOW) {\n            tv[1].tv_nsec = UTIME_NOW;\n        } else if (valid & FUSE_SET_ATTR_MTIME) {\n            tv[1] = attr->st_mtim;\n        }\n\n        if (fi) {\n            res = futimens(fd, tv);\n        } else {\n            sprintf(procname, \"%i\", inode->fd);\n            res = utimensat(lo->proc_self_fd, procname, tv, 0);\n        }\n        if (res == -1) {\n            goto out_err;\n        }\n    }\n    lo_inode_put(lo, &inode);\n\n    return lo_getattr(req, ino, fi);\n\nout_err:\n    saverr = errno;\n    lo_inode_put(lo, &inode);\n    fuse_reply_err(req, saverr);\n}"
  },
  {
    "function_name": "lo_fi_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "598-612",
    "snippet": "static int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_map_get",
          "args": [
            "&lo->fd_map",
            "fi->fh"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "414-423",
          "snippet": "static struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fi_fd(fuse_req_t req, struct fuse_file_info *fi)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->fd_map, fi->fh);\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return -1;\n    }\n\n    return elem->fd;\n}"
  },
  {
    "function_name": "lo_getattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "580-596",
    "snippet": "static void lo_getattr(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    int res;\n    struct stat buf;\n    struct lo_data *lo = lo_data(req);\n\n    (void)fi;\n\n    res =\n        fstatat(lo_fd(req, ino), \"\", &buf, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    fuse_reply_attr(req, &buf, lo->timeout);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_reply_attr",
          "args": [
            "req",
            "&buf",
            "lo->timeout"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_attr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "424-436",
          "snippet": "int fuse_reply_attr(fuse_req_t req, const struct stat *attr,\n                    double attr_timeout)\n{\n    struct fuse_attr_out arg;\n    size_t size = sizeof(arg);\n\n    memset(&arg, 0, sizeof(arg));\n    arg.attr_valid = calc_timeout_sec(attr_timeout);\n    arg.attr_valid_nsec = calc_timeout_nsec(attr_timeout);\n    convert_stat(attr, &arg.attr);\n\n    return send_reply_ok(req, &arg, size);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_attr(fuse_req_t req, const struct stat *attr,\n                    double attr_timeout)\n{\n    struct fuse_attr_out arg;\n    size_t size = sizeof(arg);\n\n    memset(&arg, 0, sizeof(arg));\n    arg.attr_valid = calc_timeout_sec(attr_timeout);\n    arg.attr_valid_nsec = calc_timeout_nsec(attr_timeout);\n    convert_stat(attr, &arg.attr);\n\n    return send_reply_ok(req, &arg, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_reply_err",
          "args": [
            "req",
            "errno"
          ],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_reply_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "299-302",
          "snippet": "int fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_reply_err(fuse_req_t req, int err)\n{\n    return send_reply(req, -err, NULL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fstatat",
          "args": [
            "lo_fd(req, ino)",
            "\"\"",
            "&buf",
            "AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_fd",
          "args": [
            "req",
            "ino"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "lo_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "527-539",
          "snippet": "static int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_getattr(fuse_req_t req, fuse_ino_t ino,\n                       struct fuse_file_info *fi)\n{\n    int res;\n    struct stat buf;\n    struct lo_data *lo = lo_data(req);\n\n    (void)fi;\n\n    res =\n        fstatat(lo_fd(req, ino), \"\", &buf, AT_EMPTY_PATH | AT_SYMLINK_NOFOLLOW);\n    if (res == -1) {\n        return (void)fuse_reply_err(req, errno);\n    }\n\n    fuse_reply_attr(req, &buf, lo->timeout);\n}"
  },
  {
    "function_name": "lo_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "541-578",
    "snippet": "static void lo_init(void *userdata, struct fuse_conn_info *conn)\n{\n    struct lo_data *lo = (struct lo_data *)userdata;\n\n    if (conn->capable & FUSE_CAP_EXPORT_SUPPORT) {\n        conn->want |= FUSE_CAP_EXPORT_SUPPORT;\n    }\n\n    if (lo->writeback && conn->capable & FUSE_CAP_WRITEBACK_CACHE) {\n        fuse_log(FUSE_LOG_DEBUG, \"lo_init: activating writeback\\n\");\n        conn->want |= FUSE_CAP_WRITEBACK_CACHE;\n    }\n    if (conn->capable & FUSE_CAP_FLOCK_LOCKS) {\n        if (lo->flock) {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: activating flock locks\\n\");\n            conn->want |= FUSE_CAP_FLOCK_LOCKS;\n        } else {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: disabling flock locks\\n\");\n            conn->want &= ~FUSE_CAP_FLOCK_LOCKS;\n        }\n    }\n\n    if (conn->capable & FUSE_CAP_POSIX_LOCKS) {\n        if (lo->posix_lock) {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: activating posix locks\\n\");\n            conn->want |= FUSE_CAP_POSIX_LOCKS;\n        } else {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: disabling posix locks\\n\");\n            conn->want &= ~FUSE_CAP_POSIX_LOCKS;\n        }\n    }\n\n    if ((lo->cache == CACHE_NONE && !lo->readdirplus_set) ||\n        lo->readdirplus_clear) {\n        fuse_log(FUSE_LOG_DEBUG, \"lo_init: disabling readdirplus\\n\");\n        conn->want &= ~FUSE_CAP_READDIRPLUS;\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"lo_init: disabling readdirplus\\n\""
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\n\nstatic void lo_init(void *userdata, struct fuse_conn_info *conn)\n{\n    struct lo_data *lo = (struct lo_data *)userdata;\n\n    if (conn->capable & FUSE_CAP_EXPORT_SUPPORT) {\n        conn->want |= FUSE_CAP_EXPORT_SUPPORT;\n    }\n\n    if (lo->writeback && conn->capable & FUSE_CAP_WRITEBACK_CACHE) {\n        fuse_log(FUSE_LOG_DEBUG, \"lo_init: activating writeback\\n\");\n        conn->want |= FUSE_CAP_WRITEBACK_CACHE;\n    }\n    if (conn->capable & FUSE_CAP_FLOCK_LOCKS) {\n        if (lo->flock) {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: activating flock locks\\n\");\n            conn->want |= FUSE_CAP_FLOCK_LOCKS;\n        } else {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: disabling flock locks\\n\");\n            conn->want &= ~FUSE_CAP_FLOCK_LOCKS;\n        }\n    }\n\n    if (conn->capable & FUSE_CAP_POSIX_LOCKS) {\n        if (lo->posix_lock) {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: activating posix locks\\n\");\n            conn->want |= FUSE_CAP_POSIX_LOCKS;\n        } else {\n            fuse_log(FUSE_LOG_DEBUG, \"lo_init: disabling posix locks\\n\");\n            conn->want &= ~FUSE_CAP_POSIX_LOCKS;\n        }\n    }\n\n    if ((lo->cache == CACHE_NONE && !lo->readdirplus_set) ||\n        lo->readdirplus_clear) {\n        fuse_log(FUSE_LOG_DEBUG, \"lo_init: disabling readdirplus\\n\");\n        conn->want &= ~FUSE_CAP_READDIRPLUS;\n    }\n}"
  },
  {
    "function_name": "lo_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "527-539",
    "snippet": "static int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_inode_put",
          "args": [
            "lo_data(req)",
            "&inode"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "486-500",
          "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_inode",
          "args": [
            "req",
            "ino"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "lo_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "503-520",
          "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_fd(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_inode *inode = lo_inode(req, ino);\n    int fd;\n\n    if (!inode) {\n        return -1;\n    }\n\n    fd = inode->fd;\n    lo_inode_put(lo_data(req), &inode);\n    return fd;\n}"
  },
  {
    "function_name": "lo_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "503-520",
    "snippet": "static struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&lo->mutex"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_atomic_int_inc",
          "args": [
            "&elem->inode->refcount"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_map_get",
          "args": [
            "&lo->ino_map",
            "ino"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "414-423",
          "snippet": "static struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&lo->mutex"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_inode *lo_inode(fuse_req_t req, fuse_ino_t ino)\n{\n    struct lo_data *lo = lo_data(req);\n    struct lo_map_elem *elem;\n\n    pthread_mutex_lock(&lo->mutex);\n    elem = lo_map_get(&lo->ino_map, ino);\n    if (elem) {\n        g_atomic_int_inc(&elem->inode->refcount);\n    }\n    pthread_mutex_unlock(&lo->mutex);\n\n    if (!elem) {\n        return NULL;\n    }\n\n    return elem->inode;\n}"
  },
  {
    "function_name": "lo_inode_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "486-500",
    "snippet": "static void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "inode"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "inode->fd"
          ],
          "line": 497
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_atomic_int_dec_and_test",
          "args": [
            "&inode->refcount"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_inode_put(struct lo_data *lo, struct lo_inode **inodep)\n{\n    struct lo_inode *inode = *inodep;\n\n    if (!inode) {\n        return;\n    }\n\n    *inodep = NULL;\n\n    if (g_atomic_int_dec_and_test(&inode->refcount)) {\n        close(inode->fd);\n        free(inode);\n    }\n}"
  },
  {
    "function_name": "lo_add_inode_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "473-484",
    "snippet": "static ssize_t lo_add_inode_mapping(fuse_req_t req, struct lo_inode *inode)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->ino_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->inode = inode;\n    return elem - lo_data(req)->ino_map.elems;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_map_alloc_elem",
          "args": [
            "&lo_data(req)->ino_map"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_alloc_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "377-391",
          "snippet": "static struct lo_map_elem *lo_map_alloc_elem(struct lo_map *map)\n{\n    struct lo_map_elem *elem;\n\n    if (map->freelist == -1 && !lo_map_grow(map, map->nelems + 256)) {\n        return NULL;\n    }\n\n    elem = &map->elems[map->freelist];\n    map->freelist = elem->freelist;\n\n    elem->in_use = true;\n\n    return elem;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_map_elem *lo_map_alloc_elem(struct lo_map *map)\n{\n    struct lo_map_elem *elem;\n\n    if (map->freelist == -1 && !lo_map_grow(map, map->nelems + 256)) {\n        return NULL;\n    }\n\n    elem = &map->elems[map->freelist];\n    map->freelist = elem->freelist;\n\n    elem->in_use = true;\n\n    return elem;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t lo_add_inode_mapping(fuse_req_t req, struct lo_inode *inode)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->ino_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->inode = inode;\n    return elem - lo_data(req)->ino_map.elems;\n}"
  },
  {
    "function_name": "lo_add_dirp_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "459-470",
    "snippet": "static ssize_t lo_add_dirp_mapping(fuse_req_t req, struct lo_dirp *dirp)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->dirp_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->dirp = dirp;\n    return elem - lo_data(req)->dirp_map.elems;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_map_alloc_elem",
          "args": [
            "&lo_data(req)->dirp_map"
          ],
          "line": 463
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_alloc_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "377-391",
          "snippet": "static struct lo_map_elem *lo_map_alloc_elem(struct lo_map *map)\n{\n    struct lo_map_elem *elem;\n\n    if (map->freelist == -1 && !lo_map_grow(map, map->nelems + 256)) {\n        return NULL;\n    }\n\n    elem = &map->elems[map->freelist];\n    map->freelist = elem->freelist;\n\n    elem->in_use = true;\n\n    return elem;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_map_elem *lo_map_alloc_elem(struct lo_map *map)\n{\n    struct lo_map_elem *elem;\n\n    if (map->freelist == -1 && !lo_map_grow(map, map->nelems + 256)) {\n        return NULL;\n    }\n\n    elem = &map->elems[map->freelist];\n    map->freelist = elem->freelist;\n\n    elem->in_use = true;\n\n    return elem;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t lo_add_dirp_mapping(fuse_req_t req, struct lo_dirp *dirp)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->dirp_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->dirp = dirp;\n    return elem - lo_data(req)->dirp_map.elems;\n}"
  },
  {
    "function_name": "lo_add_fd_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "445-456",
    "snippet": "static ssize_t lo_add_fd_mapping(fuse_req_t req, int fd)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->fd_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->fd = fd;\n    return elem - lo_data(req)->fd_map.elems;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_data",
          "args": [
            "req"
          ],
          "line": 455
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_lo_data_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "2804-2822",
          "snippet": "static void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fuse_lo_data_cleanup(struct lo_data *lo)\n{\n    if (lo->inodes) {\n        g_hash_table_destroy(lo->inodes);\n    }\n    lo_map_destroy(&lo->fd_map);\n    lo_map_destroy(&lo->dirp_map);\n    lo_map_destroy(&lo->ino_map);\n\n    if (lo->proc_self_fd >= 0) {\n        close(lo->proc_self_fd);\n    }\n\n    if (lo->root.fd >= 0) {\n        close(lo->root.fd);\n    }\n\n    free(lo->source);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lo_map_alloc_elem",
          "args": [
            "&lo_data(req)->fd_map"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_alloc_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "377-391",
          "snippet": "static struct lo_map_elem *lo_map_alloc_elem(struct lo_map *map)\n{\n    struct lo_map_elem *elem;\n\n    if (map->freelist == -1 && !lo_map_grow(map, map->nelems + 256)) {\n        return NULL;\n    }\n\n    elem = &map->elems[map->freelist];\n    map->freelist = elem->freelist;\n\n    elem->in_use = true;\n\n    return elem;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_map_elem *lo_map_alloc_elem(struct lo_map *map)\n{\n    struct lo_map_elem *elem;\n\n    if (map->freelist == -1 && !lo_map_grow(map, map->nelems + 256)) {\n        return NULL;\n    }\n\n    elem = &map->elems[map->freelist];\n    map->freelist = elem->freelist;\n\n    elem->in_use = true;\n\n    return elem;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t lo_add_fd_mapping(fuse_req_t req, int fd)\n{\n    struct lo_map_elem *elem;\n\n    elem = lo_map_alloc_elem(&lo_data(req)->fd_map);\n    if (!elem) {\n        return -1;\n    }\n\n    elem->fd = fd;\n    return elem - lo_data(req)->fd_map.elems;\n}"
  },
  {
    "function_name": "lo_map_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "425-442",
    "snippet": "static void lo_map_remove(struct lo_map *map, size_t key)\n{\n    struct lo_map_elem *elem;\n\n    if (key >= map->nelems) {\n        return;\n    }\n\n    elem = &map->elems[key];\n    if (!elem->in_use) {\n        return;\n    }\n\n    elem->in_use = false;\n\n    elem->freelist = map->freelist;\n    map->freelist = key;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_map_remove(struct lo_map *map, size_t key)\n{\n    struct lo_map_elem *elem;\n\n    if (key >= map->nelems) {\n        return;\n    }\n\n    elem = &map->elems[key];\n    if (!elem->in_use) {\n        return;\n    }\n\n    elem->in_use = false;\n\n    elem->freelist = map->freelist;\n    map->freelist = key;\n}"
  },
  {
    "function_name": "lo_map_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "414-423",
    "snippet": "static struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_map_elem *lo_map_get(struct lo_map *map, size_t key)\n{\n    if (key >= map->nelems) {\n        return NULL;\n    }\n    if (!map->elems[key].in_use) {\n        return NULL;\n    }\n    return &map->elems[key];\n}"
  },
  {
    "function_name": "lo_map_reserve",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "393-412",
    "snippet": "static struct lo_map_elem *lo_map_reserve(struct lo_map *map, size_t key)\n{\n    ssize_t *prev;\n\n    if (!lo_map_grow(map, key + 1)) {\n        return NULL;\n    }\n\n    for (prev = &map->freelist; *prev != -1;\n         prev = &map->elems[*prev].freelist) {\n        if (*prev == key) {\n            struct lo_map_elem *elem = &map->elems[key];\n\n            *prev = elem->freelist;\n            elem->in_use = true;\n            return elem;\n        }\n    }\n    return NULL;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_map_grow",
          "args": [
            "map",
            "key + 1"
          ],
          "line": 397
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_grow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "351-375",
          "snippet": "static int lo_map_grow(struct lo_map *map, size_t new_nelems)\n{\n    struct lo_map_elem *new_elems;\n    size_t i;\n\n    if (new_nelems <= map->nelems) {\n        return 1;\n    }\n\n    new_elems = realloc(map->elems, sizeof(map->elems[0]) * new_nelems);\n    if (!new_elems) {\n        return 0;\n    }\n\n    for (i = map->nelems; i < new_nelems; i++) {\n        new_elems[i].freelist = i + 1;\n        new_elems[i].in_use = false;\n    }\n    new_elems[new_nelems - 1].freelist = -1;\n\n    map->elems = new_elems;\n    map->freelist = map->nelems;\n    map->nelems = new_nelems;\n    return 1;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_map_grow(struct lo_map *map, size_t new_nelems)\n{\n    struct lo_map_elem *new_elems;\n    size_t i;\n\n    if (new_nelems <= map->nelems) {\n        return 1;\n    }\n\n    new_elems = realloc(map->elems, sizeof(map->elems[0]) * new_nelems);\n    if (!new_elems) {\n        return 0;\n    }\n\n    for (i = map->nelems; i < new_nelems; i++) {\n        new_elems[i].freelist = i + 1;\n        new_elems[i].in_use = false;\n    }\n    new_elems[new_nelems - 1].freelist = -1;\n\n    map->elems = new_elems;\n    map->freelist = map->nelems;\n    map->nelems = new_nelems;\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_map_elem *lo_map_reserve(struct lo_map *map, size_t key)\n{\n    ssize_t *prev;\n\n    if (!lo_map_grow(map, key + 1)) {\n        return NULL;\n    }\n\n    for (prev = &map->freelist; *prev != -1;\n         prev = &map->elems[*prev].freelist) {\n        if (*prev == key) {\n            struct lo_map_elem *elem = &map->elems[key];\n\n            *prev = elem->freelist;\n            elem->in_use = true;\n            return elem;\n        }\n    }\n    return NULL;\n}"
  },
  {
    "function_name": "lo_map_alloc_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "377-391",
    "snippet": "static struct lo_map_elem *lo_map_alloc_elem(struct lo_map *map)\n{\n    struct lo_map_elem *elem;\n\n    if (map->freelist == -1 && !lo_map_grow(map, map->nelems + 256)) {\n        return NULL;\n    }\n\n    elem = &map->elems[map->freelist];\n    map->freelist = elem->freelist;\n\n    elem->in_use = true;\n\n    return elem;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lo_map_grow",
          "args": [
            "map",
            "map->nelems + 256"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "lo_map_grow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "351-375",
          "snippet": "static int lo_map_grow(struct lo_map *map, size_t new_nelems)\n{\n    struct lo_map_elem *new_elems;\n    size_t i;\n\n    if (new_nelems <= map->nelems) {\n        return 1;\n    }\n\n    new_elems = realloc(map->elems, sizeof(map->elems[0]) * new_nelems);\n    if (!new_elems) {\n        return 0;\n    }\n\n    for (i = map->nelems; i < new_nelems; i++) {\n        new_elems[i].freelist = i + 1;\n        new_elems[i].in_use = false;\n    }\n    new_elems[new_nelems - 1].freelist = -1;\n\n    map->elems = new_elems;\n    map->freelist = map->nelems;\n    map->nelems = new_nelems;\n    return 1;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_map_grow(struct lo_map *map, size_t new_nelems)\n{\n    struct lo_map_elem *new_elems;\n    size_t i;\n\n    if (new_nelems <= map->nelems) {\n        return 1;\n    }\n\n    new_elems = realloc(map->elems, sizeof(map->elems[0]) * new_nelems);\n    if (!new_elems) {\n        return 0;\n    }\n\n    for (i = map->nelems; i < new_nelems; i++) {\n        new_elems[i].freelist = i + 1;\n        new_elems[i].in_use = false;\n    }\n    new_elems[new_nelems - 1].freelist = -1;\n\n    map->elems = new_elems;\n    map->freelist = map->nelems;\n    map->nelems = new_nelems;\n    return 1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_map_elem *lo_map_alloc_elem(struct lo_map *map)\n{\n    struct lo_map_elem *elem;\n\n    if (map->freelist == -1 && !lo_map_grow(map, map->nelems + 256)) {\n        return NULL;\n    }\n\n    elem = &map->elems[map->freelist];\n    map->freelist = elem->freelist;\n\n    elem->in_use = true;\n\n    return elem;\n}"
  },
  {
    "function_name": "lo_map_grow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "351-375",
    "snippet": "static int lo_map_grow(struct lo_map *map, size_t new_nelems)\n{\n    struct lo_map_elem *new_elems;\n    size_t i;\n\n    if (new_nelems <= map->nelems) {\n        return 1;\n    }\n\n    new_elems = realloc(map->elems, sizeof(map->elems[0]) * new_nelems);\n    if (!new_elems) {\n        return 0;\n    }\n\n    for (i = map->nelems; i < new_nelems; i++) {\n        new_elems[i].freelist = i + 1;\n        new_elems[i].in_use = false;\n    }\n    new_elems[new_nelems - 1].freelist = -1;\n\n    map->elems = new_elems;\n    map->freelist = map->nelems;\n    map->nelems = new_nelems;\n    return 1;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "map->elems",
            "sizeof(map->elems[0]) * new_nelems"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int lo_map_grow(struct lo_map *map, size_t new_nelems)\n{\n    struct lo_map_elem *new_elems;\n    size_t i;\n\n    if (new_nelems <= map->nelems) {\n        return 1;\n    }\n\n    new_elems = realloc(map->elems, sizeof(map->elems[0]) * new_nelems);\n    if (!new_elems) {\n        return 0;\n    }\n\n    for (i = map->nelems; i < new_nelems; i++) {\n        new_elems[i].freelist = i + 1;\n        new_elems[i].in_use = false;\n    }\n    new_elems[new_nelems - 1].freelist = -1;\n\n    map->elems = new_elems;\n    map->freelist = map->nelems;\n    map->nelems = new_nelems;\n    return 1;\n}"
  },
  {
    "function_name": "lo_map_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "346-349",
    "snippet": "static void lo_map_destroy(struct lo_map *map)\n{\n    free(map->elems);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "map->elems"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_map_destroy(struct lo_map *map)\n{\n    free(map->elems);\n}"
  },
  {
    "function_name": "lo_map_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "339-344",
    "snippet": "static void lo_map_init(struct lo_map *map)\n{\n    map->elems = NULL;\n    map->nelems = 0;\n    map->freelist = -1;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void lo_map_init(struct lo_map *map)\n{\n    map->elems = NULL;\n    map->nelems = 0;\n    map->freelist = -1;\n}"
  },
  {
    "function_name": "gain_effective_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "303-337",
    "snippet": "static int gain_effective_cap(const char *cap_name)\n{\n    int cap;\n    int ret = 0;\n\n    cap = capng_name_to_capability(cap_name);\n    if (cap < 0) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_name_to_capability(%s) failed:%s\\n\",\n                 cap_name, strerror(errno));\n        goto out;\n    }\n\n    if (load_capng()) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"load_capng() failed\\n\");\n        goto out;\n    }\n\n    if (capng_update(CAPNG_ADD, CAPNG_EFFECTIVE, cap)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_update(ADD,) failed\\n\");\n        goto out;\n    }\n\n    if (capng_apply(CAPNG_SELECT_CAPS)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"gain:capng_apply() failed\\n\");\n        goto out;\n    }\n    ret = 0;\n\nout:\n    return ret;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);",
      "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"gain:capng_apply() failed\\n\""
          ],
          "line": 330
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capng_apply",
          "args": [
            "CAPNG_SELECT_CAPS"
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_update",
          "args": [
            "CAPNG_ADD",
            "CAPNG_EFFECTIVE",
            "cap"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_capng",
          "args": [],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "load_capng",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "227-252",
          "snippet": "static int load_capng(void)\n{\n    if (!cap_loaded) {\n        pthread_mutex_lock(&cap.mutex);\n        capng_restore_state(&cap.saved);\n        /*\n         * restore_state free's the saved copy\n         * so make another.\n         */\n        cap.saved = capng_save_state();\n        if (!cap.saved) {\n            pthread_mutex_unlock(&cap.mutex);\n            fuse_log(FUSE_LOG_ERR, \"capng_save_state (thread)\\n\");\n            return -EINVAL;\n        }\n        pthread_mutex_unlock(&cap.mutex);\n\n        /*\n         * We want to use the loaded state for our pid,\n         * not the original\n         */\n        capng_setpid(syscall(SYS_gettid));\n        cap_loaded = true;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);",
            "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;",
            "static __thread bool cap_loaded = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\nstatic __thread bool cap_loaded = 0;\n\nstatic int load_capng(void)\n{\n    if (!cap_loaded) {\n        pthread_mutex_lock(&cap.mutex);\n        capng_restore_state(&cap.saved);\n        /*\n         * restore_state free's the saved copy\n         * so make another.\n         */\n        cap.saved = capng_save_state();\n        if (!cap.saved) {\n            pthread_mutex_unlock(&cap.mutex);\n            fuse_log(FUSE_LOG_ERR, \"capng_save_state (thread)\\n\");\n            return -EINVAL;\n        }\n        pthread_mutex_unlock(&cap.mutex);\n\n        /*\n         * We want to use the loaded state for our pid,\n         * not the original\n         */\n        capng_setpid(syscall(SYS_gettid));\n        cap_loaded = true;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_name_to_capability",
          "args": [
            "cap_name"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\n\nstatic int gain_effective_cap(const char *cap_name)\n{\n    int cap;\n    int ret = 0;\n\n    cap = capng_name_to_capability(cap_name);\n    if (cap < 0) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_name_to_capability(%s) failed:%s\\n\",\n                 cap_name, strerror(errno));\n        goto out;\n    }\n\n    if (load_capng()) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"load_capng() failed\\n\");\n        goto out;\n    }\n\n    if (capng_update(CAPNG_ADD, CAPNG_EFFECTIVE, cap)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_update(ADD,) failed\\n\");\n        goto out;\n    }\n\n    if (capng_apply(CAPNG_SELECT_CAPS)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"gain:capng_apply() failed\\n\");\n        goto out;\n    }\n    ret = 0;\n\nout:\n    return ret;\n}"
  },
  {
    "function_name": "drop_effective_cap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "258-301",
    "snippet": "static int drop_effective_cap(const char *cap_name, bool *cap_dropped)\n{\n    int cap, ret;\n\n    cap = capng_name_to_capability(cap_name);\n    if (cap < 0) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_name_to_capability(%s) failed:%s\\n\",\n                 cap_name, strerror(errno));\n        goto out;\n    }\n\n    if (load_capng()) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"load_capng() failed\\n\");\n        goto out;\n    }\n\n    /* We dont have this capability in effective set already. */\n    if (!capng_have_capability(CAPNG_EFFECTIVE, cap)) {\n        ret = 0;\n        goto out;\n    }\n\n    if (capng_update(CAPNG_DROP, CAPNG_EFFECTIVE, cap)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_update(DROP,) failed\\n\");\n        goto out;\n    }\n\n    if (capng_apply(CAPNG_SELECT_CAPS)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"drop:capng_apply() failed\\n\");\n        goto out;\n    }\n\n    ret = 0;\n    if (cap_dropped) {\n        *cap_dropped = true;\n    }\n\nout:\n    return ret;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);",
      "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"drop:capng_apply() failed\\n\""
          ],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capng_apply",
          "args": [
            "CAPNG_SELECT_CAPS"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_update",
          "args": [
            "CAPNG_DROP",
            "CAPNG_EFFECTIVE",
            "cap"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_have_capability",
          "args": [
            "CAPNG_EFFECTIVE",
            "cap"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "load_capng",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "load_capng",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "227-252",
          "snippet": "static int load_capng(void)\n{\n    if (!cap_loaded) {\n        pthread_mutex_lock(&cap.mutex);\n        capng_restore_state(&cap.saved);\n        /*\n         * restore_state free's the saved copy\n         * so make another.\n         */\n        cap.saved = capng_save_state();\n        if (!cap.saved) {\n            pthread_mutex_unlock(&cap.mutex);\n            fuse_log(FUSE_LOG_ERR, \"capng_save_state (thread)\\n\");\n            return -EINVAL;\n        }\n        pthread_mutex_unlock(&cap.mutex);\n\n        /*\n         * We want to use the loaded state for our pid,\n         * not the original\n         */\n        capng_setpid(syscall(SYS_gettid));\n        cap_loaded = true;\n    }\n    return 0;\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);",
            "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;",
            "static __thread bool cap_loaded = 0;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\nstatic __thread bool cap_loaded = 0;\n\nstatic int load_capng(void)\n{\n    if (!cap_loaded) {\n        pthread_mutex_lock(&cap.mutex);\n        capng_restore_state(&cap.saved);\n        /*\n         * restore_state free's the saved copy\n         * so make another.\n         */\n        cap.saved = capng_save_state();\n        if (!cap.saved) {\n            pthread_mutex_unlock(&cap.mutex);\n            fuse_log(FUSE_LOG_ERR, \"capng_save_state (thread)\\n\");\n            return -EINVAL;\n        }\n        pthread_mutex_unlock(&cap.mutex);\n\n        /*\n         * We want to use the loaded state for our pid,\n         * not the original\n         */\n        capng_setpid(syscall(SYS_gettid));\n        cap_loaded = true;\n    }\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_name_to_capability",
          "args": [
            "cap_name"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\n\nstatic int drop_effective_cap(const char *cap_name, bool *cap_dropped)\n{\n    int cap, ret;\n\n    cap = capng_name_to_capability(cap_name);\n    if (cap < 0) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_name_to_capability(%s) failed:%s\\n\",\n                 cap_name, strerror(errno));\n        goto out;\n    }\n\n    if (load_capng()) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"load_capng() failed\\n\");\n        goto out;\n    }\n\n    /* We dont have this capability in effective set already. */\n    if (!capng_have_capability(CAPNG_EFFECTIVE, cap)) {\n        ret = 0;\n        goto out;\n    }\n\n    if (capng_update(CAPNG_DROP, CAPNG_EFFECTIVE, cap)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"capng_update(DROP,) failed\\n\");\n        goto out;\n    }\n\n    if (capng_apply(CAPNG_SELECT_CAPS)) {\n        ret = errno;\n        fuse_log(FUSE_LOG_ERR, \"drop:capng_apply() failed\\n\");\n        goto out;\n    }\n\n    ret = 0;\n    if (cap_dropped) {\n        *cap_dropped = true;\n    }\n\nout:\n    return ret;\n}"
  },
  {
    "function_name": "load_capng",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "227-252",
    "snippet": "static int load_capng(void)\n{\n    if (!cap_loaded) {\n        pthread_mutex_lock(&cap.mutex);\n        capng_restore_state(&cap.saved);\n        /*\n         * restore_state free's the saved copy\n         * so make another.\n         */\n        cap.saved = capng_save_state();\n        if (!cap.saved) {\n            pthread_mutex_unlock(&cap.mutex);\n            fuse_log(FUSE_LOG_ERR, \"capng_save_state (thread)\\n\");\n            return -EINVAL;\n        }\n        pthread_mutex_unlock(&cap.mutex);\n\n        /*\n         * We want to use the loaded state for our pid,\n         * not the original\n         */\n        capng_setpid(syscall(SYS_gettid));\n        cap_loaded = true;\n    }\n    return 0;\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);",
      "static struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;",
      "static __thread bool cap_loaded = 0;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "capng_setpid",
          "args": [
            "syscall(SYS_gettid)"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall",
          "args": [
            "SYS_gettid"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&cap.mutex"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"capng_save_state (thread)\\n\""
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&cap.mutex"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_save_state",
          "args": [],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capng_restore_state",
          "args": [
            "&cap.saved"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&cap.mutex"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic void unref_inode_lolocked(struct lo_data *lo, struct lo_inode *inode,\n                                 uint64_t n);\nstatic struct {\n    pthread_mutex_t mutex;\n    void *saved;\n} cap;\nstatic __thread bool cap_loaded = 0;\n\nstatic int load_capng(void)\n{\n    if (!cap_loaded) {\n        pthread_mutex_lock(&cap.mutex);\n        capng_restore_state(&cap.saved);\n        /*\n         * restore_state free's the saved copy\n         * so make another.\n         */\n        cap.saved = capng_save_state();\n        if (!cap.saved) {\n            pthread_mutex_unlock(&cap.mutex);\n            fuse_log(FUSE_LOG_ERR, \"capng_save_state (thread)\\n\");\n            return -EINVAL;\n        }\n        pthread_mutex_unlock(&cap.mutex);\n\n        /*\n         * We want to use the loaded state for our pid,\n         * not the original\n         */\n        capng_setpid(syscall(SYS_gettid));\n        cap_loaded = true;\n    }\n    return 0;\n}"
  },
  {
    "function_name": "lo_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "217-220",
    "snippet": "static struct lo_data *lo_data(fuse_req_t req)\n{\n    return (struct lo_data *)fuse_req_userdata(req);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_req_userdata",
          "args": [
            "req"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_req_userdata",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2280-2283",
          "snippet": "void *fuse_req_userdata(fuse_req_t req)\n{\n    return req->se->userdata;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid *fuse_req_userdata(fuse_req_t req)\n{\n    return req->se->userdata;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic struct lo_data *lo_data(fuse_req_t req)\n{\n    return (struct lo_data *)fuse_req_userdata(req);\n}"
  },
  {
    "function_name": "is_safe_path_component",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "208-215",
    "snippet": "static int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_dot_or_dotdot",
          "args": [
            "path"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "is_dot_or_dotdot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
          "lines": "201-205",
          "snippet": "static int is_dot_or_dotdot(const char *name)\n{\n    return name[0] == '.' &&\n           (name[1] == '\\0' || (name[1] == '.' && name[2] == '\\0'));\n}",
          "includes": [
            "#include \"passthrough_seccomp.h\"",
            "#include \"passthrough_helpers.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/xattr.h>",
            "#include <sys/wait.h>",
            "#include <sys/types.h>",
            "#include <sys/syscall.h>",
            "#include <sys/resource.h>",
            "#include <sys/prctl.h>",
            "#include <sys/mount.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <pthread.h>",
            "#include <limits.h>",
            "#include <inttypes.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <cap-ng.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_log.h\"",
            "#include \"fuse_virtio.h\"",
            "#include \"qemu/timer.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int is_dot_or_dotdot(const char *name)\n{\n    return name[0] == '.' &&\n           (name[1] == '\\0' || (name[1] == '.' && name[2] == '\\0'));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "path",
            "'/'"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int is_safe_path_component(const char *path)\n{\n    if (strchr(path, '/')) {\n        return 0;\n    }\n\n    return !is_dot_or_dotdot(path);\n}"
  },
  {
    "function_name": "is_dot_or_dotdot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_ll.c",
    "lines": "201-205",
    "snippet": "static int is_dot_or_dotdot(const char *name)\n{\n    return name[0] == '.' &&\n           (name[1] == '\\0' || (name[1] == '.' && name[2] == '\\0'));\n}",
    "includes": [
      "#include \"passthrough_seccomp.h\"",
      "#include \"passthrough_helpers.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/xattr.h>",
      "#include <sys/wait.h>",
      "#include <sys/types.h>",
      "#include <sys/syscall.h>",
      "#include <sys/resource.h>",
      "#include <sys/prctl.h>",
      "#include <sys/mount.h>",
      "#include <sys/file.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stddef.h>",
      "#include <stdbool.h>",
      "#include <pthread.h>",
      "#include <limits.h>",
      "#include <inttypes.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <cap-ng.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_log.h\"",
      "#include \"fuse_virtio.h\"",
      "#include \"qemu/timer.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"passthrough_seccomp.h\"\n#include \"passthrough_helpers.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/xattr.h>\n#include <sys/wait.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/resource.h>\n#include <sys/prctl.h>\n#include <sys/mount.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <pthread.h>\n#include <limits.h>\n#include <inttypes.h>\n#include <glib.h>\n#include <errno.h>\n#include <dirent.h>\n#include <cap-ng.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_log.h\"\n#include \"fuse_virtio.h\"\n#include \"qemu/timer.h\"\n#include \"qemu/osdep.h\"\n\nstatic int is_dot_or_dotdot(const char *name)\n{\n    return name[0] == '.' &&\n           (name[1] == '\\0' || (name[1] == '.' && name[2] == '\\0'));\n}"
  }
]