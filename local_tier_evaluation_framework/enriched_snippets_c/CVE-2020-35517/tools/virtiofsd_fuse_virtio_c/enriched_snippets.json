[
  {
    "function_name": "virtio_session_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "1022-1034",
    "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "se->virtio_dev"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_destroy",
          "args": [
            "&se->virtio_dev->vu_dispatch_rwlock"
          ],
          "line": 1031
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "se->vu_socketfd"
          ],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
  },
  {
    "function_name": "virtio_session_mount",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "965-1020",
    "snippet": "int virtio_session_mount(struct fuse_session *se)\n{\n    int ret;\n\n    /*\n     * Test that unshare(CLONE_FS) works. fv_queue_worker() will need it. It's\n     * an unprivileged system call but some Docker/Moby versions are known to\n     * reject it via seccomp when CAP_SYS_ADMIN is not given.\n     *\n     * Note that the program is single-threaded here so this syscall has no\n     * visible effect and is safe to make.\n     */\n    ret = unshare(CLONE_FS);\n    if (ret == -1 && errno == EPERM) {\n        fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_FS) failed with EPERM. If \"\n                \"running in a container please check that the container \"\n                \"runtime seccomp policy allows unshare.\\n\");\n        return -1;\n    }\n\n    ret = fv_create_listen_socket(se);\n    if (ret < 0) {\n        return ret;\n    }\n\n    se->fd = -1;\n\n    fuse_log(FUSE_LOG_INFO, \"%s: Waiting for vhost-user socket connection...\\n\",\n             __func__);\n    int data_sock = accept(se->vu_listen_fd, NULL, NULL);\n    if (data_sock == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket accept: %m\\n\");\n        close(se->vu_listen_fd);\n        return -1;\n    }\n    close(se->vu_listen_fd);\n    se->vu_listen_fd = -1;\n    fuse_log(FUSE_LOG_INFO, \"%s: Received vhost-user socket connection\\n\",\n             __func__);\n\n    /* TODO: Some cleanup/deallocation! */\n    se->virtio_dev = calloc(sizeof(struct fv_VuDev), 1);\n    if (!se->virtio_dev) {\n        fuse_log(FUSE_LOG_ERR, \"%s: virtio_dev calloc failed\\n\", __func__);\n        close(data_sock);\n        return -1;\n    }\n\n    se->vu_socketfd = data_sock;\n    se->virtio_dev->se = se;\n    pthread_rwlock_init(&se->virtio_dev->vu_dispatch_rwlock, NULL);\n    vu_init(&se->virtio_dev->dev, 2, se->vu_socketfd, fv_panic, fv_set_watch,\n            fv_remove_watch, &fv_iface);\n\n    return 0;\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static const VuDevIface fv_iface = {\n    .get_features = fv_get_features,\n    .set_features = fv_set_features,\n\n    /* Don't need process message, we've not got any at vhost-user level */\n    .queue_set_started = fv_queue_set_started,\n\n    .queue_is_processed_in_order = fv_queue_order,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "vu_init",
          "args": [
            "&se->virtio_dev->dev",
            "2",
            "se->vu_socketfd",
            "fv_panic",
            "fv_set_watch",
            "fv_remove_watch",
            "&fv_iface"
          ],
          "line": 1016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_init",
          "args": [
            "&se->virtio_dev->vu_dispatch_rwlock",
            "NULL"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "data_sock"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"%s: virtio_dev calloc failed\\n\"",
            "__func__"
          ],
          "line": 1008
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sizeof(struct fv_VuDev)",
            "1"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "se->vu_listen_fd",
            "NULL",
            "NULL"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fv_create_listen_socket",
          "args": [
            "se"
          ],
          "line": 985
        },
        "resolved": true,
        "details": {
          "function_name": "fv_create_listen_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "887-963",
          "snippet": "static int fv_create_listen_socket(struct fuse_session *se)\n{\n    struct sockaddr_un un;\n    mode_t old_umask;\n\n    /* Nothing to do if fd is already initialized */\n    if (se->vu_listen_fd >= 0) {\n        return 0;\n    }\n\n    if (strlen(se->vu_socket_path) >= sizeof(un.sun_path)) {\n        fuse_log(FUSE_LOG_ERR, \"Socket path too long\\n\");\n        return -1;\n    }\n\n    if (!strlen(se->vu_socket_path)) {\n        fuse_log(FUSE_LOG_ERR, \"Socket path is empty\\n\");\n        return -1;\n    }\n\n    /* Check the vu_socket_path is already used */\n    if (!fv_socket_lock(se)) {\n        return -1;\n    }\n\n    /*\n     * Create the Unix socket to communicate with qemu\n     * based on QEMU's vhost-user-bridge\n     */\n    unlink(se->vu_socket_path);\n    strcpy(un.sun_path, se->vu_socket_path);\n    size_t addr_len = sizeof(un);\n\n    int listen_sock = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (listen_sock == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket creation: %m\\n\");\n        return -1;\n    }\n    un.sun_family = AF_UNIX;\n\n    /*\n     * Unfortunately bind doesn't let you set the mask on the socket,\n     * so set umask appropriately and restore it later.\n     */\n    if (se->vu_socket_group) {\n        old_umask = umask(S_IROTH | S_IWOTH | S_IXOTH);\n    } else {\n        old_umask = umask(S_IRGRP | S_IWGRP | S_IXGRP |\n                          S_IROTH | S_IWOTH | S_IXOTH);\n    }\n    if (bind(listen_sock, (struct sockaddr *)&un, addr_len) == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket bind: %m\\n\");\n        close(listen_sock);\n        umask(old_umask);\n        return -1;\n    }\n    if (se->vu_socket_group) {\n        struct group *g = getgrnam(se->vu_socket_group);\n        if (g) {\n            if (!chown(se->vu_socket_path, -1, g->gr_gid)) {\n                fuse_log(FUSE_LOG_WARNING,\n                         \"vhost socket failed to set group to %s (%d)\\n\",\n                         se->vu_socket_group, g->gr_gid);\n            }\n        }\n    }\n    umask(old_umask);\n\n    if (listen(listen_sock, 1) == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket listen: %m\\n\");\n        close(listen_sock);\n        return -1;\n    }\n\n    se->vu_listen_fd = listen_sock;\n    return 0;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic int fv_create_listen_socket(struct fuse_session *se)\n{\n    struct sockaddr_un un;\n    mode_t old_umask;\n\n    /* Nothing to do if fd is already initialized */\n    if (se->vu_listen_fd >= 0) {\n        return 0;\n    }\n\n    if (strlen(se->vu_socket_path) >= sizeof(un.sun_path)) {\n        fuse_log(FUSE_LOG_ERR, \"Socket path too long\\n\");\n        return -1;\n    }\n\n    if (!strlen(se->vu_socket_path)) {\n        fuse_log(FUSE_LOG_ERR, \"Socket path is empty\\n\");\n        return -1;\n    }\n\n    /* Check the vu_socket_path is already used */\n    if (!fv_socket_lock(se)) {\n        return -1;\n    }\n\n    /*\n     * Create the Unix socket to communicate with qemu\n     * based on QEMU's vhost-user-bridge\n     */\n    unlink(se->vu_socket_path);\n    strcpy(un.sun_path, se->vu_socket_path);\n    size_t addr_len = sizeof(un);\n\n    int listen_sock = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (listen_sock == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket creation: %m\\n\");\n        return -1;\n    }\n    un.sun_family = AF_UNIX;\n\n    /*\n     * Unfortunately bind doesn't let you set the mask on the socket,\n     * so set umask appropriately and restore it later.\n     */\n    if (se->vu_socket_group) {\n        old_umask = umask(S_IROTH | S_IWOTH | S_IXOTH);\n    } else {\n        old_umask = umask(S_IRGRP | S_IWGRP | S_IXGRP |\n                          S_IROTH | S_IWOTH | S_IXOTH);\n    }\n    if (bind(listen_sock, (struct sockaddr *)&un, addr_len) == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket bind: %m\\n\");\n        close(listen_sock);\n        umask(old_umask);\n        return -1;\n    }\n    if (se->vu_socket_group) {\n        struct group *g = getgrnam(se->vu_socket_group);\n        if (g) {\n            if (!chown(se->vu_socket_path, -1, g->gr_gid)) {\n                fuse_log(FUSE_LOG_WARNING,\n                         \"vhost socket failed to set group to %s (%d)\\n\",\n                         se->vu_socket_group, g->gr_gid);\n            }\n        }\n    }\n    umask(old_umask);\n\n    if (listen(listen_sock, 1) == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket listen: %m\\n\");\n        close(listen_sock);\n        return -1;\n    }\n\n    se->vu_listen_fd = listen_sock;\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_FS"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic const VuDevIface fv_iface = {\n    .get_features = fv_get_features,\n    .set_features = fv_set_features,\n\n    /* Don't need process message, we've not got any at vhost-user level */\n    .queue_set_started = fv_queue_set_started,\n\n    .queue_is_processed_in_order = fv_queue_order,\n};\n\nint virtio_session_mount(struct fuse_session *se)\n{\n    int ret;\n\n    /*\n     * Test that unshare(CLONE_FS) works. fv_queue_worker() will need it. It's\n     * an unprivileged system call but some Docker/Moby versions are known to\n     * reject it via seccomp when CAP_SYS_ADMIN is not given.\n     *\n     * Note that the program is single-threaded here so this syscall has no\n     * visible effect and is safe to make.\n     */\n    ret = unshare(CLONE_FS);\n    if (ret == -1 && errno == EPERM) {\n        fuse_log(FUSE_LOG_ERR, \"unshare(CLONE_FS) failed with EPERM. If \"\n                \"running in a container please check that the container \"\n                \"runtime seccomp policy allows unshare.\\n\");\n        return -1;\n    }\n\n    ret = fv_create_listen_socket(se);\n    if (ret < 0) {\n        return ret;\n    }\n\n    se->fd = -1;\n\n    fuse_log(FUSE_LOG_INFO, \"%s: Waiting for vhost-user socket connection...\\n\",\n             __func__);\n    int data_sock = accept(se->vu_listen_fd, NULL, NULL);\n    if (data_sock == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket accept: %m\\n\");\n        close(se->vu_listen_fd);\n        return -1;\n    }\n    close(se->vu_listen_fd);\n    se->vu_listen_fd = -1;\n    fuse_log(FUSE_LOG_INFO, \"%s: Received vhost-user socket connection\\n\",\n             __func__);\n\n    /* TODO: Some cleanup/deallocation! */\n    se->virtio_dev = calloc(sizeof(struct fv_VuDev), 1);\n    if (!se->virtio_dev) {\n        fuse_log(FUSE_LOG_ERR, \"%s: virtio_dev calloc failed\\n\", __func__);\n        close(data_sock);\n        return -1;\n    }\n\n    se->vu_socketfd = data_sock;\n    se->virtio_dev->se = se;\n    pthread_rwlock_init(&se->virtio_dev->vu_dispatch_rwlock, NULL);\n    vu_init(&se->virtio_dev->dev, 2, se->vu_socketfd, fv_panic, fv_set_watch,\n            fv_remove_watch, &fv_iface);\n\n    return 0;\n}"
  },
  {
    "function_name": "fv_create_listen_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "887-963",
    "snippet": "static int fv_create_listen_socket(struct fuse_session *se)\n{\n    struct sockaddr_un un;\n    mode_t old_umask;\n\n    /* Nothing to do if fd is already initialized */\n    if (se->vu_listen_fd >= 0) {\n        return 0;\n    }\n\n    if (strlen(se->vu_socket_path) >= sizeof(un.sun_path)) {\n        fuse_log(FUSE_LOG_ERR, \"Socket path too long\\n\");\n        return -1;\n    }\n\n    if (!strlen(se->vu_socket_path)) {\n        fuse_log(FUSE_LOG_ERR, \"Socket path is empty\\n\");\n        return -1;\n    }\n\n    /* Check the vu_socket_path is already used */\n    if (!fv_socket_lock(se)) {\n        return -1;\n    }\n\n    /*\n     * Create the Unix socket to communicate with qemu\n     * based on QEMU's vhost-user-bridge\n     */\n    unlink(se->vu_socket_path);\n    strcpy(un.sun_path, se->vu_socket_path);\n    size_t addr_len = sizeof(un);\n\n    int listen_sock = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (listen_sock == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket creation: %m\\n\");\n        return -1;\n    }\n    un.sun_family = AF_UNIX;\n\n    /*\n     * Unfortunately bind doesn't let you set the mask on the socket,\n     * so set umask appropriately and restore it later.\n     */\n    if (se->vu_socket_group) {\n        old_umask = umask(S_IROTH | S_IWOTH | S_IXOTH);\n    } else {\n        old_umask = umask(S_IRGRP | S_IWGRP | S_IXGRP |\n                          S_IROTH | S_IWOTH | S_IXOTH);\n    }\n    if (bind(listen_sock, (struct sockaddr *)&un, addr_len) == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket bind: %m\\n\");\n        close(listen_sock);\n        umask(old_umask);\n        return -1;\n    }\n    if (se->vu_socket_group) {\n        struct group *g = getgrnam(se->vu_socket_group);\n        if (g) {\n            if (!chown(se->vu_socket_path, -1, g->gr_gid)) {\n                fuse_log(FUSE_LOG_WARNING,\n                         \"vhost socket failed to set group to %s (%d)\\n\",\n                         se->vu_socket_group, g->gr_gid);\n            }\n        }\n    }\n    umask(old_umask);\n\n    if (listen(listen_sock, 1) == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket listen: %m\\n\");\n        close(listen_sock);\n        return -1;\n    }\n\n    se->vu_listen_fd = listen_sock;\n    return 0;\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "listen_sock"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"vhost socket listen: %m\\n\""
          ],
          "line": 956
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "listen_sock",
            "1"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chown",
          "args": [
            "se->vu_socket_path",
            "-1",
            "g->gr_gid"
          ],
          "line": 946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getgrnam",
          "args": [
            "se->vu_socket_group"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "old_umask"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "listen_sock",
            "(struct sockaddr *)&un",
            "addr_len"
          ],
          "line": 937
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "S_IRGRP | S_IWGRP | S_IXGRP |\n                          S_IROTH | S_IWOTH | S_IXOTH"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "S_IROTH | S_IWOTH | S_IXOTH"
          ],
          "line": 932
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "un.sun_path",
            "se->vu_socket_path"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "se->vu_socket_path"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fv_socket_lock",
          "args": [
            "se"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "fv_socket_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "860-885",
          "snippet": "static bool fv_socket_lock(struct fuse_session *se)\n{\n    g_autofree gchar *sk_name = NULL;\n    g_autofree gchar *pidfile = NULL;\n    g_autofree gchar *dir = NULL;\n    Error *local_err = NULL;\n\n    dir = qemu_get_local_state_pathname(\"run/virtiofsd\");\n\n    if (g_mkdir_with_parents(dir, S_IRWXU) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"%s: Failed to create directory %s: %s\",\n                 __func__, dir, strerror(errno));\n        return false;\n    }\n\n    sk_name = g_strdup(se->vu_socket_path);\n    strreplace(sk_name, '/', '.');\n    pidfile = g_strdup_printf(\"%s/%s.pid\", dir, sk_name);\n\n    if (!qemu_write_pidfile(pidfile, &local_err)) {\n        error_report_err(local_err);\n        return false;\n    }\n\n    return true;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic bool fv_socket_lock(struct fuse_session *se)\n{\n    g_autofree gchar *sk_name = NULL;\n    g_autofree gchar *pidfile = NULL;\n    g_autofree gchar *dir = NULL;\n    Error *local_err = NULL;\n\n    dir = qemu_get_local_state_pathname(\"run/virtiofsd\");\n\n    if (g_mkdir_with_parents(dir, S_IRWXU) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"%s: Failed to create directory %s: %s\",\n                 __func__, dir, strerror(errno));\n        return false;\n    }\n\n    sk_name = g_strdup(se->vu_socket_path);\n    strreplace(sk_name, '/', '.');\n    pidfile = g_strdup_printf(\"%s/%s.pid\", dir, sk_name);\n\n    if (!qemu_write_pidfile(pidfile, &local_err)) {\n        error_report_err(local_err);\n        return false;\n    }\n\n    return true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "se->vu_socket_path"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "se->vu_socket_path"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic int fv_create_listen_socket(struct fuse_session *se)\n{\n    struct sockaddr_un un;\n    mode_t old_umask;\n\n    /* Nothing to do if fd is already initialized */\n    if (se->vu_listen_fd >= 0) {\n        return 0;\n    }\n\n    if (strlen(se->vu_socket_path) >= sizeof(un.sun_path)) {\n        fuse_log(FUSE_LOG_ERR, \"Socket path too long\\n\");\n        return -1;\n    }\n\n    if (!strlen(se->vu_socket_path)) {\n        fuse_log(FUSE_LOG_ERR, \"Socket path is empty\\n\");\n        return -1;\n    }\n\n    /* Check the vu_socket_path is already used */\n    if (!fv_socket_lock(se)) {\n        return -1;\n    }\n\n    /*\n     * Create the Unix socket to communicate with qemu\n     * based on QEMU's vhost-user-bridge\n     */\n    unlink(se->vu_socket_path);\n    strcpy(un.sun_path, se->vu_socket_path);\n    size_t addr_len = sizeof(un);\n\n    int listen_sock = socket(AF_UNIX, SOCK_STREAM, 0);\n    if (listen_sock == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket creation: %m\\n\");\n        return -1;\n    }\n    un.sun_family = AF_UNIX;\n\n    /*\n     * Unfortunately bind doesn't let you set the mask on the socket,\n     * so set umask appropriately and restore it later.\n     */\n    if (se->vu_socket_group) {\n        old_umask = umask(S_IROTH | S_IWOTH | S_IXOTH);\n    } else {\n        old_umask = umask(S_IRGRP | S_IWGRP | S_IXGRP |\n                          S_IROTH | S_IWOTH | S_IXOTH);\n    }\n    if (bind(listen_sock, (struct sockaddr *)&un, addr_len) == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket bind: %m\\n\");\n        close(listen_sock);\n        umask(old_umask);\n        return -1;\n    }\n    if (se->vu_socket_group) {\n        struct group *g = getgrnam(se->vu_socket_group);\n        if (g) {\n            if (!chown(se->vu_socket_path, -1, g->gr_gid)) {\n                fuse_log(FUSE_LOG_WARNING,\n                         \"vhost socket failed to set group to %s (%d)\\n\",\n                         se->vu_socket_group, g->gr_gid);\n            }\n        }\n    }\n    umask(old_umask);\n\n    if (listen(listen_sock, 1) == -1) {\n        fuse_log(FUSE_LOG_ERR, \"vhost socket listen: %m\\n\");\n        close(listen_sock);\n        return -1;\n    }\n\n    se->vu_listen_fd = listen_sock;\n    return 0;\n}"
  },
  {
    "function_name": "fv_socket_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "860-885",
    "snippet": "static bool fv_socket_lock(struct fuse_session *se)\n{\n    g_autofree gchar *sk_name = NULL;\n    g_autofree gchar *pidfile = NULL;\n    g_autofree gchar *dir = NULL;\n    Error *local_err = NULL;\n\n    dir = qemu_get_local_state_pathname(\"run/virtiofsd\");\n\n    if (g_mkdir_with_parents(dir, S_IRWXU) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"%s: Failed to create directory %s: %s\",\n                 __func__, dir, strerror(errno));\n        return false;\n    }\n\n    sk_name = g_strdup(se->vu_socket_path);\n    strreplace(sk_name, '/', '.');\n    pidfile = g_strdup_printf(\"%s/%s.pid\", dir, sk_name);\n\n    if (!qemu_write_pidfile(pidfile, &local_err)) {\n        error_report_err(local_err);\n        return false;\n    }\n\n    return true;\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error_report_err",
          "args": [
            "local_err"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemu_write_pidfile",
          "args": [
            "pidfile",
            "&local_err"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_strdup_printf",
          "args": [
            "\"%s/%s.pid\"",
            "dir",
            "sk_name"
          ],
          "line": 877
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strreplace",
          "args": [
            "sk_name",
            "'/'",
            "'.'"
          ],
          "line": 876
        },
        "resolved": true,
        "details": {
          "function_name": "strreplace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "851-858",
          "snippet": "static void strreplace(char *s, char old, char new)\n{\n    for (; *s; ++s) {\n        if (*s == old) {\n            *s = new;\n        }\n    }\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void strreplace(char *s, char old, char new)\n{\n    for (; *s; ++s) {\n        if (*s == old) {\n            *s = new;\n        }\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_strdup",
          "args": [
            "se->vu_socket_path"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"%s: Failed to create directory %s: %s\"",
            "__func__",
            "dir",
            "strerror(errno)"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_mkdir_with_parents",
          "args": [
            "dir",
            "S_IRWXU"
          ],
          "line": 869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qemu_get_local_state_pathname",
          "args": [
            "\"run/virtiofsd\""
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic bool fv_socket_lock(struct fuse_session *se)\n{\n    g_autofree gchar *sk_name = NULL;\n    g_autofree gchar *pidfile = NULL;\n    g_autofree gchar *dir = NULL;\n    Error *local_err = NULL;\n\n    dir = qemu_get_local_state_pathname(\"run/virtiofsd\");\n\n    if (g_mkdir_with_parents(dir, S_IRWXU) < 0) {\n        fuse_log(FUSE_LOG_ERR, \"%s: Failed to create directory %s: %s\",\n                 __func__, dir, strerror(errno));\n        return false;\n    }\n\n    sk_name = g_strdup(se->vu_socket_path);\n    strreplace(sk_name, '/', '.');\n    pidfile = g_strdup_printf(\"%s/%s.pid\", dir, sk_name);\n\n    if (!qemu_write_pidfile(pidfile, &local_err)) {\n        error_report_err(local_err);\n        return false;\n    }\n\n    return true;\n}"
  },
  {
    "function_name": "strreplace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "851-858",
    "snippet": "static void strreplace(char *s, char old, char new)\n{\n    for (; *s; ++s) {\n        if (*s == old) {\n            *s = new;\n        }\n    }\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void strreplace(char *s, char old, char new)\n{\n    for (; *s; ++s) {\n        if (*s == old) {\n            *s = new;\n        }\n    }\n}"
  },
  {
    "function_name": "virtio_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "787-849",
    "snippet": "int virtio_loop(struct fuse_session *se)\n{\n    fuse_log(FUSE_LOG_INFO, \"%s: Entry\\n\", __func__);\n\n    while (!fuse_session_exited(se)) {\n        struct pollfd pf[1];\n        bool ok;\n        int ret;\n        pf[0].fd = se->vu_socketfd;\n        pf[0].events = POLLIN;\n        pf[0].revents = 0;\n\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Waiting for VU event\\n\", __func__);\n        int poll_res = ppoll(pf, 1, NULL, NULL);\n\n        if (poll_res == -1) {\n            if (errno == EINTR) {\n                fuse_log(FUSE_LOG_INFO, \"%s: ppoll interrupted, going around\\n\",\n                         __func__);\n                continue;\n            }\n            fuse_log(FUSE_LOG_ERR, \"virtio_loop ppoll: %m\\n\");\n            break;\n        }\n        assert(poll_res == 1);\n        if (pf[0].revents & (POLLERR | POLLHUP | POLLNVAL)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Unexpected poll revents %x\\n\", __func__,\n                     pf[0].revents);\n            break;\n        }\n        assert(pf[0].revents & POLLIN);\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Got VU event\\n\", __func__);\n        /* Mutual exclusion with fv_queue_thread() */\n        ret = pthread_rwlock_wrlock(&se->virtio_dev->vu_dispatch_rwlock);\n        assert(ret == 0); /* there is no possible error case */\n\n        ok = vu_dispatch(&se->virtio_dev->dev);\n\n        pthread_rwlock_unlock(&se->virtio_dev->vu_dispatch_rwlock);\n\n        if (!ok) {\n            fuse_log(FUSE_LOG_ERR, \"%s: vu_dispatch failed\\n\", __func__);\n            break;\n        }\n    }\n\n    /*\n     * Make sure all fv_queue_thread()s quit on exit, as we're about to\n     * free virtio dev and fuse session, no one should access them anymore.\n     */\n    for (int i = 0; i < se->virtio_dev->nqueues; i++) {\n        if (!se->virtio_dev->qi[i]) {\n            continue;\n        }\n\n        fuse_log(FUSE_LOG_INFO, \"%s: Stopping queue %d thread\\n\", __func__, i);\n        fv_queue_cleanup_thread(se->virtio_dev, i);\n    }\n\n    fuse_log(FUSE_LOG_INFO, \"%s: Exit\\n\", __func__);\n\n    return 0;\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_INFO",
            "\"%s: Exit\\n\"",
            "__func__"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fv_queue_cleanup_thread",
          "args": [
            "se->virtio_dev",
            "i"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "fv_queue_cleanup_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "684-707",
          "snippet": "static void fv_queue_cleanup_thread(struct fv_VuDev *vud, int qidx)\n{\n    int ret;\n    struct fv_QueueInfo *ourqi;\n\n    assert(qidx < vud->nqueues);\n    ourqi = vud->qi[qidx];\n\n    /* Kill the thread */\n    if (eventfd_write(ourqi->kill_fd, 1)) {\n        fuse_log(FUSE_LOG_ERR, \"Eventfd_write for queue %d: %s\\n\",\n                 qidx, strerror(errno));\n    }\n    ret = pthread_join(ourqi->thread, NULL);\n    if (ret) {\n        fuse_log(FUSE_LOG_ERR, \"%s: Failed to join thread idx %d err %d\\n\",\n                 __func__, qidx, ret);\n    }\n    pthread_mutex_destroy(&ourqi->vq_lock);\n    close(ourqi->kill_fd);\n    ourqi->kick_fd = -1;\n    free(vud->qi[qidx]);\n    vud->qi[qidx] = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fv_queue_cleanup_thread(struct fv_VuDev *vud, int qidx)\n{\n    int ret;\n    struct fv_QueueInfo *ourqi;\n\n    assert(qidx < vud->nqueues);\n    ourqi = vud->qi[qidx];\n\n    /* Kill the thread */\n    if (eventfd_write(ourqi->kill_fd, 1)) {\n        fuse_log(FUSE_LOG_ERR, \"Eventfd_write for queue %d: %s\\n\",\n                 qidx, strerror(errno));\n    }\n    ret = pthread_join(ourqi->thread, NULL);\n    if (ret) {\n        fuse_log(FUSE_LOG_ERR, \"%s: Failed to join thread idx %d err %d\\n\",\n                 __func__, qidx, ret);\n    }\n    pthread_mutex_destroy(&ourqi->vq_lock);\n    close(ourqi->kill_fd);\n    ourqi->kick_fd = -1;\n    free(vud->qi[qidx]);\n    vud->qi[qidx] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_unlock",
          "args": [
            "&se->virtio_dev->vu_dispatch_rwlock"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vu_dispatch",
          "args": [
            "&se->virtio_dev->dev"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ret == 0"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_wrlock",
          "args": [
            "&se->virtio_dev->vu_dispatch_rwlock"
          ],
          "line": 820
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pf[0].revents & POLLIN"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "poll_res == 1"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppoll",
          "args": [
            "pf",
            "1",
            "NULL",
            "NULL"
          ],
          "line": 800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_session_exited",
          "args": [
            "se"
          ],
          "line": 791
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nint virtio_loop(struct fuse_session *se)\n{\n    fuse_log(FUSE_LOG_INFO, \"%s: Entry\\n\", __func__);\n\n    while (!fuse_session_exited(se)) {\n        struct pollfd pf[1];\n        bool ok;\n        int ret;\n        pf[0].fd = se->vu_socketfd;\n        pf[0].events = POLLIN;\n        pf[0].revents = 0;\n\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Waiting for VU event\\n\", __func__);\n        int poll_res = ppoll(pf, 1, NULL, NULL);\n\n        if (poll_res == -1) {\n            if (errno == EINTR) {\n                fuse_log(FUSE_LOG_INFO, \"%s: ppoll interrupted, going around\\n\",\n                         __func__);\n                continue;\n            }\n            fuse_log(FUSE_LOG_ERR, \"virtio_loop ppoll: %m\\n\");\n            break;\n        }\n        assert(poll_res == 1);\n        if (pf[0].revents & (POLLERR | POLLHUP | POLLNVAL)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Unexpected poll revents %x\\n\", __func__,\n                     pf[0].revents);\n            break;\n        }\n        assert(pf[0].revents & POLLIN);\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Got VU event\\n\", __func__);\n        /* Mutual exclusion with fv_queue_thread() */\n        ret = pthread_rwlock_wrlock(&se->virtio_dev->vu_dispatch_rwlock);\n        assert(ret == 0); /* there is no possible error case */\n\n        ok = vu_dispatch(&se->virtio_dev->dev);\n\n        pthread_rwlock_unlock(&se->virtio_dev->vu_dispatch_rwlock);\n\n        if (!ok) {\n            fuse_log(FUSE_LOG_ERR, \"%s: vu_dispatch failed\\n\", __func__);\n            break;\n        }\n    }\n\n    /*\n     * Make sure all fv_queue_thread()s quit on exit, as we're about to\n     * free virtio dev and fuse session, no one should access them anymore.\n     */\n    for (int i = 0; i < se->virtio_dev->nqueues; i++) {\n        if (!se->virtio_dev->qi[i]) {\n            continue;\n        }\n\n        fuse_log(FUSE_LOG_INFO, \"%s: Stopping queue %d thread\\n\", __func__, i);\n        fv_queue_cleanup_thread(se->virtio_dev, i);\n    }\n\n    fuse_log(FUSE_LOG_INFO, \"%s: Exit\\n\", __func__);\n\n    return 0;\n}"
  },
  {
    "function_name": "fv_queue_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "768-771",
    "snippet": "static bool fv_queue_order(VuDev *dev, int qidx)\n{\n    return false;\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic bool fv_queue_order(VuDev *dev, int qidx)\n{\n    return false;\n}"
  },
  {
    "function_name": "fv_queue_set_started",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "710-766",
    "snippet": "static void fv_queue_set_started(VuDev *dev, int qidx, bool started)\n{\n    struct fv_VuDev *vud = container_of(dev, struct fv_VuDev, dev);\n    struct fv_QueueInfo *ourqi;\n\n    fuse_log(FUSE_LOG_INFO, \"%s: qidx=%d started=%d\\n\", __func__, qidx,\n             started);\n    assert(qidx >= 0);\n\n    /*\n     * Ignore additional request queues for now.  passthrough_ll.c must be\n     * audited for thread-safety issues first.  It was written with a\n     * well-behaved client in mind and may not protect against all types of\n     * races yet.\n     */\n    if (qidx > 1) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"%s: multiple request queues not yet implemented, please only \"\n                 \"configure 1 request queue\\n\",\n                 __func__);\n        exit(EXIT_FAILURE);\n    }\n\n    if (started) {\n        /* Fire up a thread to watch this queue */\n        if (qidx >= vud->nqueues) {\n            vud->qi = realloc(vud->qi, (qidx + 1) * sizeof(vud->qi[0]));\n            assert(vud->qi);\n            memset(vud->qi + vud->nqueues, 0,\n                   sizeof(vud->qi[0]) * (1 + (qidx - vud->nqueues)));\n            vud->nqueues = qidx + 1;\n        }\n        if (!vud->qi[qidx]) {\n            vud->qi[qidx] = calloc(sizeof(struct fv_QueueInfo), 1);\n            assert(vud->qi[qidx]);\n            vud->qi[qidx]->virtio_dev = vud;\n            vud->qi[qidx]->qidx = qidx;\n        } else {\n            /* Shouldn't have been started */\n            assert(vud->qi[qidx]->kick_fd == -1);\n        }\n        ourqi = vud->qi[qidx];\n        ourqi->kick_fd = dev->vq[qidx].kick_fd;\n\n        ourqi->kill_fd = eventfd(0, EFD_CLOEXEC | EFD_SEMAPHORE);\n        assert(ourqi->kill_fd != -1);\n        pthread_mutex_init(&ourqi->vq_lock, NULL);\n\n        if (pthread_create(&ourqi->thread, NULL, fv_queue_thread, ourqi)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Failed to create thread for queue %d\\n\",\n                     __func__, qidx);\n            assert(0);\n        }\n    } else {\n        fv_queue_cleanup_thread(vud, qidx);\n    }\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fv_queue_cleanup_thread",
          "args": [
            "vud",
            "qidx"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "fv_queue_cleanup_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "684-707",
          "snippet": "static void fv_queue_cleanup_thread(struct fv_VuDev *vud, int qidx)\n{\n    int ret;\n    struct fv_QueueInfo *ourqi;\n\n    assert(qidx < vud->nqueues);\n    ourqi = vud->qi[qidx];\n\n    /* Kill the thread */\n    if (eventfd_write(ourqi->kill_fd, 1)) {\n        fuse_log(FUSE_LOG_ERR, \"Eventfd_write for queue %d: %s\\n\",\n                 qidx, strerror(errno));\n    }\n    ret = pthread_join(ourqi->thread, NULL);\n    if (ret) {\n        fuse_log(FUSE_LOG_ERR, \"%s: Failed to join thread idx %d err %d\\n\",\n                 __func__, qidx, ret);\n    }\n    pthread_mutex_destroy(&ourqi->vq_lock);\n    close(ourqi->kill_fd);\n    ourqi->kick_fd = -1;\n    free(vud->qi[qidx]);\n    vud->qi[qidx] = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fv_queue_cleanup_thread(struct fv_VuDev *vud, int qidx)\n{\n    int ret;\n    struct fv_QueueInfo *ourqi;\n\n    assert(qidx < vud->nqueues);\n    ourqi = vud->qi[qidx];\n\n    /* Kill the thread */\n    if (eventfd_write(ourqi->kill_fd, 1)) {\n        fuse_log(FUSE_LOG_ERR, \"Eventfd_write for queue %d: %s\\n\",\n                 qidx, strerror(errno));\n    }\n    ret = pthread_join(ourqi->thread, NULL);\n    if (ret) {\n        fuse_log(FUSE_LOG_ERR, \"%s: Failed to join thread idx %d err %d\\n\",\n                 __func__, qidx, ret);\n    }\n    pthread_mutex_destroy(&ourqi->vq_lock);\n    close(ourqi->kill_fd);\n    ourqi->kick_fd = -1;\n    free(vud->qi[qidx]);\n    vud->qi[qidx] = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"%s: Failed to create thread for queue %d\\n\"",
            "__func__",
            "qidx"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_create",
          "args": [
            "&ourqi->thread",
            "NULL",
            "fv_queue_thread",
            "ourqi"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_init",
          "args": [
            "&ourqi->vq_lock",
            "NULL"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ourqi->kill_fd != -1"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd",
          "args": [
            "0",
            "EFD_CLOEXEC | EFD_SEMAPHORE"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "vud->qi[qidx]->kick_fd == -1"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "vud->qi[qidx]"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sizeof(struct fv_QueueInfo)",
            "1"
          ],
          "line": 743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "vud->qi + vud->nqueues",
            "0",
            "sizeof(vud->qi[0]) * (1 + (qidx - vud->nqueues))"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "vud->qi"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "realloc",
          "args": [
            "vud->qi",
            "(qidx + 1) * sizeof(vud->qi[0])"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 730
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "qidx >= 0"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dev",
            "structfv_VuDev",
            "dev"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fv_queue_set_started(VuDev *dev, int qidx, bool started)\n{\n    struct fv_VuDev *vud = container_of(dev, struct fv_VuDev, dev);\n    struct fv_QueueInfo *ourqi;\n\n    fuse_log(FUSE_LOG_INFO, \"%s: qidx=%d started=%d\\n\", __func__, qidx,\n             started);\n    assert(qidx >= 0);\n\n    /*\n     * Ignore additional request queues for now.  passthrough_ll.c must be\n     * audited for thread-safety issues first.  It was written with a\n     * well-behaved client in mind and may not protect against all types of\n     * races yet.\n     */\n    if (qidx > 1) {\n        fuse_log(FUSE_LOG_ERR,\n                 \"%s: multiple request queues not yet implemented, please only \"\n                 \"configure 1 request queue\\n\",\n                 __func__);\n        exit(EXIT_FAILURE);\n    }\n\n    if (started) {\n        /* Fire up a thread to watch this queue */\n        if (qidx >= vud->nqueues) {\n            vud->qi = realloc(vud->qi, (qidx + 1) * sizeof(vud->qi[0]));\n            assert(vud->qi);\n            memset(vud->qi + vud->nqueues, 0,\n                   sizeof(vud->qi[0]) * (1 + (qidx - vud->nqueues)));\n            vud->nqueues = qidx + 1;\n        }\n        if (!vud->qi[qidx]) {\n            vud->qi[qidx] = calloc(sizeof(struct fv_QueueInfo), 1);\n            assert(vud->qi[qidx]);\n            vud->qi[qidx]->virtio_dev = vud;\n            vud->qi[qidx]->qidx = qidx;\n        } else {\n            /* Shouldn't have been started */\n            assert(vud->qi[qidx]->kick_fd == -1);\n        }\n        ourqi = vud->qi[qidx];\n        ourqi->kick_fd = dev->vq[qidx].kick_fd;\n\n        ourqi->kill_fd = eventfd(0, EFD_CLOEXEC | EFD_SEMAPHORE);\n        assert(ourqi->kill_fd != -1);\n        pthread_mutex_init(&ourqi->vq_lock, NULL);\n\n        if (pthread_create(&ourqi->thread, NULL, fv_queue_thread, ourqi)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Failed to create thread for queue %d\\n\",\n                     __func__, qidx);\n            assert(0);\n        }\n    } else {\n        fv_queue_cleanup_thread(vud, qidx);\n    }\n}"
  },
  {
    "function_name": "fv_queue_cleanup_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "684-707",
    "snippet": "static void fv_queue_cleanup_thread(struct fv_VuDev *vud, int qidx)\n{\n    int ret;\n    struct fv_QueueInfo *ourqi;\n\n    assert(qidx < vud->nqueues);\n    ourqi = vud->qi[qidx];\n\n    /* Kill the thread */\n    if (eventfd_write(ourqi->kill_fd, 1)) {\n        fuse_log(FUSE_LOG_ERR, \"Eventfd_write for queue %d: %s\\n\",\n                 qidx, strerror(errno));\n    }\n    ret = pthread_join(ourqi->thread, NULL);\n    if (ret) {\n        fuse_log(FUSE_LOG_ERR, \"%s: Failed to join thread idx %d err %d\\n\",\n                 __func__, qidx, ret);\n    }\n    pthread_mutex_destroy(&ourqi->vq_lock);\n    close(ourqi->kill_fd);\n    ourqi->kick_fd = -1;\n    free(vud->qi[qidx]);\n    vud->qi[qidx] = NULL;\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "vud->qi[qidx]"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "ourqi->kill_fd"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_destroy",
          "args": [
            "&ourqi->vq_lock"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"%s: Failed to join thread idx %d err %d\\n\"",
            "__func__",
            "qidx",
            "ret"
          ],
          "line": 699
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_join",
          "args": [
            "ourqi->thread",
            "NULL"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_write",
          "args": [
            "ourqi->kill_fd",
            "1"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "qidx < vud->nqueues"
          ],
          "line": 689
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fv_queue_cleanup_thread(struct fv_VuDev *vud, int qidx)\n{\n    int ret;\n    struct fv_QueueInfo *ourqi;\n\n    assert(qidx < vud->nqueues);\n    ourqi = vud->qi[qidx];\n\n    /* Kill the thread */\n    if (eventfd_write(ourqi->kill_fd, 1)) {\n        fuse_log(FUSE_LOG_ERR, \"Eventfd_write for queue %d: %s\\n\",\n                 qidx, strerror(errno));\n    }\n    ret = pthread_join(ourqi->thread, NULL);\n    if (ret) {\n        fuse_log(FUSE_LOG_ERR, \"%s: Failed to join thread idx %d err %d\\n\",\n                 __func__, qidx, ret);\n    }\n    pthread_mutex_destroy(&ourqi->vq_lock);\n    close(ourqi->kill_fd);\n    ourqi->kick_fd = -1;\n    free(vud->qi[qidx]);\n    vud->qi[qidx] = NULL;\n}"
  },
  {
    "function_name": "fv_queue_thread",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "585-682",
    "snippet": "static void *fv_queue_thread(void *opaque)\n{\n    struct fv_QueueInfo *qi = opaque;\n    struct VuDev *dev = &qi->virtio_dev->dev;\n    struct VuVirtq *q = vu_get_queue(dev, qi->qidx);\n    struct fuse_session *se = qi->virtio_dev->se;\n    GThreadPool *pool;\n\n    pool = g_thread_pool_new(fv_queue_worker, qi, se->thread_pool_size, FALSE,\n                             NULL);\n    if (!pool) {\n        fuse_log(FUSE_LOG_ERR, \"%s: g_thread_pool_new failed\\n\", __func__);\n        return NULL;\n    }\n\n    fuse_log(FUSE_LOG_INFO, \"%s: Start for queue %d kick_fd %d\\n\", __func__,\n             qi->qidx, qi->kick_fd);\n    while (1) {\n        struct pollfd pf[2];\n        int ret;\n\n        pf[0].fd = qi->kick_fd;\n        pf[0].events = POLLIN;\n        pf[0].revents = 0;\n        pf[1].fd = qi->kill_fd;\n        pf[1].events = POLLIN;\n        pf[1].revents = 0;\n\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Waiting for Queue %d event\\n\", __func__,\n                 qi->qidx);\n        int poll_res = ppoll(pf, 2, NULL, NULL);\n\n        if (poll_res == -1) {\n            if (errno == EINTR) {\n                fuse_log(FUSE_LOG_INFO, \"%s: ppoll interrupted, going around\\n\",\n                         __func__);\n                continue;\n            }\n            fuse_log(FUSE_LOG_ERR, \"fv_queue_thread ppoll: %m\\n\");\n            break;\n        }\n        assert(poll_res >= 1);\n        if (pf[0].revents & (POLLERR | POLLHUP | POLLNVAL)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Unexpected poll revents %x Queue %d\\n\",\n                     __func__, pf[0].revents, qi->qidx);\n            break;\n        }\n        if (pf[1].revents & (POLLERR | POLLHUP | POLLNVAL)) {\n            fuse_log(FUSE_LOG_ERR,\n                     \"%s: Unexpected poll revents %x Queue %d killfd\\n\",\n                     __func__, pf[1].revents, qi->qidx);\n            break;\n        }\n        if (pf[1].revents) {\n            fuse_log(FUSE_LOG_INFO, \"%s: kill event on queue %d - quitting\\n\",\n                     __func__, qi->qidx);\n            break;\n        }\n        assert(pf[0].revents & POLLIN);\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Got queue event on Queue %d\\n\", __func__,\n                 qi->qidx);\n\n        eventfd_t evalue;\n        if (eventfd_read(qi->kick_fd, &evalue)) {\n            fuse_log(FUSE_LOG_ERR, \"Eventfd_read for queue: %m\\n\");\n            break;\n        }\n        /* Mutual exclusion with virtio_loop() */\n        ret = pthread_rwlock_rdlock(&qi->virtio_dev->vu_dispatch_rwlock);\n        assert(ret == 0); /* there is no possible error case */\n        pthread_mutex_lock(&qi->vq_lock);\n        /* out is from guest, in is too guest */\n        unsigned int in_bytes, out_bytes;\n        vu_queue_get_avail_bytes(dev, q, &in_bytes, &out_bytes, ~0, ~0);\n\n        fuse_log(FUSE_LOG_DEBUG,\n                 \"%s: Queue %d gave evalue: %zx available: in: %u out: %u\\n\",\n                 __func__, qi->qidx, (size_t)evalue, in_bytes, out_bytes);\n\n        while (1) {\n            FVRequest *req = vu_queue_pop(dev, q, sizeof(FVRequest));\n            if (!req) {\n                break;\n            }\n\n            req->reply_sent = false;\n\n            g_thread_pool_push(pool, req, NULL);\n        }\n\n        pthread_mutex_unlock(&qi->vq_lock);\n        pthread_rwlock_unlock(&qi->virtio_dev->vu_dispatch_rwlock);\n    }\n\n    g_thread_pool_free(pool, FALSE, TRUE);\n\n    return NULL;\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "g_thread_pool_free",
          "args": [
            "pool",
            "FALSE",
            "TRUE"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_unlock",
          "args": [
            "&qi->virtio_dev->vu_dispatch_rwlock"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&qi->vq_lock"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_thread_pool_push",
          "args": [
            "pool",
            "req",
            "NULL"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vu_queue_pop",
          "args": [
            "dev",
            "q",
            "sizeof(FVRequest)"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"%s: Queue %d gave evalue: %zx available: in: %u out: %u\\n\"",
            "__func__",
            "qi->qidx",
            "(size_t)evalue",
            "in_bytes",
            "out_bytes"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vu_queue_get_avail_bytes",
          "args": [
            "dev",
            "q",
            "&in_bytes",
            "&out_bytes",
            "~0",
            "~0"
          ],
          "line": 658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&qi->vq_lock"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ret == 0"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_rdlock",
          "args": [
            "&qi->virtio_dev->vu_dispatch_rwlock"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eventfd_read",
          "args": [
            "qi->kick_fd",
            "&evalue"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "pf[0].revents & POLLIN"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "poll_res >= 1"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ppoll",
          "args": [
            "pf",
            "2",
            "NULL",
            "NULL"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_thread_pool_new",
          "args": [
            "fv_queue_worker",
            "qi",
            "se->thread_pool_size",
            "FALSE",
            "NULL"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vu_get_queue",
          "args": [
            "dev",
            "qi->qidx"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void *fv_queue_thread(void *opaque)\n{\n    struct fv_QueueInfo *qi = opaque;\n    struct VuDev *dev = &qi->virtio_dev->dev;\n    struct VuVirtq *q = vu_get_queue(dev, qi->qidx);\n    struct fuse_session *se = qi->virtio_dev->se;\n    GThreadPool *pool;\n\n    pool = g_thread_pool_new(fv_queue_worker, qi, se->thread_pool_size, FALSE,\n                             NULL);\n    if (!pool) {\n        fuse_log(FUSE_LOG_ERR, \"%s: g_thread_pool_new failed\\n\", __func__);\n        return NULL;\n    }\n\n    fuse_log(FUSE_LOG_INFO, \"%s: Start for queue %d kick_fd %d\\n\", __func__,\n             qi->qidx, qi->kick_fd);\n    while (1) {\n        struct pollfd pf[2];\n        int ret;\n\n        pf[0].fd = qi->kick_fd;\n        pf[0].events = POLLIN;\n        pf[0].revents = 0;\n        pf[1].fd = qi->kill_fd;\n        pf[1].events = POLLIN;\n        pf[1].revents = 0;\n\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Waiting for Queue %d event\\n\", __func__,\n                 qi->qidx);\n        int poll_res = ppoll(pf, 2, NULL, NULL);\n\n        if (poll_res == -1) {\n            if (errno == EINTR) {\n                fuse_log(FUSE_LOG_INFO, \"%s: ppoll interrupted, going around\\n\",\n                         __func__);\n                continue;\n            }\n            fuse_log(FUSE_LOG_ERR, \"fv_queue_thread ppoll: %m\\n\");\n            break;\n        }\n        assert(poll_res >= 1);\n        if (pf[0].revents & (POLLERR | POLLHUP | POLLNVAL)) {\n            fuse_log(FUSE_LOG_ERR, \"%s: Unexpected poll revents %x Queue %d\\n\",\n                     __func__, pf[0].revents, qi->qidx);\n            break;\n        }\n        if (pf[1].revents & (POLLERR | POLLHUP | POLLNVAL)) {\n            fuse_log(FUSE_LOG_ERR,\n                     \"%s: Unexpected poll revents %x Queue %d killfd\\n\",\n                     __func__, pf[1].revents, qi->qidx);\n            break;\n        }\n        if (pf[1].revents) {\n            fuse_log(FUSE_LOG_INFO, \"%s: kill event on queue %d - quitting\\n\",\n                     __func__, qi->qidx);\n            break;\n        }\n        assert(pf[0].revents & POLLIN);\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Got queue event on Queue %d\\n\", __func__,\n                 qi->qidx);\n\n        eventfd_t evalue;\n        if (eventfd_read(qi->kick_fd, &evalue)) {\n            fuse_log(FUSE_LOG_ERR, \"Eventfd_read for queue: %m\\n\");\n            break;\n        }\n        /* Mutual exclusion with virtio_loop() */\n        ret = pthread_rwlock_rdlock(&qi->virtio_dev->vu_dispatch_rwlock);\n        assert(ret == 0); /* there is no possible error case */\n        pthread_mutex_lock(&qi->vq_lock);\n        /* out is from guest, in is too guest */\n        unsigned int in_bytes, out_bytes;\n        vu_queue_get_avail_bytes(dev, q, &in_bytes, &out_bytes, ~0, ~0);\n\n        fuse_log(FUSE_LOG_DEBUG,\n                 \"%s: Queue %d gave evalue: %zx available: in: %u out: %u\\n\",\n                 __func__, qi->qidx, (size_t)evalue, in_bytes, out_bytes);\n\n        while (1) {\n            FVRequest *req = vu_queue_pop(dev, q, sizeof(FVRequest));\n            if (!req) {\n                break;\n            }\n\n            req->reply_sent = false;\n\n            g_thread_pool_push(pool, req, NULL);\n        }\n\n        pthread_mutex_unlock(&qi->vq_lock);\n        pthread_rwlock_unlock(&qi->virtio_dev->vu_dispatch_rwlock);\n    }\n\n    g_thread_pool_free(pool, FALSE, TRUE);\n\n    return NULL;\n}"
  },
  {
    "function_name": "fv_queue_worker",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "434-582",
    "snippet": "static void fv_queue_worker(gpointer data, gpointer user_data)\n{\n    struct fv_QueueInfo *qi = user_data;\n    struct fuse_session *se = qi->virtio_dev->se;\n    struct VuDev *dev = &qi->virtio_dev->dev;\n    FVRequest *req = data;\n    VuVirtqElement *elem = &req->elem;\n    struct fuse_buf fbuf = {};\n    bool allocated_bufv = false;\n    struct fuse_bufvec bufv;\n    struct fuse_bufvec *pbufv;\n\n    assert(se->bufsize > sizeof(struct fuse_in_header));\n\n    if (!clone_fs_called) {\n        int ret;\n\n        /* unshare FS for xattr operation */\n        ret = unshare(CLONE_FS);\n        /* should not fail */\n        assert(ret == 0);\n\n        clone_fs_called = true;\n    }\n\n    /*\n     * An element contains one request and the space to send our response\n     * They're spread over multiple descriptors in a scatter/gather set\n     * and we can't trust the guest to keep them still; so copy in/out.\n     */\n    fbuf.mem = malloc(se->bufsize);\n    assert(fbuf.mem);\n\n    fuse_mutex_init(&req->ch.lock);\n    req->ch.fd = -1;\n    req->ch.qi = qi;\n\n    /* The 'out' part of the elem is from qemu */\n    unsigned int out_num = elem->out_num;\n    struct iovec *out_sg = elem->out_sg;\n    size_t out_len = iov_size(out_sg, out_num);\n    fuse_log(FUSE_LOG_DEBUG,\n             \"%s: elem %d: with %d out desc of length %zd\\n\",\n             __func__, elem->index, out_num, out_len);\n\n    /*\n     * The elem should contain a 'fuse_in_header' (in to fuse)\n     * plus the data based on the len in the header.\n     */\n    if (out_len < sizeof(struct fuse_in_header)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: elem %d too short for in_header\\n\",\n                 __func__, elem->index);\n        assert(0); /* TODO */\n    }\n    if (out_len > se->bufsize) {\n        fuse_log(FUSE_LOG_ERR, \"%s: elem %d too large for buffer\\n\", __func__,\n                 elem->index);\n        assert(0); /* TODO */\n    }\n    /* Copy just the first element and look at it */\n    copy_from_iov(&fbuf, 1, out_sg);\n\n    pbufv = NULL; /* Compiler thinks an unitialised path */\n    if (out_num > 2 &&\n        out_sg[0].iov_len == sizeof(struct fuse_in_header) &&\n        ((struct fuse_in_header *)fbuf.mem)->opcode == FUSE_WRITE &&\n        out_sg[1].iov_len == sizeof(struct fuse_write_in)) {\n        /*\n         * For a write we don't actually need to copy the\n         * data, we can just do it straight out of guest memory\n         * but we must still copy the headers in case the guest\n         * was nasty and changed them while we were using them.\n         */\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Write special case\\n\", __func__);\n\n        /* copy the fuse_write_in header afte rthe fuse_in_header */\n        fbuf.mem += out_sg->iov_len;\n        copy_from_iov(&fbuf, 1, out_sg + 1);\n        fbuf.mem -= out_sg->iov_len;\n        fbuf.size = out_sg[0].iov_len + out_sg[1].iov_len;\n\n        /* Allocate the bufv, with space for the rest of the iov */\n        pbufv = malloc(sizeof(struct fuse_bufvec) +\n                       sizeof(struct fuse_buf) * (out_num - 2));\n        if (!pbufv) {\n            fuse_log(FUSE_LOG_ERR, \"%s: pbufv malloc failed\\n\",\n                    __func__);\n            goto out;\n        }\n\n        allocated_bufv = true;\n        pbufv->count = 1;\n        pbufv->buf[0] = fbuf;\n\n        size_t iovindex, pbufvindex;\n        iovindex = 2; /* 2 headers, separate iovs */\n        pbufvindex = 1; /* 2 headers, 1 fusebuf */\n\n        for (; iovindex < out_num; iovindex++, pbufvindex++) {\n            pbufv->count++;\n            pbufv->buf[pbufvindex].pos = ~0; /* Dummy */\n            pbufv->buf[pbufvindex].flags = 0;\n            pbufv->buf[pbufvindex].mem = out_sg[iovindex].iov_base;\n            pbufv->buf[pbufvindex].size = out_sg[iovindex].iov_len;\n        }\n    } else {\n        /* Normal (non fast write) path */\n\n        /* Copy the rest of the buffer */\n        fbuf.mem += out_sg->iov_len;\n        copy_from_iov(&fbuf, out_num - 1, out_sg + 1);\n        fbuf.mem -= out_sg->iov_len;\n        fbuf.size = out_len;\n\n        /* TODO! Endianness of header */\n\n        /* TODO: Add checks for fuse_session_exited */\n        bufv.buf[0] = fbuf;\n        bufv.count = 1;\n        pbufv = &bufv;\n    }\n    pbufv->idx = 0;\n    pbufv->off = 0;\n    fuse_session_process_buf_int(se, pbufv, &req->ch);\n\nout:\n    if (allocated_bufv) {\n        free(pbufv);\n    }\n\n    /* If the request has no reply, still recycle the virtqueue element */\n    if (!req->reply_sent) {\n        struct VuVirtq *q = vu_get_queue(dev, qi->qidx);\n\n        fuse_log(FUSE_LOG_DEBUG, \"%s: elem %d no reply sent\\n\", __func__,\n                 elem->index);\n\n        pthread_rwlock_rdlock(&qi->virtio_dev->vu_dispatch_rwlock);\n        pthread_mutex_lock(&qi->vq_lock);\n        vu_queue_push(dev, q, elem, 0);\n        vu_queue_notify(dev, q);\n        pthread_mutex_unlock(&qi->vq_lock);\n        pthread_rwlock_unlock(&qi->virtio_dev->vu_dispatch_rwlock);\n    }\n\n    pthread_mutex_destroy(&req->ch.lock);\n    free(fbuf.mem);\n    free(req);\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static __thread bool clone_fs_called;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "req"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_mutex_destroy",
          "args": [
            "&req->ch.lock"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_unlock",
          "args": [
            "&qi->virtio_dev->vu_dispatch_rwlock"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&qi->vq_lock"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vu_queue_notify",
          "args": [
            "dev",
            "q"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vu_queue_push",
          "args": [
            "dev",
            "q",
            "elem",
            "0"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&qi->vq_lock"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_rdlock",
          "args": [
            "&qi->virtio_dev->vu_dispatch_rwlock"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"%s: elem %d no reply sent\\n\"",
            "__func__",
            "elem->index"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "vu_get_queue",
          "args": [
            "dev",
            "qi->qidx"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_session_process_buf_int",
          "args": [
            "se",
            "pbufv",
            "&req->ch"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_process_buf_int",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2393-2513",
          "snippet": "void fuse_session_process_buf_int(struct fuse_session *se,\n                                  struct fuse_bufvec *bufv,\n                                  struct fuse_chan *ch)\n{\n    const struct fuse_buf *buf = bufv->buf;\n    struct fuse_mbuf_iter iter = FUSE_MBUF_ITER_INIT(buf);\n    struct fuse_in_header *in;\n    struct fuse_req *req;\n    int err;\n\n    /* The first buffer must be a memory buffer */\n    assert(!(buf->flags & FUSE_BUF_IS_FD));\n\n    in = fuse_mbuf_iter_advance(&iter, sizeof(*in));\n    assert(in); /* caller guarantees the input buffer is large enough */\n\n    fuse_log(\n        FUSE_LOG_DEBUG,\n        \"unique: %llu, opcode: %s (%i), nodeid: %llu, insize: %zu, pid: %u\\n\",\n        (unsigned long long)in->unique, opname((enum fuse_opcode)in->opcode),\n        in->opcode, (unsigned long long)in->nodeid, buf->size, in->pid);\n\n    req = fuse_ll_alloc_req(se);\n    if (req == NULL) {\n        struct fuse_out_header out = {\n            .unique = in->unique,\n            .error = -ENOMEM,\n        };\n        struct iovec iov = {\n            .iov_base = &out,\n            .iov_len = sizeof(struct fuse_out_header),\n        };\n\n        fuse_send_msg(se, ch, &iov, 1);\n        return;\n    }\n\n    req->unique = in->unique;\n    req->ctx.uid = in->uid;\n    req->ctx.gid = in->gid;\n    req->ctx.pid = in->pid;\n    req->ch = ch;\n\n    /*\n     * INIT and DESTROY requests are serialized, all other request types\n     * run in parallel.  This prevents races between FUSE_INIT and ordinary\n     * requests, FUSE_INIT and FUSE_INIT, FUSE_INIT and FUSE_DESTROY, and\n     * FUSE_DESTROY and FUSE_DESTROY.\n     */\n    if (in->opcode == FUSE_INIT || in->opcode == CUSE_INIT ||\n        in->opcode == FUSE_DESTROY) {\n        pthread_rwlock_wrlock(&se->init_rwlock);\n    } else {\n        pthread_rwlock_rdlock(&se->init_rwlock);\n    }\n\n    err = EIO;\n    if (!se->got_init) {\n        enum fuse_opcode expected;\n\n        expected = se->cuse_data ? CUSE_INIT : FUSE_INIT;\n        if (in->opcode != expected) {\n            goto reply_err;\n        }\n    } else if (in->opcode == FUSE_INIT || in->opcode == CUSE_INIT) {\n        if (fuse_lowlevel_is_virtio(se)) {\n            /*\n             * TODO: This is after a hard reboot typically, we need to do\n             * a destroy, but we can't reply to this request yet so\n             * we can't use do_destroy\n             */\n            fuse_log(FUSE_LOG_DEBUG, \"%s: reinit\\n\", __func__);\n            se->got_destroy = 1;\n            se->got_init = 0;\n            if (se->op.destroy) {\n                se->op.destroy(se->userdata);\n            }\n        } else {\n            goto reply_err;\n        }\n    }\n\n    err = EACCES;\n    /* Implement -o allow_root */\n    if (se->deny_others && in->uid != se->owner && in->uid != 0 &&\n        in->opcode != FUSE_INIT && in->opcode != FUSE_READ &&\n        in->opcode != FUSE_WRITE && in->opcode != FUSE_FSYNC &&\n        in->opcode != FUSE_RELEASE && in->opcode != FUSE_READDIR &&\n        in->opcode != FUSE_FSYNCDIR && in->opcode != FUSE_RELEASEDIR &&\n        in->opcode != FUSE_NOTIFY_REPLY && in->opcode != FUSE_READDIRPLUS) {\n        goto reply_err;\n    }\n\n    err = ENOSYS;\n    if (in->opcode >= FUSE_MAXOP || !fuse_ll_ops[in->opcode].func) {\n        goto reply_err;\n    }\n    if (in->opcode != FUSE_INTERRUPT) {\n        struct fuse_req *intr;\n        pthread_mutex_lock(&se->lock);\n        intr = check_interrupt(se, req);\n        list_add_req(req, &se->list);\n        pthread_mutex_unlock(&se->lock);\n        if (intr) {\n            fuse_reply_err(intr, EAGAIN);\n        }\n    }\n\n    if (in->opcode == FUSE_WRITE && se->op.write_buf) {\n        do_write_buf(req, in->nodeid, &iter, bufv);\n    } else {\n        fuse_ll_ops[in->opcode].func(req, in->nodeid, &iter);\n    }\n\n    pthread_rwlock_unlock(&se->init_rwlock);\n    return;\n\nreply_err:\n    fuse_reply_err(req, err);\n    pthread_rwlock_unlock(&se->init_rwlock);\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [
            "#define FUSE_MAXOP (sizeof(fuse_ll_ops) / sizeof(fuse_ll_ops[0]))"
          ],
          "globals_used": [
            "static struct {\n    void (*func)(fuse_req_t, fuse_ino_t, struct fuse_mbuf_iter *);\n    const char *name;\n} fuse_ll_ops[] = {\n    [FUSE_LOOKUP] = { do_lookup, \"LOOKUP\" },\n    [FUSE_FORGET] = { do_forget, \"FORGET\" },\n    [FUSE_GETATTR] = { do_getattr, \"GETATTR\" },\n    [FUSE_SETATTR] = { do_setattr, \"SETATTR\" },\n    [FUSE_READLINK] = { do_readlink, \"READLINK\" },\n    [FUSE_SYMLINK] = { do_symlink, \"SYMLINK\" },\n    [FUSE_MKNOD] = { do_mknod, \"MKNOD\" },\n    [FUSE_MKDIR] = { do_mkdir, \"MKDIR\" },\n    [FUSE_UNLINK] = { do_unlink, \"UNLINK\" },\n    [FUSE_RMDIR] = { do_rmdir, \"RMDIR\" },\n    [FUSE_RENAME] = { do_rename, \"RENAME\" },\n    [FUSE_LINK] = { do_link, \"LINK\" },\n    [FUSE_OPEN] = { do_open, \"OPEN\" },\n    [FUSE_READ] = { do_read, \"READ\" },\n    [FUSE_WRITE] = { do_write, \"WRITE\" },\n    [FUSE_STATFS] = { do_statfs, \"STATFS\" },\n    [FUSE_RELEASE] = { do_release, \"RELEASE\" },\n    [FUSE_FSYNC] = { do_fsync, \"FSYNC\" },\n    [FUSE_SETXATTR] = { do_setxattr, \"SETXATTR\" },\n    [FUSE_GETXATTR] = { do_getxattr, \"GETXATTR\" },\n    [FUSE_LISTXATTR] = { do_listxattr, \"LISTXATTR\" },\n    [FUSE_REMOVEXATTR] = { do_removexattr, \"REMOVEXATTR\" },\n    [FUSE_FLUSH] = { do_flush, \"FLUSH\" },\n    [FUSE_INIT] = { do_init, \"INIT\" },\n    [FUSE_OPENDIR] = { do_opendir, \"OPENDIR\" },\n    [FUSE_READDIR] = { do_readdir, \"READDIR\" },\n    [FUSE_RELEASEDIR] = { do_releasedir, \"RELEASEDIR\" },\n    [FUSE_FSYNCDIR] = { do_fsyncdir, \"FSYNCDIR\" },\n    [FUSE_GETLK] = { do_getlk, \"GETLK\" },\n    [FUSE_SETLK] = { do_setlk, \"SETLK\" },\n    [FUSE_SETLKW] = { do_setlkw, \"SETLKW\" },\n    [FUSE_ACCESS] = { do_access, \"ACCESS\" },\n    [FUSE_CREATE] = { do_create, \"CREATE\" },\n    [FUSE_INTERRUPT] = { do_interrupt, \"INTERRUPT\" },\n    [FUSE_BMAP] = { do_bmap, \"BMAP\" },\n    [FUSE_IOCTL] = { do_ioctl, \"IOCTL\" },\n    [FUSE_POLL] = { do_poll, \"POLL\" },\n    [FUSE_FALLOCATE] = { do_fallocate, \"FALLOCATE\" },\n    [FUSE_DESTROY] = { do_destroy, \"DESTROY\" },\n    [FUSE_NOTIFY_REPLY] = { NULL, \"NOTIFY_REPLY\" },\n    [FUSE_BATCH_FORGET] = { do_batch_forget, \"BATCH_FORGET\" },\n    [FUSE_READDIRPLUS] = { do_readdirplus, \"READDIRPLUS\" },\n    [FUSE_RENAME2] = { do_rename2, \"RENAME2\" },\n    [FUSE_COPY_FILE_RANGE] = { do_copy_file_range, \"COPY_FILE_RANGE\" },\n    [FUSE_LSEEK] = { do_lseek, \"LSEEK\" },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\n#define FUSE_MAXOP (sizeof(fuse_ll_ops) / sizeof(fuse_ll_ops[0]))\n\nstatic struct {\n    void (*func)(fuse_req_t, fuse_ino_t, struct fuse_mbuf_iter *);\n    const char *name;\n} fuse_ll_ops[] = {\n    [FUSE_LOOKUP] = { do_lookup, \"LOOKUP\" },\n    [FUSE_FORGET] = { do_forget, \"FORGET\" },\n    [FUSE_GETATTR] = { do_getattr, \"GETATTR\" },\n    [FUSE_SETATTR] = { do_setattr, \"SETATTR\" },\n    [FUSE_READLINK] = { do_readlink, \"READLINK\" },\n    [FUSE_SYMLINK] = { do_symlink, \"SYMLINK\" },\n    [FUSE_MKNOD] = { do_mknod, \"MKNOD\" },\n    [FUSE_MKDIR] = { do_mkdir, \"MKDIR\" },\n    [FUSE_UNLINK] = { do_unlink, \"UNLINK\" },\n    [FUSE_RMDIR] = { do_rmdir, \"RMDIR\" },\n    [FUSE_RENAME] = { do_rename, \"RENAME\" },\n    [FUSE_LINK] = { do_link, \"LINK\" },\n    [FUSE_OPEN] = { do_open, \"OPEN\" },\n    [FUSE_READ] = { do_read, \"READ\" },\n    [FUSE_WRITE] = { do_write, \"WRITE\" },\n    [FUSE_STATFS] = { do_statfs, \"STATFS\" },\n    [FUSE_RELEASE] = { do_release, \"RELEASE\" },\n    [FUSE_FSYNC] = { do_fsync, \"FSYNC\" },\n    [FUSE_SETXATTR] = { do_setxattr, \"SETXATTR\" },\n    [FUSE_GETXATTR] = { do_getxattr, \"GETXATTR\" },\n    [FUSE_LISTXATTR] = { do_listxattr, \"LISTXATTR\" },\n    [FUSE_REMOVEXATTR] = { do_removexattr, \"REMOVEXATTR\" },\n    [FUSE_FLUSH] = { do_flush, \"FLUSH\" },\n    [FUSE_INIT] = { do_init, \"INIT\" },\n    [FUSE_OPENDIR] = { do_opendir, \"OPENDIR\" },\n    [FUSE_READDIR] = { do_readdir, \"READDIR\" },\n    [FUSE_RELEASEDIR] = { do_releasedir, \"RELEASEDIR\" },\n    [FUSE_FSYNCDIR] = { do_fsyncdir, \"FSYNCDIR\" },\n    [FUSE_GETLK] = { do_getlk, \"GETLK\" },\n    [FUSE_SETLK] = { do_setlk, \"SETLK\" },\n    [FUSE_SETLKW] = { do_setlkw, \"SETLKW\" },\n    [FUSE_ACCESS] = { do_access, \"ACCESS\" },\n    [FUSE_CREATE] = { do_create, \"CREATE\" },\n    [FUSE_INTERRUPT] = { do_interrupt, \"INTERRUPT\" },\n    [FUSE_BMAP] = { do_bmap, \"BMAP\" },\n    [FUSE_IOCTL] = { do_ioctl, \"IOCTL\" },\n    [FUSE_POLL] = { do_poll, \"POLL\" },\n    [FUSE_FALLOCATE] = { do_fallocate, \"FALLOCATE\" },\n    [FUSE_DESTROY] = { do_destroy, \"DESTROY\" },\n    [FUSE_NOTIFY_REPLY] = { NULL, \"NOTIFY_REPLY\" },\n    [FUSE_BATCH_FORGET] = { do_batch_forget, \"BATCH_FORGET\" },\n    [FUSE_READDIRPLUS] = { do_readdirplus, \"READDIRPLUS\" },\n    [FUSE_RENAME2] = { do_rename2, \"RENAME2\" },\n    [FUSE_COPY_FILE_RANGE] = { do_copy_file_range, \"COPY_FILE_RANGE\" },\n    [FUSE_LSEEK] = { do_lseek, \"LSEEK\" },\n};\n\nvoid fuse_session_process_buf_int(struct fuse_session *se,\n                                  struct fuse_bufvec *bufv,\n                                  struct fuse_chan *ch)\n{\n    const struct fuse_buf *buf = bufv->buf;\n    struct fuse_mbuf_iter iter = FUSE_MBUF_ITER_INIT(buf);\n    struct fuse_in_header *in;\n    struct fuse_req *req;\n    int err;\n\n    /* The first buffer must be a memory buffer */\n    assert(!(buf->flags & FUSE_BUF_IS_FD));\n\n    in = fuse_mbuf_iter_advance(&iter, sizeof(*in));\n    assert(in); /* caller guarantees the input buffer is large enough */\n\n    fuse_log(\n        FUSE_LOG_DEBUG,\n        \"unique: %llu, opcode: %s (%i), nodeid: %llu, insize: %zu, pid: %u\\n\",\n        (unsigned long long)in->unique, opname((enum fuse_opcode)in->opcode),\n        in->opcode, (unsigned long long)in->nodeid, buf->size, in->pid);\n\n    req = fuse_ll_alloc_req(se);\n    if (req == NULL) {\n        struct fuse_out_header out = {\n            .unique = in->unique,\n            .error = -ENOMEM,\n        };\n        struct iovec iov = {\n            .iov_base = &out,\n            .iov_len = sizeof(struct fuse_out_header),\n        };\n\n        fuse_send_msg(se, ch, &iov, 1);\n        return;\n    }\n\n    req->unique = in->unique;\n    req->ctx.uid = in->uid;\n    req->ctx.gid = in->gid;\n    req->ctx.pid = in->pid;\n    req->ch = ch;\n\n    /*\n     * INIT and DESTROY requests are serialized, all other request types\n     * run in parallel.  This prevents races between FUSE_INIT and ordinary\n     * requests, FUSE_INIT and FUSE_INIT, FUSE_INIT and FUSE_DESTROY, and\n     * FUSE_DESTROY and FUSE_DESTROY.\n     */\n    if (in->opcode == FUSE_INIT || in->opcode == CUSE_INIT ||\n        in->opcode == FUSE_DESTROY) {\n        pthread_rwlock_wrlock(&se->init_rwlock);\n    } else {\n        pthread_rwlock_rdlock(&se->init_rwlock);\n    }\n\n    err = EIO;\n    if (!se->got_init) {\n        enum fuse_opcode expected;\n\n        expected = se->cuse_data ? CUSE_INIT : FUSE_INIT;\n        if (in->opcode != expected) {\n            goto reply_err;\n        }\n    } else if (in->opcode == FUSE_INIT || in->opcode == CUSE_INIT) {\n        if (fuse_lowlevel_is_virtio(se)) {\n            /*\n             * TODO: This is after a hard reboot typically, we need to do\n             * a destroy, but we can't reply to this request yet so\n             * we can't use do_destroy\n             */\n            fuse_log(FUSE_LOG_DEBUG, \"%s: reinit\\n\", __func__);\n            se->got_destroy = 1;\n            se->got_init = 0;\n            if (se->op.destroy) {\n                se->op.destroy(se->userdata);\n            }\n        } else {\n            goto reply_err;\n        }\n    }\n\n    err = EACCES;\n    /* Implement -o allow_root */\n    if (se->deny_others && in->uid != se->owner && in->uid != 0 &&\n        in->opcode != FUSE_INIT && in->opcode != FUSE_READ &&\n        in->opcode != FUSE_WRITE && in->opcode != FUSE_FSYNC &&\n        in->opcode != FUSE_RELEASE && in->opcode != FUSE_READDIR &&\n        in->opcode != FUSE_FSYNCDIR && in->opcode != FUSE_RELEASEDIR &&\n        in->opcode != FUSE_NOTIFY_REPLY && in->opcode != FUSE_READDIRPLUS) {\n        goto reply_err;\n    }\n\n    err = ENOSYS;\n    if (in->opcode >= FUSE_MAXOP || !fuse_ll_ops[in->opcode].func) {\n        goto reply_err;\n    }\n    if (in->opcode != FUSE_INTERRUPT) {\n        struct fuse_req *intr;\n        pthread_mutex_lock(&se->lock);\n        intr = check_interrupt(se, req);\n        list_add_req(req, &se->list);\n        pthread_mutex_unlock(&se->lock);\n        if (intr) {\n            fuse_reply_err(intr, EAGAIN);\n        }\n    }\n\n    if (in->opcode == FUSE_WRITE && se->op.write_buf) {\n        do_write_buf(req, in->nodeid, &iter, bufv);\n    } else {\n        fuse_ll_ops[in->opcode].func(req, in->nodeid, &iter);\n    }\n\n    pthread_rwlock_unlock(&se->init_rwlock);\n    return;\n\nreply_err:\n    fuse_reply_err(req, err);\n    pthread_rwlock_unlock(&se->init_rwlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_iov",
          "args": [
            "&fbuf",
            "out_num - 1",
            "out_sg + 1"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "copy_from_iov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "142-154",
          "snippet": "static void copy_from_iov(struct fuse_buf *buf, size_t out_num,\n                          const struct iovec *out_sg)\n{\n    void *dest = buf->mem;\n\n    while (out_num) {\n        size_t onelen = out_sg->iov_len;\n        memcpy(dest, out_sg->iov_base, onelen);\n        dest += onelen;\n        out_sg++;\n        out_num--;\n    }\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void copy_from_iov(struct fuse_buf *buf, size_t out_num,\n                          const struct iovec *out_sg)\n{\n    void *dest = buf->mem;\n\n    while (out_num) {\n        size_t onelen = out_sg->iov_len;\n        memcpy(dest, out_sg->iov_base, onelen);\n        dest += onelen;\n        out_sg++;\n        out_num--;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(struct fuse_bufvec) +\n                       sizeof(struct fuse_buf) * (out_num - 2)"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "0"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_size",
          "args": [
            "out_sg",
            "out_num"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_mutex_init",
          "args": [
            "&req->ch.lock"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_mutex_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_misc.h",
          "lines": "27-34",
          "snippet": "static inline void fuse_mutex_init(pthread_mutex_t *mut)\n{\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);\n    pthread_mutex_init(mut, &attr);\n    pthread_mutexattr_destroy(&attr);\n}",
          "includes": [
            "#include \"config-host.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"config-host.h\"\n#include <pthread.h>\n\nstatic inline void fuse_mutex_init(pthread_mutex_t *mut)\n{\n    pthread_mutexattr_t attr;\n    pthread_mutexattr_init(&attr);\n    pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);\n    pthread_mutex_init(mut, &attr);\n    pthread_mutexattr_destroy(&attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "fbuf.mem"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "se->bufsize"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "ret == 0"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unshare",
          "args": [
            "CLONE_FS"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "se->bufsize > sizeof(struct fuse_in_header)"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic __thread bool clone_fs_called;\n\nstatic void fv_queue_worker(gpointer data, gpointer user_data)\n{\n    struct fv_QueueInfo *qi = user_data;\n    struct fuse_session *se = qi->virtio_dev->se;\n    struct VuDev *dev = &qi->virtio_dev->dev;\n    FVRequest *req = data;\n    VuVirtqElement *elem = &req->elem;\n    struct fuse_buf fbuf = {};\n    bool allocated_bufv = false;\n    struct fuse_bufvec bufv;\n    struct fuse_bufvec *pbufv;\n\n    assert(se->bufsize > sizeof(struct fuse_in_header));\n\n    if (!clone_fs_called) {\n        int ret;\n\n        /* unshare FS for xattr operation */\n        ret = unshare(CLONE_FS);\n        /* should not fail */\n        assert(ret == 0);\n\n        clone_fs_called = true;\n    }\n\n    /*\n     * An element contains one request and the space to send our response\n     * They're spread over multiple descriptors in a scatter/gather set\n     * and we can't trust the guest to keep them still; so copy in/out.\n     */\n    fbuf.mem = malloc(se->bufsize);\n    assert(fbuf.mem);\n\n    fuse_mutex_init(&req->ch.lock);\n    req->ch.fd = -1;\n    req->ch.qi = qi;\n\n    /* The 'out' part of the elem is from qemu */\n    unsigned int out_num = elem->out_num;\n    struct iovec *out_sg = elem->out_sg;\n    size_t out_len = iov_size(out_sg, out_num);\n    fuse_log(FUSE_LOG_DEBUG,\n             \"%s: elem %d: with %d out desc of length %zd\\n\",\n             __func__, elem->index, out_num, out_len);\n\n    /*\n     * The elem should contain a 'fuse_in_header' (in to fuse)\n     * plus the data based on the len in the header.\n     */\n    if (out_len < sizeof(struct fuse_in_header)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: elem %d too short for in_header\\n\",\n                 __func__, elem->index);\n        assert(0); /* TODO */\n    }\n    if (out_len > se->bufsize) {\n        fuse_log(FUSE_LOG_ERR, \"%s: elem %d too large for buffer\\n\", __func__,\n                 elem->index);\n        assert(0); /* TODO */\n    }\n    /* Copy just the first element and look at it */\n    copy_from_iov(&fbuf, 1, out_sg);\n\n    pbufv = NULL; /* Compiler thinks an unitialised path */\n    if (out_num > 2 &&\n        out_sg[0].iov_len == sizeof(struct fuse_in_header) &&\n        ((struct fuse_in_header *)fbuf.mem)->opcode == FUSE_WRITE &&\n        out_sg[1].iov_len == sizeof(struct fuse_write_in)) {\n        /*\n         * For a write we don't actually need to copy the\n         * data, we can just do it straight out of guest memory\n         * but we must still copy the headers in case the guest\n         * was nasty and changed them while we were using them.\n         */\n        fuse_log(FUSE_LOG_DEBUG, \"%s: Write special case\\n\", __func__);\n\n        /* copy the fuse_write_in header afte rthe fuse_in_header */\n        fbuf.mem += out_sg->iov_len;\n        copy_from_iov(&fbuf, 1, out_sg + 1);\n        fbuf.mem -= out_sg->iov_len;\n        fbuf.size = out_sg[0].iov_len + out_sg[1].iov_len;\n\n        /* Allocate the bufv, with space for the rest of the iov */\n        pbufv = malloc(sizeof(struct fuse_bufvec) +\n                       sizeof(struct fuse_buf) * (out_num - 2));\n        if (!pbufv) {\n            fuse_log(FUSE_LOG_ERR, \"%s: pbufv malloc failed\\n\",\n                    __func__);\n            goto out;\n        }\n\n        allocated_bufv = true;\n        pbufv->count = 1;\n        pbufv->buf[0] = fbuf;\n\n        size_t iovindex, pbufvindex;\n        iovindex = 2; /* 2 headers, separate iovs */\n        pbufvindex = 1; /* 2 headers, 1 fusebuf */\n\n        for (; iovindex < out_num; iovindex++, pbufvindex++) {\n            pbufv->count++;\n            pbufv->buf[pbufvindex].pos = ~0; /* Dummy */\n            pbufv->buf[pbufvindex].flags = 0;\n            pbufv->buf[pbufvindex].mem = out_sg[iovindex].iov_base;\n            pbufv->buf[pbufvindex].size = out_sg[iovindex].iov_len;\n        }\n    } else {\n        /* Normal (non fast write) path */\n\n        /* Copy the rest of the buffer */\n        fbuf.mem += out_sg->iov_len;\n        copy_from_iov(&fbuf, out_num - 1, out_sg + 1);\n        fbuf.mem -= out_sg->iov_len;\n        fbuf.size = out_len;\n\n        /* TODO! Endianness of header */\n\n        /* TODO: Add checks for fuse_session_exited */\n        bufv.buf[0] = fbuf;\n        bufv.count = 1;\n        pbufv = &bufv;\n    }\n    pbufv->idx = 0;\n    pbufv->off = 0;\n    fuse_session_process_buf_int(se, pbufv, &req->ch);\n\nout:\n    if (allocated_bufv) {\n        free(pbufv);\n    }\n\n    /* If the request has no reply, still recycle the virtqueue element */\n    if (!req->reply_sent) {\n        struct VuVirtq *q = vu_get_queue(dev, qi->qidx);\n\n        fuse_log(FUSE_LOG_DEBUG, \"%s: elem %d no reply sent\\n\", __func__,\n                 elem->index);\n\n        pthread_rwlock_rdlock(&qi->virtio_dev->vu_dispatch_rwlock);\n        pthread_mutex_lock(&qi->vq_lock);\n        vu_queue_push(dev, q, elem, 0);\n        vu_queue_notify(dev, q);\n        pthread_mutex_unlock(&qi->vq_lock);\n        pthread_rwlock_unlock(&qi->virtio_dev->vu_dispatch_rwlock);\n    }\n\n    pthread_mutex_destroy(&req->ch.lock);\n    free(fbuf.mem);\n    free(req);\n}"
  },
  {
    "function_name": "virtio_send_data_iov",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "272-429",
    "snippet": "int virtio_send_data_iov(struct fuse_session *se, struct fuse_chan *ch,\n                         struct iovec *iov, int count, struct fuse_bufvec *buf,\n                         size_t len)\n{\n    FVRequest *req = container_of(ch, FVRequest, ch);\n    struct fv_QueueInfo *qi = ch->qi;\n    VuDev *dev = &se->virtio_dev->dev;\n    VuVirtq *q = vu_get_queue(dev, qi->qidx);\n    VuVirtqElement *elem = &req->elem;\n    int ret = 0;\n\n    assert(count >= 1);\n    assert(iov[0].iov_len >= sizeof(struct fuse_out_header));\n\n    struct fuse_out_header *out = iov[0].iov_base;\n    /* TODO: Endianness! */\n\n    size_t iov_len = iov_size(iov, count);\n    size_t tosend_len = iov_len + len;\n\n    out->len = tosend_len;\n\n    fuse_log(FUSE_LOG_DEBUG, \"%s: count=%d len=%zd iov_len=%zd\\n\", __func__,\n             count, len, iov_len);\n\n    /* unique == 0 is notification which we don't support */\n    assert(out->unique);\n\n    assert(!req->reply_sent);\n\n    /* The 'in' part of the elem is to qemu */\n    unsigned int in_num = elem->in_num;\n    struct iovec *in_sg = elem->in_sg;\n    size_t in_len = iov_size(in_sg, in_num);\n    fuse_log(FUSE_LOG_DEBUG, \"%s: elem %d: with %d in desc of length %zd\\n\",\n             __func__, elem->index, in_num, in_len);\n\n    /*\n     * The elem should have room for a 'fuse_out_header' (out from fuse)\n     * plus the data based on the len in the header.\n     */\n    if (in_len < sizeof(struct fuse_out_header)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: elem %d too short for out_header\\n\",\n                 __func__, elem->index);\n        ret = E2BIG;\n        goto err;\n    }\n    if (in_len < tosend_len) {\n        fuse_log(FUSE_LOG_ERR, \"%s: elem %d too small for data len %zd\\n\",\n                 __func__, elem->index, tosend_len);\n        ret = E2BIG;\n        goto err;\n    }\n\n    /* TODO: Limit to 'len' */\n\n    /* First copy the header data from iov->in_sg */\n    copy_iov(iov, count, in_sg, in_num, iov_len);\n\n    /*\n     * Build a copy of the the in_sg iov so we can skip bits in it,\n     * including changing the offsets\n     */\n    struct iovec *in_sg_cpy = calloc(sizeof(struct iovec), in_num);\n    assert(in_sg_cpy);\n    memcpy(in_sg_cpy, in_sg, sizeof(struct iovec) * in_num);\n    /* These get updated as we skip */\n    struct iovec *in_sg_ptr = in_sg_cpy;\n    int in_sg_cpy_count = in_num;\n\n    /* skip over parts of in_sg that contained the header iov */\n    size_t skip_size = iov_len;\n\n    size_t in_sg_left = 0;\n    do {\n        while (skip_size != 0 && in_sg_cpy_count) {\n            if (skip_size >= in_sg_ptr[0].iov_len) {\n                skip_size -= in_sg_ptr[0].iov_len;\n                in_sg_ptr++;\n                in_sg_cpy_count--;\n            } else {\n                in_sg_ptr[0].iov_len -= skip_size;\n                in_sg_ptr[0].iov_base += skip_size;\n                break;\n            }\n        }\n\n        int i;\n        for (i = 0, in_sg_left = 0; i < in_sg_cpy_count; i++) {\n            in_sg_left += in_sg_ptr[i].iov_len;\n        }\n        fuse_log(FUSE_LOG_DEBUG,\n                 \"%s: after skip skip_size=%zd in_sg_cpy_count=%d \"\n                 \"in_sg_left=%zd\\n\",\n                 __func__, skip_size, in_sg_cpy_count, in_sg_left);\n        ret = preadv(buf->buf[0].fd, in_sg_ptr, in_sg_cpy_count,\n                     buf->buf[0].pos);\n\n        if (ret == -1) {\n            ret = errno;\n            fuse_log(FUSE_LOG_DEBUG, \"%s: preadv failed (%m) len=%zd\\n\",\n                     __func__, len);\n            free(in_sg_cpy);\n            goto err;\n        }\n        fuse_log(FUSE_LOG_DEBUG, \"%s: preadv ret=%d len=%zd\\n\", __func__,\n                 ret, len);\n        if (ret < len && ret) {\n            fuse_log(FUSE_LOG_DEBUG, \"%s: ret < len\\n\", __func__);\n            /* Skip over this much next time around */\n            skip_size = ret;\n            buf->buf[0].pos += ret;\n            len -= ret;\n\n            /* Lets do another read */\n            continue;\n        }\n        if (!ret) {\n            /* EOF case? */\n            fuse_log(FUSE_LOG_DEBUG, \"%s: !ret in_sg_left=%zd\\n\", __func__,\n                     in_sg_left);\n            break;\n        }\n        if (ret != len) {\n            fuse_log(FUSE_LOG_DEBUG, \"%s: ret!=len\\n\", __func__);\n            ret = EIO;\n            free(in_sg_cpy);\n            goto err;\n        }\n        in_sg_left -= ret;\n        len -= ret;\n    } while (in_sg_left);\n    free(in_sg_cpy);\n\n    /* Need to fix out->len on EOF */\n    if (len) {\n        struct fuse_out_header *out_sg = in_sg[0].iov_base;\n\n        tosend_len -= len;\n        out_sg->len = tosend_len;\n    }\n\n    ret = 0;\n\n    pthread_rwlock_rdlock(&qi->virtio_dev->vu_dispatch_rwlock);\n    pthread_mutex_lock(&qi->vq_lock);\n    vu_queue_push(dev, q, elem, tosend_len);\n    vu_queue_notify(dev, q);\n    pthread_mutex_unlock(&qi->vq_lock);\n    pthread_rwlock_unlock(&qi->virtio_dev->vu_dispatch_rwlock);\n\nerr:\n    if (ret == 0) {\n        req->reply_sent = true;\n    }\n\n    return ret;\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_rwlock_unlock",
          "args": [
            "&qi->virtio_dev->vu_dispatch_rwlock"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&qi->vq_lock"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vu_queue_notify",
          "args": [
            "dev",
            "q"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vu_queue_push",
          "args": [
            "dev",
            "q",
            "elem",
            "tosend_len"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&qi->vq_lock"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_rdlock",
          "args": [
            "&qi->virtio_dev->vu_dispatch_rwlock"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "in_sg_cpy"
          ],
          "line": 404
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_DEBUG",
            "\"%s: ret!=len\\n\"",
            "__func__"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preadv",
          "args": [
            "buf->buf[0].fd",
            "in_sg_ptr",
            "in_sg_cpy_count",
            "buf->buf[0].pos"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "in_sg_cpy",
            "in_sg",
            "sizeof(struct iovec) * in_num"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "in_sg_cpy"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "sizeof(struct iovec)",
            "in_num"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_iov",
          "args": [
            "iov",
            "count",
            "in_sg",
            "in_num",
            "iov_len"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "copy_iov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "160-198",
          "snippet": "static void copy_iov(struct iovec *src_iov, int src_count,\n                     struct iovec *dst_iov, int dst_count, size_t to_copy)\n{\n    size_t dst_offset = 0;\n    /* Outer loop copies 'src' elements */\n    while (to_copy) {\n        assert(src_count);\n        size_t src_len = src_iov[0].iov_len;\n        size_t src_offset = 0;\n\n        if (src_len > to_copy) {\n            src_len = to_copy;\n        }\n        /* Inner loop copies contents of one 'src' to maybe multiple dst. */\n        while (src_len) {\n            assert(dst_count);\n            size_t dst_len = dst_iov[0].iov_len - dst_offset;\n            if (dst_len > src_len) {\n                dst_len = src_len;\n            }\n\n            memcpy(dst_iov[0].iov_base + dst_offset,\n                   src_iov[0].iov_base + src_offset, dst_len);\n            src_len -= dst_len;\n            to_copy -= dst_len;\n            src_offset += dst_len;\n            dst_offset += dst_len;\n\n            assert(dst_offset <= dst_iov[0].iov_len);\n            if (dst_offset == dst_iov[0].iov_len) {\n                dst_offset = 0;\n                dst_iov++;\n                dst_count--;\n            }\n        }\n        src_iov++;\n        src_count--;\n    }\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void copy_iov(struct iovec *src_iov, int src_count,\n                     struct iovec *dst_iov, int dst_count, size_t to_copy)\n{\n    size_t dst_offset = 0;\n    /* Outer loop copies 'src' elements */\n    while (to_copy) {\n        assert(src_count);\n        size_t src_len = src_iov[0].iov_len;\n        size_t src_offset = 0;\n\n        if (src_len > to_copy) {\n            src_len = to_copy;\n        }\n        /* Inner loop copies contents of one 'src' to maybe multiple dst. */\n        while (src_len) {\n            assert(dst_count);\n            size_t dst_len = dst_iov[0].iov_len - dst_offset;\n            if (dst_len > src_len) {\n                dst_len = src_len;\n            }\n\n            memcpy(dst_iov[0].iov_base + dst_offset,\n                   src_iov[0].iov_base + src_offset, dst_len);\n            src_len -= dst_len;\n            to_copy -= dst_len;\n            src_offset += dst_len;\n            dst_offset += dst_len;\n\n            assert(dst_offset <= dst_iov[0].iov_len);\n            if (dst_offset == dst_iov[0].iov_len) {\n                dst_offset = 0;\n                dst_iov++;\n                dst_count--;\n            }\n        }\n        src_iov++;\n        src_count--;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_size",
          "args": [
            "in_sg",
            "in_num"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!req->reply_sent"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out->unique"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_size",
          "args": [
            "iov",
            "count"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "iov[0].iov_len >= sizeof(struct fuse_out_header)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "count >= 1"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vu_get_queue",
          "args": [
            "dev",
            "qi->qidx"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ch",
            "FVRequest",
            "ch"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nint virtio_send_data_iov(struct fuse_session *se, struct fuse_chan *ch,\n                         struct iovec *iov, int count, struct fuse_bufvec *buf,\n                         size_t len)\n{\n    FVRequest *req = container_of(ch, FVRequest, ch);\n    struct fv_QueueInfo *qi = ch->qi;\n    VuDev *dev = &se->virtio_dev->dev;\n    VuVirtq *q = vu_get_queue(dev, qi->qidx);\n    VuVirtqElement *elem = &req->elem;\n    int ret = 0;\n\n    assert(count >= 1);\n    assert(iov[0].iov_len >= sizeof(struct fuse_out_header));\n\n    struct fuse_out_header *out = iov[0].iov_base;\n    /* TODO: Endianness! */\n\n    size_t iov_len = iov_size(iov, count);\n    size_t tosend_len = iov_len + len;\n\n    out->len = tosend_len;\n\n    fuse_log(FUSE_LOG_DEBUG, \"%s: count=%d len=%zd iov_len=%zd\\n\", __func__,\n             count, len, iov_len);\n\n    /* unique == 0 is notification which we don't support */\n    assert(out->unique);\n\n    assert(!req->reply_sent);\n\n    /* The 'in' part of the elem is to qemu */\n    unsigned int in_num = elem->in_num;\n    struct iovec *in_sg = elem->in_sg;\n    size_t in_len = iov_size(in_sg, in_num);\n    fuse_log(FUSE_LOG_DEBUG, \"%s: elem %d: with %d in desc of length %zd\\n\",\n             __func__, elem->index, in_num, in_len);\n\n    /*\n     * The elem should have room for a 'fuse_out_header' (out from fuse)\n     * plus the data based on the len in the header.\n     */\n    if (in_len < sizeof(struct fuse_out_header)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: elem %d too short for out_header\\n\",\n                 __func__, elem->index);\n        ret = E2BIG;\n        goto err;\n    }\n    if (in_len < tosend_len) {\n        fuse_log(FUSE_LOG_ERR, \"%s: elem %d too small for data len %zd\\n\",\n                 __func__, elem->index, tosend_len);\n        ret = E2BIG;\n        goto err;\n    }\n\n    /* TODO: Limit to 'len' */\n\n    /* First copy the header data from iov->in_sg */\n    copy_iov(iov, count, in_sg, in_num, iov_len);\n\n    /*\n     * Build a copy of the the in_sg iov so we can skip bits in it,\n     * including changing the offsets\n     */\n    struct iovec *in_sg_cpy = calloc(sizeof(struct iovec), in_num);\n    assert(in_sg_cpy);\n    memcpy(in_sg_cpy, in_sg, sizeof(struct iovec) * in_num);\n    /* These get updated as we skip */\n    struct iovec *in_sg_ptr = in_sg_cpy;\n    int in_sg_cpy_count = in_num;\n\n    /* skip over parts of in_sg that contained the header iov */\n    size_t skip_size = iov_len;\n\n    size_t in_sg_left = 0;\n    do {\n        while (skip_size != 0 && in_sg_cpy_count) {\n            if (skip_size >= in_sg_ptr[0].iov_len) {\n                skip_size -= in_sg_ptr[0].iov_len;\n                in_sg_ptr++;\n                in_sg_cpy_count--;\n            } else {\n                in_sg_ptr[0].iov_len -= skip_size;\n                in_sg_ptr[0].iov_base += skip_size;\n                break;\n            }\n        }\n\n        int i;\n        for (i = 0, in_sg_left = 0; i < in_sg_cpy_count; i++) {\n            in_sg_left += in_sg_ptr[i].iov_len;\n        }\n        fuse_log(FUSE_LOG_DEBUG,\n                 \"%s: after skip skip_size=%zd in_sg_cpy_count=%d \"\n                 \"in_sg_left=%zd\\n\",\n                 __func__, skip_size, in_sg_cpy_count, in_sg_left);\n        ret = preadv(buf->buf[0].fd, in_sg_ptr, in_sg_cpy_count,\n                     buf->buf[0].pos);\n\n        if (ret == -1) {\n            ret = errno;\n            fuse_log(FUSE_LOG_DEBUG, \"%s: preadv failed (%m) len=%zd\\n\",\n                     __func__, len);\n            free(in_sg_cpy);\n            goto err;\n        }\n        fuse_log(FUSE_LOG_DEBUG, \"%s: preadv ret=%d len=%zd\\n\", __func__,\n                 ret, len);\n        if (ret < len && ret) {\n            fuse_log(FUSE_LOG_DEBUG, \"%s: ret < len\\n\", __func__);\n            /* Skip over this much next time around */\n            skip_size = ret;\n            buf->buf[0].pos += ret;\n            len -= ret;\n\n            /* Lets do another read */\n            continue;\n        }\n        if (!ret) {\n            /* EOF case? */\n            fuse_log(FUSE_LOG_DEBUG, \"%s: !ret in_sg_left=%zd\\n\", __func__,\n                     in_sg_left);\n            break;\n        }\n        if (ret != len) {\n            fuse_log(FUSE_LOG_DEBUG, \"%s: ret!=len\\n\", __func__);\n            ret = EIO;\n            free(in_sg_cpy);\n            goto err;\n        }\n        in_sg_left -= ret;\n        len -= ret;\n    } while (in_sg_left);\n    free(in_sg_cpy);\n\n    /* Need to fix out->len on EOF */\n    if (len) {\n        struct fuse_out_header *out_sg = in_sg[0].iov_base;\n\n        tosend_len -= len;\n        out_sg->len = tosend_len;\n    }\n\n    ret = 0;\n\n    pthread_rwlock_rdlock(&qi->virtio_dev->vu_dispatch_rwlock);\n    pthread_mutex_lock(&qi->vq_lock);\n    vu_queue_push(dev, q, elem, tosend_len);\n    vu_queue_notify(dev, q);\n    pthread_mutex_unlock(&qi->vq_lock);\n    pthread_rwlock_unlock(&qi->virtio_dev->vu_dispatch_rwlock);\n\nerr:\n    if (ret == 0) {\n        req->reply_sent = true;\n    }\n\n    return ret;\n}"
  },
  {
    "function_name": "virtio_send_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "205-264",
    "snippet": "int virtio_send_msg(struct fuse_session *se, struct fuse_chan *ch,\n                    struct iovec *iov, int count)\n{\n    FVRequest *req = container_of(ch, FVRequest, ch);\n    struct fv_QueueInfo *qi = ch->qi;\n    VuDev *dev = &se->virtio_dev->dev;\n    VuVirtq *q = vu_get_queue(dev, qi->qidx);\n    VuVirtqElement *elem = &req->elem;\n    int ret = 0;\n\n    assert(count >= 1);\n    assert(iov[0].iov_len >= sizeof(struct fuse_out_header));\n\n    struct fuse_out_header *out = iov[0].iov_base;\n    /* TODO: Endianness! */\n\n    size_t tosend_len = iov_size(iov, count);\n\n    /* unique == 0 is notification, which we don't support */\n    assert(out->unique);\n    assert(!req->reply_sent);\n\n    /* The 'in' part of the elem is to qemu */\n    unsigned int in_num = elem->in_num;\n    struct iovec *in_sg = elem->in_sg;\n    size_t in_len = iov_size(in_sg, in_num);\n    fuse_log(FUSE_LOG_DEBUG, \"%s: elem %d: with %d in desc of length %zd\\n\",\n             __func__, elem->index, in_num, in_len);\n\n    /*\n     * The elem should have room for a 'fuse_out_header' (out from fuse)\n     * plus the data based on the len in the header.\n     */\n    if (in_len < sizeof(struct fuse_out_header)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: elem %d too short for out_header\\n\",\n                 __func__, elem->index);\n        ret = -E2BIG;\n        goto err;\n    }\n    if (in_len < tosend_len) {\n        fuse_log(FUSE_LOG_ERR, \"%s: elem %d too small for data len %zd\\n\",\n                 __func__, elem->index, tosend_len);\n        ret = -E2BIG;\n        goto err;\n    }\n\n    copy_iov(iov, count, in_sg, in_num, tosend_len);\n\n    pthread_rwlock_rdlock(&qi->virtio_dev->vu_dispatch_rwlock);\n    pthread_mutex_lock(&qi->vq_lock);\n    vu_queue_push(dev, q, elem, tosend_len);\n    vu_queue_notify(dev, q);\n    pthread_mutex_unlock(&qi->vq_lock);\n    pthread_rwlock_unlock(&qi->virtio_dev->vu_dispatch_rwlock);\n\n    req->reply_sent = true;\n\nerr:\n    return ret;\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_rwlock_unlock",
          "args": [
            "&qi->virtio_dev->vu_dispatch_rwlock"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_unlock",
          "args": [
            "&qi->vq_lock"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vu_queue_notify",
          "args": [
            "dev",
            "q"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vu_queue_push",
          "args": [
            "dev",
            "q",
            "elem",
            "tosend_len"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_lock",
          "args": [
            "&qi->vq_lock"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_rwlock_rdlock",
          "args": [
            "&qi->virtio_dev->vu_dispatch_rwlock"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_iov",
          "args": [
            "iov",
            "count",
            "in_sg",
            "in_num",
            "tosend_len"
          ],
          "line": 251
        },
        "resolved": true,
        "details": {
          "function_name": "copy_iov",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "160-198",
          "snippet": "static void copy_iov(struct iovec *src_iov, int src_count,\n                     struct iovec *dst_iov, int dst_count, size_t to_copy)\n{\n    size_t dst_offset = 0;\n    /* Outer loop copies 'src' elements */\n    while (to_copy) {\n        assert(src_count);\n        size_t src_len = src_iov[0].iov_len;\n        size_t src_offset = 0;\n\n        if (src_len > to_copy) {\n            src_len = to_copy;\n        }\n        /* Inner loop copies contents of one 'src' to maybe multiple dst. */\n        while (src_len) {\n            assert(dst_count);\n            size_t dst_len = dst_iov[0].iov_len - dst_offset;\n            if (dst_len > src_len) {\n                dst_len = src_len;\n            }\n\n            memcpy(dst_iov[0].iov_base + dst_offset,\n                   src_iov[0].iov_base + src_offset, dst_len);\n            src_len -= dst_len;\n            to_copy -= dst_len;\n            src_offset += dst_len;\n            dst_offset += dst_len;\n\n            assert(dst_offset <= dst_iov[0].iov_len);\n            if (dst_offset == dst_iov[0].iov_len) {\n                dst_offset = 0;\n                dst_iov++;\n                dst_count--;\n            }\n        }\n        src_iov++;\n        src_count--;\n    }\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void copy_iov(struct iovec *src_iov, int src_count,\n                     struct iovec *dst_iov, int dst_count, size_t to_copy)\n{\n    size_t dst_offset = 0;\n    /* Outer loop copies 'src' elements */\n    while (to_copy) {\n        assert(src_count);\n        size_t src_len = src_iov[0].iov_len;\n        size_t src_offset = 0;\n\n        if (src_len > to_copy) {\n            src_len = to_copy;\n        }\n        /* Inner loop copies contents of one 'src' to maybe multiple dst. */\n        while (src_len) {\n            assert(dst_count);\n            size_t dst_len = dst_iov[0].iov_len - dst_offset;\n            if (dst_len > src_len) {\n                dst_len = src_len;\n            }\n\n            memcpy(dst_iov[0].iov_base + dst_offset,\n                   src_iov[0].iov_base + src_offset, dst_len);\n            src_len -= dst_len;\n            to_copy -= dst_len;\n            src_offset += dst_len;\n            dst_offset += dst_len;\n\n            assert(dst_offset <= dst_iov[0].iov_len);\n            if (dst_offset == dst_iov[0].iov_len) {\n                dst_offset = 0;\n                dst_iov++;\n                dst_count--;\n            }\n        }\n        src_iov++;\n        src_count--;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"%s: elem %d too small for data len %zd\\n\"",
            "__func__",
            "elem->index",
            "tosend_len"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "iov_size",
          "args": [
            "in_sg",
            "in_num"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "!req->reply_sent"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "out->unique"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "iov_size",
          "args": [
            "iov",
            "count"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "iov[0].iov_len >= sizeof(struct fuse_out_header)"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "count >= 1"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vu_get_queue",
          "args": [
            "dev",
            "qi->qidx"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ch",
            "FVRequest",
            "ch"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nint virtio_send_msg(struct fuse_session *se, struct fuse_chan *ch,\n                    struct iovec *iov, int count)\n{\n    FVRequest *req = container_of(ch, FVRequest, ch);\n    struct fv_QueueInfo *qi = ch->qi;\n    VuDev *dev = &se->virtio_dev->dev;\n    VuVirtq *q = vu_get_queue(dev, qi->qidx);\n    VuVirtqElement *elem = &req->elem;\n    int ret = 0;\n\n    assert(count >= 1);\n    assert(iov[0].iov_len >= sizeof(struct fuse_out_header));\n\n    struct fuse_out_header *out = iov[0].iov_base;\n    /* TODO: Endianness! */\n\n    size_t tosend_len = iov_size(iov, count);\n\n    /* unique == 0 is notification, which we don't support */\n    assert(out->unique);\n    assert(!req->reply_sent);\n\n    /* The 'in' part of the elem is to qemu */\n    unsigned int in_num = elem->in_num;\n    struct iovec *in_sg = elem->in_sg;\n    size_t in_len = iov_size(in_sg, in_num);\n    fuse_log(FUSE_LOG_DEBUG, \"%s: elem %d: with %d in desc of length %zd\\n\",\n             __func__, elem->index, in_num, in_len);\n\n    /*\n     * The elem should have room for a 'fuse_out_header' (out from fuse)\n     * plus the data based on the len in the header.\n     */\n    if (in_len < sizeof(struct fuse_out_header)) {\n        fuse_log(FUSE_LOG_ERR, \"%s: elem %d too short for out_header\\n\",\n                 __func__, elem->index);\n        ret = -E2BIG;\n        goto err;\n    }\n    if (in_len < tosend_len) {\n        fuse_log(FUSE_LOG_ERR, \"%s: elem %d too small for data len %zd\\n\",\n                 __func__, elem->index, tosend_len);\n        ret = -E2BIG;\n        goto err;\n    }\n\n    copy_iov(iov, count, in_sg, in_num, tosend_len);\n\n    pthread_rwlock_rdlock(&qi->virtio_dev->vu_dispatch_rwlock);\n    pthread_mutex_lock(&qi->vq_lock);\n    vu_queue_push(dev, q, elem, tosend_len);\n    vu_queue_notify(dev, q);\n    pthread_mutex_unlock(&qi->vq_lock);\n    pthread_rwlock_unlock(&qi->virtio_dev->vu_dispatch_rwlock);\n\n    req->reply_sent = true;\n\nerr:\n    return ret;\n}"
  },
  {
    "function_name": "copy_iov",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "160-198",
    "snippet": "static void copy_iov(struct iovec *src_iov, int src_count,\n                     struct iovec *dst_iov, int dst_count, size_t to_copy)\n{\n    size_t dst_offset = 0;\n    /* Outer loop copies 'src' elements */\n    while (to_copy) {\n        assert(src_count);\n        size_t src_len = src_iov[0].iov_len;\n        size_t src_offset = 0;\n\n        if (src_len > to_copy) {\n            src_len = to_copy;\n        }\n        /* Inner loop copies contents of one 'src' to maybe multiple dst. */\n        while (src_len) {\n            assert(dst_count);\n            size_t dst_len = dst_iov[0].iov_len - dst_offset;\n            if (dst_len > src_len) {\n                dst_len = src_len;\n            }\n\n            memcpy(dst_iov[0].iov_base + dst_offset,\n                   src_iov[0].iov_base + src_offset, dst_len);\n            src_len -= dst_len;\n            to_copy -= dst_len;\n            src_offset += dst_len;\n            dst_offset += dst_len;\n\n            assert(dst_offset <= dst_iov[0].iov_len);\n            if (dst_offset == dst_iov[0].iov_len) {\n                dst_offset = 0;\n                dst_iov++;\n                dst_count--;\n            }\n        }\n        src_iov++;\n        src_count--;\n    }\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dst_offset <= dst_iov[0].iov_len"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dst_iov[0].iov_base + dst_offset",
            "src_iov[0].iov_base + src_offset",
            "dst_len"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "dst_count"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "src_count"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void copy_iov(struct iovec *src_iov, int src_count,\n                     struct iovec *dst_iov, int dst_count, size_t to_copy)\n{\n    size_t dst_offset = 0;\n    /* Outer loop copies 'src' elements */\n    while (to_copy) {\n        assert(src_count);\n        size_t src_len = src_iov[0].iov_len;\n        size_t src_offset = 0;\n\n        if (src_len > to_copy) {\n            src_len = to_copy;\n        }\n        /* Inner loop copies contents of one 'src' to maybe multiple dst. */\n        while (src_len) {\n            assert(dst_count);\n            size_t dst_len = dst_iov[0].iov_len - dst_offset;\n            if (dst_len > src_len) {\n                dst_len = src_len;\n            }\n\n            memcpy(dst_iov[0].iov_base + dst_offset,\n                   src_iov[0].iov_base + src_offset, dst_len);\n            src_len -= dst_len;\n            to_copy -= dst_len;\n            src_offset += dst_len;\n            dst_offset += dst_len;\n\n            assert(dst_offset <= dst_iov[0].iov_len);\n            if (dst_offset == dst_iov[0].iov_len) {\n                dst_offset = 0;\n                dst_iov++;\n                dst_count--;\n            }\n        }\n        src_iov++;\n        src_count--;\n    }\n}"
  },
  {
    "function_name": "copy_from_iov",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "142-154",
    "snippet": "static void copy_from_iov(struct fuse_buf *buf, size_t out_num,\n                          const struct iovec *out_sg)\n{\n    void *dest = buf->mem;\n\n    while (out_num) {\n        size_t onelen = out_sg->iov_len;\n        memcpy(dest, out_sg->iov_base, onelen);\n        dest += onelen;\n        out_sg++;\n        out_num--;\n    }\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dest",
            "out_sg->iov_base",
            "onelen"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void copy_from_iov(struct fuse_buf *buf, size_t out_num,\n                          const struct iovec *out_sg)\n{\n    void *dest = buf->mem;\n\n    while (out_num) {\n        size_t onelen = out_sg->iov_len;\n        memcpy(dest, out_sg->iov_base, onelen);\n        dest += onelen;\n        out_sg++;\n        out_num--;\n    }\n}"
  },
  {
    "function_name": "fv_panic",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "131-136",
    "snippet": "static void fv_panic(VuDev *dev, const char *err)\n{\n    fuse_log(FUSE_LOG_ERR, \"%s: libvhost-user: %s\\n\", __func__, err);\n    /* TODO: Allow reconnects?? */\n    exit(EXIT_FAILURE);\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "EXIT_FAILURE"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_session_exited",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "2691-2694",
          "snippet": "int fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nint fuse_session_exited(struct fuse_session *se)\n{\n    return se->exited;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_ERR",
            "\"%s: libvhost-user: %s\\n\"",
            "__func__",
            "err"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fv_panic(VuDev *dev, const char *err)\n{\n    fuse_log(FUSE_LOG_ERR, \"%s: libvhost-user: %s\\n\", __func__, err);\n    /* TODO: Allow reconnects?? */\n    exit(EXIT_FAILURE);\n}"
  },
  {
    "function_name": "fv_remove_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "125-128",
    "snippet": "static void fv_remove_watch(VuDev *dev, int fd)\n{\n    fuse_log(FUSE_LOG_WARNING, \"%s: TODO! fd=%d\\n\", __func__, fd);\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_WARNING",
            "\"%s: TODO! fd=%d\\n\"",
            "__func__",
            "fd"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fv_remove_watch(VuDev *dev, int fd)\n{\n    fuse_log(FUSE_LOG_WARNING, \"%s: TODO! fd=%d\\n\", __func__, fd);\n}"
  },
  {
    "function_name": "fv_set_watch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "116-120",
    "snippet": "static void fv_set_watch(VuDev *dev, int fd, int condition, vu_watch_cb cb,\n                         void *data)\n{\n    fuse_log(FUSE_LOG_WARNING, \"%s: TODO! fd=%d\\n\", __func__, fd);\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_log",
          "args": [
            "FUSE_LOG_WARNING",
            "\"%s: TODO! fd=%d\\n\"",
            "__func__",
            "fd"
          ],
          "line": 119
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_log",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_log.c",
          "lines": "34-41",
          "snippet": "void fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}",
          "includes": [
            "#include <stdio.h>",
            "#include <stdarg.h>",
            "#include \"fuse_log.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static fuse_log_func_t log_func = default_log_func;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <stdio.h>\n#include <stdarg.h>\n#include \"fuse_log.h\"\n#include \"qemu/osdep.h\"\n\nstatic fuse_log_func_t log_func = default_log_func;\n\nvoid fuse_log(enum fuse_log_level level, const char *fmt, ...)\n{\n    va_list ap;\n\n    va_start(ap, fmt);\n    log_func(level, fmt, ap);\n    va_end(ap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fv_set_watch(VuDev *dev, int fd, int condition, vu_watch_cb cb,\n                         void *data)\n{\n    fuse_log(FUSE_LOG_WARNING, \"%s: TODO! fd=%d\\n\", __func__, fd);\n}"
  },
  {
    "function_name": "fv_set_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "108-110",
    "snippet": "static void fv_set_features(VuDev *dev, uint64_t features)\n{\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic void fv_set_features(VuDev *dev, uint64_t features)\n{\n}"
  },
  {
    "function_name": "fv_get_features",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
    "lines": "102-105",
    "snippet": "static uint64_t fv_get_features(VuDev *dev)\n{\n    return 1ULL << VIRTIO_F_VERSION_1;\n}",
    "includes": [
      "#include \"contrib/libvhost-user/libvhost-user.h\"",
      "#include <unistd.h>",
      "#include <grp.h>",
      "#include <sys/types.h>",
      "#include <sys/un.h>",
      "#include <sys/types.h>",
      "#include <sys/socket.h>",
      "#include <sys/eventfd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <stdio.h>",
      "#include <stdint.h>",
      "#include <glib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_virtio.h\"",
      "#include \"fuse_opt.h\"",
      "#include \"fuse_misc.h\"",
      "#include \"standard-headers/linux/fuse.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qapi/error.h\"",
      "#include \"qemu/iov.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nstatic uint64_t fv_get_features(VuDev *dev)\n{\n    return 1ULL << VIRTIO_F_VERSION_1;\n}"
  }
]