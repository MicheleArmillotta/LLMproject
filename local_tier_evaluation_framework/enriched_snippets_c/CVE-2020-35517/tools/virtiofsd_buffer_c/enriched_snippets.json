[
  {
    "function_name": "fuse_mbuf_iter_advance_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
    "lines": "338-351",
    "snippet": "const char *fuse_mbuf_iter_advance_str(struct fuse_mbuf_iter *iter)\n{\n    const char *str = iter->mem + iter->pos;\n    size_t remaining = iter->size - iter->pos;\n    size_t i;\n\n    for (i = 0; i < remaining; i++) {\n        if (str[i] == '\\0') {\n            iter->pos += i + 1;\n            return str;\n        }\n    }\n    return NULL;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nconst char *fuse_mbuf_iter_advance_str(struct fuse_mbuf_iter *iter)\n{\n    const char *str = iter->mem + iter->pos;\n    size_t remaining = iter->size - iter->pos;\n    size_t i;\n\n    for (i = 0; i < remaining; i++) {\n        if (str[i] == '\\0') {\n            iter->pos += i + 1;\n            return str;\n        }\n    }\n    return NULL;\n}"
  },
  {
    "function_name": "fuse_mbuf_iter_advance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
    "lines": "325-336",
    "snippet": "void *fuse_mbuf_iter_advance(struct fuse_mbuf_iter *iter, size_t len)\n{\n    void *ptr;\n\n    if (len > iter->size - iter->pos) {\n        return NULL;\n    }\n\n    ptr = iter->mem + iter->pos;\n    iter->pos += len;\n    return ptr;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid *fuse_mbuf_iter_advance(struct fuse_mbuf_iter *iter, size_t len)\n{\n    void *ptr;\n\n    if (len > iter->size - iter->pos) {\n        return NULL;\n    }\n\n    ptr = iter->mem + iter->pos;\n    iter->pos += len;\n    return ptr;\n}"
  },
  {
    "function_name": "fuse_buf_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
    "lines": "262-323",
    "snippet": "ssize_t fuse_buf_copy(struct fuse_bufvec *dstv, struct fuse_bufvec *srcv)\n{\n    size_t copied = 0, i;\n\n    if (dstv == srcv) {\n        return fuse_buf_size(dstv);\n    }\n\n    /*\n     * use writev to improve bandwidth when all the\n     * src buffers already mapped by the daemon\n     * process\n     */\n    for (i = 0; i < srcv->count; i++) {\n        if (srcv->buf[i].flags & FUSE_BUF_IS_FD) {\n            break;\n        }\n    }\n    if ((i == srcv->count) && (dstv->count == 1) &&\n        (dstv->idx == 0) &&\n        (dstv->buf[0].flags & FUSE_BUF_IS_FD)) {\n        dstv->buf[0].pos += dstv->off;\n        return fuse_buf_writev(&dstv->buf[0], srcv);\n    }\n\n    for (;;) {\n        const struct fuse_buf *src = fuse_bufvec_current(srcv);\n        const struct fuse_buf *dst = fuse_bufvec_current(dstv);\n        size_t src_len;\n        size_t dst_len;\n        size_t len;\n        ssize_t res;\n\n        if (src == NULL || dst == NULL) {\n            break;\n        }\n\n        src_len = src->size - srcv->off;\n        dst_len = dst->size - dstv->off;\n        len = min_size(src_len, dst_len);\n\n        res = fuse_buf_copy_one(dst, dstv->off, src, srcv->off, len);\n        if (res < 0) {\n            if (!copied) {\n                return res;\n            }\n            break;\n        }\n        copied += res;\n\n        if (!fuse_bufvec_advance(srcv, res) ||\n            !fuse_bufvec_advance(dstv, res)) {\n            break;\n        }\n\n        if (res < len) {\n            break;\n        }\n    }\n\n    return copied;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_bufvec_advance",
          "args": [
            "dstv",
            "res"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bufvec_advance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "245-260",
          "snippet": "static int fuse_bufvec_advance(struct fuse_bufvec *bufv, size_t len)\n{\n    const struct fuse_buf *buf = fuse_bufvec_current(bufv);\n\n    bufv->off += len;\n    assert(bufv->off <= buf->size);\n    if (bufv->off == buf->size) {\n        assert(bufv->idx < bufv->count);\n        bufv->idx++;\n        if (bufv->idx == bufv->count) {\n            return 0;\n        }\n        bufv->off = 0;\n    }\n    return 1;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic int fuse_bufvec_advance(struct fuse_bufvec *bufv, size_t len)\n{\n    const struct fuse_buf *buf = fuse_bufvec_current(bufv);\n\n    bufv->off += len;\n    assert(bufv->off <= buf->size);\n    if (bufv->off == buf->size) {\n        assert(bufv->idx < bufv->count);\n        bufv->idx++;\n        if (bufv->idx == bufv->count) {\n            return 0;\n        }\n        bufv->off = 0;\n    }\n    return 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_buf_copy_one",
          "args": [
            "dst",
            "dstv->off",
            "src",
            "srcv->off",
            "len"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_buf_copy_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "207-234",
          "snippet": "static ssize_t fuse_buf_copy_one(const struct fuse_buf *dst, size_t dst_off,\n                                 const struct fuse_buf *src, size_t src_off,\n                                 size_t len)\n{\n    int src_is_fd = src->flags & FUSE_BUF_IS_FD;\n    int dst_is_fd = dst->flags & FUSE_BUF_IS_FD;\n\n    if (!src_is_fd && !dst_is_fd) {\n        char *dstmem = (char *)dst->mem + dst_off;\n        char *srcmem = (char *)src->mem + src_off;\n\n        if (dstmem != srcmem) {\n            if (dstmem + len <= srcmem || srcmem + len <= dstmem) {\n                memcpy(dstmem, srcmem, len);\n            } else {\n                memmove(dstmem, srcmem, len);\n            }\n        }\n\n        return len;\n    } else if (!src_is_fd) {\n        return fuse_buf_write(dst, dst_off, src, src_off, len);\n    } else if (!dst_is_fd) {\n        return fuse_buf_read(dst, dst_off, src, src_off, len);\n    } else {\n        return fuse_buf_fd_to_fd(dst, dst_off, src, src_off, len);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t fuse_buf_copy_one(const struct fuse_buf *dst, size_t dst_off,\n                                 const struct fuse_buf *src, size_t src_off,\n                                 size_t len)\n{\n    int src_is_fd = src->flags & FUSE_BUF_IS_FD;\n    int dst_is_fd = dst->flags & FUSE_BUF_IS_FD;\n\n    if (!src_is_fd && !dst_is_fd) {\n        char *dstmem = (char *)dst->mem + dst_off;\n        char *srcmem = (char *)src->mem + src_off;\n\n        if (dstmem != srcmem) {\n            if (dstmem + len <= srcmem || srcmem + len <= dstmem) {\n                memcpy(dstmem, srcmem, len);\n            } else {\n                memmove(dstmem, srcmem, len);\n            }\n        }\n\n        return len;\n    } else if (!src_is_fd) {\n        return fuse_buf_write(dst, dst_off, src, src_off, len);\n    } else if (!dst_is_fd) {\n        return fuse_buf_read(dst, dst_off, src, src_off, len);\n    } else {\n        return fuse_buf_fd_to_fd(dst, dst_off, src, src_off, len);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_size",
          "args": [
            "src_len",
            "dst_len"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "min_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "73-76",
          "snippet": "static size_t min_size(size_t s1, size_t s2)\n{\n    return s1 < s2 ? s1 : s2;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic size_t min_size(size_t s1, size_t s2)\n{\n    return s1 < s2 ? s1 : s2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_bufvec_current",
          "args": [
            "dstv"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bufvec_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "236-243",
          "snippet": "static const struct fuse_buf *fuse_bufvec_current(struct fuse_bufvec *bufv)\n{\n    if (bufv->idx < bufv->count) {\n        return &bufv->buf[bufv->idx];\n    } else {\n        return NULL;\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic const struct fuse_buf *fuse_bufvec_current(struct fuse_bufvec *bufv)\n{\n    if (bufv->idx < bufv->count) {\n        return &bufv->buf[bufv->idx];\n    } else {\n        return NULL;\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_buf_writev",
          "args": [
            "&dstv->buf[0]",
            "srcv"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_buf_writev",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "37-71",
          "snippet": "static ssize_t fuse_buf_writev(struct fuse_buf *out_buf,\n                               struct fuse_bufvec *in_buf)\n{\n    ssize_t res, i, j;\n    size_t iovcnt = in_buf->count;\n    struct iovec *iov;\n    int fd = out_buf->fd;\n\n    iov = calloc(iovcnt, sizeof(struct iovec));\n    if (!iov) {\n        return -ENOMEM;\n    }\n\n    for (i = 0, j = 0; i < iovcnt; i++) {\n        /* Skip the buf with 0 size */\n        if (in_buf->buf[i].size) {\n            iov[j].iov_base = in_buf->buf[i].mem;\n            iov[j].iov_len = in_buf->buf[i].size;\n            j++;\n        }\n    }\n\n    if (out_buf->flags & FUSE_BUF_FD_SEEK) {\n        res = pwritev(fd, iov, iovcnt, out_buf->pos);\n    } else {\n        res = writev(fd, iov, iovcnt);\n    }\n\n    if (res == -1) {\n        res = -errno;\n    }\n\n    free(iov);\n    return res;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t fuse_buf_writev(struct fuse_buf *out_buf,\n                               struct fuse_bufvec *in_buf)\n{\n    ssize_t res, i, j;\n    size_t iovcnt = in_buf->count;\n    struct iovec *iov;\n    int fd = out_buf->fd;\n\n    iov = calloc(iovcnt, sizeof(struct iovec));\n    if (!iov) {\n        return -ENOMEM;\n    }\n\n    for (i = 0, j = 0; i < iovcnt; i++) {\n        /* Skip the buf with 0 size */\n        if (in_buf->buf[i].size) {\n            iov[j].iov_base = in_buf->buf[i].mem;\n            iov[j].iov_len = in_buf->buf[i].size;\n            j++;\n        }\n    }\n\n    if (out_buf->flags & FUSE_BUF_FD_SEEK) {\n        res = pwritev(fd, iov, iovcnt, out_buf->pos);\n    } else {\n        res = writev(fd, iov, iovcnt);\n    }\n\n    if (res == -1) {\n        res = -errno;\n    }\n\n    free(iov);\n    return res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_buf_size",
          "args": [
            "dstv"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_buf_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "21-35",
          "snippet": "size_t fuse_buf_size(const struct fuse_bufvec *bufv)\n{\n    size_t i;\n    size_t size = 0;\n\n    for (i = 0; i < bufv->count; i++) {\n        if (bufv->buf[i].size == SIZE_MAX) {\n            size = SIZE_MAX;\n        } else {\n            size += bufv->buf[i].size;\n        }\n    }\n\n    return size;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nsize_t fuse_buf_size(const struct fuse_bufvec *bufv)\n{\n    size_t i;\n    size_t size = 0;\n\n    for (i = 0; i < bufv->count; i++) {\n        if (bufv->buf[i].size == SIZE_MAX) {\n            size = SIZE_MAX;\n        } else {\n            size += bufv->buf[i].size;\n        }\n    }\n\n    return size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nssize_t fuse_buf_copy(struct fuse_bufvec *dstv, struct fuse_bufvec *srcv)\n{\n    size_t copied = 0, i;\n\n    if (dstv == srcv) {\n        return fuse_buf_size(dstv);\n    }\n\n    /*\n     * use writev to improve bandwidth when all the\n     * src buffers already mapped by the daemon\n     * process\n     */\n    for (i = 0; i < srcv->count; i++) {\n        if (srcv->buf[i].flags & FUSE_BUF_IS_FD) {\n            break;\n        }\n    }\n    if ((i == srcv->count) && (dstv->count == 1) &&\n        (dstv->idx == 0) &&\n        (dstv->buf[0].flags & FUSE_BUF_IS_FD)) {\n        dstv->buf[0].pos += dstv->off;\n        return fuse_buf_writev(&dstv->buf[0], srcv);\n    }\n\n    for (;;) {\n        const struct fuse_buf *src = fuse_bufvec_current(srcv);\n        const struct fuse_buf *dst = fuse_bufvec_current(dstv);\n        size_t src_len;\n        size_t dst_len;\n        size_t len;\n        ssize_t res;\n\n        if (src == NULL || dst == NULL) {\n            break;\n        }\n\n        src_len = src->size - srcv->off;\n        dst_len = dst->size - dstv->off;\n        len = min_size(src_len, dst_len);\n\n        res = fuse_buf_copy_one(dst, dstv->off, src, srcv->off, len);\n        if (res < 0) {\n            if (!copied) {\n                return res;\n            }\n            break;\n        }\n        copied += res;\n\n        if (!fuse_bufvec_advance(srcv, res) ||\n            !fuse_bufvec_advance(dstv, res)) {\n            break;\n        }\n\n        if (res < len) {\n            break;\n        }\n    }\n\n    return copied;\n}"
  },
  {
    "function_name": "fuse_bufvec_advance",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
    "lines": "245-260",
    "snippet": "static int fuse_bufvec_advance(struct fuse_bufvec *bufv, size_t len)\n{\n    const struct fuse_buf *buf = fuse_bufvec_current(bufv);\n\n    bufv->off += len;\n    assert(bufv->off <= buf->size);\n    if (bufv->off == buf->size) {\n        assert(bufv->idx < bufv->count);\n        bufv->idx++;\n        if (bufv->idx == bufv->count) {\n            return 0;\n        }\n        bufv->off = 0;\n    }\n    return 1;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "bufv->idx < bufv->count"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "assert",
          "args": [
            "bufv->off <= buf->size"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fuse_bufvec_current",
          "args": [
            "bufv"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_bufvec_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "236-243",
          "snippet": "static const struct fuse_buf *fuse_bufvec_current(struct fuse_bufvec *bufv)\n{\n    if (bufv->idx < bufv->count) {\n        return &bufv->buf[bufv->idx];\n    } else {\n        return NULL;\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic const struct fuse_buf *fuse_bufvec_current(struct fuse_bufvec *bufv)\n{\n    if (bufv->idx < bufv->count) {\n        return &bufv->buf[bufv->idx];\n    } else {\n        return NULL;\n    }\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic int fuse_bufvec_advance(struct fuse_bufvec *bufv, size_t len)\n{\n    const struct fuse_buf *buf = fuse_bufvec_current(bufv);\n\n    bufv->off += len;\n    assert(bufv->off <= buf->size);\n    if (bufv->off == buf->size) {\n        assert(bufv->idx < bufv->count);\n        bufv->idx++;\n        if (bufv->idx == bufv->count) {\n            return 0;\n        }\n        bufv->off = 0;\n    }\n    return 1;\n}"
  },
  {
    "function_name": "fuse_bufvec_current",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
    "lines": "236-243",
    "snippet": "static const struct fuse_buf *fuse_bufvec_current(struct fuse_bufvec *bufv)\n{\n    if (bufv->idx < bufv->count) {\n        return &bufv->buf[bufv->idx];\n    } else {\n        return NULL;\n    }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic const struct fuse_buf *fuse_bufvec_current(struct fuse_bufvec *bufv)\n{\n    if (bufv->idx < bufv->count) {\n        return &bufv->buf[bufv->idx];\n    } else {\n        return NULL;\n    }\n}"
  },
  {
    "function_name": "fuse_buf_copy_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
    "lines": "207-234",
    "snippet": "static ssize_t fuse_buf_copy_one(const struct fuse_buf *dst, size_t dst_off,\n                                 const struct fuse_buf *src, size_t src_off,\n                                 size_t len)\n{\n    int src_is_fd = src->flags & FUSE_BUF_IS_FD;\n    int dst_is_fd = dst->flags & FUSE_BUF_IS_FD;\n\n    if (!src_is_fd && !dst_is_fd) {\n        char *dstmem = (char *)dst->mem + dst_off;\n        char *srcmem = (char *)src->mem + src_off;\n\n        if (dstmem != srcmem) {\n            if (dstmem + len <= srcmem || srcmem + len <= dstmem) {\n                memcpy(dstmem, srcmem, len);\n            } else {\n                memmove(dstmem, srcmem, len);\n            }\n        }\n\n        return len;\n    } else if (!src_is_fd) {\n        return fuse_buf_write(dst, dst_off, src, src_off, len);\n    } else if (!dst_is_fd) {\n        return fuse_buf_read(dst, dst_off, src, src_off, len);\n    } else {\n        return fuse_buf_fd_to_fd(dst, dst_off, src, src_off, len);\n    }\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_buf_fd_to_fd",
          "args": [
            "dst",
            "dst_off",
            "src",
            "src_off",
            "len"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_buf_fd_to_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "152-205",
          "snippet": "static ssize_t fuse_buf_fd_to_fd(const struct fuse_buf *dst, size_t dst_off,\n                                 const struct fuse_buf *src, size_t src_off,\n                                 size_t len)\n{\n    char buf[4096];\n    struct fuse_buf tmp = {\n        .size = sizeof(buf),\n        .flags = 0,\n    };\n    ssize_t res;\n    size_t copied = 0;\n\n    tmp.mem = buf;\n\n    while (len) {\n        size_t this_len = min_size(tmp.size, len);\n        size_t read_len;\n\n        res = fuse_buf_read(&tmp, 0, src, src_off, this_len);\n        if (res < 0) {\n            if (!copied) {\n                return res;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        read_len = res;\n        res = fuse_buf_write(dst, dst_off, &tmp, 0, read_len);\n        if (res < 0) {\n            if (!copied) {\n                return res;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n\n        if (res < this_len) {\n            break;\n        }\n\n        dst_off += res;\n        src_off += res;\n        len -= res;\n    }\n\n    return copied;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t fuse_buf_fd_to_fd(const struct fuse_buf *dst, size_t dst_off,\n                                 const struct fuse_buf *src, size_t src_off,\n                                 size_t len)\n{\n    char buf[4096];\n    struct fuse_buf tmp = {\n        .size = sizeof(buf),\n        .flags = 0,\n    };\n    ssize_t res;\n    size_t copied = 0;\n\n    tmp.mem = buf;\n\n    while (len) {\n        size_t this_len = min_size(tmp.size, len);\n        size_t read_len;\n\n        res = fuse_buf_read(&tmp, 0, src, src_off, this_len);\n        if (res < 0) {\n            if (!copied) {\n                return res;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        read_len = res;\n        res = fuse_buf_write(dst, dst_off, &tmp, 0, read_len);\n        if (res < 0) {\n            if (!copied) {\n                return res;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n\n        if (res < this_len) {\n            break;\n        }\n\n        dst_off += res;\n        src_off += res;\n        len -= res;\n    }\n\n    return copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_buf_read",
          "args": [
            "dst",
            "dst_off",
            "src",
            "src_off",
            "len"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_buf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "115-150",
          "snippet": "static ssize_t fuse_buf_read(const struct fuse_buf *dst, size_t dst_off,\n                             const struct fuse_buf *src, size_t src_off,\n                             size_t len)\n{\n    ssize_t res = 0;\n    size_t copied = 0;\n\n    while (len) {\n        if (src->flags & FUSE_BUF_FD_SEEK) {\n            res = pread(src->fd, (char *)dst->mem + dst_off, len,\n                        src->pos + src_off);\n        } else {\n            res = read(src->fd, (char *)dst->mem + dst_off, len);\n        }\n        if (res == -1) {\n            if (!copied) {\n                return -errno;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n        if (!(src->flags & FUSE_BUF_FD_RETRY)) {\n            break;\n        }\n\n        dst_off += res;\n        src_off += res;\n        len -= res;\n    }\n\n    return copied;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t fuse_buf_read(const struct fuse_buf *dst, size_t dst_off,\n                             const struct fuse_buf *src, size_t src_off,\n                             size_t len)\n{\n    ssize_t res = 0;\n    size_t copied = 0;\n\n    while (len) {\n        if (src->flags & FUSE_BUF_FD_SEEK) {\n            res = pread(src->fd, (char *)dst->mem + dst_off, len,\n                        src->pos + src_off);\n        } else {\n            res = read(src->fd, (char *)dst->mem + dst_off, len);\n        }\n        if (res == -1) {\n            if (!copied) {\n                return -errno;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n        if (!(src->flags & FUSE_BUF_FD_RETRY)) {\n            break;\n        }\n\n        dst_off += res;\n        src_off += res;\n        len -= res;\n    }\n\n    return copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_buf_write",
          "args": [
            "dst",
            "dst_off",
            "src",
            "src_off",
            "len"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_buf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "78-113",
          "snippet": "static ssize_t fuse_buf_write(const struct fuse_buf *dst, size_t dst_off,\n                              const struct fuse_buf *src, size_t src_off,\n                              size_t len)\n{\n    ssize_t res = 0;\n    size_t copied = 0;\n\n    while (len) {\n        if (dst->flags & FUSE_BUF_FD_SEEK) {\n            res = pwrite(dst->fd, (char *)src->mem + src_off, len,\n                         dst->pos + dst_off);\n        } else {\n            res = write(dst->fd, (char *)src->mem + src_off, len);\n        }\n        if (res == -1) {\n            if (!copied) {\n                return -errno;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n        if (!(dst->flags & FUSE_BUF_FD_RETRY)) {\n            break;\n        }\n\n        src_off += res;\n        dst_off += res;\n        len -= res;\n    }\n\n    return copied;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t fuse_buf_write(const struct fuse_buf *dst, size_t dst_off,\n                              const struct fuse_buf *src, size_t src_off,\n                              size_t len)\n{\n    ssize_t res = 0;\n    size_t copied = 0;\n\n    while (len) {\n        if (dst->flags & FUSE_BUF_FD_SEEK) {\n            res = pwrite(dst->fd, (char *)src->mem + src_off, len,\n                         dst->pos + dst_off);\n        } else {\n            res = write(dst->fd, (char *)src->mem + src_off, len);\n        }\n        if (res == -1) {\n            if (!copied) {\n                return -errno;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n        if (!(dst->flags & FUSE_BUF_FD_RETRY)) {\n            break;\n        }\n\n        src_off += res;\n        dst_off += res;\n        len -= res;\n    }\n\n    return copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "dstmem",
            "srcmem",
            "len"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "dstmem",
            "srcmem",
            "len"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t fuse_buf_copy_one(const struct fuse_buf *dst, size_t dst_off,\n                                 const struct fuse_buf *src, size_t src_off,\n                                 size_t len)\n{\n    int src_is_fd = src->flags & FUSE_BUF_IS_FD;\n    int dst_is_fd = dst->flags & FUSE_BUF_IS_FD;\n\n    if (!src_is_fd && !dst_is_fd) {\n        char *dstmem = (char *)dst->mem + dst_off;\n        char *srcmem = (char *)src->mem + src_off;\n\n        if (dstmem != srcmem) {\n            if (dstmem + len <= srcmem || srcmem + len <= dstmem) {\n                memcpy(dstmem, srcmem, len);\n            } else {\n                memmove(dstmem, srcmem, len);\n            }\n        }\n\n        return len;\n    } else if (!src_is_fd) {\n        return fuse_buf_write(dst, dst_off, src, src_off, len);\n    } else if (!dst_is_fd) {\n        return fuse_buf_read(dst, dst_off, src, src_off, len);\n    } else {\n        return fuse_buf_fd_to_fd(dst, dst_off, src, src_off, len);\n    }\n}"
  },
  {
    "function_name": "fuse_buf_fd_to_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
    "lines": "152-205",
    "snippet": "static ssize_t fuse_buf_fd_to_fd(const struct fuse_buf *dst, size_t dst_off,\n                                 const struct fuse_buf *src, size_t src_off,\n                                 size_t len)\n{\n    char buf[4096];\n    struct fuse_buf tmp = {\n        .size = sizeof(buf),\n        .flags = 0,\n    };\n    ssize_t res;\n    size_t copied = 0;\n\n    tmp.mem = buf;\n\n    while (len) {\n        size_t this_len = min_size(tmp.size, len);\n        size_t read_len;\n\n        res = fuse_buf_read(&tmp, 0, src, src_off, this_len);\n        if (res < 0) {\n            if (!copied) {\n                return res;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        read_len = res;\n        res = fuse_buf_write(dst, dst_off, &tmp, 0, read_len);\n        if (res < 0) {\n            if (!copied) {\n                return res;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n\n        if (res < this_len) {\n            break;\n        }\n\n        dst_off += res;\n        src_off += res;\n        len -= res;\n    }\n\n    return copied;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fuse_buf_write",
          "args": [
            "dst",
            "dst_off",
            "&tmp",
            "0",
            "read_len"
          ],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_buf_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "78-113",
          "snippet": "static ssize_t fuse_buf_write(const struct fuse_buf *dst, size_t dst_off,\n                              const struct fuse_buf *src, size_t src_off,\n                              size_t len)\n{\n    ssize_t res = 0;\n    size_t copied = 0;\n\n    while (len) {\n        if (dst->flags & FUSE_BUF_FD_SEEK) {\n            res = pwrite(dst->fd, (char *)src->mem + src_off, len,\n                         dst->pos + dst_off);\n        } else {\n            res = write(dst->fd, (char *)src->mem + src_off, len);\n        }\n        if (res == -1) {\n            if (!copied) {\n                return -errno;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n        if (!(dst->flags & FUSE_BUF_FD_RETRY)) {\n            break;\n        }\n\n        src_off += res;\n        dst_off += res;\n        len -= res;\n    }\n\n    return copied;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t fuse_buf_write(const struct fuse_buf *dst, size_t dst_off,\n                              const struct fuse_buf *src, size_t src_off,\n                              size_t len)\n{\n    ssize_t res = 0;\n    size_t copied = 0;\n\n    while (len) {\n        if (dst->flags & FUSE_BUF_FD_SEEK) {\n            res = pwrite(dst->fd, (char *)src->mem + src_off, len,\n                         dst->pos + dst_off);\n        } else {\n            res = write(dst->fd, (char *)src->mem + src_off, len);\n        }\n        if (res == -1) {\n            if (!copied) {\n                return -errno;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n        if (!(dst->flags & FUSE_BUF_FD_RETRY)) {\n            break;\n        }\n\n        src_off += res;\n        dst_off += res;\n        len -= res;\n    }\n\n    return copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fuse_buf_read",
          "args": [
            "&tmp",
            "0",
            "src",
            "src_off",
            "this_len"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_buf_read",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "115-150",
          "snippet": "static ssize_t fuse_buf_read(const struct fuse_buf *dst, size_t dst_off,\n                             const struct fuse_buf *src, size_t src_off,\n                             size_t len)\n{\n    ssize_t res = 0;\n    size_t copied = 0;\n\n    while (len) {\n        if (src->flags & FUSE_BUF_FD_SEEK) {\n            res = pread(src->fd, (char *)dst->mem + dst_off, len,\n                        src->pos + src_off);\n        } else {\n            res = read(src->fd, (char *)dst->mem + dst_off, len);\n        }\n        if (res == -1) {\n            if (!copied) {\n                return -errno;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n        if (!(src->flags & FUSE_BUF_FD_RETRY)) {\n            break;\n        }\n\n        dst_off += res;\n        src_off += res;\n        len -= res;\n    }\n\n    return copied;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t fuse_buf_read(const struct fuse_buf *dst, size_t dst_off,\n                             const struct fuse_buf *src, size_t src_off,\n                             size_t len)\n{\n    ssize_t res = 0;\n    size_t copied = 0;\n\n    while (len) {\n        if (src->flags & FUSE_BUF_FD_SEEK) {\n            res = pread(src->fd, (char *)dst->mem + dst_off, len,\n                        src->pos + src_off);\n        } else {\n            res = read(src->fd, (char *)dst->mem + dst_off, len);\n        }\n        if (res == -1) {\n            if (!copied) {\n                return -errno;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n        if (!(src->flags & FUSE_BUF_FD_RETRY)) {\n            break;\n        }\n\n        dst_off += res;\n        src_off += res;\n        len -= res;\n    }\n\n    return copied;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_size",
          "args": [
            "tmp.size",
            "len"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "min_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
          "lines": "73-76",
          "snippet": "static size_t min_size(size_t s1, size_t s2)\n{\n    return s1 < s2 ? s1 : s2;\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_lowlevel.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic size_t min_size(size_t s1, size_t s2)\n{\n    return s1 < s2 ? s1 : s2;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t fuse_buf_fd_to_fd(const struct fuse_buf *dst, size_t dst_off,\n                                 const struct fuse_buf *src, size_t src_off,\n                                 size_t len)\n{\n    char buf[4096];\n    struct fuse_buf tmp = {\n        .size = sizeof(buf),\n        .flags = 0,\n    };\n    ssize_t res;\n    size_t copied = 0;\n\n    tmp.mem = buf;\n\n    while (len) {\n        size_t this_len = min_size(tmp.size, len);\n        size_t read_len;\n\n        res = fuse_buf_read(&tmp, 0, src, src_off, this_len);\n        if (res < 0) {\n            if (!copied) {\n                return res;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        read_len = res;\n        res = fuse_buf_write(dst, dst_off, &tmp, 0, read_len);\n        if (res < 0) {\n            if (!copied) {\n                return res;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n\n        if (res < this_len) {\n            break;\n        }\n\n        dst_off += res;\n        src_off += res;\n        len -= res;\n    }\n\n    return copied;\n}"
  },
  {
    "function_name": "fuse_buf_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
    "lines": "115-150",
    "snippet": "static ssize_t fuse_buf_read(const struct fuse_buf *dst, size_t dst_off,\n                             const struct fuse_buf *src, size_t src_off,\n                             size_t len)\n{\n    ssize_t res = 0;\n    size_t copied = 0;\n\n    while (len) {\n        if (src->flags & FUSE_BUF_FD_SEEK) {\n            res = pread(src->fd, (char *)dst->mem + dst_off, len,\n                        src->pos + src_off);\n        } else {\n            res = read(src->fd, (char *)dst->mem + dst_off, len);\n        }\n        if (res == -1) {\n            if (!copied) {\n                return -errno;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n        if (!(src->flags & FUSE_BUF_FD_RETRY)) {\n            break;\n        }\n\n        dst_off += res;\n        src_off += res;\n        len -= res;\n    }\n\n    return copied;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read",
          "args": [
            "src->fd",
            "(char *)dst->mem + dst_off",
            "len"
          ],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "do_readdirplus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "1343-1363",
          "snippet": "static void do_readdirplus(fuse_req_t req, fuse_ino_t nodeid,\n                           struct fuse_mbuf_iter *iter)\n{\n    struct fuse_read_in *arg;\n    struct fuse_file_info fi;\n\n    arg = fuse_mbuf_iter_advance(iter, sizeof(*arg));\n    if (!arg) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    memset(&fi, 0, sizeof(fi));\n    fi.fh = arg->fh;\n\n    if (req->se->op.readdirplus) {\n        req->se->op.readdirplus(req, nodeid, arg->size, arg->offset, &fi);\n    } else {\n        fuse_reply_err(req, ENOSYS);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic void do_readdirplus(fuse_req_t req, fuse_ino_t nodeid,\n                           struct fuse_mbuf_iter *iter)\n{\n    struct fuse_read_in *arg;\n    struct fuse_file_info fi;\n\n    arg = fuse_mbuf_iter_advance(iter, sizeof(*arg));\n    if (!arg) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    memset(&fi, 0, sizeof(fi));\n    fi.fh = arg->fh;\n\n    if (req->se->op.readdirplus) {\n        req->se->op.readdirplus(req, nodeid, arg->size, arg->offset, &fi);\n    } else {\n        fuse_reply_err(req, ENOSYS);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pread",
          "args": [
            "src->fd",
            "(char *)dst->mem + dst_off",
            "len",
            "src->pos + src_off"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t fuse_buf_read(const struct fuse_buf *dst, size_t dst_off,\n                             const struct fuse_buf *src, size_t src_off,\n                             size_t len)\n{\n    ssize_t res = 0;\n    size_t copied = 0;\n\n    while (len) {\n        if (src->flags & FUSE_BUF_FD_SEEK) {\n            res = pread(src->fd, (char *)dst->mem + dst_off, len,\n                        src->pos + src_off);\n        } else {\n            res = read(src->fd, (char *)dst->mem + dst_off, len);\n        }\n        if (res == -1) {\n            if (!copied) {\n                return -errno;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n        if (!(src->flags & FUSE_BUF_FD_RETRY)) {\n            break;\n        }\n\n        dst_off += res;\n        src_off += res;\n        len -= res;\n    }\n\n    return copied;\n}"
  },
  {
    "function_name": "fuse_buf_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
    "lines": "78-113",
    "snippet": "static ssize_t fuse_buf_write(const struct fuse_buf *dst, size_t dst_off,\n                              const struct fuse_buf *src, size_t src_off,\n                              size_t len)\n{\n    ssize_t res = 0;\n    size_t copied = 0;\n\n    while (len) {\n        if (dst->flags & FUSE_BUF_FD_SEEK) {\n            res = pwrite(dst->fd, (char *)src->mem + src_off, len,\n                         dst->pos + dst_off);\n        } else {\n            res = write(dst->fd, (char *)src->mem + src_off, len);\n        }\n        if (res == -1) {\n            if (!copied) {\n                return -errno;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n        if (!(dst->flags & FUSE_BUF_FD_RETRY)) {\n            break;\n        }\n\n        src_off += res;\n        dst_off += res;\n        len -= res;\n    }\n\n    return copied;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "write",
          "args": [
            "dst->fd",
            "(char *)src->mem + src_off",
            "len"
          ],
          "line": 90
        },
        "resolved": true,
        "details": {
          "function_name": "do_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "1134-1166",
          "snippet": "static void do_write(fuse_req_t req, fuse_ino_t nodeid,\n                     struct fuse_mbuf_iter *iter)\n{\n    struct fuse_write_in *arg;\n    struct fuse_file_info fi;\n    const char *param;\n\n    arg = fuse_mbuf_iter_advance(iter, sizeof(*arg));\n    if (!arg) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    param = fuse_mbuf_iter_advance(iter, arg->size);\n    if (!param) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    memset(&fi, 0, sizeof(fi));\n    fi.fh = arg->fh;\n    fi.writepage = (arg->write_flags & FUSE_WRITE_CACHE) != 0;\n    fi.kill_priv = !!(arg->write_flags & FUSE_WRITE_KILL_PRIV);\n\n    fi.lock_owner = arg->lock_owner;\n    fi.flags = arg->flags;\n\n    if (req->se->op.write) {\n        req->se->op.write(req, nodeid, param, arg->size, arg->offset, &fi);\n    } else {\n        fuse_reply_err(req, ENOSYS);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic void do_write(fuse_req_t req, fuse_ino_t nodeid,\n                     struct fuse_mbuf_iter *iter)\n{\n    struct fuse_write_in *arg;\n    struct fuse_file_info fi;\n    const char *param;\n\n    arg = fuse_mbuf_iter_advance(iter, sizeof(*arg));\n    if (!arg) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    param = fuse_mbuf_iter_advance(iter, arg->size);\n    if (!param) {\n        fuse_reply_err(req, EINVAL);\n        return;\n    }\n\n    memset(&fi, 0, sizeof(fi));\n    fi.fh = arg->fh;\n    fi.writepage = (arg->write_flags & FUSE_WRITE_CACHE) != 0;\n    fi.kill_priv = !!(arg->write_flags & FUSE_WRITE_KILL_PRIV);\n\n    fi.lock_owner = arg->lock_owner;\n    fi.flags = arg->flags;\n\n    if (req->se->op.write) {\n        req->se->op.write(req, nodeid, param, arg->size, arg->offset, &fi);\n    } else {\n        fuse_reply_err(req, ENOSYS);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "pwrite",
          "args": [
            "dst->fd",
            "(char *)src->mem + src_off",
            "len",
            "dst->pos + dst_off"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t fuse_buf_write(const struct fuse_buf *dst, size_t dst_off,\n                              const struct fuse_buf *src, size_t src_off,\n                              size_t len)\n{\n    ssize_t res = 0;\n    size_t copied = 0;\n\n    while (len) {\n        if (dst->flags & FUSE_BUF_FD_SEEK) {\n            res = pwrite(dst->fd, (char *)src->mem + src_off, len,\n                         dst->pos + dst_off);\n        } else {\n            res = write(dst->fd, (char *)src->mem + src_off, len);\n        }\n        if (res == -1) {\n            if (!copied) {\n                return -errno;\n            }\n            break;\n        }\n        if (res == 0) {\n            break;\n        }\n\n        copied += res;\n        if (!(dst->flags & FUSE_BUF_FD_RETRY)) {\n            break;\n        }\n\n        src_off += res;\n        dst_off += res;\n        len -= res;\n    }\n\n    return copied;\n}"
  },
  {
    "function_name": "min_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
    "lines": "73-76",
    "snippet": "static size_t min_size(size_t s1, size_t s2)\n{\n    return s1 < s2 ? s1 : s2;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic size_t min_size(size_t s1, size_t s2)\n{\n    return s1 < s2 ? s1 : s2;\n}"
  },
  {
    "function_name": "fuse_buf_writev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
    "lines": "37-71",
    "snippet": "static ssize_t fuse_buf_writev(struct fuse_buf *out_buf,\n                               struct fuse_bufvec *in_buf)\n{\n    ssize_t res, i, j;\n    size_t iovcnt = in_buf->count;\n    struct iovec *iov;\n    int fd = out_buf->fd;\n\n    iov = calloc(iovcnt, sizeof(struct iovec));\n    if (!iov) {\n        return -ENOMEM;\n    }\n\n    for (i = 0, j = 0; i < iovcnt; i++) {\n        /* Skip the buf with 0 size */\n        if (in_buf->buf[i].size) {\n            iov[j].iov_base = in_buf->buf[i].mem;\n            iov[j].iov_len = in_buf->buf[i].size;\n            j++;\n        }\n    }\n\n    if (out_buf->flags & FUSE_BUF_FD_SEEK) {\n        res = pwritev(fd, iov, iovcnt, out_buf->pos);\n    } else {\n        res = writev(fd, iov, iovcnt);\n    }\n\n    if (res == -1) {\n        res = -errno;\n    }\n\n    free(iov);\n    return res;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "iov"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "fuse_free_req",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_lowlevel.c",
          "lines": "122-137",
          "snippet": "void fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}",
          "includes": [
            "#include <unistd.h>",
            "#include <sys/file.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stddef.h>",
            "#include <stdbool.h>",
            "#include <limits.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <unistd.h>\n#include <sys/file.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nvoid fuse_free_req(fuse_req_t req)\n{\n    int ctr;\n    struct fuse_session *se = req->se;\n\n    pthread_mutex_lock(&se->lock);\n    req->u.ni.func = NULL;\n    req->u.ni.data = NULL;\n    list_del_req(req);\n    ctr = --req->ctr;\n    req->ch = NULL;\n    pthread_mutex_unlock(&se->lock);\n    if (!ctr) {\n        destroy_req(req);\n    }\n}"
        }
      },
      {
        "call_info": {
          "callee": "writev",
          "args": [
            "fd",
            "iov",
            "iovcnt"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pwritev",
          "args": [
            "fd",
            "iov",
            "iovcnt",
            "out_buf->pos"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "calloc",
          "args": [
            "iovcnt",
            "sizeof(struct iovec)"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nstatic ssize_t fuse_buf_writev(struct fuse_buf *out_buf,\n                               struct fuse_bufvec *in_buf)\n{\n    ssize_t res, i, j;\n    size_t iovcnt = in_buf->count;\n    struct iovec *iov;\n    int fd = out_buf->fd;\n\n    iov = calloc(iovcnt, sizeof(struct iovec));\n    if (!iov) {\n        return -ENOMEM;\n    }\n\n    for (i = 0, j = 0; i < iovcnt; i++) {\n        /* Skip the buf with 0 size */\n        if (in_buf->buf[i].size) {\n            iov[j].iov_base = in_buf->buf[i].mem;\n            iov[j].iov_len = in_buf->buf[i].size;\n            j++;\n        }\n    }\n\n    if (out_buf->flags & FUSE_BUF_FD_SEEK) {\n        res = pwritev(fd, iov, iovcnt, out_buf->pos);\n    } else {\n        res = writev(fd, iov, iovcnt);\n    }\n\n    if (res == -1) {\n        res = -errno;\n    }\n\n    free(iov);\n    return res;\n}"
  },
  {
    "function_name": "fuse_buf_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/buffer.c",
    "lines": "21-35",
    "snippet": "size_t fuse_buf_size(const struct fuse_bufvec *bufv)\n{\n    size_t i;\n    size_t size = 0;\n\n    for (i = 0; i < bufv->count; i++) {\n        if (bufv->buf[i].size == SIZE_MAX) {\n            size = SIZE_MAX;\n        } else {\n            size += bufv->buf[i].size;\n        }\n    }\n\n    return size;\n}",
    "includes": [
      "#include <unistd.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <errno.h>",
      "#include <assert.h>",
      "#include \"fuse_lowlevel.h\"",
      "#include \"fuse_i.h\"",
      "#include \"qemu/osdep.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_lowlevel.h\"\n#include \"fuse_i.h\"\n#include \"qemu/osdep.h\"\n\nsize_t fuse_buf_size(const struct fuse_bufvec *bufv)\n{\n    size_t i;\n    size_t size = 0;\n\n    for (i = 0; i < bufv->count; i++) {\n        if (bufv->buf[i].size == SIZE_MAX) {\n            size = SIZE_MAX;\n        } else {\n            size += bufv->buf[i].size;\n        }\n    }\n\n    return size;\n}"
  }
]