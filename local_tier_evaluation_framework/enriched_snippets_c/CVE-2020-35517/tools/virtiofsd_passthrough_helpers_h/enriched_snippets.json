[
  {
    "function_name": "mknod_wrapper",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/passthrough_helpers.h",
    "lines": "30-51",
    "snippet": "static int mknod_wrapper(int dirfd, const char *path, const char *link,\n                         int mode, dev_t rdev)\n{\n    int res;\n\n    if (S_ISREG(mode)) {\n        res = openat(dirfd, path, O_CREAT | O_EXCL | O_WRONLY, mode);\n        if (res >= 0) {\n            res = close(res);\n        }\n    } else if (S_ISDIR(mode)) {\n        res = mkdirat(dirfd, path, mode);\n    } else if (S_ISLNK(mode) && link != NULL) {\n        res = symlinkat(link, dirfd, path);\n    } else if (S_ISFIFO(mode)) {\n        res = mkfifoat(dirfd, path, mode);\n    } else {\n        res = mknodat(dirfd, path, mode, rdev);\n    }\n\n    return res;\n}",
    "includes": [],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mknodat",
          "args": [
            "dirfd",
            "path",
            "mode",
            "rdev"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkfifoat",
          "args": [
            "dirfd",
            "path",
            "mode"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISFIFO",
          "args": [
            "mode"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "symlinkat",
          "args": [
            "link",
            "dirfd",
            "path"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISLNK",
          "args": [
            "mode"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mkdirat",
          "args": [
            "dirfd",
            "path",
            "mode"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "mode"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "res"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "virtio_session_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2020-35517/repo/tools/virtiofsd/fuse_virtio.c",
          "lines": "1022-1034",
          "snippet": "void virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}",
          "includes": [
            "#include \"contrib/libvhost-user/libvhost-user.h\"",
            "#include <unistd.h>",
            "#include <grp.h>",
            "#include <sys/types.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <sys/eventfd.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <stdint.h>",
            "#include <glib.h>",
            "#include <errno.h>",
            "#include <assert.h>",
            "#include \"fuse_virtio.h\"",
            "#include \"fuse_opt.h\"",
            "#include \"fuse_misc.h\"",
            "#include \"standard-headers/linux/fuse.h\"",
            "#include \"fuse_i.h\"",
            "#include \"qapi/error.h\"",
            "#include \"qemu/iov.h\"",
            "#include \"qemu/osdep.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"contrib/libvhost-user/libvhost-user.h\"\n#include <unistd.h>\n#include <grp.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/eventfd.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <glib.h>\n#include <errno.h>\n#include <assert.h>\n#include \"fuse_virtio.h\"\n#include \"fuse_opt.h\"\n#include \"fuse_misc.h\"\n#include \"standard-headers/linux/fuse.h\"\n#include \"fuse_i.h\"\n#include \"qapi/error.h\"\n#include \"qemu/iov.h\"\n#include \"qemu/osdep.h\"\n\nvoid virtio_session_close(struct fuse_session *se)\n{\n    close(se->vu_socketfd);\n\n    if (!se->virtio_dev) {\n        return;\n    }\n\n    free(se->virtio_dev->qi);\n    pthread_rwlock_destroy(&se->virtio_dev->vu_dispatch_rwlock);\n    free(se->virtio_dev);\n    se->virtio_dev = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "openat",
          "args": [
            "dirfd",
            "path",
            "O_CREAT | O_EXCL | O_WRONLY",
            "mode"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "S_ISREG",
          "args": [
            "mode"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "static int mknod_wrapper(int dirfd, const char *path, const char *link,\n                         int mode, dev_t rdev)\n{\n    int res;\n\n    if (S_ISREG(mode)) {\n        res = openat(dirfd, path, O_CREAT | O_EXCL | O_WRONLY, mode);\n        if (res >= 0) {\n            res = close(res);\n        }\n    } else if (S_ISDIR(mode)) {\n        res = mkdirat(dirfd, path, mode);\n    } else if (S_ISLNK(mode) && link != NULL) {\n        res = symlinkat(link, dirfd, path);\n    } else if (S_ISFIFO(mode)) {\n        res = mkfifoat(dirfd, path, mode);\n    } else {\n        res = mknodat(dirfd, path, mode, rdev);\n    }\n\n    return res;\n}"
  }
]