[
  {
    "function_name": "task_info_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "647-683",
    "snippet": "extern stepd_step_task_info_t *\ntask_info_create(int taskid, int gtaskid,\n\t\t char *ifname, char *ofname, char *efname)\n{\n\tstepd_step_task_info_t *t = xmalloc(sizeof(stepd_step_task_info_t));\n\n\txassert(taskid >= 0);\n\txassert(gtaskid >= 0);\n\n\tslurm_mutex_init(&t->mutex);\n\tslurm_mutex_lock(&t->mutex);\n\tt->state       = STEPD_STEP_TASK_INIT;\n\tt->id          = taskid;\n\tt->gtid\t       = gtaskid;\n\tt->pid         = (pid_t) -1;\n\tt->ifname      = ifname;\n\tt->ofname      = ofname;\n\tt->efname      = efname;\n\tt->stdin_fd    = -1;\n\tt->to_stdin    = -1;\n\tt->stdout_fd   = -1;\n\tt->from_stdout = -1;\n\tt->stderr_fd   = -1;\n\tt->from_stderr = -1;\n\tt->in          = NULL;\n\tt->out         = NULL;\n\tt->err         = NULL;\n\tt->killed_by_cmd = false;\n\tt->aborted     = false;\n\tt->esent       = false;\n\tt->exited      = false;\n\tt->estatus     = -1;\n\tt->argc\t       = 0;\n\tt->argv\t       = NULL;\n\tslurm_mutex_unlock(&t->mutex);\n\treturn t;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&t->mutex"
          ],
          "line": 681
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&t->mutex"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_init",
          "args": [
            "&t->mutex"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "gtaskid >= 0"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "taskid >= 0"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(stepd_step_task_info_t)"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);\n\nextern stepd_step_task_info_t *\ntask_info_create(int taskid, int gtaskid,\n\t\t char *ifname, char *ofname, char *efname)\n{\n\tstepd_step_task_info_t *t = xmalloc(sizeof(stepd_step_task_info_t));\n\n\txassert(taskid >= 0);\n\txassert(gtaskid >= 0);\n\n\tslurm_mutex_init(&t->mutex);\n\tslurm_mutex_lock(&t->mutex);\n\tt->state       = STEPD_STEP_TASK_INIT;\n\tt->id          = taskid;\n\tt->gtid\t       = gtaskid;\n\tt->pid         = (pid_t) -1;\n\tt->ifname      = ifname;\n\tt->ofname      = ofname;\n\tt->efname      = efname;\n\tt->stdin_fd    = -1;\n\tt->to_stdin    = -1;\n\tt->stdout_fd   = -1;\n\tt->from_stdout = -1;\n\tt->stderr_fd   = -1;\n\tt->from_stderr = -1;\n\tt->in          = NULL;\n\tt->out         = NULL;\n\tt->err         = NULL;\n\tt->killed_by_cmd = false;\n\tt->aborted     = false;\n\tt->esent       = false;\n\tt->exited      = false;\n\tt->estatus     = -1;\n\tt->argc\t       = 0;\n\tt->argv\t       = NULL;\n\tslurm_mutex_unlock(&t->mutex);\n\treturn t;\n}"
  },
  {
    "function_name": "srun_info_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "640-645",
    "snippet": "extern void\nsrun_info_destroy(srun_info_t *srun)\n{\n\txfree(srun->key);\n\txfree(srun);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "srun"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nextern void\nsrun_info_destroy(srun_info_t *srun)\n{\n\txfree(srun->key);\n\txfree(srun);\n}"
  },
  {
    "function_name": "srun_info_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "601-638",
    "snippet": "extern srun_info_t *\nsrun_info_create(slurm_cred_t *cred, slurm_addr_t *resp_addr,\n\t\t slurm_addr_t *ioaddr, uint16_t protocol_version)\n{\n\tchar             *data = NULL;\n\tuint32_t          len  = 0;\n\tsrun_info_t *srun = xmalloc(sizeof(srun_info_t));\n\tsrun_key_t       *key  = xmalloc(sizeof(srun_key_t));\n\n\tsrun->key    = key;\n\tif (!protocol_version || (protocol_version == (uint16_t)NO_VAL))\n\t\tprotocol_version = SLURM_PROTOCOL_VERSION;\n\tsrun->protocol_version = protocol_version;\n\t/*\n\t * If no credential was provided, return the empty\n\t * srun info object. (This is used, for example, when\n\t * creating a batch job structure)\n\t */\n\tif (!cred) return srun;\n\n\tslurm_cred_get_signature(cred, &data, &len);\n\n\tlen = len > SLURM_IO_KEY_SIZE ? SLURM_IO_KEY_SIZE : len;\n\n\tif (data != NULL) {\n\t\tmemcpy((void *) key->data, data, len);\n\n\t\tif (len < SLURM_IO_KEY_SIZE)\n\t\t\tmemset( (void *) (key->data + len), 0,\n\t\t\t\tSLURM_IO_KEY_SIZE - len);\n\t}\n\n\tif (ioaddr != NULL)\n\t\tsrun->ioaddr    = *ioaddr;\n\tif (resp_addr != NULL)\n\t\tsrun->resp_addr = *resp_addr;\n\treturn srun;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(void *) (key->data + len)",
            "0",
            "SLURM_IO_KEY_SIZE - len"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(void *) key->data",
            "data",
            "len"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_cred_get_signature",
          "args": [
            "cred",
            "&data",
            "&len"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(srun_key_t)"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(srun_info_t)"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nextern srun_info_t *\nsrun_info_create(slurm_cred_t *cred, slurm_addr_t *resp_addr,\n\t\t slurm_addr_t *ioaddr, uint16_t protocol_version)\n{\n\tchar             *data = NULL;\n\tuint32_t          len  = 0;\n\tsrun_info_t *srun = xmalloc(sizeof(srun_info_t));\n\tsrun_key_t       *key  = xmalloc(sizeof(srun_key_t));\n\n\tsrun->key    = key;\n\tif (!protocol_version || (protocol_version == (uint16_t)NO_VAL))\n\t\tprotocol_version = SLURM_PROTOCOL_VERSION;\n\tsrun->protocol_version = protocol_version;\n\t/*\n\t * If no credential was provided, return the empty\n\t * srun info object. (This is used, for example, when\n\t * creating a batch job structure)\n\t */\n\tif (!cred) return srun;\n\n\tslurm_cred_get_signature(cred, &data, &len);\n\n\tlen = len > SLURM_IO_KEY_SIZE ? SLURM_IO_KEY_SIZE : len;\n\n\tif (data != NULL) {\n\t\tmemcpy((void *) key->data, data, len);\n\n\t\tif (len < SLURM_IO_KEY_SIZE)\n\t\t\tmemset( (void *) (key->data + len), 0,\n\t\t\t\tSLURM_IO_KEY_SIZE - len);\n\t}\n\n\tif (ioaddr != NULL)\n\t\tsrun->ioaddr    = *ioaddr;\n\tif (resp_addr != NULL)\n\t\tsrun->resp_addr = *resp_addr;\n\treturn srun;\n}"
  },
  {
    "function_name": "stepd_step_rec_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "571-599",
    "snippet": "extern void\nstepd_step_rec_destroy(stepd_step_rec_t *job)\n{\n\tint i;\n\n\t_array_free(&job->env);\n\t_array_free(&job->argv);\n\n\tfor (i = 0; i < job->node_tasks; i++)\n\t\t_task_info_destroy(job->task[i], job->multi_prog);\n\teio_handle_destroy(job->eio);\n\tFREE_NULL_LIST(job->sruns);\n\tFREE_NULL_LIST(job->clients);\n\tFREE_NULL_LIST(job->stdout_eio_objs);\n\tFREE_NULL_LIST(job->stderr_eio_objs);\n\tFREE_NULL_LIST(job->free_incoming);\n\tFREE_NULL_LIST(job->free_outgoing);\n\tFREE_NULL_LIST(job->outgoing_cache);\n\txfree(job->envtp);\n\txfree(job->node_name);\n\tmpmd_free(job);\n\txfree(job->task_prolog);\n\txfree(job->task_epilog);\n\txfree(job->job_alloc_cores);\n\txfree(job->step_alloc_cores);\n\txfree(job->task_cnts);\n\txfree(job->user_name);\n\txfree(job);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "job"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mpmd_free",
          "args": [
            "job"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "mpmd_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/multi_prog.c",
          "lines": "512-534",
          "snippet": "extern void mpmd_free(stepd_step_rec_t *job)\n{\n\tint i;\n\n\tif (!job->mpmd_set)\n\t\treturn;\n\n\tif (job->mpmd_set->args) {\n\t\tfor (i = 0; i < job->ntasks; i++)\n\t\t\txfree(job->mpmd_set->args[i]);\n\t\txfree(job->mpmd_set->args);\n\t}\n\tif (job->mpmd_set->command) {\n\t\tfor (i = 0; i < job->ntasks; i++)\n\t\t\txfree(job->mpmd_set->command[i]);\n\t\txfree(job->mpmd_set->command);\n\t}\n\txfree(job->mpmd_set->first_pe);\n\txfree(job->mpmd_set->placement);\n\txfree(job->mpmd_set->start_pe);\n\txfree(job->mpmd_set->total_pe);\n\txfree(job->mpmd_set);\n}",
          "includes": [
            "#include \"multi_prog.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/log.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"multi_prog.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdio.h>\n\nextern void mpmd_free(stepd_step_rec_t *job)\n{\n\tint i;\n\n\tif (!job->mpmd_set)\n\t\treturn;\n\n\tif (job->mpmd_set->args) {\n\t\tfor (i = 0; i < job->ntasks; i++)\n\t\t\txfree(job->mpmd_set->args[i]);\n\t\txfree(job->mpmd_set->args);\n\t}\n\tif (job->mpmd_set->command) {\n\t\tfor (i = 0; i < job->ntasks; i++)\n\t\t\txfree(job->mpmd_set->command[i]);\n\t\txfree(job->mpmd_set->command);\n\t}\n\txfree(job->mpmd_set->first_pe);\n\txfree(job->mpmd_set->placement);\n\txfree(job->mpmd_set->start_pe);\n\txfree(job->mpmd_set->total_pe);\n\txfree(job->mpmd_set);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREE_NULL_LIST",
          "args": [
            "job->outgoing_cache"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREE_NULL_LIST",
          "args": [
            "job->free_outgoing"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREE_NULL_LIST",
          "args": [
            "job->free_incoming"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREE_NULL_LIST",
          "args": [
            "job->stderr_eio_objs"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREE_NULL_LIST",
          "args": [
            "job->stdout_eio_objs"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREE_NULL_LIST",
          "args": [
            "job->clients"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREE_NULL_LIST",
          "args": [
            "job->sruns"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eio_handle_destroy",
          "args": [
            "job->eio"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_task_info_destroy",
          "args": [
            "job->task[i]",
            "job->multi_prog"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "_task_info_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "222-232",
          "snippet": "static void\n_task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog)\n{\n\tslurm_mutex_lock(&t->mutex);\n\tslurm_mutex_unlock(&t->mutex);\n\tslurm_mutex_destroy(&t->mutex);\n\tif (multi_prog) {\n\t\txfree(t->argv);\n\t} /* otherwise, t->argv is a pointer to job->argv */\n\txfree(t);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);\n\nstatic void\n_task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog)\n{\n\tslurm_mutex_lock(&t->mutex);\n\tslurm_mutex_unlock(&t->mutex);\n\tslurm_mutex_destroy(&t->mutex);\n\tif (multi_prog) {\n\t\txfree(t->argv);\n\t} /* otherwise, t->argv is a pointer to job->argv */\n\txfree(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_array_free",
          "args": [
            "&job->argv"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "_array_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "204-212",
          "snippet": "static void\n_array_free(char ***array)\n{\n\tint i = 0;\n\twhile ((*array)[i] != NULL)\n\t\txfree((*array)[i++]);\n\txfree(*array);\n\t*array = NULL;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _array_free(char ***array);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _array_free(char ***array);\n\nstatic void\n_array_free(char ***array)\n{\n\tint i = 0;\n\twhile ((*array)[i] != NULL)\n\t\txfree((*array)[i++]);\n\txfree(*array);\n\t*array = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);\n\nextern void\nstepd_step_rec_destroy(stepd_step_rec_t *job)\n{\n\tint i;\n\n\t_array_free(&job->env);\n\t_array_free(&job->argv);\n\n\tfor (i = 0; i < job->node_tasks; i++)\n\t\t_task_info_destroy(job->task[i], job->multi_prog);\n\teio_handle_destroy(job->eio);\n\tFREE_NULL_LIST(job->sruns);\n\tFREE_NULL_LIST(job->clients);\n\tFREE_NULL_LIST(job->stdout_eio_objs);\n\tFREE_NULL_LIST(job->stderr_eio_objs);\n\tFREE_NULL_LIST(job->free_incoming);\n\tFREE_NULL_LIST(job->free_outgoing);\n\tFREE_NULL_LIST(job->outgoing_cache);\n\txfree(job->envtp);\n\txfree(job->node_name);\n\tmpmd_free(job);\n\txfree(job->task_prolog);\n\txfree(job->task_epilog);\n\txfree(job->job_alloc_cores);\n\txfree(job->step_alloc_cores);\n\txfree(job->task_cnts);\n\txfree(job->user_name);\n\txfree(job);\n}"
  },
  {
    "function_name": "batch_stepd_step_rec_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "437-569",
    "snippet": "extern stepd_step_rec_t *\nbatch_stepd_step_rec_create(batch_job_launch_msg_t *msg)\n{\n\tstepd_step_rec_t *job;\n\tsrun_info_t  *srun = NULL;\n\tchar *in_name;\n\n\txassert(msg != NULL);\n\n\tdebug3(\"entering batch_stepd_step_rec_create\");\n\n\tif (!slurm_valid_uid_gid((uid_t)msg->uid, &(msg->gid),\n\t\t\t\t &(msg->user_name), already_validated_uid, 1))\n\t\treturn NULL;\n\n\tif (acct_gather_check_acct_freq_task(msg->job_mem, msg->acctg_freq))\n\t\treturn NULL;\n\n\tjob = xmalloc(sizeof(stepd_step_rec_t));\n\n\tjob->state = SLURMSTEPD_STEP_STARTING;\n\tpthread_cond_init(&job->state_cond, NULL);\n\tpthread_mutex_init(&job->state_mutex, NULL);\n\tif (msg->cpus_per_node)\n\t\tjob->cpus    = msg->cpus_per_node[0];\n\tjob->node_tasks  = 1;\n\tjob->ntasks  = msg->ntasks;\n\tjob->jobid   = msg->job_id;\n\tjob->stepid  = msg->step_id;\n\tjob->array_job_id  = msg->array_job_id;\n\tjob->array_task_id = msg->array_task_id;\n\tjob->job_core_spec = msg->job_core_spec;\n\n\tjob->batch   = true;\n\tjob->node_name  = xstrdup(conf->node_name);\n\tjob->user_name  = xstrdup(msg->user_name);\n\tjob->uid        = (uid_t) msg->uid;\n\tjob->gid        = (gid_t) msg->gid;\n\n\tjob->profile    = msg->profile;\n\n\t/* give them all to the 1 task */\n\tjob->cpus_per_task = job->cpus;\n\n\t/* This needs to happen before acct_gather_profile_startpoll\n\t   and only really looks at the profile in the job.\n\t*/\n\tacct_gather_profile_g_node_step_start(job);\n\t/* needed for the jobacct_gather plugin to start */\n\tacct_gather_profile_startpoll(msg->acctg_freq,\n\t\t\t\t      conf->job_acct_gather_freq);\n\n\tjob->multi_prog = 0;\n\tjob->open_mode  = msg->open_mode;\n\tjob->overcommit = (bool) msg->overcommit;\n\n\tjob->cwd     = xstrdup(msg->work_dir);\n\n\tjob->ckpt_dir = xstrdup(msg->ckpt_dir);\n\tjob->restart_dir = xstrdup(msg->restart_dir);\n\n\tjob->env     = _array_copy(msg->envc, msg->environment);\n\tjob->eio     = eio_handle_create(0);\n\tjob->sruns   = list_create((ListDelF) _srun_info_destructor);\n\tjob->envtp   = xmalloc(sizeof(env_t));\n\tjob->envtp->jobid = -1;\n\tjob->envtp->stepid = -1;\n\tjob->envtp->procid = -1;\n\tjob->envtp->localid = -1;\n\tjob->envtp->nodeid = -1;\n\n\tjob->envtp->distribution = 0;\n\tjob->cpu_bind_type = msg->cpu_bind_type;\n\tjob->cpu_bind = xstrdup(msg->cpu_bind);\n\tjob->envtp->mem_bind_type = 0;\n\tjob->envtp->mem_bind = NULL;\n\tjob->envtp->ckpt_dir = NULL;\n\tjob->envtp->restart_cnt = msg->restart_cnt;\n\n\tif (msg->cpus_per_node)\n\t\tjob->cpus    = msg->cpus_per_node[0];\n\n\tformat_core_allocs(msg->cred, conf->node_name, conf->cpus,\n\t\t\t   &job->job_alloc_cores, &job->step_alloc_cores,\n\t\t\t   &job->job_mem, &job->step_mem);\n\tif (job->step_mem\n\t\t&& conf->mem_limit_enforce)\n\t\tjobacct_gather_set_mem_limit(job->jobid, NO_VAL, job->step_mem);\n\telse if (job->job_mem\n\t\t&& conf->mem_limit_enforce)\n\t\tjobacct_gather_set_mem_limit(job->jobid, NO_VAL, job->job_mem);\n\n\tget_cred_gres(msg->cred, conf->node_name,\n\t\t      &job->job_gres_list, &job->step_gres_list);\n\n\tsrun = srun_info_create(NULL, NULL, NULL, (uint16_t)NO_VAL);\n\n\tlist_append(job->sruns, (void *) srun);\n\n\tif (msg->argc) {\n\t\tjob->argc    = msg->argc;\n\t\tjob->argv    = _array_copy(job->argc, msg->argv);\n\t} else {\n\t\tjob->argc    = 1;\n\t\t/* job script has not yet been written out to disk --\n\t\t * argv will be filled in later by _make_batch_script()\n\t\t */\n\t\tjob->argv    = (char **) xmalloc(2 * sizeof(char *));\n\t}\n\n\tjob->task = xmalloc(sizeof(stepd_step_task_info_t *));\n\tif (msg->std_err == NULL)\n\t\tmsg->std_err = xstrdup(msg->std_out);\n\n\tif (msg->std_in == NULL)\n\t\tin_name = xstrdup(\"/dev/null\");\n\telse\n\t\tin_name = fname_create(job, msg->std_in, 0);\n\n\tjob->task[0] = task_info_create(0, 0,\n\t\t\t\t\tin_name,\n\t\t\t\t\t_batchfilename(job, msg->std_out),\n\t\t\t\t\t_batchfilename(job, msg->std_err));\n\tjob->task[0]->argc = job->argc;\n\tjob->task[0]->argv = job->argv;\n\n#ifdef HAVE_ALPS_CRAY\n\tselect_g_select_jobinfo_get(msg->select_jobinfo, SELECT_JOBDATA_RESV_ID,\n\t\t\t\t    &job->resv_id);\n#endif\n\n\treturn job;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "select_g_select_jobinfo_get",
          "args": [
            "msg->select_jobinfo",
            "SELECT_JOBDATA_RESV_ID",
            "&job->resv_id"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_info_create",
          "args": [
            "0",
            "0",
            "in_name",
            "_batchfilename(job, msg->std_out)",
            "_batchfilename(job, msg->std_err)"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "task_info_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "647-683",
          "snippet": "extern stepd_step_task_info_t *\ntask_info_create(int taskid, int gtaskid,\n\t\t char *ifname, char *ofname, char *efname)\n{\n\tstepd_step_task_info_t *t = xmalloc(sizeof(stepd_step_task_info_t));\n\n\txassert(taskid >= 0);\n\txassert(gtaskid >= 0);\n\n\tslurm_mutex_init(&t->mutex);\n\tslurm_mutex_lock(&t->mutex);\n\tt->state       = STEPD_STEP_TASK_INIT;\n\tt->id          = taskid;\n\tt->gtid\t       = gtaskid;\n\tt->pid         = (pid_t) -1;\n\tt->ifname      = ifname;\n\tt->ofname      = ofname;\n\tt->efname      = efname;\n\tt->stdin_fd    = -1;\n\tt->to_stdin    = -1;\n\tt->stdout_fd   = -1;\n\tt->from_stdout = -1;\n\tt->stderr_fd   = -1;\n\tt->from_stderr = -1;\n\tt->in          = NULL;\n\tt->out         = NULL;\n\tt->err         = NULL;\n\tt->killed_by_cmd = false;\n\tt->aborted     = false;\n\tt->esent       = false;\n\tt->exited      = false;\n\tt->estatus     = -1;\n\tt->argc\t       = 0;\n\tt->argv\t       = NULL;\n\tslurm_mutex_unlock(&t->mutex);\n\treturn t;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);\n\nextern stepd_step_task_info_t *\ntask_info_create(int taskid, int gtaskid,\n\t\t char *ifname, char *ofname, char *efname)\n{\n\tstepd_step_task_info_t *t = xmalloc(sizeof(stepd_step_task_info_t));\n\n\txassert(taskid >= 0);\n\txassert(gtaskid >= 0);\n\n\tslurm_mutex_init(&t->mutex);\n\tslurm_mutex_lock(&t->mutex);\n\tt->state       = STEPD_STEP_TASK_INIT;\n\tt->id          = taskid;\n\tt->gtid\t       = gtaskid;\n\tt->pid         = (pid_t) -1;\n\tt->ifname      = ifname;\n\tt->ofname      = ofname;\n\tt->efname      = efname;\n\tt->stdin_fd    = -1;\n\tt->to_stdin    = -1;\n\tt->stdout_fd   = -1;\n\tt->from_stdout = -1;\n\tt->stderr_fd   = -1;\n\tt->from_stderr = -1;\n\tt->in          = NULL;\n\tt->out         = NULL;\n\tt->err         = NULL;\n\tt->killed_by_cmd = false;\n\tt->aborted     = false;\n\tt->esent       = false;\n\tt->exited      = false;\n\tt->estatus     = -1;\n\tt->argc\t       = 0;\n\tt->argv\t       = NULL;\n\tslurm_mutex_unlock(&t->mutex);\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_batchfilename",
          "args": [
            "job",
            "msg->std_err"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "_batchfilename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "89-99",
          "snippet": "static char *\n_batchfilename(stepd_step_rec_t *job, const char *name)\n{\n\tif (name == NULL) {\n\t\tif (job->array_task_id == NO_VAL)\n\t\t\treturn fname_create(job, \"slurm-%J.out\", 0);\n\t\telse\n\t\t\treturn fname_create(job, \"slurm-%A_%a.out\", 0);\n\t} else\n\t\treturn fname_create(job, name, 0);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic char *\n_batchfilename(stepd_step_rec_t *job, const char *name)\n{\n\tif (name == NULL) {\n\t\tif (job->array_task_id == NO_VAL)\n\t\t\treturn fname_create(job, \"slurm-%J.out\", 0);\n\t\telse\n\t\t\treturn fname_create(job, \"slurm-%A_%a.out\", 0);\n\t} else\n\t\treturn fname_create(job, name, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fname_create",
          "args": [
            "job",
            "msg->std_in",
            "0"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "fname_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/fname.c",
          "lines": "76-115",
          "snippet": "char *\nfname_create(stepd_step_rec_t *job, const char *format, int taskid)\n{\n\tchar *name = NULL;\n\tchar *orig = xstrdup(format);\n\tint id;\n\tchar *esc;\n\n\tif (((id = fname_single_task_io (format)) >= 0) && (taskid != id))\n\t\treturn (xstrdup (\"/dev/null\"));\n\n\tesc = is_path_escaped(orig);\n\n\t/* If format doesn't specify an absolute pathname, use cwd\n\t */\n\tif (orig[0] != '/') {\n\t\txstrcat(name, job->cwd);\n\t\tif (esc) {\n\t\t\txstrcat(name, esc);\n\t\t\tgoto fini;\n\t\t}\n\t\tif (name[strlen(name)-1] != '/')\n\t\t\txstrcatchar(name, '/');\n\t}\n\n\tif (esc) {\n\t\t/* esc is malloc */\n\t\tname = esc;\n\t\tgoto fini;\n\t}\n\n\tif (job->batch)\n\t\tname = _create_batch_fname(name, orig, job, taskid);\n\telse\n\t\tname = _create_step_fname(name, orig, job, taskid);\n\nfini:\n\txfree(orig);\n\treturn name;\n}",
          "includes": [
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void _batch_path_check(char **p, char **q, char **name,\n\t\t\t      unsigned int wid, stepd_step_rec_t *job,\n\t\t\t      int taskid);",
            "static char * _create_batch_fname(char *name, char *path,\n\t\t\t\t  stepd_step_rec_t *job, int taskid);",
            "static char * _create_step_fname(char *name, char *path, stepd_step_rec_t *job,\n\t\t\t\t int taskid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/uid.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n\nstatic void _batch_path_check(char **p, char **q, char **name,\n\t\t\t      unsigned int wid, stepd_step_rec_t *job,\n\t\t\t      int taskid);\nstatic char * _create_batch_fname(char *name, char *path,\n\t\t\t\t  stepd_step_rec_t *job, int taskid);\nstatic char * _create_step_fname(char *name, char *path, stepd_step_rec_t *job,\n\t\t\t\t int taskid);\n\nchar *\nfname_create(stepd_step_rec_t *job, const char *format, int taskid)\n{\n\tchar *name = NULL;\n\tchar *orig = xstrdup(format);\n\tint id;\n\tchar *esc;\n\n\tif (((id = fname_single_task_io (format)) >= 0) && (taskid != id))\n\t\treturn (xstrdup (\"/dev/null\"));\n\n\tesc = is_path_escaped(orig);\n\n\t/* If format doesn't specify an absolute pathname, use cwd\n\t */\n\tif (orig[0] != '/') {\n\t\txstrcat(name, job->cwd);\n\t\tif (esc) {\n\t\t\txstrcat(name, esc);\n\t\t\tgoto fini;\n\t\t}\n\t\tif (name[strlen(name)-1] != '/')\n\t\t\txstrcatchar(name, '/');\n\t}\n\n\tif (esc) {\n\t\t/* esc is malloc */\n\t\tname = esc;\n\t\tgoto fini;\n\t}\n\n\tif (job->batch)\n\t\tname = _create_batch_fname(name, orig, job, taskid);\n\telse\n\t\tname = _create_step_fname(name, orig, job, taskid);\n\nfini:\n\txfree(orig);\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"/dev/null\""
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->std_out"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(stepd_step_task_info_t *)"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "2 * sizeof(char *)"
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_array_copy",
          "args": [
            "job->argc",
            "msg->argv"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "_array_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "190-202",
          "snippet": "static char **\n_array_copy(int n, char **src)\n{\n\tchar **dst = xmalloc((n+1) * sizeof(char *));\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tdst[i] = xstrdup(src[i]);\n\t}\n\tdst[n] = NULL;\n\n\treturn dst;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char ** _array_copy(int n, char **src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic char ** _array_copy(int n, char **src);\n\nstatic char **\n_array_copy(int n, char **src)\n{\n\tchar **dst = xmalloc((n+1) * sizeof(char *));\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tdst[i] = xstrdup(src[i]);\n\t}\n\tdst[n] = NULL;\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_append",
          "args": [
            "job->sruns",
            "(void *) srun"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srun_info_create",
          "args": [
            "NULL",
            "NULL",
            "NULL",
            "(uint16_t)NO_VAL"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "srun_info_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "601-638",
          "snippet": "extern srun_info_t *\nsrun_info_create(slurm_cred_t *cred, slurm_addr_t *resp_addr,\n\t\t slurm_addr_t *ioaddr, uint16_t protocol_version)\n{\n\tchar             *data = NULL;\n\tuint32_t          len  = 0;\n\tsrun_info_t *srun = xmalloc(sizeof(srun_info_t));\n\tsrun_key_t       *key  = xmalloc(sizeof(srun_key_t));\n\n\tsrun->key    = key;\n\tif (!protocol_version || (protocol_version == (uint16_t)NO_VAL))\n\t\tprotocol_version = SLURM_PROTOCOL_VERSION;\n\tsrun->protocol_version = protocol_version;\n\t/*\n\t * If no credential was provided, return the empty\n\t * srun info object. (This is used, for example, when\n\t * creating a batch job structure)\n\t */\n\tif (!cred) return srun;\n\n\tslurm_cred_get_signature(cred, &data, &len);\n\n\tlen = len > SLURM_IO_KEY_SIZE ? SLURM_IO_KEY_SIZE : len;\n\n\tif (data != NULL) {\n\t\tmemcpy((void *) key->data, data, len);\n\n\t\tif (len < SLURM_IO_KEY_SIZE)\n\t\t\tmemset( (void *) (key->data + len), 0,\n\t\t\t\tSLURM_IO_KEY_SIZE - len);\n\t}\n\n\tif (ioaddr != NULL)\n\t\tsrun->ioaddr    = *ioaddr;\n\tif (resp_addr != NULL)\n\t\tsrun->resp_addr = *resp_addr;\n\treturn srun;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nextern srun_info_t *\nsrun_info_create(slurm_cred_t *cred, slurm_addr_t *resp_addr,\n\t\t slurm_addr_t *ioaddr, uint16_t protocol_version)\n{\n\tchar             *data = NULL;\n\tuint32_t          len  = 0;\n\tsrun_info_t *srun = xmalloc(sizeof(srun_info_t));\n\tsrun_key_t       *key  = xmalloc(sizeof(srun_key_t));\n\n\tsrun->key    = key;\n\tif (!protocol_version || (protocol_version == (uint16_t)NO_VAL))\n\t\tprotocol_version = SLURM_PROTOCOL_VERSION;\n\tsrun->protocol_version = protocol_version;\n\t/*\n\t * If no credential was provided, return the empty\n\t * srun info object. (This is used, for example, when\n\t * creating a batch job structure)\n\t */\n\tif (!cred) return srun;\n\n\tslurm_cred_get_signature(cred, &data, &len);\n\n\tlen = len > SLURM_IO_KEY_SIZE ? SLURM_IO_KEY_SIZE : len;\n\n\tif (data != NULL) {\n\t\tmemcpy((void *) key->data, data, len);\n\n\t\tif (len < SLURM_IO_KEY_SIZE)\n\t\t\tmemset( (void *) (key->data + len), 0,\n\t\t\t\tSLURM_IO_KEY_SIZE - len);\n\t}\n\n\tif (ioaddr != NULL)\n\t\tsrun->ioaddr    = *ioaddr;\n\tif (resp_addr != NULL)\n\t\tsrun->resp_addr = *resp_addr;\n\treturn srun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cred_gres",
          "args": [
            "msg->cred",
            "conf->node_name",
            "&job->job_gres_list",
            "&job->step_gres_list"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacct_gather_set_mem_limit",
          "args": [
            "job->jobid",
            "NO_VAL",
            "job->job_mem"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacct_gather_set_mem_limit",
          "args": [
            "job->jobid",
            "NO_VAL",
            "job->step_mem"
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_core_allocs",
          "args": [
            "msg->cred",
            "conf->node_name",
            "conf->cpus",
            "&job->job_alloc_cores",
            "&job->step_alloc_cores",
            "&job->job_mem",
            "&job->step_mem"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->cpu_bind"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(env_t)"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_create",
          "args": [
            "(ListDelF) _srun_info_destructor"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "_script_list_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "178-210",
          "snippet": "static List _script_list_create (const char *pattern)\n{\n\tglob_t gl;\n\tsize_t i;\n\tList l = NULL;\n\n\tif (pattern == NULL)\n\t\treturn (NULL);\n\n\tint rc = glob (pattern, GLOB_ERR, _ef, &gl);\n\tswitch (rc) {\n\tcase 0:\n\t\tl = list_create ((ListDelF) _xfree_f);\n\t\tfor (i = 0; i < gl.gl_pathc; i++)\n\t\t\tlist_push (l, xstrdup (gl.gl_pathv[i]));\n\t\tbreak;\n\tcase GLOB_NOMATCH:\n\t\tbreak;\n\tcase GLOB_NOSPACE:\n\t\terror (\"run_script: glob(3): Out of memory\");\n\t\tbreak;\n\tcase GLOB_ABORTED:\n\t\terror (\"run_script: cannot read dir %s: %m\", pattern);\n\t\tbreak;\n\tdefault:\n\t\terror (\"Unknown glob(3) return code = %d\", rc);\n\t\tbreak;\n\t}\n\n\tglobfree (&gl);\n\n\treturn l;\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic List _script_list_create (const char *pattern)\n{\n\tglob_t gl;\n\tsize_t i;\n\tList l = NULL;\n\n\tif (pattern == NULL)\n\t\treturn (NULL);\n\n\tint rc = glob (pattern, GLOB_ERR, _ef, &gl);\n\tswitch (rc) {\n\tcase 0:\n\t\tl = list_create ((ListDelF) _xfree_f);\n\t\tfor (i = 0; i < gl.gl_pathc; i++)\n\t\t\tlist_push (l, xstrdup (gl.gl_pathv[i]));\n\t\tbreak;\n\tcase GLOB_NOMATCH:\n\t\tbreak;\n\tcase GLOB_NOSPACE:\n\t\terror (\"run_script: glob(3): Out of memory\");\n\t\tbreak;\n\tcase GLOB_ABORTED:\n\t\terror (\"run_script: cannot read dir %s: %m\", pattern);\n\t\tbreak;\n\tdefault:\n\t\terror (\"Unknown glob(3) return code = %d\", rc);\n\t\tbreak;\n\t}\n\n\tglobfree (&gl);\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eio_handle_create",
          "args": [
            "0"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->restart_dir"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->ckpt_dir"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->work_dir"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_gather_profile_startpoll",
          "args": [
            "msg->acctg_freq",
            "conf->job_acct_gather_freq"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_gather_profile_g_node_step_start",
          "args": [
            "job"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->user_name"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "conf->node_name"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_init",
          "args": [
            "&job->state_mutex",
            "NULL"
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_cond_init",
          "args": [
            "&job->state_cond",
            "NULL"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(stepd_step_rec_t)"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_gather_check_acct_freq_task",
          "args": [
            "msg->job_mem",
            "msg->acctg_freq"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_valid_uid_gid",
          "args": [
            "(uid_t)msg->uid",
            "&(msg->gid)",
            "&(msg->user_name)",
            "already_validated_uid",
            "1"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"entering batch_stepd_step_rec_create\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "msg != NULL"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);\n\nextern stepd_step_rec_t *\nbatch_stepd_step_rec_create(batch_job_launch_msg_t *msg)\n{\n\tstepd_step_rec_t *job;\n\tsrun_info_t  *srun = NULL;\n\tchar *in_name;\n\n\txassert(msg != NULL);\n\n\tdebug3(\"entering batch_stepd_step_rec_create\");\n\n\tif (!slurm_valid_uid_gid((uid_t)msg->uid, &(msg->gid),\n\t\t\t\t &(msg->user_name), already_validated_uid, 1))\n\t\treturn NULL;\n\n\tif (acct_gather_check_acct_freq_task(msg->job_mem, msg->acctg_freq))\n\t\treturn NULL;\n\n\tjob = xmalloc(sizeof(stepd_step_rec_t));\n\n\tjob->state = SLURMSTEPD_STEP_STARTING;\n\tpthread_cond_init(&job->state_cond, NULL);\n\tpthread_mutex_init(&job->state_mutex, NULL);\n\tif (msg->cpus_per_node)\n\t\tjob->cpus    = msg->cpus_per_node[0];\n\tjob->node_tasks  = 1;\n\tjob->ntasks  = msg->ntasks;\n\tjob->jobid   = msg->job_id;\n\tjob->stepid  = msg->step_id;\n\tjob->array_job_id  = msg->array_job_id;\n\tjob->array_task_id = msg->array_task_id;\n\tjob->job_core_spec = msg->job_core_spec;\n\n\tjob->batch   = true;\n\tjob->node_name  = xstrdup(conf->node_name);\n\tjob->user_name  = xstrdup(msg->user_name);\n\tjob->uid        = (uid_t) msg->uid;\n\tjob->gid        = (gid_t) msg->gid;\n\n\tjob->profile    = msg->profile;\n\n\t/* give them all to the 1 task */\n\tjob->cpus_per_task = job->cpus;\n\n\t/* This needs to happen before acct_gather_profile_startpoll\n\t   and only really looks at the profile in the job.\n\t*/\n\tacct_gather_profile_g_node_step_start(job);\n\t/* needed for the jobacct_gather plugin to start */\n\tacct_gather_profile_startpoll(msg->acctg_freq,\n\t\t\t\t      conf->job_acct_gather_freq);\n\n\tjob->multi_prog = 0;\n\tjob->open_mode  = msg->open_mode;\n\tjob->overcommit = (bool) msg->overcommit;\n\n\tjob->cwd     = xstrdup(msg->work_dir);\n\n\tjob->ckpt_dir = xstrdup(msg->ckpt_dir);\n\tjob->restart_dir = xstrdup(msg->restart_dir);\n\n\tjob->env     = _array_copy(msg->envc, msg->environment);\n\tjob->eio     = eio_handle_create(0);\n\tjob->sruns   = list_create((ListDelF) _srun_info_destructor);\n\tjob->envtp   = xmalloc(sizeof(env_t));\n\tjob->envtp->jobid = -1;\n\tjob->envtp->stepid = -1;\n\tjob->envtp->procid = -1;\n\tjob->envtp->localid = -1;\n\tjob->envtp->nodeid = -1;\n\n\tjob->envtp->distribution = 0;\n\tjob->cpu_bind_type = msg->cpu_bind_type;\n\tjob->cpu_bind = xstrdup(msg->cpu_bind);\n\tjob->envtp->mem_bind_type = 0;\n\tjob->envtp->mem_bind = NULL;\n\tjob->envtp->ckpt_dir = NULL;\n\tjob->envtp->restart_cnt = msg->restart_cnt;\n\n\tif (msg->cpus_per_node)\n\t\tjob->cpus    = msg->cpus_per_node[0];\n\n\tformat_core_allocs(msg->cred, conf->node_name, conf->cpus,\n\t\t\t   &job->job_alloc_cores, &job->step_alloc_cores,\n\t\t\t   &job->job_mem, &job->step_mem);\n\tif (job->step_mem\n\t\t&& conf->mem_limit_enforce)\n\t\tjobacct_gather_set_mem_limit(job->jobid, NO_VAL, job->step_mem);\n\telse if (job->job_mem\n\t\t&& conf->mem_limit_enforce)\n\t\tjobacct_gather_set_mem_limit(job->jobid, NO_VAL, job->job_mem);\n\n\tget_cred_gres(msg->cred, conf->node_name,\n\t\t      &job->job_gres_list, &job->step_gres_list);\n\n\tsrun = srun_info_create(NULL, NULL, NULL, (uint16_t)NO_VAL);\n\n\tlist_append(job->sruns, (void *) srun);\n\n\tif (msg->argc) {\n\t\tjob->argc    = msg->argc;\n\t\tjob->argv    = _array_copy(job->argc, msg->argv);\n\t} else {\n\t\tjob->argc    = 1;\n\t\t/* job script has not yet been written out to disk --\n\t\t * argv will be filled in later by _make_batch_script()\n\t\t */\n\t\tjob->argv    = (char **) xmalloc(2 * sizeof(char *));\n\t}\n\n\tjob->task = xmalloc(sizeof(stepd_step_task_info_t *));\n\tif (msg->std_err == NULL)\n\t\tmsg->std_err = xstrdup(msg->std_out);\n\n\tif (msg->std_in == NULL)\n\t\tin_name = xstrdup(\"/dev/null\");\n\telse\n\t\tin_name = fname_create(job, msg->std_in, 0);\n\n\tjob->task[0] = task_info_create(0, 0,\n\t\t\t\t\tin_name,\n\t\t\t\t\t_batchfilename(job, msg->std_out),\n\t\t\t\t\t_batchfilename(job, msg->std_err));\n\tjob->task[0]->argc = job->argc;\n\tjob->task[0]->argv = job->argv;\n\n#ifdef HAVE_ALPS_CRAY\n\tselect_g_select_jobinfo_get(msg->select_jobinfo, SELECT_JOBDATA_RESV_ID,\n\t\t\t\t    &job->resv_id);\n#endif\n\n\treturn job;\n}"
  },
  {
    "function_name": "stepd_step_rec_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "235-435",
    "snippet": "extern stepd_step_rec_t *\nstepd_step_rec_create(launch_tasks_request_msg_t *msg, uint16_t protocol_version)\n{\n\tstepd_step_rec_t  *job = NULL;\n\tsrun_info_t   *srun = NULL;\n\tslurm_addr_t     resp_addr;\n\tslurm_addr_t     io_addr;\n\tint            i, nodeid = NO_VAL;\n\n\txassert(msg != NULL);\n\txassert(msg->complete_nodelist != NULL);\n\tdebug3(\"entering stepd_step_rec_create\");\n\n\tif (!slurm_valid_uid_gid((uid_t)msg->uid, &(msg->gid),\n\t\t\t\t &(msg->user_name), already_validated_uid, 1))\n\t\treturn NULL;\n\n\tif (acct_gather_check_acct_freq_task(msg->job_mem_lim, msg->acctg_freq))\n\t\treturn NULL;\n\n\tjob = xmalloc(sizeof(stepd_step_rec_t));\n\tjob->msg = msg;\n#ifndef HAVE_FRONT_END\n\tnodeid = nodelist_find(msg->complete_nodelist, conf->node_name);\n\tjob->node_name = xstrdup(conf->node_name);\n#else\n\tnodeid = 0;\n\tjob->node_name = xstrdup(msg->complete_nodelist);\n#endif\n\tif (nodeid < 0) {\n\t\terror(\"couldn't find node %s in %s\",\n\t\t      job->node_name, msg->complete_nodelist);\n\t\tstepd_step_rec_destroy(job);\n\t\treturn NULL;\n\t}\n\n\tjob->state = SLURMSTEPD_STEP_STARTING;\n\tpthread_cond_init(&job->state_cond, NULL);\n\tpthread_mutex_init(&job->state_mutex, NULL);\n\tjob->node_tasks\t= msg->tasks_to_launch[nodeid];\n\ti = sizeof(uint16_t) * msg->nnodes;\n\tjob->task_cnts  = xmalloc(i);\n\tmemcpy(job->task_cnts, msg->tasks_to_launch, i);\n\tjob->ntasks\t= msg->ntasks;\n\tjob->jobid\t= msg->job_id;\n\tjob->stepid\t= msg->job_step_id;\n\n\tjob->uid\t= (uid_t) msg->uid;\n\tjob->user_name  = xstrdup(msg->user_name);\n\tjob->gid\t= (gid_t) msg->gid;\n\tjob->cwd\t= xstrdup(msg->cwd);\n\tjob->task_dist\t= msg->task_dist;\n\n\tjob->cpu_bind_type = msg->cpu_bind_type;\n\tjob->cpu_bind = xstrdup(msg->cpu_bind);\n\tjob->mem_bind_type = msg->mem_bind_type;\n\tjob->mem_bind = xstrdup(msg->mem_bind);\n\tjob->cpu_freq_min = msg->cpu_freq_min;\n\tjob->cpu_freq_max = msg->cpu_freq_max;\n\tjob->cpu_freq_gov = msg->cpu_freq_gov;\n\tjob->ckpt_dir = xstrdup(msg->ckpt_dir);\n\tjob->restart_dir = xstrdup(msg->restart_dir);\n\tjob->cpus_per_task = msg->cpus_per_task;\n\n\tjob->env     = _array_copy(msg->envc, msg->env);\n\tjob->array_job_id  = msg->job_id;\n\tjob->array_task_id = NO_VAL;\n\tfor (i = 0; i < msg->envc; i++) {\n\t\t/*                         1234567890123456789 */\n\t\tif (!xstrncmp(msg->env[i], \"SLURM_ARRAY_JOB_ID=\", 19))\n\t\t\tjob->array_job_id = atoi(msg->env[i] + 19);\n\t\t/*                         12345678901234567890 */\n\t\tif (!xstrncmp(msg->env[i], \"SLURM_ARRAY_TASK_ID=\", 20))\n\t\t\tjob->array_task_id = atoi(msg->env[i] + 20);\n\t}\n\n\tjob->eio     = eio_handle_create(0);\n\tjob->sruns   = list_create((ListDelF) _srun_info_destructor);\n\n\t/* Based on my testing the next 3 lists here could use the\n\t * eio_obj_destroy, but if you do you can get an invalid read.  Since\n\t * these stay until the end of the job it isn't that big of a deal.\n\t */\n\tjob->clients = list_create(NULL); /* FIXME! Needs destructor */\n\tjob->stdout_eio_objs = list_create(NULL); /* FIXME! Needs destructor */\n\tjob->stderr_eio_objs = list_create(NULL); /* FIXME! Needs destructor */\n\tjob->free_incoming = list_create(NULL); /* FIXME! Needs destructor */\n\tjob->incoming_count = 0;\n\tjob->free_outgoing = list_create(NULL); /* FIXME! Needs destructor */\n\tjob->outgoing_count = 0;\n\tjob->outgoing_cache = list_create(NULL); /* FIXME! Needs destructor */\n\n\tjob->envtp   = xmalloc(sizeof(env_t));\n\tjob->envtp->jobid = -1;\n\tjob->envtp->stepid = -1;\n\tjob->envtp->procid = -1;\n\tjob->envtp->localid = -1;\n\tjob->envtp->nodeid = -1;\n\n\tjob->envtp->distribution = 0;\n\tjob->envtp->cpu_bind_type = 0;\n\tjob->envtp->cpu_bind = NULL;\n\tjob->envtp->mem_bind_type = 0;\n\tjob->envtp->mem_bind = NULL;\n\tjob->envtp->ckpt_dir = NULL;\n\tif (!msg->resp_port)\n\t\tmsg->num_resp_port = 0;\n\tif (msg->num_resp_port) {\n\t\tjob->envtp->comm_port =\n\t\t\tmsg->resp_port[nodeid % msg->num_resp_port];\n\t\tmemcpy(&resp_addr, &msg->orig_addr, sizeof(slurm_addr_t));\n\t\tslurm_set_addr(&resp_addr,\n\t\t\t       msg->resp_port[nodeid % msg->num_resp_port],\n\t\t\t       NULL);\n\t} else {\n\t\tmemset(&resp_addr, 0, sizeof(slurm_addr_t));\n\t}\n\tjob->user_managed_io = msg->user_managed_io;\n\tif (!msg->io_port)\n\t\tmsg->user_managed_io = 1;\n\tif (!msg->user_managed_io) {\n\t\tmemcpy(&io_addr,   &msg->orig_addr, sizeof(slurm_addr_t));\n\t\tslurm_set_addr(&io_addr,\n\t\t\t       msg->io_port[nodeid % msg->num_io_port],\n\t\t\t       NULL);\n\t} else {\n\t\tmemset(&io_addr, 0, sizeof(slurm_addr_t));\n\t}\n\n\tsrun = srun_info_create(msg->cred, &resp_addr, &io_addr,\n\t\t\t\tprotocol_version);\n\n\tjob->buffered_stdio = msg->buffered_stdio;\n\tjob->labelio = msg->labelio;\n\n\tjob->profile     = msg->profile;\n\tjob->task_prolog = xstrdup(msg->task_prolog);\n\tjob->task_epilog = xstrdup(msg->task_epilog);\n\n\tjob->argc    = msg->argc;\n\tjob->argv    = _array_copy(job->argc, msg->argv);\n\n\tjob->nnodes  = msg->nnodes;\n\tjob->nodeid  = nodeid;\n\tjob->debug   = msg->slurmd_debug;\n\tjob->cpus    = msg->node_cpus;\n\tjob->job_core_spec = msg->job_core_spec;\n\n\t/* This needs to happen before acct_gather_profile_startpoll\n\t   and only really looks at the profile in the job.\n\t*/\n\tacct_gather_profile_g_node_step_start(job);\n\n\tacct_gather_profile_startpoll(msg->acctg_freq,\n\t\t\t\t      conf->job_acct_gather_freq);\n\n\tjob->multi_prog  = msg->multi_prog;\n\tjob->timelimit   = (time_t) -1;\n\tjob->task_flags  = msg->task_flags;\n\tjob->switch_job  = msg->switch_job;\n\tjob->pty         = msg->pty;\n\tjob->open_mode   = msg->open_mode;\n\tjob->options     = msg->options;\n\tformat_core_allocs(msg->cred, conf->node_name, conf->cpus,\n\t\t\t   &job->job_alloc_cores, &job->step_alloc_cores,\n\t\t\t   &job->job_mem, &job->step_mem);\n\n\t/* If users have configured MemLimitEnforce=no\n\t * in their slurm.conf keep going.\n\t */\n\tif (job->step_mem\n\t    && conf->mem_limit_enforce) {\n\t\tjobacct_gather_set_mem_limit(job->jobid, job->stepid,\n\t\t\t\t\t     job->step_mem);\n\t} else if (job->job_mem\n\t\t   && conf->mem_limit_enforce) {\n\t\tjobacct_gather_set_mem_limit(job->jobid, job->stepid,\n\t\t\t\t\t     job->job_mem);\n\t}\n\n#ifdef HAVE_ALPS_CRAY\n\t/* This is only used for Cray emulation mode where slurmd is used to\n\t * launch job steps. On a real Cray system, ALPS is used to launch\n\t * the tasks instead of SLURM. SLURM's task launch RPC does NOT\n\t * contain the reservation ID, so just use some non-zero value here\n\t * for testing purposes. */\n\tjob->resv_id = 1;\n\tselect_g_select_jobinfo_set(msg->select_jobinfo, SELECT_JOBDATA_RESV_ID,\n\t\t\t\t    &job->resv_id);\n#endif\n\n\tget_cred_gres(msg->cred, conf->node_name,\n\t\t      &job->job_gres_list, &job->step_gres_list);\n\n\tlist_append(job->sruns, (void *) srun);\n\n\t_job_init_task_info(job, msg->global_task_ids,\n\t\t\t    msg->ifname, msg->ofname, msg->efname);\n\n\treturn job;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);",
      "static void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_job_init_task_info",
          "args": [
            "job",
            "msg->global_task_ids",
            "msg->ifname",
            "msg->ofname",
            "msg->efname"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "_job_init_task_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "135-188",
          "snippet": "static void\n_job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t    char *ifname, char *ofname, char *efname)\n{\n\tint          i, node_id = job->nodeid;\n\tchar        *in, *out, *err;\n\n\tif (job->node_tasks == 0) {\n\t\terror(\"User requested launch of zero tasks!\");\n\t\tjob->task = NULL;\n\t\treturn;\n\t}\n\n#if defined(HAVE_NATIVE_CRAY)\n\tfor (i = 0; i < job->nnodes; i++) {\n\t\tint j;\n\t\tfor (j = 1; j < job->task_cnts[i]; j++) {\n\t\t\tif (gtid[i][j] != gtid[i][j-1] + 1) {\n\t\t\t\tjob->non_smp = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tjob->task = (stepd_step_task_info_t **)\n\t\txmalloc(job->node_tasks * sizeof(stepd_step_task_info_t *));\n\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tin = _expand_stdio_filename(ifname, gtid[node_id][i], job);\n\t\tout = _expand_stdio_filename(ofname, gtid[node_id][i], job);\n\t\terr = _expand_stdio_filename(efname, gtid[node_id][i], job);\n\t\tjob->task[i] = task_info_create(i, gtid[node_id][i], in, out,\n\t\t\t\t\t\terr);\n\t\tif (!job->multi_prog) {\n\t\t\tjob->task[i]->argc = job->argc;\n\t\t\tjob->task[i]->argv = job->argv;\n\t\t}\n\t}\n\n\tif (job->multi_prog) {\n\t\tchar *switch_type = slurm_get_switch_type();\n\t\tif (!xstrcmp(switch_type, \"switch/cray\"))\n\t\t\tmulti_prog_parse(job, gtid);\n\t\txfree(switch_type);\n\t\tfor (i = 0; i < job->node_tasks; i++){\n\t\t\tmulti_prog_get_argv(job->argv[1], job->env,\n\t\t\t\t\t    gtid[node_id][i],\n\t\t\t\t\t    &job->task[i]->argc,\n\t\t\t\t\t    &job->task[i]->argv,\n\t\t\t\t\t    job->argc, job->argv);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);",
            "static void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);\nstatic void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);\n\nstatic void\n_job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t    char *ifname, char *ofname, char *efname)\n{\n\tint          i, node_id = job->nodeid;\n\tchar        *in, *out, *err;\n\n\tif (job->node_tasks == 0) {\n\t\terror(\"User requested launch of zero tasks!\");\n\t\tjob->task = NULL;\n\t\treturn;\n\t}\n\n#if defined(HAVE_NATIVE_CRAY)\n\tfor (i = 0; i < job->nnodes; i++) {\n\t\tint j;\n\t\tfor (j = 1; j < job->task_cnts[i]; j++) {\n\t\t\tif (gtid[i][j] != gtid[i][j-1] + 1) {\n\t\t\t\tjob->non_smp = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tjob->task = (stepd_step_task_info_t **)\n\t\txmalloc(job->node_tasks * sizeof(stepd_step_task_info_t *));\n\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tin = _expand_stdio_filename(ifname, gtid[node_id][i], job);\n\t\tout = _expand_stdio_filename(ofname, gtid[node_id][i], job);\n\t\terr = _expand_stdio_filename(efname, gtid[node_id][i], job);\n\t\tjob->task[i] = task_info_create(i, gtid[node_id][i], in, out,\n\t\t\t\t\t\terr);\n\t\tif (!job->multi_prog) {\n\t\t\tjob->task[i]->argc = job->argc;\n\t\t\tjob->task[i]->argv = job->argv;\n\t\t}\n\t}\n\n\tif (job->multi_prog) {\n\t\tchar *switch_type = slurm_get_switch_type();\n\t\tif (!xstrcmp(switch_type, \"switch/cray\"))\n\t\t\tmulti_prog_parse(job, gtid);\n\t\txfree(switch_type);\n\t\tfor (i = 0; i < job->node_tasks; i++){\n\t\t\tmulti_prog_get_argv(job->argv[1], job->env,\n\t\t\t\t\t    gtid[node_id][i],\n\t\t\t\t\t    &job->task[i]->argc,\n\t\t\t\t\t    &job->task[i]->argv,\n\t\t\t\t\t    job->argc, job->argv);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_append",
          "args": [
            "job->sruns",
            "(void *) srun"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cred_gres",
          "args": [
            "msg->cred",
            "conf->node_name",
            "&job->job_gres_list",
            "&job->step_gres_list"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_g_select_jobinfo_set",
          "args": [
            "msg->select_jobinfo",
            "SELECT_JOBDATA_RESV_ID",
            "&job->resv_id"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacct_gather_set_mem_limit",
          "args": [
            "job->jobid",
            "job->stepid",
            "job->job_mem"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacct_gather_set_mem_limit",
          "args": [
            "job->jobid",
            "job->stepid",
            "job->step_mem"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "format_core_allocs",
          "args": [
            "msg->cred",
            "conf->node_name",
            "conf->cpus",
            "&job->job_alloc_cores",
            "&job->step_alloc_cores",
            "&job->job_mem",
            "&job->step_mem"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_gather_profile_startpoll",
          "args": [
            "msg->acctg_freq",
            "conf->job_acct_gather_freq"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_gather_profile_g_node_step_start",
          "args": [
            "job"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_array_copy",
          "args": [
            "job->argc",
            "msg->argv"
          ],
          "line": 375
        },
        "resolved": true,
        "details": {
          "function_name": "_array_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "190-202",
          "snippet": "static char **\n_array_copy(int n, char **src)\n{\n\tchar **dst = xmalloc((n+1) * sizeof(char *));\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tdst[i] = xstrdup(src[i]);\n\t}\n\tdst[n] = NULL;\n\n\treturn dst;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char ** _array_copy(int n, char **src);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic char ** _array_copy(int n, char **src);\n\nstatic char **\n_array_copy(int n, char **src)\n{\n\tchar **dst = xmalloc((n+1) * sizeof(char *));\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tdst[i] = xstrdup(src[i]);\n\t}\n\tdst[n] = NULL;\n\n\treturn dst;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->task_epilog"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->task_prolog"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "srun_info_create",
          "args": [
            "msg->cred",
            "&resp_addr",
            "&io_addr",
            "protocol_version"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "srun_info_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "601-638",
          "snippet": "extern srun_info_t *\nsrun_info_create(slurm_cred_t *cred, slurm_addr_t *resp_addr,\n\t\t slurm_addr_t *ioaddr, uint16_t protocol_version)\n{\n\tchar             *data = NULL;\n\tuint32_t          len  = 0;\n\tsrun_info_t *srun = xmalloc(sizeof(srun_info_t));\n\tsrun_key_t       *key  = xmalloc(sizeof(srun_key_t));\n\n\tsrun->key    = key;\n\tif (!protocol_version || (protocol_version == (uint16_t)NO_VAL))\n\t\tprotocol_version = SLURM_PROTOCOL_VERSION;\n\tsrun->protocol_version = protocol_version;\n\t/*\n\t * If no credential was provided, return the empty\n\t * srun info object. (This is used, for example, when\n\t * creating a batch job structure)\n\t */\n\tif (!cred) return srun;\n\n\tslurm_cred_get_signature(cred, &data, &len);\n\n\tlen = len > SLURM_IO_KEY_SIZE ? SLURM_IO_KEY_SIZE : len;\n\n\tif (data != NULL) {\n\t\tmemcpy((void *) key->data, data, len);\n\n\t\tif (len < SLURM_IO_KEY_SIZE)\n\t\t\tmemset( (void *) (key->data + len), 0,\n\t\t\t\tSLURM_IO_KEY_SIZE - len);\n\t}\n\n\tif (ioaddr != NULL)\n\t\tsrun->ioaddr    = *ioaddr;\n\tif (resp_addr != NULL)\n\t\tsrun->resp_addr = *resp_addr;\n\treturn srun;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nextern srun_info_t *\nsrun_info_create(slurm_cred_t *cred, slurm_addr_t *resp_addr,\n\t\t slurm_addr_t *ioaddr, uint16_t protocol_version)\n{\n\tchar             *data = NULL;\n\tuint32_t          len  = 0;\n\tsrun_info_t *srun = xmalloc(sizeof(srun_info_t));\n\tsrun_key_t       *key  = xmalloc(sizeof(srun_key_t));\n\n\tsrun->key    = key;\n\tif (!protocol_version || (protocol_version == (uint16_t)NO_VAL))\n\t\tprotocol_version = SLURM_PROTOCOL_VERSION;\n\tsrun->protocol_version = protocol_version;\n\t/*\n\t * If no credential was provided, return the empty\n\t * srun info object. (This is used, for example, when\n\t * creating a batch job structure)\n\t */\n\tif (!cred) return srun;\n\n\tslurm_cred_get_signature(cred, &data, &len);\n\n\tlen = len > SLURM_IO_KEY_SIZE ? SLURM_IO_KEY_SIZE : len;\n\n\tif (data != NULL) {\n\t\tmemcpy((void *) key->data, data, len);\n\n\t\tif (len < SLURM_IO_KEY_SIZE)\n\t\t\tmemset( (void *) (key->data + len), 0,\n\t\t\t\tSLURM_IO_KEY_SIZE - len);\n\t}\n\n\tif (ioaddr != NULL)\n\t\tsrun->ioaddr    = *ioaddr;\n\tif (resp_addr != NULL)\n\t\tsrun->resp_addr = *resp_addr;\n\treturn srun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&io_addr",
            "0",
            "sizeof(slurm_addr_t)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_set_addr",
          "args": [
            "&io_addr",
            "msg->io_port[nodeid % msg->num_io_port]",
            "NULL"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&io_addr",
            "&msg->orig_addr",
            "sizeof(slurm_addr_t)"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&resp_addr",
            "0",
            "sizeof(slurm_addr_t)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_set_addr",
          "args": [
            "&resp_addr",
            "msg->resp_port[nodeid % msg->num_resp_port]",
            "NULL"
          ],
          "line": 346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&resp_addr",
            "&msg->orig_addr",
            "sizeof(slurm_addr_t)"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(env_t)"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_create",
          "args": [
            "NULL"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "_script_list_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "178-210",
          "snippet": "static List _script_list_create (const char *pattern)\n{\n\tglob_t gl;\n\tsize_t i;\n\tList l = NULL;\n\n\tif (pattern == NULL)\n\t\treturn (NULL);\n\n\tint rc = glob (pattern, GLOB_ERR, _ef, &gl);\n\tswitch (rc) {\n\tcase 0:\n\t\tl = list_create ((ListDelF) _xfree_f);\n\t\tfor (i = 0; i < gl.gl_pathc; i++)\n\t\t\tlist_push (l, xstrdup (gl.gl_pathv[i]));\n\t\tbreak;\n\tcase GLOB_NOMATCH:\n\t\tbreak;\n\tcase GLOB_NOSPACE:\n\t\terror (\"run_script: glob(3): Out of memory\");\n\t\tbreak;\n\tcase GLOB_ABORTED:\n\t\terror (\"run_script: cannot read dir %s: %m\", pattern);\n\t\tbreak;\n\tdefault:\n\t\terror (\"Unknown glob(3) return code = %d\", rc);\n\t\tbreak;\n\t}\n\n\tglobfree (&gl);\n\n\treturn l;\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic List _script_list_create (const char *pattern)\n{\n\tglob_t gl;\n\tsize_t i;\n\tList l = NULL;\n\n\tif (pattern == NULL)\n\t\treturn (NULL);\n\n\tint rc = glob (pattern, GLOB_ERR, _ef, &gl);\n\tswitch (rc) {\n\tcase 0:\n\t\tl = list_create ((ListDelF) _xfree_f);\n\t\tfor (i = 0; i < gl.gl_pathc; i++)\n\t\t\tlist_push (l, xstrdup (gl.gl_pathv[i]));\n\t\tbreak;\n\tcase GLOB_NOMATCH:\n\t\tbreak;\n\tcase GLOB_NOSPACE:\n\t\terror (\"run_script: glob(3): Out of memory\");\n\t\tbreak;\n\tcase GLOB_ABORTED:\n\t\terror (\"run_script: cannot read dir %s: %m\", pattern);\n\t\tbreak;\n\tdefault:\n\t\terror (\"Unknown glob(3) return code = %d\", rc);\n\t\tbreak;\n\t}\n\n\tglobfree (&gl);\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "eio_handle_create",
          "args": [
            "0"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "msg->env[i] + 20"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrncmp",
          "args": [
            "msg->env[i]",
            "\"SLURM_ARRAY_TASK_ID=\"",
            "20"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "msg->env[i] + 19"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrncmp",
          "args": [
            "msg->env[i]",
            "\"SLURM_ARRAY_JOB_ID=\"",
            "19"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->restart_dir"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->ckpt_dir"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->mem_bind"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->cpu_bind"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->cwd"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->user_name"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "job->task_cnts",
            "msg->tasks_to_launch",
            "i"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "i"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_mutex_init",
          "args": [
            "&job->state_mutex",
            "NULL"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_cond_init",
          "args": [
            "&job->state_cond",
            "NULL"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stepd_step_rec_destroy",
          "args": [
            "job"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "stepd_step_rec_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "571-599",
          "snippet": "extern void\nstepd_step_rec_destroy(stepd_step_rec_t *job)\n{\n\tint i;\n\n\t_array_free(&job->env);\n\t_array_free(&job->argv);\n\n\tfor (i = 0; i < job->node_tasks; i++)\n\t\t_task_info_destroy(job->task[i], job->multi_prog);\n\teio_handle_destroy(job->eio);\n\tFREE_NULL_LIST(job->sruns);\n\tFREE_NULL_LIST(job->clients);\n\tFREE_NULL_LIST(job->stdout_eio_objs);\n\tFREE_NULL_LIST(job->stderr_eio_objs);\n\tFREE_NULL_LIST(job->free_incoming);\n\tFREE_NULL_LIST(job->free_outgoing);\n\tFREE_NULL_LIST(job->outgoing_cache);\n\txfree(job->envtp);\n\txfree(job->node_name);\n\tmpmd_free(job);\n\txfree(job->task_prolog);\n\txfree(job->task_epilog);\n\txfree(job->job_alloc_cores);\n\txfree(job->step_alloc_cores);\n\txfree(job->task_cnts);\n\txfree(job->user_name);\n\txfree(job);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);\n\nextern void\nstepd_step_rec_destroy(stepd_step_rec_t *job)\n{\n\tint i;\n\n\t_array_free(&job->env);\n\t_array_free(&job->argv);\n\n\tfor (i = 0; i < job->node_tasks; i++)\n\t\t_task_info_destroy(job->task[i], job->multi_prog);\n\teio_handle_destroy(job->eio);\n\tFREE_NULL_LIST(job->sruns);\n\tFREE_NULL_LIST(job->clients);\n\tFREE_NULL_LIST(job->stdout_eio_objs);\n\tFREE_NULL_LIST(job->stderr_eio_objs);\n\tFREE_NULL_LIST(job->free_incoming);\n\tFREE_NULL_LIST(job->free_outgoing);\n\tFREE_NULL_LIST(job->outgoing_cache);\n\txfree(job->envtp);\n\txfree(job->node_name);\n\tmpmd_free(job);\n\txfree(job->task_prolog);\n\txfree(job->task_epilog);\n\txfree(job->job_alloc_cores);\n\txfree(job->step_alloc_cores);\n\txfree(job->task_cnts);\n\txfree(job->user_name);\n\txfree(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"couldn't find node %s in %s\"",
            "job->node_name",
            "msg->complete_nodelist"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "msg->complete_nodelist"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "conf->node_name"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nodelist_find",
          "args": [
            "msg->complete_nodelist",
            "conf->node_name"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(stepd_step_rec_t)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_gather_check_acct_freq_task",
          "args": [
            "msg->job_mem_lim",
            "msg->acctg_freq"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_valid_uid_gid",
          "args": [
            "(uid_t)msg->uid",
            "&(msg->gid)",
            "&(msg->user_name)",
            "already_validated_uid",
            "1"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"entering stepd_step_rec_create\""
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "msg->complete_nodelist != NULL"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "msg != NULL"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);\nstatic void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);\n\nextern stepd_step_rec_t *\nstepd_step_rec_create(launch_tasks_request_msg_t *msg, uint16_t protocol_version)\n{\n\tstepd_step_rec_t  *job = NULL;\n\tsrun_info_t   *srun = NULL;\n\tslurm_addr_t     resp_addr;\n\tslurm_addr_t     io_addr;\n\tint            i, nodeid = NO_VAL;\n\n\txassert(msg != NULL);\n\txassert(msg->complete_nodelist != NULL);\n\tdebug3(\"entering stepd_step_rec_create\");\n\n\tif (!slurm_valid_uid_gid((uid_t)msg->uid, &(msg->gid),\n\t\t\t\t &(msg->user_name), already_validated_uid, 1))\n\t\treturn NULL;\n\n\tif (acct_gather_check_acct_freq_task(msg->job_mem_lim, msg->acctg_freq))\n\t\treturn NULL;\n\n\tjob = xmalloc(sizeof(stepd_step_rec_t));\n\tjob->msg = msg;\n#ifndef HAVE_FRONT_END\n\tnodeid = nodelist_find(msg->complete_nodelist, conf->node_name);\n\tjob->node_name = xstrdup(conf->node_name);\n#else\n\tnodeid = 0;\n\tjob->node_name = xstrdup(msg->complete_nodelist);\n#endif\n\tif (nodeid < 0) {\n\t\terror(\"couldn't find node %s in %s\",\n\t\t      job->node_name, msg->complete_nodelist);\n\t\tstepd_step_rec_destroy(job);\n\t\treturn NULL;\n\t}\n\n\tjob->state = SLURMSTEPD_STEP_STARTING;\n\tpthread_cond_init(&job->state_cond, NULL);\n\tpthread_mutex_init(&job->state_mutex, NULL);\n\tjob->node_tasks\t= msg->tasks_to_launch[nodeid];\n\ti = sizeof(uint16_t) * msg->nnodes;\n\tjob->task_cnts  = xmalloc(i);\n\tmemcpy(job->task_cnts, msg->tasks_to_launch, i);\n\tjob->ntasks\t= msg->ntasks;\n\tjob->jobid\t= msg->job_id;\n\tjob->stepid\t= msg->job_step_id;\n\n\tjob->uid\t= (uid_t) msg->uid;\n\tjob->user_name  = xstrdup(msg->user_name);\n\tjob->gid\t= (gid_t) msg->gid;\n\tjob->cwd\t= xstrdup(msg->cwd);\n\tjob->task_dist\t= msg->task_dist;\n\n\tjob->cpu_bind_type = msg->cpu_bind_type;\n\tjob->cpu_bind = xstrdup(msg->cpu_bind);\n\tjob->mem_bind_type = msg->mem_bind_type;\n\tjob->mem_bind = xstrdup(msg->mem_bind);\n\tjob->cpu_freq_min = msg->cpu_freq_min;\n\tjob->cpu_freq_max = msg->cpu_freq_max;\n\tjob->cpu_freq_gov = msg->cpu_freq_gov;\n\tjob->ckpt_dir = xstrdup(msg->ckpt_dir);\n\tjob->restart_dir = xstrdup(msg->restart_dir);\n\tjob->cpus_per_task = msg->cpus_per_task;\n\n\tjob->env     = _array_copy(msg->envc, msg->env);\n\tjob->array_job_id  = msg->job_id;\n\tjob->array_task_id = NO_VAL;\n\tfor (i = 0; i < msg->envc; i++) {\n\t\t/*                         1234567890123456789 */\n\t\tif (!xstrncmp(msg->env[i], \"SLURM_ARRAY_JOB_ID=\", 19))\n\t\t\tjob->array_job_id = atoi(msg->env[i] + 19);\n\t\t/*                         12345678901234567890 */\n\t\tif (!xstrncmp(msg->env[i], \"SLURM_ARRAY_TASK_ID=\", 20))\n\t\t\tjob->array_task_id = atoi(msg->env[i] + 20);\n\t}\n\n\tjob->eio     = eio_handle_create(0);\n\tjob->sruns   = list_create((ListDelF) _srun_info_destructor);\n\n\t/* Based on my testing the next 3 lists here could use the\n\t * eio_obj_destroy, but if you do you can get an invalid read.  Since\n\t * these stay until the end of the job it isn't that big of a deal.\n\t */\n\tjob->clients = list_create(NULL); /* FIXME! Needs destructor */\n\tjob->stdout_eio_objs = list_create(NULL); /* FIXME! Needs destructor */\n\tjob->stderr_eio_objs = list_create(NULL); /* FIXME! Needs destructor */\n\tjob->free_incoming = list_create(NULL); /* FIXME! Needs destructor */\n\tjob->incoming_count = 0;\n\tjob->free_outgoing = list_create(NULL); /* FIXME! Needs destructor */\n\tjob->outgoing_count = 0;\n\tjob->outgoing_cache = list_create(NULL); /* FIXME! Needs destructor */\n\n\tjob->envtp   = xmalloc(sizeof(env_t));\n\tjob->envtp->jobid = -1;\n\tjob->envtp->stepid = -1;\n\tjob->envtp->procid = -1;\n\tjob->envtp->localid = -1;\n\tjob->envtp->nodeid = -1;\n\n\tjob->envtp->distribution = 0;\n\tjob->envtp->cpu_bind_type = 0;\n\tjob->envtp->cpu_bind = NULL;\n\tjob->envtp->mem_bind_type = 0;\n\tjob->envtp->mem_bind = NULL;\n\tjob->envtp->ckpt_dir = NULL;\n\tif (!msg->resp_port)\n\t\tmsg->num_resp_port = 0;\n\tif (msg->num_resp_port) {\n\t\tjob->envtp->comm_port =\n\t\t\tmsg->resp_port[nodeid % msg->num_resp_port];\n\t\tmemcpy(&resp_addr, &msg->orig_addr, sizeof(slurm_addr_t));\n\t\tslurm_set_addr(&resp_addr,\n\t\t\t       msg->resp_port[nodeid % msg->num_resp_port],\n\t\t\t       NULL);\n\t} else {\n\t\tmemset(&resp_addr, 0, sizeof(slurm_addr_t));\n\t}\n\tjob->user_managed_io = msg->user_managed_io;\n\tif (!msg->io_port)\n\t\tmsg->user_managed_io = 1;\n\tif (!msg->user_managed_io) {\n\t\tmemcpy(&io_addr,   &msg->orig_addr, sizeof(slurm_addr_t));\n\t\tslurm_set_addr(&io_addr,\n\t\t\t       msg->io_port[nodeid % msg->num_io_port],\n\t\t\t       NULL);\n\t} else {\n\t\tmemset(&io_addr, 0, sizeof(slurm_addr_t));\n\t}\n\n\tsrun = srun_info_create(msg->cred, &resp_addr, &io_addr,\n\t\t\t\tprotocol_version);\n\n\tjob->buffered_stdio = msg->buffered_stdio;\n\tjob->labelio = msg->labelio;\n\n\tjob->profile     = msg->profile;\n\tjob->task_prolog = xstrdup(msg->task_prolog);\n\tjob->task_epilog = xstrdup(msg->task_epilog);\n\n\tjob->argc    = msg->argc;\n\tjob->argv    = _array_copy(job->argc, msg->argv);\n\n\tjob->nnodes  = msg->nnodes;\n\tjob->nodeid  = nodeid;\n\tjob->debug   = msg->slurmd_debug;\n\tjob->cpus    = msg->node_cpus;\n\tjob->job_core_spec = msg->job_core_spec;\n\n\t/* This needs to happen before acct_gather_profile_startpoll\n\t   and only really looks at the profile in the job.\n\t*/\n\tacct_gather_profile_g_node_step_start(job);\n\n\tacct_gather_profile_startpoll(msg->acctg_freq,\n\t\t\t\t      conf->job_acct_gather_freq);\n\n\tjob->multi_prog  = msg->multi_prog;\n\tjob->timelimit   = (time_t) -1;\n\tjob->task_flags  = msg->task_flags;\n\tjob->switch_job  = msg->switch_job;\n\tjob->pty         = msg->pty;\n\tjob->open_mode   = msg->open_mode;\n\tjob->options     = msg->options;\n\tformat_core_allocs(msg->cred, conf->node_name, conf->cpus,\n\t\t\t   &job->job_alloc_cores, &job->step_alloc_cores,\n\t\t\t   &job->job_mem, &job->step_mem);\n\n\t/* If users have configured MemLimitEnforce=no\n\t * in their slurm.conf keep going.\n\t */\n\tif (job->step_mem\n\t    && conf->mem_limit_enforce) {\n\t\tjobacct_gather_set_mem_limit(job->jobid, job->stepid,\n\t\t\t\t\t     job->step_mem);\n\t} else if (job->job_mem\n\t\t   && conf->mem_limit_enforce) {\n\t\tjobacct_gather_set_mem_limit(job->jobid, job->stepid,\n\t\t\t\t\t     job->job_mem);\n\t}\n\n#ifdef HAVE_ALPS_CRAY\n\t/* This is only used for Cray emulation mode where slurmd is used to\n\t * launch job steps. On a real Cray system, ALPS is used to launch\n\t * the tasks instead of SLURM. SLURM's task launch RPC does NOT\n\t * contain the reservation ID, so just use some non-zero value here\n\t * for testing purposes. */\n\tjob->resv_id = 1;\n\tselect_g_select_jobinfo_set(msg->select_jobinfo, SELECT_JOBDATA_RESV_ID,\n\t\t\t\t    &job->resv_id);\n#endif\n\n\tget_cred_gres(msg->cred, conf->node_name,\n\t\t      &job->job_gres_list, &job->step_gres_list);\n\n\tlist_append(job->sruns, (void *) srun);\n\n\t_job_init_task_info(job, msg->global_task_ids,\n\t\t\t    msg->ifname, msg->ofname, msg->efname);\n\n\treturn job;\n}"
  },
  {
    "function_name": "_task_info_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "222-232",
    "snippet": "static void\n_task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog)\n{\n\tslurm_mutex_lock(&t->mutex);\n\tslurm_mutex_unlock(&t->mutex);\n\tslurm_mutex_destroy(&t->mutex);\n\tif (multi_prog) {\n\t\txfree(t->argv);\n\t} /* otherwise, t->argv is a pointer to job->argv */\n\txfree(t);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "t"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_mutex_destroy",
          "args": [
            "&t->mutex"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&t->mutex"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&t->mutex"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);\n\nstatic void\n_task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog)\n{\n\tslurm_mutex_lock(&t->mutex);\n\tslurm_mutex_unlock(&t->mutex);\n\tslurm_mutex_destroy(&t->mutex);\n\tif (multi_prog) {\n\t\txfree(t->argv);\n\t} /* otherwise, t->argv is a pointer to job->argv */\n\txfree(t);\n}"
  },
  {
    "function_name": "_srun_info_destructor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "215-220",
    "snippet": "static void\n_srun_info_destructor(void *arg)\n{\n\tsrun_info_t *srun = (srun_info_t *)arg;\n\tsrun_info_destroy(srun);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _srun_info_destructor(void *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "srun_info_destroy",
          "args": [
            "srun"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "srun_info_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "640-645",
          "snippet": "extern void\nsrun_info_destroy(srun_info_t *srun)\n{\n\txfree(srun->key);\n\txfree(srun);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nextern void\nsrun_info_destroy(srun_info_t *srun)\n{\n\txfree(srun->key);\n\txfree(srun);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _srun_info_destructor(void *arg);\n\nstatic void\n_srun_info_destructor(void *arg)\n{\n\tsrun_info_t *srun = (srun_info_t *)arg;\n\tsrun_info_destroy(srun);\n}"
  },
  {
    "function_name": "_array_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "204-212",
    "snippet": "static void\n_array_free(char ***array)\n{\n\tint i = 0;\n\twhile ((*array)[i] != NULL)\n\t\txfree((*array)[i++]);\n\txfree(*array);\n\t*array = NULL;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _array_free(char ***array);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "*array"
          ],
          "line": 210
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _array_free(char ***array);\n\nstatic void\n_array_free(char ***array)\n{\n\tint i = 0;\n\twhile ((*array)[i] != NULL)\n\t\txfree((*array)[i++]);\n\txfree(*array);\n\t*array = NULL;\n}"
  },
  {
    "function_name": "_array_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "190-202",
    "snippet": "static char **\n_array_copy(int n, char **src)\n{\n\tchar **dst = xmalloc((n+1) * sizeof(char *));\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tdst[i] = xstrdup(src[i]);\n\t}\n\tdst[n] = NULL;\n\n\treturn dst;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char ** _array_copy(int n, char **src);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "src[i]"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "(n+1) * sizeof(char *)"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic char ** _array_copy(int n, char **src);\n\nstatic char **\n_array_copy(int n, char **src)\n{\n\tchar **dst = xmalloc((n+1) * sizeof(char *));\n\tint i;\n\n\tfor (i = 0; i < n; i++) {\n\t\tdst[i] = xstrdup(src[i]);\n\t}\n\tdst[n] = NULL;\n\n\treturn dst;\n}"
  },
  {
    "function_name": "_job_init_task_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "135-188",
    "snippet": "static void\n_job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t    char *ifname, char *ofname, char *efname)\n{\n\tint          i, node_id = job->nodeid;\n\tchar        *in, *out, *err;\n\n\tif (job->node_tasks == 0) {\n\t\terror(\"User requested launch of zero tasks!\");\n\t\tjob->task = NULL;\n\t\treturn;\n\t}\n\n#if defined(HAVE_NATIVE_CRAY)\n\tfor (i = 0; i < job->nnodes; i++) {\n\t\tint j;\n\t\tfor (j = 1; j < job->task_cnts[i]; j++) {\n\t\t\tif (gtid[i][j] != gtid[i][j-1] + 1) {\n\t\t\t\tjob->non_smp = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tjob->task = (stepd_step_task_info_t **)\n\t\txmalloc(job->node_tasks * sizeof(stepd_step_task_info_t *));\n\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tin = _expand_stdio_filename(ifname, gtid[node_id][i], job);\n\t\tout = _expand_stdio_filename(ofname, gtid[node_id][i], job);\n\t\terr = _expand_stdio_filename(efname, gtid[node_id][i], job);\n\t\tjob->task[i] = task_info_create(i, gtid[node_id][i], in, out,\n\t\t\t\t\t\terr);\n\t\tif (!job->multi_prog) {\n\t\t\tjob->task[i]->argc = job->argc;\n\t\t\tjob->task[i]->argv = job->argv;\n\t\t}\n\t}\n\n\tif (job->multi_prog) {\n\t\tchar *switch_type = slurm_get_switch_type();\n\t\tif (!xstrcmp(switch_type, \"switch/cray\"))\n\t\t\tmulti_prog_parse(job, gtid);\n\t\txfree(switch_type);\n\t\tfor (i = 0; i < job->node_tasks; i++){\n\t\t\tmulti_prog_get_argv(job->argv[1], job->env,\n\t\t\t\t\t    gtid[node_id][i],\n\t\t\t\t\t    &job->task[i]->argc,\n\t\t\t\t\t    &job->task[i]->argv,\n\t\t\t\t\t    job->argc, job->argv);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);",
      "static void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "multi_prog_get_argv",
          "args": [
            "job->argv[1]",
            "job->env",
            "gtid[node_id][i]",
            "&job->task[i]->argc",
            "&job->task[i]->argv",
            "job->argc",
            "job->argv"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "multi_prog_get_argv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/multi_prog.c",
          "lines": "145-297",
          "snippet": "extern int multi_prog_get_argv(char *config_data, char **prog_env,\n\t\t\t       int task_rank, uint32_t *argc, char ***argv,\n\t\t\t       int global_argc, char **global_argv)\n{\n\tchar *line = NULL;\n\tint i, line_num = 0;\n\tint task_offset;\n\tchar *p = NULL, *s = NULL, *ptrptr = NULL;\n\tchar *rank_spec = NULL, *args_spec = NULL;\n\tint prog_argc = 0;\n\tchar **prog_argv = NULL;\n\tchar *local_data = NULL;\n\n\tprog_argv = (char **)xmalloc(sizeof(char *) * MAX_ARGC);\n\n\tif (task_rank < 0) {\n\t\terror(\"Invalid task rank %d\", task_rank);\n\t\t*argc = 1;\n\t\t*argv = prog_argv;\n\t\treturn -1;\n\t}\n\n\tlocal_data = xstrdup(config_data);\n\n\tline = strtok_r(local_data, \"\\n\", &ptrptr);\n\twhile (line) {\n\t\tif (line_num > 0)\n\t\t\tline = strtok_r(NULL, \"\\n\", &ptrptr);\n\t\tif (line == NULL) {\n\t\t\terror(\"No executable program specified for this task\");\n\t\t\tgoto fail;\n\t\t}\n\t\tline_num ++;\n\t\tif (strlen (line) >= (BUF_SIZE - 1)) {\n\t\t\terror (\"Line %d of configuration file too long\",\n\t\t\t\tline_num);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tp = line;\n\t\twhile (*p != '\\0' && isspace (*p)) /* remove leading spaces */\n\t\t\tp ++;\n\n\t\tif (*p == '#') /* only whole-line comments handled */\n\t\t\tcontinue;\n\n\t\tif (*p == '\\0') /* blank line ignored */\n\t\t\tcontinue;\n\n\t\trank_spec = p;\n\n\t\twhile (*p != '\\0' && !isspace (*p))\n\t\t\tp ++;\n\t\tif (*p == '\\0') {\n\t\t\terror(\"Invalid MPMD configuration line %d\", line_num);\n\t\t\tgoto fail;\n\t\t}\n\t\t*p ++ = '\\0';\n\n\t\tif (!_in_range (task_rank, rank_spec, &task_offset))\n\t\t\tcontinue;\n\n\t\t/* skip all whitspace after the range spec */\n\t\twhile(*p != '\\0' && isspace (*p))\n\t\t\tp++;\n\n\t\targs_spec = p;\n\t\twhile (*args_spec != '\\0') {\n\t\t\t/* Only simple quote and escape supported */\n\t\t\tprog_argv[prog_argc ++] = args_spec;\n\t\t\tif ((prog_argc + 1) >= MAX_ARGC) {\n\t\t\t\tinfo(\"Exceeded multi-prog argc limit\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\tCONT:\twhile (*args_spec != '\\0' && *args_spec != '\\\\'\n\t\t\t&&     *args_spec != '%'\n\t\t\t&&     *args_spec != '\\'' && !isspace (*args_spec)) {\n\t\t\t\targs_spec ++;\n\t\t\t}\n\t\t\tif (*args_spec == '\\0') {\n\t\t\t\t/* the last argument */\n\t\t\t\tbreak;\n\n\t\t\t} else if (*args_spec == '%') {\n\t\t\t\t_sub_expression(args_spec, task_rank,\n\t\t\t\t\ttask_offset);\n\t\t\t\targs_spec ++;\n\t\t\t\tgoto CONT;\n\n\t\t\t} else if (*args_spec == '\\\\') {\n\t\t\t\t/* escape, just remove the backslash */\n\t\t\t\ts = args_spec ++;\n\t\t\t\tp = args_spec;\n\t\t\t\tdo {\n\t\t\t\t\t*s ++ = *p;\n\t\t\t\t} while (*p ++ != '\\0');\n\t\t\t\tgoto CONT;\n\n\t\t\t} else if (*args_spec == '\\'') {\n\t\t\t\t/* single quote,\n\t\t\t\t * preserve all characters quoted. */\n\t\t\t\tp = args_spec + 1;\n\t\t\t\twhile (*p != '\\0' && *p != '\\'') {\n\t\t\t\t\t/* remove quote */\n\t\t\t\t\t*args_spec ++ = *p ++;\n\t\t\t\t}\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\t/* closing quote not found */\n\t\t\t\t\terror(\"Program arguments specification\"\n\t\t\t\t\t\t\" format invalid: %s.\",\n\t\t\t\t\t\tprog_argv[prog_argc -1]);\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tp ++; /* skip closing quote */\n\t\t\t\ts = args_spec;\n\t\t\t\tdo {\n\t\t\t\t\t*s ++ = *p;\n\t\t\t\t} while (*p ++ != '\\0');\n\t\t\t\tgoto CONT;\n\n\t\t\t} else {\n\t\t\t\t/* space */\n\t\t\t\t*args_spec ++ = '\\0';\n\t\t\t\twhile (*args_spec != '\\0'\n\t\t\t\t&& isspace (*args_spec))\n\t\t\t\t\targs_spec ++;\n\t\t\t}\n\n\t\t}\n\n\t\tfor (i = 2; i < global_argc; i++) {\n\t\t\tif ((prog_argc + 1) >= MAX_ARGC) {\n\t\t\t\tinfo(\"Exceeded multi-prog argc limit\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprog_argv[prog_argc++] = xstrdup(global_argv[i]);\n\t\t}\n\t\tprog_argv[prog_argc] = NULL;\n\n\t\t*argc = prog_argc;\n\t\t*argv = prog_argv;\n\t\t/* FIXME - local_data is leaked */\n\t\treturn 0;\n\t}\n\n\terror(\"Program for task rank %d not specified.\", task_rank);\nfail:\n\txfree(local_data);\n\t*argc = 1;\n\tprog_argv[0] = NULL;\n\t*argv = prog_argv;\n\treturn -1;\n}",
          "includes": [
            "#include \"multi_prog.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/log.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define MAX_ARGC 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"multi_prog.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdio.h>\n\n#define MAX_ARGC 128\n\nextern int multi_prog_get_argv(char *config_data, char **prog_env,\n\t\t\t       int task_rank, uint32_t *argc, char ***argv,\n\t\t\t       int global_argc, char **global_argv)\n{\n\tchar *line = NULL;\n\tint i, line_num = 0;\n\tint task_offset;\n\tchar *p = NULL, *s = NULL, *ptrptr = NULL;\n\tchar *rank_spec = NULL, *args_spec = NULL;\n\tint prog_argc = 0;\n\tchar **prog_argv = NULL;\n\tchar *local_data = NULL;\n\n\tprog_argv = (char **)xmalloc(sizeof(char *) * MAX_ARGC);\n\n\tif (task_rank < 0) {\n\t\terror(\"Invalid task rank %d\", task_rank);\n\t\t*argc = 1;\n\t\t*argv = prog_argv;\n\t\treturn -1;\n\t}\n\n\tlocal_data = xstrdup(config_data);\n\n\tline = strtok_r(local_data, \"\\n\", &ptrptr);\n\twhile (line) {\n\t\tif (line_num > 0)\n\t\t\tline = strtok_r(NULL, \"\\n\", &ptrptr);\n\t\tif (line == NULL) {\n\t\t\terror(\"No executable program specified for this task\");\n\t\t\tgoto fail;\n\t\t}\n\t\tline_num ++;\n\t\tif (strlen (line) >= (BUF_SIZE - 1)) {\n\t\t\terror (\"Line %d of configuration file too long\",\n\t\t\t\tline_num);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tp = line;\n\t\twhile (*p != '\\0' && isspace (*p)) /* remove leading spaces */\n\t\t\tp ++;\n\n\t\tif (*p == '#') /* only whole-line comments handled */\n\t\t\tcontinue;\n\n\t\tif (*p == '\\0') /* blank line ignored */\n\t\t\tcontinue;\n\n\t\trank_spec = p;\n\n\t\twhile (*p != '\\0' && !isspace (*p))\n\t\t\tp ++;\n\t\tif (*p == '\\0') {\n\t\t\terror(\"Invalid MPMD configuration line %d\", line_num);\n\t\t\tgoto fail;\n\t\t}\n\t\t*p ++ = '\\0';\n\n\t\tif (!_in_range (task_rank, rank_spec, &task_offset))\n\t\t\tcontinue;\n\n\t\t/* skip all whitspace after the range spec */\n\t\twhile(*p != '\\0' && isspace (*p))\n\t\t\tp++;\n\n\t\targs_spec = p;\n\t\twhile (*args_spec != '\\0') {\n\t\t\t/* Only simple quote and escape supported */\n\t\t\tprog_argv[prog_argc ++] = args_spec;\n\t\t\tif ((prog_argc + 1) >= MAX_ARGC) {\n\t\t\t\tinfo(\"Exceeded multi-prog argc limit\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\tCONT:\twhile (*args_spec != '\\0' && *args_spec != '\\\\'\n\t\t\t&&     *args_spec != '%'\n\t\t\t&&     *args_spec != '\\'' && !isspace (*args_spec)) {\n\t\t\t\targs_spec ++;\n\t\t\t}\n\t\t\tif (*args_spec == '\\0') {\n\t\t\t\t/* the last argument */\n\t\t\t\tbreak;\n\n\t\t\t} else if (*args_spec == '%') {\n\t\t\t\t_sub_expression(args_spec, task_rank,\n\t\t\t\t\ttask_offset);\n\t\t\t\targs_spec ++;\n\t\t\t\tgoto CONT;\n\n\t\t\t} else if (*args_spec == '\\\\') {\n\t\t\t\t/* escape, just remove the backslash */\n\t\t\t\ts = args_spec ++;\n\t\t\t\tp = args_spec;\n\t\t\t\tdo {\n\t\t\t\t\t*s ++ = *p;\n\t\t\t\t} while (*p ++ != '\\0');\n\t\t\t\tgoto CONT;\n\n\t\t\t} else if (*args_spec == '\\'') {\n\t\t\t\t/* single quote,\n\t\t\t\t * preserve all characters quoted. */\n\t\t\t\tp = args_spec + 1;\n\t\t\t\twhile (*p != '\\0' && *p != '\\'') {\n\t\t\t\t\t/* remove quote */\n\t\t\t\t\t*args_spec ++ = *p ++;\n\t\t\t\t}\n\t\t\t\tif (*p == '\\0') {\n\t\t\t\t\t/* closing quote not found */\n\t\t\t\t\terror(\"Program arguments specification\"\n\t\t\t\t\t\t\" format invalid: %s.\",\n\t\t\t\t\t\tprog_argv[prog_argc -1]);\n\t\t\t\t\tgoto fail;\n\t\t\t\t}\n\t\t\t\tp ++; /* skip closing quote */\n\t\t\t\ts = args_spec;\n\t\t\t\tdo {\n\t\t\t\t\t*s ++ = *p;\n\t\t\t\t} while (*p ++ != '\\0');\n\t\t\t\tgoto CONT;\n\n\t\t\t} else {\n\t\t\t\t/* space */\n\t\t\t\t*args_spec ++ = '\\0';\n\t\t\t\twhile (*args_spec != '\\0'\n\t\t\t\t&& isspace (*args_spec))\n\t\t\t\t\targs_spec ++;\n\t\t\t}\n\n\t\t}\n\n\t\tfor (i = 2; i < global_argc; i++) {\n\t\t\tif ((prog_argc + 1) >= MAX_ARGC) {\n\t\t\t\tinfo(\"Exceeded multi-prog argc limit\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tprog_argv[prog_argc++] = xstrdup(global_argv[i]);\n\t\t}\n\t\tprog_argv[prog_argc] = NULL;\n\n\t\t*argc = prog_argc;\n\t\t*argv = prog_argv;\n\t\t/* FIXME - local_data is leaked */\n\t\treturn 0;\n\t}\n\n\terror(\"Program for task rank %d not specified.\", task_rank);\nfail:\n\txfree(local_data);\n\t*argc = 1;\n\tprog_argv[0] = NULL;\n\t*argv = prog_argv;\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "switch_type"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "multi_prog_parse",
          "args": [
            "job",
            "gtid"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "multi_prog_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/multi_prog.c",
          "lines": "306-508",
          "snippet": "extern void multi_prog_parse(stepd_step_rec_t *job, uint32_t **gtid)\n{\n\tint i, j, line_num = 0, rank_id, total_ranks = 0;\n\tchar *line = NULL, *local_data = NULL;\n\tchar *end_ptr = NULL, *save_ptr = NULL, *tmp_str;\n\tchar *rank_spec = NULL, *cmd_spec = NULL, *args_spec = NULL;\n\tchar *p = NULL;\n\tchar **tmp_args, **tmp_cmd, *one_rank;\n\tuint32_t *ranks_node_id = NULL;\t/* Node ID for each rank */\n\tuint32_t *node_id2nid = NULL;\t/* Map Slurm node ID to Cray NID name */\n\thostlist_t hl;\n\n\ttmp_args = xmalloc(sizeof(char *) * job->ntasks);\n\ttmp_cmd = xmalloc(sizeof(char *) * job->ntasks);\n\tnode_id2nid = xmalloc(sizeof(uint32_t) * job->nnodes);\n\tranks_node_id = xmalloc(sizeof(uint32_t) * job->ntasks);\n\tlocal_data = xstrdup(job->argv[1]);\n\twhile (1) {\n\t\tif (line_num)\n\t\t\tline = strtok_r(NULL, \"\\n\", &save_ptr);\n\t\telse\n\t\t\tline = strtok_r(local_data, \"\\n\", &save_ptr);\n\t\tif (!line)\n\t\t\tbreak;\n\t\tline_num++;\n\n\t\tp = line;\n\t\twhile ((*p != '\\0') && isspace(*p)) /* remove leading spaces */\n\t\t\tp++;\n\t\tif (*p == '#')\t/* only whole-line comments handled */\n\t\t\tcontinue;\n\t\tif (*p == '\\0') /* blank line ignored */\n\t\t\tcontinue;\n\n\t\trank_spec = p;\t/* Rank specification for this line */\n\t\twhile ((*p != '\\0') && !isspace(*p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tgoto fail;\n\t\t*p++ = '\\0';\n\n\t\twhile ((*p != '\\0') && isspace(*p)) /* remove leading spaces */\n\t\t\tp++;\n\t\tif (*p == '\\0') /* blank line ignored */\n\t\t\tcontinue;\n\n\t\tcmd_spec = p;\t/* command only */\n\t\twhile ((*p != '\\0') && !isspace(*p))\n\t\t\tp++;\n\t\tif (isspace(*p))\n\t\t\t*p++ = '\\0';\n\n\t\twhile ((*p != '\\0') && isspace(*p)) /* remove leading spaces */\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\targs_spec = NULL;\t/* no arguments */\n\t\telse\n\t\t\targs_spec = p;\t\t/* arguments string */\n\n\t\ttmp_str = xmalloc(strlen(rank_spec) + 3);\n\t\tsprintf(tmp_str, \"[%s]\", rank_spec);\n\t\thl = hostlist_create(tmp_str);\n\t\txfree(tmp_str);\n\t\tif (!hl)\n\t\t\tgoto fail;\n\t\twhile ((one_rank = hostlist_pop(hl))) {\n\t\t\trank_id = strtol(one_rank, &end_ptr, 10);\n\t\t\tif ((end_ptr[0] != '\\0') || (rank_id < 0) ||\n\t\t\t    (rank_id >= job->ntasks)) {\n\t\t\t\tfree(one_rank);\n\t\t\t\thostlist_destroy(hl);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(one_rank);\n\t\t\tif (tmp_args[rank_id])\t/* duplicate record for rank */\n\t\t\t\txfree(tmp_args[rank_id]);\n\t\t\tif (tmp_cmd[rank_id])\t/* duplicate record for rank */\n\t\t\t\txfree(tmp_cmd[rank_id]);\n\t\t\telse\n\t\t\t\ttotal_ranks++;\n\t\t\ttmp_args[rank_id] = xstrdup(args_spec);\n\t\t\ttmp_cmd[rank_id] = xstrdup(cmd_spec);\n\t\t}\n\t\thostlist_destroy(hl);\n\t}\n\tif (total_ranks != job->ntasks)\n\t\tgoto fail;\n\n\tif (job->msg->complete_nodelist &&\n\t    ((hl = hostlist_create(job->msg->complete_nodelist)))) {\n\t\ti = 0;\n\t\twhile ((one_rank = hostlist_shift(hl))) {\n\t\t\tif (i >= job->nnodes) {\n\t\t\t\terror(\"MPMD more nodes in nodelist than count \"\n\t\t\t\t      \"(cnt:%u nodelist:%s)\", job->nnodes,\n\t\t\t\t      job->msg->complete_nodelist);\n\t\t\t}\n\t\t\tfor (j = 0; one_rank[j] && !isdigit(one_rank[j]); j++)\n\t\t\t\t;\n\t\t\tnode_id2nid[i++] = strtol(one_rank + j, &end_ptr, 10);\n\t\t\tfree(one_rank);\n\t\t}\n\t\thostlist_destroy(hl);\n\t}\n\n\tfor (i = 0; i < job->nnodes; i++) {\n\t\tif (!job->task_cnts) {\n\t\t\terror(\"MPMD job->task_cnts is NULL\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!job->task_cnts[i]) {\n\t\t\terror(\"MPMD job->task_cnts[%d] is NULL\", i);\n\t\t\tbreak;\n\t\t}\n\t\tif (!gtid) {\n\t\t\terror(\"MPMD gtid is NULL\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!gtid[i]) {\n\t\t\terror(\"MPMD gtid[%d] is NULL\", i);\n\t\t\tbreak;\n\t\t}\n\t\tfor (j = 0; j < job->task_cnts[i]; j++) {\n\t\t\tif (gtid[i][j] >= job->ntasks) {\n\t\t\t\terror(\"MPMD gtid[%d][%d] is invalid (%u >= %u)\",\n\t\t\t\t      i, j, gtid[i][j], job->ntasks);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tranks_node_id[gtid[i][j]] = i;\n\t\t}\n\t}\n\n\tjob->mpmd_set = xmalloc(sizeof(mpmd_set_t));\n\tjob->mpmd_set->apid      = SLURM_ID_HASH(job->jobid, job->stepid);\n\tjob->mpmd_set->args      = xmalloc(sizeof(char *) * job->ntasks);\n\tjob->mpmd_set->command   = xmalloc(sizeof(char *) * job->ntasks);\n\tjob->mpmd_set->first_pe  = xmalloc(sizeof(int) * job->ntasks);\n\tjob->mpmd_set->start_pe  = xmalloc(sizeof(int) * job->ntasks);\n\tjob->mpmd_set->total_pe  = xmalloc(sizeof(int) * job->ntasks);\n\tjob->mpmd_set->placement = xmalloc(sizeof(int) * job->ntasks);\n\tfor (i = 0, j = 0; i < job->ntasks; i++) {\n\t\tjob->mpmd_set->placement[i] = node_id2nid[ranks_node_id[i]];\n\t\tif (i == 0) {\n\t\t\tjob->mpmd_set->num_cmds++;\n\t\t\tif (ranks_node_id[i] == job->nodeid)\n\t\t\t\tjob->mpmd_set->first_pe[j] = i;\n\t\t\telse\n\t\t\t\tjob->mpmd_set->first_pe[j] = -1;\n\t\t\tjob->mpmd_set->args[j] = xstrdup(tmp_args[i]);\n\t\t\tjob->mpmd_set->command[j] = xstrdup(tmp_cmd[i]);\n\t\t\tjob->mpmd_set->start_pe[j] = i;\n\t\t\tjob->mpmd_set->total_pe[j]++;\n\t\t} else if (!xstrcmp(tmp_cmd[i-1],  tmp_cmd[i]) &&\n\t\t\t   !xstrcmp(tmp_args[i-1], tmp_args[i]) &&\n\t\t\t   !xstrchr(tmp_args[i-1], '%')) {\n\t\t\tif ((ranks_node_id[i] == job->nodeid) &&\n\t\t\t    (job->mpmd_set->first_pe[j] == -1))\n\t\t\t\tjob->mpmd_set->first_pe[j] = i;\n\t\t\tjob->mpmd_set->total_pe[j]++;\n\t\t} else {\n\t\t\tj++;\n\t\t\tif (ranks_node_id[i] == job->nodeid)\n\t\t\t\tjob->mpmd_set->first_pe[j] = i;\n\t\t\telse\n\t\t\t\tjob->mpmd_set->first_pe[j] = -1;\n\t\t\tjob->mpmd_set->num_cmds++;\n\t\t\tjob->mpmd_set->args[j] = xstrdup(tmp_args[i]);\n\t\t\tjob->mpmd_set->command[j] = xstrdup(tmp_cmd[i]);\n\t\t\tjob->mpmd_set->start_pe[j] = i;\n\t\t\tjob->mpmd_set->total_pe[j]++;\n\t\t}\n\t}\n#if _DEBUG\n\tinfo(\"MPMD Apid:%\"PRIu64\"\", job->mpmd_set->apid);\n\tinfo(\"MPMD NumPEs:%u\", job->ntasks);\t\t/* Total rank count */\n\tinfo(\"MPMD NumPEsHere:%u\", job->node_tasks);\t/* Node's rank count */\n\tinfo(\"MPMD NumCmds:%d\", job->mpmd_set->num_cmds);\n\tfor (i = 0; i < job->mpmd_set->num_cmds; i++) {\n\t\tinfo(\"MPMD Cmd:%s Args:%s FirstPE:%d StartPE:%d TotalPEs:%d \",\n\t\t     job->mpmd_set->command[i],  job->mpmd_set->args[i],\n\t\t     job->mpmd_set->first_pe[i], job->mpmd_set->start_pe[i],\n\t\t     job->mpmd_set->total_pe[i]);\n\t}\n\tfor (i = 0; i < job->ntasks; i++) {\n\t\tinfo(\"MPMD Placement[%d]:nid%5.5d\",\n\t\t     i, job->mpmd_set->placement[i]);\n\t}\n#endif\n\nfini:\tfor (i = 0; i < job->ntasks; i++) {\n\t\txfree(tmp_args[i]);\n\t\txfree(tmp_cmd[i]);\n\t}\n\txfree(tmp_args);\n\txfree(tmp_cmd);\n\txfree(local_data);\n\txfree(node_id2nid);\n\txfree(ranks_node_id);\n\treturn;\n\nfail:\terror(\"Invalid MPMD configuration line %d\", line_num);\n\tgoto fini;\n}",
          "includes": [
            "#include \"multi_prog.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/log.h\"",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <ctype.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [
            "#define _DEBUG   0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"multi_prog.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <stdio.h>\n\n#define _DEBUG   0\n\nextern void multi_prog_parse(stepd_step_rec_t *job, uint32_t **gtid)\n{\n\tint i, j, line_num = 0, rank_id, total_ranks = 0;\n\tchar *line = NULL, *local_data = NULL;\n\tchar *end_ptr = NULL, *save_ptr = NULL, *tmp_str;\n\tchar *rank_spec = NULL, *cmd_spec = NULL, *args_spec = NULL;\n\tchar *p = NULL;\n\tchar **tmp_args, **tmp_cmd, *one_rank;\n\tuint32_t *ranks_node_id = NULL;\t/* Node ID for each rank */\n\tuint32_t *node_id2nid = NULL;\t/* Map Slurm node ID to Cray NID name */\n\thostlist_t hl;\n\n\ttmp_args = xmalloc(sizeof(char *) * job->ntasks);\n\ttmp_cmd = xmalloc(sizeof(char *) * job->ntasks);\n\tnode_id2nid = xmalloc(sizeof(uint32_t) * job->nnodes);\n\tranks_node_id = xmalloc(sizeof(uint32_t) * job->ntasks);\n\tlocal_data = xstrdup(job->argv[1]);\n\twhile (1) {\n\t\tif (line_num)\n\t\t\tline = strtok_r(NULL, \"\\n\", &save_ptr);\n\t\telse\n\t\t\tline = strtok_r(local_data, \"\\n\", &save_ptr);\n\t\tif (!line)\n\t\t\tbreak;\n\t\tline_num++;\n\n\t\tp = line;\n\t\twhile ((*p != '\\0') && isspace(*p)) /* remove leading spaces */\n\t\t\tp++;\n\t\tif (*p == '#')\t/* only whole-line comments handled */\n\t\t\tcontinue;\n\t\tif (*p == '\\0') /* blank line ignored */\n\t\t\tcontinue;\n\n\t\trank_spec = p;\t/* Rank specification for this line */\n\t\twhile ((*p != '\\0') && !isspace(*p))\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\tgoto fail;\n\t\t*p++ = '\\0';\n\n\t\twhile ((*p != '\\0') && isspace(*p)) /* remove leading spaces */\n\t\t\tp++;\n\t\tif (*p == '\\0') /* blank line ignored */\n\t\t\tcontinue;\n\n\t\tcmd_spec = p;\t/* command only */\n\t\twhile ((*p != '\\0') && !isspace(*p))\n\t\t\tp++;\n\t\tif (isspace(*p))\n\t\t\t*p++ = '\\0';\n\n\t\twhile ((*p != '\\0') && isspace(*p)) /* remove leading spaces */\n\t\t\tp++;\n\t\tif (*p == '\\0')\n\t\t\targs_spec = NULL;\t/* no arguments */\n\t\telse\n\t\t\targs_spec = p;\t\t/* arguments string */\n\n\t\ttmp_str = xmalloc(strlen(rank_spec) + 3);\n\t\tsprintf(tmp_str, \"[%s]\", rank_spec);\n\t\thl = hostlist_create(tmp_str);\n\t\txfree(tmp_str);\n\t\tif (!hl)\n\t\t\tgoto fail;\n\t\twhile ((one_rank = hostlist_pop(hl))) {\n\t\t\trank_id = strtol(one_rank, &end_ptr, 10);\n\t\t\tif ((end_ptr[0] != '\\0') || (rank_id < 0) ||\n\t\t\t    (rank_id >= job->ntasks)) {\n\t\t\t\tfree(one_rank);\n\t\t\t\thostlist_destroy(hl);\n\t\t\t\tgoto fail;\n\t\t\t}\n\t\t\tfree(one_rank);\n\t\t\tif (tmp_args[rank_id])\t/* duplicate record for rank */\n\t\t\t\txfree(tmp_args[rank_id]);\n\t\t\tif (tmp_cmd[rank_id])\t/* duplicate record for rank */\n\t\t\t\txfree(tmp_cmd[rank_id]);\n\t\t\telse\n\t\t\t\ttotal_ranks++;\n\t\t\ttmp_args[rank_id] = xstrdup(args_spec);\n\t\t\ttmp_cmd[rank_id] = xstrdup(cmd_spec);\n\t\t}\n\t\thostlist_destroy(hl);\n\t}\n\tif (total_ranks != job->ntasks)\n\t\tgoto fail;\n\n\tif (job->msg->complete_nodelist &&\n\t    ((hl = hostlist_create(job->msg->complete_nodelist)))) {\n\t\ti = 0;\n\t\twhile ((one_rank = hostlist_shift(hl))) {\n\t\t\tif (i >= job->nnodes) {\n\t\t\t\terror(\"MPMD more nodes in nodelist than count \"\n\t\t\t\t      \"(cnt:%u nodelist:%s)\", job->nnodes,\n\t\t\t\t      job->msg->complete_nodelist);\n\t\t\t}\n\t\t\tfor (j = 0; one_rank[j] && !isdigit(one_rank[j]); j++)\n\t\t\t\t;\n\t\t\tnode_id2nid[i++] = strtol(one_rank + j, &end_ptr, 10);\n\t\t\tfree(one_rank);\n\t\t}\n\t\thostlist_destroy(hl);\n\t}\n\n\tfor (i = 0; i < job->nnodes; i++) {\n\t\tif (!job->task_cnts) {\n\t\t\terror(\"MPMD job->task_cnts is NULL\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!job->task_cnts[i]) {\n\t\t\terror(\"MPMD job->task_cnts[%d] is NULL\", i);\n\t\t\tbreak;\n\t\t}\n\t\tif (!gtid) {\n\t\t\terror(\"MPMD gtid is NULL\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!gtid[i]) {\n\t\t\terror(\"MPMD gtid[%d] is NULL\", i);\n\t\t\tbreak;\n\t\t}\n\t\tfor (j = 0; j < job->task_cnts[i]; j++) {\n\t\t\tif (gtid[i][j] >= job->ntasks) {\n\t\t\t\terror(\"MPMD gtid[%d][%d] is invalid (%u >= %u)\",\n\t\t\t\t      i, j, gtid[i][j], job->ntasks);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tranks_node_id[gtid[i][j]] = i;\n\t\t}\n\t}\n\n\tjob->mpmd_set = xmalloc(sizeof(mpmd_set_t));\n\tjob->mpmd_set->apid      = SLURM_ID_HASH(job->jobid, job->stepid);\n\tjob->mpmd_set->args      = xmalloc(sizeof(char *) * job->ntasks);\n\tjob->mpmd_set->command   = xmalloc(sizeof(char *) * job->ntasks);\n\tjob->mpmd_set->first_pe  = xmalloc(sizeof(int) * job->ntasks);\n\tjob->mpmd_set->start_pe  = xmalloc(sizeof(int) * job->ntasks);\n\tjob->mpmd_set->total_pe  = xmalloc(sizeof(int) * job->ntasks);\n\tjob->mpmd_set->placement = xmalloc(sizeof(int) * job->ntasks);\n\tfor (i = 0, j = 0; i < job->ntasks; i++) {\n\t\tjob->mpmd_set->placement[i] = node_id2nid[ranks_node_id[i]];\n\t\tif (i == 0) {\n\t\t\tjob->mpmd_set->num_cmds++;\n\t\t\tif (ranks_node_id[i] == job->nodeid)\n\t\t\t\tjob->mpmd_set->first_pe[j] = i;\n\t\t\telse\n\t\t\t\tjob->mpmd_set->first_pe[j] = -1;\n\t\t\tjob->mpmd_set->args[j] = xstrdup(tmp_args[i]);\n\t\t\tjob->mpmd_set->command[j] = xstrdup(tmp_cmd[i]);\n\t\t\tjob->mpmd_set->start_pe[j] = i;\n\t\t\tjob->mpmd_set->total_pe[j]++;\n\t\t} else if (!xstrcmp(tmp_cmd[i-1],  tmp_cmd[i]) &&\n\t\t\t   !xstrcmp(tmp_args[i-1], tmp_args[i]) &&\n\t\t\t   !xstrchr(tmp_args[i-1], '%')) {\n\t\t\tif ((ranks_node_id[i] == job->nodeid) &&\n\t\t\t    (job->mpmd_set->first_pe[j] == -1))\n\t\t\t\tjob->mpmd_set->first_pe[j] = i;\n\t\t\tjob->mpmd_set->total_pe[j]++;\n\t\t} else {\n\t\t\tj++;\n\t\t\tif (ranks_node_id[i] == job->nodeid)\n\t\t\t\tjob->mpmd_set->first_pe[j] = i;\n\t\t\telse\n\t\t\t\tjob->mpmd_set->first_pe[j] = -1;\n\t\t\tjob->mpmd_set->num_cmds++;\n\t\t\tjob->mpmd_set->args[j] = xstrdup(tmp_args[i]);\n\t\t\tjob->mpmd_set->command[j] = xstrdup(tmp_cmd[i]);\n\t\t\tjob->mpmd_set->start_pe[j] = i;\n\t\t\tjob->mpmd_set->total_pe[j]++;\n\t\t}\n\t}\n#if _DEBUG\n\tinfo(\"MPMD Apid:%\"PRIu64\"\", job->mpmd_set->apid);\n\tinfo(\"MPMD NumPEs:%u\", job->ntasks);\t\t/* Total rank count */\n\tinfo(\"MPMD NumPEsHere:%u\", job->node_tasks);\t/* Node's rank count */\n\tinfo(\"MPMD NumCmds:%d\", job->mpmd_set->num_cmds);\n\tfor (i = 0; i < job->mpmd_set->num_cmds; i++) {\n\t\tinfo(\"MPMD Cmd:%s Args:%s FirstPE:%d StartPE:%d TotalPEs:%d \",\n\t\t     job->mpmd_set->command[i],  job->mpmd_set->args[i],\n\t\t     job->mpmd_set->first_pe[i], job->mpmd_set->start_pe[i],\n\t\t     job->mpmd_set->total_pe[i]);\n\t}\n\tfor (i = 0; i < job->ntasks; i++) {\n\t\tinfo(\"MPMD Placement[%d]:nid%5.5d\",\n\t\t     i, job->mpmd_set->placement[i]);\n\t}\n#endif\n\nfini:\tfor (i = 0; i < job->ntasks; i++) {\n\t\txfree(tmp_args[i]);\n\t\txfree(tmp_cmd[i]);\n\t}\n\txfree(tmp_args);\n\txfree(tmp_cmd);\n\txfree(local_data);\n\txfree(node_id2nid);\n\txfree(ranks_node_id);\n\treturn;\n\nfail:\terror(\"Invalid MPMD configuration line %d\", line_num);\n\tgoto fini;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "switch_type",
            "\"switch/cray\""
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_get_switch_type",
          "args": [],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_info_create",
          "args": [
            "i",
            "gtid[node_id][i]",
            "in",
            "out",
            "err"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "task_info_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "647-683",
          "snippet": "extern stepd_step_task_info_t *\ntask_info_create(int taskid, int gtaskid,\n\t\t char *ifname, char *ofname, char *efname)\n{\n\tstepd_step_task_info_t *t = xmalloc(sizeof(stepd_step_task_info_t));\n\n\txassert(taskid >= 0);\n\txassert(gtaskid >= 0);\n\n\tslurm_mutex_init(&t->mutex);\n\tslurm_mutex_lock(&t->mutex);\n\tt->state       = STEPD_STEP_TASK_INIT;\n\tt->id          = taskid;\n\tt->gtid\t       = gtaskid;\n\tt->pid         = (pid_t) -1;\n\tt->ifname      = ifname;\n\tt->ofname      = ofname;\n\tt->efname      = efname;\n\tt->stdin_fd    = -1;\n\tt->to_stdin    = -1;\n\tt->stdout_fd   = -1;\n\tt->from_stdout = -1;\n\tt->stderr_fd   = -1;\n\tt->from_stderr = -1;\n\tt->in          = NULL;\n\tt->out         = NULL;\n\tt->err         = NULL;\n\tt->killed_by_cmd = false;\n\tt->aborted     = false;\n\tt->esent       = false;\n\tt->exited      = false;\n\tt->estatus     = -1;\n\tt->argc\t       = 0;\n\tt->argv\t       = NULL;\n\tslurm_mutex_unlock(&t->mutex);\n\treturn t;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);\n\nextern stepd_step_task_info_t *\ntask_info_create(int taskid, int gtaskid,\n\t\t char *ifname, char *ofname, char *efname)\n{\n\tstepd_step_task_info_t *t = xmalloc(sizeof(stepd_step_task_info_t));\n\n\txassert(taskid >= 0);\n\txassert(gtaskid >= 0);\n\n\tslurm_mutex_init(&t->mutex);\n\tslurm_mutex_lock(&t->mutex);\n\tt->state       = STEPD_STEP_TASK_INIT;\n\tt->id          = taskid;\n\tt->gtid\t       = gtaskid;\n\tt->pid         = (pid_t) -1;\n\tt->ifname      = ifname;\n\tt->ofname      = ofname;\n\tt->efname      = efname;\n\tt->stdin_fd    = -1;\n\tt->to_stdin    = -1;\n\tt->stdout_fd   = -1;\n\tt->from_stdout = -1;\n\tt->stderr_fd   = -1;\n\tt->from_stderr = -1;\n\tt->in          = NULL;\n\tt->out         = NULL;\n\tt->err         = NULL;\n\tt->killed_by_cmd = false;\n\tt->aborted     = false;\n\tt->esent       = false;\n\tt->exited      = false;\n\tt->estatus     = -1;\n\tt->argc\t       = 0;\n\tt->argv\t       = NULL;\n\tslurm_mutex_unlock(&t->mutex);\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_expand_stdio_filename",
          "args": [
            "efname",
            "gtid[node_id][i]",
            "job"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "_expand_stdio_filename",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "112-133",
          "snippet": "static char *\n_expand_stdio_filename(char *filename, int gtaskid, stepd_step_rec_t *job)\n{\n\tint id;\n\n\tif (filename == NULL)\n\t\treturn NULL;\n\n\tid = fname_single_task_io(filename);\n\n\tif (id < 0)\n\t\treturn fname_create(job, filename, gtaskid);\n\tif (id >= job->ntasks) {\n\t\terror(\"Task ID in filename is invalid\");\n\t\treturn NULL;\n\t}\n\n\tif (id == gtaskid)\n\t\treturn NULL;\n\telse\n\t\treturn xstrdup(\"/dev/null\");\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic char *\n_expand_stdio_filename(char *filename, int gtaskid, stepd_step_rec_t *job)\n{\n\tint id;\n\n\tif (filename == NULL)\n\t\treturn NULL;\n\n\tid = fname_single_task_io(filename);\n\n\tif (id < 0)\n\t\treturn fname_create(job, filename, gtaskid);\n\tif (id >= job->ntasks) {\n\t\terror(\"Task ID in filename is invalid\");\n\t\treturn NULL;\n\t}\n\n\tif (id == gtaskid)\n\t\treturn NULL;\n\telse\n\t\treturn xstrdup(\"/dev/null\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "job->node_tasks * sizeof(stepd_step_task_info_t *)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"User requested launch of zero tasks!\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);\nstatic void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);\n\nstatic void\n_job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t    char *ifname, char *ofname, char *efname)\n{\n\tint          i, node_id = job->nodeid;\n\tchar        *in, *out, *err;\n\n\tif (job->node_tasks == 0) {\n\t\terror(\"User requested launch of zero tasks!\");\n\t\tjob->task = NULL;\n\t\treturn;\n\t}\n\n#if defined(HAVE_NATIVE_CRAY)\n\tfor (i = 0; i < job->nnodes; i++) {\n\t\tint j;\n\t\tfor (j = 1; j < job->task_cnts[i]; j++) {\n\t\t\tif (gtid[i][j] != gtid[i][j-1] + 1) {\n\t\t\t\tjob->non_smp = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n#endif\n\n\tjob->task = (stepd_step_task_info_t **)\n\t\txmalloc(job->node_tasks * sizeof(stepd_step_task_info_t *));\n\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tin = _expand_stdio_filename(ifname, gtid[node_id][i], job);\n\t\tout = _expand_stdio_filename(ofname, gtid[node_id][i], job);\n\t\terr = _expand_stdio_filename(efname, gtid[node_id][i], job);\n\t\tjob->task[i] = task_info_create(i, gtid[node_id][i], in, out,\n\t\t\t\t\t\terr);\n\t\tif (!job->multi_prog) {\n\t\t\tjob->task[i]->argc = job->argc;\n\t\t\tjob->task[i]->argv = job->argv;\n\t\t}\n\t}\n\n\tif (job->multi_prog) {\n\t\tchar *switch_type = slurm_get_switch_type();\n\t\tif (!xstrcmp(switch_type, \"switch/cray\"))\n\t\t\tmulti_prog_parse(job, gtid);\n\t\txfree(switch_type);\n\t\tfor (i = 0; i < job->node_tasks; i++){\n\t\t\tmulti_prog_get_argv(job->argv[1], job->env,\n\t\t\t\t\t    gtid[node_id][i],\n\t\t\t\t\t    &job->task[i]->argc,\n\t\t\t\t\t    &job->task[i]->argv,\n\t\t\t\t\t    job->argc, job->argv);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "_expand_stdio_filename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "112-133",
    "snippet": "static char *\n_expand_stdio_filename(char *filename, int gtaskid, stepd_step_rec_t *job)\n{\n\tint id;\n\n\tif (filename == NULL)\n\t\treturn NULL;\n\n\tid = fname_single_task_io(filename);\n\n\tif (id < 0)\n\t\treturn fname_create(job, filename, gtaskid);\n\tif (id >= job->ntasks) {\n\t\terror(\"Task ID in filename is invalid\");\n\t\treturn NULL;\n\t}\n\n\tif (id == gtaskid)\n\t\treturn NULL;\n\telse\n\t\treturn xstrdup(\"/dev/null\");\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"/dev/null\""
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Task ID in filename is invalid\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fname_create",
          "args": [
            "job",
            "filename",
            "gtaskid"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "fname_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/fname.c",
          "lines": "76-115",
          "snippet": "char *\nfname_create(stepd_step_rec_t *job, const char *format, int taskid)\n{\n\tchar *name = NULL;\n\tchar *orig = xstrdup(format);\n\tint id;\n\tchar *esc;\n\n\tif (((id = fname_single_task_io (format)) >= 0) && (taskid != id))\n\t\treturn (xstrdup (\"/dev/null\"));\n\n\tesc = is_path_escaped(orig);\n\n\t/* If format doesn't specify an absolute pathname, use cwd\n\t */\n\tif (orig[0] != '/') {\n\t\txstrcat(name, job->cwd);\n\t\tif (esc) {\n\t\t\txstrcat(name, esc);\n\t\t\tgoto fini;\n\t\t}\n\t\tif (name[strlen(name)-1] != '/')\n\t\t\txstrcatchar(name, '/');\n\t}\n\n\tif (esc) {\n\t\t/* esc is malloc */\n\t\tname = esc;\n\t\tgoto fini;\n\t}\n\n\tif (job->batch)\n\t\tname = _create_batch_fname(name, orig, job, taskid);\n\telse\n\t\tname = _create_step_fname(name, orig, job, taskid);\n\nfini:\n\txfree(orig);\n\treturn name;\n}",
          "includes": [
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void _batch_path_check(char **p, char **q, char **name,\n\t\t\t      unsigned int wid, stepd_step_rec_t *job,\n\t\t\t      int taskid);",
            "static char * _create_batch_fname(char *name, char *path,\n\t\t\t\t  stepd_step_rec_t *job, int taskid);",
            "static char * _create_step_fname(char *name, char *path, stepd_step_rec_t *job,\n\t\t\t\t int taskid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/uid.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n\nstatic void _batch_path_check(char **p, char **q, char **name,\n\t\t\t      unsigned int wid, stepd_step_rec_t *job,\n\t\t\t      int taskid);\nstatic char * _create_batch_fname(char *name, char *path,\n\t\t\t\t  stepd_step_rec_t *job, int taskid);\nstatic char * _create_step_fname(char *name, char *path, stepd_step_rec_t *job,\n\t\t\t\t int taskid);\n\nchar *\nfname_create(stepd_step_rec_t *job, const char *format, int taskid)\n{\n\tchar *name = NULL;\n\tchar *orig = xstrdup(format);\n\tint id;\n\tchar *esc;\n\n\tif (((id = fname_single_task_io (format)) >= 0) && (taskid != id))\n\t\treturn (xstrdup (\"/dev/null\"));\n\n\tesc = is_path_escaped(orig);\n\n\t/* If format doesn't specify an absolute pathname, use cwd\n\t */\n\tif (orig[0] != '/') {\n\t\txstrcat(name, job->cwd);\n\t\tif (esc) {\n\t\t\txstrcat(name, esc);\n\t\t\tgoto fini;\n\t\t}\n\t\tif (name[strlen(name)-1] != '/')\n\t\t\txstrcatchar(name, '/');\n\t}\n\n\tif (esc) {\n\t\t/* esc is malloc */\n\t\tname = esc;\n\t\tgoto fini;\n\t}\n\n\tif (job->batch)\n\t\tname = _create_batch_fname(name, orig, job, taskid);\n\telse\n\t\tname = _create_step_fname(name, orig, job, taskid);\n\nfini:\n\txfree(orig);\n\treturn name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fname_single_task_io",
          "args": [
            "filename"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "fname_single_task_io",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/fname.c",
          "lines": "322-333",
          "snippet": "int fname_single_task_io (const char *fmt)\n{\n\tunsigned long taskid;\n\tchar *p;\n\n\ttaskid = strtoul (fmt, &p, 10);\n\n\tif (*p == '\\0')\n\t\treturn (int)taskid;\n\n\treturn -1;\n}",
          "includes": [
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void _batch_path_check(char **p, char **q, char **name,\n\t\t\t      unsigned int wid, stepd_step_rec_t *job,\n\t\t\t      int taskid);",
            "static char * _create_batch_fname(char *name, char *path,\n\t\t\t\t  stepd_step_rec_t *job, int taskid);",
            "static char * _create_step_fname(char *name, char *path, stepd_step_rec_t *job,\n\t\t\t\t int taskid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/uid.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n\nstatic void _batch_path_check(char **p, char **q, char **name,\n\t\t\t      unsigned int wid, stepd_step_rec_t *job,\n\t\t\t      int taskid);\nstatic char * _create_batch_fname(char *name, char *path,\n\t\t\t\t  stepd_step_rec_t *job, int taskid);\nstatic char * _create_step_fname(char *name, char *path, stepd_step_rec_t *job,\n\t\t\t\t int taskid);\n\nint fname_single_task_io (const char *fmt)\n{\n\tunsigned long taskid;\n\tchar *p;\n\n\ttaskid = strtoul (fmt, &p, 10);\n\n\tif (*p == '\\0')\n\t\treturn (int)taskid;\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic char *\n_expand_stdio_filename(char *filename, int gtaskid, stepd_step_rec_t *job)\n{\n\tint id;\n\n\tif (filename == NULL)\n\t\treturn NULL;\n\n\tid = fname_single_task_io(filename);\n\n\tif (id < 0)\n\t\treturn fname_create(job, filename, gtaskid);\n\tif (id >= job->ntasks) {\n\t\terror(\"Task ID in filename is invalid\");\n\t\treturn NULL;\n\t}\n\n\tif (id == gtaskid)\n\t\treturn NULL;\n\telse\n\t\treturn xstrdup(\"/dev/null\");\n}"
  },
  {
    "function_name": "_batchfilename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
    "lines": "89-99",
    "snippet": "static char *\n_batchfilename(stepd_step_rec_t *job, const char *name)\n{\n\tif (name == NULL) {\n\t\tif (job->array_task_id == NO_VAL)\n\t\t\treturn fname_create(job, \"slurm-%J.out\", 0);\n\t\telse\n\t\t\treturn fname_create(job, \"slurm-%A_%a.out\", 0);\n\t} else\n\t\treturn fname_create(job, name, 0);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/uid.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/xassert.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include <sys/types.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include <grp.h>",
      "#  include <string.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fname_create",
          "args": [
            "job",
            "name",
            "0"
          ],
          "line": 98
        },
        "resolved": true,
        "details": {
          "function_name": "fname_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/fname.c",
          "lines": "76-115",
          "snippet": "char *\nfname_create(stepd_step_rec_t *job, const char *format, int taskid)\n{\n\tchar *name = NULL;\n\tchar *orig = xstrdup(format);\n\tint id;\n\tchar *esc;\n\n\tif (((id = fname_single_task_io (format)) >= 0) && (taskid != id))\n\t\treturn (xstrdup (\"/dev/null\"));\n\n\tesc = is_path_escaped(orig);\n\n\t/* If format doesn't specify an absolute pathname, use cwd\n\t */\n\tif (orig[0] != '/') {\n\t\txstrcat(name, job->cwd);\n\t\tif (esc) {\n\t\t\txstrcat(name, esc);\n\t\t\tgoto fini;\n\t\t}\n\t\tif (name[strlen(name)-1] != '/')\n\t\t\txstrcatchar(name, '/');\n\t}\n\n\tif (esc) {\n\t\t/* esc is malloc */\n\t\tname = esc;\n\t\tgoto fini;\n\t}\n\n\tif (job->batch)\n\t\tname = _create_batch_fname(name, orig, job, taskid);\n\telse\n\t\tname = _create_step_fname(name, orig, job, taskid);\n\nfini:\n\txfree(orig);\n\treturn name;\n}",
          "includes": [
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void _batch_path_check(char **p, char **q, char **name,\n\t\t\t      unsigned int wid, stepd_step_rec_t *job,\n\t\t\t      int taskid);",
            "static char * _create_batch_fname(char *name, char *path,\n\t\t\t\t  stepd_step_rec_t *job, int taskid);",
            "static char * _create_step_fname(char *name, char *path, stepd_step_rec_t *job,\n\t\t\t\t int taskid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/uid.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <ctype.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <stdio.h>\n\nstatic void _batch_path_check(char **p, char **q, char **name,\n\t\t\t      unsigned int wid, stepd_step_rec_t *job,\n\t\t\t      int taskid);\nstatic char * _create_batch_fname(char *name, char *path,\n\t\t\t\t  stepd_step_rec_t *job, int taskid);\nstatic char * _create_step_fname(char *name, char *path, stepd_step_rec_t *job,\n\t\t\t\t int taskid);\n\nchar *\nfname_create(stepd_step_rec_t *job, const char *format, int taskid)\n{\n\tchar *name = NULL;\n\tchar *orig = xstrdup(format);\n\tint id;\n\tchar *esc;\n\n\tif (((id = fname_single_task_io (format)) >= 0) && (taskid != id))\n\t\treturn (xstrdup (\"/dev/null\"));\n\n\tesc = is_path_escaped(orig);\n\n\t/* If format doesn't specify an absolute pathname, use cwd\n\t */\n\tif (orig[0] != '/') {\n\t\txstrcat(name, job->cwd);\n\t\tif (esc) {\n\t\t\txstrcat(name, esc);\n\t\t\tgoto fini;\n\t\t}\n\t\tif (name[strlen(name)-1] != '/')\n\t\t\txstrcatchar(name, '/');\n\t}\n\n\tif (esc) {\n\t\t/* esc is malloc */\n\t\tname = esc;\n\t\tgoto fini;\n\t}\n\n\tif (job->batch)\n\t\tname = _create_batch_fname(name, orig, job, taskid);\n\telse\n\t\tname = _create_step_fname(name, orig, job, taskid);\n\nfini:\n\txfree(orig);\n\treturn name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic char *\n_batchfilename(stepd_step_rec_t *job, const char *name)\n{\n\tif (name == NULL) {\n\t\tif (job->array_task_id == NO_VAL)\n\t\t\treturn fname_create(job, \"slurm-%J.out\", 0);\n\t\telse\n\t\t\treturn fname_create(job, \"slurm-%A_%a.out\", 0);\n\t} else\n\t\treturn fname_create(job, name, 0);\n}"
  }
]