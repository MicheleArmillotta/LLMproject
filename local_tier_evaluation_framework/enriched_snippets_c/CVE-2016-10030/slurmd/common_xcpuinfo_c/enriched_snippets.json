[
  {
    "function_name": "_ranges_conv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "1266-1311",
    "snippet": "static int\n_ranges_conv(char* lrange,char** prange,int mode)\n{\n\tint fstatus;\n\tint i;\n\tuint16_t *amap;\n\tuint16_t *map;\n\tuint16_t *map_out;\n\n\t/* init internal data if not already done */\n\tif ( xcpuinfo_init() != XCPUINFO_SUCCESS )\n\t\treturn XCPUINFO_ERROR;\n\n\tif ( mode ) {\n\t\t/* machine to abstract conversion */\n\t\tamap = block_map_inv;\n\t}\n\telse {\n\t\t/* abstract to machine conversion */\n\t\tamap = block_map;\n\t}\n\n\t/* allocate map for local work */\n\tmap = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\tmap_out = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\n\t/* extract the input map */\n\tfstatus = _range_to_map(lrange,map,block_map_size,!mode);\n\tif ( fstatus ) {\n\t\tgoto exit;\n\t}\n\n\t/* do the conversion (see src/slurmd/slurmd/get_mach_stat.c) */\n\tfor( i = 0 ; i < block_map_size ; i++) {\n\t\tif ( map[i] )\n\t\t\tmap_out[amap[i]]=1;\n\t}\n\n\t/* build the ouput range */\n\tfstatus = _map_to_range(map_out,block_map_size,prange);\n\nexit:\n\txfree(map);\n\txfree(map_out);\n\treturn fstatus;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _ranges_conv(char* lrange, char** prange, int mode);",
      "static int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);",
      "uint16_t block_map_size;",
      "uint16_t *block_map, *block_map_inv;",
      "int _ranges_conv(char* lrange,char** prange,int mode);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "map_out"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_map_to_range",
          "args": [
            "map_out",
            "block_map_size",
            "prange"
          ],
          "line": 1305
        },
        "resolved": true,
        "details": {
          "function_name": "_map_to_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "1198-1259",
          "snippet": "static int\n_map_to_range(uint16_t *map,uint16_t map_size,char** prange)\n{\n\tsize_t len;\n\tint num_fl=0;\n\tint con_fl=0;\n\n\tchar id[12];\n\tchar *str;\n\n\tuint16_t start=0,end=0,i;\n\n\tstr = xstrdup(\"\");\n\tfor ( i = 0 ; i < map_size ; i++ ) {\n\n\t\tif ( map[i] ) {\n\t\t\tnum_fl=1;\n\t\t\tend=i;\n\t\t\tif ( !con_fl ) {\n\t\t\t\tstart=end;\n\t\t\t\tcon_fl=1;\n\t\t\t}\n\t\t}\n\t\telse if ( num_fl ) {\n\t\t\tif ( start < end ) {\n\t\t\t\tsprintf(id,\"%u-%u,\",start,end);\n\t\t\t\txstrcat(str,id);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf(id,\"%u,\",start);\n\t\t\t\txstrcat(str,id);\n\t\t\t}\n\t\t\tcon_fl = num_fl = 0;\n\t\t}\n\t}\n\tif ( num_fl ) {\n\t\tif ( start < end ) {\n\t\t\tsprintf(id,\"%u-%u,\",start,end);\n\t\t\txstrcat(str,id);\n\t\t}\n\t\telse {\n\t\t\tsprintf(id,\"%u,\",start);\n\t\t\txstrcat(str,id);\n\t\t}\n\t}\n\n\tlen = strlen(str);\n\tif ( len > 0 ) {\n\t\tstr[len-1]='\\0';\n\t}\n\telse {\n\t\txfree(str);\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\tif ( prange != NULL )\n\t\t*prange = str;\n\telse\n\t\txfree(str);\n\n\treturn XCPUINFO_SUCCESS;\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);\n\nstatic int\n_map_to_range(uint16_t *map,uint16_t map_size,char** prange)\n{\n\tsize_t len;\n\tint num_fl=0;\n\tint con_fl=0;\n\n\tchar id[12];\n\tchar *str;\n\n\tuint16_t start=0,end=0,i;\n\n\tstr = xstrdup(\"\");\n\tfor ( i = 0 ; i < map_size ; i++ ) {\n\n\t\tif ( map[i] ) {\n\t\t\tnum_fl=1;\n\t\t\tend=i;\n\t\t\tif ( !con_fl ) {\n\t\t\t\tstart=end;\n\t\t\t\tcon_fl=1;\n\t\t\t}\n\t\t}\n\t\telse if ( num_fl ) {\n\t\t\tif ( start < end ) {\n\t\t\t\tsprintf(id,\"%u-%u,\",start,end);\n\t\t\t\txstrcat(str,id);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf(id,\"%u,\",start);\n\t\t\t\txstrcat(str,id);\n\t\t\t}\n\t\t\tcon_fl = num_fl = 0;\n\t\t}\n\t}\n\tif ( num_fl ) {\n\t\tif ( start < end ) {\n\t\t\tsprintf(id,\"%u-%u,\",start,end);\n\t\t\txstrcat(str,id);\n\t\t}\n\t\telse {\n\t\t\tsprintf(id,\"%u,\",start);\n\t\t\txstrcat(str,id);\n\t\t}\n\t}\n\n\tlen = strlen(str);\n\tif ( len > 0 ) {\n\t\tstr[len-1]='\\0';\n\t}\n\telse {\n\t\txfree(str);\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\tif ( prange != NULL )\n\t\t*prange = str;\n\telse\n\t\txfree(str);\n\n\treturn XCPUINFO_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_range_to_map",
          "args": [
            "lrange",
            "map",
            "block_map_size",
            "!mode"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "_range_to_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "1120-1191",
          "snippet": "static int\n_range_to_map(char* range,uint16_t *map,uint16_t map_size,int add_threads)\n{\n\tint bad_nb=0;\n\tint num_fl=0;\n\tint con_fl=0;\n\tint last=0;\n\n\tchar *dup;\n\tchar *p;\n\tchar *s=NULL;\n\n\tuint16_t start=0,end=0,i;\n\n\t/* duplicate input range */\n\tdup = xstrdup(range);\n\tp = dup;\n\twhile ( ! last ) {\n\t\tif ( isdigit(*p) ) {\n\t\t\tif ( !num_fl ) {\n\t\t\t\tnum_fl++;\n\t\t\t\ts=p;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == '-' ) {\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tstart = (uint16_t) atoi(s);\n\t\t\t\tcon_fl=1;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == ',' || *p == '\\0') {\n\t\t\tif ( *p == '\\0' )\n\t\t\t\tlast = 1;\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tend = (uint16_t) atoi(s);\n\t\t\t\tif ( !con_fl )\n\t\t\t\t\tstart = end ;\n\t\t\t\tcon_fl=2;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbad_nb++;\n\t\t\tbreak;\n\t\t}\n\t\tif ( con_fl == 2 ) {\n\t\t\tif ( add_threads ) {\n\t\t\t\tstart = start * threads;\n\t\t\t\tend = (end+1)*threads - 1 ;\n\t\t\t}\n\t\t\tfor( i = start ; i <= end && i < map_size ; i++) {\n\t\t\t\tmap[i]=1;\n\t\t\t}\n\t\t\tcon_fl=0;\n\t\t}\n\t\tp++;\n\t}\n\n\txfree(dup);\n\n\tif ( bad_nb > 0 ) {\n\t\t/* bad format for input range */\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\treturn XCPUINFO_SUCCESS;\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _range_to_map(char* range, uint16_t *map, uint16_t map_size,\n\t\t\t int add_threads);",
            "uint16_t procs, boards, sockets, cores, threads=1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _range_to_map(char* range, uint16_t *map, uint16_t map_size,\n\t\t\t int add_threads);\nuint16_t procs, boards, sockets, cores, threads=1;\n\nstatic int\n_range_to_map(char* range,uint16_t *map,uint16_t map_size,int add_threads)\n{\n\tint bad_nb=0;\n\tint num_fl=0;\n\tint con_fl=0;\n\tint last=0;\n\n\tchar *dup;\n\tchar *p;\n\tchar *s=NULL;\n\n\tuint16_t start=0,end=0,i;\n\n\t/* duplicate input range */\n\tdup = xstrdup(range);\n\tp = dup;\n\twhile ( ! last ) {\n\t\tif ( isdigit(*p) ) {\n\t\t\tif ( !num_fl ) {\n\t\t\t\tnum_fl++;\n\t\t\t\ts=p;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == '-' ) {\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tstart = (uint16_t) atoi(s);\n\t\t\t\tcon_fl=1;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == ',' || *p == '\\0') {\n\t\t\tif ( *p == '\\0' )\n\t\t\t\tlast = 1;\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tend = (uint16_t) atoi(s);\n\t\t\t\tif ( !con_fl )\n\t\t\t\t\tstart = end ;\n\t\t\t\tcon_fl=2;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbad_nb++;\n\t\t\tbreak;\n\t\t}\n\t\tif ( con_fl == 2 ) {\n\t\t\tif ( add_threads ) {\n\t\t\t\tstart = start * threads;\n\t\t\t\tend = (end+1)*threads - 1 ;\n\t\t\t}\n\t\t\tfor( i = start ; i <= end && i < map_size ; i++) {\n\t\t\t\tmap[i]=1;\n\t\t\t}\n\t\t\tcon_fl=0;\n\t\t}\n\t\tp++;\n\t}\n\n\txfree(dup);\n\n\tif ( bad_nb > 0 ) {\n\t\t/* bad format for input range */\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\treturn XCPUINFO_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "block_map_size*sizeof(uint16_t)"
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "block_map_size*sizeof(uint16_t)"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xcpuinfo_init",
          "args": [],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "xcpuinfo_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "957-970",
          "snippet": "int\nxcpuinfo_init(void)\n{\n\tif ( initialized )\n\t\treturn XCPUINFO_SUCCESS;\n\n\tif ( get_cpuinfo(&procs,&boards,&sockets,&cores,&threads,\n\t\t\t &block_map_size,&block_map,&block_map_inv) )\n\t\treturn XCPUINFO_ERROR;\n\n\tinitialized = true ;\n\n\treturn XCPUINFO_SUCCESS;\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "bool     initialized = false;",
            "uint16_t procs, boards, sockets, cores, threads=1;",
            "uint16_t block_map_size;",
            "uint16_t *block_map, *block_map_inv;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nbool     initialized = false;\nuint16_t procs, boards, sockets, cores, threads=1;\nuint16_t block_map_size;\nuint16_t *block_map, *block_map_inv;\n\nint\nxcpuinfo_init(void)\n{\n\tif ( initialized )\n\t\treturn XCPUINFO_SUCCESS;\n\n\tif ( get_cpuinfo(&procs,&boards,&sockets,&cores,&threads,\n\t\t\t &block_map_size,&block_map,&block_map_inv) )\n\t\treturn XCPUINFO_ERROR;\n\n\tinitialized = true ;\n\n\treturn XCPUINFO_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _ranges_conv(char* lrange, char** prange, int mode);\nstatic int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);\nuint16_t block_map_size;\nuint16_t *block_map, *block_map_inv;\nint _ranges_conv(char* lrange,char** prange,int mode);\n\nstatic int\n_ranges_conv(char* lrange,char** prange,int mode)\n{\n\tint fstatus;\n\tint i;\n\tuint16_t *amap;\n\tuint16_t *map;\n\tuint16_t *map_out;\n\n\t/* init internal data if not already done */\n\tif ( xcpuinfo_init() != XCPUINFO_SUCCESS )\n\t\treturn XCPUINFO_ERROR;\n\n\tif ( mode ) {\n\t\t/* machine to abstract conversion */\n\t\tamap = block_map_inv;\n\t}\n\telse {\n\t\t/* abstract to machine conversion */\n\t\tamap = block_map;\n\t}\n\n\t/* allocate map for local work */\n\tmap = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\tmap_out = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\n\t/* extract the input map */\n\tfstatus = _range_to_map(lrange,map,block_map_size,!mode);\n\tif ( fstatus ) {\n\t\tgoto exit;\n\t}\n\n\t/* do the conversion (see src/slurmd/slurmd/get_mach_stat.c) */\n\tfor( i = 0 ; i < block_map_size ; i++) {\n\t\tif ( map[i] )\n\t\t\tmap_out[amap[i]]=1;\n\t}\n\n\t/* build the ouput range */\n\tfstatus = _map_to_range(map_out,block_map_size,prange);\n\nexit:\n\txfree(map);\n\txfree(map_out);\n\treturn fstatus;\n}"
  },
  {
    "function_name": "_map_to_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "1198-1259",
    "snippet": "static int\n_map_to_range(uint16_t *map,uint16_t map_size,char** prange)\n{\n\tsize_t len;\n\tint num_fl=0;\n\tint con_fl=0;\n\n\tchar id[12];\n\tchar *str;\n\n\tuint16_t start=0,end=0,i;\n\n\tstr = xstrdup(\"\");\n\tfor ( i = 0 ; i < map_size ; i++ ) {\n\n\t\tif ( map[i] ) {\n\t\t\tnum_fl=1;\n\t\t\tend=i;\n\t\t\tif ( !con_fl ) {\n\t\t\t\tstart=end;\n\t\t\t\tcon_fl=1;\n\t\t\t}\n\t\t}\n\t\telse if ( num_fl ) {\n\t\t\tif ( start < end ) {\n\t\t\t\tsprintf(id,\"%u-%u,\",start,end);\n\t\t\t\txstrcat(str,id);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf(id,\"%u,\",start);\n\t\t\t\txstrcat(str,id);\n\t\t\t}\n\t\t\tcon_fl = num_fl = 0;\n\t\t}\n\t}\n\tif ( num_fl ) {\n\t\tif ( start < end ) {\n\t\t\tsprintf(id,\"%u-%u,\",start,end);\n\t\t\txstrcat(str,id);\n\t\t}\n\t\telse {\n\t\t\tsprintf(id,\"%u,\",start);\n\t\t\txstrcat(str,id);\n\t\t}\n\t}\n\n\tlen = strlen(str);\n\tif ( len > 0 ) {\n\t\tstr[len-1]='\\0';\n\t}\n\telse {\n\t\txfree(str);\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\tif ( prange != NULL )\n\t\t*prange = str;\n\telse\n\t\txfree(str);\n\n\treturn XCPUINFO_SUCCESS;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "str"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcat",
          "args": [
            "str",
            "id"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "id",
            "\"%u,\"",
            "start"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcat",
          "args": [
            "str",
            "id"
          ],
          "line": 1236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "id",
            "\"%u-%u,\"",
            "start",
            "end"
          ],
          "line": 1235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcat",
          "args": [
            "str",
            "id"
          ],
          "line": 1228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "id",
            "\"%u,\"",
            "start"
          ],
          "line": 1227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcat",
          "args": [
            "str",
            "id"
          ],
          "line": 1224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "id",
            "\"%u-%u,\"",
            "start",
            "end"
          ],
          "line": 1223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "\"\""
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);\n\nstatic int\n_map_to_range(uint16_t *map,uint16_t map_size,char** prange)\n{\n\tsize_t len;\n\tint num_fl=0;\n\tint con_fl=0;\n\n\tchar id[12];\n\tchar *str;\n\n\tuint16_t start=0,end=0,i;\n\n\tstr = xstrdup(\"\");\n\tfor ( i = 0 ; i < map_size ; i++ ) {\n\n\t\tif ( map[i] ) {\n\t\t\tnum_fl=1;\n\t\t\tend=i;\n\t\t\tif ( !con_fl ) {\n\t\t\t\tstart=end;\n\t\t\t\tcon_fl=1;\n\t\t\t}\n\t\t}\n\t\telse if ( num_fl ) {\n\t\t\tif ( start < end ) {\n\t\t\t\tsprintf(id,\"%u-%u,\",start,end);\n\t\t\t\txstrcat(str,id);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf(id,\"%u,\",start);\n\t\t\t\txstrcat(str,id);\n\t\t\t}\n\t\t\tcon_fl = num_fl = 0;\n\t\t}\n\t}\n\tif ( num_fl ) {\n\t\tif ( start < end ) {\n\t\t\tsprintf(id,\"%u-%u,\",start,end);\n\t\t\txstrcat(str,id);\n\t\t}\n\t\telse {\n\t\t\tsprintf(id,\"%u,\",start);\n\t\t\txstrcat(str,id);\n\t\t}\n\t}\n\n\tlen = strlen(str);\n\tif ( len > 0 ) {\n\t\tstr[len-1]='\\0';\n\t}\n\telse {\n\t\txfree(str);\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\tif ( prange != NULL )\n\t\t*prange = str;\n\telse\n\t\txfree(str);\n\n\treturn XCPUINFO_SUCCESS;\n}"
  },
  {
    "function_name": "_range_to_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "1120-1191",
    "snippet": "static int\n_range_to_map(char* range,uint16_t *map,uint16_t map_size,int add_threads)\n{\n\tint bad_nb=0;\n\tint num_fl=0;\n\tint con_fl=0;\n\tint last=0;\n\n\tchar *dup;\n\tchar *p;\n\tchar *s=NULL;\n\n\tuint16_t start=0,end=0,i;\n\n\t/* duplicate input range */\n\tdup = xstrdup(range);\n\tp = dup;\n\twhile ( ! last ) {\n\t\tif ( isdigit(*p) ) {\n\t\t\tif ( !num_fl ) {\n\t\t\t\tnum_fl++;\n\t\t\t\ts=p;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == '-' ) {\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tstart = (uint16_t) atoi(s);\n\t\t\t\tcon_fl=1;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == ',' || *p == '\\0') {\n\t\t\tif ( *p == '\\0' )\n\t\t\t\tlast = 1;\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tend = (uint16_t) atoi(s);\n\t\t\t\tif ( !con_fl )\n\t\t\t\t\tstart = end ;\n\t\t\t\tcon_fl=2;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbad_nb++;\n\t\t\tbreak;\n\t\t}\n\t\tif ( con_fl == 2 ) {\n\t\t\tif ( add_threads ) {\n\t\t\t\tstart = start * threads;\n\t\t\t\tend = (end+1)*threads - 1 ;\n\t\t\t}\n\t\t\tfor( i = start ; i <= end && i < map_size ; i++) {\n\t\t\t\tmap[i]=1;\n\t\t\t}\n\t\t\tcon_fl=0;\n\t\t}\n\t\tp++;\n\t}\n\n\txfree(dup);\n\n\tif ( bad_nb > 0 ) {\n\t\t/* bad format for input range */\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\treturn XCPUINFO_SUCCESS;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _range_to_map(char* range, uint16_t *map, uint16_t map_size,\n\t\t\t int add_threads);",
      "uint16_t procs, boards, sockets, cores, threads=1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "dup"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 1158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "s"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "*p"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "range"
          ],
          "line": 1135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _range_to_map(char* range, uint16_t *map, uint16_t map_size,\n\t\t\t int add_threads);\nuint16_t procs, boards, sockets, cores, threads=1;\n\nstatic int\n_range_to_map(char* range,uint16_t *map,uint16_t map_size,int add_threads)\n{\n\tint bad_nb=0;\n\tint num_fl=0;\n\tint con_fl=0;\n\tint last=0;\n\n\tchar *dup;\n\tchar *p;\n\tchar *s=NULL;\n\n\tuint16_t start=0,end=0,i;\n\n\t/* duplicate input range */\n\tdup = xstrdup(range);\n\tp = dup;\n\twhile ( ! last ) {\n\t\tif ( isdigit(*p) ) {\n\t\t\tif ( !num_fl ) {\n\t\t\t\tnum_fl++;\n\t\t\t\ts=p;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == '-' ) {\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tstart = (uint16_t) atoi(s);\n\t\t\t\tcon_fl=1;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == ',' || *p == '\\0') {\n\t\t\tif ( *p == '\\0' )\n\t\t\t\tlast = 1;\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tend = (uint16_t) atoi(s);\n\t\t\t\tif ( !con_fl )\n\t\t\t\t\tstart = end ;\n\t\t\t\tcon_fl=2;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbad_nb++;\n\t\t\tbreak;\n\t\t}\n\t\tif ( con_fl == 2 ) {\n\t\t\tif ( add_threads ) {\n\t\t\t\tstart = start * threads;\n\t\t\t\tend = (end+1)*threads - 1 ;\n\t\t\t}\n\t\t\tfor( i = start ; i <= end && i < map_size ; i++) {\n\t\t\t\tmap[i]=1;\n\t\t\t}\n\t\t\tcon_fl=0;\n\t\t}\n\t\tp++;\n\t}\n\n\txfree(dup);\n\n\tif ( bad_nb > 0 ) {\n\t\t/* bad format for input range */\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\treturn XCPUINFO_SUCCESS;\n}"
  },
  {
    "function_name": "xcpuinfo_macmap_to_absmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "1093-1111",
    "snippet": "int\nxcpuinfo_macmap_to_absmap(uint16_t *amap,uint16_t amap_size,\n\t\t\t  uint16_t **bmap,uint16_t *bmap_size)\n{\n\tint i;\n\n\t/* machine to abstract conversion using inverted block map */\n\tuint16_t *cmap;\n\tcmap = block_map_inv;\n\t*bmap_size = amap_size;\n\t*bmap = (uint16_t*) xmalloc(amap_size*sizeof(uint16_t));\n\tfor( i = 0 ; i < amap_size ; i++) {\n\t\tif ( amap[i] )\n\t\t\t(*bmap)[cmap[i]]=1;\n\t\telse\n\t\t\t(*bmap)[cmap[i]]=0;\n\t}\n\treturn XCPUINFO_SUCCESS;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint16_t *block_map, *block_map_inv;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "amap_size*sizeof(uint16_t)"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nuint16_t *block_map, *block_map_inv;\n\nint\nxcpuinfo_macmap_to_absmap(uint16_t *amap,uint16_t amap_size,\n\t\t\t  uint16_t **bmap,uint16_t *bmap_size)\n{\n\tint i;\n\n\t/* machine to abstract conversion using inverted block map */\n\tuint16_t *cmap;\n\tcmap = block_map_inv;\n\t*bmap_size = amap_size;\n\t*bmap = (uint16_t*) xmalloc(amap_size*sizeof(uint16_t));\n\tfor( i = 0 ; i < amap_size ; i++) {\n\t\tif ( amap[i] )\n\t\t\t(*bmap)[cmap[i]]=1;\n\t\telse\n\t\t\t(*bmap)[cmap[i]]=0;\n\t}\n\treturn XCPUINFO_SUCCESS;\n}"
  },
  {
    "function_name": "xcpuinfo_absmap_to_macmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "1077-1091",
    "snippet": "int\nxcpuinfo_absmap_to_macmap(uint16_t *amap,uint16_t amap_size,\n\t\t\t  uint16_t **bmap,uint16_t *bmap_size)\n{\n\t/* int i; */\n\n\t/* abstract to machine conversion using block map */\n\tuint16_t *map_out;\n\n\t*bmap_size = amap_size;\n\tmap_out = (uint16_t*) xmalloc(amap_size*sizeof(uint16_t));\n\t*bmap = map_out;\n\n\treturn XCPUINFO_SUCCESS;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "amap_size*sizeof(uint16_t)"
          ],
          "line": 1087
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nint\nxcpuinfo_absmap_to_macmap(uint16_t *amap,uint16_t amap_size,\n\t\t\t  uint16_t **bmap,uint16_t *bmap_size)\n{\n\t/* int i; */\n\n\t/* abstract to machine conversion using block map */\n\tuint16_t *map_out;\n\n\t*bmap_size = amap_size;\n\tmap_out = (uint16_t*) xmalloc(amap_size*sizeof(uint16_t));\n\t*bmap = map_out;\n\n\treturn XCPUINFO_SUCCESS;\n}"
  },
  {
    "function_name": "xcpuinfo_mac_to_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "1068-1075",
    "snippet": "int\nxcpuinfo_mac_to_map(char* lrange,uint16_t **map,uint16_t *map_size)\n{\n\t*map_size = block_map_size;\n\t*map = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\t/* machine range already includes the hyperthreads */\n\treturn _range_to_map(lrange,*map,*map_size,0);\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint16_t block_map_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_range_to_map",
          "args": [
            "lrange",
            "*map",
            "*map_size",
            "0"
          ],
          "line": 1074
        },
        "resolved": true,
        "details": {
          "function_name": "_range_to_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "1120-1191",
          "snippet": "static int\n_range_to_map(char* range,uint16_t *map,uint16_t map_size,int add_threads)\n{\n\tint bad_nb=0;\n\tint num_fl=0;\n\tint con_fl=0;\n\tint last=0;\n\n\tchar *dup;\n\tchar *p;\n\tchar *s=NULL;\n\n\tuint16_t start=0,end=0,i;\n\n\t/* duplicate input range */\n\tdup = xstrdup(range);\n\tp = dup;\n\twhile ( ! last ) {\n\t\tif ( isdigit(*p) ) {\n\t\t\tif ( !num_fl ) {\n\t\t\t\tnum_fl++;\n\t\t\t\ts=p;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == '-' ) {\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tstart = (uint16_t) atoi(s);\n\t\t\t\tcon_fl=1;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == ',' || *p == '\\0') {\n\t\t\tif ( *p == '\\0' )\n\t\t\t\tlast = 1;\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tend = (uint16_t) atoi(s);\n\t\t\t\tif ( !con_fl )\n\t\t\t\t\tstart = end ;\n\t\t\t\tcon_fl=2;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbad_nb++;\n\t\t\tbreak;\n\t\t}\n\t\tif ( con_fl == 2 ) {\n\t\t\tif ( add_threads ) {\n\t\t\t\tstart = start * threads;\n\t\t\t\tend = (end+1)*threads - 1 ;\n\t\t\t}\n\t\t\tfor( i = start ; i <= end && i < map_size ; i++) {\n\t\t\t\tmap[i]=1;\n\t\t\t}\n\t\t\tcon_fl=0;\n\t\t}\n\t\tp++;\n\t}\n\n\txfree(dup);\n\n\tif ( bad_nb > 0 ) {\n\t\t/* bad format for input range */\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\treturn XCPUINFO_SUCCESS;\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _range_to_map(char* range, uint16_t *map, uint16_t map_size,\n\t\t\t int add_threads);",
            "uint16_t procs, boards, sockets, cores, threads=1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _range_to_map(char* range, uint16_t *map, uint16_t map_size,\n\t\t\t int add_threads);\nuint16_t procs, boards, sockets, cores, threads=1;\n\nstatic int\n_range_to_map(char* range,uint16_t *map,uint16_t map_size,int add_threads)\n{\n\tint bad_nb=0;\n\tint num_fl=0;\n\tint con_fl=0;\n\tint last=0;\n\n\tchar *dup;\n\tchar *p;\n\tchar *s=NULL;\n\n\tuint16_t start=0,end=0,i;\n\n\t/* duplicate input range */\n\tdup = xstrdup(range);\n\tp = dup;\n\twhile ( ! last ) {\n\t\tif ( isdigit(*p) ) {\n\t\t\tif ( !num_fl ) {\n\t\t\t\tnum_fl++;\n\t\t\t\ts=p;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == '-' ) {\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tstart = (uint16_t) atoi(s);\n\t\t\t\tcon_fl=1;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == ',' || *p == '\\0') {\n\t\t\tif ( *p == '\\0' )\n\t\t\t\tlast = 1;\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tend = (uint16_t) atoi(s);\n\t\t\t\tif ( !con_fl )\n\t\t\t\t\tstart = end ;\n\t\t\t\tcon_fl=2;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbad_nb++;\n\t\t\tbreak;\n\t\t}\n\t\tif ( con_fl == 2 ) {\n\t\t\tif ( add_threads ) {\n\t\t\t\tstart = start * threads;\n\t\t\t\tend = (end+1)*threads - 1 ;\n\t\t\t}\n\t\t\tfor( i = start ; i <= end && i < map_size ; i++) {\n\t\t\t\tmap[i]=1;\n\t\t\t}\n\t\t\tcon_fl=0;\n\t\t}\n\t\tp++;\n\t}\n\n\txfree(dup);\n\n\tif ( bad_nb > 0 ) {\n\t\t/* bad format for input range */\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\treturn XCPUINFO_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "block_map_size*sizeof(uint16_t)"
          ],
          "line": 1072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nuint16_t block_map_size;\n\nint\nxcpuinfo_mac_to_map(char* lrange,uint16_t **map,uint16_t *map_size)\n{\n\t*map_size = block_map_size;\n\t*map = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\t/* machine range already includes the hyperthreads */\n\treturn _range_to_map(lrange,*map,*map_size,0);\n}"
  },
  {
    "function_name": "xcpuinfo_map_to_mac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "1062-1066",
    "snippet": "int\nxcpuinfo_map_to_mac(uint16_t *map,uint16_t map_size,char** range)\n{\n\treturn _map_to_range(map,map_size,range);\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_map_to_range",
          "args": [
            "map",
            "map_size",
            "range"
          ],
          "line": 1065
        },
        "resolved": true,
        "details": {
          "function_name": "_map_to_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "1198-1259",
          "snippet": "static int\n_map_to_range(uint16_t *map,uint16_t map_size,char** prange)\n{\n\tsize_t len;\n\tint num_fl=0;\n\tint con_fl=0;\n\n\tchar id[12];\n\tchar *str;\n\n\tuint16_t start=0,end=0,i;\n\n\tstr = xstrdup(\"\");\n\tfor ( i = 0 ; i < map_size ; i++ ) {\n\n\t\tif ( map[i] ) {\n\t\t\tnum_fl=1;\n\t\t\tend=i;\n\t\t\tif ( !con_fl ) {\n\t\t\t\tstart=end;\n\t\t\t\tcon_fl=1;\n\t\t\t}\n\t\t}\n\t\telse if ( num_fl ) {\n\t\t\tif ( start < end ) {\n\t\t\t\tsprintf(id,\"%u-%u,\",start,end);\n\t\t\t\txstrcat(str,id);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf(id,\"%u,\",start);\n\t\t\t\txstrcat(str,id);\n\t\t\t}\n\t\t\tcon_fl = num_fl = 0;\n\t\t}\n\t}\n\tif ( num_fl ) {\n\t\tif ( start < end ) {\n\t\t\tsprintf(id,\"%u-%u,\",start,end);\n\t\t\txstrcat(str,id);\n\t\t}\n\t\telse {\n\t\t\tsprintf(id,\"%u,\",start);\n\t\t\txstrcat(str,id);\n\t\t}\n\t}\n\n\tlen = strlen(str);\n\tif ( len > 0 ) {\n\t\tstr[len-1]='\\0';\n\t}\n\telse {\n\t\txfree(str);\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\tif ( prange != NULL )\n\t\t*prange = str;\n\telse\n\t\txfree(str);\n\n\treturn XCPUINFO_SUCCESS;\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);\n\nstatic int\n_map_to_range(uint16_t *map,uint16_t map_size,char** prange)\n{\n\tsize_t len;\n\tint num_fl=0;\n\tint con_fl=0;\n\n\tchar id[12];\n\tchar *str;\n\n\tuint16_t start=0,end=0,i;\n\n\tstr = xstrdup(\"\");\n\tfor ( i = 0 ; i < map_size ; i++ ) {\n\n\t\tif ( map[i] ) {\n\t\t\tnum_fl=1;\n\t\t\tend=i;\n\t\t\tif ( !con_fl ) {\n\t\t\t\tstart=end;\n\t\t\t\tcon_fl=1;\n\t\t\t}\n\t\t}\n\t\telse if ( num_fl ) {\n\t\t\tif ( start < end ) {\n\t\t\t\tsprintf(id,\"%u-%u,\",start,end);\n\t\t\t\txstrcat(str,id);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsprintf(id,\"%u,\",start);\n\t\t\t\txstrcat(str,id);\n\t\t\t}\n\t\t\tcon_fl = num_fl = 0;\n\t\t}\n\t}\n\tif ( num_fl ) {\n\t\tif ( start < end ) {\n\t\t\tsprintf(id,\"%u-%u,\",start,end);\n\t\t\txstrcat(str,id);\n\t\t}\n\t\telse {\n\t\t\tsprintf(id,\"%u,\",start);\n\t\t\txstrcat(str,id);\n\t\t}\n\t}\n\n\tlen = strlen(str);\n\tif ( len > 0 ) {\n\t\tstr[len-1]='\\0';\n\t}\n\telse {\n\t\txfree(str);\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\tif ( prange != NULL )\n\t\t*prange = str;\n\telse\n\t\txfree(str);\n\n\treturn XCPUINFO_SUCCESS;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nint\nxcpuinfo_map_to_mac(uint16_t *map,uint16_t map_size,char** range)\n{\n\treturn _map_to_range(map,map_size,range);\n}"
  },
  {
    "function_name": "xcpuinfo_abs_to_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "1053-1060",
    "snippet": "int\nxcpuinfo_abs_to_map(char* lrange,uint16_t **map,uint16_t *map_size)\n{\n\t*map_size = block_map_size;\n\t*map = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\t/* abstract range does not already include the hyperthreads */\n\treturn _range_to_map(lrange,*map,*map_size,1);\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "uint16_t block_map_size;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_range_to_map",
          "args": [
            "lrange",
            "*map",
            "*map_size",
            "1"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "_range_to_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "1120-1191",
          "snippet": "static int\n_range_to_map(char* range,uint16_t *map,uint16_t map_size,int add_threads)\n{\n\tint bad_nb=0;\n\tint num_fl=0;\n\tint con_fl=0;\n\tint last=0;\n\n\tchar *dup;\n\tchar *p;\n\tchar *s=NULL;\n\n\tuint16_t start=0,end=0,i;\n\n\t/* duplicate input range */\n\tdup = xstrdup(range);\n\tp = dup;\n\twhile ( ! last ) {\n\t\tif ( isdigit(*p) ) {\n\t\t\tif ( !num_fl ) {\n\t\t\t\tnum_fl++;\n\t\t\t\ts=p;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == '-' ) {\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tstart = (uint16_t) atoi(s);\n\t\t\t\tcon_fl=1;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == ',' || *p == '\\0') {\n\t\t\tif ( *p == '\\0' )\n\t\t\t\tlast = 1;\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tend = (uint16_t) atoi(s);\n\t\t\t\tif ( !con_fl )\n\t\t\t\t\tstart = end ;\n\t\t\t\tcon_fl=2;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbad_nb++;\n\t\t\tbreak;\n\t\t}\n\t\tif ( con_fl == 2 ) {\n\t\t\tif ( add_threads ) {\n\t\t\t\tstart = start * threads;\n\t\t\t\tend = (end+1)*threads - 1 ;\n\t\t\t}\n\t\t\tfor( i = start ; i <= end && i < map_size ; i++) {\n\t\t\t\tmap[i]=1;\n\t\t\t}\n\t\t\tcon_fl=0;\n\t\t}\n\t\tp++;\n\t}\n\n\txfree(dup);\n\n\tif ( bad_nb > 0 ) {\n\t\t/* bad format for input range */\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\treturn XCPUINFO_SUCCESS;\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _range_to_map(char* range, uint16_t *map, uint16_t map_size,\n\t\t\t int add_threads);",
            "uint16_t procs, boards, sockets, cores, threads=1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _range_to_map(char* range, uint16_t *map, uint16_t map_size,\n\t\t\t int add_threads);\nuint16_t procs, boards, sockets, cores, threads=1;\n\nstatic int\n_range_to_map(char* range,uint16_t *map,uint16_t map_size,int add_threads)\n{\n\tint bad_nb=0;\n\tint num_fl=0;\n\tint con_fl=0;\n\tint last=0;\n\n\tchar *dup;\n\tchar *p;\n\tchar *s=NULL;\n\n\tuint16_t start=0,end=0,i;\n\n\t/* duplicate input range */\n\tdup = xstrdup(range);\n\tp = dup;\n\twhile ( ! last ) {\n\t\tif ( isdigit(*p) ) {\n\t\t\tif ( !num_fl ) {\n\t\t\t\tnum_fl++;\n\t\t\t\ts=p;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == '-' ) {\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tstart = (uint16_t) atoi(s);\n\t\t\t\tcon_fl=1;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse if ( *p == ',' || *p == '\\0') {\n\t\t\tif ( *p == '\\0' )\n\t\t\t\tlast = 1;\n\t\t\tif ( s && num_fl ) {\n\t\t\t\t*p = '\\0';\n\t\t\t\tend = (uint16_t) atoi(s);\n\t\t\t\tif ( !con_fl )\n\t\t\t\t\tstart = end ;\n\t\t\t\tcon_fl=2;\n\t\t\t\tnum_fl=0;\n\t\t\t\ts=NULL;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tbad_nb++;\n\t\t\tbreak;\n\t\t}\n\t\tif ( con_fl == 2 ) {\n\t\t\tif ( add_threads ) {\n\t\t\t\tstart = start * threads;\n\t\t\t\tend = (end+1)*threads - 1 ;\n\t\t\t}\n\t\t\tfor( i = start ; i <= end && i < map_size ; i++) {\n\t\t\t\tmap[i]=1;\n\t\t\t}\n\t\t\tcon_fl=0;\n\t\t}\n\t\tp++;\n\t}\n\n\txfree(dup);\n\n\tif ( bad_nb > 0 ) {\n\t\t/* bad format for input range */\n\t\treturn XCPUINFO_ERROR;\n\t}\n\n\treturn XCPUINFO_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "block_map_size*sizeof(uint16_t)"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nuint16_t block_map_size;\n\nint\nxcpuinfo_abs_to_map(char* lrange,uint16_t **map,uint16_t *map_size)\n{\n\t*map_size = block_map_size;\n\t*map = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\t/* abstract range does not already include the hyperthreads */\n\treturn _range_to_map(lrange,*map,*map_size,1);\n}"
  },
  {
    "function_name": "xcpuinfo_mac_to_abs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "1047-1051",
    "snippet": "int\nxcpuinfo_mac_to_abs(char* lrange,char** prange)\n{\n\treturn _ranges_conv(lrange,prange,1);\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_ranges_conv",
          "args": [
            "lrange",
            "prange",
            "1"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "_ranges_conv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "1266-1311",
          "snippet": "static int\n_ranges_conv(char* lrange,char** prange,int mode)\n{\n\tint fstatus;\n\tint i;\n\tuint16_t *amap;\n\tuint16_t *map;\n\tuint16_t *map_out;\n\n\t/* init internal data if not already done */\n\tif ( xcpuinfo_init() != XCPUINFO_SUCCESS )\n\t\treturn XCPUINFO_ERROR;\n\n\tif ( mode ) {\n\t\t/* machine to abstract conversion */\n\t\tamap = block_map_inv;\n\t}\n\telse {\n\t\t/* abstract to machine conversion */\n\t\tamap = block_map;\n\t}\n\n\t/* allocate map for local work */\n\tmap = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\tmap_out = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\n\t/* extract the input map */\n\tfstatus = _range_to_map(lrange,map,block_map_size,!mode);\n\tif ( fstatus ) {\n\t\tgoto exit;\n\t}\n\n\t/* do the conversion (see src/slurmd/slurmd/get_mach_stat.c) */\n\tfor( i = 0 ; i < block_map_size ; i++) {\n\t\tif ( map[i] )\n\t\t\tmap_out[amap[i]]=1;\n\t}\n\n\t/* build the ouput range */\n\tfstatus = _map_to_range(map_out,block_map_size,prange);\n\nexit:\n\txfree(map);\n\txfree(map_out);\n\treturn fstatus;\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _ranges_conv(char* lrange, char** prange, int mode);",
            "static int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);",
            "uint16_t block_map_size;",
            "uint16_t *block_map, *block_map_inv;",
            "int _ranges_conv(char* lrange,char** prange,int mode);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _ranges_conv(char* lrange, char** prange, int mode);\nstatic int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);\nuint16_t block_map_size;\nuint16_t *block_map, *block_map_inv;\nint _ranges_conv(char* lrange,char** prange,int mode);\n\nstatic int\n_ranges_conv(char* lrange,char** prange,int mode)\n{\n\tint fstatus;\n\tint i;\n\tuint16_t *amap;\n\tuint16_t *map;\n\tuint16_t *map_out;\n\n\t/* init internal data if not already done */\n\tif ( xcpuinfo_init() != XCPUINFO_SUCCESS )\n\t\treturn XCPUINFO_ERROR;\n\n\tif ( mode ) {\n\t\t/* machine to abstract conversion */\n\t\tamap = block_map_inv;\n\t}\n\telse {\n\t\t/* abstract to machine conversion */\n\t\tamap = block_map;\n\t}\n\n\t/* allocate map for local work */\n\tmap = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\tmap_out = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\n\t/* extract the input map */\n\tfstatus = _range_to_map(lrange,map,block_map_size,!mode);\n\tif ( fstatus ) {\n\t\tgoto exit;\n\t}\n\n\t/* do the conversion (see src/slurmd/slurmd/get_mach_stat.c) */\n\tfor( i = 0 ; i < block_map_size ; i++) {\n\t\tif ( map[i] )\n\t\t\tmap_out[amap[i]]=1;\n\t}\n\n\t/* build the ouput range */\n\tfstatus = _map_to_range(map_out,block_map_size,prange);\n\nexit:\n\txfree(map);\n\txfree(map_out);\n\treturn fstatus;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);\n\nint\nxcpuinfo_mac_to_abs(char* lrange,char** prange)\n{\n\treturn _ranges_conv(lrange,prange,1);\n}"
  },
  {
    "function_name": "xcpuinfo_abs_to_mac",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "987-1045",
    "snippet": "int\nxcpuinfo_abs_to_mac(char* lrange,char** prange)\n{\n\tstatic int total_cores = -1, total_cpus = -1;\n\tbitstr_t* absmap = NULL;\n\tbitstr_t* macmap = NULL;\n\tint icore, ithread;\n\tint absid, macid;\n\tint rc = SLURM_SUCCESS;\n\n\tif (total_cores == -1) {\n\t\ttotal_cores = conf->sockets * conf->cores;\n\t\ttotal_cpus  = conf->block_map_size;\n\t}\n\n\t/* allocate bitmap */\n\tabsmap = bit_alloc(total_cores);\n\tmacmap = bit_alloc(total_cpus);\n\n\tif (!absmap || !macmap) {\n\t\trc = SLURM_ERROR;\n\t\tgoto end_it;\n\t}\n\n\t/* string to bitmap conversion */\n\tif (bit_unfmt(absmap, lrange)) {\n\t\trc = SLURM_ERROR;\n\t\tgoto end_it;\n\t}\n\n\t/* mapping abstract id to machine id using conf->block_map */\n\tfor (icore = 0; icore < total_cores; icore++) {\n\t\tif (bit_test(absmap, icore)) {\n\t\t\tfor (ithread = 0; ithread<conf->threads; ithread++) {\n\t\t\t\tabsid  = icore*conf->threads + ithread;\n\t\t\t\tabsid %= total_cpus;\n\n\t\t\t\tmacid  = conf->block_map[absid];\n\t\t\t\tmacid %= total_cpus;\n\n\t\t\t\tbit_set(macmap, macid);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* convert machine cpu bitmap to range string */\n\t*prange = (char*)xmalloc(total_cpus*6);\n\tbit_fmt(*prange, total_cpus*6, macmap);\n\n\t/* free unused bitmaps */\nend_it:\n\tFREE_NULL_BITMAP(absmap);\n\tFREE_NULL_BITMAP(macmap);\n\n\tif (rc != SLURM_SUCCESS)\n\t\tinfo(\"_abs_to_mac failed\");\n\n\treturn rc;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);",
      "uint16_t procs, boards, sockets, cores, threads=1;",
      "uint16_t block_map_size;",
      "extern slurmd_conf_t *conf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "info",
          "args": [
            "\"_abs_to_mac failed\""
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "_fork_child_with_wait_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "1464-1486",
          "snippet": "static struct exec_wait_info * _fork_child_with_wait_info (int id)\n{\n\tstruct exec_wait_info *e;\n\n\tif (!(e = _exec_wait_info_create (id)))\n\t\treturn (NULL);\n\n\tif ((e->pid = fork ()) < 0) {\n\t\t_exec_wait_info_destroy (e);\n\t\treturn (NULL);\n\t}\n\t/*\n\t *  Close parentfd in child, and childfd in parent:\n\t */\n\tif (e->pid == 0) {\n\t\tclose (e->parentfd);\n\t\te->parentfd = -1;\n\t} else {\n\t\tclose (e->childfd);\n\t\te->childfd = -1;\n\t}\n\treturn (e);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic struct exec_wait_info * _fork_child_with_wait_info (int id)\n{\n\tstruct exec_wait_info *e;\n\n\tif (!(e = _exec_wait_info_create (id)))\n\t\treturn (NULL);\n\n\tif ((e->pid = fork ()) < 0) {\n\t\t_exec_wait_info_destroy (e);\n\t\treturn (NULL);\n\t}\n\t/*\n\t *  Close parentfd in child, and childfd in parent:\n\t */\n\tif (e->pid == 0) {\n\t\tclose (e->parentfd);\n\t\te->parentfd = -1;\n\t} else {\n\t\tclose (e->childfd);\n\t\te->childfd = -1;\n\t}\n\treturn (e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREE_NULL_BITMAP",
          "args": [
            "macmap"
          ],
          "line": 1039
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "FREE_NULL_BITMAP",
          "args": [
            "absmap"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_fmt",
          "args": [
            "*prange",
            "total_cpus*6",
            "macmap"
          ],
          "line": 1034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "total_cpus*6"
          ],
          "line": 1033
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_set",
          "args": [
            "macmap",
            "macid"
          ],
          "line": 1027
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_test",
          "args": [
            "absmap",
            "icore"
          ],
          "line": 1019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_unfmt",
          "args": [
            "absmap",
            "lrange"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_alloc",
          "args": [
            "total_cpus"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_alloc",
          "args": [
            "total_cores"
          ],
          "line": 1003
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _map_to_range(uint16_t *map, uint16_t map_size, char** prange);\nuint16_t procs, boards, sockets, cores, threads=1;\nuint16_t block_map_size;\nextern slurmd_conf_t *conf;\n\nint\nxcpuinfo_abs_to_mac(char* lrange,char** prange)\n{\n\tstatic int total_cores = -1, total_cpus = -1;\n\tbitstr_t* absmap = NULL;\n\tbitstr_t* macmap = NULL;\n\tint icore, ithread;\n\tint absid, macid;\n\tint rc = SLURM_SUCCESS;\n\n\tif (total_cores == -1) {\n\t\ttotal_cores = conf->sockets * conf->cores;\n\t\ttotal_cpus  = conf->block_map_size;\n\t}\n\n\t/* allocate bitmap */\n\tabsmap = bit_alloc(total_cores);\n\tmacmap = bit_alloc(total_cpus);\n\n\tif (!absmap || !macmap) {\n\t\trc = SLURM_ERROR;\n\t\tgoto end_it;\n\t}\n\n\t/* string to bitmap conversion */\n\tif (bit_unfmt(absmap, lrange)) {\n\t\trc = SLURM_ERROR;\n\t\tgoto end_it;\n\t}\n\n\t/* mapping abstract id to machine id using conf->block_map */\n\tfor (icore = 0; icore < total_cores; icore++) {\n\t\tif (bit_test(absmap, icore)) {\n\t\t\tfor (ithread = 0; ithread<conf->threads; ithread++) {\n\t\t\t\tabsid  = icore*conf->threads + ithread;\n\t\t\t\tabsid %= total_cpus;\n\n\t\t\t\tmacid  = conf->block_map[absid];\n\t\t\t\tmacid %= total_cpus;\n\n\t\t\t\tbit_set(macmap, macid);\n\t\t\t}\n\t\t}\n\t}\n\n\t/* convert machine cpu bitmap to range string */\n\t*prange = (char*)xmalloc(total_cpus*6);\n\tbit_fmt(*prange, total_cpus*6, macmap);\n\n\t/* free unused bitmaps */\nend_it:\n\tFREE_NULL_BITMAP(absmap);\n\tFREE_NULL_BITMAP(macmap);\n\n\tif (rc != SLURM_SUCCESS)\n\t\tinfo(\"_abs_to_mac failed\");\n\n\treturn rc;\n}"
  },
  {
    "function_name": "xcpuinfo_fini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "972-985",
    "snippet": "int\nxcpuinfo_fini(void)\n{\n\tif ( ! initialized )\n\t\treturn XCPUINFO_SUCCESS;\n\n\tinitialized = false ;\n\tprocs = sockets = cores = threads = 0;\n\tblock_map_size = 0;\n\txfree(block_map);\n\txfree(block_map_inv);\n\n\treturn XCPUINFO_SUCCESS;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool     initialized = false;",
      "uint16_t procs, boards, sockets, cores, threads=1;",
      "uint16_t block_map_size;",
      "uint16_t *block_map, *block_map_inv;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "block_map_inv"
          ],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nbool     initialized = false;\nuint16_t procs, boards, sockets, cores, threads=1;\nuint16_t block_map_size;\nuint16_t *block_map, *block_map_inv;\n\nint\nxcpuinfo_fini(void)\n{\n\tif ( ! initialized )\n\t\treturn XCPUINFO_SUCCESS;\n\n\tinitialized = false ;\n\tprocs = sockets = cores = threads = 0;\n\tblock_map_size = 0;\n\txfree(block_map);\n\txfree(block_map_inv);\n\n\treturn XCPUINFO_SUCCESS;\n}"
  },
  {
    "function_name": "xcpuinfo_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "957-970",
    "snippet": "int\nxcpuinfo_init(void)\n{\n\tif ( initialized )\n\t\treturn XCPUINFO_SUCCESS;\n\n\tif ( get_cpuinfo(&procs,&boards,&sockets,&cores,&threads,\n\t\t\t &block_map_size,&block_map,&block_map_inv) )\n\t\treturn XCPUINFO_ERROR;\n\n\tinitialized = true ;\n\n\treturn XCPUINFO_SUCCESS;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "bool     initialized = false;",
      "uint16_t procs, boards, sockets, cores, threads=1;",
      "uint16_t block_map_size;",
      "uint16_t *block_map, *block_map_inv;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_cpuinfo",
          "args": [
            "&procs",
            "&boards",
            "&sockets",
            "&cores",
            "&threads",
            "&block_map_size",
            "&block_map",
            "&block_map_inv"
          ],
          "line": 963
        },
        "resolved": true,
        "details": {
          "function_name": "get_cpuinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "438-744",
          "snippet": "extern int\nget_cpuinfo(uint16_t *p_cpus, uint16_t *p_boards,\n\t    uint16_t *p_sockets, uint16_t *p_cores, uint16_t *p_threads,\n\t    uint16_t *p_block_map_size,\n\t    uint16_t **p_block_map, uint16_t **p_block_map_inv)\n{\n\tint retval;\n\n\tuint16_t numproc;\n\tuint16_t numcpu\t   = 0;\t\t/* number of cpus seen */\n\tuint16_t numphys   = 0;\t\t/* number of unique \"physical id\"s */\n\tuint16_t numcores  = 0;\t\t/* number of unique \"cores id\"s */\n\n\tuint16_t maxsibs   = 0;\t\t/* maximum value of \"siblings\" */\n\tuint16_t maxcores  = 0;\t\t/* maximum value of \"cores\" */\n\tuint16_t minsibs   = 0xffff;\t/* minimum value of \"siblings\" */\n\tuint16_t mincores  = 0xffff;\t/* minimum value of \"cores\" */\n\n\tuint32_t maxcpuid  = 0;\t\t/* maximum CPU ID (\"processor\") */\n\tuint32_t maxphysid = 0;\t\t/* maximum \"physical id\" */\n\tuint32_t maxcoreid = 0;\t\t/* maximum \"core id\" */\n\tuint32_t mincpuid  = 0xffffffff;/* minimum CPU ID (\"processor\") */\n\tuint32_t minphysid = 0xffffffff;/* minimum \"physical id\" */\n\tuint32_t mincoreid = 0xffffffff;/* minimum \"core id\" */\n\tint i;\n#if defined (__sun)\n#if defined (_LP64)\n\tint64_t curcpu, val, sockets, cores, threads;\n#else\n\tint32_t curcpu, val, sockets, cores, threads;\n#endif\n\tint32_t chip_id, core_id, ncore_per_chip, ncpu_per_chip;\n#else\n\tFILE *cpu_info_file;\n\tchar buffer[128];\n\tuint16_t curcpu, sockets, cores, threads;\n#endif\n\n\tget_procs(&numproc);\n\t*p_cpus = numproc;\n\t*p_boards = 1;\t\t/* Boards not identified from /proc/cpuinfo */\n\t*p_sockets = numproc;\t/* initially all single core/thread */\n\t*p_cores   = 1;\n\t*p_threads = 1;\n\t*p_block_map_size = 0;\n\t*p_block_map      = NULL;\n\t*p_block_map_inv  = NULL;\n\n#if defined (__sun)\n\tkstat_ctl_t   *kc;\n\tkstat_t       *ksp;\n\tkstat_named_t *knp;\n\n\tkc = kstat_open();\n\tif (kc == NULL) {\n\t\terror (\"get speed: kstat error %d\", errno);\n\t\treturn errno;\n\t}\n#else\n\tcpu_info_file = fopen(_cpuinfo_path, \"r\");\n\tif (cpu_info_file == NULL) {\n\t\terror (\"get_cpuinfo: error %d opening %s\",\n\t\t\terrno, _cpuinfo_path);\n\t\treturn errno;\n\t}\n#endif\n\n\t/* Note: assumes all processor IDs are within [0:numproc-1] */\n\t/*       treats physical/core IDs as tokens, not indices */\n\tif (cpuinfo)\n\t\tmemset(cpuinfo, 0, numproc * sizeof(cpuinfo_t));\n\telse\n\t\tcpuinfo = xmalloc(numproc * sizeof(cpuinfo_t));\n\n#if defined (__sun)\n\tksp = kstat_lookup(kc, \"cpu_info\", -1, NULL);\n\tfor (; ksp != NULL; ksp = ksp->ks_next) {\n\t\tif (xstrcmp(ksp->ks_module, \"cpu_info\"))\n\t\t\tcontinue;\n\n\t\tnumcpu++;\n\t\tkstat_read(kc, ksp, NULL);\n\n\t\tknp = kstat_data_lookup(ksp, \"chip_id\");\n\t\tchip_id = knp->value.l;\n\t\tknp = kstat_data_lookup(ksp, \"core_id\");\n\t\tcore_id = knp->value.l;\n\t\tknp = kstat_data_lookup(ksp, \"ncore_per_chip\");\n\t\tncore_per_chip = knp->value.l;\n\t\tknp = kstat_data_lookup(ksp, \"ncpu_per_chip\");\n\t\tncpu_per_chip = knp->value.l;\n\n\t\tif (chip_id >= numproc) {\n\t\t\tdebug(\"cpuid is %ld (> %d), ignored\", curcpu, numproc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcpuinfo[chip_id].seen = 1;\n\t\tcpuinfo[chip_id].cpuid = chip_id;\n\n\t\tmaxcpuid = MAX(maxcpuid, chip_id);\n\t\tmincpuid = MIN(mincpuid, chip_id);\n\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tif ((cpuinfo[i].coreid == core_id) &&\n\t\t\t    (cpuinfo[i].corecnt))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == numproc) {\n\t\t\tnumcores++;\n\t\t} else {\n\t\t\tcpuinfo[i].corecnt++;\n\t\t}\n\n\t\tif (chip_id < numproc) {\n\t\t\tcpuinfo[chip_id].corecnt++;\n\t\t\tcpuinfo[chip_id].coreid = core_id;\n\t\t}\n\n\t\tmaxcoreid = MAX(maxcoreid, core_id);\n\t\tmincoreid = MIN(mincoreid, core_id);\n\n\t\tif (ncore_per_chip > numproc) {\n\t\t\tdebug(\"cores is %u (> %d), ignored\",\n\t\t\t      ncore_per_chip, numproc);\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (chip_id < numproc)\n\t\t\tcpuinfo[chip_id].cores = ncore_per_chip;\n\n\t\tmaxcores = MAX(maxcores, ncore_per_chip);\n\t\tmincores = MIN(mincores, ncore_per_chip);\n\t}\n#else\n\n\tcurcpu = 0;\n\twhile (fgets(buffer, sizeof(buffer), cpu_info_file) != NULL) {\n\t\tuint32_t val;\n\t\tif (_chk_cpuinfo_uint32(buffer, \"processor\", &val)) {\n\t\t\tcurcpu = numcpu;\n\t\t\tnumcpu++;\n\t\t\tif (curcpu >= numproc) {\n\t\t\t\tinfo(\"processor limit reached (%u >= %d)\",\n\t\t\t\t     curcpu, numproc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcpuinfo[curcpu].seen = 1;\n\t\t\tcpuinfo[curcpu].cpuid = val;\n\t\t\tmaxcpuid = MAX(maxcpuid, val);\n\t\t\tmincpuid = MIN(mincpuid, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"physical id\", &val)) {\n\t\t\t/* see if the ID has already been seen */\n\t\t\tfor (i=0; i<numproc; i++) {\n\t\t\t\tif ((cpuinfo[i].physid == val)\n\t\t\t\t&&  (cpuinfo[i].physcnt))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == numproc) {\t\t/* new ID... */\n\t\t\t\tnumphys++;\t\t/* ...increment total */\n\t\t\t} else {\t\t\t/* existing ID... */\n\t\t\t\tcpuinfo[i].physcnt++;\t/* ...update ID cnt */\n\t\t\t}\n\n\t\t\tif (curcpu < numproc) {\n\t\t\t\tcpuinfo[curcpu].physcnt++;\n\t\t\t\tcpuinfo[curcpu].physid = val;\n\t\t\t}\n\n\t\t\tmaxphysid = MAX(maxphysid, val);\n\t\t\tminphysid = MIN(minphysid, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"core id\", &val)) {\n\t\t\t/* see if the ID has already been seen */\n\t\t\tfor (i = 0; i < numproc; i++) {\n\t\t\t\tif ((cpuinfo[i].coreid == val)\n\t\t\t\t&&  (cpuinfo[i].corecnt))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == numproc) {\t\t/* new ID... */\n\t\t\t\tnumcores++;\t\t/* ...increment total */\n\t\t\t} else {\t\t\t/* existing ID... */\n\t\t\t\tcpuinfo[i].corecnt++;\t/* ...update ID cnt */\n\t\t\t}\n\n\t\t\tif (curcpu < numproc) {\n\t\t\t\tcpuinfo[curcpu].corecnt++;\n\t\t\t\tcpuinfo[curcpu].coreid = val;\n\t\t\t}\n\n\t\t\tmaxcoreid = MAX(maxcoreid, val);\n\t\t\tmincoreid = MIN(mincoreid, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"siblings\", &val)) {\n\t\t\t/* Note: this value is a count, not an index */\n\t\t    \tif (val > numproc) {\t/* out of bounds, ignore */\n\t\t\t\tdebug(\"siblings is %u (> %d), ignored\",\n\t\t\t\t\tval, numproc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (curcpu < numproc)\n\t\t\t\tcpuinfo[curcpu].siblings = val;\n\t\t\tmaxsibs = MAX(maxsibs, val);\n\t\t\tminsibs = MIN(minsibs, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"cpu cores\", &val)) {\n\t\t\t/* Note: this value is a count, not an index */\n\t\t    \tif (val > numproc) {\t/* out of bounds, ignore */\n\t\t\t\tdebug(\"cores is %u (> %d), ignored\",\n\t\t\t\t\tval, numproc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (curcpu < numproc)\n\t\t\t\tcpuinfo[curcpu].cores = val;\n\t\t\tmaxcores = MAX(maxcores, val);\n\t\t\tmincores = MIN(mincores, val);\n\t\t}\n\t}\n\n\tfclose(cpu_info_file);\n#endif\n\n\t/*** Sanity check ***/\n\tif (minsibs == 0) minsibs = 1;\t\t/* guaranteee non-zero */\n\tif (maxsibs == 0) {\n\t    \tminsibs = 1;\n\t    \tmaxsibs = 1;\n\t}\n\tif (maxcores == 0) {\t\t\t/* no core data */\n\t    \tmincores = 0;\n\t    \tmaxcores = 0;\n\t}\n\n\t/*** Compute Sockets/Cores/Threads ***/\n\tif ((minsibs == maxsibs) &&\t\t/* homogeneous system */\n\t    (mincores == maxcores)) {\n\t\tsockets = numphys; \t\t/* unique \"physical id\" */\n\t\tif (sockets <= 1) {\t\t/* verify single socket */\n\t\t\tsockets = numcpu / maxsibs; /* maximum \"siblings\" */\n\t\t}\n\t\tif (sockets == 0)\n\t\t\tsockets = 1;\t\t/* guarantee non-zero */\n\n\t\tcores = numcores / sockets;\t/* unique \"core id\" */\n\t\tcores = MAX(maxcores, cores);\t/* maximum \"cpu cores\" */\n\n\t\tif (cores == 0) {\n\t\t\tcores = numcpu / sockets;\t/* assume multi-core */\n\t\t\tif (cores > 1) {\n\t\t\t\tdebug3(\"Warning: cpuinfo missing 'core id' or \"\n\t\t\t\t\t\"'cpu cores' but assuming multi-core\");\n\t\t\t}\n\t\t}\n\t\tif (cores == 0)\n\t\t\tcores = 1;\t/* guarantee non-zero */\n\n\t\tthreads = numcpu / (sockets * cores); /* solve for threads */\n\t\tif (threads == 0)\n\t\t\tthreads = 1;\t/* guarantee non-zero */\n\t} else {\t\t\t\t/* heterogeneous system */\n\t\tsockets = numcpu;\n\t\tcores   = 1;\t\t\t/* one core per socket */\n\t\tthreads = 1;\t\t\t/* one core per core */\n\t}\n\n\t*p_sockets = sockets;\t\t/* update output parameters */\n\t*p_cores   = cores;\n\t*p_threads = threads;\n\n#if _DEBUG\n\t/*** Display raw data ***/\n\tdebug3(\"numcpu:     %u\", numcpu);\n\tdebug3(\"numphys:    %u\", numphys);\n\tdebug3(\"numcores:   %u\", numcores);\n\n\tdebug3(\"cores:      %u->%u\", mincores, maxcores);\n\tdebug3(\"sibs:       %u->%u\", minsibs,  maxsibs);\n\n\tdebug3(\"cpuid:      %u->%u\", mincpuid,  maxcpuid);\n\tdebug3(\"physid:     %u->%u\", minphysid, maxphysid);\n\tdebug3(\"coreid:     %u->%u\", mincoreid, maxcoreid);\n\n\tfor (i = 0; i < numproc; i++) {\n\t\tdebug3(\"CPU %d:\", i);\n\t\tdebug3(\" cpuid:    %u\", cpuinfo[i].cpuid);\n\t\tdebug3(\" seen:     %u\", cpuinfo[i].seen);\n\t\tdebug3(\" physid:   %u\", cpuinfo[i].physid);\n\t\tdebug3(\" physcnt:  %u\", cpuinfo[i].physcnt);\n\t\tdebug3(\" siblings: %u\", cpuinfo[i].siblings);\n\t\tdebug3(\" cores:    %u\", cpuinfo[i].cores);\n\t\tdebug3(\" coreid:   %u\", cpuinfo[i].coreid);\n\t\tdebug3(\" corecnt:  %u\\n\", cpuinfo[i].corecnt);\n\t}\n\n\tdebug3(\"Sockets:          %u\", sockets);\n\tdebug3(\"Cores per socket: %u\", cores);\n\tdebug3(\"Threads per core: %u\", threads);\n#endif\n\n\t*p_block_map_size = numcpu;\n\tretval = _compute_block_map(*p_block_map_size, p_block_map,\n\t\t\t\t    p_block_map_inv);\n\n\txfree(cpuinfo);\t\t/* done with raw cpuinfo data */\n\n\treturn retval;\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [
            "#define _DEBUG 0"
          ],
          "globals_used": [
            "uint16_t procs, boards, sockets, cores, threads=1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\n#define _DEBUG 0\n\nuint16_t procs, boards, sockets, cores, threads=1;\n\nextern int\nget_cpuinfo(uint16_t *p_cpus, uint16_t *p_boards,\n\t    uint16_t *p_sockets, uint16_t *p_cores, uint16_t *p_threads,\n\t    uint16_t *p_block_map_size,\n\t    uint16_t **p_block_map, uint16_t **p_block_map_inv)\n{\n\tint retval;\n\n\tuint16_t numproc;\n\tuint16_t numcpu\t   = 0;\t\t/* number of cpus seen */\n\tuint16_t numphys   = 0;\t\t/* number of unique \"physical id\"s */\n\tuint16_t numcores  = 0;\t\t/* number of unique \"cores id\"s */\n\n\tuint16_t maxsibs   = 0;\t\t/* maximum value of \"siblings\" */\n\tuint16_t maxcores  = 0;\t\t/* maximum value of \"cores\" */\n\tuint16_t minsibs   = 0xffff;\t/* minimum value of \"siblings\" */\n\tuint16_t mincores  = 0xffff;\t/* minimum value of \"cores\" */\n\n\tuint32_t maxcpuid  = 0;\t\t/* maximum CPU ID (\"processor\") */\n\tuint32_t maxphysid = 0;\t\t/* maximum \"physical id\" */\n\tuint32_t maxcoreid = 0;\t\t/* maximum \"core id\" */\n\tuint32_t mincpuid  = 0xffffffff;/* minimum CPU ID (\"processor\") */\n\tuint32_t minphysid = 0xffffffff;/* minimum \"physical id\" */\n\tuint32_t mincoreid = 0xffffffff;/* minimum \"core id\" */\n\tint i;\n#if defined (__sun)\n#if defined (_LP64)\n\tint64_t curcpu, val, sockets, cores, threads;\n#else\n\tint32_t curcpu, val, sockets, cores, threads;\n#endif\n\tint32_t chip_id, core_id, ncore_per_chip, ncpu_per_chip;\n#else\n\tFILE *cpu_info_file;\n\tchar buffer[128];\n\tuint16_t curcpu, sockets, cores, threads;\n#endif\n\n\tget_procs(&numproc);\n\t*p_cpus = numproc;\n\t*p_boards = 1;\t\t/* Boards not identified from /proc/cpuinfo */\n\t*p_sockets = numproc;\t/* initially all single core/thread */\n\t*p_cores   = 1;\n\t*p_threads = 1;\n\t*p_block_map_size = 0;\n\t*p_block_map      = NULL;\n\t*p_block_map_inv  = NULL;\n\n#if defined (__sun)\n\tkstat_ctl_t   *kc;\n\tkstat_t       *ksp;\n\tkstat_named_t *knp;\n\n\tkc = kstat_open();\n\tif (kc == NULL) {\n\t\terror (\"get speed: kstat error %d\", errno);\n\t\treturn errno;\n\t}\n#else\n\tcpu_info_file = fopen(_cpuinfo_path, \"r\");\n\tif (cpu_info_file == NULL) {\n\t\terror (\"get_cpuinfo: error %d opening %s\",\n\t\t\terrno, _cpuinfo_path);\n\t\treturn errno;\n\t}\n#endif\n\n\t/* Note: assumes all processor IDs are within [0:numproc-1] */\n\t/*       treats physical/core IDs as tokens, not indices */\n\tif (cpuinfo)\n\t\tmemset(cpuinfo, 0, numproc * sizeof(cpuinfo_t));\n\telse\n\t\tcpuinfo = xmalloc(numproc * sizeof(cpuinfo_t));\n\n#if defined (__sun)\n\tksp = kstat_lookup(kc, \"cpu_info\", -1, NULL);\n\tfor (; ksp != NULL; ksp = ksp->ks_next) {\n\t\tif (xstrcmp(ksp->ks_module, \"cpu_info\"))\n\t\t\tcontinue;\n\n\t\tnumcpu++;\n\t\tkstat_read(kc, ksp, NULL);\n\n\t\tknp = kstat_data_lookup(ksp, \"chip_id\");\n\t\tchip_id = knp->value.l;\n\t\tknp = kstat_data_lookup(ksp, \"core_id\");\n\t\tcore_id = knp->value.l;\n\t\tknp = kstat_data_lookup(ksp, \"ncore_per_chip\");\n\t\tncore_per_chip = knp->value.l;\n\t\tknp = kstat_data_lookup(ksp, \"ncpu_per_chip\");\n\t\tncpu_per_chip = knp->value.l;\n\n\t\tif (chip_id >= numproc) {\n\t\t\tdebug(\"cpuid is %ld (> %d), ignored\", curcpu, numproc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcpuinfo[chip_id].seen = 1;\n\t\tcpuinfo[chip_id].cpuid = chip_id;\n\n\t\tmaxcpuid = MAX(maxcpuid, chip_id);\n\t\tmincpuid = MIN(mincpuid, chip_id);\n\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tif ((cpuinfo[i].coreid == core_id) &&\n\t\t\t    (cpuinfo[i].corecnt))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == numproc) {\n\t\t\tnumcores++;\n\t\t} else {\n\t\t\tcpuinfo[i].corecnt++;\n\t\t}\n\n\t\tif (chip_id < numproc) {\n\t\t\tcpuinfo[chip_id].corecnt++;\n\t\t\tcpuinfo[chip_id].coreid = core_id;\n\t\t}\n\n\t\tmaxcoreid = MAX(maxcoreid, core_id);\n\t\tmincoreid = MIN(mincoreid, core_id);\n\n\t\tif (ncore_per_chip > numproc) {\n\t\t\tdebug(\"cores is %u (> %d), ignored\",\n\t\t\t      ncore_per_chip, numproc);\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (chip_id < numproc)\n\t\t\tcpuinfo[chip_id].cores = ncore_per_chip;\n\n\t\tmaxcores = MAX(maxcores, ncore_per_chip);\n\t\tmincores = MIN(mincores, ncore_per_chip);\n\t}\n#else\n\n\tcurcpu = 0;\n\twhile (fgets(buffer, sizeof(buffer), cpu_info_file) != NULL) {\n\t\tuint32_t val;\n\t\tif (_chk_cpuinfo_uint32(buffer, \"processor\", &val)) {\n\t\t\tcurcpu = numcpu;\n\t\t\tnumcpu++;\n\t\t\tif (curcpu >= numproc) {\n\t\t\t\tinfo(\"processor limit reached (%u >= %d)\",\n\t\t\t\t     curcpu, numproc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcpuinfo[curcpu].seen = 1;\n\t\t\tcpuinfo[curcpu].cpuid = val;\n\t\t\tmaxcpuid = MAX(maxcpuid, val);\n\t\t\tmincpuid = MIN(mincpuid, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"physical id\", &val)) {\n\t\t\t/* see if the ID has already been seen */\n\t\t\tfor (i=0; i<numproc; i++) {\n\t\t\t\tif ((cpuinfo[i].physid == val)\n\t\t\t\t&&  (cpuinfo[i].physcnt))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == numproc) {\t\t/* new ID... */\n\t\t\t\tnumphys++;\t\t/* ...increment total */\n\t\t\t} else {\t\t\t/* existing ID... */\n\t\t\t\tcpuinfo[i].physcnt++;\t/* ...update ID cnt */\n\t\t\t}\n\n\t\t\tif (curcpu < numproc) {\n\t\t\t\tcpuinfo[curcpu].physcnt++;\n\t\t\t\tcpuinfo[curcpu].physid = val;\n\t\t\t}\n\n\t\t\tmaxphysid = MAX(maxphysid, val);\n\t\t\tminphysid = MIN(minphysid, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"core id\", &val)) {\n\t\t\t/* see if the ID has already been seen */\n\t\t\tfor (i = 0; i < numproc; i++) {\n\t\t\t\tif ((cpuinfo[i].coreid == val)\n\t\t\t\t&&  (cpuinfo[i].corecnt))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == numproc) {\t\t/* new ID... */\n\t\t\t\tnumcores++;\t\t/* ...increment total */\n\t\t\t} else {\t\t\t/* existing ID... */\n\t\t\t\tcpuinfo[i].corecnt++;\t/* ...update ID cnt */\n\t\t\t}\n\n\t\t\tif (curcpu < numproc) {\n\t\t\t\tcpuinfo[curcpu].corecnt++;\n\t\t\t\tcpuinfo[curcpu].coreid = val;\n\t\t\t}\n\n\t\t\tmaxcoreid = MAX(maxcoreid, val);\n\t\t\tmincoreid = MIN(mincoreid, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"siblings\", &val)) {\n\t\t\t/* Note: this value is a count, not an index */\n\t\t    \tif (val > numproc) {\t/* out of bounds, ignore */\n\t\t\t\tdebug(\"siblings is %u (> %d), ignored\",\n\t\t\t\t\tval, numproc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (curcpu < numproc)\n\t\t\t\tcpuinfo[curcpu].siblings = val;\n\t\t\tmaxsibs = MAX(maxsibs, val);\n\t\t\tminsibs = MIN(minsibs, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"cpu cores\", &val)) {\n\t\t\t/* Note: this value is a count, not an index */\n\t\t    \tif (val > numproc) {\t/* out of bounds, ignore */\n\t\t\t\tdebug(\"cores is %u (> %d), ignored\",\n\t\t\t\t\tval, numproc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (curcpu < numproc)\n\t\t\t\tcpuinfo[curcpu].cores = val;\n\t\t\tmaxcores = MAX(maxcores, val);\n\t\t\tmincores = MIN(mincores, val);\n\t\t}\n\t}\n\n\tfclose(cpu_info_file);\n#endif\n\n\t/*** Sanity check ***/\n\tif (minsibs == 0) minsibs = 1;\t\t/* guaranteee non-zero */\n\tif (maxsibs == 0) {\n\t    \tminsibs = 1;\n\t    \tmaxsibs = 1;\n\t}\n\tif (maxcores == 0) {\t\t\t/* no core data */\n\t    \tmincores = 0;\n\t    \tmaxcores = 0;\n\t}\n\n\t/*** Compute Sockets/Cores/Threads ***/\n\tif ((minsibs == maxsibs) &&\t\t/* homogeneous system */\n\t    (mincores == maxcores)) {\n\t\tsockets = numphys; \t\t/* unique \"physical id\" */\n\t\tif (sockets <= 1) {\t\t/* verify single socket */\n\t\t\tsockets = numcpu / maxsibs; /* maximum \"siblings\" */\n\t\t}\n\t\tif (sockets == 0)\n\t\t\tsockets = 1;\t\t/* guarantee non-zero */\n\n\t\tcores = numcores / sockets;\t/* unique \"core id\" */\n\t\tcores = MAX(maxcores, cores);\t/* maximum \"cpu cores\" */\n\n\t\tif (cores == 0) {\n\t\t\tcores = numcpu / sockets;\t/* assume multi-core */\n\t\t\tif (cores > 1) {\n\t\t\t\tdebug3(\"Warning: cpuinfo missing 'core id' or \"\n\t\t\t\t\t\"'cpu cores' but assuming multi-core\");\n\t\t\t}\n\t\t}\n\t\tif (cores == 0)\n\t\t\tcores = 1;\t/* guarantee non-zero */\n\n\t\tthreads = numcpu / (sockets * cores); /* solve for threads */\n\t\tif (threads == 0)\n\t\t\tthreads = 1;\t/* guarantee non-zero */\n\t} else {\t\t\t\t/* heterogeneous system */\n\t\tsockets = numcpu;\n\t\tcores   = 1;\t\t\t/* one core per socket */\n\t\tthreads = 1;\t\t\t/* one core per core */\n\t}\n\n\t*p_sockets = sockets;\t\t/* update output parameters */\n\t*p_cores   = cores;\n\t*p_threads = threads;\n\n#if _DEBUG\n\t/*** Display raw data ***/\n\tdebug3(\"numcpu:     %u\", numcpu);\n\tdebug3(\"numphys:    %u\", numphys);\n\tdebug3(\"numcores:   %u\", numcores);\n\n\tdebug3(\"cores:      %u->%u\", mincores, maxcores);\n\tdebug3(\"sibs:       %u->%u\", minsibs,  maxsibs);\n\n\tdebug3(\"cpuid:      %u->%u\", mincpuid,  maxcpuid);\n\tdebug3(\"physid:     %u->%u\", minphysid, maxphysid);\n\tdebug3(\"coreid:     %u->%u\", mincoreid, maxcoreid);\n\n\tfor (i = 0; i < numproc; i++) {\n\t\tdebug3(\"CPU %d:\", i);\n\t\tdebug3(\" cpuid:    %u\", cpuinfo[i].cpuid);\n\t\tdebug3(\" seen:     %u\", cpuinfo[i].seen);\n\t\tdebug3(\" physid:   %u\", cpuinfo[i].physid);\n\t\tdebug3(\" physcnt:  %u\", cpuinfo[i].physcnt);\n\t\tdebug3(\" siblings: %u\", cpuinfo[i].siblings);\n\t\tdebug3(\" cores:    %u\", cpuinfo[i].cores);\n\t\tdebug3(\" coreid:   %u\", cpuinfo[i].coreid);\n\t\tdebug3(\" corecnt:  %u\\n\", cpuinfo[i].corecnt);\n\t}\n\n\tdebug3(\"Sockets:          %u\", sockets);\n\tdebug3(\"Cores per socket: %u\", cores);\n\tdebug3(\"Threads per core: %u\", threads);\n#endif\n\n\t*p_block_map_size = numcpu;\n\tretval = _compute_block_map(*p_block_map_size, p_block_map,\n\t\t\t\t    p_block_map_inv);\n\n\txfree(cpuinfo);\t\t/* done with raw cpuinfo data */\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nbool     initialized = false;\nuint16_t procs, boards, sockets, cores, threads=1;\nuint16_t block_map_size;\nuint16_t *block_map, *block_map_inv;\n\nint\nxcpuinfo_init(void)\n{\n\tif ( initialized )\n\t\treturn XCPUINFO_SUCCESS;\n\n\tif ( get_cpuinfo(&procs,&boards,&sockets,&cores,&threads,\n\t\t\t &block_map_size,&block_map,&block_map_inv) )\n\t\treturn XCPUINFO_ERROR;\n\n\tinitialized = true ;\n\n\treturn XCPUINFO_SUCCESS;\n}"
  },
  {
    "function_name": "_compute_block_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "869-944",
    "snippet": "static int _compute_block_map(uint16_t numproc,\n\t\t\t      uint16_t **block_map, uint16_t **block_map_inv)\n{\n\tuint16_t i;\n\t/* Compute abstract->machine block mapping (and inverse) */\n\tif (block_map) {\n\t\t*block_map = xmalloc(numproc * sizeof(uint16_t));\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\t(*block_map)[i] = i;\n\t\t}\n\t\tqsort(*block_map, numproc, sizeof(uint16_t), &_compare_cpus);\n\t}\n\tif (block_map && block_map_inv) {\n\t\t*block_map_inv = xmalloc(numproc * sizeof(uint16_t));\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tuint16_t idx = (*block_map)[i];\n\t\t\t(*block_map_inv)[idx] = i;\n\t\t}\n\t}\n#if _DEBUG\n\t/* Display the mapping tables */\n\n\tdebug3(\"\\nMachine logical CPU ID assignment:\");\n\tdebug3(\"Logical CPU ID:      \");\n\tfor (i = 0; i < numproc; i++) {\n\t\tdebug3(\"%3d\", i);\n\t}\n\tdebug3(\"\");\n\tdebug3(\"Physical Socket ID:  \");\n\tfor (i = 0; i < numproc; i++) {\n\t\tdebug3(\"%3u\", cpuinfo[i].physid);\n\t}\n\tdebug3(\"\");\n\n\tif (block_map) {\n\t\tdebug3(\"\\nAbstract -> Machine logical CPU ID block mapping:\");\n\t\tdebug3(\"Input: (Abstract ID) \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3d\", i);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Output: (Machine ID) \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3u\", (*block_map)[i]);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Physical Socket ID:  \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tuint16_t id = (*block_map)[i];\n\t\t\tdebug3(\"%3u\", cpuinfo[id].physid);\n\t\t}\n\t\tdebug3(\"\");\n\t}\n\n\tif (block_map_inv) {\n\t\tdebug3(\"\\nMachine -> Abstract logical CPU ID block mapping: \"\n\t\t\t\"(inverse)\");\n\t\tdebug3(\"Input: (Machine ID)  \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3d\", i);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Output: (Abstract ID)\");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3u\", (*block_map_inv)[i]);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Physical Socket ID:  \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3u\", cpuinfo[i].physid);\n\t\t}\n\t\tdebug3(\"\");\n\t}\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [
      "#define _DEBUG 0"
    ],
    "globals_used": [
      "uint16_t *block_map, *block_map_inv;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"\""
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%3u\"",
            "cpuinfo[i].physid"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Physical Socket ID:  \""
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"\""
          ],
          "line": 935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%3u\"",
            "(*block_map_inv)[i]"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Output: (Abstract ID)\""
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"\""
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%3d\"",
            "i"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Input: (Machine ID)  \""
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"\\nMachine -> Abstract logical CPU ID block mapping: \"\n\t\t\t\"(inverse)\""
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"\""
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%3u\"",
            "cpuinfo[id].physid"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Physical Socket ID:  \""
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"\""
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%3u\"",
            "(*block_map)[i]"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Output: (Machine ID) \""
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"\""
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%3d\"",
            "i"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Input: (Abstract ID) \""
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"\\nAbstract -> Machine logical CPU ID block mapping:\""
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"\""
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%3u\"",
            "cpuinfo[i].physid"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Physical Socket ID:  \""
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"\""
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"%3d\"",
            "i"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Logical CPU ID:      \""
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"\\nMachine logical CPU ID assignment:\""
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "numproc * sizeof(uint16_t)"
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "qsort",
          "args": [
            "*block_map",
            "numproc",
            "sizeof(uint16_t)",
            "&_compare_cpus"
          ],
          "line": 879
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "numproc * sizeof(uint16_t)"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\n#define _DEBUG 0\n\nuint16_t *block_map, *block_map_inv;\n\nstatic int _compute_block_map(uint16_t numproc,\n\t\t\t      uint16_t **block_map, uint16_t **block_map_inv)\n{\n\tuint16_t i;\n\t/* Compute abstract->machine block mapping (and inverse) */\n\tif (block_map) {\n\t\t*block_map = xmalloc(numproc * sizeof(uint16_t));\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\t(*block_map)[i] = i;\n\t\t}\n\t\tqsort(*block_map, numproc, sizeof(uint16_t), &_compare_cpus);\n\t}\n\tif (block_map && block_map_inv) {\n\t\t*block_map_inv = xmalloc(numproc * sizeof(uint16_t));\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tuint16_t idx = (*block_map)[i];\n\t\t\t(*block_map_inv)[idx] = i;\n\t\t}\n\t}\n#if _DEBUG\n\t/* Display the mapping tables */\n\n\tdebug3(\"\\nMachine logical CPU ID assignment:\");\n\tdebug3(\"Logical CPU ID:      \");\n\tfor (i = 0; i < numproc; i++) {\n\t\tdebug3(\"%3d\", i);\n\t}\n\tdebug3(\"\");\n\tdebug3(\"Physical Socket ID:  \");\n\tfor (i = 0; i < numproc; i++) {\n\t\tdebug3(\"%3u\", cpuinfo[i].physid);\n\t}\n\tdebug3(\"\");\n\n\tif (block_map) {\n\t\tdebug3(\"\\nAbstract -> Machine logical CPU ID block mapping:\");\n\t\tdebug3(\"Input: (Abstract ID) \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3d\", i);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Output: (Machine ID) \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3u\", (*block_map)[i]);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Physical Socket ID:  \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tuint16_t id = (*block_map)[i];\n\t\t\tdebug3(\"%3u\", cpuinfo[id].physid);\n\t\t}\n\t\tdebug3(\"\");\n\t}\n\n\tif (block_map_inv) {\n\t\tdebug3(\"\\nMachine -> Abstract logical CPU ID block mapping: \"\n\t\t\t\"(inverse)\");\n\t\tdebug3(\"Input: (Machine ID)  \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3d\", i);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Output: (Abstract ID)\");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3u\", (*block_map_inv)[i]);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Physical Socket ID:  \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3u\", cpuinfo[i].physid);\n\t\t}\n\t\tdebug3(\"\");\n\t}\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "_compare_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "848-867",
    "snippet": "static int _compare_cpus(const void *a1, const void *b1) {\n\tuint16_t *a = (uint16_t *) a1;\n\tuint16_t *b = (uint16_t *) b1;\n\tint cmp;\n\n\tcmp = -1 * _icmp16(cpuinfo[*a].seen,cpuinfo[*b].seen); /* seen to front */\n\tif (cmp != 0)\n\t\treturn cmp;\n\n\tcmp = _icmp32(cpuinfo[*a].physid, cpuinfo[*b].physid); /* key 1: physid */\n\tif (cmp != 0)\n\t\treturn cmp;\n\n\tcmp = _icmp32(cpuinfo[*a].coreid, cpuinfo[*b].coreid); /* key 2: coreid */\n\tif (cmp != 0)\n\t\treturn cmp;\n\n\tcmp = _icmp32(cpuinfo[*a].cpuid, cpuinfo[*b].cpuid);   /* key 3: cpu id */\n\treturn cmp;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_icmp32",
          "args": [
            "cpuinfo[*a].cpuid",
            "cpuinfo[*b].cpuid"
          ],
          "line": 865
        },
        "resolved": true,
        "details": {
          "function_name": "_icmp32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "837-846",
          "snippet": "static int _icmp32(uint32_t a, uint32_t b)\n{\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a == b) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _icmp32(uint32_t a, uint32_t b)\n{\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a == b) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_icmp16",
          "args": [
            "cpuinfo[*a].seen",
            "cpuinfo[*b].seen"
          ],
          "line": 853
        },
        "resolved": true,
        "details": {
          "function_name": "_icmp16",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "827-836",
          "snippet": "static int _icmp16(uint16_t a, uint16_t b)\n{\n    \tif (a < b) {\n\t\treturn -1;\n\t} else if (a == b) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _icmp16(uint16_t a, uint16_t b)\n{\n    \tif (a < b) {\n\t\treturn -1;\n\t} else if (a == b) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _compare_cpus(const void *a1, const void *b1) {\n\tuint16_t *a = (uint16_t *) a1;\n\tuint16_t *b = (uint16_t *) b1;\n\tint cmp;\n\n\tcmp = -1 * _icmp16(cpuinfo[*a].seen,cpuinfo[*b].seen); /* seen to front */\n\tif (cmp != 0)\n\t\treturn cmp;\n\n\tcmp = _icmp32(cpuinfo[*a].physid, cpuinfo[*b].physid); /* key 1: physid */\n\tif (cmp != 0)\n\t\treturn cmp;\n\n\tcmp = _icmp32(cpuinfo[*a].coreid, cpuinfo[*b].coreid); /* key 2: coreid */\n\tif (cmp != 0)\n\t\treturn cmp;\n\n\tcmp = _icmp32(cpuinfo[*a].cpuid, cpuinfo[*b].cpuid);   /* key 3: cpu id */\n\treturn cmp;\n}"
  },
  {
    "function_name": "_icmp32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "837-846",
    "snippet": "static int _icmp32(uint32_t a, uint32_t b)\n{\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a == b) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _icmp32(uint32_t a, uint32_t b)\n{\n\tif (a < b) {\n\t\treturn -1;\n\t} else if (a == b) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "_icmp16",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "827-836",
    "snippet": "static int _icmp16(uint16_t a, uint16_t b)\n{\n    \tif (a < b) {\n\t\treturn -1;\n\t} else if (a == b) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _icmp16(uint16_t a, uint16_t b)\n{\n    \tif (a < b) {\n\t\treturn -1;\n\t} else if (a == b) {\n\t\treturn 0;\n\t} else {\n\t\treturn 1;\n\t}\n}"
  },
  {
    "function_name": "_chk_cpuinfo_uint32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "775-784",
    "snippet": "static int _chk_cpuinfo_uint32(char *buffer, char *keyword, uint32_t *val)\n{\n\tchar *valptr;\n\tif (_chk_cpuinfo_str(buffer, keyword, &valptr)) {\n\t\t*val = strtoul(valptr, (char **)NULL, 10);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "valptr",
            "(char **)NULL",
            "10"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_chk_cpuinfo_str",
          "args": [
            "buffer",
            "keyword",
            "&valptr"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "_chk_cpuinfo_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "754-765",
          "snippet": "static int _chk_cpuinfo_str(char *buffer, char *keyword, char **valptr)\n{\n\tchar *ptr;\n\tif (xstrncmp(buffer, keyword, strlen(keyword)))\n\t\treturn false;\n\n\tptr = strstr(buffer, \":\");\n\tif (ptr != NULL)\n\t\tptr++;\n\t*valptr = ptr;\n\treturn true;\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _chk_cpuinfo_str(char *buffer, char *keyword, char **valptr)\n{\n\tchar *ptr;\n\tif (xstrncmp(buffer, keyword, strlen(keyword)))\n\t\treturn false;\n\n\tptr = strstr(buffer, \":\");\n\tif (ptr != NULL)\n\t\tptr++;\n\t*valptr = ptr;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _chk_cpuinfo_uint32(char *buffer, char *keyword, uint32_t *val)\n{\n\tchar *valptr;\n\tif (_chk_cpuinfo_str(buffer, keyword, &valptr)) {\n\t\t*val = strtoul(valptr, (char **)NULL, 10);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "_chk_cpuinfo_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "754-765",
    "snippet": "static int _chk_cpuinfo_str(char *buffer, char *keyword, char **valptr)\n{\n\tchar *ptr;\n\tif (xstrncmp(buffer, keyword, strlen(keyword)))\n\t\treturn false;\n\n\tptr = strstr(buffer, \":\");\n\tif (ptr != NULL)\n\t\tptr++;\n\t*valptr = ptr;\n\treturn true;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "buffer",
            "\":\""
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrncmp",
          "args": [
            "buffer",
            "keyword",
            "strlen(keyword)"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "keyword"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _chk_cpuinfo_str(char *buffer, char *keyword, char **valptr)\n{\n\tchar *ptr;\n\tif (xstrncmp(buffer, keyword, strlen(keyword)))\n\t\treturn false;\n\n\tptr = strstr(buffer, \":\");\n\tif (ptr != NULL)\n\t\tptr++;\n\t*valptr = ptr;\n\treturn true;\n}"
  },
  {
    "function_name": "get_cpuinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "438-744",
    "snippet": "extern int\nget_cpuinfo(uint16_t *p_cpus, uint16_t *p_boards,\n\t    uint16_t *p_sockets, uint16_t *p_cores, uint16_t *p_threads,\n\t    uint16_t *p_block_map_size,\n\t    uint16_t **p_block_map, uint16_t **p_block_map_inv)\n{\n\tint retval;\n\n\tuint16_t numproc;\n\tuint16_t numcpu\t   = 0;\t\t/* number of cpus seen */\n\tuint16_t numphys   = 0;\t\t/* number of unique \"physical id\"s */\n\tuint16_t numcores  = 0;\t\t/* number of unique \"cores id\"s */\n\n\tuint16_t maxsibs   = 0;\t\t/* maximum value of \"siblings\" */\n\tuint16_t maxcores  = 0;\t\t/* maximum value of \"cores\" */\n\tuint16_t minsibs   = 0xffff;\t/* minimum value of \"siblings\" */\n\tuint16_t mincores  = 0xffff;\t/* minimum value of \"cores\" */\n\n\tuint32_t maxcpuid  = 0;\t\t/* maximum CPU ID (\"processor\") */\n\tuint32_t maxphysid = 0;\t\t/* maximum \"physical id\" */\n\tuint32_t maxcoreid = 0;\t\t/* maximum \"core id\" */\n\tuint32_t mincpuid  = 0xffffffff;/* minimum CPU ID (\"processor\") */\n\tuint32_t minphysid = 0xffffffff;/* minimum \"physical id\" */\n\tuint32_t mincoreid = 0xffffffff;/* minimum \"core id\" */\n\tint i;\n#if defined (__sun)\n#if defined (_LP64)\n\tint64_t curcpu, val, sockets, cores, threads;\n#else\n\tint32_t curcpu, val, sockets, cores, threads;\n#endif\n\tint32_t chip_id, core_id, ncore_per_chip, ncpu_per_chip;\n#else\n\tFILE *cpu_info_file;\n\tchar buffer[128];\n\tuint16_t curcpu, sockets, cores, threads;\n#endif\n\n\tget_procs(&numproc);\n\t*p_cpus = numproc;\n\t*p_boards = 1;\t\t/* Boards not identified from /proc/cpuinfo */\n\t*p_sockets = numproc;\t/* initially all single core/thread */\n\t*p_cores   = 1;\n\t*p_threads = 1;\n\t*p_block_map_size = 0;\n\t*p_block_map      = NULL;\n\t*p_block_map_inv  = NULL;\n\n#if defined (__sun)\n\tkstat_ctl_t   *kc;\n\tkstat_t       *ksp;\n\tkstat_named_t *knp;\n\n\tkc = kstat_open();\n\tif (kc == NULL) {\n\t\terror (\"get speed: kstat error %d\", errno);\n\t\treturn errno;\n\t}\n#else\n\tcpu_info_file = fopen(_cpuinfo_path, \"r\");\n\tif (cpu_info_file == NULL) {\n\t\terror (\"get_cpuinfo: error %d opening %s\",\n\t\t\terrno, _cpuinfo_path);\n\t\treturn errno;\n\t}\n#endif\n\n\t/* Note: assumes all processor IDs are within [0:numproc-1] */\n\t/*       treats physical/core IDs as tokens, not indices */\n\tif (cpuinfo)\n\t\tmemset(cpuinfo, 0, numproc * sizeof(cpuinfo_t));\n\telse\n\t\tcpuinfo = xmalloc(numproc * sizeof(cpuinfo_t));\n\n#if defined (__sun)\n\tksp = kstat_lookup(kc, \"cpu_info\", -1, NULL);\n\tfor (; ksp != NULL; ksp = ksp->ks_next) {\n\t\tif (xstrcmp(ksp->ks_module, \"cpu_info\"))\n\t\t\tcontinue;\n\n\t\tnumcpu++;\n\t\tkstat_read(kc, ksp, NULL);\n\n\t\tknp = kstat_data_lookup(ksp, \"chip_id\");\n\t\tchip_id = knp->value.l;\n\t\tknp = kstat_data_lookup(ksp, \"core_id\");\n\t\tcore_id = knp->value.l;\n\t\tknp = kstat_data_lookup(ksp, \"ncore_per_chip\");\n\t\tncore_per_chip = knp->value.l;\n\t\tknp = kstat_data_lookup(ksp, \"ncpu_per_chip\");\n\t\tncpu_per_chip = knp->value.l;\n\n\t\tif (chip_id >= numproc) {\n\t\t\tdebug(\"cpuid is %ld (> %d), ignored\", curcpu, numproc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcpuinfo[chip_id].seen = 1;\n\t\tcpuinfo[chip_id].cpuid = chip_id;\n\n\t\tmaxcpuid = MAX(maxcpuid, chip_id);\n\t\tmincpuid = MIN(mincpuid, chip_id);\n\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tif ((cpuinfo[i].coreid == core_id) &&\n\t\t\t    (cpuinfo[i].corecnt))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == numproc) {\n\t\t\tnumcores++;\n\t\t} else {\n\t\t\tcpuinfo[i].corecnt++;\n\t\t}\n\n\t\tif (chip_id < numproc) {\n\t\t\tcpuinfo[chip_id].corecnt++;\n\t\t\tcpuinfo[chip_id].coreid = core_id;\n\t\t}\n\n\t\tmaxcoreid = MAX(maxcoreid, core_id);\n\t\tmincoreid = MIN(mincoreid, core_id);\n\n\t\tif (ncore_per_chip > numproc) {\n\t\t\tdebug(\"cores is %u (> %d), ignored\",\n\t\t\t      ncore_per_chip, numproc);\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (chip_id < numproc)\n\t\t\tcpuinfo[chip_id].cores = ncore_per_chip;\n\n\t\tmaxcores = MAX(maxcores, ncore_per_chip);\n\t\tmincores = MIN(mincores, ncore_per_chip);\n\t}\n#else\n\n\tcurcpu = 0;\n\twhile (fgets(buffer, sizeof(buffer), cpu_info_file) != NULL) {\n\t\tuint32_t val;\n\t\tif (_chk_cpuinfo_uint32(buffer, \"processor\", &val)) {\n\t\t\tcurcpu = numcpu;\n\t\t\tnumcpu++;\n\t\t\tif (curcpu >= numproc) {\n\t\t\t\tinfo(\"processor limit reached (%u >= %d)\",\n\t\t\t\t     curcpu, numproc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcpuinfo[curcpu].seen = 1;\n\t\t\tcpuinfo[curcpu].cpuid = val;\n\t\t\tmaxcpuid = MAX(maxcpuid, val);\n\t\t\tmincpuid = MIN(mincpuid, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"physical id\", &val)) {\n\t\t\t/* see if the ID has already been seen */\n\t\t\tfor (i=0; i<numproc; i++) {\n\t\t\t\tif ((cpuinfo[i].physid == val)\n\t\t\t\t&&  (cpuinfo[i].physcnt))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == numproc) {\t\t/* new ID... */\n\t\t\t\tnumphys++;\t\t/* ...increment total */\n\t\t\t} else {\t\t\t/* existing ID... */\n\t\t\t\tcpuinfo[i].physcnt++;\t/* ...update ID cnt */\n\t\t\t}\n\n\t\t\tif (curcpu < numproc) {\n\t\t\t\tcpuinfo[curcpu].physcnt++;\n\t\t\t\tcpuinfo[curcpu].physid = val;\n\t\t\t}\n\n\t\t\tmaxphysid = MAX(maxphysid, val);\n\t\t\tminphysid = MIN(minphysid, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"core id\", &val)) {\n\t\t\t/* see if the ID has already been seen */\n\t\t\tfor (i = 0; i < numproc; i++) {\n\t\t\t\tif ((cpuinfo[i].coreid == val)\n\t\t\t\t&&  (cpuinfo[i].corecnt))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == numproc) {\t\t/* new ID... */\n\t\t\t\tnumcores++;\t\t/* ...increment total */\n\t\t\t} else {\t\t\t/* existing ID... */\n\t\t\t\tcpuinfo[i].corecnt++;\t/* ...update ID cnt */\n\t\t\t}\n\n\t\t\tif (curcpu < numproc) {\n\t\t\t\tcpuinfo[curcpu].corecnt++;\n\t\t\t\tcpuinfo[curcpu].coreid = val;\n\t\t\t}\n\n\t\t\tmaxcoreid = MAX(maxcoreid, val);\n\t\t\tmincoreid = MIN(mincoreid, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"siblings\", &val)) {\n\t\t\t/* Note: this value is a count, not an index */\n\t\t    \tif (val > numproc) {\t/* out of bounds, ignore */\n\t\t\t\tdebug(\"siblings is %u (> %d), ignored\",\n\t\t\t\t\tval, numproc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (curcpu < numproc)\n\t\t\t\tcpuinfo[curcpu].siblings = val;\n\t\t\tmaxsibs = MAX(maxsibs, val);\n\t\t\tminsibs = MIN(minsibs, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"cpu cores\", &val)) {\n\t\t\t/* Note: this value is a count, not an index */\n\t\t    \tif (val > numproc) {\t/* out of bounds, ignore */\n\t\t\t\tdebug(\"cores is %u (> %d), ignored\",\n\t\t\t\t\tval, numproc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (curcpu < numproc)\n\t\t\t\tcpuinfo[curcpu].cores = val;\n\t\t\tmaxcores = MAX(maxcores, val);\n\t\t\tmincores = MIN(mincores, val);\n\t\t}\n\t}\n\n\tfclose(cpu_info_file);\n#endif\n\n\t/*** Sanity check ***/\n\tif (minsibs == 0) minsibs = 1;\t\t/* guaranteee non-zero */\n\tif (maxsibs == 0) {\n\t    \tminsibs = 1;\n\t    \tmaxsibs = 1;\n\t}\n\tif (maxcores == 0) {\t\t\t/* no core data */\n\t    \tmincores = 0;\n\t    \tmaxcores = 0;\n\t}\n\n\t/*** Compute Sockets/Cores/Threads ***/\n\tif ((minsibs == maxsibs) &&\t\t/* homogeneous system */\n\t    (mincores == maxcores)) {\n\t\tsockets = numphys; \t\t/* unique \"physical id\" */\n\t\tif (sockets <= 1) {\t\t/* verify single socket */\n\t\t\tsockets = numcpu / maxsibs; /* maximum \"siblings\" */\n\t\t}\n\t\tif (sockets == 0)\n\t\t\tsockets = 1;\t\t/* guarantee non-zero */\n\n\t\tcores = numcores / sockets;\t/* unique \"core id\" */\n\t\tcores = MAX(maxcores, cores);\t/* maximum \"cpu cores\" */\n\n\t\tif (cores == 0) {\n\t\t\tcores = numcpu / sockets;\t/* assume multi-core */\n\t\t\tif (cores > 1) {\n\t\t\t\tdebug3(\"Warning: cpuinfo missing 'core id' or \"\n\t\t\t\t\t\"'cpu cores' but assuming multi-core\");\n\t\t\t}\n\t\t}\n\t\tif (cores == 0)\n\t\t\tcores = 1;\t/* guarantee non-zero */\n\n\t\tthreads = numcpu / (sockets * cores); /* solve for threads */\n\t\tif (threads == 0)\n\t\t\tthreads = 1;\t/* guarantee non-zero */\n\t} else {\t\t\t\t/* heterogeneous system */\n\t\tsockets = numcpu;\n\t\tcores   = 1;\t\t\t/* one core per socket */\n\t\tthreads = 1;\t\t\t/* one core per core */\n\t}\n\n\t*p_sockets = sockets;\t\t/* update output parameters */\n\t*p_cores   = cores;\n\t*p_threads = threads;\n\n#if _DEBUG\n\t/*** Display raw data ***/\n\tdebug3(\"numcpu:     %u\", numcpu);\n\tdebug3(\"numphys:    %u\", numphys);\n\tdebug3(\"numcores:   %u\", numcores);\n\n\tdebug3(\"cores:      %u->%u\", mincores, maxcores);\n\tdebug3(\"sibs:       %u->%u\", minsibs,  maxsibs);\n\n\tdebug3(\"cpuid:      %u->%u\", mincpuid,  maxcpuid);\n\tdebug3(\"physid:     %u->%u\", minphysid, maxphysid);\n\tdebug3(\"coreid:     %u->%u\", mincoreid, maxcoreid);\n\n\tfor (i = 0; i < numproc; i++) {\n\t\tdebug3(\"CPU %d:\", i);\n\t\tdebug3(\" cpuid:    %u\", cpuinfo[i].cpuid);\n\t\tdebug3(\" seen:     %u\", cpuinfo[i].seen);\n\t\tdebug3(\" physid:   %u\", cpuinfo[i].physid);\n\t\tdebug3(\" physcnt:  %u\", cpuinfo[i].physcnt);\n\t\tdebug3(\" siblings: %u\", cpuinfo[i].siblings);\n\t\tdebug3(\" cores:    %u\", cpuinfo[i].cores);\n\t\tdebug3(\" coreid:   %u\", cpuinfo[i].coreid);\n\t\tdebug3(\" corecnt:  %u\\n\", cpuinfo[i].corecnt);\n\t}\n\n\tdebug3(\"Sockets:          %u\", sockets);\n\tdebug3(\"Cores per socket: %u\", cores);\n\tdebug3(\"Threads per core: %u\", threads);\n#endif\n\n\t*p_block_map_size = numcpu;\n\tretval = _compute_block_map(*p_block_map_size, p_block_map,\n\t\t\t\t    p_block_map_inv);\n\n\txfree(cpuinfo);\t\t/* done with raw cpuinfo data */\n\n\treturn retval;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [
      "#define _DEBUG 0"
    ],
    "globals_used": [
      "uint16_t procs, boards, sockets, cores, threads=1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "cpuinfo"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_compute_block_map",
          "args": [
            "*p_block_map_size",
            "p_block_map",
            "p_block_map_inv"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "_compute_block_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "869-944",
          "snippet": "static int _compute_block_map(uint16_t numproc,\n\t\t\t      uint16_t **block_map, uint16_t **block_map_inv)\n{\n\tuint16_t i;\n\t/* Compute abstract->machine block mapping (and inverse) */\n\tif (block_map) {\n\t\t*block_map = xmalloc(numproc * sizeof(uint16_t));\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\t(*block_map)[i] = i;\n\t\t}\n\t\tqsort(*block_map, numproc, sizeof(uint16_t), &_compare_cpus);\n\t}\n\tif (block_map && block_map_inv) {\n\t\t*block_map_inv = xmalloc(numproc * sizeof(uint16_t));\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tuint16_t idx = (*block_map)[i];\n\t\t\t(*block_map_inv)[idx] = i;\n\t\t}\n\t}\n#if _DEBUG\n\t/* Display the mapping tables */\n\n\tdebug3(\"\\nMachine logical CPU ID assignment:\");\n\tdebug3(\"Logical CPU ID:      \");\n\tfor (i = 0; i < numproc; i++) {\n\t\tdebug3(\"%3d\", i);\n\t}\n\tdebug3(\"\");\n\tdebug3(\"Physical Socket ID:  \");\n\tfor (i = 0; i < numproc; i++) {\n\t\tdebug3(\"%3u\", cpuinfo[i].physid);\n\t}\n\tdebug3(\"\");\n\n\tif (block_map) {\n\t\tdebug3(\"\\nAbstract -> Machine logical CPU ID block mapping:\");\n\t\tdebug3(\"Input: (Abstract ID) \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3d\", i);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Output: (Machine ID) \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3u\", (*block_map)[i]);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Physical Socket ID:  \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tuint16_t id = (*block_map)[i];\n\t\t\tdebug3(\"%3u\", cpuinfo[id].physid);\n\t\t}\n\t\tdebug3(\"\");\n\t}\n\n\tif (block_map_inv) {\n\t\tdebug3(\"\\nMachine -> Abstract logical CPU ID block mapping: \"\n\t\t\t\"(inverse)\");\n\t\tdebug3(\"Input: (Machine ID)  \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3d\", i);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Output: (Abstract ID)\");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3u\", (*block_map_inv)[i]);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Physical Socket ID:  \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3u\", cpuinfo[i].physid);\n\t\t}\n\t\tdebug3(\"\");\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [
            "#define _DEBUG 0"
          ],
          "globals_used": [
            "uint16_t *block_map, *block_map_inv;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\n#define _DEBUG 0\n\nuint16_t *block_map, *block_map_inv;\n\nstatic int _compute_block_map(uint16_t numproc,\n\t\t\t      uint16_t **block_map, uint16_t **block_map_inv)\n{\n\tuint16_t i;\n\t/* Compute abstract->machine block mapping (and inverse) */\n\tif (block_map) {\n\t\t*block_map = xmalloc(numproc * sizeof(uint16_t));\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\t(*block_map)[i] = i;\n\t\t}\n\t\tqsort(*block_map, numproc, sizeof(uint16_t), &_compare_cpus);\n\t}\n\tif (block_map && block_map_inv) {\n\t\t*block_map_inv = xmalloc(numproc * sizeof(uint16_t));\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tuint16_t idx = (*block_map)[i];\n\t\t\t(*block_map_inv)[idx] = i;\n\t\t}\n\t}\n#if _DEBUG\n\t/* Display the mapping tables */\n\n\tdebug3(\"\\nMachine logical CPU ID assignment:\");\n\tdebug3(\"Logical CPU ID:      \");\n\tfor (i = 0; i < numproc; i++) {\n\t\tdebug3(\"%3d\", i);\n\t}\n\tdebug3(\"\");\n\tdebug3(\"Physical Socket ID:  \");\n\tfor (i = 0; i < numproc; i++) {\n\t\tdebug3(\"%3u\", cpuinfo[i].physid);\n\t}\n\tdebug3(\"\");\n\n\tif (block_map) {\n\t\tdebug3(\"\\nAbstract -> Machine logical CPU ID block mapping:\");\n\t\tdebug3(\"Input: (Abstract ID) \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3d\", i);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Output: (Machine ID) \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3u\", (*block_map)[i]);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Physical Socket ID:  \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tuint16_t id = (*block_map)[i];\n\t\t\tdebug3(\"%3u\", cpuinfo[id].physid);\n\t\t}\n\t\tdebug3(\"\");\n\t}\n\n\tif (block_map_inv) {\n\t\tdebug3(\"\\nMachine -> Abstract logical CPU ID block mapping: \"\n\t\t\t\"(inverse)\");\n\t\tdebug3(\"Input: (Machine ID)  \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3d\", i);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Output: (Abstract ID)\");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3u\", (*block_map_inv)[i]);\n\t\t}\n\t\tdebug3(\"\");\n\t\tdebug3(\"Physical Socket ID:  \");\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tdebug3(\"%3u\", cpuinfo[i].physid);\n\t\t}\n\t\tdebug3(\"\");\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Threads per core: %u\"",
            "threads"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Cores per socket: %u\"",
            "cores"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Sockets:          %u\"",
            "sockets"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\" corecnt:  %u\\n\"",
            "cpuinfo[i].corecnt"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\" coreid:   %u\"",
            "cpuinfo[i].coreid"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\" cores:    %u\"",
            "cpuinfo[i].cores"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\" siblings: %u\"",
            "cpuinfo[i].siblings"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\" physcnt:  %u\"",
            "cpuinfo[i].physcnt"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\" physid:   %u\"",
            "cpuinfo[i].physid"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\" seen:     %u\"",
            "cpuinfo[i].seen"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\" cpuid:    %u\"",
            "cpuinfo[i].cpuid"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"CPU %d:\"",
            "i"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"coreid:     %u->%u\"",
            "mincoreid",
            "maxcoreid"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"physid:     %u->%u\"",
            "minphysid",
            "maxphysid"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"cpuid:      %u->%u\"",
            "mincpuid",
            "maxcpuid"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"sibs:       %u->%u\"",
            "minsibs",
            "maxsibs"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"cores:      %u->%u\"",
            "mincores",
            "maxcores"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"numcores:   %u\"",
            "numcores"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"numphys:    %u\"",
            "numphys"
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"numcpu:     %u\"",
            "numcpu"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Warning: cpuinfo missing 'core id' or \"\n\t\t\t\t\t\"'cpu cores' but assuming multi-core\""
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "maxcores",
            "cores"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "cpu_info_file"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "mincores",
            "val"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "maxcores",
            "val"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"cores is %u (> %d), ignored\"",
            "val",
            "numproc"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_chk_cpuinfo_uint32",
          "args": [
            "buffer",
            "\"cpu cores\"",
            "&val"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "_chk_cpuinfo_uint32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "775-784",
          "snippet": "static int _chk_cpuinfo_uint32(char *buffer, char *keyword, uint32_t *val)\n{\n\tchar *valptr;\n\tif (_chk_cpuinfo_str(buffer, keyword, &valptr)) {\n\t\t*val = strtoul(valptr, (char **)NULL, 10);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _chk_cpuinfo_uint32(char *buffer, char *keyword, uint32_t *val)\n{\n\tchar *valptr;\n\tif (_chk_cpuinfo_str(buffer, keyword, &valptr)) {\n\t\t*val = strtoul(valptr, (char **)NULL, 10);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "minsibs",
            "val"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "maxsibs",
            "val"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"siblings is %u (> %d), ignored\"",
            "val",
            "numproc"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "mincoreid",
            "val"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "maxcoreid",
            "val"
          ],
          "line": 630
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "minphysid",
            "val"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "maxphysid",
            "val"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "mincpuid",
            "val"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "maxcpuid",
            "val"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info",
          "args": [
            "\"processor limit reached (%u >= %d)\"",
            "curcpu",
            "numproc"
          ],
          "line": 582
        },
        "resolved": true,
        "details": {
          "function_name": "xcpuinfo_mac_to_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "1068-1075",
          "snippet": "int\nxcpuinfo_mac_to_map(char* lrange,uint16_t **map,uint16_t *map_size)\n{\n\t*map_size = block_map_size;\n\t*map = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\t/* machine range already includes the hyperthreads */\n\treturn _range_to_map(lrange,*map,*map_size,0);\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "uint16_t block_map_size;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nuint16_t block_map_size;\n\nint\nxcpuinfo_mac_to_map(char* lrange,uint16_t **map,uint16_t *map_size)\n{\n\t*map_size = block_map_size;\n\t*map = (uint16_t*) xmalloc(block_map_size*sizeof(uint16_t));\n\t/* machine range already includes the hyperthreads */\n\treturn _range_to_map(lrange,*map,*map_size,0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buffer",
            "sizeof(buffer)",
            "cpu_info_file"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "mincores",
            "ncore_per_chip"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "maxcores",
            "ncore_per_chip"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"cores is %u (> %d), ignored\"",
            "ncore_per_chip",
            "numproc"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "mincoreid",
            "core_id"
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "maxcoreid",
            "core_id"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MIN",
          "args": [
            "mincpuid",
            "chip_id"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "maxcpuid",
            "chip_id"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"cpuid is %ld (> %d), ignored\"",
            "curcpu",
            "numproc"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstat_data_lookup",
          "args": [
            "ksp",
            "\"ncpu_per_chip\""
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstat_data_lookup",
          "args": [
            "ksp",
            "\"ncore_per_chip\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstat_data_lookup",
          "args": [
            "ksp",
            "\"core_id\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstat_data_lookup",
          "args": [
            "ksp",
            "\"chip_id\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstat_read",
          "args": [
            "kc",
            "ksp",
            "NULL"
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "ksp->ks_module",
            "\"cpu_info\""
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstat_lookup",
          "args": [
            "kc",
            "\"cpu_info\"",
            "-1",
            "NULL"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "numproc * sizeof(cpuinfo_t)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cpuinfo",
            "0",
            "numproc * sizeof(cpuinfo_t)"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"get_cpuinfo: error %d opening %s\"",
            "errno",
            "_cpuinfo_path"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "_cpuinfo_path",
            "\"r\""
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"get speed: kstat error %d\"",
            "errno"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "_task_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "641-650",
          "snippet": "static int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static bool _task_writable(eio_obj_t *);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int _task_write_error(eio_obj_t *obj, List objs);",
            "static bool _task_readable(eio_obj_t *);",
            "static int  _task_read(eio_obj_t *, List);",
            "static void _route_msg_task_to_client(eio_obj_t *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstat_open",
          "args": [],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_procs",
          "args": [
            "&numproc"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "get_procs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "105-150",
          "snippet": "extern int\nget_procs(uint16_t *procs)\n{\n#ifdef LPAR_INFO_FORMAT2\n\t/* AIX 5.3 only */\n\tlpar_info_format2_t info;\n\n\t*procs = 1;\n\tif (lpar_get_info(LPAR_INFO_FORMAT2, &info, sizeof(info)) != 0) {\n\t\terror(\"lpar_get_info() failed\");\n\t\treturn EINVAL;\n\t}\n\n\t*procs = (uint16_t) info.online_vcpus;\n#else /* !LPAR_INFO_FORMAT2 */\n\n#  ifdef _SC_NPROCESSORS_ONLN\n\tint my_proc_tally;\n\n\t*procs = 1;\n\tmy_proc_tally = (int)sysconf(_SC_NPROCESSORS_ONLN);\n\tif (my_proc_tally < 1) {\n\t\terror (\"get_procs: error running sysconf(_SC_NPROCESSORS_ONLN)\");\n\t\treturn EINVAL;\n\t}\n\n\t*procs = (uint16_t) my_proc_tally;\n#  else\n#    ifdef HAVE_SYSCTLBYNAME\n\tint ncpu;\n\tsize_t len = sizeof(ncpu);\n\n\t*procs = 1;\n\tif (sysctlbyname(\"hw.ncpus\", &ncpu, &len, NULL, 0) == -1) {\n\t\terror(\"get_procs: error running sysctl(HW_NCPU)\");\n\t\treturn EINVAL;\n\t}\n\t*procs = (uint16_t) ncpu;\n#    else /* !HAVE_SYSCTLBYNAME */\n\t*procs = 1;\n#    endif /* HAVE_SYSCTLBYNAME */\n#  endif /* _SC_NPROCESSORS_ONLN */\n#endif /* LPAR_INFO_FORMAT2 */\n\n\treturn 0;\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nextern int\nget_procs(uint16_t *procs)\n{\n#ifdef LPAR_INFO_FORMAT2\n\t/* AIX 5.3 only */\n\tlpar_info_format2_t info;\n\n\t*procs = 1;\n\tif (lpar_get_info(LPAR_INFO_FORMAT2, &info, sizeof(info)) != 0) {\n\t\terror(\"lpar_get_info() failed\");\n\t\treturn EINVAL;\n\t}\n\n\t*procs = (uint16_t) info.online_vcpus;\n#else /* !LPAR_INFO_FORMAT2 */\n\n#  ifdef _SC_NPROCESSORS_ONLN\n\tint my_proc_tally;\n\n\t*procs = 1;\n\tmy_proc_tally = (int)sysconf(_SC_NPROCESSORS_ONLN);\n\tif (my_proc_tally < 1) {\n\t\terror (\"get_procs: error running sysconf(_SC_NPROCESSORS_ONLN)\");\n\t\treturn EINVAL;\n\t}\n\n\t*procs = (uint16_t) my_proc_tally;\n#  else\n#    ifdef HAVE_SYSCTLBYNAME\n\tint ncpu;\n\tsize_t len = sizeof(ncpu);\n\n\t*procs = 1;\n\tif (sysctlbyname(\"hw.ncpus\", &ncpu, &len, NULL, 0) == -1) {\n\t\terror(\"get_procs: error running sysctl(HW_NCPU)\");\n\t\treturn EINVAL;\n\t}\n\t*procs = (uint16_t) ncpu;\n#    else /* !HAVE_SYSCTLBYNAME */\n\t*procs = 1;\n#    endif /* HAVE_SYSCTLBYNAME */\n#  endif /* _SC_NPROCESSORS_ONLN */\n#endif /* LPAR_INFO_FORMAT2 */\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\n#define _DEBUG 0\n\nuint16_t procs, boards, sockets, cores, threads=1;\n\nextern int\nget_cpuinfo(uint16_t *p_cpus, uint16_t *p_boards,\n\t    uint16_t *p_sockets, uint16_t *p_cores, uint16_t *p_threads,\n\t    uint16_t *p_block_map_size,\n\t    uint16_t **p_block_map, uint16_t **p_block_map_inv)\n{\n\tint retval;\n\n\tuint16_t numproc;\n\tuint16_t numcpu\t   = 0;\t\t/* number of cpus seen */\n\tuint16_t numphys   = 0;\t\t/* number of unique \"physical id\"s */\n\tuint16_t numcores  = 0;\t\t/* number of unique \"cores id\"s */\n\n\tuint16_t maxsibs   = 0;\t\t/* maximum value of \"siblings\" */\n\tuint16_t maxcores  = 0;\t\t/* maximum value of \"cores\" */\n\tuint16_t minsibs   = 0xffff;\t/* minimum value of \"siblings\" */\n\tuint16_t mincores  = 0xffff;\t/* minimum value of \"cores\" */\n\n\tuint32_t maxcpuid  = 0;\t\t/* maximum CPU ID (\"processor\") */\n\tuint32_t maxphysid = 0;\t\t/* maximum \"physical id\" */\n\tuint32_t maxcoreid = 0;\t\t/* maximum \"core id\" */\n\tuint32_t mincpuid  = 0xffffffff;/* minimum CPU ID (\"processor\") */\n\tuint32_t minphysid = 0xffffffff;/* minimum \"physical id\" */\n\tuint32_t mincoreid = 0xffffffff;/* minimum \"core id\" */\n\tint i;\n#if defined (__sun)\n#if defined (_LP64)\n\tint64_t curcpu, val, sockets, cores, threads;\n#else\n\tint32_t curcpu, val, sockets, cores, threads;\n#endif\n\tint32_t chip_id, core_id, ncore_per_chip, ncpu_per_chip;\n#else\n\tFILE *cpu_info_file;\n\tchar buffer[128];\n\tuint16_t curcpu, sockets, cores, threads;\n#endif\n\n\tget_procs(&numproc);\n\t*p_cpus = numproc;\n\t*p_boards = 1;\t\t/* Boards not identified from /proc/cpuinfo */\n\t*p_sockets = numproc;\t/* initially all single core/thread */\n\t*p_cores   = 1;\n\t*p_threads = 1;\n\t*p_block_map_size = 0;\n\t*p_block_map      = NULL;\n\t*p_block_map_inv  = NULL;\n\n#if defined (__sun)\n\tkstat_ctl_t   *kc;\n\tkstat_t       *ksp;\n\tkstat_named_t *knp;\n\n\tkc = kstat_open();\n\tif (kc == NULL) {\n\t\terror (\"get speed: kstat error %d\", errno);\n\t\treturn errno;\n\t}\n#else\n\tcpu_info_file = fopen(_cpuinfo_path, \"r\");\n\tif (cpu_info_file == NULL) {\n\t\terror (\"get_cpuinfo: error %d opening %s\",\n\t\t\terrno, _cpuinfo_path);\n\t\treturn errno;\n\t}\n#endif\n\n\t/* Note: assumes all processor IDs are within [0:numproc-1] */\n\t/*       treats physical/core IDs as tokens, not indices */\n\tif (cpuinfo)\n\t\tmemset(cpuinfo, 0, numproc * sizeof(cpuinfo_t));\n\telse\n\t\tcpuinfo = xmalloc(numproc * sizeof(cpuinfo_t));\n\n#if defined (__sun)\n\tksp = kstat_lookup(kc, \"cpu_info\", -1, NULL);\n\tfor (; ksp != NULL; ksp = ksp->ks_next) {\n\t\tif (xstrcmp(ksp->ks_module, \"cpu_info\"))\n\t\t\tcontinue;\n\n\t\tnumcpu++;\n\t\tkstat_read(kc, ksp, NULL);\n\n\t\tknp = kstat_data_lookup(ksp, \"chip_id\");\n\t\tchip_id = knp->value.l;\n\t\tknp = kstat_data_lookup(ksp, \"core_id\");\n\t\tcore_id = knp->value.l;\n\t\tknp = kstat_data_lookup(ksp, \"ncore_per_chip\");\n\t\tncore_per_chip = knp->value.l;\n\t\tknp = kstat_data_lookup(ksp, \"ncpu_per_chip\");\n\t\tncpu_per_chip = knp->value.l;\n\n\t\tif (chip_id >= numproc) {\n\t\t\tdebug(\"cpuid is %ld (> %d), ignored\", curcpu, numproc);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcpuinfo[chip_id].seen = 1;\n\t\tcpuinfo[chip_id].cpuid = chip_id;\n\n\t\tmaxcpuid = MAX(maxcpuid, chip_id);\n\t\tmincpuid = MIN(mincpuid, chip_id);\n\n\t\tfor (i = 0; i < numproc; i++) {\n\t\t\tif ((cpuinfo[i].coreid == core_id) &&\n\t\t\t    (cpuinfo[i].corecnt))\n\t\t\t\tbreak;\n\t\t}\n\n\t\tif (i == numproc) {\n\t\t\tnumcores++;\n\t\t} else {\n\t\t\tcpuinfo[i].corecnt++;\n\t\t}\n\n\t\tif (chip_id < numproc) {\n\t\t\tcpuinfo[chip_id].corecnt++;\n\t\t\tcpuinfo[chip_id].coreid = core_id;\n\t\t}\n\n\t\tmaxcoreid = MAX(maxcoreid, core_id);\n\t\tmincoreid = MIN(mincoreid, core_id);\n\n\t\tif (ncore_per_chip > numproc) {\n\t\t\tdebug(\"cores is %u (> %d), ignored\",\n\t\t\t      ncore_per_chip, numproc);\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (chip_id < numproc)\n\t\t\tcpuinfo[chip_id].cores = ncore_per_chip;\n\n\t\tmaxcores = MAX(maxcores, ncore_per_chip);\n\t\tmincores = MIN(mincores, ncore_per_chip);\n\t}\n#else\n\n\tcurcpu = 0;\n\twhile (fgets(buffer, sizeof(buffer), cpu_info_file) != NULL) {\n\t\tuint32_t val;\n\t\tif (_chk_cpuinfo_uint32(buffer, \"processor\", &val)) {\n\t\t\tcurcpu = numcpu;\n\t\t\tnumcpu++;\n\t\t\tif (curcpu >= numproc) {\n\t\t\t\tinfo(\"processor limit reached (%u >= %d)\",\n\t\t\t\t     curcpu, numproc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcpuinfo[curcpu].seen = 1;\n\t\t\tcpuinfo[curcpu].cpuid = val;\n\t\t\tmaxcpuid = MAX(maxcpuid, val);\n\t\t\tmincpuid = MIN(mincpuid, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"physical id\", &val)) {\n\t\t\t/* see if the ID has already been seen */\n\t\t\tfor (i=0; i<numproc; i++) {\n\t\t\t\tif ((cpuinfo[i].physid == val)\n\t\t\t\t&&  (cpuinfo[i].physcnt))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == numproc) {\t\t/* new ID... */\n\t\t\t\tnumphys++;\t\t/* ...increment total */\n\t\t\t} else {\t\t\t/* existing ID... */\n\t\t\t\tcpuinfo[i].physcnt++;\t/* ...update ID cnt */\n\t\t\t}\n\n\t\t\tif (curcpu < numproc) {\n\t\t\t\tcpuinfo[curcpu].physcnt++;\n\t\t\t\tcpuinfo[curcpu].physid = val;\n\t\t\t}\n\n\t\t\tmaxphysid = MAX(maxphysid, val);\n\t\t\tminphysid = MIN(minphysid, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"core id\", &val)) {\n\t\t\t/* see if the ID has already been seen */\n\t\t\tfor (i = 0; i < numproc; i++) {\n\t\t\t\tif ((cpuinfo[i].coreid == val)\n\t\t\t\t&&  (cpuinfo[i].corecnt))\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (i == numproc) {\t\t/* new ID... */\n\t\t\t\tnumcores++;\t\t/* ...increment total */\n\t\t\t} else {\t\t\t/* existing ID... */\n\t\t\t\tcpuinfo[i].corecnt++;\t/* ...update ID cnt */\n\t\t\t}\n\n\t\t\tif (curcpu < numproc) {\n\t\t\t\tcpuinfo[curcpu].corecnt++;\n\t\t\t\tcpuinfo[curcpu].coreid = val;\n\t\t\t}\n\n\t\t\tmaxcoreid = MAX(maxcoreid, val);\n\t\t\tmincoreid = MIN(mincoreid, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"siblings\", &val)) {\n\t\t\t/* Note: this value is a count, not an index */\n\t\t    \tif (val > numproc) {\t/* out of bounds, ignore */\n\t\t\t\tdebug(\"siblings is %u (> %d), ignored\",\n\t\t\t\t\tval, numproc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (curcpu < numproc)\n\t\t\t\tcpuinfo[curcpu].siblings = val;\n\t\t\tmaxsibs = MAX(maxsibs, val);\n\t\t\tminsibs = MIN(minsibs, val);\n\t\t} else if (_chk_cpuinfo_uint32(buffer, \"cpu cores\", &val)) {\n\t\t\t/* Note: this value is a count, not an index */\n\t\t    \tif (val > numproc) {\t/* out of bounds, ignore */\n\t\t\t\tdebug(\"cores is %u (> %d), ignored\",\n\t\t\t\t\tval, numproc);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (curcpu < numproc)\n\t\t\t\tcpuinfo[curcpu].cores = val;\n\t\t\tmaxcores = MAX(maxcores, val);\n\t\t\tmincores = MIN(mincores, val);\n\t\t}\n\t}\n\n\tfclose(cpu_info_file);\n#endif\n\n\t/*** Sanity check ***/\n\tif (minsibs == 0) minsibs = 1;\t\t/* guaranteee non-zero */\n\tif (maxsibs == 0) {\n\t    \tminsibs = 1;\n\t    \tmaxsibs = 1;\n\t}\n\tif (maxcores == 0) {\t\t\t/* no core data */\n\t    \tmincores = 0;\n\t    \tmaxcores = 0;\n\t}\n\n\t/*** Compute Sockets/Cores/Threads ***/\n\tif ((minsibs == maxsibs) &&\t\t/* homogeneous system */\n\t    (mincores == maxcores)) {\n\t\tsockets = numphys; \t\t/* unique \"physical id\" */\n\t\tif (sockets <= 1) {\t\t/* verify single socket */\n\t\t\tsockets = numcpu / maxsibs; /* maximum \"siblings\" */\n\t\t}\n\t\tif (sockets == 0)\n\t\t\tsockets = 1;\t\t/* guarantee non-zero */\n\n\t\tcores = numcores / sockets;\t/* unique \"core id\" */\n\t\tcores = MAX(maxcores, cores);\t/* maximum \"cpu cores\" */\n\n\t\tif (cores == 0) {\n\t\t\tcores = numcpu / sockets;\t/* assume multi-core */\n\t\t\tif (cores > 1) {\n\t\t\t\tdebug3(\"Warning: cpuinfo missing 'core id' or \"\n\t\t\t\t\t\"'cpu cores' but assuming multi-core\");\n\t\t\t}\n\t\t}\n\t\tif (cores == 0)\n\t\t\tcores = 1;\t/* guarantee non-zero */\n\n\t\tthreads = numcpu / (sockets * cores); /* solve for threads */\n\t\tif (threads == 0)\n\t\t\tthreads = 1;\t/* guarantee non-zero */\n\t} else {\t\t\t\t/* heterogeneous system */\n\t\tsockets = numcpu;\n\t\tcores   = 1;\t\t\t/* one core per socket */\n\t\tthreads = 1;\t\t\t/* one core per core */\n\t}\n\n\t*p_sockets = sockets;\t\t/* update output parameters */\n\t*p_cores   = cores;\n\t*p_threads = threads;\n\n#if _DEBUG\n\t/*** Display raw data ***/\n\tdebug3(\"numcpu:     %u\", numcpu);\n\tdebug3(\"numphys:    %u\", numphys);\n\tdebug3(\"numcores:   %u\", numcores);\n\n\tdebug3(\"cores:      %u->%u\", mincores, maxcores);\n\tdebug3(\"sibs:       %u->%u\", minsibs,  maxsibs);\n\n\tdebug3(\"cpuid:      %u->%u\", mincpuid,  maxcpuid);\n\tdebug3(\"physid:     %u->%u\", minphysid, maxphysid);\n\tdebug3(\"coreid:     %u->%u\", mincoreid, maxcoreid);\n\n\tfor (i = 0; i < numproc; i++) {\n\t\tdebug3(\"CPU %d:\", i);\n\t\tdebug3(\" cpuid:    %u\", cpuinfo[i].cpuid);\n\t\tdebug3(\" seen:     %u\", cpuinfo[i].seen);\n\t\tdebug3(\" physid:   %u\", cpuinfo[i].physid);\n\t\tdebug3(\" physcnt:  %u\", cpuinfo[i].physcnt);\n\t\tdebug3(\" siblings: %u\", cpuinfo[i].siblings);\n\t\tdebug3(\" cores:    %u\", cpuinfo[i].cores);\n\t\tdebug3(\" coreid:   %u\", cpuinfo[i].coreid);\n\t\tdebug3(\" corecnt:  %u\\n\", cpuinfo[i].corecnt);\n\t}\n\n\tdebug3(\"Sockets:          %u\", sockets);\n\tdebug3(\"Cores per socket: %u\", cores);\n\tdebug3(\"Threads per core: %u\", threads);\n#endif\n\n\t*p_block_map_size = numcpu;\n\tretval = _compute_block_map(*p_block_map_size, p_block_map,\n\t\t\t\t    p_block_map_inv);\n\n\txfree(cpuinfo);\t\t/* done with raw cpuinfo data */\n\n\treturn retval;\n}"
  },
  {
    "function_name": "get_cpuinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "195-423",
    "snippet": "extern int\nget_cpuinfo(uint16_t *p_cpus, uint16_t *p_boards,\n\t    uint16_t *p_sockets, uint16_t *p_cores, uint16_t *p_threads,\n\t    uint16_t *p_block_map_size,\n\t    uint16_t **p_block_map, uint16_t **p_block_map_inv)\n{\n\tenum { SOCKET=0, CORE=1, PU=2, LAST_OBJ=3 };\n\thwloc_topology_t topology;\n\thwloc_obj_t obj;\n\thwloc_obj_type_t objtype[LAST_OBJ];\n\tunsigned idx[LAST_OBJ];\n\tint nobj[LAST_OBJ];\n\tbitstr_t *used_socket = NULL;\n\tint *cores_per_socket;\n\tint actual_cpus;\n\tint macid;\n\tint absid;\n\tint actual_boards = 1, depth, sock_cnt, tot_socks = 0;\n\tint i, used_core_idx, used_sock_idx;\n\n\tdebug2(\"hwloc_topology_init\");\n\tif (hwloc_topology_init(&topology)) {\n\t\t/* error in initialize hwloc library */\n\t\tdebug(\"hwloc_topology_init() failed.\");\n\t\treturn 1;\n\t}\n\n\t/* parse all system */\n\thwloc_topology_set_flags(topology, HWLOC_TOPOLOGY_FLAG_WHOLE_SYSTEM);\n\n\t/* ignores cache, misc */\n\thwloc_topology_ignore_type (topology, HWLOC_OBJ_CACHE);\n\thwloc_topology_ignore_type (topology, HWLOC_OBJ_MISC);\n\n\t/* load topology */\n\tdebug2(\"hwloc_topology_load\");\n\tif (hwloc_topology_load(topology)) {\n\t\t/* error in load hardware topology */\n\t\tdebug(\"hwloc_topology_load() failed.\");\n\t\thwloc_topology_destroy(topology);\n\t\treturn 2;\n\t}\n#if _DEBUG\n\t_hwloc_children(topology, hwloc_get_root_obj(topology), 0);\n#endif\n\t/* Some processors (e.g. AMD Opteron 6000 series) contain multiple\n\t * NUMA nodes per socket. This is a configuration which does not map\n\t * into the hardware entities that Slurm optimizes resource allocation\n\t * for (PU/thread, core, socket, baseboard, node and network switch).\n\t * In order to optimize resource allocations on such hardware, Slurm\n\t * will consider each NUMA node within the socket as a separate socket.\n\t * You can disable this configuring \"SchedulerParameters=Ignore_NUMA\",\n\t * in which case Slurm will report the correct socket count on the node,\n\t * but not be able to optimize resource allocations on the NUMA nodes.\n\t */\n\tobjtype[SOCKET] = HWLOC_OBJ_SOCKET;\n\tobjtype[CORE]   = HWLOC_OBJ_CORE;\n\tobjtype[PU]     = HWLOC_OBJ_PU;\n\tif (hwloc_get_type_depth(topology, HWLOC_OBJ_NODE) >\n\t    hwloc_get_type_depth(topology, HWLOC_OBJ_SOCKET)) {\n\t\tchar *sched_params = slurm_get_sched_params();\n\t\tif (sched_params &&\n\t\t    strcasestr(sched_params, \"Ignore_NUMA\")) {\n\t\t\tinfo(\"Ignoring NUMA nodes within a socket\");\n\t\t} else {\n\t\t\tinfo(\"Considering each NUMA node as a socket\");\n\t\t\tobjtype[SOCKET] = HWLOC_OBJ_NODE;\n\t\t}\n\t\txfree(sched_params);\n\t}\n\n\t/* number of objects */\n\tdepth = hwloc_get_type_depth(topology, HWLOC_OBJ_GROUP);\n\tif (depth != HWLOC_TYPE_DEPTH_UNKNOWN) {\n\t\tactual_boards = MAX(hwloc_get_nbobjs_by_depth(topology, depth),\n\t\t\t\t    1);\n\t}\n\n\t/* Count sockets/NUMA containing any cores.\n\t * KNL NUMA with no cores are NOT counted. */\n\tnobj[SOCKET] = 0;\n\tdepth = hwloc_get_type_depth(topology, objtype[SOCKET]);\n\tused_socket = bit_alloc(_MAX_SOCKET_INX);\n\tcores_per_socket = xmalloc(sizeof(int) * _MAX_SOCKET_INX);\n\tsock_cnt = hwloc_get_nbobjs_by_depth(topology, depth);\n\tfor (i = 0; i < sock_cnt; i++) {\n\t\tobj = hwloc_get_obj_by_depth(topology, depth, i);\n\t\tif (obj->type == objtype[SOCKET]) {\n\t\t\tcores_per_socket[i] = _core_child_count(topology, obj);\n\t\t\tif (cores_per_socket[i] > 0) {\n\t\t\t\tnobj[SOCKET]++;\n\t\t\t\tbit_set(used_socket, tot_socks);\n\t\t\t}\n\t\t\tif (++tot_socks >= _MAX_SOCKET_INX) {\t/* Bitmap size */\n\t\t\t\tfatal(\"Socket count exceeds %d, expand data structure size\",\n\t\t\t\t      _MAX_SOCKET_INX);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tnobj[CORE] = hwloc_get_nbobjs_by_type(topology, objtype[CORE]);\n\n\t/* Workaround for hwloc bug, in some cases the topology \"children\" array\n\t * does not get populated, so _core_child_count() always returns 0 */\n\tif (nobj[SOCKET] == 0) {\n\t\tnobj[SOCKET] = hwloc_get_nbobjs_by_type(topology,\n\t\t\t\t\t\t\tobjtype[SOCKET]);\n\t\tif (nobj[SOCKET] == 0) {\n\t\t\tdebug(\"get_cpuinfo() fudging nobj[SOCKET] from 0 to 1\");\n\t\t\tnobj[SOCKET] = 1;\n\t\t}\n\t\tif (nobj[SOCKET] >= _MAX_SOCKET_INX) {\t/* Bitmap size */\n\t\t\tfatal(\"Socket count exceeds %d, expand data structure size\",\n\t\t\t      _MAX_SOCKET_INX);\n\t\t}\n\t\tbit_nset(used_socket, 0, nobj[SOCKET] - 1);\n\t}\n\n\t/*\n\t * Workaround for hwloc\n\t * hwloc_get_nbobjs_by_type() returns 0 on some architectures.\n\t */\n\tif ( nobj[CORE] == 0 ) {\n\t\tdebug(\"get_cpuinfo() fudging nobj[CORE] from 0 to 1\");\n\t\tnobj[CORE] = 1;\n\t}\n\tif ( nobj[SOCKET] == -1 )\n\t\tfatal(\"get_cpuinfo() can not handle nobj[SOCKET] = -1\");\n\tif ( nobj[CORE] == -1 )\n\t\tfatal(\"get_cpuinfo() can not handle nobj[CORE] = -1\");\n\tactual_cpus  = hwloc_get_nbobjs_by_type(topology, objtype[PU]);\n#if 0\n\t/* Used to find workaround above */\n\tinfo(\"CORE = %d SOCKET = %d actual_cpus = %d nobj[CORE] = %d\",\n\t     CORE, SOCKET, actual_cpus, nobj[CORE]);\n#endif\n\tif ((actual_cpus % nobj[CORE]) != 0) {\n\t\terror(\"Thread count (%d) not multiple of core count (%d)\",\n\t\t      actual_cpus, nobj[CORE]);\n\t}\n\tnobj[PU] = actual_cpus / nobj[CORE];\t/* threads per core */\n\n\tif ((nobj[CORE] % nobj[SOCKET]) != 0) {\n\t\terror(\"Core count (%d) not multiple of socket count (%d)\",\n\t\t      nobj[CORE], nobj[SOCKET]);\n\t}\n\tnobj[CORE] /= nobj[SOCKET];\t\t/* cores per socket */\n\n\tdebug(\"CPUs:%d Boards:%d Sockets:%d CoresPerSocket:%d ThreadsPerCore:%d\",\n\t      actual_cpus, actual_boards, nobj[SOCKET], nobj[CORE], nobj[PU]);\n\n\t/* allocate block_map */\n\t*p_block_map_size = (uint16_t)actual_cpus;\n\tif (p_block_map && p_block_map_inv) {\n\t\t*p_block_map     = xmalloc(actual_cpus * sizeof(uint16_t));\n\t\t*p_block_map_inv = xmalloc(actual_cpus * sizeof(uint16_t));\n\n\t\t/* initialize default as linear mapping */\n\t\tfor (i = 0; i < actual_cpus; i++) {\n\t\t\t(*p_block_map)[i]     = i;\n\t\t\t(*p_block_map_inv)[i] = i;\n\t\t}\n\t\t/* create map with hwloc */\n\t\tused_sock_idx = -1;\n\t\tused_core_idx = -1;\n\t\tfor (idx[SOCKET] = 0; (used_sock_idx + 1) < nobj[SOCKET];\n\t\t     idx[SOCKET]++) {\n\t\t\tif (!bit_test(used_socket, idx[SOCKET]))\n\t\t\t\tcontinue;\n\t\t\tused_sock_idx++;\n\t\t\tfor (idx[CORE] = 0;\n\t\t\t     idx[CORE] < cores_per_socket[idx[SOCKET]];\n\t\t\t     idx[CORE]++) {\n\t\t\t\tused_core_idx++;\n\t\t\t\tfor (idx[PU]=0; idx[PU]<nobj[PU]; ++idx[PU]) {\n\t\t\t\t\t/* get hwloc_obj by indexes */\n\t\t\t\t\tobj=hwloc_get_obj_below_array_by_type(\n\t\t\t\t\t            topology, 3, objtype, idx);\n\t\t\t\t\tif (!obj)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tmacid = obj->os_index;\n\t\t\t\t\tabsid = used_core_idx * nobj[PU] + idx[PU];\n\n\t\t\t\t\tif ((macid >= actual_cpus) ||\n\t\t\t\t\t    (absid >= actual_cpus)) {\n\t\t\t\t\t\t/* physical or logical ID are\n\t\t\t\t\t\t * out of range */\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdebug4(\"CPU map[%d]=>%d S:C:T %d:%d:%d\", absid, macid,\n\t\t\t\t\t       used_sock_idx, idx[CORE], idx[PU]);\n\t\t\t\t\t(*p_block_map)[absid]     = macid;\n\t\t\t\t\t(*p_block_map_inv)[macid] = absid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tFREE_NULL_BITMAP(used_socket);\n\txfree(cores_per_socket);\n\thwloc_topology_destroy(topology);\n\n\t/* update output parameters */\n\t*p_cpus    = actual_cpus;\n\t*p_boards  = actual_boards;\n\t*p_sockets = nobj[SOCKET];\n\t*p_cores   = nobj[CORE];\n\t*p_threads = nobj[PU];\n\n#if _DEBUG\n\t/*** Display raw data ***/\n\tdebug(\"CPUs:%u Boards:%u Sockets:%u CoresPerSocket:%u ThreadsPerCore:%u\",\n\t      *p_cpus, *p_boards, *p_sockets, *p_cores, *p_threads);\n\n\t/* Display the mapping tables */\n\tif (p_block_map && p_block_map_inv) {\n\t\tdebug(\"------\");\n\t\tdebug(\"Abstract -> Machine logical CPU ID block mapping:\");\n\t\tdebug(\"AbstractId PhysicalId Inverse\");\n\t\tfor (i = 0; i < *p_cpus; i++) {\n\t\t\tdebug3(\"   %4d      %4u       %4u\",\n\t\t\t\ti, (*p_block_map)[i], (*p_block_map_inv)[i]);\n\t\t}\n\t\tdebug(\"------\");\n\t}\n#endif\n\treturn 0;\n\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [
      "#define _MAX_SOCKET_INX 1024",
      "#define _DEBUG 0"
    ],
    "globals_used": [
      "uint16_t procs, boards, sockets, cores, threads=1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"------\""
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_stop_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "120-139",
          "snippet": "void\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"   %4d      %4u       %4u\"",
            "i",
            "(*p_block_map)[i]",
            "(*p_block_map_inv)[i]"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"CPUs:%u Boards:%u Sockets:%u CoresPerSocket:%u ThreadsPerCore:%u\"",
            "*p_cpus",
            "*p_boards",
            "*p_sockets",
            "*p_cores",
            "*p_threads"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_topology_destroy",
          "args": [
            "topology"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "cores_per_socket"
          ],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "FREE_NULL_BITMAP",
          "args": [
            "used_socket"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"CPU map[%d]=>%d S:C:T %d:%d:%d\"",
            "absid",
            "macid",
            "used_sock_idx",
            "idx[CORE]",
            "idx[PU]"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_get_obj_below_array_by_type",
          "args": [
            "topology",
            "3",
            "objtype",
            "idx"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_test",
          "args": [
            "used_socket",
            "idx[SOCKET]"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "actual_cpus * sizeof(uint16_t)"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "actual_cpus * sizeof(uint16_t)"
          ],
          "line": 350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"CPUs:%d Boards:%d Sockets:%d CoresPerSocket:%d ThreadsPerCore:%d\"",
            "actual_cpus",
            "actual_boards",
            "nobj[SOCKET]",
            "nobj[CORE]",
            "nobj[PU]"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Core count (%d) not multiple of socket count (%d)\"",
            "nobj[CORE]",
            "nobj[SOCKET]"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Thread count (%d) not multiple of core count (%d)\"",
            "actual_cpus",
            "nobj[CORE]"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info",
          "args": [
            "\"CORE = %d SOCKET = %d actual_cpus = %d nobj[CORE] = %d\"",
            "CORE",
            "SOCKET",
            "actual_cpus",
            "nobj[CORE]"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "task_info_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "647-683",
          "snippet": "extern stepd_step_task_info_t *\ntask_info_create(int taskid, int gtaskid,\n\t\t char *ifname, char *ofname, char *efname)\n{\n\tstepd_step_task_info_t *t = xmalloc(sizeof(stepd_step_task_info_t));\n\n\txassert(taskid >= 0);\n\txassert(gtaskid >= 0);\n\n\tslurm_mutex_init(&t->mutex);\n\tslurm_mutex_lock(&t->mutex);\n\tt->state       = STEPD_STEP_TASK_INIT;\n\tt->id          = taskid;\n\tt->gtid\t       = gtaskid;\n\tt->pid         = (pid_t) -1;\n\tt->ifname      = ifname;\n\tt->ofname      = ofname;\n\tt->efname      = efname;\n\tt->stdin_fd    = -1;\n\tt->to_stdin    = -1;\n\tt->stdout_fd   = -1;\n\tt->from_stdout = -1;\n\tt->stderr_fd   = -1;\n\tt->from_stderr = -1;\n\tt->in          = NULL;\n\tt->out         = NULL;\n\tt->err         = NULL;\n\tt->killed_by_cmd = false;\n\tt->aborted     = false;\n\tt->esent       = false;\n\tt->exited      = false;\n\tt->estatus     = -1;\n\tt->argc\t       = 0;\n\tt->argv\t       = NULL;\n\tslurm_mutex_unlock(&t->mutex);\n\treturn t;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _job_init_task_info(stepd_step_rec_t *job, uint32_t **gtid,\n\t\t\t\tchar *ifname, char *ofname, char *efname);\n\nextern stepd_step_task_info_t *\ntask_info_create(int taskid, int gtaskid,\n\t\t char *ifname, char *ofname, char *efname)\n{\n\tstepd_step_task_info_t *t = xmalloc(sizeof(stepd_step_task_info_t));\n\n\txassert(taskid >= 0);\n\txassert(gtaskid >= 0);\n\n\tslurm_mutex_init(&t->mutex);\n\tslurm_mutex_lock(&t->mutex);\n\tt->state       = STEPD_STEP_TASK_INIT;\n\tt->id          = taskid;\n\tt->gtid\t       = gtaskid;\n\tt->pid         = (pid_t) -1;\n\tt->ifname      = ifname;\n\tt->ofname      = ofname;\n\tt->efname      = efname;\n\tt->stdin_fd    = -1;\n\tt->to_stdin    = -1;\n\tt->stdout_fd   = -1;\n\tt->from_stdout = -1;\n\tt->stderr_fd   = -1;\n\tt->from_stderr = -1;\n\tt->in          = NULL;\n\tt->out         = NULL;\n\tt->err         = NULL;\n\tt->killed_by_cmd = false;\n\tt->aborted     = false;\n\tt->esent       = false;\n\tt->exited      = false;\n\tt->estatus     = -1;\n\tt->argc\t       = 0;\n\tt->argv\t       = NULL;\n\tslurm_mutex_unlock(&t->mutex);\n\treturn t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hwloc_get_nbobjs_by_type",
          "args": [
            "topology",
            "objtype[PU]"
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"get_cpuinfo() can not handle nobj[CORE] = -1\""
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"get_cpuinfo() can not handle nobj[SOCKET] = -1\""
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_nset",
          "args": [
            "used_socket",
            "0",
            "nobj[SOCKET] - 1"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Socket count exceeds %d, expand data structure size\"",
            "_MAX_SOCKET_INX"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_get_nbobjs_by_type",
          "args": [
            "topology",
            "objtype[SOCKET]"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_get_nbobjs_by_type",
          "args": [
            "topology",
            "objtype[CORE]"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Socket count exceeds %d, expand data structure size\"",
            "_MAX_SOCKET_INX"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_set",
          "args": [
            "used_socket",
            "tot_socks"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_core_child_count",
          "args": [
            "topology",
            "obj"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "_core_child_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "183-193",
          "snippet": "static int _core_child_count(hwloc_topology_t topology, hwloc_obj_t obj)\n{\n\tint count = 0, i;\n\n\tif (obj->type == HWLOC_OBJ_CORE)\n\t\treturn 1;\n\n\tfor (i = 0; i < obj->arity; i++)\n\t\tcount += _core_child_count(topology, obj->children[i]);\n\treturn count;\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _core_child_count(hwloc_topology_t topology, hwloc_obj_t obj)\n{\n\tint count = 0, i;\n\n\tif (obj->type == HWLOC_OBJ_CORE)\n\t\treturn 1;\n\n\tfor (i = 0; i < obj->arity; i++)\n\t\tcount += _core_child_count(topology, obj->children[i]);\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hwloc_get_obj_by_depth",
          "args": [
            "topology",
            "depth",
            "i"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_get_nbobjs_by_depth",
          "args": [
            "topology",
            "depth"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(int) * _MAX_SOCKET_INX"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_alloc",
          "args": [
            "_MAX_SOCKET_INX"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_get_type_depth",
          "args": [
            "topology",
            "objtype[SOCKET]"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "hwloc_get_nbobjs_by_depth(topology, depth)",
            "1"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_get_nbobjs_by_depth",
          "args": [
            "topology",
            "depth"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_get_type_depth",
          "args": [
            "topology",
            "HWLOC_OBJ_GROUP"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info",
          "args": [
            "\"Considering each NUMA node as a socket\""
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "_fork_child_with_wait_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "1464-1486",
          "snippet": "static struct exec_wait_info * _fork_child_with_wait_info (int id)\n{\n\tstruct exec_wait_info *e;\n\n\tif (!(e = _exec_wait_info_create (id)))\n\t\treturn (NULL);\n\n\tif ((e->pid = fork ()) < 0) {\n\t\t_exec_wait_info_destroy (e);\n\t\treturn (NULL);\n\t}\n\t/*\n\t *  Close parentfd in child, and childfd in parent:\n\t */\n\tif (e->pid == 0) {\n\t\tclose (e->parentfd);\n\t\te->parentfd = -1;\n\t} else {\n\t\tclose (e->childfd);\n\t\te->childfd = -1;\n\t}\n\treturn (e);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic struct exec_wait_info * _fork_child_with_wait_info (int id)\n{\n\tstruct exec_wait_info *e;\n\n\tif (!(e = _exec_wait_info_create (id)))\n\t\treturn (NULL);\n\n\tif ((e->pid = fork ()) < 0) {\n\t\t_exec_wait_info_destroy (e);\n\t\treturn (NULL);\n\t}\n\t/*\n\t *  Close parentfd in child, and childfd in parent:\n\t */\n\tif (e->pid == 0) {\n\t\tclose (e->parentfd);\n\t\te->parentfd = -1;\n\t} else {\n\t\tclose (e->childfd);\n\t\te->childfd = -1;\n\t}\n\treturn (e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcasestr",
          "args": [
            "sched_params",
            "\"Ignore_NUMA\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_get_sched_params",
          "args": [],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_get_type_depth",
          "args": [
            "topology",
            "HWLOC_OBJ_SOCKET"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_get_type_depth",
          "args": [
            "topology",
            "HWLOC_OBJ_NODE"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_hwloc_children",
          "args": [
            "topology",
            "hwloc_get_root_obj(topology)",
            "0"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "_hwloc_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "166-179",
          "snippet": "static void _hwloc_children(hwloc_topology_t topology, hwloc_obj_t obj,\n\t\t\t    int depth)\n{\n\tchar string[128];\n\tunsigned i;\n\n\tif (!obj)\n\t\treturn;\n\thwloc_obj_snprintf(string, sizeof(string), topology, obj, \"#\", 0);\n\tdebug(\"%*s%s\", 2 * depth, \"\", string);\n\tfor (i = 0; i < obj->arity; i++) {\n\t\t_hwloc_children(topology, obj->children[i], depth + 1);\n\t}\n}",
          "includes": [
            "#include \"xcpuinfo.h\"",
            "#include <hwloc.h>",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <ctype.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic void _hwloc_children(hwloc_topology_t topology, hwloc_obj_t obj,\n\t\t\t    int depth)\n{\n\tchar string[128];\n\tunsigned i;\n\n\tif (!obj)\n\t\treturn;\n\thwloc_obj_snprintf(string, sizeof(string), topology, obj, \"#\", 0);\n\tdebug(\"%*s%s\", 2 * depth, \"\", string);\n\tfor (i = 0; i < obj->arity; i++) {\n\t\t_hwloc_children(topology, obj->children[i], depth + 1);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hwloc_get_root_obj",
          "args": [
            "topology"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_topology_destroy",
          "args": [
            "topology"
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_topology_load",
          "args": [
            "topology"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"hwloc_topology_load\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_topology_ignore_type",
          "args": [
            "topology",
            "HWLOC_OBJ_MISC"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_topology_ignore_type",
          "args": [
            "topology",
            "HWLOC_OBJ_CACHE"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_topology_set_flags",
          "args": [
            "topology",
            "HWLOC_TOPOLOGY_FLAG_WHOLE_SYSTEM"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_topology_init",
          "args": [
            "&topology"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"hwloc_topology_init\""
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\n#define _MAX_SOCKET_INX 1024\n#define _DEBUG 0\n\nuint16_t procs, boards, sockets, cores, threads=1;\n\nextern int\nget_cpuinfo(uint16_t *p_cpus, uint16_t *p_boards,\n\t    uint16_t *p_sockets, uint16_t *p_cores, uint16_t *p_threads,\n\t    uint16_t *p_block_map_size,\n\t    uint16_t **p_block_map, uint16_t **p_block_map_inv)\n{\n\tenum { SOCKET=0, CORE=1, PU=2, LAST_OBJ=3 };\n\thwloc_topology_t topology;\n\thwloc_obj_t obj;\n\thwloc_obj_type_t objtype[LAST_OBJ];\n\tunsigned idx[LAST_OBJ];\n\tint nobj[LAST_OBJ];\n\tbitstr_t *used_socket = NULL;\n\tint *cores_per_socket;\n\tint actual_cpus;\n\tint macid;\n\tint absid;\n\tint actual_boards = 1, depth, sock_cnt, tot_socks = 0;\n\tint i, used_core_idx, used_sock_idx;\n\n\tdebug2(\"hwloc_topology_init\");\n\tif (hwloc_topology_init(&topology)) {\n\t\t/* error in initialize hwloc library */\n\t\tdebug(\"hwloc_topology_init() failed.\");\n\t\treturn 1;\n\t}\n\n\t/* parse all system */\n\thwloc_topology_set_flags(topology, HWLOC_TOPOLOGY_FLAG_WHOLE_SYSTEM);\n\n\t/* ignores cache, misc */\n\thwloc_topology_ignore_type (topology, HWLOC_OBJ_CACHE);\n\thwloc_topology_ignore_type (topology, HWLOC_OBJ_MISC);\n\n\t/* load topology */\n\tdebug2(\"hwloc_topology_load\");\n\tif (hwloc_topology_load(topology)) {\n\t\t/* error in load hardware topology */\n\t\tdebug(\"hwloc_topology_load() failed.\");\n\t\thwloc_topology_destroy(topology);\n\t\treturn 2;\n\t}\n#if _DEBUG\n\t_hwloc_children(topology, hwloc_get_root_obj(topology), 0);\n#endif\n\t/* Some processors (e.g. AMD Opteron 6000 series) contain multiple\n\t * NUMA nodes per socket. This is a configuration which does not map\n\t * into the hardware entities that Slurm optimizes resource allocation\n\t * for (PU/thread, core, socket, baseboard, node and network switch).\n\t * In order to optimize resource allocations on such hardware, Slurm\n\t * will consider each NUMA node within the socket as a separate socket.\n\t * You can disable this configuring \"SchedulerParameters=Ignore_NUMA\",\n\t * in which case Slurm will report the correct socket count on the node,\n\t * but not be able to optimize resource allocations on the NUMA nodes.\n\t */\n\tobjtype[SOCKET] = HWLOC_OBJ_SOCKET;\n\tobjtype[CORE]   = HWLOC_OBJ_CORE;\n\tobjtype[PU]     = HWLOC_OBJ_PU;\n\tif (hwloc_get_type_depth(topology, HWLOC_OBJ_NODE) >\n\t    hwloc_get_type_depth(topology, HWLOC_OBJ_SOCKET)) {\n\t\tchar *sched_params = slurm_get_sched_params();\n\t\tif (sched_params &&\n\t\t    strcasestr(sched_params, \"Ignore_NUMA\")) {\n\t\t\tinfo(\"Ignoring NUMA nodes within a socket\");\n\t\t} else {\n\t\t\tinfo(\"Considering each NUMA node as a socket\");\n\t\t\tobjtype[SOCKET] = HWLOC_OBJ_NODE;\n\t\t}\n\t\txfree(sched_params);\n\t}\n\n\t/* number of objects */\n\tdepth = hwloc_get_type_depth(topology, HWLOC_OBJ_GROUP);\n\tif (depth != HWLOC_TYPE_DEPTH_UNKNOWN) {\n\t\tactual_boards = MAX(hwloc_get_nbobjs_by_depth(topology, depth),\n\t\t\t\t    1);\n\t}\n\n\t/* Count sockets/NUMA containing any cores.\n\t * KNL NUMA with no cores are NOT counted. */\n\tnobj[SOCKET] = 0;\n\tdepth = hwloc_get_type_depth(topology, objtype[SOCKET]);\n\tused_socket = bit_alloc(_MAX_SOCKET_INX);\n\tcores_per_socket = xmalloc(sizeof(int) * _MAX_SOCKET_INX);\n\tsock_cnt = hwloc_get_nbobjs_by_depth(topology, depth);\n\tfor (i = 0; i < sock_cnt; i++) {\n\t\tobj = hwloc_get_obj_by_depth(topology, depth, i);\n\t\tif (obj->type == objtype[SOCKET]) {\n\t\t\tcores_per_socket[i] = _core_child_count(topology, obj);\n\t\t\tif (cores_per_socket[i] > 0) {\n\t\t\t\tnobj[SOCKET]++;\n\t\t\t\tbit_set(used_socket, tot_socks);\n\t\t\t}\n\t\t\tif (++tot_socks >= _MAX_SOCKET_INX) {\t/* Bitmap size */\n\t\t\t\tfatal(\"Socket count exceeds %d, expand data structure size\",\n\t\t\t\t      _MAX_SOCKET_INX);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tnobj[CORE] = hwloc_get_nbobjs_by_type(topology, objtype[CORE]);\n\n\t/* Workaround for hwloc bug, in some cases the topology \"children\" array\n\t * does not get populated, so _core_child_count() always returns 0 */\n\tif (nobj[SOCKET] == 0) {\n\t\tnobj[SOCKET] = hwloc_get_nbobjs_by_type(topology,\n\t\t\t\t\t\t\tobjtype[SOCKET]);\n\t\tif (nobj[SOCKET] == 0) {\n\t\t\tdebug(\"get_cpuinfo() fudging nobj[SOCKET] from 0 to 1\");\n\t\t\tnobj[SOCKET] = 1;\n\t\t}\n\t\tif (nobj[SOCKET] >= _MAX_SOCKET_INX) {\t/* Bitmap size */\n\t\t\tfatal(\"Socket count exceeds %d, expand data structure size\",\n\t\t\t      _MAX_SOCKET_INX);\n\t\t}\n\t\tbit_nset(used_socket, 0, nobj[SOCKET] - 1);\n\t}\n\n\t/*\n\t * Workaround for hwloc\n\t * hwloc_get_nbobjs_by_type() returns 0 on some architectures.\n\t */\n\tif ( nobj[CORE] == 0 ) {\n\t\tdebug(\"get_cpuinfo() fudging nobj[CORE] from 0 to 1\");\n\t\tnobj[CORE] = 1;\n\t}\n\tif ( nobj[SOCKET] == -1 )\n\t\tfatal(\"get_cpuinfo() can not handle nobj[SOCKET] = -1\");\n\tif ( nobj[CORE] == -1 )\n\t\tfatal(\"get_cpuinfo() can not handle nobj[CORE] = -1\");\n\tactual_cpus  = hwloc_get_nbobjs_by_type(topology, objtype[PU]);\n#if 0\n\t/* Used to find workaround above */\n\tinfo(\"CORE = %d SOCKET = %d actual_cpus = %d nobj[CORE] = %d\",\n\t     CORE, SOCKET, actual_cpus, nobj[CORE]);\n#endif\n\tif ((actual_cpus % nobj[CORE]) != 0) {\n\t\terror(\"Thread count (%d) not multiple of core count (%d)\",\n\t\t      actual_cpus, nobj[CORE]);\n\t}\n\tnobj[PU] = actual_cpus / nobj[CORE];\t/* threads per core */\n\n\tif ((nobj[CORE] % nobj[SOCKET]) != 0) {\n\t\terror(\"Core count (%d) not multiple of socket count (%d)\",\n\t\t      nobj[CORE], nobj[SOCKET]);\n\t}\n\tnobj[CORE] /= nobj[SOCKET];\t\t/* cores per socket */\n\n\tdebug(\"CPUs:%d Boards:%d Sockets:%d CoresPerSocket:%d ThreadsPerCore:%d\",\n\t      actual_cpus, actual_boards, nobj[SOCKET], nobj[CORE], nobj[PU]);\n\n\t/* allocate block_map */\n\t*p_block_map_size = (uint16_t)actual_cpus;\n\tif (p_block_map && p_block_map_inv) {\n\t\t*p_block_map     = xmalloc(actual_cpus * sizeof(uint16_t));\n\t\t*p_block_map_inv = xmalloc(actual_cpus * sizeof(uint16_t));\n\n\t\t/* initialize default as linear mapping */\n\t\tfor (i = 0; i < actual_cpus; i++) {\n\t\t\t(*p_block_map)[i]     = i;\n\t\t\t(*p_block_map_inv)[i] = i;\n\t\t}\n\t\t/* create map with hwloc */\n\t\tused_sock_idx = -1;\n\t\tused_core_idx = -1;\n\t\tfor (idx[SOCKET] = 0; (used_sock_idx + 1) < nobj[SOCKET];\n\t\t     idx[SOCKET]++) {\n\t\t\tif (!bit_test(used_socket, idx[SOCKET]))\n\t\t\t\tcontinue;\n\t\t\tused_sock_idx++;\n\t\t\tfor (idx[CORE] = 0;\n\t\t\t     idx[CORE] < cores_per_socket[idx[SOCKET]];\n\t\t\t     idx[CORE]++) {\n\t\t\t\tused_core_idx++;\n\t\t\t\tfor (idx[PU]=0; idx[PU]<nobj[PU]; ++idx[PU]) {\n\t\t\t\t\t/* get hwloc_obj by indexes */\n\t\t\t\t\tobj=hwloc_get_obj_below_array_by_type(\n\t\t\t\t\t            topology, 3, objtype, idx);\n\t\t\t\t\tif (!obj)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tmacid = obj->os_index;\n\t\t\t\t\tabsid = used_core_idx * nobj[PU] + idx[PU];\n\n\t\t\t\t\tif ((macid >= actual_cpus) ||\n\t\t\t\t\t    (absid >= actual_cpus)) {\n\t\t\t\t\t\t/* physical or logical ID are\n\t\t\t\t\t\t * out of range */\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdebug4(\"CPU map[%d]=>%d S:C:T %d:%d:%d\", absid, macid,\n\t\t\t\t\t       used_sock_idx, idx[CORE], idx[PU]);\n\t\t\t\t\t(*p_block_map)[absid]     = macid;\n\t\t\t\t\t(*p_block_map_inv)[macid] = absid;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tFREE_NULL_BITMAP(used_socket);\n\txfree(cores_per_socket);\n\thwloc_topology_destroy(topology);\n\n\t/* update output parameters */\n\t*p_cpus    = actual_cpus;\n\t*p_boards  = actual_boards;\n\t*p_sockets = nobj[SOCKET];\n\t*p_cores   = nobj[CORE];\n\t*p_threads = nobj[PU];\n\n#if _DEBUG\n\t/*** Display raw data ***/\n\tdebug(\"CPUs:%u Boards:%u Sockets:%u CoresPerSocket:%u ThreadsPerCore:%u\",\n\t      *p_cpus, *p_boards, *p_sockets, *p_cores, *p_threads);\n\n\t/* Display the mapping tables */\n\tif (p_block_map && p_block_map_inv) {\n\t\tdebug(\"------\");\n\t\tdebug(\"Abstract -> Machine logical CPU ID block mapping:\");\n\t\tdebug(\"AbstractId PhysicalId Inverse\");\n\t\tfor (i = 0; i < *p_cpus; i++) {\n\t\t\tdebug3(\"   %4d      %4u       %4u\",\n\t\t\t\ti, (*p_block_map)[i], (*p_block_map_inv)[i]);\n\t\t}\n\t\tdebug(\"------\");\n\t}\n#endif\n\treturn 0;\n\n}"
  },
  {
    "function_name": "_core_child_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "183-193",
    "snippet": "static int _core_child_count(hwloc_topology_t topology, hwloc_obj_t obj)\n{\n\tint count = 0, i;\n\n\tif (obj->type == HWLOC_OBJ_CORE)\n\t\treturn 1;\n\n\tfor (i = 0; i < obj->arity; i++)\n\t\tcount += _core_child_count(topology, obj->children[i]);\n\treturn count;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_core_child_count",
          "args": [
            "topology",
            "obj->children[i]"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "_core_child_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "183-193",
          "snippet": "static int _core_child_count(hwloc_topology_t topology, hwloc_obj_t obj)\n{\n\tint count = 0, i;\n\n\tif (obj->type == HWLOC_OBJ_CORE)\n\t\treturn 1;\n\n\tfor (i = 0; i < obj->arity; i++)\n\t\tcount += _core_child_count(topology, obj->children[i]);\n\treturn count;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic int _core_child_count(hwloc_topology_t topology, hwloc_obj_t obj)\n{\n\tint count = 0, i;\n\n\tif (obj->type == HWLOC_OBJ_CORE)\n\t\treturn 1;\n\n\tfor (i = 0; i < obj->arity; i++)\n\t\tcount += _core_child_count(topology, obj->children[i]);\n\treturn count;\n}"
  },
  {
    "function_name": "_hwloc_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "166-179",
    "snippet": "static void _hwloc_children(hwloc_topology_t topology, hwloc_obj_t obj,\n\t\t\t    int depth)\n{\n\tchar string[128];\n\tunsigned i;\n\n\tif (!obj)\n\t\treturn;\n\thwloc_obj_snprintf(string, sizeof(string), topology, obj, \"#\", 0);\n\tdebug(\"%*s%s\", 2 * depth, \"\", string);\n\tfor (i = 0; i < obj->arity; i++) {\n\t\t_hwloc_children(topology, obj->children[i], depth + 1);\n\t}\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "_hwloc_children",
          "args": [
            "topology",
            "obj->children[i]",
            "depth + 1"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "_hwloc_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
          "lines": "166-179",
          "snippet": "static void _hwloc_children(hwloc_topology_t topology, hwloc_obj_t obj,\n\t\t\t    int depth)\n{\n\tchar string[128];\n\tunsigned i;\n\n\tif (!obj)\n\t\treturn;\n\thwloc_obj_snprintf(string, sizeof(string), topology, obj, \"#\", 0);\n\tdebug(\"%*s%s\", 2 * depth, \"\", string);\n\tfor (i = 0; i < obj->arity; i++) {\n\t\t_hwloc_children(topology, obj->children[i], depth + 1);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%*s%s\"",
            "2 * depth",
            "\"\"",
            "string"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hwloc_obj_snprintf",
          "args": [
            "string",
            "sizeof(string)",
            "topology",
            "obj",
            "\"#\"",
            "0"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nstatic void _hwloc_children(hwloc_topology_t topology, hwloc_obj_t obj,\n\t\t\t    int depth)\n{\n\tchar string[128];\n\tunsigned i;\n\n\tif (!obj)\n\t\treturn;\n\thwloc_obj_snprintf(string, sizeof(string), topology, obj, \"#\", 0);\n\tdebug(\"%*s%s\", 2 * depth, \"\", string);\n\tfor (i = 0; i < obj->arity; i++) {\n\t\t_hwloc_children(topology, obj->children[i], depth + 1);\n\t}\n}"
  },
  {
    "function_name": "get_procs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcpuinfo.c",
    "lines": "105-150",
    "snippet": "extern int\nget_procs(uint16_t *procs)\n{\n#ifdef LPAR_INFO_FORMAT2\n\t/* AIX 5.3 only */\n\tlpar_info_format2_t info;\n\n\t*procs = 1;\n\tif (lpar_get_info(LPAR_INFO_FORMAT2, &info, sizeof(info)) != 0) {\n\t\terror(\"lpar_get_info() failed\");\n\t\treturn EINVAL;\n\t}\n\n\t*procs = (uint16_t) info.online_vcpus;\n#else /* !LPAR_INFO_FORMAT2 */\n\n#  ifdef _SC_NPROCESSORS_ONLN\n\tint my_proc_tally;\n\n\t*procs = 1;\n\tmy_proc_tally = (int)sysconf(_SC_NPROCESSORS_ONLN);\n\tif (my_proc_tally < 1) {\n\t\terror (\"get_procs: error running sysconf(_SC_NPROCESSORS_ONLN)\");\n\t\treturn EINVAL;\n\t}\n\n\t*procs = (uint16_t) my_proc_tally;\n#  else\n#    ifdef HAVE_SYSCTLBYNAME\n\tint ncpu;\n\tsize_t len = sizeof(ncpu);\n\n\t*procs = 1;\n\tif (sysctlbyname(\"hw.ncpus\", &ncpu, &len, NULL, 0) == -1) {\n\t\terror(\"get_procs: error running sysctl(HW_NCPU)\");\n\t\treturn EINVAL;\n\t}\n\t*procs = (uint16_t) ncpu;\n#    else /* !HAVE_SYSCTLBYNAME */\n\t*procs = 1;\n#    endif /* HAVE_SYSCTLBYNAME */\n#  endif /* _SC_NPROCESSORS_ONLN */\n#endif /* LPAR_INFO_FORMAT2 */\n\n\treturn 0;\n}",
    "includes": [
      "#include \"xcpuinfo.h\"",
      "#include <hwloc.h>",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/log.h\"",
      "#include \"slurm/slurm_errno.h\"",
      "#include \"slurm/slurm.h\"",
      "#include <strings.h>",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <fcntl.h>",
      "#include <ctype.h>",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#  include <inttypes.h>",
      "#  include <stdint.h>",
      "#   include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"get_procs: error running sysctl(HW_NCPU)\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysctlbyname",
          "args": [
            "\"hw.ncpus\"",
            "&ncpu",
            "&len",
            "NULL",
            "0"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"get_procs: error running sysconf(_SC_NPROCESSORS_ONLN)\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysconf",
          "args": [
            "_SC_NPROCESSORS_ONLN"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"lpar_get_info() failed\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lpar_get_info",
          "args": [
            "LPAR_INFO_FORMAT2",
            "&info",
            "sizeof(info)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"xcpuinfo.h\"\n#include <hwloc.h>\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nextern int\nget_procs(uint16_t *procs)\n{\n#ifdef LPAR_INFO_FORMAT2\n\t/* AIX 5.3 only */\n\tlpar_info_format2_t info;\n\n\t*procs = 1;\n\tif (lpar_get_info(LPAR_INFO_FORMAT2, &info, sizeof(info)) != 0) {\n\t\terror(\"lpar_get_info() failed\");\n\t\treturn EINVAL;\n\t}\n\n\t*procs = (uint16_t) info.online_vcpus;\n#else /* !LPAR_INFO_FORMAT2 */\n\n#  ifdef _SC_NPROCESSORS_ONLN\n\tint my_proc_tally;\n\n\t*procs = 1;\n\tmy_proc_tally = (int)sysconf(_SC_NPROCESSORS_ONLN);\n\tif (my_proc_tally < 1) {\n\t\terror (\"get_procs: error running sysconf(_SC_NPROCESSORS_ONLN)\");\n\t\treturn EINVAL;\n\t}\n\n\t*procs = (uint16_t) my_proc_tally;\n#  else\n#    ifdef HAVE_SYSCTLBYNAME\n\tint ncpu;\n\tsize_t len = sizeof(ncpu);\n\n\t*procs = 1;\n\tif (sysctlbyname(\"hw.ncpus\", &ncpu, &len, NULL, 0) == -1) {\n\t\terror(\"get_procs: error running sysctl(HW_NCPU)\");\n\t\treturn EINVAL;\n\t}\n\t*procs = (uint16_t) ncpu;\n#    else /* !HAVE_SYSCTLBYNAME */\n\t*procs = 1;\n#    endif /* HAVE_SYSCTLBYNAME */\n#  endif /* _SC_NPROCESSORS_ONLN */\n#endif /* LPAR_INFO_FORMAT2 */\n\n\treturn 0;\n}"
  }
]