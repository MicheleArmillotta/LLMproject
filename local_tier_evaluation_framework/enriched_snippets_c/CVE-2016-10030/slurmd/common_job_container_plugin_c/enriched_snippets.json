[
  {
    "function_name": "container_g_reconfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
    "lines": "261-272",
    "snippet": "extern void container_g_reconfig(void)\n{\n\tint i;\n\n\t(void) job_container_init();\n\n\tfor (i = 0; i < g_container_context_num;i++) {\n\t\t(*(ops[i].container_p_reconfig))();\n\t}\n\n\treturn;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/job_container_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static job_container_ops_t\t*ops = NULL;",
      "static int\t\t\tg_container_context_num = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "job_container_init",
          "args": [],
          "line": 265
        },
        "resolved": true,
        "details": {
          "function_name": "job_container_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
          "lines": "83-143",
          "snippet": "extern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};",
            "static job_container_ops_t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_container_context = NULL;",
            "static int\t\t\tg_container_context_num = -1;",
            "static pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};\nstatic job_container_ops_t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_container_context = NULL;\nstatic int\t\t\tg_container_context_num = -1;\nstatic pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic job_container_ops_t\t*ops = NULL;\nstatic int\t\t\tg_container_context_num = -1;\n\nextern void container_g_reconfig(void)\n{\n\tint i;\n\n\t(void) job_container_init();\n\n\tfor (i = 0; i < g_container_context_num;i++) {\n\t\t(*(ops[i].container_p_reconfig))();\n\t}\n\n\treturn;\n}"
  },
  {
    "function_name": "container_g_restore",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
    "lines": "245-258",
    "snippet": "extern int container_g_restore(char * dir_name, bool recover)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (job_container_init())\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_container_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].container_p_restore))(dir_name, recover);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/job_container_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static job_container_ops_t\t*ops = NULL;",
      "static int\t\t\tg_container_context_num = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "dir_name",
            "recover"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "job_container_init",
          "args": [],
          "line": 249
        },
        "resolved": true,
        "details": {
          "function_name": "job_container_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
          "lines": "83-143",
          "snippet": "extern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};",
            "static job_container_ops_t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_container_context = NULL;",
            "static int\t\t\tg_container_context_num = -1;",
            "static pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};\nstatic job_container_ops_t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_container_context = NULL;\nstatic int\t\t\tg_container_context_num = -1;\nstatic pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic job_container_ops_t\t*ops = NULL;\nstatic int\t\t\tg_container_context_num = -1;\n\nextern int container_g_restore(char * dir_name, bool recover)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (job_container_init())\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_container_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].container_p_restore))(dir_name, recover);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "container_g_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
    "lines": "229-242",
    "snippet": "extern int container_g_delete(uint32_t job_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (job_container_init())\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_container_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].container_p_delete))(job_id);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/job_container_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static job_container_ops_t\t*ops = NULL;",
      "static int\t\t\tg_container_context_num = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "job_id"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "job_container_init",
          "args": [],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "job_container_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
          "lines": "83-143",
          "snippet": "extern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};",
            "static job_container_ops_t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_container_context = NULL;",
            "static int\t\t\tg_container_context_num = -1;",
            "static pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};\nstatic job_container_ops_t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_container_context = NULL;\nstatic int\t\t\tg_container_context_num = -1;\nstatic pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic job_container_ops_t\t*ops = NULL;\nstatic int\t\t\tg_container_context_num = -1;\n\nextern int container_g_delete(uint32_t job_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (job_container_init())\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_container_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].container_p_delete))(job_id);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "container_g_add_cont",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
    "lines": "213-226",
    "snippet": "extern int container_g_add_cont(uint32_t job_id, uint64_t cont_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (job_container_init())\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_container_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].container_p_add_cont))(job_id, cont_id);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/job_container_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static job_container_ops_t\t*ops = NULL;",
      "static int\t\t\tg_container_context_num = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "job_id",
            "cont_id"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "job_container_init",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "job_container_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
          "lines": "83-143",
          "snippet": "extern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};",
            "static job_container_ops_t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_container_context = NULL;",
            "static int\t\t\tg_container_context_num = -1;",
            "static pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};\nstatic job_container_ops_t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_container_context = NULL;\nstatic int\t\t\tg_container_context_num = -1;\nstatic pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic job_container_ops_t\t*ops = NULL;\nstatic int\t\t\tg_container_context_num = -1;\n\nextern int container_g_add_cont(uint32_t job_id, uint64_t cont_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (job_container_init())\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_container_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].container_p_add_cont))(job_id, cont_id);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "container_g_add_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
    "lines": "196-209",
    "snippet": "extern int container_g_add_pid(uint32_t job_id, pid_t pid, uid_t uid)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (job_container_init())\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_container_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].container_p_add_pid))(job_id, pid, uid);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/job_container_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static job_container_ops_t\t*ops = NULL;",
      "static int\t\t\tg_container_context_num = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "job_id",
            "pid",
            "uid"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "job_container_init",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "job_container_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
          "lines": "83-143",
          "snippet": "extern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};",
            "static job_container_ops_t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_container_context = NULL;",
            "static int\t\t\tg_container_context_num = -1;",
            "static pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};\nstatic job_container_ops_t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_container_context = NULL;\nstatic int\t\t\tg_container_context_num = -1;\nstatic pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic job_container_ops_t\t*ops = NULL;\nstatic int\t\t\tg_container_context_num = -1;\n\nextern int container_g_add_pid(uint32_t job_id, pid_t pid, uid_t uid)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (job_container_init())\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_container_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].container_p_add_pid))(job_id, pid, uid);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "container_g_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
    "lines": "178-191",
    "snippet": "extern int container_g_create(uint32_t job_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (job_container_init())\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_container_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].container_p_create))(job_id);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/job_container_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static job_container_ops_t\t*ops = NULL;",
      "static int\t\t\tg_container_context_num = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "job_id"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "job_container_init",
          "args": [],
          "line": 182
        },
        "resolved": true,
        "details": {
          "function_name": "job_container_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
          "lines": "83-143",
          "snippet": "extern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};",
            "static job_container_ops_t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_container_context = NULL;",
            "static int\t\t\tg_container_context_num = -1;",
            "static pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};\nstatic job_container_ops_t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_container_context = NULL;\nstatic int\t\t\tg_container_context_num = -1;\nstatic pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic job_container_ops_t\t*ops = NULL;\nstatic int\t\t\tg_container_context_num = -1;\n\nextern int container_g_create(uint32_t job_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (job_container_init())\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_container_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].container_p_create))(job_id);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "job_container_fini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
    "lines": "150-175",
    "snippet": "extern int job_container_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\tif (!g_container_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_container_context_num; i++) {\n\t\tif (g_container_context[i]) {\n\t\t\tif (plugin_context_destroy(g_container_context[i])\n\t\t\t    != SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_container_context);\n\tg_container_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/job_container_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static job_container_ops_t\t*ops = NULL;",
      "static plugin_context_t\t\t**g_container_context = NULL;",
      "static int\t\t\tg_container_context_num = -1;",
      "static pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
      "static bool init_run = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_container_context_lock"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "g_container_context"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plugin_context_destroy",
          "args": [
            "g_container_context[i]"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_container_context_lock"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic job_container_ops_t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_container_context = NULL;\nstatic int\t\t\tg_container_context_num = -1;\nstatic pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int job_container_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\tif (!g_container_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_container_context_num; i++) {\n\t\tif (g_container_context[i]) {\n\t\t\tif (plugin_context_destroy(g_container_context[i])\n\t\t\t    != SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_container_context);\n\tg_container_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\treturn rc;\n}"
  },
  {
    "function_name": "job_container_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
    "lines": "83-143",
    "snippet": "extern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/job_container_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};",
      "static job_container_ops_t\t*ops = NULL;",
      "static plugin_context_t\t\t**g_container_context = NULL;",
      "static int\t\t\tg_container_context_num = -1;",
      "static pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
      "static bool init_run = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "job_container_fini",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "job_container_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
          "lines": "150-175",
          "snippet": "extern int job_container_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\tif (!g_container_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_container_context_num; i++) {\n\t\tif (g_container_context[i]) {\n\t\t\tif (plugin_context_destroy(g_container_context[i])\n\t\t\t    != SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_container_context);\n\tg_container_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\treturn rc;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static job_container_ops_t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_container_context = NULL;",
            "static int\t\t\tg_container_context_num = -1;",
            "static pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic job_container_ops_t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_container_context = NULL;\nstatic int\t\t\tg_container_context_num = -1;\nstatic pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int job_container_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\tif (!g_container_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_container_context_num; i++) {\n\t\tif (g_container_context[i]) {\n\t\t\tif (plugin_context_destroy(g_container_context[i])\n\t\t\t    != SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_container_context);\n\tg_container_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "container_plugin_type"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_container_context_lock"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"cannot create %s context for %s\"",
            "plugin_type",
            "job_container"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plugin_context_create",
          "args": [
            "plugin_type",
            "job_container",
            "(void **)&ops[g_container_context_num]",
            "syms",
            "sizeof(syms)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup_printf",
          "args": [
            "\"job_container/%s\"",
            "job_container"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrncmp",
          "args": [
            "job_container",
            "\"job_container/\"",
            "14"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xrealloc",
          "args": [
            "g_container_context",
            "(sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1))"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xrealloc",
          "args": [
            "ops",
            "sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "job_container_plugin_list",
            "\",\"",
            "&last"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_get_job_container_plugin",
          "args": [],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_container_context_lock"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"container_p_create\",\n\t\"container_p_add_cont\",\n\t\"container_p_add_pid\",\n\t\"container_p_delete\",\n\t\"container_p_restore\",\n\t\"container_p_reconfig\",\n};\nstatic job_container_ops_t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_container_context = NULL;\nstatic int\t\t\tg_container_context_num = -1;\nstatic pthread_mutex_t\t\tg_container_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int job_container_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"job_container\";\n\tchar *container_plugin_type = NULL;\n\tchar *last = NULL, *job_container_plugin_list, *job_container = NULL;\n\n\tif (init_run && (g_container_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_container_context_lock);\n\n\tif (g_container_context_num >= 0)\n\t\tgoto done;\n\n\tcontainer_plugin_type = slurm_get_job_container_plugin();\n\tg_container_context_num = 0; /* mark it before anything else */\n\tif ((container_plugin_type == NULL) ||\n\t    (container_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tjob_container_plugin_list = container_plugin_type;\n\twhile ((job_container =\n\t\tstrtok_r(job_container_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(job_container_ops_t) *\n\t\t\t (g_container_context_num + 1));\n\t\txrealloc(g_container_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_container_context_num + 1)));\n\t\tif (xstrncmp(job_container, \"job_container/\", 14) == 0)\n\t\t\tjob_container += 14; /* backward compatibility */\n\t\tjob_container = xstrdup_printf(\"job_container/%s\",\n\t\t\t\t\t       job_container);\n\t\tg_container_context[g_container_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, job_container,\n\t\t\t\t(void **)&ops[g_container_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_container_context[g_container_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, job_container);\n\t\t\txfree(job_container);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(job_container);\n\t\tg_container_context_num++;\n\t\tjob_container_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_container_context_lock);\n\txfree(container_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tjob_container_fini();\n\n\treturn retval;\n}"
  }
]