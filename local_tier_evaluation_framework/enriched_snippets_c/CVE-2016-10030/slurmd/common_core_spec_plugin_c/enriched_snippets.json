[
  {
    "function_name": "core_spec_g_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
    "lines": "236-249",
    "snippet": "extern int core_spec_g_resume(uint64_t cont_id, uint16_t count)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (core_spec_g_init() != SLURM_SUCCESS)\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_core_spec_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].core_spec_p_resume))(cont_id, count);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static core_spec_ops_t\t\t*ops = NULL;",
      "static int\t\t\tg_core_spec_context_num = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "cont_id",
            "count"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "core_spec_g_init",
          "args": [],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "core_spec_g_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
          "lines": "77-137",
          "snippet": "extern int core_spec_g_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"core_spec\";\n\tchar *core_spec_plugin_type = NULL;\n\tchar *last = NULL, *core_spec_plugin_list, *core_spec = NULL;\n\n\tif (init_run && (g_core_spec_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\n\tif (g_core_spec_context_num >= 0)\n\t\tgoto done;\n\n\tcore_spec_plugin_type = slurm_get_core_spec_plugin();\n\tg_core_spec_context_num = 0; /* mark it before anything else */\n\tif ((core_spec_plugin_type == NULL) ||\n\t    (core_spec_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tcore_spec_plugin_list = core_spec_plugin_type;\n\twhile ((core_spec =\n\t\tstrtok_r(core_spec_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(core_spec_ops_t) *\n\t\t\t (g_core_spec_context_num + 1));\n\t\txrealloc(g_core_spec_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_core_spec_context_num + 1)));\n\t\tif (xstrncmp(core_spec, \"core_spec/\", 10) == 0)\n\t\t\tcore_spec += 10; /* backward compatibility */\n\t\tcore_spec = xstrdup_printf(\"core_spec/%s\",\n\t\t\t\t\t       core_spec);\n\t\tg_core_spec_context[g_core_spec_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, core_spec,\n\t\t\t\t(void **)&ops[g_core_spec_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_core_spec_context[g_core_spec_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, core_spec);\n\t\t\txfree(core_spec);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(core_spec);\n\t\tg_core_spec_context_num++;\n\t\tcore_spec_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\txfree(core_spec_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tcore_spec_g_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"core_spec_p_set\",\n\t\"core_spec_p_clear\",\n\t\"core_spec_p_suspend\",\n\t\"core_spec_p_resume\",\n};",
            "static core_spec_ops_t\t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_core_spec_context = NULL;",
            "static int\t\t\tg_core_spec_context_num = -1;",
            "static pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"core_spec_p_set\",\n\t\"core_spec_p_clear\",\n\t\"core_spec_p_suspend\",\n\t\"core_spec_p_resume\",\n};\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_core_spec_context = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\nstatic pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int core_spec_g_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"core_spec\";\n\tchar *core_spec_plugin_type = NULL;\n\tchar *last = NULL, *core_spec_plugin_list, *core_spec = NULL;\n\n\tif (init_run && (g_core_spec_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\n\tif (g_core_spec_context_num >= 0)\n\t\tgoto done;\n\n\tcore_spec_plugin_type = slurm_get_core_spec_plugin();\n\tg_core_spec_context_num = 0; /* mark it before anything else */\n\tif ((core_spec_plugin_type == NULL) ||\n\t    (core_spec_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tcore_spec_plugin_list = core_spec_plugin_type;\n\twhile ((core_spec =\n\t\tstrtok_r(core_spec_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(core_spec_ops_t) *\n\t\t\t (g_core_spec_context_num + 1));\n\t\txrealloc(g_core_spec_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_core_spec_context_num + 1)));\n\t\tif (xstrncmp(core_spec, \"core_spec/\", 10) == 0)\n\t\t\tcore_spec += 10; /* backward compatibility */\n\t\tcore_spec = xstrdup_printf(\"core_spec/%s\",\n\t\t\t\t\t       core_spec);\n\t\tg_core_spec_context[g_core_spec_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, core_spec,\n\t\t\t\t(void **)&ops[g_core_spec_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_core_spec_context[g_core_spec_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, core_spec);\n\t\t\txfree(core_spec);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(core_spec);\n\t\tg_core_spec_context_num++;\n\t\tcore_spec_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\txfree(core_spec_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tcore_spec_g_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\n\nextern int core_spec_g_resume(uint64_t cont_id, uint16_t count)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (core_spec_g_init() != SLURM_SUCCESS)\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_core_spec_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].core_spec_p_resume))(cont_id, count);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "core_spec_g_suspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
    "lines": "216-229",
    "snippet": "extern int core_spec_g_suspend(uint64_t cont_id, uint16_t count)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (core_spec_g_init() != SLURM_SUCCESS)\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_core_spec_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].core_spec_p_suspend))(cont_id, count);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static core_spec_ops_t\t\t*ops = NULL;",
      "static int\t\t\tg_core_spec_context_num = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "cont_id",
            "count"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "core_spec_g_init",
          "args": [],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "core_spec_g_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
          "lines": "77-137",
          "snippet": "extern int core_spec_g_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"core_spec\";\n\tchar *core_spec_plugin_type = NULL;\n\tchar *last = NULL, *core_spec_plugin_list, *core_spec = NULL;\n\n\tif (init_run && (g_core_spec_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\n\tif (g_core_spec_context_num >= 0)\n\t\tgoto done;\n\n\tcore_spec_plugin_type = slurm_get_core_spec_plugin();\n\tg_core_spec_context_num = 0; /* mark it before anything else */\n\tif ((core_spec_plugin_type == NULL) ||\n\t    (core_spec_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tcore_spec_plugin_list = core_spec_plugin_type;\n\twhile ((core_spec =\n\t\tstrtok_r(core_spec_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(core_spec_ops_t) *\n\t\t\t (g_core_spec_context_num + 1));\n\t\txrealloc(g_core_spec_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_core_spec_context_num + 1)));\n\t\tif (xstrncmp(core_spec, \"core_spec/\", 10) == 0)\n\t\t\tcore_spec += 10; /* backward compatibility */\n\t\tcore_spec = xstrdup_printf(\"core_spec/%s\",\n\t\t\t\t\t       core_spec);\n\t\tg_core_spec_context[g_core_spec_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, core_spec,\n\t\t\t\t(void **)&ops[g_core_spec_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_core_spec_context[g_core_spec_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, core_spec);\n\t\t\txfree(core_spec);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(core_spec);\n\t\tg_core_spec_context_num++;\n\t\tcore_spec_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\txfree(core_spec_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tcore_spec_g_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"core_spec_p_set\",\n\t\"core_spec_p_clear\",\n\t\"core_spec_p_suspend\",\n\t\"core_spec_p_resume\",\n};",
            "static core_spec_ops_t\t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_core_spec_context = NULL;",
            "static int\t\t\tg_core_spec_context_num = -1;",
            "static pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"core_spec_p_set\",\n\t\"core_spec_p_clear\",\n\t\"core_spec_p_suspend\",\n\t\"core_spec_p_resume\",\n};\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_core_spec_context = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\nstatic pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int core_spec_g_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"core_spec\";\n\tchar *core_spec_plugin_type = NULL;\n\tchar *last = NULL, *core_spec_plugin_list, *core_spec = NULL;\n\n\tif (init_run && (g_core_spec_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\n\tif (g_core_spec_context_num >= 0)\n\t\tgoto done;\n\n\tcore_spec_plugin_type = slurm_get_core_spec_plugin();\n\tg_core_spec_context_num = 0; /* mark it before anything else */\n\tif ((core_spec_plugin_type == NULL) ||\n\t    (core_spec_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tcore_spec_plugin_list = core_spec_plugin_type;\n\twhile ((core_spec =\n\t\tstrtok_r(core_spec_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(core_spec_ops_t) *\n\t\t\t (g_core_spec_context_num + 1));\n\t\txrealloc(g_core_spec_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_core_spec_context_num + 1)));\n\t\tif (xstrncmp(core_spec, \"core_spec/\", 10) == 0)\n\t\t\tcore_spec += 10; /* backward compatibility */\n\t\tcore_spec = xstrdup_printf(\"core_spec/%s\",\n\t\t\t\t\t       core_spec);\n\t\tg_core_spec_context[g_core_spec_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, core_spec,\n\t\t\t\t(void **)&ops[g_core_spec_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_core_spec_context[g_core_spec_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, core_spec);\n\t\t\txfree(core_spec);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(core_spec);\n\t\tg_core_spec_context_num++;\n\t\tcore_spec_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\txfree(core_spec_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tcore_spec_g_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\n\nextern int core_spec_g_suspend(uint64_t cont_id, uint16_t count)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (core_spec_g_init() != SLURM_SUCCESS)\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_core_spec_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].core_spec_p_suspend))(cont_id, count);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "core_spec_g_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
    "lines": "196-209",
    "snippet": "extern int core_spec_g_clear(uint64_t cont_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (core_spec_g_init() != SLURM_SUCCESS)\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_core_spec_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].core_spec_p_clear))(cont_id);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static core_spec_ops_t\t\t*ops = NULL;",
      "static int\t\t\tg_core_spec_context_num = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "cont_id"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "core_spec_g_init",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "core_spec_g_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
          "lines": "77-137",
          "snippet": "extern int core_spec_g_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"core_spec\";\n\tchar *core_spec_plugin_type = NULL;\n\tchar *last = NULL, *core_spec_plugin_list, *core_spec = NULL;\n\n\tif (init_run && (g_core_spec_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\n\tif (g_core_spec_context_num >= 0)\n\t\tgoto done;\n\n\tcore_spec_plugin_type = slurm_get_core_spec_plugin();\n\tg_core_spec_context_num = 0; /* mark it before anything else */\n\tif ((core_spec_plugin_type == NULL) ||\n\t    (core_spec_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tcore_spec_plugin_list = core_spec_plugin_type;\n\twhile ((core_spec =\n\t\tstrtok_r(core_spec_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(core_spec_ops_t) *\n\t\t\t (g_core_spec_context_num + 1));\n\t\txrealloc(g_core_spec_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_core_spec_context_num + 1)));\n\t\tif (xstrncmp(core_spec, \"core_spec/\", 10) == 0)\n\t\t\tcore_spec += 10; /* backward compatibility */\n\t\tcore_spec = xstrdup_printf(\"core_spec/%s\",\n\t\t\t\t\t       core_spec);\n\t\tg_core_spec_context[g_core_spec_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, core_spec,\n\t\t\t\t(void **)&ops[g_core_spec_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_core_spec_context[g_core_spec_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, core_spec);\n\t\t\txfree(core_spec);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(core_spec);\n\t\tg_core_spec_context_num++;\n\t\tcore_spec_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\txfree(core_spec_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tcore_spec_g_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"core_spec_p_set\",\n\t\"core_spec_p_clear\",\n\t\"core_spec_p_suspend\",\n\t\"core_spec_p_resume\",\n};",
            "static core_spec_ops_t\t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_core_spec_context = NULL;",
            "static int\t\t\tg_core_spec_context_num = -1;",
            "static pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"core_spec_p_set\",\n\t\"core_spec_p_clear\",\n\t\"core_spec_p_suspend\",\n\t\"core_spec_p_resume\",\n};\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_core_spec_context = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\nstatic pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int core_spec_g_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"core_spec\";\n\tchar *core_spec_plugin_type = NULL;\n\tchar *last = NULL, *core_spec_plugin_list, *core_spec = NULL;\n\n\tif (init_run && (g_core_spec_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\n\tif (g_core_spec_context_num >= 0)\n\t\tgoto done;\n\n\tcore_spec_plugin_type = slurm_get_core_spec_plugin();\n\tg_core_spec_context_num = 0; /* mark it before anything else */\n\tif ((core_spec_plugin_type == NULL) ||\n\t    (core_spec_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tcore_spec_plugin_list = core_spec_plugin_type;\n\twhile ((core_spec =\n\t\tstrtok_r(core_spec_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(core_spec_ops_t) *\n\t\t\t (g_core_spec_context_num + 1));\n\t\txrealloc(g_core_spec_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_core_spec_context_num + 1)));\n\t\tif (xstrncmp(core_spec, \"core_spec/\", 10) == 0)\n\t\t\tcore_spec += 10; /* backward compatibility */\n\t\tcore_spec = xstrdup_printf(\"core_spec/%s\",\n\t\t\t\t\t       core_spec);\n\t\tg_core_spec_context[g_core_spec_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, core_spec,\n\t\t\t\t(void **)&ops[g_core_spec_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_core_spec_context[g_core_spec_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, core_spec);\n\t\t\txfree(core_spec);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(core_spec);\n\t\tg_core_spec_context_num++;\n\t\tcore_spec_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\txfree(core_spec_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tcore_spec_g_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\n\nextern int core_spec_g_clear(uint64_t cont_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (core_spec_g_init() != SLURM_SUCCESS)\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_core_spec_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].core_spec_p_clear))(cont_id);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "core_spec_g_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
    "lines": "176-189",
    "snippet": "extern int core_spec_g_set(uint64_t cont_id, uint16_t core_count)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (core_spec_g_init() != SLURM_SUCCESS)\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_core_spec_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].core_spec_p_set))(cont_id, core_count);\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static core_spec_ops_t\t\t*ops = NULL;",
      "static int\t\t\tg_core_spec_context_num = -1;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "cont_id",
            "core_count"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "core_spec_g_init",
          "args": [],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "core_spec_g_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
          "lines": "77-137",
          "snippet": "extern int core_spec_g_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"core_spec\";\n\tchar *core_spec_plugin_type = NULL;\n\tchar *last = NULL, *core_spec_plugin_list, *core_spec = NULL;\n\n\tif (init_run && (g_core_spec_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\n\tif (g_core_spec_context_num >= 0)\n\t\tgoto done;\n\n\tcore_spec_plugin_type = slurm_get_core_spec_plugin();\n\tg_core_spec_context_num = 0; /* mark it before anything else */\n\tif ((core_spec_plugin_type == NULL) ||\n\t    (core_spec_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tcore_spec_plugin_list = core_spec_plugin_type;\n\twhile ((core_spec =\n\t\tstrtok_r(core_spec_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(core_spec_ops_t) *\n\t\t\t (g_core_spec_context_num + 1));\n\t\txrealloc(g_core_spec_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_core_spec_context_num + 1)));\n\t\tif (xstrncmp(core_spec, \"core_spec/\", 10) == 0)\n\t\t\tcore_spec += 10; /* backward compatibility */\n\t\tcore_spec = xstrdup_printf(\"core_spec/%s\",\n\t\t\t\t\t       core_spec);\n\t\tg_core_spec_context[g_core_spec_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, core_spec,\n\t\t\t\t(void **)&ops[g_core_spec_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_core_spec_context[g_core_spec_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, core_spec);\n\t\t\txfree(core_spec);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(core_spec);\n\t\tg_core_spec_context_num++;\n\t\tcore_spec_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\txfree(core_spec_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tcore_spec_g_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"core_spec_p_set\",\n\t\"core_spec_p_clear\",\n\t\"core_spec_p_suspend\",\n\t\"core_spec_p_resume\",\n};",
            "static core_spec_ops_t\t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_core_spec_context = NULL;",
            "static int\t\t\tg_core_spec_context_num = -1;",
            "static pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"core_spec_p_set\",\n\t\"core_spec_p_clear\",\n\t\"core_spec_p_suspend\",\n\t\"core_spec_p_resume\",\n};\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_core_spec_context = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\nstatic pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int core_spec_g_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"core_spec\";\n\tchar *core_spec_plugin_type = NULL;\n\tchar *last = NULL, *core_spec_plugin_list, *core_spec = NULL;\n\n\tif (init_run && (g_core_spec_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\n\tif (g_core_spec_context_num >= 0)\n\t\tgoto done;\n\n\tcore_spec_plugin_type = slurm_get_core_spec_plugin();\n\tg_core_spec_context_num = 0; /* mark it before anything else */\n\tif ((core_spec_plugin_type == NULL) ||\n\t    (core_spec_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tcore_spec_plugin_list = core_spec_plugin_type;\n\twhile ((core_spec =\n\t\tstrtok_r(core_spec_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(core_spec_ops_t) *\n\t\t\t (g_core_spec_context_num + 1));\n\t\txrealloc(g_core_spec_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_core_spec_context_num + 1)));\n\t\tif (xstrncmp(core_spec, \"core_spec/\", 10) == 0)\n\t\t\tcore_spec += 10; /* backward compatibility */\n\t\tcore_spec = xstrdup_printf(\"core_spec/%s\",\n\t\t\t\t\t       core_spec);\n\t\tg_core_spec_context[g_core_spec_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, core_spec,\n\t\t\t\t(void **)&ops[g_core_spec_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_core_spec_context[g_core_spec_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, core_spec);\n\t\t\txfree(core_spec);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(core_spec);\n\t\tg_core_spec_context_num++;\n\t\tcore_spec_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\txfree(core_spec_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tcore_spec_g_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\n\nextern int core_spec_g_set(uint64_t cont_id, uint16_t core_count)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (core_spec_g_init() != SLURM_SUCCESS)\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_core_spec_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].core_spec_p_set))(cont_id, core_count);\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "core_spec_g_fini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
    "lines": "144-169",
    "snippet": "extern int core_spec_g_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\tif (!g_core_spec_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_core_spec_context_num; i++) {\n\t\tif (g_core_spec_context[i]) {\n\t\t\tif (plugin_context_destroy(g_core_spec_context[i])\n\t\t\t    != SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_core_spec_context);\n\tg_core_spec_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static core_spec_ops_t\t\t*ops = NULL;",
      "static plugin_context_t\t\t**g_core_spec_context = NULL;",
      "static int\t\t\tg_core_spec_context_num = -1;",
      "static pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
      "static bool init_run = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_core_spec_context_lock"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "g_core_spec_context"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plugin_context_destroy",
          "args": [
            "g_core_spec_context[i]"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_core_spec_context_lock"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_core_spec_context = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\nstatic pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int core_spec_g_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\tif (!g_core_spec_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_core_spec_context_num; i++) {\n\t\tif (g_core_spec_context[i]) {\n\t\t\tif (plugin_context_destroy(g_core_spec_context[i])\n\t\t\t    != SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_core_spec_context);\n\tg_core_spec_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\treturn rc;\n}"
  },
  {
    "function_name": "core_spec_g_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
    "lines": "77-137",
    "snippet": "extern int core_spec_g_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"core_spec\";\n\tchar *core_spec_plugin_type = NULL;\n\tchar *last = NULL, *core_spec_plugin_list, *core_spec = NULL;\n\n\tif (init_run && (g_core_spec_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\n\tif (g_core_spec_context_num >= 0)\n\t\tgoto done;\n\n\tcore_spec_plugin_type = slurm_get_core_spec_plugin();\n\tg_core_spec_context_num = 0; /* mark it before anything else */\n\tif ((core_spec_plugin_type == NULL) ||\n\t    (core_spec_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tcore_spec_plugin_list = core_spec_plugin_type;\n\twhile ((core_spec =\n\t\tstrtok_r(core_spec_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(core_spec_ops_t) *\n\t\t\t (g_core_spec_context_num + 1));\n\t\txrealloc(g_core_spec_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_core_spec_context_num + 1)));\n\t\tif (xstrncmp(core_spec, \"core_spec/\", 10) == 0)\n\t\t\tcore_spec += 10; /* backward compatibility */\n\t\tcore_spec = xstrdup_printf(\"core_spec/%s\",\n\t\t\t\t\t       core_spec);\n\t\tg_core_spec_context[g_core_spec_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, core_spec,\n\t\t\t\t(void **)&ops[g_core_spec_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_core_spec_context[g_core_spec_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, core_spec);\n\t\t\txfree(core_spec);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(core_spec);\n\t\tg_core_spec_context_num++;\n\t\tcore_spec_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\txfree(core_spec_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tcore_spec_g_fini();\n\n\treturn retval;\n}",
    "includes": [
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *syms[] = {\n\t\"core_spec_p_set\",\n\t\"core_spec_p_clear\",\n\t\"core_spec_p_suspend\",\n\t\"core_spec_p_resume\",\n};",
      "static core_spec_ops_t\t\t*ops = NULL;",
      "static plugin_context_t\t\t**g_core_spec_context = NULL;",
      "static int\t\t\tg_core_spec_context_num = -1;",
      "static pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
      "static bool init_run = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "core_spec_g_fini",
          "args": [],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "core_spec_g_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
          "lines": "144-169",
          "snippet": "extern int core_spec_g_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\tif (!g_core_spec_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_core_spec_context_num; i++) {\n\t\tif (g_core_spec_context[i]) {\n\t\t\tif (plugin_context_destroy(g_core_spec_context[i])\n\t\t\t    != SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_core_spec_context);\n\tg_core_spec_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\treturn rc;\n}",
          "includes": [
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static core_spec_ops_t\t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_core_spec_context = NULL;",
            "static int\t\t\tg_core_spec_context_num = -1;",
            "static pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_core_spec_context = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\nstatic pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int core_spec_g_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\tif (!g_core_spec_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_core_spec_context_num; i++) {\n\t\tif (g_core_spec_context[i]) {\n\t\t\tif (plugin_context_destroy(g_core_spec_context[i])\n\t\t\t    != SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_core_spec_context);\n\tg_core_spec_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "core_spec_plugin_type"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_core_spec_context_lock"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"cannot create %s context for %s\"",
            "plugin_type",
            "core_spec"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plugin_context_create",
          "args": [
            "plugin_type",
            "core_spec",
            "(void **)&ops[g_core_spec_context_num]",
            "syms",
            "sizeof(syms)"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup_printf",
          "args": [
            "\"core_spec/%s\"",
            "core_spec"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrncmp",
          "args": [
            "core_spec",
            "\"core_spec/\"",
            "10"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xrealloc",
          "args": [
            "g_core_spec_context",
            "(sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_core_spec_context_num + 1))"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xrealloc",
          "args": [
            "ops",
            "sizeof(core_spec_ops_t) *\n\t\t\t (g_core_spec_context_num + 1)"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "core_spec_plugin_list",
            "\",\"",
            "&last"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_get_core_spec_plugin",
          "args": [],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_core_spec_context_lock"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"core_spec_p_set\",\n\t\"core_spec_p_clear\",\n\t\"core_spec_p_suspend\",\n\t\"core_spec_p_resume\",\n};\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_core_spec_context = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\nstatic pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int core_spec_g_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"core_spec\";\n\tchar *core_spec_plugin_type = NULL;\n\tchar *last = NULL, *core_spec_plugin_list, *core_spec = NULL;\n\n\tif (init_run && (g_core_spec_context_num >= 0))\n\t\treturn retval;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\n\tif (g_core_spec_context_num >= 0)\n\t\tgoto done;\n\n\tcore_spec_plugin_type = slurm_get_core_spec_plugin();\n\tg_core_spec_context_num = 0; /* mark it before anything else */\n\tif ((core_spec_plugin_type == NULL) ||\n\t    (core_spec_plugin_type[0] == '\\0'))\n\t\tgoto done;\n\n\tcore_spec_plugin_list = core_spec_plugin_type;\n\twhile ((core_spec =\n\t\tstrtok_r(core_spec_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(core_spec_ops_t) *\n\t\t\t (g_core_spec_context_num + 1));\n\t\txrealloc(g_core_spec_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_core_spec_context_num + 1)));\n\t\tif (xstrncmp(core_spec, \"core_spec/\", 10) == 0)\n\t\t\tcore_spec += 10; /* backward compatibility */\n\t\tcore_spec = xstrdup_printf(\"core_spec/%s\",\n\t\t\t\t\t       core_spec);\n\t\tg_core_spec_context[g_core_spec_context_num] =\n\t\t\tplugin_context_create(\n\t\t\t\tplugin_type, core_spec,\n\t\t\t\t(void **)&ops[g_core_spec_context_num],\n\t\t\t\tsyms, sizeof(syms));\n\t\tif (!g_core_spec_context[g_core_spec_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, core_spec);\n\t\t\txfree(core_spec);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(core_spec);\n\t\tg_core_spec_context_num++;\n\t\tcore_spec_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\txfree(core_spec_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tcore_spec_g_fini();\n\n\treturn retval;\n}"
  }
]