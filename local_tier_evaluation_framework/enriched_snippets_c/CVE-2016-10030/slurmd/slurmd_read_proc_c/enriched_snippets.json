[
  {
    "function_name": "read_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/read_proc.c",
    "lines": "234-350",
    "snippet": "extern int \nread_proc(void) \n{\n\tDIR *proc_fs;\n\tstruct dirent *proc_ent;\n\tint proc_fd, proc_stat_size, found, n;\n\tchar proc_name[22], *proc_stat;\n\tstruct stat buffer;\n\tint uid, session;\n\tlong resident_set_size;\n\tunsigned long time;\n\tstruct sess_record *s_ptr, *sess_free;\n\n\t/* Initialization */\n\tif (hertz == 0) {\n\t\thertz = sysconf(_SC_CLK_TCK);\n\t\tif (hertz == 0) {\n\t\t\terror (\"read_proc: unable to get clock rate\");\n\t\t\thertz = 100;\t/* default on many systems */\n\t\t} \n\t} \n\tproc_stat_size = BUF_SIZE;\n\tproc_stat = (char *) xmalloc(proc_stat_size);\n\tproc_fs = opendir(\"/proc\");\n\tif (proc_fs == NULL) {\n\t\terror (\"read_proc: opendir unable to open /proc %m\");\n\t\treturn errno;\n\t}\n\titeration++;\n\n\t/* Read the entries */\n\twhile ((proc_ent = readdir(proc_fs)) != (struct dirent *)NULL) {\n\t\tif (proc_ent->d_name[0] < '0') \n\t\t\tcontinue;\t/* Not \"real\" process ID */\n\t\tif (proc_ent->d_name[0] > '9') \n\t\t\tcontinue;\t/* Not \"real\" process ID */\n\t\tif (strlen(proc_ent->d_name) > 10) {\n\t\t\t/* make proc_name longer and change this value */\n\t\t\terror (\"read_proc: process ID number too long\");\n\t\t\tcontinue;\n\t\t} \n\t\tsprintf (proc_name, \"/proc/%s/stat\", proc_ent->d_name);\n\t\tproc_fd = open (proc_name, O_RDONLY, 0);\n\t\tif (proc_fd == -1) \n\t\t\tcontinue;  /* process is now gone */\n\t\twhile ((n = read(proc_fd, proc_stat, proc_stat_size)) > 0) {\n\t\t\tif (n < (proc_stat_size-1))\n\t\t\t\tbreak;\n\t\t\tproc_stat_size += BUF_SIZE;\n\t\t\txrealloc(proc_stat, proc_stat_size);\n\t\t\tif (lseek(proc_fd, (off_t) 0, SEEK_SET) != 0) \n\t\t\t\tbreak;\n\t\t}\n\t\tfstat(proc_fd, &buffer);\n\t\tclose(proc_fd);\n\t\tif (n <= 0) \n\t\t\tcontinue;\n\t\tuid = buffer.st_uid;\n\t\t_parse_proc_stat(proc_stat, &session, &time, \n\t\t\t\t &resident_set_size);\n\t\tfound = 0;\n\t\tsess_free = NULL;\n\t\tfor (s_ptr=session_ptr; s_ptr<(session_ptr+sess_rec_cnt); \n\t\t     s_ptr++) {\n\t\t\tif (s_ptr->iteration == -1) {\n\t\t\t\tif (sess_free == NULL) \n\t\t\t\t\tsess_free = s_ptr;\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif (s_ptr->session != session) \n\t\t\t\tcontinue;\n\t\t\tif (s_ptr->iteration != iteration) {\n\t\t\t\ts_ptr->iteration = iteration;\n\t\t\t\ts_ptr->processes = 0;\n\t\t\t\ts_ptr->resident_set_size       = 0;\n\t\t\t\ts_ptr->time      = 0;\n\t\t\t} \n\t\t\ts_ptr->processes += 1;\n\t\t\ts_ptr->resident_set_size       += resident_set_size;\n\t\t\ts_ptr->time      += time;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t} \n\t\tif (found == 0) {\n\t\t\tif (sess_free == NULL) {\n\t\t\t\t_init_proc();\n\t\t\t\tfor (s_ptr=session_ptr; \n\t\t\t\t     s_ptr<(session_ptr+sess_rec_cnt); \n\t\t\t\t     s_ptr++) {\n\t\t\t\t\tif (s_ptr->iteration != -1) \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tsess_free = s_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\t\t\t\tif (sess_free == NULL) {\n\t\t\t\t\terror (\"read_proc: Internal error\");\n\t\t\t\t\treturn EINVAL;\n\t\t\t\t} \n\t\t\t} \n\t\t\tsess_free->iteration = iteration;\n\t\t\tsess_free->processes = 1;\n\t\t\tsess_free->resident_set_size       = resident_set_size;\n\t\t\tsess_free->session   = session;\n\t\t\tsess_free->time      = time;\n\t\t\tsess_free->uid       = uid;\n\t\t} \n\t}\n\n\t/* Termination */\n\txfree(proc_stat);\n\tclosedir(proc_fs);\n\tfor (s_ptr=session_ptr; s_ptr<(session_ptr+sess_rec_cnt); s_ptr++) {\n\t\tif (s_ptr->iteration != iteration) \n\t\t\ts_ptr->iteration=-1;   /* Defunct */\n\t} \n\treturn 0;\n}",
    "includes": [
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/log.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define BUF_SIZE 1024"
    ],
    "globals_used": [
      "int hertz = 0;",
      "int iteration = -1;",
      "int sess_rec_cnt = 0;",
      "struct sess_record *session_ptr;",
      "static void _init_proc(void);",
      "static int _parse_proc_stat(char* proc_stat, int *session, \n\t\t\t    unsigned long *time, long *resident_set_size);",
      "extern int read_proc(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "closedir",
          "args": [
            "proc_fs"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "proc_stat"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"read_proc: Internal error\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_init_proc",
          "args": [],
          "line": 319
        },
        "resolved": true,
        "details": {
          "function_name": "_init_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/read_proc.c",
          "lines": "150-167",
          "snippet": "static void \n_init_proc (void) \n{\n\tstruct sess_record *s_ptr;\n\n\tif (sess_rec_cnt == 0)\n\t\tsession_ptr = (struct sess_record *) \n\t\t\txmalloc (sizeof (struct sess_record) * SESSION_RECS);\n\telse\n\t\txrealloc (session_ptr, sizeof (struct sess_record) * \n\t\t\t\t(sess_rec_cnt+SESSION_RECS));\n\n\tfor (s_ptr= (session_ptr+sess_rec_cnt); \n\t     s_ptr<(session_ptr+sess_rec_cnt+SESSION_RECS); s_ptr++) {\n\t\ts_ptr->iteration = -1;\n\t} \n\tsess_rec_cnt += SESSION_RECS;\n}",
          "includes": [
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/log.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [
            "#define SESSION_RECS 50"
          ],
          "globals_used": [
            "int iteration = -1;",
            "int sess_rec_cnt = 0;",
            "struct sess_record *session_ptr;",
            "static void _init_proc(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <stdlib.h>\n#  include \"config.h\"\n\n#define SESSION_RECS 50\n\nint iteration = -1;\nint sess_rec_cnt = 0;\nstruct sess_record *session_ptr;\nstatic void _init_proc(void);\n\nstatic void \n_init_proc (void) \n{\n\tstruct sess_record *s_ptr;\n\n\tif (sess_rec_cnt == 0)\n\t\tsession_ptr = (struct sess_record *) \n\t\t\txmalloc (sizeof (struct sess_record) * SESSION_RECS);\n\telse\n\t\txrealloc (session_ptr, sizeof (struct sess_record) * \n\t\t\t\t(sess_rec_cnt+SESSION_RECS));\n\n\tfor (s_ptr= (session_ptr+sess_rec_cnt); \n\t     s_ptr<(session_ptr+sess_rec_cnt+SESSION_RECS); s_ptr++) {\n\t\ts_ptr->iteration = -1;\n\t} \n\tsess_rec_cnt += SESSION_RECS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_parse_proc_stat",
          "args": [
            "proc_stat",
            "&session",
            "&time",
            "&resident_set_size"
          ],
          "line": 292
        },
        "resolved": true,
        "details": {
          "function_name": "_parse_proc_stat",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/read_proc.c",
          "lines": "179-227",
          "snippet": "static int \n_parse_proc_stat(char* proc_stat, int *session, unsigned long *time, \n\t\t long *resident_set_size)\n{\n\tint pid, ppid, pgrp, tty, tpgid;\n\tchar cmd[16], state[1];\n\tlong unsigned flags, min_flt, cmin_flt, maj_flt, cmaj_flt;\n\tlong unsigned utime, stime;\n\tlong cutime, cstime, priority, nice, timeout, it_real_value;\n\tlong unsigned start_time, vsize;\n\tlong unsigned resident_set_size_rlim, start_code, end_code;\n\tlong unsigned start_stack, kstk_esp, kstk_eip;\n\tlong unsigned w_chan, n_swap, sn_swap;\n\tint  l_proc;\n\tint num;\n\tchar *str_ptr;\n    \n\t/* split into \"PID (cmd\" and \"<rest>\" */\n\tstr_ptr = (char *)strrchr(proc_stat, ')'); \n\t*str_ptr = '\\0';\t\t/* replace trailing ')' with NULL */\n\t/* parse these two strings separately, skipping the leading \"(\". */\n\tmemset (cmd, 0, sizeof(cmd));\n\tsscanf (proc_stat, \"%d (%15c\", &pid, cmd);   /* comm[16] in kernel */\n\tnum = sscanf(str_ptr + 2,\t\t/* skip space after ')' too */\n\t\t\"%c \"\n\t\t\"%d %d %d %d %d \"\n\t\t\"%lu %lu %lu %lu %lu %lu %lu \"\n\t\t\"%ld %ld %ld %ld %ld %ld \"\n\t\t\"%lu %lu \"\n\t\t\"%ld \"\n\t\t\"%lu %lu %lu \"\n\t\t\"%lu %lu %lu \"\n\t\t\"%*s %*s %*s %*s \" /* discard, no RT signals & Linux 2.1 used hex */\n\t\t\"%lu %lu %lu %*d %d\",\n\t\tstate,\n\t\t&ppid, &pgrp, session, &tty, &tpgid,\n\t\t&flags, &min_flt, &cmin_flt, &maj_flt, &cmaj_flt, &utime, &stime, \n\t\t&cutime, &cstime, &priority, &nice, &timeout, &it_real_value,\n\t\t&start_time, &vsize,\n\t\tresident_set_size,\n\t\t&resident_set_size_rlim, &start_code, &end_code, \n\t\t&start_stack, &kstk_esp, &kstk_eip,\n/*\t\t&signal, &blocked, &sig_ignore, &sig_catch, */ /* can't use */\n\t\t&w_chan, &n_swap, &sn_swap /* , &Exit_signal  */, &l_proc);\n\tif (num < 13)\n\t\terror(\"/proc entry too short (%s)\", proc_stat);\n\t*time = (utime + stime) / hertz;\n\treturn 0;\n}",
          "includes": [
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/log.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int hertz = 0;",
            "static int _parse_proc_stat(char* proc_stat, int *session, \n\t\t\t    unsigned long *time, long *resident_set_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <stdlib.h>\n#  include \"config.h\"\n\nint hertz = 0;\nstatic int _parse_proc_stat(char* proc_stat, int *session, \n\t\t\t    unsigned long *time, long *resident_set_size);\n\nstatic int \n_parse_proc_stat(char* proc_stat, int *session, unsigned long *time, \n\t\t long *resident_set_size)\n{\n\tint pid, ppid, pgrp, tty, tpgid;\n\tchar cmd[16], state[1];\n\tlong unsigned flags, min_flt, cmin_flt, maj_flt, cmaj_flt;\n\tlong unsigned utime, stime;\n\tlong cutime, cstime, priority, nice, timeout, it_real_value;\n\tlong unsigned start_time, vsize;\n\tlong unsigned resident_set_size_rlim, start_code, end_code;\n\tlong unsigned start_stack, kstk_esp, kstk_eip;\n\tlong unsigned w_chan, n_swap, sn_swap;\n\tint  l_proc;\n\tint num;\n\tchar *str_ptr;\n    \n\t/* split into \"PID (cmd\" and \"<rest>\" */\n\tstr_ptr = (char *)strrchr(proc_stat, ')'); \n\t*str_ptr = '\\0';\t\t/* replace trailing ')' with NULL */\n\t/* parse these two strings separately, skipping the leading \"(\". */\n\tmemset (cmd, 0, sizeof(cmd));\n\tsscanf (proc_stat, \"%d (%15c\", &pid, cmd);   /* comm[16] in kernel */\n\tnum = sscanf(str_ptr + 2,\t\t/* skip space after ')' too */\n\t\t\"%c \"\n\t\t\"%d %d %d %d %d \"\n\t\t\"%lu %lu %lu %lu %lu %lu %lu \"\n\t\t\"%ld %ld %ld %ld %ld %ld \"\n\t\t\"%lu %lu \"\n\t\t\"%ld \"\n\t\t\"%lu %lu %lu \"\n\t\t\"%lu %lu %lu \"\n\t\t\"%*s %*s %*s %*s \" /* discard, no RT signals & Linux 2.1 used hex */\n\t\t\"%lu %lu %lu %*d %d\",\n\t\tstate,\n\t\t&ppid, &pgrp, session, &tty, &tpgid,\n\t\t&flags, &min_flt, &cmin_flt, &maj_flt, &cmaj_flt, &utime, &stime, \n\t\t&cutime, &cstime, &priority, &nice, &timeout, &it_real_value,\n\t\t&start_time, &vsize,\n\t\tresident_set_size,\n\t\t&resident_set_size_rlim, &start_code, &end_code, \n\t\t&start_stack, &kstk_esp, &kstk_eip,\n/*\t\t&signal, &blocked, &sig_ignore, &sig_catch, */ /* can't use */\n\t\t&w_chan, &n_swap, &sn_swap /* , &Exit_signal  */, &l_proc);\n\tif (num < 13)\n\t\terror(\"/proc entry too short (%s)\", proc_stat);\n\t*time = (utime + stime) / hertz;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "proc_fd"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "_file_bcast_close_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "3635-3640",
          "snippet": "static void _file_bcast_close_file(file_bcast_info_t *key)\n{\n\t_fb_wrlock();\n\tlist_delete_all(file_bcast_list, _bcast_find_in_list, key);\n\t_fb_wrunlock();\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _job_limits_match(void *x, void *key);",
            "static int  _step_limits_match(void *x, void *key);",
            "static int  _file_bcast_register_file(slurm_msg_t *msg,\n\t\t\t\t      file_bcast_info_t *key);",
            "static List file_bcast_list = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic int  _job_limits_match(void *x, void *key);\nstatic int  _step_limits_match(void *x, void *key);\nstatic int  _file_bcast_register_file(slurm_msg_t *msg,\n\t\t\t\t      file_bcast_info_t *key);\nstatic List file_bcast_list = NULL;\n\nstatic void _file_bcast_close_file(file_bcast_info_t *key)\n{\n\t_fb_wrlock();\n\tlist_delete_all(file_bcast_list, _bcast_find_in_list, key);\n\t_fb_wrunlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "fstat",
          "args": [
            "proc_fd",
            "&buffer"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lseek",
          "args": [
            "proc_fd",
            "(off_t) 0",
            "SEEK_SET"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xrealloc",
          "args": [
            "proc_stat",
            "proc_stat_size"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "proc_fd",
            "proc_stat",
            "proc_stat_size"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "_file_read_content",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcgroup.c",
          "lines": "1149-1197",
          "snippet": "int _file_read_content(char* file_path, char** content, size_t *csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\tsize_t fsize;\n\tchar* buf;\n\n\tfstatus = XCGROUP_ERROR;\n\n\t/* check input pointers */\n\tif (content == NULL || csize == NULL)\n\t\treturn fstatus;\n\n\t/* open file for reading */\n\tfd = open(file_path, O_RDONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for reading : %m\",\n\t\t\t__func__, file_path);\n\t\treturn fstatus;\n\t}\n\n\t/* get file size */\n\tfsize=_file_getsize(fd);\n\tif (fsize == -1) {\n\t\tclose(fd);\n\t\treturn fstatus;\n\t}\n\n\t/* read file contents */\n\tbuf = (char*) xmalloc((fsize+1)*sizeof(char));\n\tbuf[fsize]='\\0';\n\tdo {\n\t\trc = read(fd, buf, fsize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* set output values */\n\tif (rc >= 0) {\n\t\t*content = buf;\n\t\t*csize = rc;\n\t\tfstatus = XCGROUP_SUCCESS;\n\t}\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}",
          "includes": [
            "#include \"xcgroup.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "size_t _file_getsize(int fd);",
            "int _file_read_content(char* file_path, char** content, size_t *csize);",
            "int _file_write_content(char* file_path, char* content, size_t csize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcgroup.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <sys/mount.h>\n#include <dirent.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nsize_t _file_getsize(int fd);\nint _file_read_content(char* file_path, char** content, size_t *csize);\nint _file_write_content(char* file_path, char* content, size_t csize);\n\nint _file_read_content(char* file_path, char** content, size_t *csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\tsize_t fsize;\n\tchar* buf;\n\n\tfstatus = XCGROUP_ERROR;\n\n\t/* check input pointers */\n\tif (content == NULL || csize == NULL)\n\t\treturn fstatus;\n\n\t/* open file for reading */\n\tfd = open(file_path, O_RDONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for reading : %m\",\n\t\t\t__func__, file_path);\n\t\treturn fstatus;\n\t}\n\n\t/* get file size */\n\tfsize=_file_getsize(fd);\n\tif (fsize == -1) {\n\t\tclose(fd);\n\t\treturn fstatus;\n\t}\n\n\t/* read file contents */\n\tbuf = (char*) xmalloc((fsize+1)*sizeof(char));\n\tbuf[fsize]='\\0';\n\tdo {\n\t\trc = read(fd, buf, fsize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* set output values */\n\tif (rc >= 0) {\n\t\t*content = buf;\n\t\t*csize = rc;\n\t\tfstatus = XCGROUP_SUCCESS;\n\t}\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "proc_name",
            "O_RDONLY",
            "0"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "proc_name",
            "\"/proc/%s/stat\"",
            "proc_ent->d_name"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"read_proc: process ID number too long\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "proc_ent->d_name"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "readdir",
          "args": [
            "proc_fs"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"read_proc: opendir unable to open /proc %m\""
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "opendir",
          "args": [
            "\"/proc\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "proc_stat_size"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"read_proc: unable to get clock rate\""
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sysconf",
          "args": [
            "_SC_CLK_TCK"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <stdlib.h>\n#  include \"config.h\"\n\n#define BUF_SIZE 1024\n\nint hertz = 0;\nint iteration = -1;\nint sess_rec_cnt = 0;\nstruct sess_record *session_ptr;\nstatic void _init_proc(void);\nstatic int _parse_proc_stat(char* proc_stat, int *session, \n\t\t\t    unsigned long *time, long *resident_set_size);\nextern int read_proc(void);\n\nextern int \nread_proc(void) \n{\n\tDIR *proc_fs;\n\tstruct dirent *proc_ent;\n\tint proc_fd, proc_stat_size, found, n;\n\tchar proc_name[22], *proc_stat;\n\tstruct stat buffer;\n\tint uid, session;\n\tlong resident_set_size;\n\tunsigned long time;\n\tstruct sess_record *s_ptr, *sess_free;\n\n\t/* Initialization */\n\tif (hertz == 0) {\n\t\thertz = sysconf(_SC_CLK_TCK);\n\t\tif (hertz == 0) {\n\t\t\terror (\"read_proc: unable to get clock rate\");\n\t\t\thertz = 100;\t/* default on many systems */\n\t\t} \n\t} \n\tproc_stat_size = BUF_SIZE;\n\tproc_stat = (char *) xmalloc(proc_stat_size);\n\tproc_fs = opendir(\"/proc\");\n\tif (proc_fs == NULL) {\n\t\terror (\"read_proc: opendir unable to open /proc %m\");\n\t\treturn errno;\n\t}\n\titeration++;\n\n\t/* Read the entries */\n\twhile ((proc_ent = readdir(proc_fs)) != (struct dirent *)NULL) {\n\t\tif (proc_ent->d_name[0] < '0') \n\t\t\tcontinue;\t/* Not \"real\" process ID */\n\t\tif (proc_ent->d_name[0] > '9') \n\t\t\tcontinue;\t/* Not \"real\" process ID */\n\t\tif (strlen(proc_ent->d_name) > 10) {\n\t\t\t/* make proc_name longer and change this value */\n\t\t\terror (\"read_proc: process ID number too long\");\n\t\t\tcontinue;\n\t\t} \n\t\tsprintf (proc_name, \"/proc/%s/stat\", proc_ent->d_name);\n\t\tproc_fd = open (proc_name, O_RDONLY, 0);\n\t\tif (proc_fd == -1) \n\t\t\tcontinue;  /* process is now gone */\n\t\twhile ((n = read(proc_fd, proc_stat, proc_stat_size)) > 0) {\n\t\t\tif (n < (proc_stat_size-1))\n\t\t\t\tbreak;\n\t\t\tproc_stat_size += BUF_SIZE;\n\t\t\txrealloc(proc_stat, proc_stat_size);\n\t\t\tif (lseek(proc_fd, (off_t) 0, SEEK_SET) != 0) \n\t\t\t\tbreak;\n\t\t}\n\t\tfstat(proc_fd, &buffer);\n\t\tclose(proc_fd);\n\t\tif (n <= 0) \n\t\t\tcontinue;\n\t\tuid = buffer.st_uid;\n\t\t_parse_proc_stat(proc_stat, &session, &time, \n\t\t\t\t &resident_set_size);\n\t\tfound = 0;\n\t\tsess_free = NULL;\n\t\tfor (s_ptr=session_ptr; s_ptr<(session_ptr+sess_rec_cnt); \n\t\t     s_ptr++) {\n\t\t\tif (s_ptr->iteration == -1) {\n\t\t\t\tif (sess_free == NULL) \n\t\t\t\t\tsess_free = s_ptr;\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif (s_ptr->session != session) \n\t\t\t\tcontinue;\n\t\t\tif (s_ptr->iteration != iteration) {\n\t\t\t\ts_ptr->iteration = iteration;\n\t\t\t\ts_ptr->processes = 0;\n\t\t\t\ts_ptr->resident_set_size       = 0;\n\t\t\t\ts_ptr->time      = 0;\n\t\t\t} \n\t\t\ts_ptr->processes += 1;\n\t\t\ts_ptr->resident_set_size       += resident_set_size;\n\t\t\ts_ptr->time      += time;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t} \n\t\tif (found == 0) {\n\t\t\tif (sess_free == NULL) {\n\t\t\t\t_init_proc();\n\t\t\t\tfor (s_ptr=session_ptr; \n\t\t\t\t     s_ptr<(session_ptr+sess_rec_cnt); \n\t\t\t\t     s_ptr++) {\n\t\t\t\t\tif (s_ptr->iteration != -1) \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tsess_free = s_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\t\t\t\tif (sess_free == NULL) {\n\t\t\t\t\terror (\"read_proc: Internal error\");\n\t\t\t\t\treturn EINVAL;\n\t\t\t\t} \n\t\t\t} \n\t\t\tsess_free->iteration = iteration;\n\t\t\tsess_free->processes = 1;\n\t\t\tsess_free->resident_set_size       = resident_set_size;\n\t\t\tsess_free->session   = session;\n\t\t\tsess_free->time      = time;\n\t\t\tsess_free->uid       = uid;\n\t\t} \n\t}\n\n\t/* Termination */\n\txfree(proc_stat);\n\tclosedir(proc_fs);\n\tfor (s_ptr=session_ptr; s_ptr<(session_ptr+sess_rec_cnt); s_ptr++) {\n\t\tif (s_ptr->iteration != iteration) \n\t\t\ts_ptr->iteration=-1;   /* Defunct */\n\t} \n\treturn 0;\n}"
  },
  {
    "function_name": "_parse_proc_stat",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/read_proc.c",
    "lines": "179-227",
    "snippet": "static int \n_parse_proc_stat(char* proc_stat, int *session, unsigned long *time, \n\t\t long *resident_set_size)\n{\n\tint pid, ppid, pgrp, tty, tpgid;\n\tchar cmd[16], state[1];\n\tlong unsigned flags, min_flt, cmin_flt, maj_flt, cmaj_flt;\n\tlong unsigned utime, stime;\n\tlong cutime, cstime, priority, nice, timeout, it_real_value;\n\tlong unsigned start_time, vsize;\n\tlong unsigned resident_set_size_rlim, start_code, end_code;\n\tlong unsigned start_stack, kstk_esp, kstk_eip;\n\tlong unsigned w_chan, n_swap, sn_swap;\n\tint  l_proc;\n\tint num;\n\tchar *str_ptr;\n    \n\t/* split into \"PID (cmd\" and \"<rest>\" */\n\tstr_ptr = (char *)strrchr(proc_stat, ')'); \n\t*str_ptr = '\\0';\t\t/* replace trailing ')' with NULL */\n\t/* parse these two strings separately, skipping the leading \"(\". */\n\tmemset (cmd, 0, sizeof(cmd));\n\tsscanf (proc_stat, \"%d (%15c\", &pid, cmd);   /* comm[16] in kernel */\n\tnum = sscanf(str_ptr + 2,\t\t/* skip space after ')' too */\n\t\t\"%c \"\n\t\t\"%d %d %d %d %d \"\n\t\t\"%lu %lu %lu %lu %lu %lu %lu \"\n\t\t\"%ld %ld %ld %ld %ld %ld \"\n\t\t\"%lu %lu \"\n\t\t\"%ld \"\n\t\t\"%lu %lu %lu \"\n\t\t\"%lu %lu %lu \"\n\t\t\"%*s %*s %*s %*s \" /* discard, no RT signals & Linux 2.1 used hex */\n\t\t\"%lu %lu %lu %*d %d\",\n\t\tstate,\n\t\t&ppid, &pgrp, session, &tty, &tpgid,\n\t\t&flags, &min_flt, &cmin_flt, &maj_flt, &cmaj_flt, &utime, &stime, \n\t\t&cutime, &cstime, &priority, &nice, &timeout, &it_real_value,\n\t\t&start_time, &vsize,\n\t\tresident_set_size,\n\t\t&resident_set_size_rlim, &start_code, &end_code, \n\t\t&start_stack, &kstk_esp, &kstk_eip,\n/*\t\t&signal, &blocked, &sig_ignore, &sig_catch, */ /* can't use */\n\t\t&w_chan, &n_swap, &sn_swap /* , &Exit_signal  */, &l_proc);\n\tif (num < 13)\n\t\terror(\"/proc entry too short (%s)\", proc_stat);\n\t*time = (utime + stime) / hertz;\n\treturn 0;\n}",
    "includes": [
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/log.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int hertz = 0;",
      "static int _parse_proc_stat(char* proc_stat, int *session, \n\t\t\t    unsigned long *time, long *resident_set_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"/proc entry too short (%s)\"",
            "proc_stat"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "_prolog_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "1386-1434",
          "snippet": "static void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _is_batch_job_finished(uint32_t job_id);",
            "static bool _job_still_running(uint32_t job_id);",
            "static void _launch_complete_add(uint32_t job_id);",
            "static void _launch_complete_log(char *type, uint32_t job_id);",
            "static void _launch_complete_rm(uint32_t job_id);",
            "static void _launch_complete_wait(uint32_t job_id);",
            "static bool _launch_job_test(uint32_t job_id);",
            "static void _note_batch_job_finished(uint32_t job_id);",
            "static bool _slurm_authorized_user(uid_t uid);",
            "static void _sync_messages_kill(kill_job_msg_t *req);",
            "static int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);",
            "static gids_t *_gids_cache_lookup(char *user, gid_t gid);",
            "static int  _add_starting_step(uint16_t type, void *req);",
            "static int  _remove_starting_step(uint16_t type, void *req);",
            "static void _add_job_running_prolog(uint32_t job_id);",
            "static void _remove_job_running_prolog(uint32_t job_id);",
            "static void _wait_for_job_running_prolog(uint32_t job_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic bool _is_batch_job_finished(uint32_t job_id);\nstatic bool _job_still_running(uint32_t job_id);\nstatic void _launch_complete_add(uint32_t job_id);\nstatic void _launch_complete_log(char *type, uint32_t job_id);\nstatic void _launch_complete_rm(uint32_t job_id);\nstatic void _launch_complete_wait(uint32_t job_id);\nstatic bool _launch_job_test(uint32_t job_id);\nstatic void _note_batch_job_finished(uint32_t job_id);\nstatic bool _slurm_authorized_user(uid_t uid);\nstatic void _sync_messages_kill(kill_job_msg_t *req);\nstatic int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);\nstatic gids_t *_gids_cache_lookup(char *user, gid_t gid);\nstatic int  _add_starting_step(uint16_t type, void *req);\nstatic int  _remove_starting_step(uint16_t type, void *req);\nstatic void _add_job_running_prolog(uint32_t job_id);\nstatic void _remove_job_running_prolog(uint32_t job_id);\nstatic void _wait_for_job_running_prolog(uint32_t job_id);\n\nstatic void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "str_ptr + 2",
            "/* skip space after ')' too */\"%c \"\n\t\t\"%d %d %d %d %d \"\n\t\t\"%lu %lu %lu %lu %lu %lu %lu \"\n\t\t\"%ld %ld %ld %ld %ld %ld \"\n\t\t\"%lu %lu \"\n\t\t\"%ld \"\n\t\t\"%lu %lu %lu \"\n\t\t\"%lu %lu %lu \"\n\t\t\"%*s %*s %*s %*s \" /* discard, no RT signals & Linux 2.1 used hex */\n\t\t\"%lu %lu %lu %*d %d\"",
            "state",
            "&ppid",
            "&pgrp",
            "session",
            "&tty",
            "&tpgid",
            "&flags",
            "&min_flt",
            "&cmin_flt",
            "&maj_flt",
            "&cmaj_flt",
            "&utime",
            "&stime",
            "&cutime",
            "&cstime",
            "&priority",
            "&nice",
            "&timeout",
            "&it_real_value",
            "&start_time",
            "&vsize",
            "resident_set_size",
            "&resident_set_size_rlim",
            "&start_code",
            "&end_code",
            "&start_stack",
            "&kstk_esp",
            "&kstk_eip",
            "/*\t\t&signal, &blocked, &sig_ignore, &sig_catch, *//* can't use */&w_chan",
            "&n_swap",
            "&sn_swap/* , &Exit_signal  */",
            "&l_proc"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "proc_stat",
            "\"%d (%15c\"",
            "&pid",
            "cmd"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cmd",
            "0",
            "sizeof(cmd)"
          ],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "proc_stat",
            "')'"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <stdlib.h>\n#  include \"config.h\"\n\nint hertz = 0;\nstatic int _parse_proc_stat(char* proc_stat, int *session, \n\t\t\t    unsigned long *time, long *resident_set_size);\n\nstatic int \n_parse_proc_stat(char* proc_stat, int *session, unsigned long *time, \n\t\t long *resident_set_size)\n{\n\tint pid, ppid, pgrp, tty, tpgid;\n\tchar cmd[16], state[1];\n\tlong unsigned flags, min_flt, cmin_flt, maj_flt, cmaj_flt;\n\tlong unsigned utime, stime;\n\tlong cutime, cstime, priority, nice, timeout, it_real_value;\n\tlong unsigned start_time, vsize;\n\tlong unsigned resident_set_size_rlim, start_code, end_code;\n\tlong unsigned start_stack, kstk_esp, kstk_eip;\n\tlong unsigned w_chan, n_swap, sn_swap;\n\tint  l_proc;\n\tint num;\n\tchar *str_ptr;\n    \n\t/* split into \"PID (cmd\" and \"<rest>\" */\n\tstr_ptr = (char *)strrchr(proc_stat, ')'); \n\t*str_ptr = '\\0';\t\t/* replace trailing ')' with NULL */\n\t/* parse these two strings separately, skipping the leading \"(\". */\n\tmemset (cmd, 0, sizeof(cmd));\n\tsscanf (proc_stat, \"%d (%15c\", &pid, cmd);   /* comm[16] in kernel */\n\tnum = sscanf(str_ptr + 2,\t\t/* skip space after ')' too */\n\t\t\"%c \"\n\t\t\"%d %d %d %d %d \"\n\t\t\"%lu %lu %lu %lu %lu %lu %lu \"\n\t\t\"%ld %ld %ld %ld %ld %ld \"\n\t\t\"%lu %lu \"\n\t\t\"%ld \"\n\t\t\"%lu %lu %lu \"\n\t\t\"%lu %lu %lu \"\n\t\t\"%*s %*s %*s %*s \" /* discard, no RT signals & Linux 2.1 used hex */\n\t\t\"%lu %lu %lu %*d %d\",\n\t\tstate,\n\t\t&ppid, &pgrp, session, &tty, &tpgid,\n\t\t&flags, &min_flt, &cmin_flt, &maj_flt, &cmaj_flt, &utime, &stime, \n\t\t&cutime, &cstime, &priority, &nice, &timeout, &it_real_value,\n\t\t&start_time, &vsize,\n\t\tresident_set_size,\n\t\t&resident_set_size_rlim, &start_code, &end_code, \n\t\t&start_stack, &kstk_esp, &kstk_eip,\n/*\t\t&signal, &blocked, &sig_ignore, &sig_catch, */ /* can't use */\n\t\t&w_chan, &n_swap, &sn_swap /* , &Exit_signal  */, &l_proc);\n\tif (num < 13)\n\t\terror(\"/proc entry too short (%s)\", proc_stat);\n\t*time = (utime + stime) / hertz;\n\treturn 0;\n}"
  },
  {
    "function_name": "_init_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/read_proc.c",
    "lines": "150-167",
    "snippet": "static void \n_init_proc (void) \n{\n\tstruct sess_record *s_ptr;\n\n\tif (sess_rec_cnt == 0)\n\t\tsession_ptr = (struct sess_record *) \n\t\t\txmalloc (sizeof (struct sess_record) * SESSION_RECS);\n\telse\n\t\txrealloc (session_ptr, sizeof (struct sess_record) * \n\t\t\t\t(sess_rec_cnt+SESSION_RECS));\n\n\tfor (s_ptr= (session_ptr+sess_rec_cnt); \n\t     s_ptr<(session_ptr+sess_rec_cnt+SESSION_RECS); s_ptr++) {\n\t\ts_ptr->iteration = -1;\n\t} \n\tsess_rec_cnt += SESSION_RECS;\n}",
    "includes": [
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/log.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define SESSION_RECS 50"
    ],
    "globals_used": [
      "int iteration = -1;",
      "int sess_rec_cnt = 0;",
      "struct sess_record *session_ptr;",
      "static void _init_proc(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xrealloc",
          "args": [
            "session_ptr",
            "sizeof (struct sess_record) * \n\t\t\t\t(sess_rec_cnt+SESSION_RECS)"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof (struct sess_record) * SESSION_RECS"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <stdlib.h>\n#  include \"config.h\"\n\n#define SESSION_RECS 50\n\nint iteration = -1;\nint sess_rec_cnt = 0;\nstruct sess_record *session_ptr;\nstatic void _init_proc(void);\n\nstatic void \n_init_proc (void) \n{\n\tstruct sess_record *s_ptr;\n\n\tif (sess_rec_cnt == 0)\n\t\tsession_ptr = (struct sess_record *) \n\t\t\txmalloc (sizeof (struct sess_record) * SESSION_RECS);\n\telse\n\t\txrealloc (session_ptr, sizeof (struct sess_record) * \n\t\t\t\t(sess_rec_cnt+SESSION_RECS));\n\n\tfor (s_ptr= (session_ptr+sess_rec_cnt); \n\t     s_ptr<(session_ptr+sess_rec_cnt+SESSION_RECS); s_ptr++) {\n\t\ts_ptr->iteration = -1;\n\t} \n\tsess_rec_cnt += SESSION_RECS;\n}"
  },
  {
    "function_name": "_dump_proc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/read_proc.c",
    "lines": "122-143",
    "snippet": "static int \n_dump_proc(int uid, int sid) \n{\n\tstruct sess_record *s_ptr;\n\tint count = 0;\n\n\tfor (s_ptr=session_ptr; s_ptr<(session_ptr+sess_rec_cnt); s_ptr++) {\n\t\tif (s_ptr->iteration == -1) \n\t\t\tcontinue;   /* Defunct */\n\t\tif ((uid != -1) && (uid != s_ptr->uid)) \n\t\t\tcontinue;\n\t\tif ((sid != -1) && (sid != s_ptr->session))\n\t\t\tcontinue;\n\t\tprintf (\"uid=%lu session=%lu time=%lu resident_set_size=%ld \", \n\t\t\t(u_long) s_ptr->uid, (u_long) s_ptr->session, \n\t\t\t(u_long) s_ptr->time, (long) s_ptr->resident_set_size);\n\t\tprintf (\"iteration=%d processes=%d\\n\", \n\t\t\ts_ptr->iteration, s_ptr->processes);\n\t\tcount++;\n\t}\n\treturn count;\n}",
    "includes": [
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/log.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "int iteration = -1;",
      "int sess_rec_cnt = 0;",
      "struct sess_record *session_ptr;",
      "static int _parse_proc_stat(char* proc_stat, int *session, \n\t\t\t    unsigned long *time, long *resident_set_size);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"iteration=%d processes=%d\\n\"",
            "s_ptr->iteration",
            "s_ptr->processes"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"uid=%lu session=%lu time=%lu resident_set_size=%ld \"",
            "(u_long) s_ptr->uid",
            "(u_long) s_ptr->session",
            "(u_long) s_ptr->time",
            "(long) s_ptr->resident_set_size"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <stdlib.h>\n#  include \"config.h\"\n\nint iteration = -1;\nint sess_rec_cnt = 0;\nstruct sess_record *session_ptr;\nstatic int _parse_proc_stat(char* proc_stat, int *session, \n\t\t\t    unsigned long *time, long *resident_set_size);\n\nstatic int \n_dump_proc(int uid, int sid) \n{\n\tstruct sess_record *s_ptr;\n\tint count = 0;\n\n\tfor (s_ptr=session_ptr; s_ptr<(session_ptr+sess_rec_cnt); s_ptr++) {\n\t\tif (s_ptr->iteration == -1) \n\t\t\tcontinue;   /* Defunct */\n\t\tif ((uid != -1) && (uid != s_ptr->uid)) \n\t\t\tcontinue;\n\t\tif ((sid != -1) && (sid != s_ptr->session))\n\t\t\tcontinue;\n\t\tprintf (\"uid=%lu session=%lu time=%lu resident_set_size=%ld \", \n\t\t\t(u_long) s_ptr->uid, (u_long) s_ptr->session, \n\t\t\t(u_long) s_ptr->time, (long) s_ptr->resident_set_size);\n\t\tprintf (\"iteration=%d processes=%d\\n\", \n\t\t\ts_ptr->iteration, s_ptr->processes);\n\t\tcount++;\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/read_proc.c",
    "lines": "86-114",
    "snippet": "int \nmain(int argc, char * argv[]) \n{\n\tint error_code, i, iterations, uid;\n\tif ((argc < 2) || (argc > 3)) {\n\t\tprintf (\"Usage: %s <iterations> [<uid>]\\n\", argv[0]);\n\t\texit (0);\n\t} \n\tif (argc == 3) \n\t\tuid = atoi (argv[2]);\n\telse\n\t\tuid = -1;\n\titerations = atoi (argv[1]);\n\t_init_proc ();\n\n\tfor (i=0; i<iterations; i++) {\n\t\tif (i > 0) {\n\t\t\tsleep (10);\n\t\t\tprintf(\"\\n\\n\");\n\t\t} \n\t\terror_code = read_proc ();\n\t\tif (error_code != 0) {\n\t\t\tprintf (\"Error %d from read_proc\\n\", error_code);\n\t\t\texit (1);\n\t\t} \n\t\t_dump_proc (uid, -1);\n\t}\n\texit (0);\n}",
    "includes": [
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/log.h\"",
      "#include <unistd.h>",
      "#include <syslog.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <fcntl.h>",
      "#include <errno.h>",
      "#include <dirent.h>",
      "#include <stdlib.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _init_proc(void);",
      "extern int read_proc(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "_send_pending_exit_msgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "1890-1927",
          "snippet": "static int\n_send_pending_exit_msgs(stepd_step_rec_t *job)\n{\n\tint  i;\n\tint  nsent  = 0;\n\tint  status = 0;\n\tbool set    = false;\n\tuint32_t *tid;\n\n\t/*\n\t * Collect all exit codes with the same status into a\n\t * single message.\n\t */\n\ttid = xmalloc(sizeof(uint32_t) * job->node_tasks);\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tstepd_step_task_info_t *t = job->task[i];\n\n\t\tif (!t->exited || t->esent)\n\t\t\tcontinue;\n\n\t\tif (!set) {\n\t\t\tstatus = t->estatus;\n\t\t\tset    = true;\n\t\t} else if (status != t->estatus)\n\t\t\tcontinue;\n\n\t\ttid[nsent++] = t->gtid;\n\t\tt->esent = true;\n\t}\n\n\tif (nsent) {\n\t\tdebug2(\"Aggregated %d task exit messages\", nsent);\n\t\t_send_exit_msg(job, tid, nsent, status);\n\t}\n\txfree(tid);\n\n\treturn nsent;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static int  _send_exit_msg(stepd_step_rec_t *job, uint32_t *tid, int n,\n\t\t\t   int status);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int    _send_complete_batch_script_msg(stepd_step_rec_t *job,\n\t\t\t\t\t      int err, int status);",
            "static int _initgroups(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic int  _send_exit_msg(stepd_step_rec_t *job, uint32_t *tid, int n,\n\t\t\t   int status);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int    _send_complete_batch_script_msg(stepd_step_rec_t *job,\n\t\t\t\t\t      int err, int status);\nstatic int _initgroups(stepd_step_rec_t *job);\n\nstatic int\n_send_pending_exit_msgs(stepd_step_rec_t *job)\n{\n\tint  i;\n\tint  nsent  = 0;\n\tint  status = 0;\n\tbool set    = false;\n\tuint32_t *tid;\n\n\t/*\n\t * Collect all exit codes with the same status into a\n\t * single message.\n\t */\n\ttid = xmalloc(sizeof(uint32_t) * job->node_tasks);\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tstepd_step_task_info_t *t = job->task[i];\n\n\t\tif (!t->exited || t->esent)\n\t\t\tcontinue;\n\n\t\tif (!set) {\n\t\t\tstatus = t->estatus;\n\t\t\tset    = true;\n\t\t} else if (status != t->estatus)\n\t\t\tcontinue;\n\n\t\ttid[nsent++] = t->gtid;\n\t\tt->esent = true;\n\t}\n\n\tif (nsent) {\n\t\tdebug2(\"Aggregated %d task exit messages\", nsent);\n\t\t_send_exit_msg(job, tid, nsent, status);\n\t}\n\txfree(tid);\n\n\treturn nsent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_dump_proc",
          "args": [
            "uid",
            "-1"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "_dump_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/read_proc.c",
          "lines": "122-143",
          "snippet": "static int \n_dump_proc(int uid, int sid) \n{\n\tstruct sess_record *s_ptr;\n\tint count = 0;\n\n\tfor (s_ptr=session_ptr; s_ptr<(session_ptr+sess_rec_cnt); s_ptr++) {\n\t\tif (s_ptr->iteration == -1) \n\t\t\tcontinue;   /* Defunct */\n\t\tif ((uid != -1) && (uid != s_ptr->uid)) \n\t\t\tcontinue;\n\t\tif ((sid != -1) && (sid != s_ptr->session))\n\t\t\tcontinue;\n\t\tprintf (\"uid=%lu session=%lu time=%lu resident_set_size=%ld \", \n\t\t\t(u_long) s_ptr->uid, (u_long) s_ptr->session, \n\t\t\t(u_long) s_ptr->time, (long) s_ptr->resident_set_size);\n\t\tprintf (\"iteration=%d processes=%d\\n\", \n\t\t\ts_ptr->iteration, s_ptr->processes);\n\t\tcount++;\n\t}\n\treturn count;\n}",
          "includes": [
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/log.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "int iteration = -1;",
            "int sess_rec_cnt = 0;",
            "struct sess_record *session_ptr;",
            "static int _parse_proc_stat(char* proc_stat, int *session, \n\t\t\t    unsigned long *time, long *resident_set_size);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <stdlib.h>\n#  include \"config.h\"\n\nint iteration = -1;\nint sess_rec_cnt = 0;\nstruct sess_record *session_ptr;\nstatic int _parse_proc_stat(char* proc_stat, int *session, \n\t\t\t    unsigned long *time, long *resident_set_size);\n\nstatic int \n_dump_proc(int uid, int sid) \n{\n\tstruct sess_record *s_ptr;\n\tint count = 0;\n\n\tfor (s_ptr=session_ptr; s_ptr<(session_ptr+sess_rec_cnt); s_ptr++) {\n\t\tif (s_ptr->iteration == -1) \n\t\t\tcontinue;   /* Defunct */\n\t\tif ((uid != -1) && (uid != s_ptr->uid)) \n\t\t\tcontinue;\n\t\tif ((sid != -1) && (sid != s_ptr->session))\n\t\t\tcontinue;\n\t\tprintf (\"uid=%lu session=%lu time=%lu resident_set_size=%ld \", \n\t\t\t(u_long) s_ptr->uid, (u_long) s_ptr->session, \n\t\t\t(u_long) s_ptr->time, (long) s_ptr->resident_set_size);\n\t\tprintf (\"iteration=%d processes=%d\\n\", \n\t\t\ts_ptr->iteration, s_ptr->processes);\n\t\tcount++;\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Error %d from read_proc\\n\"",
            "error_code"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_proc",
          "args": [],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "read_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/read_proc.c",
          "lines": "234-350",
          "snippet": "extern int \nread_proc(void) \n{\n\tDIR *proc_fs;\n\tstruct dirent *proc_ent;\n\tint proc_fd, proc_stat_size, found, n;\n\tchar proc_name[22], *proc_stat;\n\tstruct stat buffer;\n\tint uid, session;\n\tlong resident_set_size;\n\tunsigned long time;\n\tstruct sess_record *s_ptr, *sess_free;\n\n\t/* Initialization */\n\tif (hertz == 0) {\n\t\thertz = sysconf(_SC_CLK_TCK);\n\t\tif (hertz == 0) {\n\t\t\terror (\"read_proc: unable to get clock rate\");\n\t\t\thertz = 100;\t/* default on many systems */\n\t\t} \n\t} \n\tproc_stat_size = BUF_SIZE;\n\tproc_stat = (char *) xmalloc(proc_stat_size);\n\tproc_fs = opendir(\"/proc\");\n\tif (proc_fs == NULL) {\n\t\terror (\"read_proc: opendir unable to open /proc %m\");\n\t\treturn errno;\n\t}\n\titeration++;\n\n\t/* Read the entries */\n\twhile ((proc_ent = readdir(proc_fs)) != (struct dirent *)NULL) {\n\t\tif (proc_ent->d_name[0] < '0') \n\t\t\tcontinue;\t/* Not \"real\" process ID */\n\t\tif (proc_ent->d_name[0] > '9') \n\t\t\tcontinue;\t/* Not \"real\" process ID */\n\t\tif (strlen(proc_ent->d_name) > 10) {\n\t\t\t/* make proc_name longer and change this value */\n\t\t\terror (\"read_proc: process ID number too long\");\n\t\t\tcontinue;\n\t\t} \n\t\tsprintf (proc_name, \"/proc/%s/stat\", proc_ent->d_name);\n\t\tproc_fd = open (proc_name, O_RDONLY, 0);\n\t\tif (proc_fd == -1) \n\t\t\tcontinue;  /* process is now gone */\n\t\twhile ((n = read(proc_fd, proc_stat, proc_stat_size)) > 0) {\n\t\t\tif (n < (proc_stat_size-1))\n\t\t\t\tbreak;\n\t\t\tproc_stat_size += BUF_SIZE;\n\t\t\txrealloc(proc_stat, proc_stat_size);\n\t\t\tif (lseek(proc_fd, (off_t) 0, SEEK_SET) != 0) \n\t\t\t\tbreak;\n\t\t}\n\t\tfstat(proc_fd, &buffer);\n\t\tclose(proc_fd);\n\t\tif (n <= 0) \n\t\t\tcontinue;\n\t\tuid = buffer.st_uid;\n\t\t_parse_proc_stat(proc_stat, &session, &time, \n\t\t\t\t &resident_set_size);\n\t\tfound = 0;\n\t\tsess_free = NULL;\n\t\tfor (s_ptr=session_ptr; s_ptr<(session_ptr+sess_rec_cnt); \n\t\t     s_ptr++) {\n\t\t\tif (s_ptr->iteration == -1) {\n\t\t\t\tif (sess_free == NULL) \n\t\t\t\t\tsess_free = s_ptr;\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif (s_ptr->session != session) \n\t\t\t\tcontinue;\n\t\t\tif (s_ptr->iteration != iteration) {\n\t\t\t\ts_ptr->iteration = iteration;\n\t\t\t\ts_ptr->processes = 0;\n\t\t\t\ts_ptr->resident_set_size       = 0;\n\t\t\t\ts_ptr->time      = 0;\n\t\t\t} \n\t\t\ts_ptr->processes += 1;\n\t\t\ts_ptr->resident_set_size       += resident_set_size;\n\t\t\ts_ptr->time      += time;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t} \n\t\tif (found == 0) {\n\t\t\tif (sess_free == NULL) {\n\t\t\t\t_init_proc();\n\t\t\t\tfor (s_ptr=session_ptr; \n\t\t\t\t     s_ptr<(session_ptr+sess_rec_cnt); \n\t\t\t\t     s_ptr++) {\n\t\t\t\t\tif (s_ptr->iteration != -1) \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tsess_free = s_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\t\t\t\tif (sess_free == NULL) {\n\t\t\t\t\terror (\"read_proc: Internal error\");\n\t\t\t\t\treturn EINVAL;\n\t\t\t\t} \n\t\t\t} \n\t\t\tsess_free->iteration = iteration;\n\t\t\tsess_free->processes = 1;\n\t\t\tsess_free->resident_set_size       = resident_set_size;\n\t\t\tsess_free->session   = session;\n\t\t\tsess_free->time      = time;\n\t\t\tsess_free->uid       = uid;\n\t\t} \n\t}\n\n\t/* Termination */\n\txfree(proc_stat);\n\tclosedir(proc_fs);\n\tfor (s_ptr=session_ptr; s_ptr<(session_ptr+sess_rec_cnt); s_ptr++) {\n\t\tif (s_ptr->iteration != iteration) \n\t\t\ts_ptr->iteration=-1;   /* Defunct */\n\t} \n\treturn 0;\n}",
          "includes": [
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/log.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [
            "#define BUF_SIZE 1024"
          ],
          "globals_used": [
            "int hertz = 0;",
            "int iteration = -1;",
            "int sess_rec_cnt = 0;",
            "struct sess_record *session_ptr;",
            "static void _init_proc(void);",
            "static int _parse_proc_stat(char* proc_stat, int *session, \n\t\t\t    unsigned long *time, long *resident_set_size);",
            "extern int read_proc(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <stdlib.h>\n#  include \"config.h\"\n\n#define BUF_SIZE 1024\n\nint hertz = 0;\nint iteration = -1;\nint sess_rec_cnt = 0;\nstruct sess_record *session_ptr;\nstatic void _init_proc(void);\nstatic int _parse_proc_stat(char* proc_stat, int *session, \n\t\t\t    unsigned long *time, long *resident_set_size);\nextern int read_proc(void);\n\nextern int \nread_proc(void) \n{\n\tDIR *proc_fs;\n\tstruct dirent *proc_ent;\n\tint proc_fd, proc_stat_size, found, n;\n\tchar proc_name[22], *proc_stat;\n\tstruct stat buffer;\n\tint uid, session;\n\tlong resident_set_size;\n\tunsigned long time;\n\tstruct sess_record *s_ptr, *sess_free;\n\n\t/* Initialization */\n\tif (hertz == 0) {\n\t\thertz = sysconf(_SC_CLK_TCK);\n\t\tif (hertz == 0) {\n\t\t\terror (\"read_proc: unable to get clock rate\");\n\t\t\thertz = 100;\t/* default on many systems */\n\t\t} \n\t} \n\tproc_stat_size = BUF_SIZE;\n\tproc_stat = (char *) xmalloc(proc_stat_size);\n\tproc_fs = opendir(\"/proc\");\n\tif (proc_fs == NULL) {\n\t\terror (\"read_proc: opendir unable to open /proc %m\");\n\t\treturn errno;\n\t}\n\titeration++;\n\n\t/* Read the entries */\n\twhile ((proc_ent = readdir(proc_fs)) != (struct dirent *)NULL) {\n\t\tif (proc_ent->d_name[0] < '0') \n\t\t\tcontinue;\t/* Not \"real\" process ID */\n\t\tif (proc_ent->d_name[0] > '9') \n\t\t\tcontinue;\t/* Not \"real\" process ID */\n\t\tif (strlen(proc_ent->d_name) > 10) {\n\t\t\t/* make proc_name longer and change this value */\n\t\t\terror (\"read_proc: process ID number too long\");\n\t\t\tcontinue;\n\t\t} \n\t\tsprintf (proc_name, \"/proc/%s/stat\", proc_ent->d_name);\n\t\tproc_fd = open (proc_name, O_RDONLY, 0);\n\t\tif (proc_fd == -1) \n\t\t\tcontinue;  /* process is now gone */\n\t\twhile ((n = read(proc_fd, proc_stat, proc_stat_size)) > 0) {\n\t\t\tif (n < (proc_stat_size-1))\n\t\t\t\tbreak;\n\t\t\tproc_stat_size += BUF_SIZE;\n\t\t\txrealloc(proc_stat, proc_stat_size);\n\t\t\tif (lseek(proc_fd, (off_t) 0, SEEK_SET) != 0) \n\t\t\t\tbreak;\n\t\t}\n\t\tfstat(proc_fd, &buffer);\n\t\tclose(proc_fd);\n\t\tif (n <= 0) \n\t\t\tcontinue;\n\t\tuid = buffer.st_uid;\n\t\t_parse_proc_stat(proc_stat, &session, &time, \n\t\t\t\t &resident_set_size);\n\t\tfound = 0;\n\t\tsess_free = NULL;\n\t\tfor (s_ptr=session_ptr; s_ptr<(session_ptr+sess_rec_cnt); \n\t\t     s_ptr++) {\n\t\t\tif (s_ptr->iteration == -1) {\n\t\t\t\tif (sess_free == NULL) \n\t\t\t\t\tsess_free = s_ptr;\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif (s_ptr->session != session) \n\t\t\t\tcontinue;\n\t\t\tif (s_ptr->iteration != iteration) {\n\t\t\t\ts_ptr->iteration = iteration;\n\t\t\t\ts_ptr->processes = 0;\n\t\t\t\ts_ptr->resident_set_size       = 0;\n\t\t\t\ts_ptr->time      = 0;\n\t\t\t} \n\t\t\ts_ptr->processes += 1;\n\t\t\ts_ptr->resident_set_size       += resident_set_size;\n\t\t\ts_ptr->time      += time;\n\t\t\tfound = 1;\n\t\t\tbreak;\n\t\t} \n\t\tif (found == 0) {\n\t\t\tif (sess_free == NULL) {\n\t\t\t\t_init_proc();\n\t\t\t\tfor (s_ptr=session_ptr; \n\t\t\t\t     s_ptr<(session_ptr+sess_rec_cnt); \n\t\t\t\t     s_ptr++) {\n\t\t\t\t\tif (s_ptr->iteration != -1) \n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tsess_free = s_ptr;\n\t\t\t\t\tbreak;\n\t\t\t\t} \n\t\t\t\tif (sess_free == NULL) {\n\t\t\t\t\terror (\"read_proc: Internal error\");\n\t\t\t\t\treturn EINVAL;\n\t\t\t\t} \n\t\t\t} \n\t\t\tsess_free->iteration = iteration;\n\t\t\tsess_free->processes = 1;\n\t\t\tsess_free->resident_set_size       = resident_set_size;\n\t\t\tsess_free->session   = session;\n\t\t\tsess_free->time      = time;\n\t\t\tsess_free->uid       = uid;\n\t\t} \n\t}\n\n\t/* Termination */\n\txfree(proc_stat);\n\tclosedir(proc_fs);\n\tfor (s_ptr=session_ptr; s_ptr<(session_ptr+sess_rec_cnt); s_ptr++) {\n\t\tif (s_ptr->iteration != iteration) \n\t\t\ts_ptr->iteration=-1;   /* Defunct */\n\t} \n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\\n\""
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "10"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "_random_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "664-678",
          "snippet": "static void\n_random_sleep(stepd_step_rec_t *job)\n{\n#if !defined HAVE_FRONT_END\n\tlong int delay = 0;\n\tlong int max   = (slurm_get_tcp_timeout() * job->nnodes);\n\n\tmax = MIN(max, 5000);\n\tsrand48((long int) (job->jobid + job->nodeid));\n\n\tdelay = lrand48() % ( max + 1 );\n\tdebug3(\"delaying %ldms\", delay);\n\tpoll(NULL, 0, delay);\n#endif\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int _initgroups(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int _initgroups(stepd_step_rec_t *job);\n\nstatic void\n_random_sleep(stepd_step_rec_t *job)\n{\n#if !defined HAVE_FRONT_END\n\tlong int delay = 0;\n\tlong int max   = (slurm_get_tcp_timeout() * job->nnodes);\n\n\tmax = MIN(max, 5000);\n\tsrand48((long int) (job->jobid + job->nodeid));\n\n\tdelay = lrand48() % ( max + 1 );\n\tdebug3(\"delaying %ldms\", delay);\n\tpoll(NULL, 0, delay);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "_init_proc",
          "args": [],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "_init_proc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/read_proc.c",
          "lines": "150-167",
          "snippet": "static void \n_init_proc (void) \n{\n\tstruct sess_record *s_ptr;\n\n\tif (sess_rec_cnt == 0)\n\t\tsession_ptr = (struct sess_record *) \n\t\t\txmalloc (sizeof (struct sess_record) * SESSION_RECS);\n\telse\n\t\txrealloc (session_ptr, sizeof (struct sess_record) * \n\t\t\t\t(sess_rec_cnt+SESSION_RECS));\n\n\tfor (s_ptr= (session_ptr+sess_rec_cnt); \n\t     s_ptr<(session_ptr+sess_rec_cnt+SESSION_RECS); s_ptr++) {\n\t\ts_ptr->iteration = -1;\n\t} \n\tsess_rec_cnt += SESSION_RECS;\n}",
          "includes": [
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/log.h\"",
            "#include <unistd.h>",
            "#include <syslog.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "#include <dirent.h>",
            "#include <stdlib.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [
            "#define SESSION_RECS 50"
          ],
          "globals_used": [
            "int iteration = -1;",
            "int sess_rec_cnt = 0;",
            "struct sess_record *session_ptr;",
            "static void _init_proc(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <stdlib.h>\n#  include \"config.h\"\n\n#define SESSION_RECS 50\n\nint iteration = -1;\nint sess_rec_cnt = 0;\nstruct sess_record *session_ptr;\nstatic void _init_proc(void);\n\nstatic void \n_init_proc (void) \n{\n\tstruct sess_record *s_ptr;\n\n\tif (sess_rec_cnt == 0)\n\t\tsession_ptr = (struct sess_record *) \n\t\t\txmalloc (sizeof (struct sess_record) * SESSION_RECS);\n\telse\n\t\txrealloc (session_ptr, sizeof (struct sess_record) * \n\t\t\t\t(sess_rec_cnt+SESSION_RECS));\n\n\tfor (s_ptr= (session_ptr+sess_rec_cnt); \n\t     s_ptr<(session_ptr+sess_rec_cnt+SESSION_RECS); s_ptr++) {\n\t\ts_ptr->iteration = -1;\n\t} \n\tsess_rec_cnt += SESSION_RECS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[1]"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "argv[2]"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Usage: %s <iterations> [<uid>]\\n\"",
            "argv[0]"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include <unistd.h>\n#include <syslog.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <string.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n#include <dirent.h>\n#include <stdlib.h>\n#  include \"config.h\"\n\nstatic void _init_proc(void);\nextern int read_proc(void);\n\nint \nmain(int argc, char * argv[]) \n{\n\tint error_code, i, iterations, uid;\n\tif ((argc < 2) || (argc > 3)) {\n\t\tprintf (\"Usage: %s <iterations> [<uid>]\\n\", argv[0]);\n\t\texit (0);\n\t} \n\tif (argc == 3) \n\t\tuid = atoi (argv[2]);\n\telse\n\t\tuid = -1;\n\titerations = atoi (argv[1]);\n\t_init_proc ();\n\n\tfor (i=0; i<iterations; i++) {\n\t\tif (i > 0) {\n\t\t\tsleep (10);\n\t\t\tprintf(\"\\n\\n\");\n\t\t} \n\t\terror_code = read_proc ();\n\t\tif (error_code != 0) {\n\t\t\tprintf (\"Error %d from read_proc\\n\", error_code);\n\t\t\texit (1);\n\t\t} \n\t\t_dump_proc (uid, -1);\n\t}\n\texit (0);\n}"
  }
]