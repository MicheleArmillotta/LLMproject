[
  {
    "function_name": "_get_env_val",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/ulimits.c",
    "lines": "295-327",
    "snippet": "static int _get_env_val(char **env, const char *name, unsigned long *valp,\n\t\tbool *u_req_propagate)\n{\n\tchar *val    = NULL;\n\tchar *p      = NULL;\n\n\txassert(env  != NULL);\n\txassert(name != NULL);\n\n\tif (!(val = getenvp(env, name)))\n\t\treturn (-1);\n\n\t/*\n\t * The letter 'U' would have been prepended to the string value if the\n\t * user requested to have this rlimit propagated via 'srun --propagate'\n\t */\n\tif (*val == 'U') {\n\t\t*u_req_propagate = TRUE;\n\t\tdebug2( \"_get_env_val: %s propagated by user option\", &name[6]);\n\t\tval++;\n\t}\n\telse\n\t\t*u_req_propagate = FALSE;\n\n\t*valp = strtoul(val, &p, 10);\n\n\tif (p && (*p != '\\0'))  {\n\t\terror(\"Invalid %s env var, value = `%s'\", name, val);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/strlcpy.h\"",
      "#include \"src/common/env.h\" /* For unsetenvp() */",
      "#include \"src/common/log.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _get_env_val(char **env, const char *name, unsigned long *valp,\n\t\tbool *u_req_propagate);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Invalid %s env var, value = `%s'\"",
            "name",
            "val"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "val",
            "&p",
            "10"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"_get_env_val: %s propagated by user option\"",
            "&name[6]"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenvp",
          "args": [
            "env",
            "name"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "name != NULL"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "env  != NULL"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/strlcpy.h\"\n#include \"src/common/env.h\" /* For unsetenvp() */\n#include \"src/common/log.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#  include \"config.h\"\n\nstatic int _get_env_val(char **env, const char *name, unsigned long *valp,\n\t\tbool *u_req_propagate);\n\nstatic int _get_env_val(char **env, const char *name, unsigned long *valp,\n\t\tbool *u_req_propagate)\n{\n\tchar *val    = NULL;\n\tchar *p      = NULL;\n\n\txassert(env  != NULL);\n\txassert(name != NULL);\n\n\tif (!(val = getenvp(env, name)))\n\t\treturn (-1);\n\n\t/*\n\t * The letter 'U' would have been prepended to the string value if the\n\t * user requested to have this rlimit propagated via 'srun --propagate'\n\t */\n\tif (*val == 'U') {\n\t\t*u_req_propagate = TRUE;\n\t\tdebug2( \"_get_env_val: %s propagated by user option\", &name[6]);\n\t\tval++;\n\t}\n\telse\n\t\t*u_req_propagate = FALSE;\n\n\t*valp = strtoul(val, &p, 10);\n\n\tif (p && (*p != '\\0'))  {\n\t\terror(\"Invalid %s env var, value = `%s'\", name, val);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
  },
  {
    "function_name": "_set_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/ulimits.c",
    "lines": "214-289",
    "snippet": "static int\n_set_limit(char **env, slurm_rlimits_info_t *rli)\n{\n\tunsigned long env_value;\n\tchar max[24], cur[24], req[24];\n\tstruct rlimit r;\n\tbool u_req_propagate;  /* e.g. TRUE if 'srun --propagate' */\n\n\tchar env_name[25] = \"SLURM_RLIMIT_\";\n\tchar *rlimit_name = &env_name[6];\n\n\tstrcpy( &env_name[sizeof(\"SLURM_RLIMIT_\")-1], rli->name );\n\n\tif (_get_env_val( env, env_name, &env_value, &u_req_propagate )){\n\t\tdebug( \"Couldn't find %s in environment\", env_name );\n\t\treturn SLURM_ERROR;\n\t}\n\n\t/*\n\t * Users shouldn't get the SLURM_RLIMIT_* env vars in their environ\n\t */\n\tunsetenvp( env, env_name );\n\n\t/*\n\t * We'll only attempt to set the propagated soft rlimit when indicated\n\t * by the slurm conf file settings, or the user requested it.\n\t */\n\tif ( ! (rli->propagate_flag == PROPAGATE_RLIMITS || u_req_propagate))\n\t\treturn SLURM_SUCCESS;\n\n\tif (getrlimit( rli->resource, &r ) < 0) {\n\t\terror(\"getrlimit(%s): %m\", rlimit_name);\n\t\treturn SLURM_ERROR;\n\t}\n\n\t/*\n\t * Nothing to do if the rlimit won't change\n\t */\n\tif (r.rlim_cur == (rlim_t) env_value) {\n\t\tdebug2( \"_set_limit: %s setrlimit %s no change in value: %lu\",\n\t\t\tu_req_propagate?\"user\":\"conf\", rlimit_name,\n\t\t\t(unsigned long) r.rlim_cur);\n\t\treturn SLURM_SUCCESS;\n\t}\n\n\tdebug2(\"_set_limit: %-14s: max:%s cur:%s req:%s\", rlimit_name,\n\t\trlim_to_string (r.rlim_max, max, sizeof (max)),\n\t\trlim_to_string (r.rlim_cur, cur, sizeof (cur)),\n\t\trlim_to_string (env_value,  req, sizeof (req)) );\n\n\tr.rlim_cur = (rlim_t) env_value;\n\tif (r.rlim_max < r.rlim_cur)\n\t\tr.rlim_max = r.rlim_cur;\n\n\tif (setrlimit( rli->resource, &r ) < 0) {\n\t\t/*\n\t\t * Report an error only if the user requested propagate\n\t\t */\n\t\tif (u_req_propagate) {\n\t\t\terror( \"Can't propagate %s of %s from submit host: %m\",\n\t\t\t\trlimit_name,\n\t\t\t\tr.rlim_cur == RLIM_INFINITY ? \"'unlimited'\" :\n\t\t\t\trlim_to_string( r.rlim_cur, cur, sizeof(cur)));\n\t\t} else {\n\t\t\tverbose(\"Can't propagate %s of %s from submit host: %m\",\n\t\t\t\trlimit_name,\n\t\t\t\tr.rlim_cur == RLIM_INFINITY ? \"'unlimited'\" :\n\t\t\t\trlim_to_string( r.rlim_cur, cur, sizeof(cur)));\n\t\t}\n\t\treturn SLURM_ERROR;\n\t}\n\tdebug2( \"_set_limit: %s setrlimit %s succeeded\",\n\t\t\tu_req_propagate?\"user\":\"conf\", rlimit_name );\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/strlcpy.h\"",
      "#include \"src/common/env.h\" /* For unsetenvp() */",
      "#include \"src/common/log.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _get_env_val(char **env, const char *name, unsigned long *valp,\n\t\tbool *u_req_propagate);",
      "static int _set_limit(char **env, slurm_rlimits_info_t *rli);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"_set_limit: %s setrlimit %s succeeded\"",
            "u_req_propagate?\"user\":\"conf\"",
            "rlimit_name"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Can't propagate %s of %s from submit host: %m\"",
            "rlimit_name",
            "r.rlim_cur == RLIM_INFINITY ? \"'unlimited'\" :\n\t\t\t\trlim_to_string( r.rlim_cur, cur, sizeof(cur))"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlim_to_string",
          "args": [
            "r.rlim_cur",
            "cur",
            "sizeof(cur)"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "rlim_to_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/ulimits.c",
          "lines": "171-178",
          "snippet": "static char * rlim_to_string (unsigned long rlim, char *buf, size_t n)\n{\n\tif (rlim == (unsigned long) RLIM_INFINITY)\n\t\tstrlcpy (buf, \"inf\", n);\n\telse\n\t\tsnprintf (buf, n, \"%lu\", rlim);\n\treturn (buf);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/strlcpy.h\"",
            "#include \"src/common/env.h\" /* For unsetenvp() */",
            "#include \"src/common/log.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/strlcpy.h\"\n#include \"src/common/env.h\" /* For unsetenvp() */\n#include \"src/common/log.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#  include \"config.h\"\n\nstatic char * rlim_to_string (unsigned long rlim, char *buf, size_t n)\n{\n\tif (rlim == (unsigned long) RLIM_INFINITY)\n\t\tstrlcpy (buf, \"inf\", n);\n\telse\n\t\tsnprintf (buf, n, \"%lu\", rlim);\n\treturn (buf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Can't propagate %s of %s from submit host: %m\"",
            "rlimit_name",
            "r.rlim_cur == RLIM_INFINITY ? \"'unlimited'\" :\n\t\t\t\trlim_to_string( r.rlim_cur, cur, sizeof(cur))"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setrlimit",
          "args": [
            "rli->resource",
            "&r"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"_set_limit: %-14s: max:%s cur:%s req:%s\"",
            "rlimit_name",
            "rlim_to_string (r.rlim_max, max, sizeof (max))",
            "rlim_to_string (r.rlim_cur, cur, sizeof (cur))",
            "rlim_to_string (env_value,  req, sizeof (req))"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"_set_limit: %s setrlimit %s no change in value: %lu\"",
            "u_req_propagate?\"user\":\"conf\"",
            "rlimit_name",
            "(unsigned long) r.rlim_cur"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"getrlimit(%s): %m\"",
            "rlimit_name"
          ],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "_task_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "641-650",
          "snippet": "static int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static bool _task_writable(eio_obj_t *);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int _task_write_error(eio_obj_t *obj, List objs);",
            "static bool _task_readable(eio_obj_t *);",
            "static int  _task_read(eio_obj_t *, List);",
            "static void _route_msg_task_to_client(eio_obj_t *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrlimit",
          "args": [
            "rli->resource",
            "&r"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsetenvp",
          "args": [
            "env",
            "env_name"
          ],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Couldn't find %s in environment\"",
            "env_name"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_wake_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "187-199",
          "snippet": "void pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_get_env_val",
          "args": [
            "env",
            "env_name",
            "&env_value",
            "&u_req_propagate"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "_get_env_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/ulimits.c",
          "lines": "295-327",
          "snippet": "static int _get_env_val(char **env, const char *name, unsigned long *valp,\n\t\tbool *u_req_propagate)\n{\n\tchar *val    = NULL;\n\tchar *p      = NULL;\n\n\txassert(env  != NULL);\n\txassert(name != NULL);\n\n\tif (!(val = getenvp(env, name)))\n\t\treturn (-1);\n\n\t/*\n\t * The letter 'U' would have been prepended to the string value if the\n\t * user requested to have this rlimit propagated via 'srun --propagate'\n\t */\n\tif (*val == 'U') {\n\t\t*u_req_propagate = TRUE;\n\t\tdebug2( \"_get_env_val: %s propagated by user option\", &name[6]);\n\t\tval++;\n\t}\n\telse\n\t\t*u_req_propagate = FALSE;\n\n\t*valp = strtoul(val, &p, 10);\n\n\tif (p && (*p != '\\0'))  {\n\t\terror(\"Invalid %s env var, value = `%s'\", name, val);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/strlcpy.h\"",
            "#include \"src/common/env.h\" /* For unsetenvp() */",
            "#include \"src/common/log.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _get_env_val(char **env, const char *name, unsigned long *valp,\n\t\tbool *u_req_propagate);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/strlcpy.h\"\n#include \"src/common/env.h\" /* For unsetenvp() */\n#include \"src/common/log.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#  include \"config.h\"\n\nstatic int _get_env_val(char **env, const char *name, unsigned long *valp,\n\t\tbool *u_req_propagate);\n\nstatic int _get_env_val(char **env, const char *name, unsigned long *valp,\n\t\tbool *u_req_propagate)\n{\n\tchar *val    = NULL;\n\tchar *p      = NULL;\n\n\txassert(env  != NULL);\n\txassert(name != NULL);\n\n\tif (!(val = getenvp(env, name)))\n\t\treturn (-1);\n\n\t/*\n\t * The letter 'U' would have been prepended to the string value if the\n\t * user requested to have this rlimit propagated via 'srun --propagate'\n\t */\n\tif (*val == 'U') {\n\t\t*u_req_propagate = TRUE;\n\t\tdebug2( \"_get_env_val: %s propagated by user option\", &name[6]);\n\t\tval++;\n\t}\n\telse\n\t\t*u_req_propagate = FALSE;\n\n\t*valp = strtoul(val, &p, 10);\n\n\tif (p && (*p != '\\0'))  {\n\t\terror(\"Invalid %s env var, value = `%s'\", name, val);\n\t\treturn (-1);\n\t}\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "&env_name[sizeof(\"SLURM_RLIMIT_\")-1]",
            "rli->name"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/strlcpy.h\"\n#include \"src/common/env.h\" /* For unsetenvp() */\n#include \"src/common/log.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#  include \"config.h\"\n\nstatic int _get_env_val(char **env, const char *name, unsigned long *valp,\n\t\tbool *u_req_propagate);\nstatic int _set_limit(char **env, slurm_rlimits_info_t *rli);\n\nstatic int\n_set_limit(char **env, slurm_rlimits_info_t *rli)\n{\n\tunsigned long env_value;\n\tchar max[24], cur[24], req[24];\n\tstruct rlimit r;\n\tbool u_req_propagate;  /* e.g. TRUE if 'srun --propagate' */\n\n\tchar env_name[25] = \"SLURM_RLIMIT_\";\n\tchar *rlimit_name = &env_name[6];\n\n\tstrcpy( &env_name[sizeof(\"SLURM_RLIMIT_\")-1], rli->name );\n\n\tif (_get_env_val( env, env_name, &env_value, &u_req_propagate )){\n\t\tdebug( \"Couldn't find %s in environment\", env_name );\n\t\treturn SLURM_ERROR;\n\t}\n\n\t/*\n\t * Users shouldn't get the SLURM_RLIMIT_* env vars in their environ\n\t */\n\tunsetenvp( env, env_name );\n\n\t/*\n\t * We'll only attempt to set the propagated soft rlimit when indicated\n\t * by the slurm conf file settings, or the user requested it.\n\t */\n\tif ( ! (rli->propagate_flag == PROPAGATE_RLIMITS || u_req_propagate))\n\t\treturn SLURM_SUCCESS;\n\n\tif (getrlimit( rli->resource, &r ) < 0) {\n\t\terror(\"getrlimit(%s): %m\", rlimit_name);\n\t\treturn SLURM_ERROR;\n\t}\n\n\t/*\n\t * Nothing to do if the rlimit won't change\n\t */\n\tif (r.rlim_cur == (rlim_t) env_value) {\n\t\tdebug2( \"_set_limit: %s setrlimit %s no change in value: %lu\",\n\t\t\tu_req_propagate?\"user\":\"conf\", rlimit_name,\n\t\t\t(unsigned long) r.rlim_cur);\n\t\treturn SLURM_SUCCESS;\n\t}\n\n\tdebug2(\"_set_limit: %-14s: max:%s cur:%s req:%s\", rlimit_name,\n\t\trlim_to_string (r.rlim_max, max, sizeof (max)),\n\t\trlim_to_string (r.rlim_cur, cur, sizeof (cur)),\n\t\trlim_to_string (env_value,  req, sizeof (req)) );\n\n\tr.rlim_cur = (rlim_t) env_value;\n\tif (r.rlim_max < r.rlim_cur)\n\t\tr.rlim_max = r.rlim_cur;\n\n\tif (setrlimit( rli->resource, &r ) < 0) {\n\t\t/*\n\t\t * Report an error only if the user requested propagate\n\t\t */\n\t\tif (u_req_propagate) {\n\t\t\terror( \"Can't propagate %s of %s from submit host: %m\",\n\t\t\t\trlimit_name,\n\t\t\t\tr.rlim_cur == RLIM_INFINITY ? \"'unlimited'\" :\n\t\t\t\trlim_to_string( r.rlim_cur, cur, sizeof(cur)));\n\t\t} else {\n\t\t\tverbose(\"Can't propagate %s of %s from submit host: %m\",\n\t\t\t\trlimit_name,\n\t\t\t\tr.rlim_cur == RLIM_INFINITY ? \"'unlimited'\" :\n\t\t\t\trlim_to_string( r.rlim_cur, cur, sizeof(cur)));\n\t\t}\n\t\treturn SLURM_ERROR;\n\t}\n\tdebug2( \"_set_limit: %s setrlimit %s succeeded\",\n\t\t\tu_req_propagate?\"user\":\"conf\", rlimit_name );\n\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "set_umask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/ulimits.c",
    "lines": "181-199",
    "snippet": "extern int\nset_umask(stepd_step_rec_t *job)\n{\n\tmode_t mask;\n\tchar *val;\n\n\tif (!(val = getenvp(job->env, \"SLURM_UMASK\"))) {\n\t\tif (job->stepid != SLURM_EXTERN_CONT)\n\t\t\tdebug(\"Couldn't find SLURM_UMASK in environment\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\tmask = strtol(val, (char **)NULL, 8);\n\tif ((job->stepid == SLURM_EXTERN_CONT) ||\n\t    (job->stepid == SLURM_BATCH_SCRIPT))\n\t\tunsetenvp(job->env, \"SLURM_UMASK\");\n\tumask(mask);\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/strlcpy.h\"",
      "#include \"src/common/env.h\" /* For unsetenvp() */",
      "#include \"src/common/log.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "mask"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "set_umask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/ulimits.c",
          "lines": "181-199",
          "snippet": "extern int\nset_umask(stepd_step_rec_t *job)\n{\n\tmode_t mask;\n\tchar *val;\n\n\tif (!(val = getenvp(job->env, \"SLURM_UMASK\"))) {\n\t\tif (job->stepid != SLURM_EXTERN_CONT)\n\t\t\tdebug(\"Couldn't find SLURM_UMASK in environment\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\tmask = strtol(val, (char **)NULL, 8);\n\tif ((job->stepid == SLURM_EXTERN_CONT) ||\n\t    (job->stepid == SLURM_BATCH_SCRIPT))\n\t\tunsetenvp(job->env, \"SLURM_UMASK\");\n\tumask(mask);\n\treturn SLURM_SUCCESS;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "unsetenvp",
          "args": [
            "job->env",
            "\"SLURM_UMASK\""
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtol",
          "args": [
            "val",
            "(char **)NULL",
            "8"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Couldn't find SLURM_UMASK in environment\""
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_stop_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "120-139",
          "snippet": "void\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "getenvp",
          "args": [
            "job->env",
            "\"SLURM_UMASK\""
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/strlcpy.h\"\n#include \"src/common/env.h\" /* For unsetenvp() */\n#include \"src/common/log.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#  include \"config.h\"\n\nextern int\nset_umask(stepd_step_rec_t *job)\n{\n\tmode_t mask;\n\tchar *val;\n\n\tif (!(val = getenvp(job->env, \"SLURM_UMASK\"))) {\n\t\tif (job->stepid != SLURM_EXTERN_CONT)\n\t\t\tdebug(\"Couldn't find SLURM_UMASK in environment\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\tmask = strtol(val, (char **)NULL, 8);\n\tif ((job->stepid == SLURM_EXTERN_CONT) ||\n\t    (job->stepid == SLURM_BATCH_SCRIPT))\n\t\tunsetenvp(job->env, \"SLURM_UMASK\");\n\tumask(mask);\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "rlim_to_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/ulimits.c",
    "lines": "171-178",
    "snippet": "static char * rlim_to_string (unsigned long rlim, char *buf, size_t n)\n{\n\tif (rlim == (unsigned long) RLIM_INFINITY)\n\t\tstrlcpy (buf, \"inf\", n);\n\telse\n\t\tsnprintf (buf, n, \"%lu\", rlim);\n\treturn (buf);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/strlcpy.h\"",
      "#include \"src/common/env.h\" /* For unsetenvp() */",
      "#include \"src/common/log.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "n",
            "\"%lu\"",
            "rlim"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlcpy",
          "args": [
            "buf",
            "\"inf\"",
            "n"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/strlcpy.h\"\n#include \"src/common/env.h\" /* For unsetenvp() */\n#include \"src/common/log.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#  include \"config.h\"\n\nstatic char * rlim_to_string (unsigned long rlim, char *buf, size_t n)\n{\n\tif (rlim == (unsigned long) RLIM_INFINITY)\n\t\tstrlcpy (buf, \"inf\", n);\n\telse\n\t\tsnprintf (buf, n, \"%lu\", rlim);\n\treturn (buf);\n}"
  },
  {
    "function_name": "set_user_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/ulimits.c",
    "lines": "88-166",
    "snippet": "int set_user_limits(stepd_step_rec_t *job)\n{\n#ifdef RLIMIT_AS\n#define SLURM_RLIMIT_VSIZE RLIMIT_AS\n#define SLURM_RLIMIT_VNAME \"RLIMIT_AS\"\n#elif defined(RLIMIT_DATA)\n/* RLIMIT_DATA is useless on many systems which provide anonymous\n * mmap()'s in addition to brk(), use it here only as a fallback for\n * oddball systems lacking RLIMIT_AS. */\n#define SLURM_RLIMIT_VSIZE RLIMIT_DATA\n#define SLURM_RLIMIT_VNAME \"RLIMIT_DATA\"\n#endif\n\tslurm_rlimits_info_t *rli;\n\tstruct rlimit r;\n\trlim_t task_mem_bytes;\n#ifdef SLURM_RLIMIT_VSIZE\n\tuint16_t vsize_factor;\n#endif\n\n\tif (getrlimit(RLIMIT_CPU, &r) == 0) {\n\t\tif (r.rlim_max != RLIM_INFINITY) {\n\t\t\terror(\"SLURM process CPU time limit is %d seconds\",\n\t\t\t      (int) r.rlim_max);\n\t\t}\n\t}\n\n\tfor (rli = get_slurm_rlimits_info(); rli->name; rli++)\n\t\t_set_limit( job->env, rli );\n\n\t/* Set soft and hard rss and vsize limit for this process,\n\t * handle job limit (for all spawned processes) in slurmd */\n\ttask_mem_bytes  = job->step_mem;\t/* MB */\n\ttask_mem_bytes *= (1024 * 1024);\n\n\t/* Many systems, Linux included, ignore RSS limits, but set it\n\t * here anyway for consistency and to provide a way for\n\t * applications to interrogate what the RSS limit is (with the\n\t * caveat that the real RSS limit is over all job tasks on the\n\t * node and not per process, but hopefully this is better than\n\t * nothing).  */\n#ifdef RLIMIT_RSS\n\tif ((task_mem_bytes) && (getrlimit(RLIMIT_RSS, &r) == 0) &&\n\t    (r.rlim_max > task_mem_bytes)) {\n\t\tr.rlim_max =  r.rlim_cur = task_mem_bytes;\n\t\tif (setrlimit(RLIMIT_RSS, &r)) {\n\t\t\t/* Indicates that limit has already been exceeded */\n\t\t\tfatal(\"setrlimit(RLIMIT_RSS, %u MB): %m\",\n\t\t\t      job->step_mem);\n\t\t} else\n\t\t\tdebug2(\"Set task rss(%u MB)\", job->step_mem);\n#if 0\n\t\tgetrlimit(RLIMIT_RSS, &r);\n\t\tinfo(\"task RSS limits: %u %u\", r.rlim_cur, r.rlim_max);\n#endif\n\t}\n#endif\n\n#ifdef SLURM_RLIMIT_VSIZE\n\tif ((task_mem_bytes) &&\n\t    ((vsize_factor = slurm_get_vsize_factor()) != 0) &&\n\t    (getrlimit(SLURM_RLIMIT_VSIZE, &r) == 0) &&\n\t    (r.rlim_max > task_mem_bytes)) {\n\t\tr.rlim_max = task_mem_bytes * (vsize_factor / 100.0);\n\t\tr.rlim_cur = r.rlim_max;\n\t\tif (setrlimit(SLURM_RLIMIT_VSIZE, &r)) {\n\t\t\t/* Indicates that limit has already been exceeded */\n\t\t\tfatal(\"setrlimit(%s, %u MB): %m\", \n\t\t\t      SLURM_RLIMIT_VNAME, job->step_mem);\n\t\t} else\n\t\t\tdebug2(\"Set task vsize(%u MB)\", job->step_mem);\n#if 0\n\t\tgetrlimit(SLURM_RLIMIT_VSIZE, &r);\n\t\tinfo(\"task VSIZE limits:   %u %u\", r.rlim_cur, r.rlim_max);\n#endif\n\t}\n#endif\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/strlcpy.h\"",
      "#include \"src/common/env.h\" /* For unsetenvp() */",
      "#include \"src/common/log.h\"",
      "#include <string.h>",
      "#include <stdlib.h>",
      "#include <unistd.h>",
      "#include <sys/types.h>",
      "#include <sys/stat.h>",
      "#include <sys/resource.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define SLURM_RLIMIT_VNAME \"RLIMIT_DATA\"",
      "#define SLURM_RLIMIT_VSIZE RLIMIT_DATA",
      "#define SLURM_RLIMIT_VNAME \"RLIMIT_AS\"",
      "#define SLURM_RLIMIT_VSIZE RLIMIT_AS"
    ],
    "globals_used": [
      "static int _set_limit(char **env, slurm_rlimits_info_t *rli);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "info",
          "args": [
            "\"task VSIZE limits:   %u %u\"",
            "r.rlim_cur",
            "r.rlim_max"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "_chk_cpuinfo_float",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/get_mach_stat.c",
          "lines": "414-423",
          "snippet": "static int _chk_cpuinfo_float(char *buffer, char *keyword, float *val)\n{\n\tchar *valptr;\n\tif (_chk_cpuinfo_str(buffer, keyword, &valptr)) {\n\t\t*val = (float) strtod(valptr, (char **)NULL);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/slurmctld/slurmctld.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/parse_spec.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include <unistd.h>",
            "# include <kstat.h>",
            "#  include <sys/vfs.h>",
            "#  include <sys/statfs.h>",
            "#  include <sys/statvfs.h>",
            "#include <sys/utsname.h>",
            "#  include <sys/sysinfo.h>",
            "#  include <sys/times.h> /* for times(3) */",
            "#  include <sys/types.h>",
            "#  include <sys/times.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "# include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "# include <sys/dr.h>",
            "# include <sys/systemcfg.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/slurmctld/slurmctld.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/parse_spec.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include <unistd.h>\n# include <kstat.h>\n#  include <sys/vfs.h>\n#  include <sys/statfs.h>\n#  include <sys/statvfs.h>\n#include <sys/utsname.h>\n#  include <sys/sysinfo.h>\n#  include <sys/times.h> /* for times(3) */\n#  include <sys/types.h>\n#  include <sys/times.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n# include <sys/sysctl.h>\n#include <sys/types.h>\n# include <sys/dr.h>\n# include <sys/systemcfg.h>\n#  include \"config.h\"\n\nstatic int _chk_cpuinfo_float(char *buffer, char *keyword, float *val)\n{\n\tchar *valptr;\n\tif (_chk_cpuinfo_str(buffer, keyword, &valptr)) {\n\t\t*val = (float) strtod(valptr, (char **)NULL);\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrlimit",
          "args": [
            "SLURM_RLIMIT_VSIZE",
            "&r"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"Set task vsize(%u MB)\"",
            "job->step_mem"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"setrlimit(%s, %u MB): %m\"",
            "SLURM_RLIMIT_VNAME",
            "job->step_mem"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setrlimit",
          "args": [
            "SLURM_RLIMIT_VSIZE",
            "&r"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getrlimit",
          "args": [
            "SLURM_RLIMIT_VSIZE",
            "&r"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_get_vsize_factor",
          "args": [],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getrlimit",
          "args": [
            "RLIMIT_RSS",
            "&r"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"Set task rss(%u MB)\"",
            "job->step_mem"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"setrlimit(RLIMIT_RSS, %u MB): %m\"",
            "job->step_mem"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setrlimit",
          "args": [
            "RLIMIT_RSS",
            "&r"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getrlimit",
          "args": [
            "RLIMIT_RSS",
            "&r"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_set_limit",
          "args": [
            "job->env",
            "rli"
          ],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "_set_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/ulimits.c",
          "lines": "214-289",
          "snippet": "static int\n_set_limit(char **env, slurm_rlimits_info_t *rli)\n{\n\tunsigned long env_value;\n\tchar max[24], cur[24], req[24];\n\tstruct rlimit r;\n\tbool u_req_propagate;  /* e.g. TRUE if 'srun --propagate' */\n\n\tchar env_name[25] = \"SLURM_RLIMIT_\";\n\tchar *rlimit_name = &env_name[6];\n\n\tstrcpy( &env_name[sizeof(\"SLURM_RLIMIT_\")-1], rli->name );\n\n\tif (_get_env_val( env, env_name, &env_value, &u_req_propagate )){\n\t\tdebug( \"Couldn't find %s in environment\", env_name );\n\t\treturn SLURM_ERROR;\n\t}\n\n\t/*\n\t * Users shouldn't get the SLURM_RLIMIT_* env vars in their environ\n\t */\n\tunsetenvp( env, env_name );\n\n\t/*\n\t * We'll only attempt to set the propagated soft rlimit when indicated\n\t * by the slurm conf file settings, or the user requested it.\n\t */\n\tif ( ! (rli->propagate_flag == PROPAGATE_RLIMITS || u_req_propagate))\n\t\treturn SLURM_SUCCESS;\n\n\tif (getrlimit( rli->resource, &r ) < 0) {\n\t\terror(\"getrlimit(%s): %m\", rlimit_name);\n\t\treturn SLURM_ERROR;\n\t}\n\n\t/*\n\t * Nothing to do if the rlimit won't change\n\t */\n\tif (r.rlim_cur == (rlim_t) env_value) {\n\t\tdebug2( \"_set_limit: %s setrlimit %s no change in value: %lu\",\n\t\t\tu_req_propagate?\"user\":\"conf\", rlimit_name,\n\t\t\t(unsigned long) r.rlim_cur);\n\t\treturn SLURM_SUCCESS;\n\t}\n\n\tdebug2(\"_set_limit: %-14s: max:%s cur:%s req:%s\", rlimit_name,\n\t\trlim_to_string (r.rlim_max, max, sizeof (max)),\n\t\trlim_to_string (r.rlim_cur, cur, sizeof (cur)),\n\t\trlim_to_string (env_value,  req, sizeof (req)) );\n\n\tr.rlim_cur = (rlim_t) env_value;\n\tif (r.rlim_max < r.rlim_cur)\n\t\tr.rlim_max = r.rlim_cur;\n\n\tif (setrlimit( rli->resource, &r ) < 0) {\n\t\t/*\n\t\t * Report an error only if the user requested propagate\n\t\t */\n\t\tif (u_req_propagate) {\n\t\t\terror( \"Can't propagate %s of %s from submit host: %m\",\n\t\t\t\trlimit_name,\n\t\t\t\tr.rlim_cur == RLIM_INFINITY ? \"'unlimited'\" :\n\t\t\t\trlim_to_string( r.rlim_cur, cur, sizeof(cur)));\n\t\t} else {\n\t\t\tverbose(\"Can't propagate %s of %s from submit host: %m\",\n\t\t\t\trlimit_name,\n\t\t\t\tr.rlim_cur == RLIM_INFINITY ? \"'unlimited'\" :\n\t\t\t\trlim_to_string( r.rlim_cur, cur, sizeof(cur)));\n\t\t}\n\t\treturn SLURM_ERROR;\n\t}\n\tdebug2( \"_set_limit: %s setrlimit %s succeeded\",\n\t\t\tu_req_propagate?\"user\":\"conf\", rlimit_name );\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/strlcpy.h\"",
            "#include \"src/common/env.h\" /* For unsetenvp() */",
            "#include \"src/common/log.h\"",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _get_env_val(char **env, const char *name, unsigned long *valp,\n\t\tbool *u_req_propagate);",
            "static int _set_limit(char **env, slurm_rlimits_info_t *rli);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/strlcpy.h\"\n#include \"src/common/env.h\" /* For unsetenvp() */\n#include \"src/common/log.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#  include \"config.h\"\n\nstatic int _get_env_val(char **env, const char *name, unsigned long *valp,\n\t\tbool *u_req_propagate);\nstatic int _set_limit(char **env, slurm_rlimits_info_t *rli);\n\nstatic int\n_set_limit(char **env, slurm_rlimits_info_t *rli)\n{\n\tunsigned long env_value;\n\tchar max[24], cur[24], req[24];\n\tstruct rlimit r;\n\tbool u_req_propagate;  /* e.g. TRUE if 'srun --propagate' */\n\n\tchar env_name[25] = \"SLURM_RLIMIT_\";\n\tchar *rlimit_name = &env_name[6];\n\n\tstrcpy( &env_name[sizeof(\"SLURM_RLIMIT_\")-1], rli->name );\n\n\tif (_get_env_val( env, env_name, &env_value, &u_req_propagate )){\n\t\tdebug( \"Couldn't find %s in environment\", env_name );\n\t\treturn SLURM_ERROR;\n\t}\n\n\t/*\n\t * Users shouldn't get the SLURM_RLIMIT_* env vars in their environ\n\t */\n\tunsetenvp( env, env_name );\n\n\t/*\n\t * We'll only attempt to set the propagated soft rlimit when indicated\n\t * by the slurm conf file settings, or the user requested it.\n\t */\n\tif ( ! (rli->propagate_flag == PROPAGATE_RLIMITS || u_req_propagate))\n\t\treturn SLURM_SUCCESS;\n\n\tif (getrlimit( rli->resource, &r ) < 0) {\n\t\terror(\"getrlimit(%s): %m\", rlimit_name);\n\t\treturn SLURM_ERROR;\n\t}\n\n\t/*\n\t * Nothing to do if the rlimit won't change\n\t */\n\tif (r.rlim_cur == (rlim_t) env_value) {\n\t\tdebug2( \"_set_limit: %s setrlimit %s no change in value: %lu\",\n\t\t\tu_req_propagate?\"user\":\"conf\", rlimit_name,\n\t\t\t(unsigned long) r.rlim_cur);\n\t\treturn SLURM_SUCCESS;\n\t}\n\n\tdebug2(\"_set_limit: %-14s: max:%s cur:%s req:%s\", rlimit_name,\n\t\trlim_to_string (r.rlim_max, max, sizeof (max)),\n\t\trlim_to_string (r.rlim_cur, cur, sizeof (cur)),\n\t\trlim_to_string (env_value,  req, sizeof (req)) );\n\n\tr.rlim_cur = (rlim_t) env_value;\n\tif (r.rlim_max < r.rlim_cur)\n\t\tr.rlim_max = r.rlim_cur;\n\n\tif (setrlimit( rli->resource, &r ) < 0) {\n\t\t/*\n\t\t * Report an error only if the user requested propagate\n\t\t */\n\t\tif (u_req_propagate) {\n\t\t\terror( \"Can't propagate %s of %s from submit host: %m\",\n\t\t\t\trlimit_name,\n\t\t\t\tr.rlim_cur == RLIM_INFINITY ? \"'unlimited'\" :\n\t\t\t\trlim_to_string( r.rlim_cur, cur, sizeof(cur)));\n\t\t} else {\n\t\t\tverbose(\"Can't propagate %s of %s from submit host: %m\",\n\t\t\t\trlimit_name,\n\t\t\t\tr.rlim_cur == RLIM_INFINITY ? \"'unlimited'\" :\n\t\t\t\trlim_to_string( r.rlim_cur, cur, sizeof(cur)));\n\t\t}\n\t\treturn SLURM_ERROR;\n\t}\n\tdebug2( \"_set_limit: %s setrlimit %s succeeded\",\n\t\t\tu_req_propagate?\"user\":\"conf\", rlimit_name );\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_slurm_rlimits_info",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"SLURM process CPU time limit is %d seconds\"",
            "(int) r.rlim_max"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "_task_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "641-650",
          "snippet": "static int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static bool _task_writable(eio_obj_t *);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int _task_write_error(eio_obj_t *obj, List objs);",
            "static bool _task_readable(eio_obj_t *);",
            "static int  _task_read(eio_obj_t *, List);",
            "static void _route_msg_task_to_client(eio_obj_t *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getrlimit",
          "args": [
            "RLIMIT_CPU",
            "&r"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/strlcpy.h\"\n#include \"src/common/env.h\" /* For unsetenvp() */\n#include \"src/common/log.h\"\n#include <string.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#  include \"config.h\"\n\n#define SLURM_RLIMIT_VNAME \"RLIMIT_DATA\"\n#define SLURM_RLIMIT_VSIZE RLIMIT_DATA\n#define SLURM_RLIMIT_VNAME \"RLIMIT_AS\"\n#define SLURM_RLIMIT_VSIZE RLIMIT_AS\n\nstatic int _set_limit(char **env, slurm_rlimits_info_t *rli);\n\nint set_user_limits(stepd_step_rec_t *job)\n{\n#ifdef RLIMIT_AS\n#define SLURM_RLIMIT_VSIZE RLIMIT_AS\n#define SLURM_RLIMIT_VNAME \"RLIMIT_AS\"\n#elif defined(RLIMIT_DATA)\n/* RLIMIT_DATA is useless on many systems which provide anonymous\n * mmap()'s in addition to brk(), use it here only as a fallback for\n * oddball systems lacking RLIMIT_AS. */\n#define SLURM_RLIMIT_VSIZE RLIMIT_DATA\n#define SLURM_RLIMIT_VNAME \"RLIMIT_DATA\"\n#endif\n\tslurm_rlimits_info_t *rli;\n\tstruct rlimit r;\n\trlim_t task_mem_bytes;\n#ifdef SLURM_RLIMIT_VSIZE\n\tuint16_t vsize_factor;\n#endif\n\n\tif (getrlimit(RLIMIT_CPU, &r) == 0) {\n\t\tif (r.rlim_max != RLIM_INFINITY) {\n\t\t\terror(\"SLURM process CPU time limit is %d seconds\",\n\t\t\t      (int) r.rlim_max);\n\t\t}\n\t}\n\n\tfor (rli = get_slurm_rlimits_info(); rli->name; rli++)\n\t\t_set_limit( job->env, rli );\n\n\t/* Set soft and hard rss and vsize limit for this process,\n\t * handle job limit (for all spawned processes) in slurmd */\n\ttask_mem_bytes  = job->step_mem;\t/* MB */\n\ttask_mem_bytes *= (1024 * 1024);\n\n\t/* Many systems, Linux included, ignore RSS limits, but set it\n\t * here anyway for consistency and to provide a way for\n\t * applications to interrogate what the RSS limit is (with the\n\t * caveat that the real RSS limit is over all job tasks on the\n\t * node and not per process, but hopefully this is better than\n\t * nothing).  */\n#ifdef RLIMIT_RSS\n\tif ((task_mem_bytes) && (getrlimit(RLIMIT_RSS, &r) == 0) &&\n\t    (r.rlim_max > task_mem_bytes)) {\n\t\tr.rlim_max =  r.rlim_cur = task_mem_bytes;\n\t\tif (setrlimit(RLIMIT_RSS, &r)) {\n\t\t\t/* Indicates that limit has already been exceeded */\n\t\t\tfatal(\"setrlimit(RLIMIT_RSS, %u MB): %m\",\n\t\t\t      job->step_mem);\n\t\t} else\n\t\t\tdebug2(\"Set task rss(%u MB)\", job->step_mem);\n#if 0\n\t\tgetrlimit(RLIMIT_RSS, &r);\n\t\tinfo(\"task RSS limits: %u %u\", r.rlim_cur, r.rlim_max);\n#endif\n\t}\n#endif\n\n#ifdef SLURM_RLIMIT_VSIZE\n\tif ((task_mem_bytes) &&\n\t    ((vsize_factor = slurm_get_vsize_factor()) != 0) &&\n\t    (getrlimit(SLURM_RLIMIT_VSIZE, &r) == 0) &&\n\t    (r.rlim_max > task_mem_bytes)) {\n\t\tr.rlim_max = task_mem_bytes * (vsize_factor / 100.0);\n\t\tr.rlim_cur = r.rlim_max;\n\t\tif (setrlimit(SLURM_RLIMIT_VSIZE, &r)) {\n\t\t\t/* Indicates that limit has already been exceeded */\n\t\t\tfatal(\"setrlimit(%s, %u MB): %m\", \n\t\t\t      SLURM_RLIMIT_VNAME, job->step_mem);\n\t\t} else\n\t\t\tdebug2(\"Set task vsize(%u MB)\", job->step_mem);\n#if 0\n\t\tgetrlimit(SLURM_RLIMIT_VSIZE, &r);\n\t\tinfo(\"task VSIZE limits:   %u %u\", r.rlim_cur, r.rlim_max);\n#endif\n\t}\n#endif\n\n\treturn SLURM_SUCCESS;\n}"
  }
]