[
  {
    "function_name": "wait_for_resumed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1806-1820",
    "snippet": "extern void wait_for_resumed(uint16_t msg_type)\n{\n\tint i;\n\n\tfor (i = 0; ; i++) {\n\t\tif (i)\n\t\t\tsleep(1);\n\t\tif (!suspended)\n\t\t\treturn;\n\t\tif (i == 0) {\n\t\t\tinfo(\"defer sending msg_type %u to suspended job\",\n\t\t\t     msg_type);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static bool suspended = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "info",
          "args": [
            "\"defer sending msg_type %u to suspended job\"",
            "msg_type"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_task_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1726-1747",
          "snippet": "static int\n_handle_task_info(int fd, stepd_step_rec_t *job)\n{\n\tint i;\n\tstepd_step_task_info_t *task;\n\n\tdebug(\"_handle_task_info for job %u.%u\", job->jobid, job->stepid);\n\n\tsafe_write(fd, &job->node_tasks, sizeof(uint32_t));\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\ttask = job->task[i];\n\t\tsafe_write(fd, &task->id, sizeof(int));\n\t\tsafe_write(fd, &task->gtid, sizeof(uint32_t));\n\t\tsafe_write(fd, &task->pid, sizeof(pid_t));\n\t\tsafe_write(fd, &task->exited, sizeof(bool));\n\t\tsafe_write(fd, &task->estatus, sizeof(int));\n\t}\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_task_info(int fd, stepd_step_rec_t *job)\n{\n\tint i;\n\tstepd_step_task_info_t *task;\n\n\tdebug(\"_handle_task_info for job %u.%u\", job->jobid, job->stepid);\n\n\tsafe_write(fd, &job->node_tasks, sizeof(uint32_t));\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\ttask = job->task[i];\n\t\tsafe_write(fd, &task->id, sizeof(int));\n\t\tsafe_write(fd, &task->gtid, sizeof(uint32_t));\n\t\tsafe_write(fd, &task->pid, sizeof(pid_t));\n\t\tsafe_write(fd, &task->exited, sizeof(bool));\n\t\tsafe_write(fd, &task->estatus, sizeof(int));\n\t}\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "_random_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "664-678",
          "snippet": "static void\n_random_sleep(stepd_step_rec_t *job)\n{\n#if !defined HAVE_FRONT_END\n\tlong int delay = 0;\n\tlong int max   = (slurm_get_tcp_timeout() * job->nnodes);\n\n\tmax = MIN(max, 5000);\n\tsrand48((long int) (job->jobid + job->nodeid));\n\n\tdelay = lrand48() % ( max + 1 );\n\tdebug3(\"delaying %ldms\", delay);\n\tpoll(NULL, 0, delay);\n#endif\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int _initgroups(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int _initgroups(stepd_step_rec_t *job);\n\nstatic void\n_random_sleep(stepd_step_rec_t *job)\n{\n#if !defined HAVE_FRONT_END\n\tlong int delay = 0;\n\tlong int max   = (slurm_get_tcp_timeout() * job->nnodes);\n\n\tmax = MIN(max, 5000);\n\tsrand48((long int) (job->jobid + job->nodeid));\n\n\tdelay = lrand48() % ( max + 1 );\n\tdebug3(\"delaying %ldms\", delay);\n\tpoll(NULL, 0, delay);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic bool suspended = false;\n\nextern void wait_for_resumed(uint16_t msg_type)\n{\n\tint i;\n\n\tfor (i = 0; ; i++) {\n\t\tif (i)\n\t\t\tsleep(1);\n\t\tif (!suspended)\n\t\t\treturn;\n\t\tif (i == 0) {\n\t\t\tinfo(\"defer sending msg_type %u to suspended job\",\n\t\t\t     msg_type);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "_handle_reconfig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1775-1804",
    "snippet": "static int\n_handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"job step reconfigure request from uid %ld \"\n\t\t      \"for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t/* We just want to make sure the file handle is correct on a\n\t   reconfigure since the file could had rolled thus making\n\t   the currect fd incorrect. */\n\tlog_alter(conf->log_opts, SYSLOG_FACILITY_DAEMON, conf->logfile);\n\tdebug(\"_handle_reconfigure for job %u.%u successful\",\n\t      job->jobid, job->stepid);\n\ndone:\n\t/* Send the return code and errno */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&errnum",
            "sizeof(int)"
          ],
          "line": 1800
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 1799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"_handle_reconfigure for job %u.%u successful\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_alter",
          "args": [
            "conf->log_opts",
            "SYSLOG_FACILITY_DAEMON",
            "conf->logfile"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"job step reconfigure request from uid %ld \"\n\t\t      \"for job %u.%u \"",
            "(long)uid",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_slurm_authorized_user",
          "args": [
            "uid"
          ],
          "line": 1781
        },
        "resolved": true,
        "details": {
          "function_name": "_slurm_authorized_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "136-140",
          "snippet": "static bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"job step reconfigure request from uid %ld \"\n\t\t      \"for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t/* We just want to make sure the file handle is correct on a\n\t   reconfigure since the file could had rolled thus making\n\t   the currect fd incorrect. */\n\tlog_alter(conf->log_opts, SYSLOG_FACILITY_DAEMON, conf->logfile);\n\tdebug(\"_handle_reconfigure for job %u.%u successful\",\n\t      job->jobid, job->stepid);\n\ndone:\n\t/* Send the return code and errno */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_list_pids",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1750-1773",
    "snippet": "static int\n_handle_list_pids(int fd, stepd_step_rec_t *job)\n{\n\tint i;\n\tpid_t *pids = NULL;\n\tint npids = 0;\n\tuint32_t pid;\n\n\tdebug(\"_handle_list_pids for job %u.%u\", job->jobid, job->stepid);\n\tproctrack_g_get_pids(job->cont_id, &pids, &npids);\n\tsafe_write(fd, &npids, sizeof(uint32_t));\n\tfor (i = 0; i < npids; i++) {\n\t\tpid = (uint32_t)pids[i];\n\t\tsafe_write(fd, &pid, sizeof(uint32_t));\n\t}\n\tif (npids > 0)\n\t\txfree(pids);\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\tif (npids > 0)\n\t\txfree(pids);\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "pids"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&pid",
            "sizeof(uint32_t)"
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&npids",
            "sizeof(uint32_t)"
          ],
          "line": 1760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proctrack_g_get_pids",
          "args": [
            "job->cont_id",
            "&pids",
            "&npids"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "proctrack_g_get_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/proctrack.c",
          "lines": "468-475",
          "snippet": "extern int\nproctrack_g_get_pids(uint64_t cont_id, pid_t ** pids, int *npids)\n{\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\treturn (*(ops.get_pids)) (cont_id, pids, npids);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/log.h\"",
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static slurm_proctrack_ops_t ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/log.h\"\n#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic slurm_proctrack_ops_t ops;\n\nextern int\nproctrack_g_get_pids(uint64_t cont_id, pid_t ** pids, int *npids)\n{\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\treturn (*(ops.get_pids)) (cont_id, pids, npids);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"_handle_list_pids for job %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_list_pids(int fd, stepd_step_rec_t *job)\n{\n\tint i;\n\tpid_t *pids = NULL;\n\tint npids = 0;\n\tuint32_t pid;\n\n\tdebug(\"_handle_list_pids for job %u.%u\", job->jobid, job->stepid);\n\tproctrack_g_get_pids(job->cont_id, &pids, &npids);\n\tsafe_write(fd, &npids, sizeof(uint32_t));\n\tfor (i = 0; i < npids; i++) {\n\t\tpid = (uint32_t)pids[i];\n\t\tsafe_write(fd, &pid, sizeof(uint32_t));\n\t}\n\tif (npids > 0)\n\t\txfree(pids);\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\tif (npids > 0)\n\t\txfree(pids);\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_task_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1726-1747",
    "snippet": "static int\n_handle_task_info(int fd, stepd_step_rec_t *job)\n{\n\tint i;\n\tstepd_step_task_info_t *task;\n\n\tdebug(\"_handle_task_info for job %u.%u\", job->jobid, job->stepid);\n\n\tsafe_write(fd, &job->node_tasks, sizeof(uint32_t));\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\ttask = job->task[i];\n\t\tsafe_write(fd, &task->id, sizeof(int));\n\t\tsafe_write(fd, &task->gtid, sizeof(uint32_t));\n\t\tsafe_write(fd, &task->pid, sizeof(pid_t));\n\t\tsafe_write(fd, &task->exited, sizeof(bool));\n\t\tsafe_write(fd, &task->estatus, sizeof(int));\n\t}\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&task->estatus",
            "sizeof(int)"
          ],
          "line": 1741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&task->exited",
            "sizeof(bool)"
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&task->pid",
            "sizeof(pid_t)"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&task->gtid",
            "sizeof(uint32_t)"
          ],
          "line": 1738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&task->id",
            "sizeof(int)"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->node_tasks",
            "sizeof(uint32_t)"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"_handle_task_info for job %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1732
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_task_info(int fd, stepd_step_rec_t *job)\n{\n\tint i;\n\tstepd_step_task_info_t *task;\n\n\tdebug(\"_handle_task_info for job %u.%u\", job->jobid, job->stepid);\n\n\tsafe_write(fd, &job->node_tasks, sizeof(uint32_t));\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\ttask = job->task[i];\n\t\tsafe_write(fd, &task->id, sizeof(int));\n\t\tsafe_write(fd, &task->gtid, sizeof(uint32_t));\n\t\tsafe_write(fd, &task->pid, sizeof(pid_t));\n\t\tsafe_write(fd, &task->exited, sizeof(bool));\n\t\tsafe_write(fd, &task->estatus, sizeof(int));\n\t}\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_stat_jobacct",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1681-1723",
    "snippet": "static int\n_handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tjobacctinfo_t *jobacct = NULL;\n\tjobacctinfo_t *temp_jobacct = NULL;\n\tint i = 0;\n\tint num_tasks = 0;\n\tdebug(\"_handle_stat_jobacct for job %u.%u\",\n\t      job->jobid, job->stepid);\n\n\tdebug3(\"  uid = %d\", uid);\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"stat jobacct from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\t/* Send NULL */\n\t\tjobacctinfo_setinfo(jobacct, JOBACCT_DATA_PIPE, &fd,\n\t\t\t\t    SLURM_PROTOCOL_VERSION);\n\t\treturn SLURM_ERROR;\n\t}\n\n\tjobacct = jobacctinfo_create(NULL);\n\tdebug3(\"num tasks = %d\", job->node_tasks);\n\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\ttemp_jobacct = jobacct_gather_stat_task(job->task[i]->pid);\n\t\tif (temp_jobacct) {\n\t\t\tjobacctinfo_aggregate(jobacct, temp_jobacct);\n\t\t\tjobacctinfo_destroy(temp_jobacct);\n\t\t\tnum_tasks++;\n\t\t}\n\t}\n\n\tjobacctinfo_setinfo(jobacct, JOBACCT_DATA_PIPE, &fd,\n\t\t\t    SLURM_PROTOCOL_VERSION);\n\tsafe_write(fd, &num_tasks, sizeof(int));\n\n\tjobacctinfo_destroy(jobacct);\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_ERROR;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "jobacctinfo_destroy",
          "args": [
            "jobacct"
          ],
          "line": 1718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&num_tasks",
            "sizeof(int)"
          ],
          "line": 1716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacctinfo_setinfo",
          "args": [
            "jobacct",
            "JOBACCT_DATA_PIPE",
            "&fd",
            "SLURM_PROTOCOL_VERSION"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacctinfo_destroy",
          "args": [
            "temp_jobacct"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacctinfo_aggregate",
          "args": [
            "jobacct",
            "temp_jobacct"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacct_gather_stat_task",
          "args": [
            "job->task[i]->pid"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"num tasks = %d\"",
            "job->node_tasks"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacctinfo_create",
          "args": [
            "NULL"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacctinfo_setinfo",
          "args": [
            "jobacct",
            "JOBACCT_DATA_PIPE",
            "&fd",
            "SLURM_PROTOCOL_VERSION"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"stat jobacct from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\"",
            "(long)uid",
            "job->jobid",
            "job->stepid",
            "(long)job->uid"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_slurm_authorized_user",
          "args": [
            "uid"
          ],
          "line": 1692
        },
        "resolved": true,
        "details": {
          "function_name": "_slurm_authorized_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "136-140",
          "snippet": "static bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"  uid = %d\"",
            "uid"
          ],
          "line": 1691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"_handle_stat_jobacct for job %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tjobacctinfo_t *jobacct = NULL;\n\tjobacctinfo_t *temp_jobacct = NULL;\n\tint i = 0;\n\tint num_tasks = 0;\n\tdebug(\"_handle_stat_jobacct for job %u.%u\",\n\t      job->jobid, job->stepid);\n\n\tdebug3(\"  uid = %d\", uid);\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"stat jobacct from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\t/* Send NULL */\n\t\tjobacctinfo_setinfo(jobacct, JOBACCT_DATA_PIPE, &fd,\n\t\t\t\t    SLURM_PROTOCOL_VERSION);\n\t\treturn SLURM_ERROR;\n\t}\n\n\tjobacct = jobacctinfo_create(NULL);\n\tdebug3(\"num tasks = %d\", job->node_tasks);\n\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\ttemp_jobacct = jobacct_gather_stat_task(job->task[i]->pid);\n\t\tif (temp_jobacct) {\n\t\t\tjobacctinfo_aggregate(jobacct, temp_jobacct);\n\t\t\tjobacctinfo_destroy(temp_jobacct);\n\t\t\tnum_tasks++;\n\t\t}\n\t}\n\n\tjobacctinfo_setinfo(jobacct, JOBACCT_DATA_PIPE, &fd,\n\t\t\t    SLURM_PROTOCOL_VERSION);\n\tsafe_write(fd, &num_tasks, sizeof(int));\n\n\tjobacctinfo_destroy(jobacct);\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_ERROR;\n}"
  },
  {
    "function_name": "_handle_completion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1574-1679",
    "snippet": "static int\n_handle_completion(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tint first;\n\tint last;\n\tjobacctinfo_t *jobacct = NULL;\n\tint step_rc;\n\tchar* buf;\n\tint len;\n\tBuf buffer;\n\tbool lock_set = false;\n\n\tdebug(\"_handle_completion for job %u.%u\",\n\t      job->jobid, job->stepid);\n\n\tdebug3(\"  uid = %d\", uid);\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"step completion message from uid %ld for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\t/* Send the return code and errno */\n\t\tsafe_write(fd, &rc, sizeof(int));\n\t\tsafe_write(fd, &errnum, sizeof(int));\n\t\treturn SLURM_SUCCESS;\n\t}\n\n\tsafe_read(fd, &first, sizeof(int));\n\tsafe_read(fd, &last, sizeof(int));\n\tsafe_read(fd, &step_rc, sizeof(int));\n\n\t/*\n\t * We must not use getinfo over a pipe with slurmd here\n\t * Indeed, slurmstepd does a large use of setinfo over a pipe\n\t * with slurmd and doing the reverse can result in a deadlock\n\t * scenario with slurmd :\n\t * slurmd(lockforread,write)/slurmstepd(write,lockforread)\n\t * Do pack/unpack instead to be sure of independances of\n\t * slurmd and slurmstepd\n\t */\n\tsafe_read(fd, &len, sizeof(int));\n\tbuf = xmalloc(len);\n\tsafe_read(fd, buf, len);\n\tbuffer = create_buf(buf, len);\n\tjobacctinfo_unpack(&jobacct, SLURM_PROTOCOL_VERSION,\n\t\t\t   PROTOCOL_TYPE_SLURM, buffer, 1);\n\tfree_buf(buffer);\n\n\t/*\n\t * Record the completed nodes\n\t */\n\tslurm_mutex_lock(&step_complete.lock);\n\tlock_set = true;\n\tif (! step_complete.wait_children) {\n\t\trc = -1;\n\t\terrnum = ETIMEDOUT; /* not used anyway */\n\t\tgoto timeout;\n\t}\n\n\t/* SlurmUser or root can craft a launch without a valid credential\n\t * (\"srun --no-alloc ...\") and no tree information can be built\n\t *  without the hostlist from the credential. */\n\tif (step_complete.rank >= 0) {\n#if 0\n\t\tchar bits_string[128];\n\t\tdebug2(\"Setting range %d (bit %d) through %d(bit %d)\",\n\t\t       first, first-(step_complete.rank+1),\n\t\t       last, last-(step_complete.rank+1));\n\t\tbit_fmt(bits_string, sizeof(bits_string), step_complete.bits);\n\t\tdebug2(\"  before bits: %s\", bits_string);\n#endif\n\t\tbit_nset(step_complete.bits,\n\t\t\t first - (step_complete.rank+1),\n\t\t\t last - (step_complete.rank+1));\n#if 0\n\t\tbit_fmt(bits_string, sizeof(bits_string), step_complete.bits);\n\t\tdebug2(\"  after bits: %s\", bits_string);\n#endif\n\t}\n\tstep_complete.step_rc = MAX(step_complete.step_rc, step_rc);\n\n\t/************* acct stuff ********************/\n\tjobacctinfo_aggregate(step_complete.jobacct, jobacct);\ntimeout:\n\tjobacctinfo_destroy(jobacct);\n\t/*********************************************/\n\n\t/* Send the return code and errno, we do this within the locked\n\t * region to ensure that the stepd doesn't exit before we can\n\t * perform this send. */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\tpthread_cond_signal(&step_complete.cond);\n\tslurm_mutex_unlock(&step_complete.lock);\n\n\treturn SLURM_SUCCESS;\n\n\nrwfail:\tif (lock_set) {\n\t\tpthread_cond_signal(&step_complete.cond);\n\t\tslurm_mutex_unlock(&step_complete.lock);\n\t}\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&step_complete.lock"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_cond_signal",
          "args": [
            "&step_complete.cond"
          ],
          "line": 1675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&step_complete.lock"
          ],
          "line": 1669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_cond_signal",
          "args": [
            "&step_complete.cond"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&errnum",
            "sizeof(int)"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacctinfo_destroy",
          "args": [
            "jobacct"
          ],
          "line": 1660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacctinfo_aggregate",
          "args": [
            "step_complete.jobacct",
            "jobacct"
          ],
          "line": 1658
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAX",
          "args": [
            "step_complete.step_rc",
            "step_rc"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"  after bits: %s\"",
            "bits_string"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_fmt",
          "args": [
            "bits_string",
            "sizeof(bits_string)",
            "step_complete.bits"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_nset",
          "args": [
            "step_complete.bits",
            "first - (step_complete.rank+1)",
            "last - (step_complete.rank+1)"
          ],
          "line": 1647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"  before bits: %s\"",
            "bits_string"
          ],
          "line": 1645
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_fmt",
          "args": [
            "bits_string",
            "sizeof(bits_string)",
            "step_complete.bits"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"Setting range %d (bit %d) through %d(bit %d)\"",
            "first",
            "first-(step_complete.rank+1)",
            "last",
            "last-(step_complete.rank+1)"
          ],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&step_complete.lock"
          ],
          "line": 1627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buf",
          "args": [
            "buffer"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacctinfo_unpack",
          "args": [
            "&jobacct",
            "SLURM_PROTOCOL_VERSION",
            "PROTOCOL_TYPE_SLURM",
            "buffer",
            "1"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_buf",
          "args": [
            "buf",
            "len"
          ],
          "line": 1619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "buf",
            "len"
          ],
          "line": 1618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "len"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&len",
            "sizeof(int)"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&step_rc",
            "sizeof(int)"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&last",
            "sizeof(int)"
          ],
          "line": 1604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&first",
            "sizeof(int)"
          ],
          "line": 1603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&errnum",
            "sizeof(int)"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 1598
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"step completion message from uid %ld for job %u.%u \"",
            "(long)uid",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_slurm_authorized_user",
          "args": [
            "uid"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "_slurm_authorized_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "136-140",
          "snippet": "static bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"  uid = %d\"",
            "uid"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"_handle_completion for job %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_completion(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tint first;\n\tint last;\n\tjobacctinfo_t *jobacct = NULL;\n\tint step_rc;\n\tchar* buf;\n\tint len;\n\tBuf buffer;\n\tbool lock_set = false;\n\n\tdebug(\"_handle_completion for job %u.%u\",\n\t      job->jobid, job->stepid);\n\n\tdebug3(\"  uid = %d\", uid);\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"step completion message from uid %ld for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\t/* Send the return code and errno */\n\t\tsafe_write(fd, &rc, sizeof(int));\n\t\tsafe_write(fd, &errnum, sizeof(int));\n\t\treturn SLURM_SUCCESS;\n\t}\n\n\tsafe_read(fd, &first, sizeof(int));\n\tsafe_read(fd, &last, sizeof(int));\n\tsafe_read(fd, &step_rc, sizeof(int));\n\n\t/*\n\t * We must not use getinfo over a pipe with slurmd here\n\t * Indeed, slurmstepd does a large use of setinfo over a pipe\n\t * with slurmd and doing the reverse can result in a deadlock\n\t * scenario with slurmd :\n\t * slurmd(lockforread,write)/slurmstepd(write,lockforread)\n\t * Do pack/unpack instead to be sure of independances of\n\t * slurmd and slurmstepd\n\t */\n\tsafe_read(fd, &len, sizeof(int));\n\tbuf = xmalloc(len);\n\tsafe_read(fd, buf, len);\n\tbuffer = create_buf(buf, len);\n\tjobacctinfo_unpack(&jobacct, SLURM_PROTOCOL_VERSION,\n\t\t\t   PROTOCOL_TYPE_SLURM, buffer, 1);\n\tfree_buf(buffer);\n\n\t/*\n\t * Record the completed nodes\n\t */\n\tslurm_mutex_lock(&step_complete.lock);\n\tlock_set = true;\n\tif (! step_complete.wait_children) {\n\t\trc = -1;\n\t\terrnum = ETIMEDOUT; /* not used anyway */\n\t\tgoto timeout;\n\t}\n\n\t/* SlurmUser or root can craft a launch without a valid credential\n\t * (\"srun --no-alloc ...\") and no tree information can be built\n\t *  without the hostlist from the credential. */\n\tif (step_complete.rank >= 0) {\n#if 0\n\t\tchar bits_string[128];\n\t\tdebug2(\"Setting range %d (bit %d) through %d(bit %d)\",\n\t\t       first, first-(step_complete.rank+1),\n\t\t       last, last-(step_complete.rank+1));\n\t\tbit_fmt(bits_string, sizeof(bits_string), step_complete.bits);\n\t\tdebug2(\"  before bits: %s\", bits_string);\n#endif\n\t\tbit_nset(step_complete.bits,\n\t\t\t first - (step_complete.rank+1),\n\t\t\t last - (step_complete.rank+1));\n#if 0\n\t\tbit_fmt(bits_string, sizeof(bits_string), step_complete.bits);\n\t\tdebug2(\"  after bits: %s\", bits_string);\n#endif\n\t}\n\tstep_complete.step_rc = MAX(step_complete.step_rc, step_rc);\n\n\t/************* acct stuff ********************/\n\tjobacctinfo_aggregate(step_complete.jobacct, jobacct);\ntimeout:\n\tjobacctinfo_destroy(jobacct);\n\t/*********************************************/\n\n\t/* Send the return code and errno, we do this within the locked\n\t * region to ensure that the stepd doesn't exit before we can\n\t * perform this send. */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\tpthread_cond_signal(&step_complete.cond);\n\tslurm_mutex_unlock(&step_complete.lock);\n\n\treturn SLURM_SUCCESS;\n\n\nrwfail:\tif (lock_set) {\n\t\tpthread_cond_signal(&step_complete.cond);\n\t\tslurm_mutex_unlock(&step_complete.lock);\n\t}\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_resume",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1503-1572",
    "snippet": "static int\n_handle_resume(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tuint16_t job_core_spec = (uint16_t) NO_VAL;\n\n\tsafe_read(fd, &job_core_spec, sizeof(uint16_t));\n\n\tdebug(\"_handle_resume for step:%u.%u uid:%ld core_spec:%u\",\n\t      job->jobid, job->stepid, (long)uid, job_core_spec);\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"job step resume request from uid %ld for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tacct_gather_resume_poll();\n\t/*\n\t * Signal the container\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (!suspended) {\n\t\trc = -1;\n\t\terrnum = ESLURMD_STEP_NOTSUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t} else {\n\t\tif (!job->batch && switch_g_job_step_pre_resume(job))\n\t\t\terror(\"switch_g_job_step_pre_resume: %m\");\n\t\tif (!job->batch && core_spec_g_resume(job->cont_id,\n\t\t\t\t\t\t      job_core_spec))\n\t\t\terror(\"core_spec_g_resume: %m\");\n\t\tif (proctrack_g_signal(job->cont_id, SIGCONT) < 0) {\n\t\t\tverbose(\"Error resuming %u.%u: %m\",\n\t\t\t\tjob->jobid, job->stepid);\n\t\t} else {\n\t\t\tverbose(\"Resumed %u.%u\", job->jobid, job->stepid);\n\t\t}\n\t\tsuspended = false;\n\t}\n\tif (!job->batch && switch_g_job_step_post_resume(job))\n\t\terror(\"switch_g_job_step_post_resume: %m\");\n\t/* set the cpu frequencies if cpu_freq option used */\n\tif (job->cpu_freq_min != NO_VAL || job->cpu_freq_max != NO_VAL ||\n\t    job->cpu_freq_gov != NO_VAL) {\n\t\tcpu_freq_set(job);\n\t}\n\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errno */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;",
      "static bool suspended = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&errnum",
            "sizeof(int)"
          ],
          "line": 1568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 1567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 1563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_freq_set",
          "args": [
            "job"
          ],
          "line": 1560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"switch_g_job_step_post_resume: %m\""
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_g_job_step_post_resume",
          "args": [
            "job"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Resumed %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Error resuming %u.%u: %m\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proctrack_g_signal",
          "args": [
            "job->cont_id",
            "SIGCONT"
          ],
          "line": 1547
        },
        "resolved": true,
        "details": {
          "function_name": "proctrack_g_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/proctrack.c",
          "lines": "348-397",
          "snippet": "extern int proctrack_g_signal(uint64_t cont_id, int signal)\n{\n\n\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\tif (signal == SIGKILL) {\n\t\tpid_t *pids = NULL;\n\t\tint i, j, npids = 0, hung_pids = 0;\n\t\tchar *stat_fname = NULL;\n\t\tif (proctrack_g_get_pids(cont_id, &pids, &npids) ==\n\t\t    SLURM_SUCCESS) {\n\t\t\t/* NOTE: proctrack_g_get_pids() is not supported\n\t\t\t * by the proctrack/pgid plugin */\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tif (j)\n\t\t\t\t\tsleep(2);\n\t\t\t\thung_pids = 0;\n\t\t\t\tfor (i = 0; i < npids; i++) {\n\t\t\t\t\tif (!pids[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\txstrfmtcat(stat_fname, \"/proc/%d/stat\",\n\t\t\t\t\t\t   (int) pids[i]);\n\t\t\t\t\tif (_test_core_dumping(stat_fname)) {\n\t\t\t\t\t\tdebug(\"Process %d continuing \"\n\t\t\t\t\t\t      \"core dump\",\n\t\t\t\t\t\t      (int) pids[i]);\n\t\t\t\t\t\thung_pids++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Don't test this PID again */\n\t\t\t\t\t\tpids[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\txfree(stat_fname);\n\t\t\t\t}\n\t\t\t\tif (hung_pids == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\txfree(pids);\n\t\t\tif (hung_pids) {\n\t\t\t\tinfo(\"Defering sending signal, processes in \"\n\t\t\t\t     \"job are currently core dumping\");\n\t\t\t\t_spawn_signal_thread(cont_id, signal);\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (*(ops.signal)) (cont_id, signal);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/log.h\"",
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static slurm_proctrack_ops_t ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/log.h\"\n#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic slurm_proctrack_ops_t ops;\n\nextern int proctrack_g_signal(uint64_t cont_id, int signal)\n{\n\n\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\tif (signal == SIGKILL) {\n\t\tpid_t *pids = NULL;\n\t\tint i, j, npids = 0, hung_pids = 0;\n\t\tchar *stat_fname = NULL;\n\t\tif (proctrack_g_get_pids(cont_id, &pids, &npids) ==\n\t\t    SLURM_SUCCESS) {\n\t\t\t/* NOTE: proctrack_g_get_pids() is not supported\n\t\t\t * by the proctrack/pgid plugin */\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tif (j)\n\t\t\t\t\tsleep(2);\n\t\t\t\thung_pids = 0;\n\t\t\t\tfor (i = 0; i < npids; i++) {\n\t\t\t\t\tif (!pids[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\txstrfmtcat(stat_fname, \"/proc/%d/stat\",\n\t\t\t\t\t\t   (int) pids[i]);\n\t\t\t\t\tif (_test_core_dumping(stat_fname)) {\n\t\t\t\t\t\tdebug(\"Process %d continuing \"\n\t\t\t\t\t\t      \"core dump\",\n\t\t\t\t\t\t      (int) pids[i]);\n\t\t\t\t\t\thung_pids++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Don't test this PID again */\n\t\t\t\t\t\tpids[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\txfree(stat_fname);\n\t\t\t\t}\n\t\t\t\tif (hung_pids == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\txfree(pids);\n\t\t\tif (hung_pids) {\n\t\t\t\tinfo(\"Defering sending signal, processes in \"\n\t\t\t\t     \"job are currently core dumping\");\n\t\t\t\t_spawn_signal_thread(cont_id, signal);\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (*(ops.signal)) (cont_id, signal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"core_spec_g_resume: %m\""
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "core_spec_g_resume",
          "args": [
            "job->cont_id",
            "job_core_spec"
          ],
          "line": 1544
        },
        "resolved": true,
        "details": {
          "function_name": "core_spec_g_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
          "lines": "236-249",
          "snippet": "extern int core_spec_g_resume(uint64_t cont_id, uint16_t count)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (core_spec_g_init() != SLURM_SUCCESS)\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_core_spec_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].core_spec_p_resume))(cont_id, count);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static core_spec_ops_t\t\t*ops = NULL;",
            "static int\t\t\tg_core_spec_context_num = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\n\nextern int core_spec_g_resume(uint64_t cont_id, uint16_t count)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (core_spec_g_init() != SLURM_SUCCESS)\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_core_spec_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].core_spec_p_resume))(cont_id, count);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"switch_g_job_step_pre_resume: %m\""
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_g_job_step_pre_resume",
          "args": [
            "job"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 1539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 1535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_gather_resume_poll",
          "args": [],
          "line": 1531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\"",
            "job->jobid",
            "job->stepid",
            "job->cont_id"
          ],
          "line": 1524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"job step resume request from uid %ld for job %u.%u \"",
            "(long)uid",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_slurm_authorized_user",
          "args": [
            "uid"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "_slurm_authorized_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "136-140",
          "snippet": "static bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"_handle_resume for step:%u.%u uid:%ld core_spec:%u\"",
            "job->jobid",
            "job->stepid",
            "(long)uid",
            "job_core_spec"
          ],
          "line": 1512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&job_core_spec",
            "sizeof(uint16_t)"
          ],
          "line": 1510
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool suspended = false;\n\nstatic int\n_handle_resume(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tuint16_t job_core_spec = (uint16_t) NO_VAL;\n\n\tsafe_read(fd, &job_core_spec, sizeof(uint16_t));\n\n\tdebug(\"_handle_resume for step:%u.%u uid:%ld core_spec:%u\",\n\t      job->jobid, job->stepid, (long)uid, job_core_spec);\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"job step resume request from uid %ld for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tacct_gather_resume_poll();\n\t/*\n\t * Signal the container\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (!suspended) {\n\t\trc = -1;\n\t\terrnum = ESLURMD_STEP_NOTSUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t} else {\n\t\tif (!job->batch && switch_g_job_step_pre_resume(job))\n\t\t\terror(\"switch_g_job_step_pre_resume: %m\");\n\t\tif (!job->batch && core_spec_g_resume(job->cont_id,\n\t\t\t\t\t\t      job_core_spec))\n\t\t\terror(\"core_spec_g_resume: %m\");\n\t\tif (proctrack_g_signal(job->cont_id, SIGCONT) < 0) {\n\t\t\tverbose(\"Error resuming %u.%u: %m\",\n\t\t\t\tjob->jobid, job->stepid);\n\t\t} else {\n\t\t\tverbose(\"Resumed %u.%u\", job->jobid, job->stepid);\n\t\t}\n\t\tsuspended = false;\n\t}\n\tif (!job->batch && switch_g_job_step_post_resume(job))\n\t\terror(\"switch_g_job_step_post_resume: %m\");\n\t/* set the cpu frequencies if cpu_freq option used */\n\tif (job->cpu_freq_min != NO_VAL || job->cpu_freq_max != NO_VAL ||\n\t    job->cpu_freq_gov != NO_VAL) {\n\t\tcpu_freq_set(job);\n\t}\n\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errno */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_suspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1406-1501",
    "snippet": "static int\n_handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tstatic int launch_poe = -1;\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tuint16_t job_core_spec = (uint16_t) NO_VAL;\n\n\tsafe_read(fd, &job_core_spec, sizeof(uint16_t));\n\n\tdebug(\"_handle_suspend for step:%u.%u uid:%ld core_spec:%u\",\n\t      job->jobid, job->stepid, (long)uid, job_core_spec);\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"job step suspend request from uid %ld for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t_wait_for_job_init(job);\n\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tacct_gather_suspend_poll();\n\tif (launch_poe == -1) {\n\t\tchar *launch_type = slurm_get_launch_type();\n\t\tif (!xstrcmp(launch_type, \"launch/poe\"))\n\t\t\tlaunch_poe = 1;\n\t\telse\n\t\t\tlaunch_poe = 0;\n\t\txfree(launch_type);\n\t}\n\n\t/*\n\t * Signal the container\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\trc = -1;\n\t\terrnum = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t} else {\n\t\tif (!job->batch && switch_g_job_step_pre_suspend(job))\n\t\t\terror(\"switch_g_job_step_pre_suspend: %m\");\n\n\t\t/* SIGTSTP is sent first to let MPI daemons stop their tasks,\n\t\t * then wait 2 seconds, then send SIGSTOP to the spawned\n\t\t * process's container to stop everything else.\n\t\t *\n\t\t * In some cases, 1 second has proven insufficient. Longer\n\t\t * delays may help insure that all MPI tasks have been stopped\n\t\t * (that depends upon the MPI implementaiton used), but will\n\t\t * also permit longer time periods when more than one job can\n\t\t * be running on each resource (not good). */\n\t\tif (launch_poe == 0) {\n\t\t\t/* IBM MPI seens to periodically hang upon receipt\n\t\t\t * of SIGTSTP. */\n\t\t\tif (proctrack_g_signal(job->cont_id, SIGTSTP) < 0) {\n\t\t\t\tverbose(\"Error suspending %u.%u (SIGTSTP): %m\",\n\t\t\t\t\tjob->jobid, job->stepid);\n\t\t\t} else\n\t\t\t\tsleep(2);\n\t\t}\n\n\t\tif (proctrack_g_signal(job->cont_id, SIGSTOP) < 0) {\n\t\t\tverbose(\"Error suspending %u.%u (SIGSTOP): %m\",\n\t\t\t\tjob->jobid, job->stepid);\n\t\t} else {\n\t\t\tverbose(\"Suspended %u.%u\", job->jobid, job->stepid);\n\t\t}\n\t\tsuspended = true;\n\t}\n\tif (!job->batch && switch_g_job_step_post_suspend(job))\n\t\terror(\"switch_g_job_step_post_suspend: %m\");\n\tif (!job->batch && core_spec_g_suspend(job->cont_id, job_core_spec))\n\t\terror(\"core_spec_g_suspend: %m\");\n\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errno */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;",
      "static bool suspended = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&errnum",
            "sizeof(int)"
          ],
          "line": 1497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 1496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 1492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"core_spec_g_suspend: %m\""
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "core_spec_g_suspend",
          "args": [
            "job->cont_id",
            "job_core_spec"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "core_spec_g_suspend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
          "lines": "216-229",
          "snippet": "extern int core_spec_g_suspend(uint64_t cont_id, uint16_t count)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (core_spec_g_init() != SLURM_SUCCESS)\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_core_spec_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].core_spec_p_suspend))(cont_id, count);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static core_spec_ops_t\t\t*ops = NULL;",
            "static int\t\t\tg_core_spec_context_num = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\n\nextern int core_spec_g_suspend(uint64_t cont_id, uint16_t count)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (core_spec_g_init() != SLURM_SUCCESS)\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_core_spec_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].core_spec_p_suspend))(cont_id, count);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"switch_g_job_step_post_suspend: %m\""
          ],
          "line": 1488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_g_job_step_post_suspend",
          "args": [
            "job"
          ],
          "line": 1487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Suspended %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Error suspending %u.%u (SIGSTOP): %m\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proctrack_g_signal",
          "args": [
            "job->cont_id",
            "SIGSTOP"
          ],
          "line": 1479
        },
        "resolved": true,
        "details": {
          "function_name": "proctrack_g_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/proctrack.c",
          "lines": "348-397",
          "snippet": "extern int proctrack_g_signal(uint64_t cont_id, int signal)\n{\n\n\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\tif (signal == SIGKILL) {\n\t\tpid_t *pids = NULL;\n\t\tint i, j, npids = 0, hung_pids = 0;\n\t\tchar *stat_fname = NULL;\n\t\tif (proctrack_g_get_pids(cont_id, &pids, &npids) ==\n\t\t    SLURM_SUCCESS) {\n\t\t\t/* NOTE: proctrack_g_get_pids() is not supported\n\t\t\t * by the proctrack/pgid plugin */\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tif (j)\n\t\t\t\t\tsleep(2);\n\t\t\t\thung_pids = 0;\n\t\t\t\tfor (i = 0; i < npids; i++) {\n\t\t\t\t\tif (!pids[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\txstrfmtcat(stat_fname, \"/proc/%d/stat\",\n\t\t\t\t\t\t   (int) pids[i]);\n\t\t\t\t\tif (_test_core_dumping(stat_fname)) {\n\t\t\t\t\t\tdebug(\"Process %d continuing \"\n\t\t\t\t\t\t      \"core dump\",\n\t\t\t\t\t\t      (int) pids[i]);\n\t\t\t\t\t\thung_pids++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Don't test this PID again */\n\t\t\t\t\t\tpids[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\txfree(stat_fname);\n\t\t\t\t}\n\t\t\t\tif (hung_pids == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\txfree(pids);\n\t\t\tif (hung_pids) {\n\t\t\t\tinfo(\"Defering sending signal, processes in \"\n\t\t\t\t     \"job are currently core dumping\");\n\t\t\t\t_spawn_signal_thread(cont_id, signal);\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (*(ops.signal)) (cont_id, signal);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/log.h\"",
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static slurm_proctrack_ops_t ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/log.h\"\n#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic slurm_proctrack_ops_t ops;\n\nextern int proctrack_g_signal(uint64_t cont_id, int signal)\n{\n\n\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\tif (signal == SIGKILL) {\n\t\tpid_t *pids = NULL;\n\t\tint i, j, npids = 0, hung_pids = 0;\n\t\tchar *stat_fname = NULL;\n\t\tif (proctrack_g_get_pids(cont_id, &pids, &npids) ==\n\t\t    SLURM_SUCCESS) {\n\t\t\t/* NOTE: proctrack_g_get_pids() is not supported\n\t\t\t * by the proctrack/pgid plugin */\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tif (j)\n\t\t\t\t\tsleep(2);\n\t\t\t\thung_pids = 0;\n\t\t\t\tfor (i = 0; i < npids; i++) {\n\t\t\t\t\tif (!pids[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\txstrfmtcat(stat_fname, \"/proc/%d/stat\",\n\t\t\t\t\t\t   (int) pids[i]);\n\t\t\t\t\tif (_test_core_dumping(stat_fname)) {\n\t\t\t\t\t\tdebug(\"Process %d continuing \"\n\t\t\t\t\t\t      \"core dump\",\n\t\t\t\t\t\t      (int) pids[i]);\n\t\t\t\t\t\thung_pids++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Don't test this PID again */\n\t\t\t\t\t\tpids[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\txfree(stat_fname);\n\t\t\t\t}\n\t\t\t\tif (hung_pids == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\txfree(pids);\n\t\t\tif (hung_pids) {\n\t\t\t\tinfo(\"Defering sending signal, processes in \"\n\t\t\t\t     \"job are currently core dumping\");\n\t\t\t\t_spawn_signal_thread(cont_id, signal);\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (*(ops.signal)) (cont_id, signal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "2"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "_random_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "664-678",
          "snippet": "static void\n_random_sleep(stepd_step_rec_t *job)\n{\n#if !defined HAVE_FRONT_END\n\tlong int delay = 0;\n\tlong int max   = (slurm_get_tcp_timeout() * job->nnodes);\n\n\tmax = MIN(max, 5000);\n\tsrand48((long int) (job->jobid + job->nodeid));\n\n\tdelay = lrand48() % ( max + 1 );\n\tdebug3(\"delaying %ldms\", delay);\n\tpoll(NULL, 0, delay);\n#endif\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int _initgroups(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int _initgroups(stepd_step_rec_t *job);\n\nstatic void\n_random_sleep(stepd_step_rec_t *job)\n{\n#if !defined HAVE_FRONT_END\n\tlong int delay = 0;\n\tlong int max   = (slurm_get_tcp_timeout() * job->nnodes);\n\n\tmax = MIN(max, 5000);\n\tsrand48((long int) (job->jobid + job->nodeid));\n\n\tdelay = lrand48() % ( max + 1 );\n\tdebug3(\"delaying %ldms\", delay);\n\tpoll(NULL, 0, delay);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Error suspending %u.%u (SIGTSTP): %m\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"switch_g_job_step_pre_suspend: %m\""
          ],
          "line": 1458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_g_job_step_pre_suspend",
          "args": [
            "job"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "launch_type"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "launch_type",
            "\"launch/poe\""
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_get_launch_type",
          "args": [],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acct_gather_suspend_poll",
          "args": [],
          "line": 1437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\"",
            "job->jobid",
            "job->stepid",
            "job->cont_id"
          ],
          "line": 1430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_wait_for_job_init",
          "args": [
            "job"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "_wait_for_job_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1394-1404",
          "snippet": "static void _wait_for_job_init(stepd_step_rec_t *job)\n{\n\tslurm_mutex_lock(&job->state_mutex);\n\twhile (1) {\n\t\tif (job->state != SLURMSTEPD_STEP_STARTING) {\n\t\t\tslurm_mutex_unlock(&job->state_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tpthread_cond_wait(&job->state_cond, &job->state_mutex);\n\t}\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic void _wait_for_job_init(stepd_step_rec_t *job)\n{\n\tslurm_mutex_lock(&job->state_mutex);\n\twhile (1) {\n\t\tif (job->state != SLURMSTEPD_STEP_STARTING) {\n\t\t\tslurm_mutex_unlock(&job->state_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tpthread_cond_wait(&job->state_cond, &job->state_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"job step suspend request from uid %ld for job %u.%u \"",
            "(long)uid",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_slurm_authorized_user",
          "args": [
            "uid"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "_slurm_authorized_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "136-140",
          "snippet": "static bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"_handle_suspend for step:%u.%u uid:%ld core_spec:%u\"",
            "job->jobid",
            "job->stepid",
            "(long)uid",
            "job_core_spec"
          ],
          "line": 1416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&job_core_spec",
            "sizeof(uint16_t)"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool suspended = false;\n\nstatic int\n_handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tstatic int launch_poe = -1;\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tuint16_t job_core_spec = (uint16_t) NO_VAL;\n\n\tsafe_read(fd, &job_core_spec, sizeof(uint16_t));\n\n\tdebug(\"_handle_suspend for step:%u.%u uid:%ld core_spec:%u\",\n\t      job->jobid, job->stepid, (long)uid, job_core_spec);\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"job step suspend request from uid %ld for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t_wait_for_job_init(job);\n\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tacct_gather_suspend_poll();\n\tif (launch_poe == -1) {\n\t\tchar *launch_type = slurm_get_launch_type();\n\t\tif (!xstrcmp(launch_type, \"launch/poe\"))\n\t\t\tlaunch_poe = 1;\n\t\telse\n\t\t\tlaunch_poe = 0;\n\t\txfree(launch_type);\n\t}\n\n\t/*\n\t * Signal the container\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\trc = -1;\n\t\terrnum = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t} else {\n\t\tif (!job->batch && switch_g_job_step_pre_suspend(job))\n\t\t\terror(\"switch_g_job_step_pre_suspend: %m\");\n\n\t\t/* SIGTSTP is sent first to let MPI daemons stop their tasks,\n\t\t * then wait 2 seconds, then send SIGSTOP to the spawned\n\t\t * process's container to stop everything else.\n\t\t *\n\t\t * In some cases, 1 second has proven insufficient. Longer\n\t\t * delays may help insure that all MPI tasks have been stopped\n\t\t * (that depends upon the MPI implementaiton used), but will\n\t\t * also permit longer time periods when more than one job can\n\t\t * be running on each resource (not good). */\n\t\tif (launch_poe == 0) {\n\t\t\t/* IBM MPI seens to periodically hang upon receipt\n\t\t\t * of SIGTSTP. */\n\t\t\tif (proctrack_g_signal(job->cont_id, SIGTSTP) < 0) {\n\t\t\t\tverbose(\"Error suspending %u.%u (SIGTSTP): %m\",\n\t\t\t\t\tjob->jobid, job->stepid);\n\t\t\t} else\n\t\t\t\tsleep(2);\n\t\t}\n\n\t\tif (proctrack_g_signal(job->cont_id, SIGSTOP) < 0) {\n\t\t\tverbose(\"Error suspending %u.%u (SIGSTOP): %m\",\n\t\t\t\tjob->jobid, job->stepid);\n\t\t} else {\n\t\t\tverbose(\"Suspended %u.%u\", job->jobid, job->stepid);\n\t\t}\n\t\tsuspended = true;\n\t}\n\tif (!job->batch && switch_g_job_step_post_suspend(job))\n\t\terror(\"switch_g_job_step_post_suspend: %m\");\n\tif (!job->batch && core_spec_g_suspend(job->cont_id, job_core_spec))\n\t\terror(\"core_spec_g_suspend: %m\");\n\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errno */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_wait_for_job_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1394-1404",
    "snippet": "static void _wait_for_job_init(stepd_step_rec_t *job)\n{\n\tslurm_mutex_lock(&job->state_mutex);\n\twhile (1) {\n\t\tif (job->state != SLURMSTEPD_STEP_STARTING) {\n\t\t\tslurm_mutex_unlock(&job->state_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tpthread_cond_wait(&job->state_cond, &job->state_mutex);\n\t}\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pthread_cond_wait",
          "args": [
            "&job->state_cond",
            "&job->state_mutex"
          ],
          "line": 1402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&job->state_mutex"
          ],
          "line": 1399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&job->state_mutex"
          ],
          "line": 1396
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic void _wait_for_job_init(stepd_step_rec_t *job)\n{\n\tslurm_mutex_lock(&job->state_mutex);\n\twhile (1) {\n\t\tif (job->state != SLURMSTEPD_STEP_STARTING) {\n\t\t\tslurm_mutex_unlock(&job->state_mutex);\n\t\t\tbreak;\n\t\t}\n\t\tpthread_cond_wait(&job->state_cond, &job->state_mutex);\n\t}\n}"
  },
  {
    "function_name": "_handle_daemon_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1383-1391",
    "snippet": "static int\n_handle_daemon_pid(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->jmgr_pid, sizeof(pid_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->jmgr_pid",
            "sizeof(pid_t)"
          ],
          "line": 1386
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_daemon_pid(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->jmgr_pid, sizeof(pid_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_add_extern_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1364-1381",
    "snippet": "static int\n_handle_add_extern_pid(int fd, stepd_step_rec_t *job)\n{\n\tint rc = SLURM_SUCCESS;\n\tpid_t pid;\n\n\tsafe_read(fd, &pid, sizeof(pid_t));\n\n\trc = _handle_add_extern_pid_internal(job, pid);\n\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\n\tdebug(\"Leaving _handle_add_extern_pid\");\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Leaving _handle_add_extern_pid\""
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_stop_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "120-139",
          "snippet": "void\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 1375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_handle_add_extern_pid_internal",
          "args": [
            "job",
            "pid"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_add_extern_pid_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1303-1362",
          "snippet": "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\textern_pid_t *extern_pid;\n\tjobacct_id_t jobacct_id;\n\tint retries = 0, rc = SLURM_SUCCESS;\n\n\tif (job->stepid != SLURM_EXTERN_CONT) {\n\t\terror(\"%s: non-extern step (%u) given for job %u.\",\n\t\t      __func__, job->stepid, job->jobid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tdebug(\"%s: for job %u.%u, pid %d\",\n\t      __func__, job->jobid, job->stepid, pid);\n\n\textern_pid = xmalloc(sizeof(extern_pid_t));\n\textern_pid->job = job;\n\textern_pid->pid = pid;\n\n\t/* track pid: add outside of the below thread so that the pam module\n\t * waits until the parent pid is added, before letting the parent spawn\n\t * any children. */\n\tjobacct_id.taskid = job->nodeid;\n\tjobacct_id.nodeid = job->nodeid;\n\tjobacct_id.job = job;\n\n\tif (proctrack_g_add(job, pid) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to proctrack plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tif (task_g_add_pid(pid) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to task plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tif (jobacct_gather_add_task(pid, &jobacct_id, 1) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to jobacct_gather plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\t/* spawn a thread that will wait on the pid given */\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&thread_id, &attr,\n\t\t\t      &_wait_extern_pid, (void *) extern_pid)) {\n\t\terror(\"%s: pthread_create: %m\", __func__);\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"%s: Can't create pthread\", __func__);\n\t\t\trc = SLURM_FAILURE;\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\textern_pid_t *extern_pid;\n\tjobacct_id_t jobacct_id;\n\tint retries = 0, rc = SLURM_SUCCESS;\n\n\tif (job->stepid != SLURM_EXTERN_CONT) {\n\t\terror(\"%s: non-extern step (%u) given for job %u.\",\n\t\t      __func__, job->stepid, job->jobid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tdebug(\"%s: for job %u.%u, pid %d\",\n\t      __func__, job->jobid, job->stepid, pid);\n\n\textern_pid = xmalloc(sizeof(extern_pid_t));\n\textern_pid->job = job;\n\textern_pid->pid = pid;\n\n\t/* track pid: add outside of the below thread so that the pam module\n\t * waits until the parent pid is added, before letting the parent spawn\n\t * any children. */\n\tjobacct_id.taskid = job->nodeid;\n\tjobacct_id.nodeid = job->nodeid;\n\tjobacct_id.job = job;\n\n\tif (proctrack_g_add(job, pid) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to proctrack plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tif (task_g_add_pid(pid) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to task plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tif (jobacct_gather_add_task(pid, &jobacct_id, 1) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to jobacct_gather plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\t/* spawn a thread that will wait on the pid given */\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&thread_id, &attr,\n\t\t\t      &_wait_extern_pid, (void *) extern_pid)) {\n\t\terror(\"%s: pthread_create: %m\", __func__);\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"%s: Can't create pthread\", __func__);\n\t\t\trc = SLURM_FAILURE;\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&pid",
            "sizeof(pid_t)"
          ],
          "line": 1370
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_add_extern_pid(int fd, stepd_step_rec_t *job)\n{\n\tint rc = SLURM_SUCCESS;\n\tpid_t pid;\n\n\tsafe_read(fd, &pid, sizeof(pid_t));\n\n\trc = _handle_add_extern_pid_internal(job, pid);\n\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\n\tdebug(\"Leaving _handle_add_extern_pid\");\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_add_extern_pid_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1303-1362",
    "snippet": "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\textern_pid_t *extern_pid;\n\tjobacct_id_t jobacct_id;\n\tint retries = 0, rc = SLURM_SUCCESS;\n\n\tif (job->stepid != SLURM_EXTERN_CONT) {\n\t\terror(\"%s: non-extern step (%u) given for job %u.\",\n\t\t      __func__, job->stepid, job->jobid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tdebug(\"%s: for job %u.%u, pid %d\",\n\t      __func__, job->jobid, job->stepid, pid);\n\n\textern_pid = xmalloc(sizeof(extern_pid_t));\n\textern_pid->job = job;\n\textern_pid->pid = pid;\n\n\t/* track pid: add outside of the below thread so that the pam module\n\t * waits until the parent pid is added, before letting the parent spawn\n\t * any children. */\n\tjobacct_id.taskid = job->nodeid;\n\tjobacct_id.nodeid = job->nodeid;\n\tjobacct_id.job = job;\n\n\tif (proctrack_g_add(job, pid) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to proctrack plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tif (task_g_add_pid(pid) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to task plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tif (jobacct_gather_add_task(pid, &jobacct_id, 1) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to jobacct_gather plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\t/* spawn a thread that will wait on the pid given */\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&thread_id, &attr,\n\t\t\t      &_wait_extern_pid, (void *) extern_pid)) {\n\t\terror(\"%s: pthread_create: %m\", __func__);\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"%s: Can't create pthread\", __func__);\n\t\t\trc = SLURM_FAILURE;\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_attr_destroy",
          "args": [
            "&attr"
          ],
          "line": 1359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Can't create pthread\"",
            "__func__"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "_prolog_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "1386-1434",
          "snippet": "static void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _is_batch_job_finished(uint32_t job_id);",
            "static bool _job_still_running(uint32_t job_id);",
            "static void _launch_complete_add(uint32_t job_id);",
            "static void _launch_complete_log(char *type, uint32_t job_id);",
            "static void _launch_complete_rm(uint32_t job_id);",
            "static void _launch_complete_wait(uint32_t job_id);",
            "static bool _launch_job_test(uint32_t job_id);",
            "static void _note_batch_job_finished(uint32_t job_id);",
            "static bool _slurm_authorized_user(uid_t uid);",
            "static void _sync_messages_kill(kill_job_msg_t *req);",
            "static int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);",
            "static gids_t *_gids_cache_lookup(char *user, gid_t gid);",
            "static int  _add_starting_step(uint16_t type, void *req);",
            "static int  _remove_starting_step(uint16_t type, void *req);",
            "static void _add_job_running_prolog(uint32_t job_id);",
            "static void _remove_job_running_prolog(uint32_t job_id);",
            "static void _wait_for_job_running_prolog(uint32_t job_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic bool _is_batch_job_finished(uint32_t job_id);\nstatic bool _job_still_running(uint32_t job_id);\nstatic void _launch_complete_add(uint32_t job_id);\nstatic void _launch_complete_log(char *type, uint32_t job_id);\nstatic void _launch_complete_rm(uint32_t job_id);\nstatic void _launch_complete_wait(uint32_t job_id);\nstatic bool _launch_job_test(uint32_t job_id);\nstatic void _note_batch_job_finished(uint32_t job_id);\nstatic bool _slurm_authorized_user(uid_t uid);\nstatic void _sync_messages_kill(kill_job_msg_t *req);\nstatic int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);\nstatic gids_t *_gids_cache_lookup(char *user, gid_t gid);\nstatic int  _add_starting_step(uint16_t type, void *req);\nstatic int  _remove_starting_step(uint16_t type, void *req);\nstatic void _add_job_running_prolog(uint32_t job_id);\nstatic void _remove_job_running_prolog(uint32_t job_id);\nstatic void _wait_for_job_running_prolog(uint32_t job_id);\n\nstatic void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_create",
          "args": [
            "&thread_id",
            "&attr",
            "&_wait_extern_pid",
            "(void *) extern_pid"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_attr_setdetachstate",
          "args": [
            "&attr",
            "PTHREAD_CREATE_DETACHED"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_attr_init",
          "args": [
            "&attr"
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Job %u can't add pid %d to jobacct_gather plugin in the extern_step.\"",
            "__func__",
            "job->jobid",
            "pid"
          ],
          "line": 1342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacct_gather_add_task",
          "args": [
            "pid",
            "&jobacct_id",
            "1"
          ],
          "line": 1341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Job %u can't add pid %d to task plugin in the extern_step.\"",
            "__func__",
            "job->jobid",
            "pid"
          ],
          "line": 1337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_g_add_pid",
          "args": [
            "pid"
          ],
          "line": 1336
        },
        "resolved": true,
        "details": {
          "function_name": "task_g_add_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "430-443",
          "snippet": "extern int task_g_add_pid(pid_t pid)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].add_pid))(pid);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static slurmd_task_ops_t *ops = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_add_pid(pid_t pid)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].add_pid))(pid);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: Job %u can't add pid %d to proctrack plugin in the extern_step.\"",
            "__func__",
            "job->jobid",
            "pid"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proctrack_g_add",
          "args": [
            "job",
            "pid"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "proctrack_g_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/proctrack.c",
          "lines": "180-199",
          "snippet": "extern int proctrack_g_add(stepd_step_rec_t * job, pid_t pid)\n{\n\tint i = 0, max_retry = 3, rc;\n\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\t/* Sometimes a plugin is transient in adding a pid, so lets\n\t * try a few times before we call it quits.\n\t */\n\twhile ((rc = (*(ops.add)) (job, pid)) != SLURM_SUCCESS) {\n\t\tif (i++ > max_retry)\n\t\t\tbreak;\n\t\tdebug(\"%s: %u.%u couldn't add pid %u, sleeping and trying again\",\n\t\t      __func__, job->jobid, job->stepid, pid);\n\t\tsleep(1);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/log.h\"",
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static slurm_proctrack_ops_t ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/log.h\"\n#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic slurm_proctrack_ops_t ops;\n\nextern int proctrack_g_add(stepd_step_rec_t * job, pid_t pid)\n{\n\tint i = 0, max_retry = 3, rc;\n\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\t/* Sometimes a plugin is transient in adding a pid, so lets\n\t * try a few times before we call it quits.\n\t */\n\twhile ((rc = (*(ops.add)) (job, pid)) != SLURM_SUCCESS) {\n\t\tif (i++ > max_retry)\n\t\t\tbreak;\n\t\tdebug(\"%s: %u.%u couldn't add pid %u, sleeping and trying again\",\n\t\t      __func__, job->jobid, job->stepid, pid);\n\t\tsleep(1);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(extern_pid_t)"
          ],
          "line": 1320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s: for job %u.%u, pid %d\"",
            "__func__",
            "job->jobid",
            "job->stepid",
            "pid"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: non-extern step (%u) given for job %u.\"",
            "__func__",
            "job->stepid",
            "job->jobid"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\textern_pid_t *extern_pid;\n\tjobacct_id_t jobacct_id;\n\tint retries = 0, rc = SLURM_SUCCESS;\n\n\tif (job->stepid != SLURM_EXTERN_CONT) {\n\t\terror(\"%s: non-extern step (%u) given for job %u.\",\n\t\t      __func__, job->stepid, job->jobid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tdebug(\"%s: for job %u.%u, pid %d\",\n\t      __func__, job->jobid, job->stepid, pid);\n\n\textern_pid = xmalloc(sizeof(extern_pid_t));\n\textern_pid->job = job;\n\textern_pid->pid = pid;\n\n\t/* track pid: add outside of the below thread so that the pam module\n\t * waits until the parent pid is added, before letting the parent spawn\n\t * any children. */\n\tjobacct_id.taskid = job->nodeid;\n\tjobacct_id.nodeid = job->nodeid;\n\tjobacct_id.job = job;\n\n\tif (proctrack_g_add(job, pid) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to proctrack plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tif (task_g_add_pid(pid) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to task plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tif (jobacct_gather_add_task(pid, &jobacct_id, 1) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to jobacct_gather plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\t/* spawn a thread that will wait on the pid given */\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&thread_id, &attr,\n\t\t\t      &_wait_extern_pid, (void *) extern_pid)) {\n\t\terror(\"%s: pthread_create: %m\", __func__);\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"%s: Can't create pthread\", __func__);\n\t\t\trc = SLURM_FAILURE;\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "_wait_extern_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1240-1301",
    "snippet": "static void *_wait_extern_pid(void *args)\n{\n\textern_pid_t *extern_pid = (extern_pid_t *)args;\n\n\tstepd_step_rec_t *job = extern_pid->job;\n\tpid_t pid = extern_pid->pid;\n\n\tjobacctinfo_t *jobacct = NULL;\n\tpid_t *pids = NULL;\n\tint npids = 0, i;\n\tchar\tproc_stat_file[256];\t/* Allow ~20x extra length */\n\tFILE *stat_fp = NULL;\n\tint fd;\n\tchar sbuf[256], *tmp, state[1];\n\tint num_read, ppid;\n\n\txfree(extern_pid);\n\n\t//info(\"waiting on pid %d\", pid);\n\t_block_on_pid(pid);\n\t//info(\"done with pid %d %d: %m\", pid, rc);\n\tjobacct = jobacct_gather_remove_task(pid);\n\tif (jobacct) {\n\t\tjob->jobacct->energy.consumed_energy = 0;\n\t\tjobacctinfo_aggregate(job->jobacct, jobacct);\n\t\tjobacctinfo_destroy(jobacct);\n\t}\n\tacct_gather_profile_g_task_end(pid);\n\n\t/* See if we have any children of init left and add them to track. */\n\tproctrack_g_get_pids(job->cont_id, &pids, &npids);\n\tfor (i = 0; i < npids; i++) {\n\t\tsnprintf(proc_stat_file, 256, \"/proc/%d/stat\", pids[i]);\n\t\tif (!(stat_fp = fopen(proc_stat_file, \"r\")))\n\t\t\tcontinue;  /* Assume the process went away */\n\t\tfd = fileno(stat_fp);\n\t\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n\n\t\tnum_read = read(fd, sbuf, (sizeof(sbuf) - 1));\n\n\t\tif (num_read <= 0)\n\t\t\tgoto next_pid;\n\n\t\tsbuf[num_read] = '\\0';\n\n\t\t/* get to the end of cmd name */\n\t\ttmp = strrchr(sbuf, ')');\n\t\t*tmp = '\\0';\t/* replace trailing ')' with NULL */\n\t\t/* skip space after ')' too */\n\t\tsscanf(tmp + 2,\t\"%c %d \", state, &ppid);\n\n\t\tif (ppid == 1) {\n\t\t\tdebug2(\"adding tracking of orphaned process %d\",\n\t\t\t       pids[i]);\n\t\t\t_handle_add_extern_pid_internal(job, pids[i]);\n\t\t}\n\tnext_pid:\n\t\tfclose(stat_fp);\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static void *_wait_extern_pid(void *args);",
      "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "stat_fp"
          ],
          "line": 1297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_handle_add_extern_pid_internal",
          "args": [
            "job",
            "pids[i]"
          ],
          "line": 1294
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_add_extern_pid_internal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1303-1362",
          "snippet": "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\textern_pid_t *extern_pid;\n\tjobacct_id_t jobacct_id;\n\tint retries = 0, rc = SLURM_SUCCESS;\n\n\tif (job->stepid != SLURM_EXTERN_CONT) {\n\t\terror(\"%s: non-extern step (%u) given for job %u.\",\n\t\t      __func__, job->stepid, job->jobid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tdebug(\"%s: for job %u.%u, pid %d\",\n\t      __func__, job->jobid, job->stepid, pid);\n\n\textern_pid = xmalloc(sizeof(extern_pid_t));\n\textern_pid->job = job;\n\textern_pid->pid = pid;\n\n\t/* track pid: add outside of the below thread so that the pam module\n\t * waits until the parent pid is added, before letting the parent spawn\n\t * any children. */\n\tjobacct_id.taskid = job->nodeid;\n\tjobacct_id.nodeid = job->nodeid;\n\tjobacct_id.job = job;\n\n\tif (proctrack_g_add(job, pid) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to proctrack plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tif (task_g_add_pid(pid) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to task plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tif (jobacct_gather_add_task(pid, &jobacct_id, 1) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to jobacct_gather plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\t/* spawn a thread that will wait on the pid given */\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&thread_id, &attr,\n\t\t\t      &_wait_extern_pid, (void *) extern_pid)) {\n\t\terror(\"%s: pthread_create: %m\", __func__);\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"%s: Can't create pthread\", __func__);\n\t\t\trc = SLURM_FAILURE;\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid)\n{\n\tpthread_t thread_id;\n\tpthread_attr_t attr;\n\textern_pid_t *extern_pid;\n\tjobacct_id_t jobacct_id;\n\tint retries = 0, rc = SLURM_SUCCESS;\n\n\tif (job->stepid != SLURM_EXTERN_CONT) {\n\t\terror(\"%s: non-extern step (%u) given for job %u.\",\n\t\t      __func__, job->stepid, job->jobid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tdebug(\"%s: for job %u.%u, pid %d\",\n\t      __func__, job->jobid, job->stepid, pid);\n\n\textern_pid = xmalloc(sizeof(extern_pid_t));\n\textern_pid->job = job;\n\textern_pid->pid = pid;\n\n\t/* track pid: add outside of the below thread so that the pam module\n\t * waits until the parent pid is added, before letting the parent spawn\n\t * any children. */\n\tjobacct_id.taskid = job->nodeid;\n\tjobacct_id.nodeid = job->nodeid;\n\tjobacct_id.job = job;\n\n\tif (proctrack_g_add(job, pid) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to proctrack plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tif (task_g_add_pid(pid) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to task plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\tif (jobacct_gather_add_task(pid, &jobacct_id, 1) != SLURM_SUCCESS) {\n\t\terror(\"%s: Job %u can't add pid %d to jobacct_gather plugin in the extern_step.\", __func__, job->jobid, pid);\n\t\treturn SLURM_FAILURE;\n\t}\n\n\t/* spawn a thread that will wait on the pid given */\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&thread_id, &attr,\n\t\t\t      &_wait_extern_pid, (void *) extern_pid)) {\n\t\terror(\"%s: pthread_create: %m\", __func__);\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"%s: Can't create pthread\", __func__);\n\t\t\trc = SLURM_FAILURE;\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"adding tracking of orphaned process %d\"",
            "pids[i]"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "tmp + 2",
            "\"%c %d \"",
            "state",
            "&ppid"
          ],
          "line": 1289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "sbuf",
            "')'"
          ],
          "line": 1286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "sbuf",
            "(sizeof(sbuf) - 1)"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "_file_read_content",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcgroup.c",
          "lines": "1149-1197",
          "snippet": "int _file_read_content(char* file_path, char** content, size_t *csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\tsize_t fsize;\n\tchar* buf;\n\n\tfstatus = XCGROUP_ERROR;\n\n\t/* check input pointers */\n\tif (content == NULL || csize == NULL)\n\t\treturn fstatus;\n\n\t/* open file for reading */\n\tfd = open(file_path, O_RDONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for reading : %m\",\n\t\t\t__func__, file_path);\n\t\treturn fstatus;\n\t}\n\n\t/* get file size */\n\tfsize=_file_getsize(fd);\n\tif (fsize == -1) {\n\t\tclose(fd);\n\t\treturn fstatus;\n\t}\n\n\t/* read file contents */\n\tbuf = (char*) xmalloc((fsize+1)*sizeof(char));\n\tbuf[fsize]='\\0';\n\tdo {\n\t\trc = read(fd, buf, fsize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* set output values */\n\tif (rc >= 0) {\n\t\t*content = buf;\n\t\t*csize = rc;\n\t\tfstatus = XCGROUP_SUCCESS;\n\t}\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}",
          "includes": [
            "#include \"xcgroup.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "size_t _file_getsize(int fd);",
            "int _file_read_content(char* file_path, char** content, size_t *csize);",
            "int _file_write_content(char* file_path, char* content, size_t csize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcgroup.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <sys/mount.h>\n#include <dirent.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nsize_t _file_getsize(int fd);\nint _file_read_content(char* file_path, char** content, size_t *csize);\nint _file_write_content(char* file_path, char* content, size_t csize);\n\nint _file_read_content(char* file_path, char** content, size_t *csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\tsize_t fsize;\n\tchar* buf;\n\n\tfstatus = XCGROUP_ERROR;\n\n\t/* check input pointers */\n\tif (content == NULL || csize == NULL)\n\t\treturn fstatus;\n\n\t/* open file for reading */\n\tfd = open(file_path, O_RDONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for reading : %m\",\n\t\t\t__func__, file_path);\n\t\treturn fstatus;\n\t}\n\n\t/* get file size */\n\tfsize=_file_getsize(fd);\n\tif (fsize == -1) {\n\t\tclose(fd);\n\t\treturn fstatus;\n\t}\n\n\t/* read file contents */\n\tbuf = (char*) xmalloc((fsize+1)*sizeof(char));\n\tbuf[fsize]='\\0';\n\tdo {\n\t\trc = read(fd, buf, fsize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* set output values */\n\tif (rc >= 0) {\n\t\t*content = buf;\n\t\t*csize = rc;\n\t\tfstatus = XCGROUP_SUCCESS;\n\t}\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcntl",
          "args": [
            "fd",
            "F_SETFD",
            "FD_CLOEXEC"
          ],
          "line": 1276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fileno",
          "args": [
            "stat_fp"
          ],
          "line": 1275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "proc_stat_file",
            "\"r\""
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "proc_stat_file",
            "256",
            "\"/proc/%d/stat\"",
            "pids[i]"
          ],
          "line": 1272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proctrack_g_get_pids",
          "args": [
            "job->cont_id",
            "&pids",
            "&npids"
          ],
          "line": 1270
        },
        "resolved": true,
        "details": {
          "function_name": "proctrack_g_get_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/proctrack.c",
          "lines": "468-475",
          "snippet": "extern int\nproctrack_g_get_pids(uint64_t cont_id, pid_t ** pids, int *npids)\n{\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\treturn (*(ops.get_pids)) (cont_id, pids, npids);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/log.h\"",
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static slurm_proctrack_ops_t ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/log.h\"\n#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic slurm_proctrack_ops_t ops;\n\nextern int\nproctrack_g_get_pids(uint64_t cont_id, pid_t ** pids, int *npids)\n{\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\treturn (*(ops.get_pids)) (cont_id, pids, npids);\n}"
        }
      },
      {
        "call_info": {
          "callee": "acct_gather_profile_g_task_end",
          "args": [
            "pid"
          ],
          "line": 1267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacctinfo_destroy",
          "args": [
            "jobacct"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacctinfo_aggregate",
          "args": [
            "job->jobacct",
            "jobacct"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacct_gather_remove_task",
          "args": [
            "pid"
          ],
          "line": 1261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_block_on_pid",
          "args": [
            "pid"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "_block_on_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1228-1235",
          "snippet": "static void _block_on_pid(pid_t pid)\n{\n\t/* I wish there was another way to wait on a foreign pid, but\n\t * I was unable to find one.\n\t */\n\twhile (kill(pid, 0) != -1)\n\t\tsleep(1);\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\n\nstatic void _block_on_pid(pid_t pid)\n{\n\t/* I wish there was another way to wait on a foreign pid, but\n\t * I was unable to find one.\n\t */\n\twhile (kill(pid, 0) != -1)\n\t\tsleep(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "extern_pid"
          ],
          "line": 1256
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic void *_wait_extern_pid(void *args);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic void *_wait_extern_pid(void *args)\n{\n\textern_pid_t *extern_pid = (extern_pid_t *)args;\n\n\tstepd_step_rec_t *job = extern_pid->job;\n\tpid_t pid = extern_pid->pid;\n\n\tjobacctinfo_t *jobacct = NULL;\n\tpid_t *pids = NULL;\n\tint npids = 0, i;\n\tchar\tproc_stat_file[256];\t/* Allow ~20x extra length */\n\tFILE *stat_fp = NULL;\n\tint fd;\n\tchar sbuf[256], *tmp, state[1];\n\tint num_read, ppid;\n\n\txfree(extern_pid);\n\n\t//info(\"waiting on pid %d\", pid);\n\t_block_on_pid(pid);\n\t//info(\"done with pid %d %d: %m\", pid, rc);\n\tjobacct = jobacct_gather_remove_task(pid);\n\tif (jobacct) {\n\t\tjob->jobacct->energy.consumed_energy = 0;\n\t\tjobacctinfo_aggregate(job->jobacct, jobacct);\n\t\tjobacctinfo_destroy(jobacct);\n\t}\n\tacct_gather_profile_g_task_end(pid);\n\n\t/* See if we have any children of init left and add them to track. */\n\tproctrack_g_get_pids(job->cont_id, &pids, &npids);\n\tfor (i = 0; i < npids; i++) {\n\t\tsnprintf(proc_stat_file, 256, \"/proc/%d/stat\", pids[i]);\n\t\tif (!(stat_fp = fopen(proc_stat_file, \"r\")))\n\t\t\tcontinue;  /* Assume the process went away */\n\t\tfd = fileno(stat_fp);\n\t\tfcntl(fd, F_SETFD, FD_CLOEXEC);\n\n\t\tnum_read = read(fd, sbuf, (sizeof(sbuf) - 1));\n\n\t\tif (num_read <= 0)\n\t\t\tgoto next_pid;\n\n\t\tsbuf[num_read] = '\\0';\n\n\t\t/* get to the end of cmd name */\n\t\ttmp = strrchr(sbuf, ')');\n\t\t*tmp = '\\0';\t/* replace trailing ')' with NULL */\n\t\t/* skip space after ')' too */\n\t\tsscanf(tmp + 2,\t\"%c %d \", state, &ppid);\n\n\t\tif (ppid == 1) {\n\t\t\tdebug2(\"adding tracking of orphaned process %d\",\n\t\t\t       pids[i]);\n\t\t\t_handle_add_extern_pid_internal(job, pids[i]);\n\t\t}\n\tnext_pid:\n\t\tfclose(stat_fp);\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "_block_on_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1228-1235",
    "snippet": "static void _block_on_pid(pid_t pid)\n{\n\t/* I wish there was another way to wait on a foreign pid, but\n\t * I was unable to find one.\n\t */\n\twhile (kill(pid, 0) != -1)\n\t\tsleep(1);\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 1234
        },
        "resolved": true,
        "details": {
          "function_name": "_random_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "664-678",
          "snippet": "static void\n_random_sleep(stepd_step_rec_t *job)\n{\n#if !defined HAVE_FRONT_END\n\tlong int delay = 0;\n\tlong int max   = (slurm_get_tcp_timeout() * job->nnodes);\n\n\tmax = MIN(max, 5000);\n\tsrand48((long int) (job->jobid + job->nodeid));\n\n\tdelay = lrand48() % ( max + 1 );\n\tdebug3(\"delaying %ldms\", delay);\n\tpoll(NULL, 0, delay);\n#endif\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int _initgroups(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int _initgroups(stepd_step_rec_t *job);\n\nstatic void\n_random_sleep(stepd_step_rec_t *job)\n{\n#if !defined HAVE_FRONT_END\n\tlong int delay = 0;\n\tlong int max   = (slurm_get_tcp_timeout() * job->nnodes);\n\n\tmax = MIN(max, 5000);\n\tsrand48((long int) (job->jobid + job->nodeid));\n\n\tdelay = lrand48() % ( max + 1 );\n\tdebug3(\"delaying %ldms\", delay);\n\tpoll(NULL, 0, delay);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "pid",
            "0"
          ],
          "line": 1233
        },
        "resolved": true,
        "details": {
          "function_name": "_delay_kill_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "2124-2144",
          "snippet": "static void _delay_kill_thread(pthread_t thread_id, int secs)\n{\n\tpthread_t kill_id;\n\tpthread_attr_t attr;\n\tkill_thread_t *kt = xmalloc(sizeof(kill_thread_t));\n\tint retries = 0;\n\n\tkt->thread_id = thread_id;\n\tkt->secs = secs;\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&kill_id, &attr, &_kill_thr, (void *) kt)) {\n\t\terror(\"_delay_kill_thread: pthread_create: %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"_delay_kill_thread: Can't create pthread\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void _delay_kill_thread(pthread_t thread_id, int secs)\n{\n\tpthread_t kill_id;\n\tpthread_attr_t attr;\n\tkill_thread_t *kt = xmalloc(sizeof(kill_thread_t));\n\tint retries = 0;\n\n\tkt->thread_id = thread_id;\n\tkt->secs = secs;\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&kill_id, &attr, &_kill_thr, (void *) kt)) {\n\t\terror(\"_delay_kill_thread: pthread_create: %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"_delay_kill_thread: Can't create pthread\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\n\nstatic void _block_on_pid(pid_t pid)\n{\n\t/* I wish there was another way to wait on a foreign pid, but\n\t * I was unable to find one.\n\t */\n\twhile (kill(pid, 0) != -1)\n\t\tsleep(1);\n}"
  },
  {
    "function_name": "_handle_pid_in_container",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1206-1226",
    "snippet": "static int\n_handle_pid_in_container(int fd, stepd_step_rec_t *job)\n{\n\tbool rc = false;\n\tpid_t pid;\n\n\tdebug(\"_handle_pid_in_container for job %u.%u\",\n\t      job->jobid, job->stepid);\n\n\tsafe_read(fd, &pid, sizeof(pid_t));\n\n\trc = proctrack_g_has_pid(job->cont_id, pid);\n\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(bool));\n\n\tdebug(\"Leaving _handle_pid_in_container\");\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Leaving _handle_pid_in_container\""
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_stop_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "120-139",
          "snippet": "void\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(bool)"
          ],
          "line": 1220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proctrack_g_has_pid",
          "args": [
            "job->cont_id",
            "pid"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "proctrack_g_has_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/proctrack.c",
          "lines": "430-436",
          "snippet": "extern bool proctrack_g_has_pid(uint64_t cont_id, pid_t pid)\n{\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\treturn (*(ops.has_pid)) (cont_id, pid);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/log.h\"",
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static slurm_proctrack_ops_t ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/log.h\"\n#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic slurm_proctrack_ops_t ops;\n\nextern bool proctrack_g_has_pid(uint64_t cont_id, pid_t pid)\n{\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\treturn (*(ops.has_pid)) (cont_id, pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&pid",
            "sizeof(pid_t)"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"_handle_pid_in_container for job %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_pid_in_container(int fd, stepd_step_rec_t *job)\n{\n\tbool rc = false;\n\tpid_t pid;\n\n\tdebug(\"_handle_pid_in_container for job %u.%u\",\n\t      job->jobid, job->stepid);\n\n\tsafe_read(fd, &pid, sizeof(pid_t));\n\n\trc = proctrack_g_has_pid(job->cont_id, pid);\n\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(bool));\n\n\tdebug(\"Leaving _handle_pid_in_container\");\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1117-1204",
    "snippet": "static int\n_handle_attach(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tsrun_info_t *srun;\n\tint rc = SLURM_SUCCESS;\n\n\tdebug(\"_handle_attach for job %u.%u\", job->jobid, job->stepid);\n\n\tsrun       = xmalloc(sizeof(srun_info_t));\n\tsrun->key  = (srun_key_t *)xmalloc(SLURM_IO_KEY_SIZE);\n\n\tdebug(\"sizeof(srun_info_t) = %d, sizeof(slurm_addr_t) = %d\",\n\t      (int) sizeof(srun_info_t), (int) sizeof(slurm_addr_t));\n\tsafe_read(fd, &srun->ioaddr, sizeof(slurm_addr_t));\n\tsafe_read(fd, &srun->resp_addr, sizeof(slurm_addr_t));\n\tsafe_read(fd, srun->key, SLURM_IO_KEY_SIZE);\n\tsafe_read(fd, &srun->protocol_version, sizeof(int));\n\n\tif (!srun->protocol_version)\n\t\tsrun->protocol_version = (uint16_t)NO_VAL;\n\t/*\n\t * Check if jobstep is actually running.\n\t */\n\tif (job->state != SLURMSTEPD_STEP_RUNNING) {\n\t\trc = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * At the moment, it only makes sense for the slurmd to make this\n\t * call, so only _slurm_authorized_user is allowed.\n\t */\n\tif (!_slurm_authorized_user(uid)) {\n\t\terror(\"uid %ld attempt to attach to job %u.%u owned by %ld\",\n\t\t      (long) uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\n\tlist_prepend(job->sruns, (void *) srun);\n\trc = io_client_connect(srun, job);\n\tdebug(\"  back from io_client_connect, rc = %d\", rc);\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\n\tdebug(\"  in _handle_attach rc = %d\", rc);\n\tif (rc == SLURM_SUCCESS) {\n\t\t/* Send response info */\n\t\tuint32_t *pids, *gtids;\n\t\tint len, i;\n\n\t\tdebug(\"  in _handle_attach sending response info\");\n\t\tlen = job->node_tasks * sizeof(uint32_t);\n\t\tpids = xmalloc(len);\n\t\tgtids = xmalloc(len);\n\n\t\tif (job->task != NULL) {\n\t\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\t\tif (job->task[i] == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tpids[i] = (uint32_t)job->task[i]->pid;\n\t\t\t\tgtids[i] = job->task[i]->gtid;\n\t\t\t}\n\t\t}\n\n\t\tsafe_write(fd, &job->node_tasks, sizeof(uint32_t));\n\t\tsafe_write(fd, pids, len);\n\t\tsafe_write(fd, gtids, len);\n\t\txfree(pids);\n\t\txfree(gtids);\n\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i] && job->task[i]->argv) {\n\t\t\t\tlen = strlen(job->task[i]->argv[0]) + 1;\n\t\t\t\tsafe_write(fd, &len, sizeof(int));\n\t\t\t\tsafe_write(fd, job->task[i]->argv[0], len);\n\t\t\t} else {\n\t\t\t\tlen = 0;\n\t\t\t\tsafe_write(fd, &len, sizeof(int));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&len",
            "sizeof(int)"
          ],
          "line": 1196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "job->task[i]->argv[0]",
            "len"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&len",
            "sizeof(int)"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "job->task[i]->argv[0]"
          ],
          "line": 1191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "gtids"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "gtids",
            "len"
          ],
          "line": 1185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "pids",
            "len"
          ],
          "line": 1184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->node_tasks",
            "sizeof(uint32_t)"
          ],
          "line": 1183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "len"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "len"
          ],
          "line": 1171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"  in _handle_attach sending response info\""
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_stop_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "120-139",
          "snippet": "void\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"  in _handle_attach rc = %d\"",
            "rc"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_wake_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "187-199",
          "snippet": "void pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_client_connect",
          "args": [
            "srun",
            "job"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "io_client_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1637-1691",
          "snippet": "int\nio_client_connect(srun_info_t *srun, stepd_step_rec_t *job)\n{\n\tint sock = -1;\n\tstruct client_io_info *client;\n\teio_obj_t *obj;\n\n\tdebug4 (\"adding IO connection (logical node rank %d)\", job->nodeid);\n\n\tif (srun->ioaddr.sin_addr.s_addr) {\n\t\tchar         ip[256];\n\t\tuint16_t     port;\n\t\tslurm_get_ip_str(&srun->ioaddr, &port, ip, sizeof(ip));\n\t\tdebug4(\"connecting IO back to %s:%d\", ip, ntohs(port));\n\t}\n\n\tif ((sock = (int) slurm_open_stream(&srun->ioaddr, true)) < 0) {\n\t\terror(\"connect io: %m\");\n\t\t/* XXX retry or silently fail?\n\t\t *     fail for now.\n\t\t */\n\t\treturn SLURM_ERROR;\n\t}\n\n\tfd_set_blocking(sock);  /* just in case... */\n\n\t_send_io_init_msg(sock, srun->key, job);\n\n\tdebug5(\"  back from _send_io_init_msg\");\n\tfd_set_nonblocking(sock);\n\tfd_set_close_on_exec(sock);\n\n\t/* Now set up the eio object */\n\tclient = xmalloc(sizeof(struct client_io_info));\n#ifndef NDEBUG\n\tclient->magic = CLIENT_IO_MAGIC;\n#endif\n\tclient->job = job;\n\tclient->msg_queue = NULL; /* initialized in _client_writable */\n\n\tclient->ltaskid_stdout = -1;     /* accept from all tasks */\n\tclient->ltaskid_stderr = -1;     /* accept from all tasks */\n\tclient->labelio = false;\n\tclient->label_width = 0;\n\tclient->is_local_file = false;\n\n\t/* client object adds itself to job->clients in _client_writable */\n\n\tobj = eio_obj_create(sock, &client_ops, (void *)client);\n\teio_new_obj(job->eio, (void *)obj);\n\n\tdebug5(\"New IO Client object added\");\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [
            "#define CLIENT_IO_MAGIC  0x10102"
          ],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "struct io_operations client_ops = {\n\t.readable = &_client_readable,\n\t.writable = &_client_writable,\n\t.handle_read = &_client_read,\n\t.handle_write = &_client_write,\n};",
            "static bool _local_file_writable(eio_obj_t *);",
            "static bool _task_writable(eio_obj_t *);",
            "static bool _task_readable(eio_obj_t *);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _route_msg_task_to_client(eio_obj_t *obj);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstruct io_operations client_ops = {\n\t.readable = &_client_readable,\n\t.writable = &_client_writable,\n\t.handle_read = &_client_read,\n\t.handle_write = &_client_write,\n};\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nint\nio_client_connect(srun_info_t *srun, stepd_step_rec_t *job)\n{\n\tint sock = -1;\n\tstruct client_io_info *client;\n\teio_obj_t *obj;\n\n\tdebug4 (\"adding IO connection (logical node rank %d)\", job->nodeid);\n\n\tif (srun->ioaddr.sin_addr.s_addr) {\n\t\tchar         ip[256];\n\t\tuint16_t     port;\n\t\tslurm_get_ip_str(&srun->ioaddr, &port, ip, sizeof(ip));\n\t\tdebug4(\"connecting IO back to %s:%d\", ip, ntohs(port));\n\t}\n\n\tif ((sock = (int) slurm_open_stream(&srun->ioaddr, true)) < 0) {\n\t\terror(\"connect io: %m\");\n\t\t/* XXX retry or silently fail?\n\t\t *     fail for now.\n\t\t */\n\t\treturn SLURM_ERROR;\n\t}\n\n\tfd_set_blocking(sock);  /* just in case... */\n\n\t_send_io_init_msg(sock, srun->key, job);\n\n\tdebug5(\"  back from _send_io_init_msg\");\n\tfd_set_nonblocking(sock);\n\tfd_set_close_on_exec(sock);\n\n\t/* Now set up the eio object */\n\tclient = xmalloc(sizeof(struct client_io_info));\n#ifndef NDEBUG\n\tclient->magic = CLIENT_IO_MAGIC;\n#endif\n\tclient->job = job;\n\tclient->msg_queue = NULL; /* initialized in _client_writable */\n\n\tclient->ltaskid_stdout = -1;     /* accept from all tasks */\n\tclient->ltaskid_stderr = -1;     /* accept from all tasks */\n\tclient->labelio = false;\n\tclient->label_width = 0;\n\tclient->is_local_file = false;\n\n\t/* client object adds itself to job->clients in _client_writable */\n\n\tobj = eio_obj_create(sock, &client_ops, (void *)client);\n\teio_new_obj(job->eio, (void *)obj);\n\n\tdebug5(\"New IO Client object added\");\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_prepend",
          "args": [
            "job->sruns",
            "(void *) srun"
          ],
          "line": 1156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"uid %ld attempt to attach to job %u.%u owned by %ld\"",
            "(long) uid",
            "job->jobid",
            "job->stepid",
            "(long)job->uid"
          ],
          "line": 1150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_slurm_authorized_user",
          "args": [
            "uid"
          ],
          "line": 1149
        },
        "resolved": true,
        "details": {
          "function_name": "_slurm_authorized_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "136-140",
          "snippet": "static bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&srun->protocol_version",
            "sizeof(int)"
          ],
          "line": 1133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "srun->key",
            "SLURM_IO_KEY_SIZE"
          ],
          "line": 1132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&srun->resp_addr",
            "sizeof(slurm_addr_t)"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&srun->ioaddr",
            "sizeof(slurm_addr_t)"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"sizeof(srun_info_t) = %d, sizeof(slurm_addr_t) = %d\"",
            "(int) sizeof(srun_info_t)",
            "(int) sizeof(slurm_addr_t)"
          ],
          "line": 1128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "SLURM_IO_KEY_SIZE"
          ],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(srun_info_t)"
          ],
          "line": 1125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"_handle_attach for job %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_attach(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tsrun_info_t *srun;\n\tint rc = SLURM_SUCCESS;\n\n\tdebug(\"_handle_attach for job %u.%u\", job->jobid, job->stepid);\n\n\tsrun       = xmalloc(sizeof(srun_info_t));\n\tsrun->key  = (srun_key_t *)xmalloc(SLURM_IO_KEY_SIZE);\n\n\tdebug(\"sizeof(srun_info_t) = %d, sizeof(slurm_addr_t) = %d\",\n\t      (int) sizeof(srun_info_t), (int) sizeof(slurm_addr_t));\n\tsafe_read(fd, &srun->ioaddr, sizeof(slurm_addr_t));\n\tsafe_read(fd, &srun->resp_addr, sizeof(slurm_addr_t));\n\tsafe_read(fd, srun->key, SLURM_IO_KEY_SIZE);\n\tsafe_read(fd, &srun->protocol_version, sizeof(int));\n\n\tif (!srun->protocol_version)\n\t\tsrun->protocol_version = (uint16_t)NO_VAL;\n\t/*\n\t * Check if jobstep is actually running.\n\t */\n\tif (job->state != SLURMSTEPD_STEP_RUNNING) {\n\t\trc = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * At the moment, it only makes sense for the slurmd to make this\n\t * call, so only _slurm_authorized_user is allowed.\n\t */\n\tif (!_slurm_authorized_user(uid)) {\n\t\terror(\"uid %ld attempt to attach to job %u.%u owned by %ld\",\n\t\t      (long) uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\n\tlist_prepend(job->sruns, (void *) srun);\n\trc = io_client_connect(srun, job);\n\tdebug(\"  back from io_client_connect, rc = %d\", rc);\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\n\tdebug(\"  in _handle_attach rc = %d\", rc);\n\tif (rc == SLURM_SUCCESS) {\n\t\t/* Send response info */\n\t\tuint32_t *pids, *gtids;\n\t\tint len, i;\n\n\t\tdebug(\"  in _handle_attach sending response info\");\n\t\tlen = job->node_tasks * sizeof(uint32_t);\n\t\tpids = xmalloc(len);\n\t\tgtids = xmalloc(len);\n\n\t\tif (job->task != NULL) {\n\t\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\t\tif (job->task[i] == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tpids[i] = (uint32_t)job->task[i]->pid;\n\t\t\t\tgtids[i] = job->task[i]->gtid;\n\t\t\t}\n\t\t}\n\n\t\tsafe_write(fd, &job->node_tasks, sizeof(uint32_t));\n\t\tsafe_write(fd, pids, len);\n\t\tsafe_write(fd, gtids, len);\n\t\txfree(pids);\n\t\txfree(gtids);\n\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i] && job->task[i]->argv) {\n\t\t\t\tlen = strlen(job->task[i]->argv[0]) + 1;\n\t\t\t\tsafe_write(fd, &len, sizeof(int));\n\t\t\t\tsafe_write(fd, job->task[i]->argv[0], len);\n\t\t\t} else {\n\t\t\t\tlen = 0;\n\t\t\t\tsafe_write(fd, &len, sizeof(int));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_terminate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "1035-1115",
    "snippet": "static int\n_handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tstepd_step_task_info_t *task;\n\tuint32_t i;\n\n\tdebug(\"_handle_terminate for step=%u.%u uid=%d\",\n\t      job->jobid, job->stepid, uid);\n\tstep_terminate_monitor_start(job->jobid, job->stepid);\n\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"terminate req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\t/* cycle thru the tasks and mark those that have not\n\t * called abort and/or terminated as killed_by_cmd\n\t */\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tif (NULL == (task = job->task[i])) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (task->aborted || task->exited) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* mark that this task is going to be killed by\n\t\t * cmd so we ignore its exit status - otherwise,\n\t\t * we will probably report the final exit status\n\t\t * as SIGKILL\n\t\t */\n\t\ttask->killed_by_cmd = true;\n\t}\n\n\t/*\n\t * Signal the container with SIGKILL\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\tdebug(\"Terminating suspended job step %u.%u\",\n\t\t      job->jobid, job->stepid);\n\t\tsuspended = false;\n\t}\n\n\tif (proctrack_g_signal(job->cont_id, SIGKILL) < 0) {\n\t\tif (errno != ESRCH) {\t/* No error if process already gone */\n\t\t\trc = -1;\n\t\t\terrnum = errno;\n\t\t}\n\t\tverbose(\"Error sending SIGKILL signal to %u.%u: %m\",\n\t\t\tjob->jobid, job->stepid);\n\t} else {\n\t\tverbose(\"Sent SIGKILL signal to %u.%u\",\n\t\t\tjob->jobid, job->stepid);\n\t}\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errnum */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;",
      "static bool suspended = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&errnum",
            "sizeof(int)"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 1110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Sent SIGKILL signal to %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Error sending SIGKILL signal to %u.%u: %m\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proctrack_g_signal",
          "args": [
            "job->cont_id",
            "SIGKILL"
          ],
          "line": 1095
        },
        "resolved": true,
        "details": {
          "function_name": "proctrack_g_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/proctrack.c",
          "lines": "348-397",
          "snippet": "extern int proctrack_g_signal(uint64_t cont_id, int signal)\n{\n\n\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\tif (signal == SIGKILL) {\n\t\tpid_t *pids = NULL;\n\t\tint i, j, npids = 0, hung_pids = 0;\n\t\tchar *stat_fname = NULL;\n\t\tif (proctrack_g_get_pids(cont_id, &pids, &npids) ==\n\t\t    SLURM_SUCCESS) {\n\t\t\t/* NOTE: proctrack_g_get_pids() is not supported\n\t\t\t * by the proctrack/pgid plugin */\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tif (j)\n\t\t\t\t\tsleep(2);\n\t\t\t\thung_pids = 0;\n\t\t\t\tfor (i = 0; i < npids; i++) {\n\t\t\t\t\tif (!pids[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\txstrfmtcat(stat_fname, \"/proc/%d/stat\",\n\t\t\t\t\t\t   (int) pids[i]);\n\t\t\t\t\tif (_test_core_dumping(stat_fname)) {\n\t\t\t\t\t\tdebug(\"Process %d continuing \"\n\t\t\t\t\t\t      \"core dump\",\n\t\t\t\t\t\t      (int) pids[i]);\n\t\t\t\t\t\thung_pids++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Don't test this PID again */\n\t\t\t\t\t\tpids[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\txfree(stat_fname);\n\t\t\t\t}\n\t\t\t\tif (hung_pids == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\txfree(pids);\n\t\t\tif (hung_pids) {\n\t\t\t\tinfo(\"Defering sending signal, processes in \"\n\t\t\t\t     \"job are currently core dumping\");\n\t\t\t\t_spawn_signal_thread(cont_id, signal);\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (*(ops.signal)) (cont_id, signal);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/log.h\"",
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static slurm_proctrack_ops_t ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/log.h\"\n#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic slurm_proctrack_ops_t ops;\n\nextern int proctrack_g_signal(uint64_t cont_id, int signal)\n{\n\n\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\tif (signal == SIGKILL) {\n\t\tpid_t *pids = NULL;\n\t\tint i, j, npids = 0, hung_pids = 0;\n\t\tchar *stat_fname = NULL;\n\t\tif (proctrack_g_get_pids(cont_id, &pids, &npids) ==\n\t\t    SLURM_SUCCESS) {\n\t\t\t/* NOTE: proctrack_g_get_pids() is not supported\n\t\t\t * by the proctrack/pgid plugin */\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tif (j)\n\t\t\t\t\tsleep(2);\n\t\t\t\thung_pids = 0;\n\t\t\t\tfor (i = 0; i < npids; i++) {\n\t\t\t\t\tif (!pids[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\txstrfmtcat(stat_fname, \"/proc/%d/stat\",\n\t\t\t\t\t\t   (int) pids[i]);\n\t\t\t\t\tif (_test_core_dumping(stat_fname)) {\n\t\t\t\t\t\tdebug(\"Process %d continuing \"\n\t\t\t\t\t\t      \"core dump\",\n\t\t\t\t\t\t      (int) pids[i]);\n\t\t\t\t\t\thung_pids++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Don't test this PID again */\n\t\t\t\t\t\tpids[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\txfree(stat_fname);\n\t\t\t\t}\n\t\t\t\tif (hung_pids == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\txfree(pids);\n\t\t\tif (hung_pids) {\n\t\t\t\tinfo(\"Defering sending signal, processes in \"\n\t\t\t\t     \"job are currently core dumping\");\n\t\t\t\t_spawn_signal_thread(cont_id, signal);\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (*(ops.signal)) (cont_id, signal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Terminating suspended job step %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 1088
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\"",
            "job->jobid",
            "job->stepid",
            "job->cont_id"
          ],
          "line": 1060
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"terminate req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\"",
            "(long)uid",
            "job->jobid",
            "job->stepid",
            "(long)job->uid"
          ],
          "line": 1048
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_slurm_authorized_user",
          "args": [
            "uid"
          ],
          "line": 1047
        },
        "resolved": true,
        "details": {
          "function_name": "_slurm_authorized_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "136-140",
          "snippet": "static bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "step_terminate_monitor_start",
          "args": [
            "job->jobid",
            "job->stepid"
          ],
          "line": 1045
        },
        "resolved": true,
        "details": {
          "function_name": "step_terminate_monitor_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/step_terminate_monitor.c",
          "lines": "59-92",
          "snippet": "void step_terminate_monitor_start(uint32_t jobid, uint32_t stepid)\n{\n\tslurm_ctl_conf_t *conf;\n\tpthread_attr_t attr;\n\n\tslurm_mutex_lock(&lock);\n\n\tif (running_flag) {\n\t\tslurm_mutex_unlock(&lock);\n\t\treturn;\n\t}\n\n\tconf = slurm_conf_lock();\n\tif (conf->unkillable_program == NULL) {\n\t\t/* do nothing */\n\t\tslurm_conf_unlock();\n\t\tslurm_mutex_unlock(&lock);\n\t\treturn;\n\t}\n\ttimeout = conf->unkillable_timeout;\n\tprogram_name = xstrdup(conf->unkillable_program);\n\tslurm_conf_unlock();\n\n\tslurm_attr_init(&attr);\n\tpthread_create(&tid, &attr, _monitor, NULL);\n\tslurm_attr_destroy(&attr);\n\trunning_flag = 1;\n\trecorded_jobid = jobid;\n\trecorded_stepid = stepid;\n\n\tslurm_mutex_unlock(&lock);\n\n\treturn;\n}",
          "includes": [
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/macros.h\"",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;",
            "static int running_flag = 0;",
            "static pthread_t tid;",
            "static uint16_t timeout;",
            "static char *program_name;",
            "static uint32_t recorded_jobid = NO_VAL;",
            "static uint32_t recorded_stepid = NO_VAL;",
            "static void *_monitor(void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <pthread.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/macros.h\"\n#  include \"config.h\"\n\nstatic pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\nstatic int running_flag = 0;\nstatic pthread_t tid;\nstatic uint16_t timeout;\nstatic char *program_name;\nstatic uint32_t recorded_jobid = NO_VAL;\nstatic uint32_t recorded_stepid = NO_VAL;\nstatic void *_monitor(void *);\n\nvoid step_terminate_monitor_start(uint32_t jobid, uint32_t stepid)\n{\n\tslurm_ctl_conf_t *conf;\n\tpthread_attr_t attr;\n\n\tslurm_mutex_lock(&lock);\n\n\tif (running_flag) {\n\t\tslurm_mutex_unlock(&lock);\n\t\treturn;\n\t}\n\n\tconf = slurm_conf_lock();\n\tif (conf->unkillable_program == NULL) {\n\t\t/* do nothing */\n\t\tslurm_conf_unlock();\n\t\tslurm_mutex_unlock(&lock);\n\t\treturn;\n\t}\n\ttimeout = conf->unkillable_timeout;\n\tprogram_name = xstrdup(conf->unkillable_program);\n\tslurm_conf_unlock();\n\n\tslurm_attr_init(&attr);\n\tpthread_create(&tid, &attr, _monitor, NULL);\n\tslurm_attr_destroy(&attr);\n\trunning_flag = 1;\n\trecorded_jobid = jobid;\n\trecorded_stepid = stepid;\n\n\tslurm_mutex_unlock(&lock);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"_handle_terminate for step=%u.%u uid=%d\"",
            "job->jobid",
            "job->stepid",
            "uid"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool suspended = false;\n\nstatic int\n_handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tstepd_step_task_info_t *task;\n\tuint32_t i;\n\n\tdebug(\"_handle_terminate for step=%u.%u uid=%d\",\n\t      job->jobid, job->stepid, uid);\n\tstep_terminate_monitor_start(job->jobid, job->stepid);\n\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"terminate req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\t/* cycle thru the tasks and mark those that have not\n\t * called abort and/or terminated as killed_by_cmd\n\t */\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tif (NULL == (task = job->task[i])) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (task->aborted || task->exited) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* mark that this task is going to be killed by\n\t\t * cmd so we ignore its exit status - otherwise,\n\t\t * we will probably report the final exit status\n\t\t * as SIGKILL\n\t\t */\n\t\ttask->killed_by_cmd = true;\n\t}\n\n\t/*\n\t * Signal the container with SIGKILL\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\tdebug(\"Terminating suspended job step %u.%u\",\n\t\t      job->jobid, job->stepid);\n\t\tsuspended = false;\n\t}\n\n\tif (proctrack_g_signal(job->cont_id, SIGKILL) < 0) {\n\t\tif (errno != ESRCH) {\t/* No error if process already gone */\n\t\t\trc = -1;\n\t\t\terrnum = errno;\n\t\t}\n\t\tverbose(\"Error sending SIGKILL signal to %u.%u: %m\",\n\t\t\tjob->jobid, job->stepid);\n\t} else {\n\t\tverbose(\"Sent SIGKILL signal to %u.%u\",\n\t\t\tjob->jobid, job->stepid);\n\t}\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errnum */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_notify_job",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "999-1033",
    "snippet": "static int\n_handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint len;\n\tchar *message = NULL;\n\n\tdebug3(\"_handle_notify_job for job %u.%u\",\n\t       job->jobid, job->stepid);\n\n\tsafe_read(fd, &len, sizeof(int));\n\tif (len) {\n\t\tmessage = xmalloc (len);\n\t\tsafe_read(fd, message, len); /* '\\0' terminated */\n\t}\n\n\tdebug3(\"  uid = %d\", uid);\n\tif ((uid != job->uid) && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"notify req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\terror(\"%s\", message);\n\txfree(message);\n\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\txfree(message);\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "message"
          ],
          "line": 1029
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s\"",
            "message"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "_prolog_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "1386-1434",
          "snippet": "static void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _is_batch_job_finished(uint32_t job_id);",
            "static bool _job_still_running(uint32_t job_id);",
            "static void _launch_complete_add(uint32_t job_id);",
            "static void _launch_complete_log(char *type, uint32_t job_id);",
            "static void _launch_complete_rm(uint32_t job_id);",
            "static void _launch_complete_wait(uint32_t job_id);",
            "static bool _launch_job_test(uint32_t job_id);",
            "static void _note_batch_job_finished(uint32_t job_id);",
            "static bool _slurm_authorized_user(uid_t uid);",
            "static void _sync_messages_kill(kill_job_msg_t *req);",
            "static int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);",
            "static gids_t *_gids_cache_lookup(char *user, gid_t gid);",
            "static int  _add_starting_step(uint16_t type, void *req);",
            "static int  _remove_starting_step(uint16_t type, void *req);",
            "static void _add_job_running_prolog(uint32_t job_id);",
            "static void _remove_job_running_prolog(uint32_t job_id);",
            "static void _wait_for_job_running_prolog(uint32_t job_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic bool _is_batch_job_finished(uint32_t job_id);\nstatic bool _job_still_running(uint32_t job_id);\nstatic void _launch_complete_add(uint32_t job_id);\nstatic void _launch_complete_log(char *type, uint32_t job_id);\nstatic void _launch_complete_rm(uint32_t job_id);\nstatic void _launch_complete_wait(uint32_t job_id);\nstatic bool _launch_job_test(uint32_t job_id);\nstatic void _note_batch_job_finished(uint32_t job_id);\nstatic bool _slurm_authorized_user(uid_t uid);\nstatic void _sync_messages_kill(kill_job_msg_t *req);\nstatic int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);\nstatic gids_t *_gids_cache_lookup(char *user, gid_t gid);\nstatic int  _add_starting_step(uint16_t type, void *req);\nstatic int  _remove_starting_step(uint16_t type, void *req);\nstatic void _add_job_running_prolog(uint32_t job_id);\nstatic void _remove_job_running_prolog(uint32_t job_id);\nstatic void _wait_for_job_running_prolog(uint32_t job_id);\n\nstatic void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"notify req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\"",
            "(long)uid",
            "job->jobid",
            "job->stepid",
            "(long)job->uid"
          ],
          "line": 1017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_slurm_authorized_user",
          "args": [
            "uid"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "_slurm_authorized_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "136-140",
          "snippet": "static bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"  uid = %d\"",
            "uid"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "message",
            "len"
          ],
          "line": 1012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "len"
          ],
          "line": 1011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&len",
            "sizeof(int)"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"_handle_notify_job for job %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint len;\n\tchar *message = NULL;\n\n\tdebug3(\"_handle_notify_job for job %u.%u\",\n\t       job->jobid, job->stepid);\n\n\tsafe_read(fd, &len, sizeof(int));\n\tif (len) {\n\t\tmessage = xmalloc (len);\n\t\tsafe_read(fd, message, len); /* '\\0' terminated */\n\t}\n\n\tdebug3(\"  uid = %d\", uid);\n\tif ((uid != job->uid) && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"notify req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\terror(\"%s\", message);\n\txfree(message);\n\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\txfree(message);\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_checkpoint_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "916-997",
    "snippet": "static int\n_handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\ttime_t timestamp;\n\tint len;\n\tchar *image_dir = NULL;\n\n\tdebug3(\"_handle_checkpoint_tasks for job %u.%u\",\n\t       job->jobid, job->stepid);\n\n\tsafe_read(fd, &timestamp, sizeof(time_t));\n\tsafe_read(fd, &len, sizeof(int));\n\tif (len) {\n\t\timage_dir = xmalloc (len);\n\t\tsafe_read(fd, image_dir, len); /* '\\0' terminated */\n\t}\n\n\tdebug3(\"  uid = %d\", uid);\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"checkpoint req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\n\tif (job->ckpt_timestamp &&\n\t    timestamp == job->ckpt_timestamp) {\n\t\tdebug(\"duplicate checkpoint req for job %u.%u, \"\n\t\t      \"timestamp %ld. discarded.\",\n\t\t      job->jobid, job->stepid, (long)timestamp);\n\t\trc = ESLURM_ALREADY_DONE; /* EINPROGRESS? */\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (job->pgid <= (pid_t)1) {\n\t\tdebug (\"step %u.%u invalid [jmgr_pid:%d pgid:%u]\",\n\t\t       job->jobid, job->stepid, job->jmgr_pid, job->pgid);\n\t\trc = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\trc = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\t/* set timestamp in case another request comes */\n\tjob->ckpt_timestamp = timestamp;\n\n\t/* TODO: do we need job->ckpt_dir any more,\n\t *\texcept for checkpoint/xlch? */\n/*\tif (! image_dir) { */\n/*\t\timage_dir = xstrdup(job->ckpt_dir); */\n/*\t} */\n\n\t/* call the plugin to send the request */\n\tif (checkpoint_signal_tasks(job, image_dir) != SLURM_SUCCESS) {\n\t\trc = -1;\n\t\tverbose(\"Error sending checkpoint request to %u.%u: %s\",\n\t\t\tjob->jobid, job->stepid, slurm_strerror(rc));\n\t} else {\n\t\tverbose(\"Sent checkpoint request to %u.%u\",\n\t\t\tjob->jobid, job->stepid);\n\t}\n\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\txfree(image_dir);\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;",
      "static bool suspended = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "image_dir"
          ],
          "line": 993
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Sent checkpoint request to %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Error sending checkpoint request to %u.%u: %s\"",
            "job->jobid",
            "job->stepid",
            "slurm_strerror(rc)"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_strerror",
          "args": [
            "rc"
          ],
          "line": 982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "checkpoint_signal_tasks",
          "args": [
            "job",
            "image_dir"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"step %u.%u invalid [jmgr_pid:%d pgid:%u]\"",
            "job->jobid",
            "job->stepid",
            "job->jmgr_pid",
            "job->pgid"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"duplicate checkpoint req for job %u.%u, \"\n\t\t      \"timestamp %ld. discarded.\"",
            "job->jobid",
            "job->stepid",
            "(long)timestamp"
          ],
          "line": 945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"checkpoint req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\"",
            "(long)uid",
            "job->jobid",
            "job->stepid",
            "(long)job->uid"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_slurm_authorized_user",
          "args": [
            "uid"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "_slurm_authorized_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "136-140",
          "snippet": "static bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"  uid = %d\"",
            "uid"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "image_dir",
            "len"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "len"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&len",
            "sizeof(int)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&timestamp",
            "sizeof(time_t)"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"_handle_checkpoint_tasks for job %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool suspended = false;\n\nstatic int\n_handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\ttime_t timestamp;\n\tint len;\n\tchar *image_dir = NULL;\n\n\tdebug3(\"_handle_checkpoint_tasks for job %u.%u\",\n\t       job->jobid, job->stepid);\n\n\tsafe_read(fd, &timestamp, sizeof(time_t));\n\tsafe_read(fd, &len, sizeof(int));\n\tif (len) {\n\t\timage_dir = xmalloc (len);\n\t\tsafe_read(fd, image_dir, len); /* '\\0' terminated */\n\t}\n\n\tdebug3(\"  uid = %d\", uid);\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"checkpoint req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\n\tif (job->ckpt_timestamp &&\n\t    timestamp == job->ckpt_timestamp) {\n\t\tdebug(\"duplicate checkpoint req for job %u.%u, \"\n\t\t      \"timestamp %ld. discarded.\",\n\t\t      job->jobid, job->stepid, (long)timestamp);\n\t\trc = ESLURM_ALREADY_DONE; /* EINPROGRESS? */\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (job->pgid <= (pid_t)1) {\n\t\tdebug (\"step %u.%u invalid [jmgr_pid:%d pgid:%u]\",\n\t\t       job->jobid, job->stepid, job->jmgr_pid, job->pgid);\n\t\trc = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\trc = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\t/* set timestamp in case another request comes */\n\tjob->ckpt_timestamp = timestamp;\n\n\t/* TODO: do we need job->ckpt_dir any more,\n\t *\texcept for checkpoint/xlch? */\n/*\tif (! image_dir) { */\n/*\t\timage_dir = xstrdup(job->ckpt_dir); */\n/*\t} */\n\n\t/* call the plugin to send the request */\n\tif (checkpoint_signal_tasks(job, image_dir) != SLURM_SUCCESS) {\n\t\trc = -1;\n\t\tverbose(\"Error sending checkpoint request to %u.%u: %s\",\n\t\t\tjob->jobid, job->stepid, slurm_strerror(rc));\n\t} else {\n\t\tverbose(\"Sent checkpoint request to %u.%u\",\n\t\t\tjob->jobid, job->stepid);\n\t}\n\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\txfree(image_dir);\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_signal_container",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "735-914",
    "snippet": "static int\n_handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tint sig;\n\tstatic int msg_sent = 0;\n\tchar *ptr = NULL;\n\tint target_node_id = 0;\n\tstepd_step_task_info_t *task;\n\tuint32_t i;\n\tuint32_t flag;\n\tuint32_t signal;\n\n\tsafe_read(fd, &signal, sizeof(int));\n\tflag = signal >> 24;\n\tsig = signal & 0xfff;\n\n\tdebug(\"_handle_signal_container for step=%u.%u uid=%d signal=%d\",\n\t      job->jobid, job->stepid, (int) uid, sig);\n\tif ((uid != job->uid) && !_slurm_authorized_user(uid)) {\n\t\terror(\"signal container req from uid %ld for step=%u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tif ((sig == SIGTERM) || (sig == SIGKILL)) {\n\t\t/* cycle thru the tasks and mark those that have not\n\t\t * called abort and/or terminated as killed_by_cmd\n\t\t */\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (NULL == (task = job->task[i])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task->aborted || task->exited) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* mark that this task is going to be killed by\n\t\t\t * cmd so we ignore its exit status - otherwise,\n\t\t\t * we will probably report the final exit status\n\t\t\t * as SIGKILL\n\t\t\t */\n\t\t\ttask->killed_by_cmd = true;\n\t\t}\n\t}\n\n\tptr = getenvp(job->env, \"SLURM_STEP_KILLED_MSG_NODE_ID\");\n\tif (ptr)\n\t\ttarget_node_id = atoi(ptr);\n\tif ((job->stepid != SLURM_EXTERN_CONT) &&\n\t    (job->nodeid == target_node_id) && (msg_sent == 0) &&\n\t    (job->state < SLURMSTEPD_STEP_ENDING)) {\n\t\ttime_t now = time(NULL);\n\t\tchar entity[24], time_str[24];\n\n\t\tif (job->stepid == SLURM_BATCH_SCRIPT) {\n\t\t\tsnprintf(entity, sizeof(entity), \"JOB %u\", job->jobid);\n\t\t} else {\n\t\t\tsnprintf(entity, sizeof(entity), \"STEP %u.%u\",\n\t\t\t\t job->jobid, job->stepid);\n\t\t}\n\t\tslurm_make_time_str(&now, time_str, sizeof(time_str));\n\n\t\t/* Not really errors,\n\t\t * but we want messages displayed by default */\n\t\tif (sig == SIG_TIME_LIMIT) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO TIME LIMIT ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_PREEMPTED) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO PREEMPTION ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_NODE_FAIL) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO NODE \"\n\t\t\t      \"FAILURE, SEE SLURMCTLD LOG FOR DETAILS ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_REQUEUED) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO JOB REQUEUE ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_FAILURE) {\n\t\t\terror(\"*** %s ON %s FAILED (non-zero exit code or other \"\n\t\t\t      \"failure mode) ***\",\n\t\t\t      entity, job->node_name);\n\t\t\tmsg_sent = 1;\n\t\t} else if ((sig == SIGTERM) || (sig == SIGKILL)) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t}\n\t}\n\tif ((sig == SIG_TIME_LIMIT) || (sig == SIG_NODE_FAIL) ||\n\t    (sig == SIG_PREEMPTED)  || (sig == SIG_FAILURE) ||\n\t    (sig == SIG_REQUEUED))\n\t\tgoto done;\n\n\tif (sig == SIG_ABORT) {\n\t\tsig = SIGKILL;\n\t\tjob->aborted = true;\n\t}\n\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended && (sig != SIGKILL)) {\n\t\trc = -1;\n\t\terrnum = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\tif (sig == SIG_DEBUG_WAKE) {\n\t\tint i;\n\t\tfor (i = 0; i < job->node_tasks; i++)\n\t\t\tpdebug_wake_process(job, job->task[i]->pid);\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\tif (flag & KILL_JOB_BATCH\n\t    && job->stepid == SLURM_BATCH_SCRIPT) {\n\t\t/* We should only signal the batch script\n\t\t * and nothing else, the job pgid is the\n\t\t * equal to the pid of the batch script.\n\t\t */\n\t\tif (kill(job->pgid, sig) < 0) {\n\t\t\terror(\"%s: failed signal %d container pid\"\n\t\t\t      \"%u job %u.%u %m\",\n\t\t\t      __func__, sig, job->pgid,\n\t\t\t      job->jobid, job->stepid);\n\t\t\trc = SLURM_ERROR;\n\t\t\terrnum = errno;\n\t\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\t\tgoto done;\n\t\t}\n\t\trc = SLURM_SUCCESS;\n\t\terrnum = 0;\n\t\tverbose(\"%s: sent signal %d to container pid %u job %u.%u\",\n\t\t\t__func__, sig, job->pgid,\n\t\t\tjob->jobid, job->stepid);\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Signal the container\n\t */\n\tif (proctrack_g_signal(job->cont_id, sig) < 0) {\n\t\trc = -1;\n\t\terrnum = errno;\n\t\tverbose(\"Error sending signal %d to %u.%u: %m\",\n\t\t\tsig, job->jobid, job->stepid);\n\t} else {\n\t\tverbose(\"Sent signal %d to %u.%u\",\n\t\t\tsig, job->jobid, job->stepid);\n\t}\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errnum */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;",
      "static bool suspended = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&errnum",
            "sizeof(int)"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Sent signal %d to %u.%u\"",
            "sig",
            "job->jobid",
            "job->stepid"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Error sending signal %d to %u.%u: %m\"",
            "sig",
            "job->jobid",
            "job->stepid"
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proctrack_g_signal",
          "args": [
            "job->cont_id",
            "sig"
          ],
          "line": 896
        },
        "resolved": true,
        "details": {
          "function_name": "proctrack_g_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/proctrack.c",
          "lines": "348-397",
          "snippet": "extern int proctrack_g_signal(uint64_t cont_id, int signal)\n{\n\n\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\tif (signal == SIGKILL) {\n\t\tpid_t *pids = NULL;\n\t\tint i, j, npids = 0, hung_pids = 0;\n\t\tchar *stat_fname = NULL;\n\t\tif (proctrack_g_get_pids(cont_id, &pids, &npids) ==\n\t\t    SLURM_SUCCESS) {\n\t\t\t/* NOTE: proctrack_g_get_pids() is not supported\n\t\t\t * by the proctrack/pgid plugin */\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tif (j)\n\t\t\t\t\tsleep(2);\n\t\t\t\thung_pids = 0;\n\t\t\t\tfor (i = 0; i < npids; i++) {\n\t\t\t\t\tif (!pids[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\txstrfmtcat(stat_fname, \"/proc/%d/stat\",\n\t\t\t\t\t\t   (int) pids[i]);\n\t\t\t\t\tif (_test_core_dumping(stat_fname)) {\n\t\t\t\t\t\tdebug(\"Process %d continuing \"\n\t\t\t\t\t\t      \"core dump\",\n\t\t\t\t\t\t      (int) pids[i]);\n\t\t\t\t\t\thung_pids++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Don't test this PID again */\n\t\t\t\t\t\tpids[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\txfree(stat_fname);\n\t\t\t\t}\n\t\t\t\tif (hung_pids == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\txfree(pids);\n\t\t\tif (hung_pids) {\n\t\t\t\tinfo(\"Defering sending signal, processes in \"\n\t\t\t\t     \"job are currently core dumping\");\n\t\t\t\t_spawn_signal_thread(cont_id, signal);\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (*(ops.signal)) (cont_id, signal);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/log.h\"",
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <unistd.h>",
            "#include <pthread.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static slurm_proctrack_ops_t ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/log.h\"\n#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic slurm_proctrack_ops_t ops;\n\nextern int proctrack_g_signal(uint64_t cont_id, int signal)\n{\n\n\n\tif (slurm_proctrack_init() < 0)\n\t\treturn SLURM_ERROR;\n\n\tif (signal == SIGKILL) {\n\t\tpid_t *pids = NULL;\n\t\tint i, j, npids = 0, hung_pids = 0;\n\t\tchar *stat_fname = NULL;\n\t\tif (proctrack_g_get_pids(cont_id, &pids, &npids) ==\n\t\t    SLURM_SUCCESS) {\n\t\t\t/* NOTE: proctrack_g_get_pids() is not supported\n\t\t\t * by the proctrack/pgid plugin */\n\t\t\tfor (j = 0; j < 2; j++) {\n\t\t\t\tif (j)\n\t\t\t\t\tsleep(2);\n\t\t\t\thung_pids = 0;\n\t\t\t\tfor (i = 0; i < npids; i++) {\n\t\t\t\t\tif (!pids[i])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\txstrfmtcat(stat_fname, \"/proc/%d/stat\",\n\t\t\t\t\t\t   (int) pids[i]);\n\t\t\t\t\tif (_test_core_dumping(stat_fname)) {\n\t\t\t\t\t\tdebug(\"Process %d continuing \"\n\t\t\t\t\t\t      \"core dump\",\n\t\t\t\t\t\t      (int) pids[i]);\n\t\t\t\t\t\thung_pids++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t/* Don't test this PID again */\n\t\t\t\t\t\tpids[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t\txfree(stat_fname);\n\t\t\t\t}\n\t\t\t\tif (hung_pids == 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\txfree(pids);\n\t\t\tif (hung_pids) {\n\t\t\t\tinfo(\"Defering sending signal, processes in \"\n\t\t\t\t     \"job are currently core dumping\");\n\t\t\t\t_spawn_signal_thread(cont_id, signal);\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (*(ops.signal)) (cont_id, signal);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"%s: sent signal %d to container pid %u job %u.%u\"",
            "__func__",
            "sig",
            "job->pgid",
            "job->jobid",
            "job->stepid"
          ],
          "line": 886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: failed signal %d container pid\"\n\t\t\t      \"%u job %u.%u %m\"",
            "__func__",
            "sig",
            "job->pgid",
            "job->jobid",
            "job->stepid"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "job->pgid",
            "sig"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "_delay_kill_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "2124-2144",
          "snippet": "static void _delay_kill_thread(pthread_t thread_id, int secs)\n{\n\tpthread_t kill_id;\n\tpthread_attr_t attr;\n\tkill_thread_t *kt = xmalloc(sizeof(kill_thread_t));\n\tint retries = 0;\n\n\tkt->thread_id = thread_id;\n\tkt->secs = secs;\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&kill_id, &attr, &_kill_thr, (void *) kt)) {\n\t\terror(\"_delay_kill_thread: pthread_create: %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"_delay_kill_thread: Can't create pthread\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void _delay_kill_thread(pthread_t thread_id, int secs)\n{\n\tpthread_t kill_id;\n\tpthread_attr_t attr;\n\tkill_thread_t *kt = xmalloc(sizeof(kill_thread_t));\n\tint retries = 0;\n\n\tkt->thread_id = thread_id;\n\tkt->secs = secs;\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&kill_id, &attr, &_kill_thr, (void *) kt)) {\n\t\terror(\"_delay_kill_thread: pthread_create: %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"_delay_kill_thread: Can't create pthread\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pdebug_wake_process",
          "args": [
            "job",
            "job->task[i]->pid"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_wake_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "187-199",
          "snippet": "void pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"*** %s ON %s CANCELLED AT %s ***\"",
            "entity",
            "job->node_name",
            "time_str"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"*** %s ON %s FAILED (non-zero exit code or other \"\n\t\t\t      \"failure mode) ***\"",
            "entity",
            "job->node_name"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"*** %s ON %s CANCELLED AT %s DUE TO JOB REQUEUE ***\"",
            "entity",
            "job->node_name",
            "time_str"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"*** %s ON %s CANCELLED AT %s DUE TO NODE \"\n\t\t\t      \"FAILURE, SEE SLURMCTLD LOG FOR DETAILS ***\"",
            "entity",
            "job->node_name",
            "time_str"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"*** %s ON %s CANCELLED AT %s DUE TO PREEMPTION ***\"",
            "entity",
            "job->node_name",
            "time_str"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"*** %s ON %s CANCELLED AT %s DUE TO TIME LIMIT ***\"",
            "entity",
            "job->node_name",
            "time_str"
          ],
          "line": 815
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_make_time_str",
          "args": [
            "&now",
            "time_str",
            "sizeof(time_str)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "entity",
            "sizeof(entity)",
            "\"STEP %u.%u\"",
            "job->jobid",
            "job->stepid"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "entity",
            "sizeof(entity)",
            "\"JOB %u\"",
            "job->jobid"
          ],
          "line": 805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "_prolog_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "5661-5696",
          "snippet": "static void *_prolog_timer(void *x)\n{\n\tint delay_time, rc = SLURM_SUCCESS;\n\tstruct timespec ts;\n\tstruct timeval now;\n\tslurm_msg_t msg;\n\tjob_notify_msg_t notify_req;\n\tchar srun_msg[128];\n\ttimer_struct_t *timer_struct = (timer_struct_t *) x;\n\n\tdelay_time = MAX(2, (timer_struct->msg_timeout - 2));\n\tgettimeofday(&now, NULL);\n\tts.tv_sec = now.tv_sec + delay_time;\n\tts.tv_nsec = now.tv_usec * 1000;\n\tslurm_mutex_lock(timer_struct->timer_mutex);\n\tif (!timer_struct->prolog_fini) {\n\t\trc = pthread_cond_timedwait(timer_struct->timer_cond,\n\t\t\t\t\t    timer_struct->timer_mutex,\n\t\t\t\t\t    &ts);\n\t}\n\tslurm_mutex_unlock(timer_struct->timer_mutex);\n\n\tif (rc != ETIMEDOUT)\n\t\treturn NULL;\n\n\tslurm_msg_t_init(&msg);\n\tsnprintf(srun_msg, sizeof(srun_msg), \"Prolog hung on node %s\",\n\t\t conf->node_name);\n\tnotify_req.job_id\t= timer_struct->job_id;\n\tnotify_req.job_step_id\t= NO_VAL;\n\tnotify_req.message\t= srun_msg;\n\tmsg.msg_type\t= REQUEST_JOB_NOTIFY;\n\tmsg.data\t= &notify_req;\n\tslurm_send_only_controller_msg(&msg);\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _is_batch_job_finished(uint32_t job_id);",
            "static void _job_limits_free(void *x);",
            "static bool _job_still_running(uint32_t job_id);",
            "static void _launch_complete_add(uint32_t job_id);",
            "static void _launch_complete_log(char *type, uint32_t job_id);",
            "static void _launch_complete_rm(uint32_t job_id);",
            "static void _launch_complete_wait(uint32_t job_id);",
            "static bool _launch_job_test(uint32_t job_id);",
            "static void _note_batch_job_finished(uint32_t job_id);",
            "static void _rpc_launch_tasks(slurm_msg_t *);",
            "static void _rpc_abort_job(slurm_msg_t *);",
            "static void _rpc_prolog(slurm_msg_t *msg);",
            "static void _rpc_job_notify(slurm_msg_t *);",
            "static void _rpc_signal_tasks(slurm_msg_t *);",
            "static void _rpc_checkpoint_tasks(slurm_msg_t *);",
            "static void _rpc_complete_batch(slurm_msg_t *);",
            "static void _rpc_terminate_tasks(slurm_msg_t *);",
            "static void _rpc_timelimit(slurm_msg_t *);",
            "static void _rpc_reattach_tasks(slurm_msg_t *);",
            "static void _rpc_signal_job(slurm_msg_t *);",
            "static void _rpc_suspend_job(slurm_msg_t *msg);",
            "static void _rpc_terminate_job(slurm_msg_t *);",
            "static void _rpc_update_time(slurm_msg_t *);",
            "static void _rpc_shutdown(slurm_msg_t *msg);",
            "static void _rpc_reconfig(slurm_msg_t *msg);",
            "static void _rpc_reboot(slurm_msg_t *msg);",
            "static void _rpc_pid2jid(slurm_msg_t *msg);",
            "static int  _rpc_file_bcast(slurm_msg_t *msg);",
            "static int  _rpc_ping(slurm_msg_t *);",
            "static int  _rpc_health_check(slurm_msg_t *);",
            "static int  _rpc_acct_gather_update(slurm_msg_t *);",
            "static int  _rpc_acct_gather_energy(slurm_msg_t *);",
            "static int  _rpc_step_complete(slurm_msg_t *msg);",
            "static int  _rpc_step_complete_aggr(slurm_msg_t *msg);",
            "static int  _rpc_stat_jobacct(slurm_msg_t *msg);",
            "static int  _rpc_list_pids(slurm_msg_t *msg);",
            "static int  _rpc_daemon_status(slurm_msg_t *msg);",
            "static void _rpc_forward_data(slurm_msg_t *msg);",
            "static int  _rpc_network_callerid(slurm_msg_t *msg);",
            "static int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);",
            "static void _add_job_running_prolog(uint32_t job_id);",
            "static void _remove_job_running_prolog(uint32_t job_id);",
            "static void _wait_for_job_running_prolog(uint32_t job_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic bool _is_batch_job_finished(uint32_t job_id);\nstatic void _job_limits_free(void *x);\nstatic bool _job_still_running(uint32_t job_id);\nstatic void _launch_complete_add(uint32_t job_id);\nstatic void _launch_complete_log(char *type, uint32_t job_id);\nstatic void _launch_complete_rm(uint32_t job_id);\nstatic void _launch_complete_wait(uint32_t job_id);\nstatic bool _launch_job_test(uint32_t job_id);\nstatic void _note_batch_job_finished(uint32_t job_id);\nstatic void _rpc_launch_tasks(slurm_msg_t *);\nstatic void _rpc_abort_job(slurm_msg_t *);\nstatic void _rpc_prolog(slurm_msg_t *msg);\nstatic void _rpc_job_notify(slurm_msg_t *);\nstatic void _rpc_signal_tasks(slurm_msg_t *);\nstatic void _rpc_checkpoint_tasks(slurm_msg_t *);\nstatic void _rpc_complete_batch(slurm_msg_t *);\nstatic void _rpc_terminate_tasks(slurm_msg_t *);\nstatic void _rpc_timelimit(slurm_msg_t *);\nstatic void _rpc_reattach_tasks(slurm_msg_t *);\nstatic void _rpc_signal_job(slurm_msg_t *);\nstatic void _rpc_suspend_job(slurm_msg_t *msg);\nstatic void _rpc_terminate_job(slurm_msg_t *);\nstatic void _rpc_update_time(slurm_msg_t *);\nstatic void _rpc_shutdown(slurm_msg_t *msg);\nstatic void _rpc_reconfig(slurm_msg_t *msg);\nstatic void _rpc_reboot(slurm_msg_t *msg);\nstatic void _rpc_pid2jid(slurm_msg_t *msg);\nstatic int  _rpc_file_bcast(slurm_msg_t *msg);\nstatic int  _rpc_ping(slurm_msg_t *);\nstatic int  _rpc_health_check(slurm_msg_t *);\nstatic int  _rpc_acct_gather_update(slurm_msg_t *);\nstatic int  _rpc_acct_gather_energy(slurm_msg_t *);\nstatic int  _rpc_step_complete(slurm_msg_t *msg);\nstatic int  _rpc_step_complete_aggr(slurm_msg_t *msg);\nstatic int  _rpc_stat_jobacct(slurm_msg_t *msg);\nstatic int  _rpc_list_pids(slurm_msg_t *msg);\nstatic int  _rpc_daemon_status(slurm_msg_t *msg);\nstatic void _rpc_forward_data(slurm_msg_t *msg);\nstatic int  _rpc_network_callerid(slurm_msg_t *msg);\nstatic int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);\nstatic void _add_job_running_prolog(uint32_t job_id);\nstatic void _remove_job_running_prolog(uint32_t job_id);\nstatic void _wait_for_job_running_prolog(uint32_t job_id);\n\nstatic void *_prolog_timer(void *x)\n{\n\tint delay_time, rc = SLURM_SUCCESS;\n\tstruct timespec ts;\n\tstruct timeval now;\n\tslurm_msg_t msg;\n\tjob_notify_msg_t notify_req;\n\tchar srun_msg[128];\n\ttimer_struct_t *timer_struct = (timer_struct_t *) x;\n\n\tdelay_time = MAX(2, (timer_struct->msg_timeout - 2));\n\tgettimeofday(&now, NULL);\n\tts.tv_sec = now.tv_sec + delay_time;\n\tts.tv_nsec = now.tv_usec * 1000;\n\tslurm_mutex_lock(timer_struct->timer_mutex);\n\tif (!timer_struct->prolog_fini) {\n\t\trc = pthread_cond_timedwait(timer_struct->timer_cond,\n\t\t\t\t\t    timer_struct->timer_mutex,\n\t\t\t\t\t    &ts);\n\t}\n\tslurm_mutex_unlock(timer_struct->timer_mutex);\n\n\tif (rc != ETIMEDOUT)\n\t\treturn NULL;\n\n\tslurm_msg_t_init(&msg);\n\tsnprintf(srun_msg, sizeof(srun_msg), \"Prolog hung on node %s\",\n\t\t conf->node_name);\n\tnotify_req.job_id\t= timer_struct->job_id;\n\tnotify_req.job_step_id\t= NO_VAL;\n\tnotify_req.message\t= srun_msg;\n\tmsg.msg_type\t= REQUEST_JOB_NOTIFY;\n\tmsg.data\t= &notify_req;\n\tslurm_send_only_controller_msg(&msg);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "ptr"
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenvp",
          "args": [
            "job->env",
            "\"SLURM_STEP_KILLED_MSG_NODE_ID\""
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\"",
            "job->jobid",
            "job->stepid",
            "job->cont_id"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"signal container req from uid %ld for step=%u.%u \"\n\t\t      \"owned by uid %ld\"",
            "(long)uid",
            "job->jobid",
            "job->stepid",
            "(long)job->uid"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_slurm_authorized_user",
          "args": [
            "uid"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "_slurm_authorized_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "136-140",
          "snippet": "static bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"_handle_signal_container for step=%u.%u uid=%d signal=%d\"",
            "job->jobid",
            "job->stepid",
            "(int) uid",
            "sig"
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&signal",
            "sizeof(int)"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool suspended = false;\n\nstatic int\n_handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tint sig;\n\tstatic int msg_sent = 0;\n\tchar *ptr = NULL;\n\tint target_node_id = 0;\n\tstepd_step_task_info_t *task;\n\tuint32_t i;\n\tuint32_t flag;\n\tuint32_t signal;\n\n\tsafe_read(fd, &signal, sizeof(int));\n\tflag = signal >> 24;\n\tsig = signal & 0xfff;\n\n\tdebug(\"_handle_signal_container for step=%u.%u uid=%d signal=%d\",\n\t      job->jobid, job->stepid, (int) uid, sig);\n\tif ((uid != job->uid) && !_slurm_authorized_user(uid)) {\n\t\terror(\"signal container req from uid %ld for step=%u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tif ((sig == SIGTERM) || (sig == SIGKILL)) {\n\t\t/* cycle thru the tasks and mark those that have not\n\t\t * called abort and/or terminated as killed_by_cmd\n\t\t */\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (NULL == (task = job->task[i])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task->aborted || task->exited) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* mark that this task is going to be killed by\n\t\t\t * cmd so we ignore its exit status - otherwise,\n\t\t\t * we will probably report the final exit status\n\t\t\t * as SIGKILL\n\t\t\t */\n\t\t\ttask->killed_by_cmd = true;\n\t\t}\n\t}\n\n\tptr = getenvp(job->env, \"SLURM_STEP_KILLED_MSG_NODE_ID\");\n\tif (ptr)\n\t\ttarget_node_id = atoi(ptr);\n\tif ((job->stepid != SLURM_EXTERN_CONT) &&\n\t    (job->nodeid == target_node_id) && (msg_sent == 0) &&\n\t    (job->state < SLURMSTEPD_STEP_ENDING)) {\n\t\ttime_t now = time(NULL);\n\t\tchar entity[24], time_str[24];\n\n\t\tif (job->stepid == SLURM_BATCH_SCRIPT) {\n\t\t\tsnprintf(entity, sizeof(entity), \"JOB %u\", job->jobid);\n\t\t} else {\n\t\t\tsnprintf(entity, sizeof(entity), \"STEP %u.%u\",\n\t\t\t\t job->jobid, job->stepid);\n\t\t}\n\t\tslurm_make_time_str(&now, time_str, sizeof(time_str));\n\n\t\t/* Not really errors,\n\t\t * but we want messages displayed by default */\n\t\tif (sig == SIG_TIME_LIMIT) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO TIME LIMIT ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_PREEMPTED) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO PREEMPTION ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_NODE_FAIL) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO NODE \"\n\t\t\t      \"FAILURE, SEE SLURMCTLD LOG FOR DETAILS ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_REQUEUED) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO JOB REQUEUE ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_FAILURE) {\n\t\t\terror(\"*** %s ON %s FAILED (non-zero exit code or other \"\n\t\t\t      \"failure mode) ***\",\n\t\t\t      entity, job->node_name);\n\t\t\tmsg_sent = 1;\n\t\t} else if ((sig == SIGTERM) || (sig == SIGKILL)) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t}\n\t}\n\tif ((sig == SIG_TIME_LIMIT) || (sig == SIG_NODE_FAIL) ||\n\t    (sig == SIG_PREEMPTED)  || (sig == SIG_FAILURE) ||\n\t    (sig == SIG_REQUEUED))\n\t\tgoto done;\n\n\tif (sig == SIG_ABORT) {\n\t\tsig = SIGKILL;\n\t\tjob->aborted = true;\n\t}\n\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended && (sig != SIGKILL)) {\n\t\trc = -1;\n\t\terrnum = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\tif (sig == SIG_DEBUG_WAKE) {\n\t\tint i;\n\t\tfor (i = 0; i < job->node_tasks; i++)\n\t\t\tpdebug_wake_process(job, job->task[i]->pid);\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\tif (flag & KILL_JOB_BATCH\n\t    && job->stepid == SLURM_BATCH_SCRIPT) {\n\t\t/* We should only signal the batch script\n\t\t * and nothing else, the job pgid is the\n\t\t * equal to the pid of the batch script.\n\t\t */\n\t\tif (kill(job->pgid, sig) < 0) {\n\t\t\terror(\"%s: failed signal %d container pid\"\n\t\t\t      \"%u job %u.%u %m\",\n\t\t\t      __func__, sig, job->pgid,\n\t\t\t      job->jobid, job->stepid);\n\t\t\trc = SLURM_ERROR;\n\t\t\terrnum = errno;\n\t\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\t\tgoto done;\n\t\t}\n\t\trc = SLURM_SUCCESS;\n\t\terrnum = 0;\n\t\tverbose(\"%s: sent signal %d to container pid %u job %u.%u\",\n\t\t\t__func__, sig, job->pgid,\n\t\t\tjob->jobid, job->stepid);\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Signal the container\n\t */\n\tif (proctrack_g_signal(job->cont_id, sig) < 0) {\n\t\trc = -1;\n\t\terrnum = errno;\n\t\tverbose(\"Error sending signal %d to %u.%u: %m\",\n\t\t\tsig, job->jobid, job->stepid);\n\t} else {\n\t\tverbose(\"Sent signal %d to %u.%u\",\n\t\t\tsig, job->jobid, job->stepid);\n\t}\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errnum */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_signal_task_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "662-733",
    "snippet": "static int\n_handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint signal;\n\tint ltaskid; /* local task index */\n\n\tsafe_read(fd, &signal, sizeof(int));\n\tsafe_read(fd, &ltaskid, sizeof(int));\n\tdebug(\"_handle_signal_task_local for step=%u.%u uid=%d signal=%d\",\n\t      job->jobid, job->stepid, (int) uid, signal);\n\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"kill req from uid %ld for job %u.%u owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (ltaskid < 0 || ltaskid >= job->node_tasks) {\n\t\tdebug(\"step %u.%u invalid local task id %d\",\n\t\t      job->jobid, job->stepid, ltaskid);\n\t\trc = SLURM_ERROR;\n\t\tgoto done;\n\t}\n\tif (!job->task\n\t    || !job->task[ltaskid]) {\n\t\tdebug(\"step %u.%u no task info for task id %d\",\n\t\t      job->jobid, job->stepid, ltaskid);\n\t\trc = SLURM_ERROR;\n\t\tgoto done;\n\t}\n\tif (job->task[ltaskid]->pid <= 1) {\n\t\tdebug(\"step %u.%u invalid pid %d for task %d\",\n\t\t      job->jobid, job->stepid,\n\t\t      job->task[ltaskid]->pid, ltaskid);\n\t\trc = SLURM_ERROR;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Signal the task\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\trc = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\tif (kill(job->task[ltaskid]->pid, signal) == -1) {\n\t\trc = -1;\n\t\tverbose(\"Error sending signal %d to %u.%u, pid %d: %m\",\n\t\t\tsignal, job->jobid, job->stepid,\n\t\t\tjob->task[ltaskid]->pid);\n\t} else {\n\t\tverbose(\"Sent signal %d to %u.%u, pid %d\",\n\t\t\tsignal, job->jobid, job->stepid,\n\t\t\tjob->task[ltaskid]->pid);\n\t}\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;",
      "static bool suspended = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Sent signal %d to %u.%u, pid %d\"",
            "signal",
            "job->jobid",
            "job->stepid",
            "job->task[ltaskid]->pid"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "\"Error sending signal %d to %u.%u, pid %d: %m\"",
            "signal",
            "job->jobid",
            "job->stepid",
            "job->task[ltaskid]->pid"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "job->task[ltaskid]->pid",
            "signal"
          ],
          "line": 715
        },
        "resolved": true,
        "details": {
          "function_name": "_delay_kill_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "2124-2144",
          "snippet": "static void _delay_kill_thread(pthread_t thread_id, int secs)\n{\n\tpthread_t kill_id;\n\tpthread_attr_t attr;\n\tkill_thread_t *kt = xmalloc(sizeof(kill_thread_t));\n\tint retries = 0;\n\n\tkt->thread_id = thread_id;\n\tkt->secs = secs;\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&kill_id, &attr, &_kill_thr, (void *) kt)) {\n\t\terror(\"_delay_kill_thread: pthread_create: %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"_delay_kill_thread: Can't create pthread\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void _delay_kill_thread(pthread_t thread_id, int secs)\n{\n\tpthread_t kill_id;\n\tpthread_attr_t attr;\n\tkill_thread_t *kt = xmalloc(sizeof(kill_thread_t));\n\tint retries = 0;\n\n\tkt->thread_id = thread_id;\n\tkt->secs = secs;\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&kill_id, &attr, &_kill_thr, (void *) kt)) {\n\t\terror(\"_delay_kill_thread: pthread_create: %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"_delay_kill_thread: Can't create pthread\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&suspend_mutex"
          ],
          "line": 708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"step %u.%u invalid pid %d for task %d\"",
            "job->jobid",
            "job->stepid",
            "job->task[ltaskid]->pid",
            "ltaskid"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"step %u.%u no task info for task id %d\"",
            "job->jobid",
            "job->stepid",
            "ltaskid"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"step %u.%u invalid local task id %d\"",
            "job->jobid",
            "job->stepid",
            "ltaskid"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"kill req from uid %ld for job %u.%u owned by uid %ld\"",
            "(long)uid",
            "job->jobid",
            "job->stepid",
            "(long)job->uid"
          ],
          "line": 675
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_slurm_authorized_user",
          "args": [
            "uid"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "_slurm_authorized_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "136-140",
          "snippet": "static bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"_handle_signal_task_local for step=%u.%u uid=%d signal=%d\"",
            "job->jobid",
            "job->stepid",
            "(int) uid",
            "signal"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&ltaskid",
            "sizeof(int)"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&signal",
            "sizeof(int)"
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool suspended = false;\n\nstatic int\n_handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint signal;\n\tint ltaskid; /* local task index */\n\n\tsafe_read(fd, &signal, sizeof(int));\n\tsafe_read(fd, &ltaskid, sizeof(int));\n\tdebug(\"_handle_signal_task_local for step=%u.%u uid=%d signal=%d\",\n\t      job->jobid, job->stepid, (int) uid, signal);\n\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"kill req from uid %ld for job %u.%u owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (ltaskid < 0 || ltaskid >= job->node_tasks) {\n\t\tdebug(\"step %u.%u invalid local task id %d\",\n\t\t      job->jobid, job->stepid, ltaskid);\n\t\trc = SLURM_ERROR;\n\t\tgoto done;\n\t}\n\tif (!job->task\n\t    || !job->task[ltaskid]) {\n\t\tdebug(\"step %u.%u no task info for task id %d\",\n\t\t      job->jobid, job->stepid, ltaskid);\n\t\trc = SLURM_ERROR;\n\t\tgoto done;\n\t}\n\tif (job->task[ltaskid]->pid <= 1) {\n\t\tdebug(\"step %u.%u invalid pid %d for task %d\",\n\t\t      job->jobid, job->stepid,\n\t\t      job->task[ltaskid]->pid, ltaskid);\n\t\trc = SLURM_ERROR;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Signal the task\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\trc = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\tif (kill(job->task[ltaskid]->pid, signal) == -1) {\n\t\trc = -1;\n\t\tverbose(\"Error sending signal %d to %u.%u, pid %d: %m\",\n\t\t\tsignal, job->jobid, job->stepid,\n\t\t\tjob->task[ltaskid]->pid);\n\t} else {\n\t\tverbose(\"Sent signal %d to %u.%u, pid %d\",\n\t\t\tsignal, job->jobid, job->stepid,\n\t\t\tjob->task[ltaskid]->pid);\n\t}\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_nodeid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "652-660",
    "snippet": "static int\n_handle_nodeid(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->nodeid, sizeof(uid_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->nodeid",
            "sizeof(uid_t)"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_nodeid(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->nodeid, sizeof(uid_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "642-650",
    "snippet": "static int\n_handle_uid(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->uid, sizeof(uid_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->uid",
            "sizeof(uid_t)"
          ],
          "line": 645
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_uid(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->uid, sizeof(uid_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_mem_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "631-640",
    "snippet": "static int\n_handle_mem_limits(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->job_mem, sizeof(uint32_t));\n\tsafe_write(fd, &job->step_mem, sizeof(uint32_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->step_mem",
            "sizeof(uint32_t)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->job_mem",
            "sizeof(uint32_t)"
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_mem_limits(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->job_mem, sizeof(uint32_t));\n\tsafe_write(fd, &job->step_mem, sizeof(uint32_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "607-629",
    "snippet": "static int\n_handle_info(int fd, stepd_step_rec_t *job)\n{\n\tuint16_t protocol_version = SLURM_PROTOCOL_VERSION;\n\n\tsafe_write(fd, &job->uid, sizeof(uid_t));\n\tsafe_write(fd, &job->jobid, sizeof(uint32_t));\n\tsafe_write(fd, &job->stepid, sizeof(uint32_t));\n\n\t/* protocol_version was added in SLURM version 2.2,\n\t * so it needed to be added later in the data sent\n\t * for backward compatibility (so that it doesn't\n\t * get confused for a huge UID, job ID or step ID;\n\t * we should be save in avoiding huge node IDs). */\n\tsafe_write(fd, &protocol_version, sizeof(uint16_t));\n\tsafe_write(fd, &job->nodeid, sizeof(uint32_t));\n\tsafe_write(fd, &job->job_mem, sizeof(uint32_t));\n\tsafe_write(fd, &job->step_mem, sizeof(uint32_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->step_mem",
            "sizeof(uint32_t)"
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->job_mem",
            "sizeof(uint32_t)"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->nodeid",
            "sizeof(uint32_t)"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&protocol_version",
            "sizeof(uint16_t)"
          ],
          "line": 621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->stepid",
            "sizeof(uint32_t)"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->jobid",
            "sizeof(uint32_t)"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->uid",
            "sizeof(uid_t)"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_info(int fd, stepd_step_rec_t *job)\n{\n\tuint16_t protocol_version = SLURM_PROTOCOL_VERSION;\n\n\tsafe_write(fd, &job->uid, sizeof(uid_t));\n\tsafe_write(fd, &job->jobid, sizeof(uint32_t));\n\tsafe_write(fd, &job->stepid, sizeof(uint32_t));\n\n\t/* protocol_version was added in SLURM version 2.2,\n\t * so it needed to be added later in the data sent\n\t * for backward compatibility (so that it doesn't\n\t * get confused for a huge UID, job ID or step ID;\n\t * we should be save in avoiding huge node IDs). */\n\tsafe_write(fd, &protocol_version, sizeof(uint16_t));\n\tsafe_write(fd, &job->nodeid, sizeof(uint32_t));\n\tsafe_write(fd, &job->job_mem, sizeof(uint32_t));\n\tsafe_write(fd, &job->step_mem, sizeof(uint32_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "597-605",
    "snippet": "static int\n_handle_state(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->state, sizeof(slurmstepd_state_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&job->state",
            "sizeof(slurmstepd_state_t)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_state(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->state, sizeof(slurmstepd_state_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
  },
  {
    "function_name": "_handle_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "480-595",
    "snippet": "int\n_handle_request(int fd, stepd_step_rec_t *job, uid_t uid, gid_t gid)\n{\n\tint rc = 0;\n\tint req;\n\n\tdebug3(\"Entering _handle_request\");\n\tif ((rc = read(fd, &req, sizeof(int))) != sizeof(int)) {\n\t\tif (rc == 0) { /* EOF, normal */\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tdebug3(\"Leaving _handle_request on read error: %m\");\n\t\t\treturn SLURM_FAILURE;\n\t\t}\n\t}\n\tdebug3(\"Got request %d\", req);\n\trc = SLURM_SUCCESS;\n\tswitch (req) {\n\tcase REQUEST_SIGNAL_TASK_LOCAL:\n\t\tdebug(\"Handling REQUEST_SIGNAL_TASK_LOCAL\");\n\t\trc = _handle_signal_task_local(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_SIGNAL_TASK_GLOBAL:\n\t\tdebug(\"Handling REQUEST_SIGNAL_TASK_GLOBAL (not implemented)\");\n\t\tbreak;\n\tcase REQUEST_SIGNAL_PROCESS_GROUP:\t/* Defunct */\n\tcase REQUEST_SIGNAL_CONTAINER:\n\t\tdebug(\"Handling REQUEST_SIGNAL_CONTAINER\");\n\t\trc = _handle_signal_container(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_CHECKPOINT_TASKS:\n\t\tdebug(\"Handling REQUEST_CHECKPOINT_TASKS\");\n\t\trc = _handle_checkpoint_tasks(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STATE:\n\t\tdebug(\"Handling REQUEST_STATE\");\n\t\trc = _handle_state(fd, job);\n\t\tbreak;\n\tcase REQUEST_INFO:\n\t\tdebug(\"Handling REQUEST_INFO\");\n\t\trc = _handle_info(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_MEM_LIMITS:\n\t\tdebug(\"Handling REQUEST_STEP_MEM_LIMITS\");\n\t\trc = _handle_mem_limits(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_UID:\n\t\tdebug(\"Handling REQUEST_STEP_UID\");\n\t\trc = _handle_uid(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_NODEID:\n\t\tdebug(\"Handling REQUEST_STEP_NODEID\");\n\t\trc = _handle_nodeid(fd, job);\n\t\tbreak;\n\tcase REQUEST_ATTACH:\n\t\tdebug(\"Handling REQUEST_ATTACH\");\n\t\trc = _handle_attach(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_PID_IN_CONTAINER:\n\t\tdebug(\"Handling REQUEST_PID_IN_CONTAINER\");\n\t\trc = _handle_pid_in_container(fd, job);\n\t\tbreak;\n\tcase REQUEST_DAEMON_PID:\n\t\tdebug(\"Handling REQUEST_DAEMON_PID\");\n\t\trc = _handle_daemon_pid(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_SUSPEND:\n\t\tdebug(\"Handling REQUEST_STEP_SUSPEND\");\n\t\trc = _handle_suspend(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_RESUME:\n\t\tdebug(\"Handling REQUEST_STEP_RESUME\");\n\t\trc = _handle_resume(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_TERMINATE:\n\t\tdebug(\"Handling REQUEST_STEP_TERMINATE\");\n\t\trc = _handle_terminate(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_COMPLETION_V2:\n\t\tdebug(\"Handling REQUEST_STEP_COMPLETION_V2\");\n\t\trc = _handle_completion(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_TASK_INFO:\n\t\tdebug(\"Handling REQUEST_STEP_TASK_INFO\");\n\t\trc = _handle_task_info(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_STAT:\n\t\tdebug(\"Handling REQUEST_STEP_STAT\");\n\t\trc = _handle_stat_jobacct(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_LIST_PIDS:\n\t\tdebug(\"Handling REQUEST_STEP_LIST_PIDS\");\n\t\trc = _handle_list_pids(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_RECONFIGURE:\n\t\tdebug(\"Handling REQUEST_STEP_RECONFIGURE\");\n\t\trc = _handle_reconfig(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_JOB_NOTIFY:\n\t\tdebug(\"Handling REQUEST_JOB_NOTIFY\");\n\t\trc = _handle_notify_job(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_ADD_EXTERN_PID:\n\t\tdebug(\"Handling REQUEST_ADD_EXTERN_PID\");\n\t\trc = _handle_add_extern_pid(fd, job);\n\t\tbreak;\n\tdefault:\n\t\terror(\"Unrecognized request: %d\", req);\n\t\trc = SLURM_FAILURE;\n\t\tbreak;\n\t}\n\n\tdebug3(\"Leaving  _handle_request: %s\",\n\t       rc ? \"SLURM_FAILURE\" : \"SLURM_SUCCESS\");\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_request(int fd, stepd_step_rec_t *job, uid_t uid, gid_t gid);",
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Leaving  _handle_request: %s\"",
            "rc ? \"SLURM_FAILURE\" : \"SLURM_SUCCESS\""
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unrecognized request: %d\"",
            "req"
          ],
          "line": 587
        },
        "resolved": true,
        "details": {
          "function_name": "_prolog_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "1386-1434",
          "snippet": "static void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _is_batch_job_finished(uint32_t job_id);",
            "static bool _job_still_running(uint32_t job_id);",
            "static void _launch_complete_add(uint32_t job_id);",
            "static void _launch_complete_log(char *type, uint32_t job_id);",
            "static void _launch_complete_rm(uint32_t job_id);",
            "static void _launch_complete_wait(uint32_t job_id);",
            "static bool _launch_job_test(uint32_t job_id);",
            "static void _note_batch_job_finished(uint32_t job_id);",
            "static bool _slurm_authorized_user(uid_t uid);",
            "static void _sync_messages_kill(kill_job_msg_t *req);",
            "static int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);",
            "static gids_t *_gids_cache_lookup(char *user, gid_t gid);",
            "static int  _add_starting_step(uint16_t type, void *req);",
            "static int  _remove_starting_step(uint16_t type, void *req);",
            "static void _add_job_running_prolog(uint32_t job_id);",
            "static void _remove_job_running_prolog(uint32_t job_id);",
            "static void _wait_for_job_running_prolog(uint32_t job_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic bool _is_batch_job_finished(uint32_t job_id);\nstatic bool _job_still_running(uint32_t job_id);\nstatic void _launch_complete_add(uint32_t job_id);\nstatic void _launch_complete_log(char *type, uint32_t job_id);\nstatic void _launch_complete_rm(uint32_t job_id);\nstatic void _launch_complete_wait(uint32_t job_id);\nstatic bool _launch_job_test(uint32_t job_id);\nstatic void _note_batch_job_finished(uint32_t job_id);\nstatic bool _slurm_authorized_user(uid_t uid);\nstatic void _sync_messages_kill(kill_job_msg_t *req);\nstatic int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);\nstatic gids_t *_gids_cache_lookup(char *user, gid_t gid);\nstatic int  _add_starting_step(uint16_t type, void *req);\nstatic int  _remove_starting_step(uint16_t type, void *req);\nstatic void _add_job_running_prolog(uint32_t job_id);\nstatic void _remove_job_running_prolog(uint32_t job_id);\nstatic void _wait_for_job_running_prolog(uint32_t job_id);\n\nstatic void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_add_extern_pid",
          "args": [
            "fd",
            "job"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_add_extern_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1364-1381",
          "snippet": "static int\n_handle_add_extern_pid(int fd, stepd_step_rec_t *job)\n{\n\tint rc = SLURM_SUCCESS;\n\tpid_t pid;\n\n\tsafe_read(fd, &pid, sizeof(pid_t));\n\n\trc = _handle_add_extern_pid_internal(job, pid);\n\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\n\tdebug(\"Leaving _handle_add_extern_pid\");\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_add_extern_pid(int fd, stepd_step_rec_t *job)\n{\n\tint rc = SLURM_SUCCESS;\n\tpid_t pid;\n\n\tsafe_read(fd, &pid, sizeof(pid_t));\n\n\trc = _handle_add_extern_pid_internal(job, pid);\n\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\n\tdebug(\"Leaving _handle_add_extern_pid\");\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Handling REQUEST_ADD_EXTERN_PID\""
          ],
          "line": 583
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_stop_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "120-139",
          "snippet": "void\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_notify_job",
          "args": [
            "fd",
            "job",
            "uid"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_notify_job",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "999-1033",
          "snippet": "static int\n_handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint len;\n\tchar *message = NULL;\n\n\tdebug3(\"_handle_notify_job for job %u.%u\",\n\t       job->jobid, job->stepid);\n\n\tsafe_read(fd, &len, sizeof(int));\n\tif (len) {\n\t\tmessage = xmalloc (len);\n\t\tsafe_read(fd, message, len); /* '\\0' terminated */\n\t}\n\n\tdebug3(\"  uid = %d\", uid);\n\tif ((uid != job->uid) && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"notify req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\terror(\"%s\", message);\n\txfree(message);\n\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\txfree(message);\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint len;\n\tchar *message = NULL;\n\n\tdebug3(\"_handle_notify_job for job %u.%u\",\n\t       job->jobid, job->stepid);\n\n\tsafe_read(fd, &len, sizeof(int));\n\tif (len) {\n\t\tmessage = xmalloc (len);\n\t\tsafe_read(fd, message, len); /* '\\0' terminated */\n\t}\n\n\tdebug3(\"  uid = %d\", uid);\n\tif ((uid != job->uid) && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"notify req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\terror(\"%s\", message);\n\txfree(message);\n\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\txfree(message);\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_reconfig",
          "args": [
            "fd",
            "job",
            "uid"
          ],
          "line": 576
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_reconfig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1775-1804",
          "snippet": "static int\n_handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"job step reconfigure request from uid %ld \"\n\t\t      \"for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t/* We just want to make sure the file handle is correct on a\n\t   reconfigure since the file could had rolled thus making\n\t   the currect fd incorrect. */\n\tlog_alter(conf->log_opts, SYSLOG_FACILITY_DAEMON, conf->logfile);\n\tdebug(\"_handle_reconfigure for job %u.%u successful\",\n\t      job->jobid, job->stepid);\n\ndone:\n\t/* Send the return code and errno */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"job step reconfigure request from uid %ld \"\n\t\t      \"for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t/* We just want to make sure the file handle is correct on a\n\t   reconfigure since the file could had rolled thus making\n\t   the currect fd incorrect. */\n\tlog_alter(conf->log_opts, SYSLOG_FACILITY_DAEMON, conf->logfile);\n\tdebug(\"_handle_reconfigure for job %u.%u successful\",\n\t      job->jobid, job->stepid);\n\ndone:\n\t/* Send the return code and errno */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_list_pids",
          "args": [
            "fd",
            "job"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_list_pids",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1750-1773",
          "snippet": "static int\n_handle_list_pids(int fd, stepd_step_rec_t *job)\n{\n\tint i;\n\tpid_t *pids = NULL;\n\tint npids = 0;\n\tuint32_t pid;\n\n\tdebug(\"_handle_list_pids for job %u.%u\", job->jobid, job->stepid);\n\tproctrack_g_get_pids(job->cont_id, &pids, &npids);\n\tsafe_write(fd, &npids, sizeof(uint32_t));\n\tfor (i = 0; i < npids; i++) {\n\t\tpid = (uint32_t)pids[i];\n\t\tsafe_write(fd, &pid, sizeof(uint32_t));\n\t}\n\tif (npids > 0)\n\t\txfree(pids);\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\tif (npids > 0)\n\t\txfree(pids);\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_list_pids(int fd, stepd_step_rec_t *job)\n{\n\tint i;\n\tpid_t *pids = NULL;\n\tint npids = 0;\n\tuint32_t pid;\n\n\tdebug(\"_handle_list_pids for job %u.%u\", job->jobid, job->stepid);\n\tproctrack_g_get_pids(job->cont_id, &pids, &npids);\n\tsafe_write(fd, &npids, sizeof(uint32_t));\n\tfor (i = 0; i < npids; i++) {\n\t\tpid = (uint32_t)pids[i];\n\t\tsafe_write(fd, &pid, sizeof(uint32_t));\n\t}\n\tif (npids > 0)\n\t\txfree(pids);\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\tif (npids > 0)\n\t\txfree(pids);\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_stat_jobacct",
          "args": [
            "fd",
            "job",
            "uid"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_stat_jobacct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1681-1723",
          "snippet": "static int\n_handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tjobacctinfo_t *jobacct = NULL;\n\tjobacctinfo_t *temp_jobacct = NULL;\n\tint i = 0;\n\tint num_tasks = 0;\n\tdebug(\"_handle_stat_jobacct for job %u.%u\",\n\t      job->jobid, job->stepid);\n\n\tdebug3(\"  uid = %d\", uid);\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"stat jobacct from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\t/* Send NULL */\n\t\tjobacctinfo_setinfo(jobacct, JOBACCT_DATA_PIPE, &fd,\n\t\t\t\t    SLURM_PROTOCOL_VERSION);\n\t\treturn SLURM_ERROR;\n\t}\n\n\tjobacct = jobacctinfo_create(NULL);\n\tdebug3(\"num tasks = %d\", job->node_tasks);\n\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\ttemp_jobacct = jobacct_gather_stat_task(job->task[i]->pid);\n\t\tif (temp_jobacct) {\n\t\t\tjobacctinfo_aggregate(jobacct, temp_jobacct);\n\t\t\tjobacctinfo_destroy(temp_jobacct);\n\t\t\tnum_tasks++;\n\t\t}\n\t}\n\n\tjobacctinfo_setinfo(jobacct, JOBACCT_DATA_PIPE, &fd,\n\t\t\t    SLURM_PROTOCOL_VERSION);\n\tsafe_write(fd, &num_tasks, sizeof(int));\n\n\tjobacctinfo_destroy(jobacct);\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_ERROR;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tjobacctinfo_t *jobacct = NULL;\n\tjobacctinfo_t *temp_jobacct = NULL;\n\tint i = 0;\n\tint num_tasks = 0;\n\tdebug(\"_handle_stat_jobacct for job %u.%u\",\n\t      job->jobid, job->stepid);\n\n\tdebug3(\"  uid = %d\", uid);\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"stat jobacct from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\t/* Send NULL */\n\t\tjobacctinfo_setinfo(jobacct, JOBACCT_DATA_PIPE, &fd,\n\t\t\t\t    SLURM_PROTOCOL_VERSION);\n\t\treturn SLURM_ERROR;\n\t}\n\n\tjobacct = jobacctinfo_create(NULL);\n\tdebug3(\"num tasks = %d\", job->node_tasks);\n\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\ttemp_jobacct = jobacct_gather_stat_task(job->task[i]->pid);\n\t\tif (temp_jobacct) {\n\t\t\tjobacctinfo_aggregate(jobacct, temp_jobacct);\n\t\t\tjobacctinfo_destroy(temp_jobacct);\n\t\t\tnum_tasks++;\n\t\t}\n\t}\n\n\tjobacctinfo_setinfo(jobacct, JOBACCT_DATA_PIPE, &fd,\n\t\t\t    SLURM_PROTOCOL_VERSION);\n\tsafe_write(fd, &num_tasks, sizeof(int));\n\n\tjobacctinfo_destroy(jobacct);\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_task_info",
          "args": [
            "fd",
            "job"
          ],
          "line": 564
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_task_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1726-1747",
          "snippet": "static int\n_handle_task_info(int fd, stepd_step_rec_t *job)\n{\n\tint i;\n\tstepd_step_task_info_t *task;\n\n\tdebug(\"_handle_task_info for job %u.%u\", job->jobid, job->stepid);\n\n\tsafe_write(fd, &job->node_tasks, sizeof(uint32_t));\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\ttask = job->task[i];\n\t\tsafe_write(fd, &task->id, sizeof(int));\n\t\tsafe_write(fd, &task->gtid, sizeof(uint32_t));\n\t\tsafe_write(fd, &task->pid, sizeof(pid_t));\n\t\tsafe_write(fd, &task->exited, sizeof(bool));\n\t\tsafe_write(fd, &task->estatus, sizeof(int));\n\t}\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_task_info(int fd, stepd_step_rec_t *job)\n{\n\tint i;\n\tstepd_step_task_info_t *task;\n\n\tdebug(\"_handle_task_info for job %u.%u\", job->jobid, job->stepid);\n\n\tsafe_write(fd, &job->node_tasks, sizeof(uint32_t));\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\ttask = job->task[i];\n\t\tsafe_write(fd, &task->id, sizeof(int));\n\t\tsafe_write(fd, &task->gtid, sizeof(uint32_t));\n\t\tsafe_write(fd, &task->pid, sizeof(pid_t));\n\t\tsafe_write(fd, &task->exited, sizeof(bool));\n\t\tsafe_write(fd, &task->estatus, sizeof(int));\n\t}\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_completion",
          "args": [
            "fd",
            "job",
            "uid"
          ],
          "line": 560
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1574-1679",
          "snippet": "static int\n_handle_completion(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tint first;\n\tint last;\n\tjobacctinfo_t *jobacct = NULL;\n\tint step_rc;\n\tchar* buf;\n\tint len;\n\tBuf buffer;\n\tbool lock_set = false;\n\n\tdebug(\"_handle_completion for job %u.%u\",\n\t      job->jobid, job->stepid);\n\n\tdebug3(\"  uid = %d\", uid);\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"step completion message from uid %ld for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\t/* Send the return code and errno */\n\t\tsafe_write(fd, &rc, sizeof(int));\n\t\tsafe_write(fd, &errnum, sizeof(int));\n\t\treturn SLURM_SUCCESS;\n\t}\n\n\tsafe_read(fd, &first, sizeof(int));\n\tsafe_read(fd, &last, sizeof(int));\n\tsafe_read(fd, &step_rc, sizeof(int));\n\n\t/*\n\t * We must not use getinfo over a pipe with slurmd here\n\t * Indeed, slurmstepd does a large use of setinfo over a pipe\n\t * with slurmd and doing the reverse can result in a deadlock\n\t * scenario with slurmd :\n\t * slurmd(lockforread,write)/slurmstepd(write,lockforread)\n\t * Do pack/unpack instead to be sure of independances of\n\t * slurmd and slurmstepd\n\t */\n\tsafe_read(fd, &len, sizeof(int));\n\tbuf = xmalloc(len);\n\tsafe_read(fd, buf, len);\n\tbuffer = create_buf(buf, len);\n\tjobacctinfo_unpack(&jobacct, SLURM_PROTOCOL_VERSION,\n\t\t\t   PROTOCOL_TYPE_SLURM, buffer, 1);\n\tfree_buf(buffer);\n\n\t/*\n\t * Record the completed nodes\n\t */\n\tslurm_mutex_lock(&step_complete.lock);\n\tlock_set = true;\n\tif (! step_complete.wait_children) {\n\t\trc = -1;\n\t\terrnum = ETIMEDOUT; /* not used anyway */\n\t\tgoto timeout;\n\t}\n\n\t/* SlurmUser or root can craft a launch without a valid credential\n\t * (\"srun --no-alloc ...\") and no tree information can be built\n\t *  without the hostlist from the credential. */\n\tif (step_complete.rank >= 0) {\n#if 0\n\t\tchar bits_string[128];\n\t\tdebug2(\"Setting range %d (bit %d) through %d(bit %d)\",\n\t\t       first, first-(step_complete.rank+1),\n\t\t       last, last-(step_complete.rank+1));\n\t\tbit_fmt(bits_string, sizeof(bits_string), step_complete.bits);\n\t\tdebug2(\"  before bits: %s\", bits_string);\n#endif\n\t\tbit_nset(step_complete.bits,\n\t\t\t first - (step_complete.rank+1),\n\t\t\t last - (step_complete.rank+1));\n#if 0\n\t\tbit_fmt(bits_string, sizeof(bits_string), step_complete.bits);\n\t\tdebug2(\"  after bits: %s\", bits_string);\n#endif\n\t}\n\tstep_complete.step_rc = MAX(step_complete.step_rc, step_rc);\n\n\t/************* acct stuff ********************/\n\tjobacctinfo_aggregate(step_complete.jobacct, jobacct);\ntimeout:\n\tjobacctinfo_destroy(jobacct);\n\t/*********************************************/\n\n\t/* Send the return code and errno, we do this within the locked\n\t * region to ensure that the stepd doesn't exit before we can\n\t * perform this send. */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\tpthread_cond_signal(&step_complete.cond);\n\tslurm_mutex_unlock(&step_complete.lock);\n\n\treturn SLURM_SUCCESS;\n\n\nrwfail:\tif (lock_set) {\n\t\tpthread_cond_signal(&step_complete.cond);\n\t\tslurm_mutex_unlock(&step_complete.lock);\n\t}\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_completion(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tint first;\n\tint last;\n\tjobacctinfo_t *jobacct = NULL;\n\tint step_rc;\n\tchar* buf;\n\tint len;\n\tBuf buffer;\n\tbool lock_set = false;\n\n\tdebug(\"_handle_completion for job %u.%u\",\n\t      job->jobid, job->stepid);\n\n\tdebug3(\"  uid = %d\", uid);\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"step completion message from uid %ld for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\t/* Send the return code and errno */\n\t\tsafe_write(fd, &rc, sizeof(int));\n\t\tsafe_write(fd, &errnum, sizeof(int));\n\t\treturn SLURM_SUCCESS;\n\t}\n\n\tsafe_read(fd, &first, sizeof(int));\n\tsafe_read(fd, &last, sizeof(int));\n\tsafe_read(fd, &step_rc, sizeof(int));\n\n\t/*\n\t * We must not use getinfo over a pipe with slurmd here\n\t * Indeed, slurmstepd does a large use of setinfo over a pipe\n\t * with slurmd and doing the reverse can result in a deadlock\n\t * scenario with slurmd :\n\t * slurmd(lockforread,write)/slurmstepd(write,lockforread)\n\t * Do pack/unpack instead to be sure of independances of\n\t * slurmd and slurmstepd\n\t */\n\tsafe_read(fd, &len, sizeof(int));\n\tbuf = xmalloc(len);\n\tsafe_read(fd, buf, len);\n\tbuffer = create_buf(buf, len);\n\tjobacctinfo_unpack(&jobacct, SLURM_PROTOCOL_VERSION,\n\t\t\t   PROTOCOL_TYPE_SLURM, buffer, 1);\n\tfree_buf(buffer);\n\n\t/*\n\t * Record the completed nodes\n\t */\n\tslurm_mutex_lock(&step_complete.lock);\n\tlock_set = true;\n\tif (! step_complete.wait_children) {\n\t\trc = -1;\n\t\terrnum = ETIMEDOUT; /* not used anyway */\n\t\tgoto timeout;\n\t}\n\n\t/* SlurmUser or root can craft a launch without a valid credential\n\t * (\"srun --no-alloc ...\") and no tree information can be built\n\t *  without the hostlist from the credential. */\n\tif (step_complete.rank >= 0) {\n#if 0\n\t\tchar bits_string[128];\n\t\tdebug2(\"Setting range %d (bit %d) through %d(bit %d)\",\n\t\t       first, first-(step_complete.rank+1),\n\t\t       last, last-(step_complete.rank+1));\n\t\tbit_fmt(bits_string, sizeof(bits_string), step_complete.bits);\n\t\tdebug2(\"  before bits: %s\", bits_string);\n#endif\n\t\tbit_nset(step_complete.bits,\n\t\t\t first - (step_complete.rank+1),\n\t\t\t last - (step_complete.rank+1));\n#if 0\n\t\tbit_fmt(bits_string, sizeof(bits_string), step_complete.bits);\n\t\tdebug2(\"  after bits: %s\", bits_string);\n#endif\n\t}\n\tstep_complete.step_rc = MAX(step_complete.step_rc, step_rc);\n\n\t/************* acct stuff ********************/\n\tjobacctinfo_aggregate(step_complete.jobacct, jobacct);\ntimeout:\n\tjobacctinfo_destroy(jobacct);\n\t/*********************************************/\n\n\t/* Send the return code and errno, we do this within the locked\n\t * region to ensure that the stepd doesn't exit before we can\n\t * perform this send. */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\tpthread_cond_signal(&step_complete.cond);\n\tslurm_mutex_unlock(&step_complete.lock);\n\n\treturn SLURM_SUCCESS;\n\n\nrwfail:\tif (lock_set) {\n\t\tpthread_cond_signal(&step_complete.cond);\n\t\tslurm_mutex_unlock(&step_complete.lock);\n\t}\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_terminate",
          "args": [
            "fd",
            "job",
            "uid"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_terminate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1035-1115",
          "snippet": "static int\n_handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tstepd_step_task_info_t *task;\n\tuint32_t i;\n\n\tdebug(\"_handle_terminate for step=%u.%u uid=%d\",\n\t      job->jobid, job->stepid, uid);\n\tstep_terminate_monitor_start(job->jobid, job->stepid);\n\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"terminate req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\t/* cycle thru the tasks and mark those that have not\n\t * called abort and/or terminated as killed_by_cmd\n\t */\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tif (NULL == (task = job->task[i])) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (task->aborted || task->exited) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* mark that this task is going to be killed by\n\t\t * cmd so we ignore its exit status - otherwise,\n\t\t * we will probably report the final exit status\n\t\t * as SIGKILL\n\t\t */\n\t\ttask->killed_by_cmd = true;\n\t}\n\n\t/*\n\t * Signal the container with SIGKILL\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\tdebug(\"Terminating suspended job step %u.%u\",\n\t\t      job->jobid, job->stepid);\n\t\tsuspended = false;\n\t}\n\n\tif (proctrack_g_signal(job->cont_id, SIGKILL) < 0) {\n\t\tif (errno != ESRCH) {\t/* No error if process already gone */\n\t\t\trc = -1;\n\t\t\terrnum = errno;\n\t\t}\n\t\tverbose(\"Error sending SIGKILL signal to %u.%u: %m\",\n\t\t\tjob->jobid, job->stepid);\n\t} else {\n\t\tverbose(\"Sent SIGKILL signal to %u.%u\",\n\t\t\tjob->jobid, job->stepid);\n\t}\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errnum */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;",
            "static bool suspended = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool suspended = false;\n\nstatic int\n_handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tstepd_step_task_info_t *task;\n\tuint32_t i;\n\n\tdebug(\"_handle_terminate for step=%u.%u uid=%d\",\n\t      job->jobid, job->stepid, uid);\n\tstep_terminate_monitor_start(job->jobid, job->stepid);\n\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"terminate req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\t/* cycle thru the tasks and mark those that have not\n\t * called abort and/or terminated as killed_by_cmd\n\t */\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tif (NULL == (task = job->task[i])) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (task->aborted || task->exited) {\n\t\t\tcontinue;\n\t\t}\n\t\t/* mark that this task is going to be killed by\n\t\t * cmd so we ignore its exit status - otherwise,\n\t\t * we will probably report the final exit status\n\t\t * as SIGKILL\n\t\t */\n\t\ttask->killed_by_cmd = true;\n\t}\n\n\t/*\n\t * Signal the container with SIGKILL\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\tdebug(\"Terminating suspended job step %u.%u\",\n\t\t      job->jobid, job->stepid);\n\t\tsuspended = false;\n\t}\n\n\tif (proctrack_g_signal(job->cont_id, SIGKILL) < 0) {\n\t\tif (errno != ESRCH) {\t/* No error if process already gone */\n\t\t\trc = -1;\n\t\t\terrnum = errno;\n\t\t}\n\t\tverbose(\"Error sending SIGKILL signal to %u.%u: %m\",\n\t\t\tjob->jobid, job->stepid);\n\t} else {\n\t\tverbose(\"Sent SIGKILL signal to %u.%u\",\n\t\t\tjob->jobid, job->stepid);\n\t}\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errnum */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_resume",
          "args": [
            "fd",
            "job",
            "uid"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_resume",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1503-1572",
          "snippet": "static int\n_handle_resume(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tuint16_t job_core_spec = (uint16_t) NO_VAL;\n\n\tsafe_read(fd, &job_core_spec, sizeof(uint16_t));\n\n\tdebug(\"_handle_resume for step:%u.%u uid:%ld core_spec:%u\",\n\t      job->jobid, job->stepid, (long)uid, job_core_spec);\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"job step resume request from uid %ld for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tacct_gather_resume_poll();\n\t/*\n\t * Signal the container\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (!suspended) {\n\t\trc = -1;\n\t\terrnum = ESLURMD_STEP_NOTSUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t} else {\n\t\tif (!job->batch && switch_g_job_step_pre_resume(job))\n\t\t\terror(\"switch_g_job_step_pre_resume: %m\");\n\t\tif (!job->batch && core_spec_g_resume(job->cont_id,\n\t\t\t\t\t\t      job_core_spec))\n\t\t\terror(\"core_spec_g_resume: %m\");\n\t\tif (proctrack_g_signal(job->cont_id, SIGCONT) < 0) {\n\t\t\tverbose(\"Error resuming %u.%u: %m\",\n\t\t\t\tjob->jobid, job->stepid);\n\t\t} else {\n\t\t\tverbose(\"Resumed %u.%u\", job->jobid, job->stepid);\n\t\t}\n\t\tsuspended = false;\n\t}\n\tif (!job->batch && switch_g_job_step_post_resume(job))\n\t\terror(\"switch_g_job_step_post_resume: %m\");\n\t/* set the cpu frequencies if cpu_freq option used */\n\tif (job->cpu_freq_min != NO_VAL || job->cpu_freq_max != NO_VAL ||\n\t    job->cpu_freq_gov != NO_VAL) {\n\t\tcpu_freq_set(job);\n\t}\n\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errno */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;",
            "static bool suspended = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool suspended = false;\n\nstatic int\n_handle_resume(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tuint16_t job_core_spec = (uint16_t) NO_VAL;\n\n\tsafe_read(fd, &job_core_spec, sizeof(uint16_t));\n\n\tdebug(\"_handle_resume for step:%u.%u uid:%ld core_spec:%u\",\n\t      job->jobid, job->stepid, (long)uid, job_core_spec);\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"job step resume request from uid %ld for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tacct_gather_resume_poll();\n\t/*\n\t * Signal the container\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (!suspended) {\n\t\trc = -1;\n\t\terrnum = ESLURMD_STEP_NOTSUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t} else {\n\t\tif (!job->batch && switch_g_job_step_pre_resume(job))\n\t\t\terror(\"switch_g_job_step_pre_resume: %m\");\n\t\tif (!job->batch && core_spec_g_resume(job->cont_id,\n\t\t\t\t\t\t      job_core_spec))\n\t\t\terror(\"core_spec_g_resume: %m\");\n\t\tif (proctrack_g_signal(job->cont_id, SIGCONT) < 0) {\n\t\t\tverbose(\"Error resuming %u.%u: %m\",\n\t\t\t\tjob->jobid, job->stepid);\n\t\t} else {\n\t\t\tverbose(\"Resumed %u.%u\", job->jobid, job->stepid);\n\t\t}\n\t\tsuspended = false;\n\t}\n\tif (!job->batch && switch_g_job_step_post_resume(job))\n\t\terror(\"switch_g_job_step_post_resume: %m\");\n\t/* set the cpu frequencies if cpu_freq option used */\n\tif (job->cpu_freq_min != NO_VAL || job->cpu_freq_max != NO_VAL ||\n\t    job->cpu_freq_gov != NO_VAL) {\n\t\tcpu_freq_set(job);\n\t}\n\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errno */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_suspend",
          "args": [
            "fd",
            "job",
            "uid"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_suspend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1406-1501",
          "snippet": "static int\n_handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tstatic int launch_poe = -1;\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tuint16_t job_core_spec = (uint16_t) NO_VAL;\n\n\tsafe_read(fd, &job_core_spec, sizeof(uint16_t));\n\n\tdebug(\"_handle_suspend for step:%u.%u uid:%ld core_spec:%u\",\n\t      job->jobid, job->stepid, (long)uid, job_core_spec);\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"job step suspend request from uid %ld for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t_wait_for_job_init(job);\n\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tacct_gather_suspend_poll();\n\tif (launch_poe == -1) {\n\t\tchar *launch_type = slurm_get_launch_type();\n\t\tif (!xstrcmp(launch_type, \"launch/poe\"))\n\t\t\tlaunch_poe = 1;\n\t\telse\n\t\t\tlaunch_poe = 0;\n\t\txfree(launch_type);\n\t}\n\n\t/*\n\t * Signal the container\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\trc = -1;\n\t\terrnum = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t} else {\n\t\tif (!job->batch && switch_g_job_step_pre_suspend(job))\n\t\t\terror(\"switch_g_job_step_pre_suspend: %m\");\n\n\t\t/* SIGTSTP is sent first to let MPI daemons stop their tasks,\n\t\t * then wait 2 seconds, then send SIGSTOP to the spawned\n\t\t * process's container to stop everything else.\n\t\t *\n\t\t * In some cases, 1 second has proven insufficient. Longer\n\t\t * delays may help insure that all MPI tasks have been stopped\n\t\t * (that depends upon the MPI implementaiton used), but will\n\t\t * also permit longer time periods when more than one job can\n\t\t * be running on each resource (not good). */\n\t\tif (launch_poe == 0) {\n\t\t\t/* IBM MPI seens to periodically hang upon receipt\n\t\t\t * of SIGTSTP. */\n\t\t\tif (proctrack_g_signal(job->cont_id, SIGTSTP) < 0) {\n\t\t\t\tverbose(\"Error suspending %u.%u (SIGTSTP): %m\",\n\t\t\t\t\tjob->jobid, job->stepid);\n\t\t\t} else\n\t\t\t\tsleep(2);\n\t\t}\n\n\t\tif (proctrack_g_signal(job->cont_id, SIGSTOP) < 0) {\n\t\t\tverbose(\"Error suspending %u.%u (SIGSTOP): %m\",\n\t\t\t\tjob->jobid, job->stepid);\n\t\t} else {\n\t\t\tverbose(\"Suspended %u.%u\", job->jobid, job->stepid);\n\t\t}\n\t\tsuspended = true;\n\t}\n\tif (!job->batch && switch_g_job_step_post_suspend(job))\n\t\terror(\"switch_g_job_step_post_suspend: %m\");\n\tif (!job->batch && core_spec_g_suspend(job->cont_id, job_core_spec))\n\t\terror(\"core_spec_g_suspend: %m\");\n\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errno */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;",
            "static bool suspended = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool suspended = false;\n\nstatic int\n_handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tstatic int launch_poe = -1;\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tuint16_t job_core_spec = (uint16_t) NO_VAL;\n\n\tsafe_read(fd, &job_core_spec, sizeof(uint16_t));\n\n\tdebug(\"_handle_suspend for step:%u.%u uid:%ld core_spec:%u\",\n\t      job->jobid, job->stepid, (long)uid, job_core_spec);\n\n\tif (!_slurm_authorized_user(uid)) {\n\t\tdebug(\"job step suspend request from uid %ld for job %u.%u \",\n\t\t      (long)uid, job->jobid, job->stepid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t_wait_for_job_init(job);\n\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tacct_gather_suspend_poll();\n\tif (launch_poe == -1) {\n\t\tchar *launch_type = slurm_get_launch_type();\n\t\tif (!xstrcmp(launch_type, \"launch/poe\"))\n\t\t\tlaunch_poe = 1;\n\t\telse\n\t\t\tlaunch_poe = 0;\n\t\txfree(launch_type);\n\t}\n\n\t/*\n\t * Signal the container\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\trc = -1;\n\t\terrnum = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t} else {\n\t\tif (!job->batch && switch_g_job_step_pre_suspend(job))\n\t\t\terror(\"switch_g_job_step_pre_suspend: %m\");\n\n\t\t/* SIGTSTP is sent first to let MPI daemons stop their tasks,\n\t\t * then wait 2 seconds, then send SIGSTOP to the spawned\n\t\t * process's container to stop everything else.\n\t\t *\n\t\t * In some cases, 1 second has proven insufficient. Longer\n\t\t * delays may help insure that all MPI tasks have been stopped\n\t\t * (that depends upon the MPI implementaiton used), but will\n\t\t * also permit longer time periods when more than one job can\n\t\t * be running on each resource (not good). */\n\t\tif (launch_poe == 0) {\n\t\t\t/* IBM MPI seens to periodically hang upon receipt\n\t\t\t * of SIGTSTP. */\n\t\t\tif (proctrack_g_signal(job->cont_id, SIGTSTP) < 0) {\n\t\t\t\tverbose(\"Error suspending %u.%u (SIGTSTP): %m\",\n\t\t\t\t\tjob->jobid, job->stepid);\n\t\t\t} else\n\t\t\t\tsleep(2);\n\t\t}\n\n\t\tif (proctrack_g_signal(job->cont_id, SIGSTOP) < 0) {\n\t\t\tverbose(\"Error suspending %u.%u (SIGSTOP): %m\",\n\t\t\t\tjob->jobid, job->stepid);\n\t\t} else {\n\t\t\tverbose(\"Suspended %u.%u\", job->jobid, job->stepid);\n\t\t}\n\t\tsuspended = true;\n\t}\n\tif (!job->batch && switch_g_job_step_post_suspend(job))\n\t\terror(\"switch_g_job_step_post_suspend: %m\");\n\tif (!job->batch && core_spec_g_suspend(job->cont_id, job_core_spec))\n\t\terror(\"core_spec_g_suspend: %m\");\n\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errno */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_daemon_pid",
          "args": [
            "fd",
            "job"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_daemon_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1383-1391",
          "snippet": "static int\n_handle_daemon_pid(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->jmgr_pid, sizeof(pid_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_daemon_pid(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->jmgr_pid, sizeof(pid_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_pid_in_container",
          "args": [
            "fd",
            "job"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_pid_in_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1206-1226",
          "snippet": "static int\n_handle_pid_in_container(int fd, stepd_step_rec_t *job)\n{\n\tbool rc = false;\n\tpid_t pid;\n\n\tdebug(\"_handle_pid_in_container for job %u.%u\",\n\t      job->jobid, job->stepid);\n\n\tsafe_read(fd, &pid, sizeof(pid_t));\n\n\trc = proctrack_g_has_pid(job->cont_id, pid);\n\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(bool));\n\n\tdebug(\"Leaving _handle_pid_in_container\");\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_pid_in_container(int fd, stepd_step_rec_t *job)\n{\n\tbool rc = false;\n\tpid_t pid;\n\n\tdebug(\"_handle_pid_in_container for job %u.%u\",\n\t      job->jobid, job->stepid);\n\n\tsafe_read(fd, &pid, sizeof(pid_t));\n\n\trc = proctrack_g_has_pid(job->cont_id, pid);\n\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(bool));\n\n\tdebug(\"Leaving _handle_pid_in_container\");\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_attach",
          "args": [
            "fd",
            "job",
            "uid"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "1117-1204",
          "snippet": "static int\n_handle_attach(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tsrun_info_t *srun;\n\tint rc = SLURM_SUCCESS;\n\n\tdebug(\"_handle_attach for job %u.%u\", job->jobid, job->stepid);\n\n\tsrun       = xmalloc(sizeof(srun_info_t));\n\tsrun->key  = (srun_key_t *)xmalloc(SLURM_IO_KEY_SIZE);\n\n\tdebug(\"sizeof(srun_info_t) = %d, sizeof(slurm_addr_t) = %d\",\n\t      (int) sizeof(srun_info_t), (int) sizeof(slurm_addr_t));\n\tsafe_read(fd, &srun->ioaddr, sizeof(slurm_addr_t));\n\tsafe_read(fd, &srun->resp_addr, sizeof(slurm_addr_t));\n\tsafe_read(fd, srun->key, SLURM_IO_KEY_SIZE);\n\tsafe_read(fd, &srun->protocol_version, sizeof(int));\n\n\tif (!srun->protocol_version)\n\t\tsrun->protocol_version = (uint16_t)NO_VAL;\n\t/*\n\t * Check if jobstep is actually running.\n\t */\n\tif (job->state != SLURMSTEPD_STEP_RUNNING) {\n\t\trc = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * At the moment, it only makes sense for the slurmd to make this\n\t * call, so only _slurm_authorized_user is allowed.\n\t */\n\tif (!_slurm_authorized_user(uid)) {\n\t\terror(\"uid %ld attempt to attach to job %u.%u owned by %ld\",\n\t\t      (long) uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\n\tlist_prepend(job->sruns, (void *) srun);\n\trc = io_client_connect(srun, job);\n\tdebug(\"  back from io_client_connect, rc = %d\", rc);\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\n\tdebug(\"  in _handle_attach rc = %d\", rc);\n\tif (rc == SLURM_SUCCESS) {\n\t\t/* Send response info */\n\t\tuint32_t *pids, *gtids;\n\t\tint len, i;\n\n\t\tdebug(\"  in _handle_attach sending response info\");\n\t\tlen = job->node_tasks * sizeof(uint32_t);\n\t\tpids = xmalloc(len);\n\t\tgtids = xmalloc(len);\n\n\t\tif (job->task != NULL) {\n\t\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\t\tif (job->task[i] == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tpids[i] = (uint32_t)job->task[i]->pid;\n\t\t\t\tgtids[i] = job->task[i]->gtid;\n\t\t\t}\n\t\t}\n\n\t\tsafe_write(fd, &job->node_tasks, sizeof(uint32_t));\n\t\tsafe_write(fd, pids, len);\n\t\tsafe_write(fd, gtids, len);\n\t\txfree(pids);\n\t\txfree(gtids);\n\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i] && job->task[i]->argv) {\n\t\t\t\tlen = strlen(job->task[i]->argv[0]) + 1;\n\t\t\t\tsafe_write(fd, &len, sizeof(int));\n\t\t\t\tsafe_write(fd, job->task[i]->argv[0], len);\n\t\t\t} else {\n\t\t\t\tlen = 0;\n\t\t\t\tsafe_write(fd, &len, sizeof(int));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_attach(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tsrun_info_t *srun;\n\tint rc = SLURM_SUCCESS;\n\n\tdebug(\"_handle_attach for job %u.%u\", job->jobid, job->stepid);\n\n\tsrun       = xmalloc(sizeof(srun_info_t));\n\tsrun->key  = (srun_key_t *)xmalloc(SLURM_IO_KEY_SIZE);\n\n\tdebug(\"sizeof(srun_info_t) = %d, sizeof(slurm_addr_t) = %d\",\n\t      (int) sizeof(srun_info_t), (int) sizeof(slurm_addr_t));\n\tsafe_read(fd, &srun->ioaddr, sizeof(slurm_addr_t));\n\tsafe_read(fd, &srun->resp_addr, sizeof(slurm_addr_t));\n\tsafe_read(fd, srun->key, SLURM_IO_KEY_SIZE);\n\tsafe_read(fd, &srun->protocol_version, sizeof(int));\n\n\tif (!srun->protocol_version)\n\t\tsrun->protocol_version = (uint16_t)NO_VAL;\n\t/*\n\t * Check if jobstep is actually running.\n\t */\n\tif (job->state != SLURMSTEPD_STEP_RUNNING) {\n\t\trc = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * At the moment, it only makes sense for the slurmd to make this\n\t * call, so only _slurm_authorized_user is allowed.\n\t */\n\tif (!_slurm_authorized_user(uid)) {\n\t\terror(\"uid %ld attempt to attach to job %u.%u owned by %ld\",\n\t\t      (long) uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\n\tlist_prepend(job->sruns, (void *) srun);\n\trc = io_client_connect(srun, job);\n\tdebug(\"  back from io_client_connect, rc = %d\", rc);\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\n\tdebug(\"  in _handle_attach rc = %d\", rc);\n\tif (rc == SLURM_SUCCESS) {\n\t\t/* Send response info */\n\t\tuint32_t *pids, *gtids;\n\t\tint len, i;\n\n\t\tdebug(\"  in _handle_attach sending response info\");\n\t\tlen = job->node_tasks * sizeof(uint32_t);\n\t\tpids = xmalloc(len);\n\t\tgtids = xmalloc(len);\n\n\t\tif (job->task != NULL) {\n\t\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\t\tif (job->task[i] == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tpids[i] = (uint32_t)job->task[i]->pid;\n\t\t\t\tgtids[i] = job->task[i]->gtid;\n\t\t\t}\n\t\t}\n\n\t\tsafe_write(fd, &job->node_tasks, sizeof(uint32_t));\n\t\tsafe_write(fd, pids, len);\n\t\tsafe_write(fd, gtids, len);\n\t\txfree(pids);\n\t\txfree(gtids);\n\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i] && job->task[i]->argv) {\n\t\t\t\tlen = strlen(job->task[i]->argv[0]) + 1;\n\t\t\t\tsafe_write(fd, &len, sizeof(int));\n\t\t\t\tsafe_write(fd, job->task[i]->argv[0], len);\n\t\t\t} else {\n\t\t\t\tlen = 0;\n\t\t\t\tsafe_write(fd, &len, sizeof(int));\n\t\t\t}\n\t\t}\n\t}\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_nodeid",
          "args": [
            "fd",
            "job"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_nodeid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "652-660",
          "snippet": "static int\n_handle_nodeid(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->nodeid, sizeof(uid_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_nodeid(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->nodeid, sizeof(uid_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_uid",
          "args": [
            "fd",
            "job"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "642-650",
          "snippet": "static int\n_handle_uid(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->uid, sizeof(uid_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_uid(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->uid, sizeof(uid_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_mem_limits",
          "args": [
            "fd",
            "job"
          ],
          "line": 524
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_mem_limits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "631-640",
          "snippet": "static int\n_handle_mem_limits(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->job_mem, sizeof(uint32_t));\n\tsafe_write(fd, &job->step_mem, sizeof(uint32_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_mem_limits(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->job_mem, sizeof(uint32_t));\n\tsafe_write(fd, &job->step_mem, sizeof(uint32_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_info",
          "args": [
            "fd",
            "job"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "607-629",
          "snippet": "static int\n_handle_info(int fd, stepd_step_rec_t *job)\n{\n\tuint16_t protocol_version = SLURM_PROTOCOL_VERSION;\n\n\tsafe_write(fd, &job->uid, sizeof(uid_t));\n\tsafe_write(fd, &job->jobid, sizeof(uint32_t));\n\tsafe_write(fd, &job->stepid, sizeof(uint32_t));\n\n\t/* protocol_version was added in SLURM version 2.2,\n\t * so it needed to be added later in the data sent\n\t * for backward compatibility (so that it doesn't\n\t * get confused for a huge UID, job ID or step ID;\n\t * we should be save in avoiding huge node IDs). */\n\tsafe_write(fd, &protocol_version, sizeof(uint16_t));\n\tsafe_write(fd, &job->nodeid, sizeof(uint32_t));\n\tsafe_write(fd, &job->job_mem, sizeof(uint32_t));\n\tsafe_write(fd, &job->step_mem, sizeof(uint32_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic int\n_handle_info(int fd, stepd_step_rec_t *job)\n{\n\tuint16_t protocol_version = SLURM_PROTOCOL_VERSION;\n\n\tsafe_write(fd, &job->uid, sizeof(uid_t));\n\tsafe_write(fd, &job->jobid, sizeof(uint32_t));\n\tsafe_write(fd, &job->stepid, sizeof(uint32_t));\n\n\t/* protocol_version was added in SLURM version 2.2,\n\t * so it needed to be added later in the data sent\n\t * for backward compatibility (so that it doesn't\n\t * get confused for a huge UID, job ID or step ID;\n\t * we should be save in avoiding huge node IDs). */\n\tsafe_write(fd, &protocol_version, sizeof(uint16_t));\n\tsafe_write(fd, &job->nodeid, sizeof(uint32_t));\n\tsafe_write(fd, &job->job_mem, sizeof(uint32_t));\n\tsafe_write(fd, &job->step_mem, sizeof(uint32_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_state",
          "args": [
            "fd",
            "job"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "597-605",
          "snippet": "static int\n_handle_state(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->state, sizeof(slurmstepd_state_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_state(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->state, sizeof(slurmstepd_state_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_checkpoint_tasks",
          "args": [
            "fd",
            "job",
            "uid"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_checkpoint_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "916-997",
          "snippet": "static int\n_handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\ttime_t timestamp;\n\tint len;\n\tchar *image_dir = NULL;\n\n\tdebug3(\"_handle_checkpoint_tasks for job %u.%u\",\n\t       job->jobid, job->stepid);\n\n\tsafe_read(fd, &timestamp, sizeof(time_t));\n\tsafe_read(fd, &len, sizeof(int));\n\tif (len) {\n\t\timage_dir = xmalloc (len);\n\t\tsafe_read(fd, image_dir, len); /* '\\0' terminated */\n\t}\n\n\tdebug3(\"  uid = %d\", uid);\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"checkpoint req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\n\tif (job->ckpt_timestamp &&\n\t    timestamp == job->ckpt_timestamp) {\n\t\tdebug(\"duplicate checkpoint req for job %u.%u, \"\n\t\t      \"timestamp %ld. discarded.\",\n\t\t      job->jobid, job->stepid, (long)timestamp);\n\t\trc = ESLURM_ALREADY_DONE; /* EINPROGRESS? */\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (job->pgid <= (pid_t)1) {\n\t\tdebug (\"step %u.%u invalid [jmgr_pid:%d pgid:%u]\",\n\t\t       job->jobid, job->stepid, job->jmgr_pid, job->pgid);\n\t\trc = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\trc = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\t/* set timestamp in case another request comes */\n\tjob->ckpt_timestamp = timestamp;\n\n\t/* TODO: do we need job->ckpt_dir any more,\n\t *\texcept for checkpoint/xlch? */\n/*\tif (! image_dir) { */\n/*\t\timage_dir = xstrdup(job->ckpt_dir); */\n/*\t} */\n\n\t/* call the plugin to send the request */\n\tif (checkpoint_signal_tasks(job, image_dir) != SLURM_SUCCESS) {\n\t\trc = -1;\n\t\tverbose(\"Error sending checkpoint request to %u.%u: %s\",\n\t\t\tjob->jobid, job->stepid, slurm_strerror(rc));\n\t} else {\n\t\tverbose(\"Sent checkpoint request to %u.%u\",\n\t\t\tjob->jobid, job->stepid);\n\t}\n\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\txfree(image_dir);\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;",
            "static bool suspended = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool suspended = false;\n\nstatic int\n_handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\ttime_t timestamp;\n\tint len;\n\tchar *image_dir = NULL;\n\n\tdebug3(\"_handle_checkpoint_tasks for job %u.%u\",\n\t       job->jobid, job->stepid);\n\n\tsafe_read(fd, &timestamp, sizeof(time_t));\n\tsafe_read(fd, &len, sizeof(int));\n\tif (len) {\n\t\timage_dir = xmalloc (len);\n\t\tsafe_read(fd, image_dir, len); /* '\\0' terminated */\n\t}\n\n\tdebug3(\"  uid = %d\", uid);\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"checkpoint req from uid %ld for job %u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\n\tif (job->ckpt_timestamp &&\n\t    timestamp == job->ckpt_timestamp) {\n\t\tdebug(\"duplicate checkpoint req for job %u.%u, \"\n\t\t      \"timestamp %ld. discarded.\",\n\t\t      job->jobid, job->stepid, (long)timestamp);\n\t\trc = ESLURM_ALREADY_DONE; /* EINPROGRESS? */\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (job->pgid <= (pid_t)1) {\n\t\tdebug (\"step %u.%u invalid [jmgr_pid:%d pgid:%u]\",\n\t\t       job->jobid, job->stepid, job->jmgr_pid, job->pgid);\n\t\trc = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\trc = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\t/* set timestamp in case another request comes */\n\tjob->ckpt_timestamp = timestamp;\n\n\t/* TODO: do we need job->ckpt_dir any more,\n\t *\texcept for checkpoint/xlch? */\n/*\tif (! image_dir) { */\n/*\t\timage_dir = xstrdup(job->ckpt_dir); */\n/*\t} */\n\n\t/* call the plugin to send the request */\n\tif (checkpoint_signal_tasks(job, image_dir) != SLURM_SUCCESS) {\n\t\trc = -1;\n\t\tverbose(\"Error sending checkpoint request to %u.%u: %s\",\n\t\t\tjob->jobid, job->stepid, slurm_strerror(rc));\n\t} else {\n\t\tverbose(\"Sent checkpoint request to %u.%u\",\n\t\t\tjob->jobid, job->stepid);\n\t}\n\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\txfree(image_dir);\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_signal_container",
          "args": [
            "fd",
            "job",
            "uid"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_signal_container",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "735-914",
          "snippet": "static int\n_handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tint sig;\n\tstatic int msg_sent = 0;\n\tchar *ptr = NULL;\n\tint target_node_id = 0;\n\tstepd_step_task_info_t *task;\n\tuint32_t i;\n\tuint32_t flag;\n\tuint32_t signal;\n\n\tsafe_read(fd, &signal, sizeof(int));\n\tflag = signal >> 24;\n\tsig = signal & 0xfff;\n\n\tdebug(\"_handle_signal_container for step=%u.%u uid=%d signal=%d\",\n\t      job->jobid, job->stepid, (int) uid, sig);\n\tif ((uid != job->uid) && !_slurm_authorized_user(uid)) {\n\t\terror(\"signal container req from uid %ld for step=%u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tif ((sig == SIGTERM) || (sig == SIGKILL)) {\n\t\t/* cycle thru the tasks and mark those that have not\n\t\t * called abort and/or terminated as killed_by_cmd\n\t\t */\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (NULL == (task = job->task[i])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task->aborted || task->exited) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* mark that this task is going to be killed by\n\t\t\t * cmd so we ignore its exit status - otherwise,\n\t\t\t * we will probably report the final exit status\n\t\t\t * as SIGKILL\n\t\t\t */\n\t\t\ttask->killed_by_cmd = true;\n\t\t}\n\t}\n\n\tptr = getenvp(job->env, \"SLURM_STEP_KILLED_MSG_NODE_ID\");\n\tif (ptr)\n\t\ttarget_node_id = atoi(ptr);\n\tif ((job->stepid != SLURM_EXTERN_CONT) &&\n\t    (job->nodeid == target_node_id) && (msg_sent == 0) &&\n\t    (job->state < SLURMSTEPD_STEP_ENDING)) {\n\t\ttime_t now = time(NULL);\n\t\tchar entity[24], time_str[24];\n\n\t\tif (job->stepid == SLURM_BATCH_SCRIPT) {\n\t\t\tsnprintf(entity, sizeof(entity), \"JOB %u\", job->jobid);\n\t\t} else {\n\t\t\tsnprintf(entity, sizeof(entity), \"STEP %u.%u\",\n\t\t\t\t job->jobid, job->stepid);\n\t\t}\n\t\tslurm_make_time_str(&now, time_str, sizeof(time_str));\n\n\t\t/* Not really errors,\n\t\t * but we want messages displayed by default */\n\t\tif (sig == SIG_TIME_LIMIT) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO TIME LIMIT ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_PREEMPTED) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO PREEMPTION ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_NODE_FAIL) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO NODE \"\n\t\t\t      \"FAILURE, SEE SLURMCTLD LOG FOR DETAILS ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_REQUEUED) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO JOB REQUEUE ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_FAILURE) {\n\t\t\terror(\"*** %s ON %s FAILED (non-zero exit code or other \"\n\t\t\t      \"failure mode) ***\",\n\t\t\t      entity, job->node_name);\n\t\t\tmsg_sent = 1;\n\t\t} else if ((sig == SIGTERM) || (sig == SIGKILL)) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t}\n\t}\n\tif ((sig == SIG_TIME_LIMIT) || (sig == SIG_NODE_FAIL) ||\n\t    (sig == SIG_PREEMPTED)  || (sig == SIG_FAILURE) ||\n\t    (sig == SIG_REQUEUED))\n\t\tgoto done;\n\n\tif (sig == SIG_ABORT) {\n\t\tsig = SIGKILL;\n\t\tjob->aborted = true;\n\t}\n\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended && (sig != SIGKILL)) {\n\t\trc = -1;\n\t\terrnum = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\tif (sig == SIG_DEBUG_WAKE) {\n\t\tint i;\n\t\tfor (i = 0; i < job->node_tasks; i++)\n\t\t\tpdebug_wake_process(job, job->task[i]->pid);\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\tif (flag & KILL_JOB_BATCH\n\t    && job->stepid == SLURM_BATCH_SCRIPT) {\n\t\t/* We should only signal the batch script\n\t\t * and nothing else, the job pgid is the\n\t\t * equal to the pid of the batch script.\n\t\t */\n\t\tif (kill(job->pgid, sig) < 0) {\n\t\t\terror(\"%s: failed signal %d container pid\"\n\t\t\t      \"%u job %u.%u %m\",\n\t\t\t      __func__, sig, job->pgid,\n\t\t\t      job->jobid, job->stepid);\n\t\t\trc = SLURM_ERROR;\n\t\t\terrnum = errno;\n\t\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\t\tgoto done;\n\t\t}\n\t\trc = SLURM_SUCCESS;\n\t\terrnum = 0;\n\t\tverbose(\"%s: sent signal %d to container pid %u job %u.%u\",\n\t\t\t__func__, sig, job->pgid,\n\t\t\tjob->jobid, job->stepid);\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Signal the container\n\t */\n\tif (proctrack_g_signal(job->cont_id, sig) < 0) {\n\t\trc = -1;\n\t\terrnum = errno;\n\t\tverbose(\"Error sending signal %d to %u.%u: %m\",\n\t\t\tsig, job->jobid, job->stepid);\n\t} else {\n\t\tverbose(\"Sent signal %d to %u.%u\",\n\t\t\tsig, job->jobid, job->stepid);\n\t}\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errnum */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;",
            "static bool suspended = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool suspended = false;\n\nstatic int\n_handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint errnum = 0;\n\tint sig;\n\tstatic int msg_sent = 0;\n\tchar *ptr = NULL;\n\tint target_node_id = 0;\n\tstepd_step_task_info_t *task;\n\tuint32_t i;\n\tuint32_t flag;\n\tuint32_t signal;\n\n\tsafe_read(fd, &signal, sizeof(int));\n\tflag = signal >> 24;\n\tsig = signal & 0xfff;\n\n\tdebug(\"_handle_signal_container for step=%u.%u uid=%d signal=%d\",\n\t      job->jobid, job->stepid, (int) uid, sig);\n\tif ((uid != job->uid) && !_slurm_authorized_user(uid)) {\n\t\terror(\"signal container req from uid %ld for step=%u.%u \"\n\t\t      \"owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = -1;\n\t\terrnum = EPERM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (job->cont_id == 0) {\n\t\tdebug (\"step %u.%u invalid container [cont_id:%\"PRIu64\"]\",\n\t\t\tjob->jobid, job->stepid, job->cont_id);\n\t\trc = -1;\n\t\terrnum = ESLURMD_JOB_NOTRUNNING;\n\t\tgoto done;\n\t}\n\n\tif ((sig == SIGTERM) || (sig == SIGKILL)) {\n\t\t/* cycle thru the tasks and mark those that have not\n\t\t * called abort and/or terminated as killed_by_cmd\n\t\t */\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (NULL == (task = job->task[i])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (task->aborted || task->exited) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* mark that this task is going to be killed by\n\t\t\t * cmd so we ignore its exit status - otherwise,\n\t\t\t * we will probably report the final exit status\n\t\t\t * as SIGKILL\n\t\t\t */\n\t\t\ttask->killed_by_cmd = true;\n\t\t}\n\t}\n\n\tptr = getenvp(job->env, \"SLURM_STEP_KILLED_MSG_NODE_ID\");\n\tif (ptr)\n\t\ttarget_node_id = atoi(ptr);\n\tif ((job->stepid != SLURM_EXTERN_CONT) &&\n\t    (job->nodeid == target_node_id) && (msg_sent == 0) &&\n\t    (job->state < SLURMSTEPD_STEP_ENDING)) {\n\t\ttime_t now = time(NULL);\n\t\tchar entity[24], time_str[24];\n\n\t\tif (job->stepid == SLURM_BATCH_SCRIPT) {\n\t\t\tsnprintf(entity, sizeof(entity), \"JOB %u\", job->jobid);\n\t\t} else {\n\t\t\tsnprintf(entity, sizeof(entity), \"STEP %u.%u\",\n\t\t\t\t job->jobid, job->stepid);\n\t\t}\n\t\tslurm_make_time_str(&now, time_str, sizeof(time_str));\n\n\t\t/* Not really errors,\n\t\t * but we want messages displayed by default */\n\t\tif (sig == SIG_TIME_LIMIT) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO TIME LIMIT ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_PREEMPTED) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO PREEMPTION ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_NODE_FAIL) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO NODE \"\n\t\t\t      \"FAILURE, SEE SLURMCTLD LOG FOR DETAILS ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_REQUEUED) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s DUE TO JOB REQUEUE ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t} else if (sig == SIG_FAILURE) {\n\t\t\terror(\"*** %s ON %s FAILED (non-zero exit code or other \"\n\t\t\t      \"failure mode) ***\",\n\t\t\t      entity, job->node_name);\n\t\t\tmsg_sent = 1;\n\t\t} else if ((sig == SIGTERM) || (sig == SIGKILL)) {\n\t\t\terror(\"*** %s ON %s CANCELLED AT %s ***\",\n\t\t\t      entity, job->node_name, time_str);\n\t\t\tmsg_sent = 1;\n\t\t}\n\t}\n\tif ((sig == SIG_TIME_LIMIT) || (sig == SIG_NODE_FAIL) ||\n\t    (sig == SIG_PREEMPTED)  || (sig == SIG_FAILURE) ||\n\t    (sig == SIG_REQUEUED))\n\t\tgoto done;\n\n\tif (sig == SIG_ABORT) {\n\t\tsig = SIGKILL;\n\t\tjob->aborted = true;\n\t}\n\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended && (sig != SIGKILL)) {\n\t\trc = -1;\n\t\terrnum = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\tif (sig == SIG_DEBUG_WAKE) {\n\t\tint i;\n\t\tfor (i = 0; i < job->node_tasks; i++)\n\t\t\tpdebug_wake_process(job, job->task[i]->pid);\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\tif (flag & KILL_JOB_BATCH\n\t    && job->stepid == SLURM_BATCH_SCRIPT) {\n\t\t/* We should only signal the batch script\n\t\t * and nothing else, the job pgid is the\n\t\t * equal to the pid of the batch script.\n\t\t */\n\t\tif (kill(job->pgid, sig) < 0) {\n\t\t\terror(\"%s: failed signal %d container pid\"\n\t\t\t      \"%u job %u.%u %m\",\n\t\t\t      __func__, sig, job->pgid,\n\t\t\t      job->jobid, job->stepid);\n\t\t\trc = SLURM_ERROR;\n\t\t\terrnum = errno;\n\t\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\t\tgoto done;\n\t\t}\n\t\trc = SLURM_SUCCESS;\n\t\terrnum = 0;\n\t\tverbose(\"%s: sent signal %d to container pid %u job %u.%u\",\n\t\t\t__func__, sig, job->pgid,\n\t\t\tjob->jobid, job->stepid);\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Signal the container\n\t */\n\tif (proctrack_g_signal(job->cont_id, sig) < 0) {\n\t\trc = -1;\n\t\terrnum = errno;\n\t\tverbose(\"Error sending signal %d to %u.%u: %m\",\n\t\t\tsig, job->jobid, job->stepid);\n\t} else {\n\t\tverbose(\"Sent signal %d to %u.%u\",\n\t\t\tsig, job->jobid, job->stepid);\n\t}\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code and errnum */\n\tsafe_write(fd, &rc, sizeof(int));\n\tsafe_write(fd, &errnum, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_signal_task_local",
          "args": [
            "fd",
            "job",
            "uid"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_signal_task_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "662-733",
          "snippet": "static int\n_handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint signal;\n\tint ltaskid; /* local task index */\n\n\tsafe_read(fd, &signal, sizeof(int));\n\tsafe_read(fd, &ltaskid, sizeof(int));\n\tdebug(\"_handle_signal_task_local for step=%u.%u uid=%d signal=%d\",\n\t      job->jobid, job->stepid, (int) uid, signal);\n\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"kill req from uid %ld for job %u.%u owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (ltaskid < 0 || ltaskid >= job->node_tasks) {\n\t\tdebug(\"step %u.%u invalid local task id %d\",\n\t\t      job->jobid, job->stepid, ltaskid);\n\t\trc = SLURM_ERROR;\n\t\tgoto done;\n\t}\n\tif (!job->task\n\t    || !job->task[ltaskid]) {\n\t\tdebug(\"step %u.%u no task info for task id %d\",\n\t\t      job->jobid, job->stepid, ltaskid);\n\t\trc = SLURM_ERROR;\n\t\tgoto done;\n\t}\n\tif (job->task[ltaskid]->pid <= 1) {\n\t\tdebug(\"step %u.%u invalid pid %d for task %d\",\n\t\t      job->jobid, job->stepid,\n\t\t      job->task[ltaskid]->pid, ltaskid);\n\t\trc = SLURM_ERROR;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Signal the task\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\trc = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\tif (kill(job->task[ltaskid]->pid, signal) == -1) {\n\t\trc = -1;\n\t\tverbose(\"Error sending signal %d to %u.%u, pid %d: %m\",\n\t\t\tsignal, job->jobid, job->stepid,\n\t\t\tjob->task[ltaskid]->pid);\n\t} else {\n\t\tverbose(\"Sent signal %d to %u.%u, pid %d\",\n\t\t\tsignal, job->jobid, job->stepid,\n\t\t\tjob->task[ltaskid]->pid);\n\t}\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;",
            "static bool suspended = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t suspend_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic bool suspended = false;\n\nstatic int\n_handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid)\n{\n\tint rc = SLURM_SUCCESS;\n\tint signal;\n\tint ltaskid; /* local task index */\n\n\tsafe_read(fd, &signal, sizeof(int));\n\tsafe_read(fd, &ltaskid, sizeof(int));\n\tdebug(\"_handle_signal_task_local for step=%u.%u uid=%d signal=%d\",\n\t      job->jobid, job->stepid, (int) uid, signal);\n\n\tif (uid != job->uid && !_slurm_authorized_user(uid)) {\n\t\tdebug(\"kill req from uid %ld for job %u.%u owned by uid %ld\",\n\t\t      (long)uid, job->jobid, job->stepid, (long)job->uid);\n\t\trc = EPERM;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Sanity checks\n\t */\n\tif (ltaskid < 0 || ltaskid >= job->node_tasks) {\n\t\tdebug(\"step %u.%u invalid local task id %d\",\n\t\t      job->jobid, job->stepid, ltaskid);\n\t\trc = SLURM_ERROR;\n\t\tgoto done;\n\t}\n\tif (!job->task\n\t    || !job->task[ltaskid]) {\n\t\tdebug(\"step %u.%u no task info for task id %d\",\n\t\t      job->jobid, job->stepid, ltaskid);\n\t\trc = SLURM_ERROR;\n\t\tgoto done;\n\t}\n\tif (job->task[ltaskid]->pid <= 1) {\n\t\tdebug(\"step %u.%u invalid pid %d for task %d\",\n\t\t      job->jobid, job->stepid,\n\t\t      job->task[ltaskid]->pid, ltaskid);\n\t\trc = SLURM_ERROR;\n\t\tgoto done;\n\t}\n\n\t/*\n\t * Signal the task\n\t */\n\tslurm_mutex_lock(&suspend_mutex);\n\tif (suspended) {\n\t\trc = ESLURMD_STEP_SUSPENDED;\n\t\tslurm_mutex_unlock(&suspend_mutex);\n\t\tgoto done;\n\t}\n\n\tif (kill(job->task[ltaskid]->pid, signal) == -1) {\n\t\trc = -1;\n\t\tverbose(\"Error sending signal %d to %u.%u, pid %d: %m\",\n\t\t\tsignal, job->jobid, job->stepid,\n\t\t\tjob->task[ltaskid]->pid);\n\t} else {\n\t\tverbose(\"Sent signal %d to %u.%u, pid %d\",\n\t\t\tsignal, job->jobid, job->stepid,\n\t\t\tjob->task[ltaskid]->pid);\n\t}\n\tslurm_mutex_unlock(&suspend_mutex);\n\ndone:\n\t/* Send the return code */\n\tsafe_write(fd, &rc, sizeof(int));\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Got request %d\"",
            "req"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Leaving _handle_request on read error: %m\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "&req",
            "sizeof(int)"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "_file_read_content",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcgroup.c",
          "lines": "1149-1197",
          "snippet": "int _file_read_content(char* file_path, char** content, size_t *csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\tsize_t fsize;\n\tchar* buf;\n\n\tfstatus = XCGROUP_ERROR;\n\n\t/* check input pointers */\n\tif (content == NULL || csize == NULL)\n\t\treturn fstatus;\n\n\t/* open file for reading */\n\tfd = open(file_path, O_RDONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for reading : %m\",\n\t\t\t__func__, file_path);\n\t\treturn fstatus;\n\t}\n\n\t/* get file size */\n\tfsize=_file_getsize(fd);\n\tif (fsize == -1) {\n\t\tclose(fd);\n\t\treturn fstatus;\n\t}\n\n\t/* read file contents */\n\tbuf = (char*) xmalloc((fsize+1)*sizeof(char));\n\tbuf[fsize]='\\0';\n\tdo {\n\t\trc = read(fd, buf, fsize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* set output values */\n\tif (rc >= 0) {\n\t\t*content = buf;\n\t\t*csize = rc;\n\t\tfstatus = XCGROUP_SUCCESS;\n\t}\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}",
          "includes": [
            "#include \"xcgroup.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "size_t _file_getsize(int fd);",
            "int _file_read_content(char* file_path, char** content, size_t *csize);",
            "int _file_write_content(char* file_path, char* content, size_t csize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcgroup.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <sys/mount.h>\n#include <dirent.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nsize_t _file_getsize(int fd);\nint _file_read_content(char* file_path, char** content, size_t *csize);\nint _file_write_content(char* file_path, char* content, size_t csize);\n\nint _file_read_content(char* file_path, char** content, size_t *csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\tsize_t fsize;\n\tchar* buf;\n\n\tfstatus = XCGROUP_ERROR;\n\n\t/* check input pointers */\n\tif (content == NULL || csize == NULL)\n\t\treturn fstatus;\n\n\t/* open file for reading */\n\tfd = open(file_path, O_RDONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for reading : %m\",\n\t\t\t__func__, file_path);\n\t\treturn fstatus;\n\t}\n\n\t/* get file size */\n\tfsize=_file_getsize(fd);\n\tif (fsize == -1) {\n\t\tclose(fd);\n\t\treturn fstatus;\n\t}\n\n\t/* read file contents */\n\tbuf = (char*) xmalloc((fsize+1)*sizeof(char));\n\tbuf[fsize]='\\0';\n\tdo {\n\t\trc = read(fd, buf, fsize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* set output values */\n\tif (rc >= 0) {\n\t\t*content = buf;\n\t\t*csize = rc;\n\t\tfstatus = XCGROUP_SUCCESS;\n\t}\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Entering _handle_request\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_request(int fd, stepd_step_rec_t *job, uid_t uid, gid_t gid);\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nint\n_handle_request(int fd, stepd_step_rec_t *job, uid_t uid, gid_t gid)\n{\n\tint rc = 0;\n\tint req;\n\n\tdebug3(\"Entering _handle_request\");\n\tif ((rc = read(fd, &req, sizeof(int))) != sizeof(int)) {\n\t\tif (rc == 0) { /* EOF, normal */\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tdebug3(\"Leaving _handle_request on read error: %m\");\n\t\t\treturn SLURM_FAILURE;\n\t\t}\n\t}\n\tdebug3(\"Got request %d\", req);\n\trc = SLURM_SUCCESS;\n\tswitch (req) {\n\tcase REQUEST_SIGNAL_TASK_LOCAL:\n\t\tdebug(\"Handling REQUEST_SIGNAL_TASK_LOCAL\");\n\t\trc = _handle_signal_task_local(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_SIGNAL_TASK_GLOBAL:\n\t\tdebug(\"Handling REQUEST_SIGNAL_TASK_GLOBAL (not implemented)\");\n\t\tbreak;\n\tcase REQUEST_SIGNAL_PROCESS_GROUP:\t/* Defunct */\n\tcase REQUEST_SIGNAL_CONTAINER:\n\t\tdebug(\"Handling REQUEST_SIGNAL_CONTAINER\");\n\t\trc = _handle_signal_container(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_CHECKPOINT_TASKS:\n\t\tdebug(\"Handling REQUEST_CHECKPOINT_TASKS\");\n\t\trc = _handle_checkpoint_tasks(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STATE:\n\t\tdebug(\"Handling REQUEST_STATE\");\n\t\trc = _handle_state(fd, job);\n\t\tbreak;\n\tcase REQUEST_INFO:\n\t\tdebug(\"Handling REQUEST_INFO\");\n\t\trc = _handle_info(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_MEM_LIMITS:\n\t\tdebug(\"Handling REQUEST_STEP_MEM_LIMITS\");\n\t\trc = _handle_mem_limits(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_UID:\n\t\tdebug(\"Handling REQUEST_STEP_UID\");\n\t\trc = _handle_uid(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_NODEID:\n\t\tdebug(\"Handling REQUEST_STEP_NODEID\");\n\t\trc = _handle_nodeid(fd, job);\n\t\tbreak;\n\tcase REQUEST_ATTACH:\n\t\tdebug(\"Handling REQUEST_ATTACH\");\n\t\trc = _handle_attach(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_PID_IN_CONTAINER:\n\t\tdebug(\"Handling REQUEST_PID_IN_CONTAINER\");\n\t\trc = _handle_pid_in_container(fd, job);\n\t\tbreak;\n\tcase REQUEST_DAEMON_PID:\n\t\tdebug(\"Handling REQUEST_DAEMON_PID\");\n\t\trc = _handle_daemon_pid(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_SUSPEND:\n\t\tdebug(\"Handling REQUEST_STEP_SUSPEND\");\n\t\trc = _handle_suspend(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_RESUME:\n\t\tdebug(\"Handling REQUEST_STEP_RESUME\");\n\t\trc = _handle_resume(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_TERMINATE:\n\t\tdebug(\"Handling REQUEST_STEP_TERMINATE\");\n\t\trc = _handle_terminate(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_COMPLETION_V2:\n\t\tdebug(\"Handling REQUEST_STEP_COMPLETION_V2\");\n\t\trc = _handle_completion(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_TASK_INFO:\n\t\tdebug(\"Handling REQUEST_STEP_TASK_INFO\");\n\t\trc = _handle_task_info(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_STAT:\n\t\tdebug(\"Handling REQUEST_STEP_STAT\");\n\t\trc = _handle_stat_jobacct(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_LIST_PIDS:\n\t\tdebug(\"Handling REQUEST_STEP_LIST_PIDS\");\n\t\trc = _handle_list_pids(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_RECONFIGURE:\n\t\tdebug(\"Handling REQUEST_STEP_RECONFIGURE\");\n\t\trc = _handle_reconfig(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_JOB_NOTIFY:\n\t\tdebug(\"Handling REQUEST_JOB_NOTIFY\");\n\t\trc = _handle_notify_job(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_ADD_EXTERN_PID:\n\t\tdebug(\"Handling REQUEST_ADD_EXTERN_PID\");\n\t\trc = _handle_add_extern_pid(fd, job);\n\t\tbreak;\n\tdefault:\n\t\terror(\"Unrecognized request: %d\", req);\n\t\trc = SLURM_FAILURE;\n\t\tbreak;\n\t}\n\n\tdebug3(\"Leaving  _handle_request: %s\",\n\t       rc ? \"SLURM_FAILURE\" : \"SLURM_SUCCESS\");\n\treturn rc;\n}"
  },
  {
    "function_name": "_handle_accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "394-477",
    "snippet": "static void *\n_handle_accept(void *arg)\n{\n\t/*struct request_params *param = (struct request_params *)arg;*/\n\tint fd = ((struct request_params *)arg)->fd;\n\tstepd_step_rec_t *job = ((struct request_params *)arg)->job;\n\tint req;\n\tint len;\n\tBuf buffer;\n\tvoid *auth_cred;\n\tint rc;\n\tuid_t uid;\n\tgid_t gid;\n\tchar *auth_info;\n\n\tdebug3(\"Entering _handle_accept (new thread)\");\n\txfree(arg);\n\n\tsafe_read(fd, &req, sizeof(int));\n\tif (req != REQUEST_CONNECT) {\n\t\terror(\"First message must be REQUEST_CONNECT\");\n\t\tgoto fail;\n\t}\n\n\tsafe_read(fd, &len, sizeof(int));\n\tbuffer = init_buf(len);\n\tsafe_read(fd, get_buf_data(buffer), len);\n\n\t/* Unpack and verify the auth credential */\n\tauth_cred = g_slurm_auth_unpack(buffer);\n\tif (auth_cred == NULL) {\n\t\terror(\"Unpacking authentication credential: %s\",\n\t\t      g_slurm_auth_errstr(g_slurm_auth_errno(NULL)));\n\t\tfree_buf(buffer);\n\t\tgoto fail;\n\t}\n\tauth_info = slurm_get_auth_info();\n\trc = g_slurm_auth_verify(auth_cred, NULL, 2, auth_info);\n\tif (rc != SLURM_SUCCESS) {\n\t\terror(\"Verifying authentication credential: %s\",\n\t\t      g_slurm_auth_errstr(g_slurm_auth_errno(auth_cred)));\n\t\txfree(auth_info);\n\t\t(void) g_slurm_auth_destroy(auth_cred);\n\t\tfree_buf(buffer);\n\t\tgoto fail;\n\t}\n\n\t/* Get the uid & gid from the credential, then destroy it. */\n\tuid = g_slurm_auth_get_uid(auth_cred, auth_info);\n\tgid = g_slurm_auth_get_gid(auth_cred, auth_info);\n\txfree(auth_info);\n\tdebug3(\"  Identity: uid=%d, gid=%d\", uid, gid);\n\tg_slurm_auth_destroy(auth_cred);\n\tfree_buf(buffer);\n\n\trc = SLURM_PROTOCOL_VERSION;\n\tsafe_write(fd, &rc, sizeof(int));\n\n\twhile (1) {\n\t\trc = _handle_request(fd, job, uid, gid);\n\t\tif (rc != SLURM_SUCCESS)\n\t\t\tbreak;\n\t}\n\n\tif (close(fd) == -1)\n\t\terror(\"Closing accepted fd: %m\");\n\n\tslurm_mutex_lock(&message_lock);\n\tmessage_connections--;\n\tpthread_cond_signal(&message_cond);\n\tslurm_mutex_unlock(&message_lock);\n\n\tdebug3(\"Leaving  _handle_accept\");\n\treturn NULL;\n\nfail:\n\trc = SLURM_FAILURE;\n\tsafe_write(fd, &rc, sizeof(int));\nrwfail:\n\tif (close(fd) == -1)\n\t\terror(\"Closing accepted fd after error: %m\");\n\tdebug(\"Leaving  _handle_accept on an error\");\n\treturn NULL;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *_handle_accept(void *arg);",
      "static int _handle_request(int fd, stepd_step_rec_t *job, uid_t uid, gid_t gid);",
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static pthread_mutex_t message_lock = PTHREAD_MUTEX_INITIALIZER;",
      "static pthread_cond_t message_cond = PTHREAD_COND_INITIALIZER;",
      "static int message_connections;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Leaving  _handle_accept on an error\""
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_stop_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "120-139",
          "snippet": "void\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Closing accepted fd after error: %m\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 473
        },
        "resolved": true,
        "details": {
          "function_name": "_file_bcast_close_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "3635-3640",
          "snippet": "static void _file_bcast_close_file(file_bcast_info_t *key)\n{\n\t_fb_wrlock();\n\tlist_delete_all(file_bcast_list, _bcast_find_in_list, key);\n\t_fb_wrunlock();\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _job_limits_match(void *x, void *key);",
            "static int  _step_limits_match(void *x, void *key);",
            "static int  _file_bcast_register_file(slurm_msg_t *msg,\n\t\t\t\t      file_bcast_info_t *key);",
            "static List file_bcast_list = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic int  _job_limits_match(void *x, void *key);\nstatic int  _step_limits_match(void *x, void *key);\nstatic int  _file_bcast_register_file(slurm_msg_t *msg,\n\t\t\t\t      file_bcast_info_t *key);\nstatic List file_bcast_list = NULL;\n\nstatic void _file_bcast_close_file(file_bcast_info_t *key)\n{\n\t_fb_wrlock();\n\tlist_delete_all(file_bcast_list, _bcast_find_in_list, key);\n\t_fb_wrunlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Leaving  _handle_accept\""
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&message_lock"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_cond_signal",
          "args": [
            "&message_cond"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&message_lock"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Closing accepted fd: %m\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_handle_request",
          "args": [
            "fd",
            "job",
            "uid",
            "gid"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_request",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "480-595",
          "snippet": "int\n_handle_request(int fd, stepd_step_rec_t *job, uid_t uid, gid_t gid)\n{\n\tint rc = 0;\n\tint req;\n\n\tdebug3(\"Entering _handle_request\");\n\tif ((rc = read(fd, &req, sizeof(int))) != sizeof(int)) {\n\t\tif (rc == 0) { /* EOF, normal */\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tdebug3(\"Leaving _handle_request on read error: %m\");\n\t\t\treturn SLURM_FAILURE;\n\t\t}\n\t}\n\tdebug3(\"Got request %d\", req);\n\trc = SLURM_SUCCESS;\n\tswitch (req) {\n\tcase REQUEST_SIGNAL_TASK_LOCAL:\n\t\tdebug(\"Handling REQUEST_SIGNAL_TASK_LOCAL\");\n\t\trc = _handle_signal_task_local(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_SIGNAL_TASK_GLOBAL:\n\t\tdebug(\"Handling REQUEST_SIGNAL_TASK_GLOBAL (not implemented)\");\n\t\tbreak;\n\tcase REQUEST_SIGNAL_PROCESS_GROUP:\t/* Defunct */\n\tcase REQUEST_SIGNAL_CONTAINER:\n\t\tdebug(\"Handling REQUEST_SIGNAL_CONTAINER\");\n\t\trc = _handle_signal_container(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_CHECKPOINT_TASKS:\n\t\tdebug(\"Handling REQUEST_CHECKPOINT_TASKS\");\n\t\trc = _handle_checkpoint_tasks(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STATE:\n\t\tdebug(\"Handling REQUEST_STATE\");\n\t\trc = _handle_state(fd, job);\n\t\tbreak;\n\tcase REQUEST_INFO:\n\t\tdebug(\"Handling REQUEST_INFO\");\n\t\trc = _handle_info(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_MEM_LIMITS:\n\t\tdebug(\"Handling REQUEST_STEP_MEM_LIMITS\");\n\t\trc = _handle_mem_limits(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_UID:\n\t\tdebug(\"Handling REQUEST_STEP_UID\");\n\t\trc = _handle_uid(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_NODEID:\n\t\tdebug(\"Handling REQUEST_STEP_NODEID\");\n\t\trc = _handle_nodeid(fd, job);\n\t\tbreak;\n\tcase REQUEST_ATTACH:\n\t\tdebug(\"Handling REQUEST_ATTACH\");\n\t\trc = _handle_attach(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_PID_IN_CONTAINER:\n\t\tdebug(\"Handling REQUEST_PID_IN_CONTAINER\");\n\t\trc = _handle_pid_in_container(fd, job);\n\t\tbreak;\n\tcase REQUEST_DAEMON_PID:\n\t\tdebug(\"Handling REQUEST_DAEMON_PID\");\n\t\trc = _handle_daemon_pid(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_SUSPEND:\n\t\tdebug(\"Handling REQUEST_STEP_SUSPEND\");\n\t\trc = _handle_suspend(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_RESUME:\n\t\tdebug(\"Handling REQUEST_STEP_RESUME\");\n\t\trc = _handle_resume(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_TERMINATE:\n\t\tdebug(\"Handling REQUEST_STEP_TERMINATE\");\n\t\trc = _handle_terminate(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_COMPLETION_V2:\n\t\tdebug(\"Handling REQUEST_STEP_COMPLETION_V2\");\n\t\trc = _handle_completion(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_TASK_INFO:\n\t\tdebug(\"Handling REQUEST_STEP_TASK_INFO\");\n\t\trc = _handle_task_info(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_STAT:\n\t\tdebug(\"Handling REQUEST_STEP_STAT\");\n\t\trc = _handle_stat_jobacct(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_LIST_PIDS:\n\t\tdebug(\"Handling REQUEST_STEP_LIST_PIDS\");\n\t\trc = _handle_list_pids(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_RECONFIGURE:\n\t\tdebug(\"Handling REQUEST_STEP_RECONFIGURE\");\n\t\trc = _handle_reconfig(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_JOB_NOTIFY:\n\t\tdebug(\"Handling REQUEST_JOB_NOTIFY\");\n\t\trc = _handle_notify_job(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_ADD_EXTERN_PID:\n\t\tdebug(\"Handling REQUEST_ADD_EXTERN_PID\");\n\t\trc = _handle_add_extern_pid(fd, job);\n\t\tbreak;\n\tdefault:\n\t\terror(\"Unrecognized request: %d\", req);\n\t\trc = SLURM_FAILURE;\n\t\tbreak;\n\t}\n\n\tdebug3(\"Leaving  _handle_request: %s\",\n\t       rc ? \"SLURM_FAILURE\" : \"SLURM_SUCCESS\");\n\treturn rc;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_request(int fd, stepd_step_rec_t *job, uid_t uid, gid_t gid);",
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_request(int fd, stepd_step_rec_t *job, uid_t uid, gid_t gid);\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nint\n_handle_request(int fd, stepd_step_rec_t *job, uid_t uid, gid_t gid)\n{\n\tint rc = 0;\n\tint req;\n\n\tdebug3(\"Entering _handle_request\");\n\tif ((rc = read(fd, &req, sizeof(int))) != sizeof(int)) {\n\t\tif (rc == 0) { /* EOF, normal */\n\t\t\treturn -1;\n\t\t} else {\n\t\t\tdebug3(\"Leaving _handle_request on read error: %m\");\n\t\t\treturn SLURM_FAILURE;\n\t\t}\n\t}\n\tdebug3(\"Got request %d\", req);\n\trc = SLURM_SUCCESS;\n\tswitch (req) {\n\tcase REQUEST_SIGNAL_TASK_LOCAL:\n\t\tdebug(\"Handling REQUEST_SIGNAL_TASK_LOCAL\");\n\t\trc = _handle_signal_task_local(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_SIGNAL_TASK_GLOBAL:\n\t\tdebug(\"Handling REQUEST_SIGNAL_TASK_GLOBAL (not implemented)\");\n\t\tbreak;\n\tcase REQUEST_SIGNAL_PROCESS_GROUP:\t/* Defunct */\n\tcase REQUEST_SIGNAL_CONTAINER:\n\t\tdebug(\"Handling REQUEST_SIGNAL_CONTAINER\");\n\t\trc = _handle_signal_container(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_CHECKPOINT_TASKS:\n\t\tdebug(\"Handling REQUEST_CHECKPOINT_TASKS\");\n\t\trc = _handle_checkpoint_tasks(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STATE:\n\t\tdebug(\"Handling REQUEST_STATE\");\n\t\trc = _handle_state(fd, job);\n\t\tbreak;\n\tcase REQUEST_INFO:\n\t\tdebug(\"Handling REQUEST_INFO\");\n\t\trc = _handle_info(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_MEM_LIMITS:\n\t\tdebug(\"Handling REQUEST_STEP_MEM_LIMITS\");\n\t\trc = _handle_mem_limits(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_UID:\n\t\tdebug(\"Handling REQUEST_STEP_UID\");\n\t\trc = _handle_uid(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_NODEID:\n\t\tdebug(\"Handling REQUEST_STEP_NODEID\");\n\t\trc = _handle_nodeid(fd, job);\n\t\tbreak;\n\tcase REQUEST_ATTACH:\n\t\tdebug(\"Handling REQUEST_ATTACH\");\n\t\trc = _handle_attach(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_PID_IN_CONTAINER:\n\t\tdebug(\"Handling REQUEST_PID_IN_CONTAINER\");\n\t\trc = _handle_pid_in_container(fd, job);\n\t\tbreak;\n\tcase REQUEST_DAEMON_PID:\n\t\tdebug(\"Handling REQUEST_DAEMON_PID\");\n\t\trc = _handle_daemon_pid(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_SUSPEND:\n\t\tdebug(\"Handling REQUEST_STEP_SUSPEND\");\n\t\trc = _handle_suspend(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_RESUME:\n\t\tdebug(\"Handling REQUEST_STEP_RESUME\");\n\t\trc = _handle_resume(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_TERMINATE:\n\t\tdebug(\"Handling REQUEST_STEP_TERMINATE\");\n\t\trc = _handle_terminate(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_COMPLETION_V2:\n\t\tdebug(\"Handling REQUEST_STEP_COMPLETION_V2\");\n\t\trc = _handle_completion(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_TASK_INFO:\n\t\tdebug(\"Handling REQUEST_STEP_TASK_INFO\");\n\t\trc = _handle_task_info(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_STAT:\n\t\tdebug(\"Handling REQUEST_STEP_STAT\");\n\t\trc = _handle_stat_jobacct(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_STEP_LIST_PIDS:\n\t\tdebug(\"Handling REQUEST_STEP_LIST_PIDS\");\n\t\trc = _handle_list_pids(fd, job);\n\t\tbreak;\n\tcase REQUEST_STEP_RECONFIGURE:\n\t\tdebug(\"Handling REQUEST_STEP_RECONFIGURE\");\n\t\trc = _handle_reconfig(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_JOB_NOTIFY:\n\t\tdebug(\"Handling REQUEST_JOB_NOTIFY\");\n\t\trc = _handle_notify_job(fd, job, uid);\n\t\tbreak;\n\tcase REQUEST_ADD_EXTERN_PID:\n\t\tdebug(\"Handling REQUEST_ADD_EXTERN_PID\");\n\t\trc = _handle_add_extern_pid(fd, job);\n\t\tbreak;\n\tdefault:\n\t\terror(\"Unrecognized request: %d\", req);\n\t\trc = SLURM_FAILURE;\n\t\tbreak;\n\t}\n\n\tdebug3(\"Leaving  _handle_request: %s\",\n\t       rc ? \"SLURM_FAILURE\" : \"SLURM_SUCCESS\");\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "fd",
            "&rc",
            "sizeof(int)"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buf",
          "args": [
            "buffer"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_slurm_auth_destroy",
          "args": [
            "auth_cred"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"  Identity: uid=%d, gid=%d\"",
            "uid",
            "gid"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "auth_info"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_slurm_auth_get_gid",
          "args": [
            "auth_cred",
            "auth_info"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_slurm_auth_get_uid",
          "args": [
            "auth_cred",
            "auth_info"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buf",
          "args": [
            "buffer"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_slurm_auth_destroy",
          "args": [
            "auth_cred"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Verifying authentication credential: %s\"",
            "g_slurm_auth_errstr(g_slurm_auth_errno(auth_cred))"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "_prolog_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "1386-1434",
          "snippet": "static void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _is_batch_job_finished(uint32_t job_id);",
            "static bool _job_still_running(uint32_t job_id);",
            "static void _launch_complete_add(uint32_t job_id);",
            "static void _launch_complete_log(char *type, uint32_t job_id);",
            "static void _launch_complete_rm(uint32_t job_id);",
            "static void _launch_complete_wait(uint32_t job_id);",
            "static bool _launch_job_test(uint32_t job_id);",
            "static void _note_batch_job_finished(uint32_t job_id);",
            "static bool _slurm_authorized_user(uid_t uid);",
            "static void _sync_messages_kill(kill_job_msg_t *req);",
            "static int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);",
            "static gids_t *_gids_cache_lookup(char *user, gid_t gid);",
            "static int  _add_starting_step(uint16_t type, void *req);",
            "static int  _remove_starting_step(uint16_t type, void *req);",
            "static void _add_job_running_prolog(uint32_t job_id);",
            "static void _remove_job_running_prolog(uint32_t job_id);",
            "static void _wait_for_job_running_prolog(uint32_t job_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic bool _is_batch_job_finished(uint32_t job_id);\nstatic bool _job_still_running(uint32_t job_id);\nstatic void _launch_complete_add(uint32_t job_id);\nstatic void _launch_complete_log(char *type, uint32_t job_id);\nstatic void _launch_complete_rm(uint32_t job_id);\nstatic void _launch_complete_wait(uint32_t job_id);\nstatic bool _launch_job_test(uint32_t job_id);\nstatic void _note_batch_job_finished(uint32_t job_id);\nstatic bool _slurm_authorized_user(uid_t uid);\nstatic void _sync_messages_kill(kill_job_msg_t *req);\nstatic int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);\nstatic gids_t *_gids_cache_lookup(char *user, gid_t gid);\nstatic int  _add_starting_step(uint16_t type, void *req);\nstatic int  _remove_starting_step(uint16_t type, void *req);\nstatic void _add_job_running_prolog(uint32_t job_id);\nstatic void _remove_job_running_prolog(uint32_t job_id);\nstatic void _wait_for_job_running_prolog(uint32_t job_id);\n\nstatic void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "g_slurm_auth_errstr",
          "args": [
            "g_slurm_auth_errno(auth_cred)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_slurm_auth_errno",
          "args": [
            "auth_cred"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_slurm_auth_verify",
          "args": [
            "auth_cred",
            "NULL",
            "2",
            "auth_info"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_get_auth_info",
          "args": [],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buf",
          "args": [
            "buffer"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_slurm_auth_errstr",
          "args": [
            "g_slurm_auth_errno(NULL)"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_slurm_auth_errno",
          "args": [
            "NULL"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "g_slurm_auth_unpack",
          "args": [
            "buffer"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "get_buf_data(buffer)",
            "len"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_buf_data",
          "args": [
            "buffer"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_buf",
          "args": [
            "len"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&len",
            "sizeof(int)"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"First message must be REQUEST_CONNECT\""
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&req",
            "sizeof(int)"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Entering _handle_accept (new thread)\""
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic void *_handle_accept(void *arg);\nstatic int _handle_request(int fd, stepd_step_rec_t *job, uid_t uid, gid_t gid);\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t message_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t message_cond = PTHREAD_COND_INITIALIZER;\nstatic int message_connections;\n\nstatic void *\n_handle_accept(void *arg)\n{\n\t/*struct request_params *param = (struct request_params *)arg;*/\n\tint fd = ((struct request_params *)arg)->fd;\n\tstepd_step_rec_t *job = ((struct request_params *)arg)->job;\n\tint req;\n\tint len;\n\tBuf buffer;\n\tvoid *auth_cred;\n\tint rc;\n\tuid_t uid;\n\tgid_t gid;\n\tchar *auth_info;\n\n\tdebug3(\"Entering _handle_accept (new thread)\");\n\txfree(arg);\n\n\tsafe_read(fd, &req, sizeof(int));\n\tif (req != REQUEST_CONNECT) {\n\t\terror(\"First message must be REQUEST_CONNECT\");\n\t\tgoto fail;\n\t}\n\n\tsafe_read(fd, &len, sizeof(int));\n\tbuffer = init_buf(len);\n\tsafe_read(fd, get_buf_data(buffer), len);\n\n\t/* Unpack and verify the auth credential */\n\tauth_cred = g_slurm_auth_unpack(buffer);\n\tif (auth_cred == NULL) {\n\t\terror(\"Unpacking authentication credential: %s\",\n\t\t      g_slurm_auth_errstr(g_slurm_auth_errno(NULL)));\n\t\tfree_buf(buffer);\n\t\tgoto fail;\n\t}\n\tauth_info = slurm_get_auth_info();\n\trc = g_slurm_auth_verify(auth_cred, NULL, 2, auth_info);\n\tif (rc != SLURM_SUCCESS) {\n\t\terror(\"Verifying authentication credential: %s\",\n\t\t      g_slurm_auth_errstr(g_slurm_auth_errno(auth_cred)));\n\t\txfree(auth_info);\n\t\t(void) g_slurm_auth_destroy(auth_cred);\n\t\tfree_buf(buffer);\n\t\tgoto fail;\n\t}\n\n\t/* Get the uid & gid from the credential, then destroy it. */\n\tuid = g_slurm_auth_get_uid(auth_cred, auth_info);\n\tgid = g_slurm_auth_get_gid(auth_cred, auth_info);\n\txfree(auth_info);\n\tdebug3(\"  Identity: uid=%d, gid=%d\", uid, gid);\n\tg_slurm_auth_destroy(auth_cred);\n\tfree_buf(buffer);\n\n\trc = SLURM_PROTOCOL_VERSION;\n\tsafe_write(fd, &rc, sizeof(int));\n\n\twhile (1) {\n\t\trc = _handle_request(fd, job, uid, gid);\n\t\tif (rc != SLURM_SUCCESS)\n\t\t\tbreak;\n\t}\n\n\tif (close(fd) == -1)\n\t\terror(\"Closing accepted fd: %m\");\n\n\tslurm_mutex_lock(&message_lock);\n\tmessage_connections--;\n\tpthread_cond_signal(&message_cond);\n\tslurm_mutex_unlock(&message_lock);\n\n\tdebug3(\"Leaving  _handle_accept\");\n\treturn NULL;\n\nfail:\n\trc = SLURM_FAILURE;\n\tsafe_write(fd, &rc, sizeof(int));\nrwfail:\n\tif (close(fd) == -1)\n\t\terror(\"Closing accepted fd after error: %m\");\n\tdebug(\"Leaving  _handle_accept on an error\");\n\treturn NULL;\n}"
  },
  {
    "function_name": "_msg_socket_accept",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "322-392",
    "snippet": "static int\n_msg_socket_accept(eio_obj_t *obj, List objs)\n{\n\tstepd_step_rec_t *job = (stepd_step_rec_t *)obj->arg;\n\tint fd;\n\tstruct sockaddr_un addr;\n\tint len = sizeof(addr);\n\tstruct request_params *param = NULL;\n\tpthread_attr_t attr;\n\tpthread_t id;\n\tint retries = 0;\n\n\tdebug3(\"Called _msg_socket_accept\");\n\n\twhile ((fd = accept(obj->fd, (struct sockaddr *)&addr,\n\t\t\t    (socklen_t *)&len)) < 0) {\n\t\tif (errno == EINTR)\n\t\t\tcontinue;\n\t\tif ((errno == EAGAIN) ||\n\t\t    (errno == ECONNABORTED) ||\n\t\t    (errno == EWOULDBLOCK)) {\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\terror(\"Error on msg accept socket: %m\");\n\t\tif ((errno == EMFILE)  ||\n\t\t    (errno == ENFILE)  ||\n\t\t    (errno == ENOBUFS) ||\n\t\t    (errno == ENOMEM)) {\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tobj->shutdown = true;\n\t\treturn SLURM_SUCCESS;\n\t}\n\n\tslurm_mutex_lock(&message_lock);\n\tmessage_connections++;\n\tslurm_mutex_unlock(&message_lock);\n\n\tfd_set_close_on_exec(fd);\n\tfd_set_blocking(fd);\n\n\tslurm_attr_init(&attr);\n\tif (pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) != 0) {\n\t\terror(\"Unable to set detachstate on attr: %m\");\n\t\tslurm_attr_destroy(&attr);\n\t\tclose(fd);\n\t\treturn SLURM_ERROR;\n\t}\n\n\tparam = xmalloc(sizeof(struct request_params));\n\tparam->fd = fd;\n\tparam->job = job;\n\twhile (pthread_create(&id, &attr, &_handle_accept, (void *)param)) {\n\t\terror(\"stepd_api message engine pthread_create: %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"running handle_accept without \"\n\t\t\t      \"starting a thread stepd will be \"\n\t\t\t      \"unresponsive until done\");\n\t\t\t_handle_accept((void *)param);\n\t\t\tinfo(\"stepd should be responsive now\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\n\tslurm_attr_destroy(&attr);\n\tparam = NULL;\n\n\tdebug3(\"Leaving _msg_socket_accept\");\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *_handle_accept(void *arg);",
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static bool _msg_socket_readable(eio_obj_t *obj);",
      "static int _msg_socket_accept(eio_obj_t *obj, List objs);",
      "static pthread_mutex_t message_lock = PTHREAD_MUTEX_INITIALIZER;",
      "static int message_connections;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Leaving _msg_socket_accept\""
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_attr_destroy",
          "args": [
            "&attr"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info",
          "args": [
            "\"stepd should be responsive now\""
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "_free_file_bcast_info_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "3642-3648",
          "snippet": "static void _free_file_bcast_info_t(file_bcast_info_t *f)\n{\n\txfree(f->fname);\n\tif (f->fd)\n\t\tclose(f->fd);\n\txfree(f);\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic void _free_file_bcast_info_t(file_bcast_info_t *f)\n{\n\txfree(f->fname);\n\tif (f->fd)\n\t\tclose(f->fd);\n\txfree(f);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_accept",
          "args": [
            "(void *)param"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_accept",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "394-477",
          "snippet": "static void *\n_handle_accept(void *arg)\n{\n\t/*struct request_params *param = (struct request_params *)arg;*/\n\tint fd = ((struct request_params *)arg)->fd;\n\tstepd_step_rec_t *job = ((struct request_params *)arg)->job;\n\tint req;\n\tint len;\n\tBuf buffer;\n\tvoid *auth_cred;\n\tint rc;\n\tuid_t uid;\n\tgid_t gid;\n\tchar *auth_info;\n\n\tdebug3(\"Entering _handle_accept (new thread)\");\n\txfree(arg);\n\n\tsafe_read(fd, &req, sizeof(int));\n\tif (req != REQUEST_CONNECT) {\n\t\terror(\"First message must be REQUEST_CONNECT\");\n\t\tgoto fail;\n\t}\n\n\tsafe_read(fd, &len, sizeof(int));\n\tbuffer = init_buf(len);\n\tsafe_read(fd, get_buf_data(buffer), len);\n\n\t/* Unpack and verify the auth credential */\n\tauth_cred = g_slurm_auth_unpack(buffer);\n\tif (auth_cred == NULL) {\n\t\terror(\"Unpacking authentication credential: %s\",\n\t\t      g_slurm_auth_errstr(g_slurm_auth_errno(NULL)));\n\t\tfree_buf(buffer);\n\t\tgoto fail;\n\t}\n\tauth_info = slurm_get_auth_info();\n\trc = g_slurm_auth_verify(auth_cred, NULL, 2, auth_info);\n\tif (rc != SLURM_SUCCESS) {\n\t\terror(\"Verifying authentication credential: %s\",\n\t\t      g_slurm_auth_errstr(g_slurm_auth_errno(auth_cred)));\n\t\txfree(auth_info);\n\t\t(void) g_slurm_auth_destroy(auth_cred);\n\t\tfree_buf(buffer);\n\t\tgoto fail;\n\t}\n\n\t/* Get the uid & gid from the credential, then destroy it. */\n\tuid = g_slurm_auth_get_uid(auth_cred, auth_info);\n\tgid = g_slurm_auth_get_gid(auth_cred, auth_info);\n\txfree(auth_info);\n\tdebug3(\"  Identity: uid=%d, gid=%d\", uid, gid);\n\tg_slurm_auth_destroy(auth_cred);\n\tfree_buf(buffer);\n\n\trc = SLURM_PROTOCOL_VERSION;\n\tsafe_write(fd, &rc, sizeof(int));\n\n\twhile (1) {\n\t\trc = _handle_request(fd, job, uid, gid);\n\t\tif (rc != SLURM_SUCCESS)\n\t\t\tbreak;\n\t}\n\n\tif (close(fd) == -1)\n\t\terror(\"Closing accepted fd: %m\");\n\n\tslurm_mutex_lock(&message_lock);\n\tmessage_connections--;\n\tpthread_cond_signal(&message_cond);\n\tslurm_mutex_unlock(&message_lock);\n\n\tdebug3(\"Leaving  _handle_accept\");\n\treturn NULL;\n\nfail:\n\trc = SLURM_FAILURE;\n\tsafe_write(fd, &rc, sizeof(int));\nrwfail:\n\tif (close(fd) == -1)\n\t\terror(\"Closing accepted fd after error: %m\");\n\tdebug(\"Leaving  _handle_accept on an error\");\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void *_handle_accept(void *arg);",
            "static int _handle_request(int fd, stepd_step_rec_t *job, uid_t uid, gid_t gid);",
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);",
            "static pthread_mutex_t message_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static pthread_cond_t message_cond = PTHREAD_COND_INITIALIZER;",
            "static int message_connections;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic void *_handle_accept(void *arg);\nstatic int _handle_request(int fd, stepd_step_rec_t *job, uid_t uid, gid_t gid);\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic pthread_mutex_t message_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t message_cond = PTHREAD_COND_INITIALIZER;\nstatic int message_connections;\n\nstatic void *\n_handle_accept(void *arg)\n{\n\t/*struct request_params *param = (struct request_params *)arg;*/\n\tint fd = ((struct request_params *)arg)->fd;\n\tstepd_step_rec_t *job = ((struct request_params *)arg)->job;\n\tint req;\n\tint len;\n\tBuf buffer;\n\tvoid *auth_cred;\n\tint rc;\n\tuid_t uid;\n\tgid_t gid;\n\tchar *auth_info;\n\n\tdebug3(\"Entering _handle_accept (new thread)\");\n\txfree(arg);\n\n\tsafe_read(fd, &req, sizeof(int));\n\tif (req != REQUEST_CONNECT) {\n\t\terror(\"First message must be REQUEST_CONNECT\");\n\t\tgoto fail;\n\t}\n\n\tsafe_read(fd, &len, sizeof(int));\n\tbuffer = init_buf(len);\n\tsafe_read(fd, get_buf_data(buffer), len);\n\n\t/* Unpack and verify the auth credential */\n\tauth_cred = g_slurm_auth_unpack(buffer);\n\tif (auth_cred == NULL) {\n\t\terror(\"Unpacking authentication credential: %s\",\n\t\t      g_slurm_auth_errstr(g_slurm_auth_errno(NULL)));\n\t\tfree_buf(buffer);\n\t\tgoto fail;\n\t}\n\tauth_info = slurm_get_auth_info();\n\trc = g_slurm_auth_verify(auth_cred, NULL, 2, auth_info);\n\tif (rc != SLURM_SUCCESS) {\n\t\terror(\"Verifying authentication credential: %s\",\n\t\t      g_slurm_auth_errstr(g_slurm_auth_errno(auth_cred)));\n\t\txfree(auth_info);\n\t\t(void) g_slurm_auth_destroy(auth_cred);\n\t\tfree_buf(buffer);\n\t\tgoto fail;\n\t}\n\n\t/* Get the uid & gid from the credential, then destroy it. */\n\tuid = g_slurm_auth_get_uid(auth_cred, auth_info);\n\tgid = g_slurm_auth_get_gid(auth_cred, auth_info);\n\txfree(auth_info);\n\tdebug3(\"  Identity: uid=%d, gid=%d\", uid, gid);\n\tg_slurm_auth_destroy(auth_cred);\n\tfree_buf(buffer);\n\n\trc = SLURM_PROTOCOL_VERSION;\n\tsafe_write(fd, &rc, sizeof(int));\n\n\twhile (1) {\n\t\trc = _handle_request(fd, job, uid, gid);\n\t\tif (rc != SLURM_SUCCESS)\n\t\t\tbreak;\n\t}\n\n\tif (close(fd) == -1)\n\t\terror(\"Closing accepted fd: %m\");\n\n\tslurm_mutex_lock(&message_lock);\n\tmessage_connections--;\n\tpthread_cond_signal(&message_cond);\n\tslurm_mutex_unlock(&message_lock);\n\n\tdebug3(\"Leaving  _handle_accept\");\n\treturn NULL;\n\nfail:\n\trc = SLURM_FAILURE;\n\tsafe_write(fd, &rc, sizeof(int));\nrwfail:\n\tif (close(fd) == -1)\n\t\terror(\"Closing accepted fd after error: %m\");\n\tdebug(\"Leaving  _handle_accept on an error\");\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"running handle_accept without \"\n\t\t\t      \"starting a thread stepd will be \"\n\t\t\t      \"unresponsive until done\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"stepd_api message engine pthread_create: %m\""
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_create",
          "args": [
            "&id",
            "&attr",
            "&_handle_accept",
            "(void *)param"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(struct request_params)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "_file_bcast_close_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "3635-3640",
          "snippet": "static void _file_bcast_close_file(file_bcast_info_t *key)\n{\n\t_fb_wrlock();\n\tlist_delete_all(file_bcast_list, _bcast_find_in_list, key);\n\t_fb_wrunlock();\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _job_limits_match(void *x, void *key);",
            "static int  _step_limits_match(void *x, void *key);",
            "static int  _file_bcast_register_file(slurm_msg_t *msg,\n\t\t\t\t      file_bcast_info_t *key);",
            "static List file_bcast_list = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic int  _job_limits_match(void *x, void *key);\nstatic int  _step_limits_match(void *x, void *key);\nstatic int  _file_bcast_register_file(slurm_msg_t *msg,\n\t\t\t\t      file_bcast_info_t *key);\nstatic List file_bcast_list = NULL;\n\nstatic void _file_bcast_close_file(file_bcast_info_t *key)\n{\n\t_fb_wrlock();\n\tlist_delete_all(file_bcast_list, _bcast_find_in_list, key);\n\t_fb_wrunlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_attr_destroy",
          "args": [
            "&attr"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to set detachstate on attr: %m\""
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_attr_setdetachstate",
          "args": [
            "&attr",
            "PTHREAD_CREATE_DETACHED"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_attr_init",
          "args": [
            "&attr"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_blocking",
          "args": [
            "fd"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_close_on_exec",
          "args": [
            "fd"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&message_lock"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&message_lock"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Error on msg accept socket: %m\""
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "accept",
          "args": [
            "obj->fd",
            "(struct sockaddr *)&addr",
            "(socklen_t *)&len"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Called _msg_socket_accept\""
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic void *_handle_accept(void *arg);\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic bool _msg_socket_readable(eio_obj_t *obj);\nstatic int _msg_socket_accept(eio_obj_t *obj, List objs);\nstatic pthread_mutex_t message_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic int message_connections;\n\nstatic int\n_msg_socket_accept(eio_obj_t *obj, List objs)\n{\n\tstepd_step_rec_t *job = (stepd_step_rec_t *)obj->arg;\n\tint fd;\n\tstruct sockaddr_un addr;\n\tint len = sizeof(addr);\n\tstruct request_params *param = NULL;\n\tpthread_attr_t attr;\n\tpthread_t id;\n\tint retries = 0;\n\n\tdebug3(\"Called _msg_socket_accept\");\n\n\twhile ((fd = accept(obj->fd, (struct sockaddr *)&addr,\n\t\t\t    (socklen_t *)&len)) < 0) {\n\t\tif (errno == EINTR)\n\t\t\tcontinue;\n\t\tif ((errno == EAGAIN) ||\n\t\t    (errno == ECONNABORTED) ||\n\t\t    (errno == EWOULDBLOCK)) {\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\terror(\"Error on msg accept socket: %m\");\n\t\tif ((errno == EMFILE)  ||\n\t\t    (errno == ENFILE)  ||\n\t\t    (errno == ENOBUFS) ||\n\t\t    (errno == ENOMEM)) {\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tobj->shutdown = true;\n\t\treturn SLURM_SUCCESS;\n\t}\n\n\tslurm_mutex_lock(&message_lock);\n\tmessage_connections++;\n\tslurm_mutex_unlock(&message_lock);\n\n\tfd_set_close_on_exec(fd);\n\tfd_set_blocking(fd);\n\n\tslurm_attr_init(&attr);\n\tif (pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED) != 0) {\n\t\terror(\"Unable to set detachstate on attr: %m\");\n\t\tslurm_attr_destroy(&attr);\n\t\tclose(fd);\n\t\treturn SLURM_ERROR;\n\t}\n\n\tparam = xmalloc(sizeof(struct request_params));\n\tparam->fd = fd;\n\tparam->job = job;\n\twhile (pthread_create(&id, &attr, &_handle_accept, (void *)param)) {\n\t\terror(\"stepd_api message engine pthread_create: %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"running handle_accept without \"\n\t\t\t      \"starting a thread stepd will be \"\n\t\t\t      \"unresponsive until done\");\n\t\t\t_handle_accept((void *)param);\n\t\t\tinfo(\"stepd should be responsive now\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\n\tslurm_attr_destroy(&attr);\n\tparam = NULL;\n\n\tdebug3(\"Leaving _msg_socket_accept\");\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "_msg_socket_readable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "301-320",
    "snippet": "static bool\n_msg_socket_readable(eio_obj_t *obj)\n{\n\tdebug3(\"Called _msg_socket_readable\");\n\tif (obj->shutdown == true) {\n\t\t/* All spawned tasks have been completed by this point */\n\t\tif (obj->fd != -1) {\n\t\t\tdebug2(\"  false, shutdown\");\n\t\t\t_domain_socket_destroy(obj->fd);\n\t\t\t/* slurmd considers the job step done now that\n\t\t\t * the domain name socket is destroyed */\n\t\t\tobj->fd = -1;\n\t\t\t_wait_for_connections();\n\t\t} else {\n\t\t\tdebug2(\"  false\");\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static bool _msg_socket_readable(eio_obj_t *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"  false\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_wait_for_connections",
          "args": [],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "_wait_for_connections",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "288-299",
          "snippet": "static void _wait_for_connections(void)\n{\n\tstruct timespec ts = {0, 0};\n\tint rc = 0;\n\n\tslurm_mutex_lock(&message_lock);\n\tts.tv_sec = time(NULL) + STEPD_MESSAGE_COMP_WAIT;\n\twhile (message_connections > 0 && rc == 0)\n\t\trc = pthread_cond_timedwait(&message_cond, &message_lock, &ts);\n\n\tslurm_mutex_unlock(&message_lock);\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static pthread_mutex_t message_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static pthread_cond_t message_cond = PTHREAD_COND_INITIALIZER;",
            "static int message_connections;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic pthread_mutex_t message_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t message_cond = PTHREAD_COND_INITIALIZER;\nstatic int message_connections;\n\nstatic void _wait_for_connections(void)\n{\n\tstruct timespec ts = {0, 0};\n\tint rc = 0;\n\n\tslurm_mutex_lock(&message_lock);\n\tts.tv_sec = time(NULL) + STEPD_MESSAGE_COMP_WAIT;\n\twhile (message_connections > 0 && rc == 0)\n\t\trc = pthread_cond_timedwait(&message_cond, &message_lock, &ts);\n\n\tslurm_mutex_unlock(&message_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "_domain_socket_destroy",
          "args": [
            "obj->fd"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "_domain_socket_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "223-231",
          "snippet": "static void\n_domain_socket_destroy(int fd)\n{\n\tif (close(fd) < 0)\n\t\terror(\"Unable to close domain socket: %m\");\n\n\tif (unlink(socket_name) == -1)\n\t\terror(\"Unable to unlink domain socket: %m\");\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static char *socket_name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic char *socket_name;\n\nstatic void\n_domain_socket_destroy(int fd)\n{\n\tif (close(fd) < 0)\n\t\terror(\"Unable to close domain socket: %m\");\n\n\tif (unlink(socket_name) == -1)\n\t\terror(\"Unable to unlink domain socket: %m\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"  false, shutdown\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"Called _msg_socket_readable\""
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic bool _msg_socket_readable(eio_obj_t *obj);\n\nstatic bool\n_msg_socket_readable(eio_obj_t *obj)\n{\n\tdebug3(\"Called _msg_socket_readable\");\n\tif (obj->shutdown == true) {\n\t\t/* All spawned tasks have been completed by this point */\n\t\tif (obj->fd != -1) {\n\t\t\tdebug2(\"  false, shutdown\");\n\t\t\t_domain_socket_destroy(obj->fd);\n\t\t\t/* slurmd considers the job step done now that\n\t\t\t * the domain name socket is destroyed */\n\t\t\tobj->fd = -1;\n\t\t\t_wait_for_connections();\n\t\t} else {\n\t\t\tdebug2(\"  false\");\n\t\t}\n\t\treturn false;\n\t}\n\treturn true;\n}"
  },
  {
    "function_name": "_wait_for_connections",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "288-299",
    "snippet": "static void _wait_for_connections(void)\n{\n\tstruct timespec ts = {0, 0};\n\tint rc = 0;\n\n\tslurm_mutex_lock(&message_lock);\n\tts.tv_sec = time(NULL) + STEPD_MESSAGE_COMP_WAIT;\n\twhile (message_connections > 0 && rc == 0)\n\t\trc = pthread_cond_timedwait(&message_cond, &message_lock, &ts);\n\n\tslurm_mutex_unlock(&message_lock);\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pthread_mutex_t message_lock = PTHREAD_MUTEX_INITIALIZER;",
      "static pthread_cond_t message_cond = PTHREAD_COND_INITIALIZER;",
      "static int message_connections;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&message_lock"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_cond_timedwait",
          "args": [
            "&message_cond",
            "&message_lock",
            "&ts"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "_prolog_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "5661-5696",
          "snippet": "static void *_prolog_timer(void *x)\n{\n\tint delay_time, rc = SLURM_SUCCESS;\n\tstruct timespec ts;\n\tstruct timeval now;\n\tslurm_msg_t msg;\n\tjob_notify_msg_t notify_req;\n\tchar srun_msg[128];\n\ttimer_struct_t *timer_struct = (timer_struct_t *) x;\n\n\tdelay_time = MAX(2, (timer_struct->msg_timeout - 2));\n\tgettimeofday(&now, NULL);\n\tts.tv_sec = now.tv_sec + delay_time;\n\tts.tv_nsec = now.tv_usec * 1000;\n\tslurm_mutex_lock(timer_struct->timer_mutex);\n\tif (!timer_struct->prolog_fini) {\n\t\trc = pthread_cond_timedwait(timer_struct->timer_cond,\n\t\t\t\t\t    timer_struct->timer_mutex,\n\t\t\t\t\t    &ts);\n\t}\n\tslurm_mutex_unlock(timer_struct->timer_mutex);\n\n\tif (rc != ETIMEDOUT)\n\t\treturn NULL;\n\n\tslurm_msg_t_init(&msg);\n\tsnprintf(srun_msg, sizeof(srun_msg), \"Prolog hung on node %s\",\n\t\t conf->node_name);\n\tnotify_req.job_id\t= timer_struct->job_id;\n\tnotify_req.job_step_id\t= NO_VAL;\n\tnotify_req.message\t= srun_msg;\n\tmsg.msg_type\t= REQUEST_JOB_NOTIFY;\n\tmsg.data\t= &notify_req;\n\tslurm_send_only_controller_msg(&msg);\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _is_batch_job_finished(uint32_t job_id);",
            "static void _job_limits_free(void *x);",
            "static bool _job_still_running(uint32_t job_id);",
            "static void _launch_complete_add(uint32_t job_id);",
            "static void _launch_complete_log(char *type, uint32_t job_id);",
            "static void _launch_complete_rm(uint32_t job_id);",
            "static void _launch_complete_wait(uint32_t job_id);",
            "static bool _launch_job_test(uint32_t job_id);",
            "static void _note_batch_job_finished(uint32_t job_id);",
            "static void _rpc_launch_tasks(slurm_msg_t *);",
            "static void _rpc_abort_job(slurm_msg_t *);",
            "static void _rpc_prolog(slurm_msg_t *msg);",
            "static void _rpc_job_notify(slurm_msg_t *);",
            "static void _rpc_signal_tasks(slurm_msg_t *);",
            "static void _rpc_checkpoint_tasks(slurm_msg_t *);",
            "static void _rpc_complete_batch(slurm_msg_t *);",
            "static void _rpc_terminate_tasks(slurm_msg_t *);",
            "static void _rpc_timelimit(slurm_msg_t *);",
            "static void _rpc_reattach_tasks(slurm_msg_t *);",
            "static void _rpc_signal_job(slurm_msg_t *);",
            "static void _rpc_suspend_job(slurm_msg_t *msg);",
            "static void _rpc_terminate_job(slurm_msg_t *);",
            "static void _rpc_update_time(slurm_msg_t *);",
            "static void _rpc_shutdown(slurm_msg_t *msg);",
            "static void _rpc_reconfig(slurm_msg_t *msg);",
            "static void _rpc_reboot(slurm_msg_t *msg);",
            "static void _rpc_pid2jid(slurm_msg_t *msg);",
            "static int  _rpc_file_bcast(slurm_msg_t *msg);",
            "static int  _rpc_ping(slurm_msg_t *);",
            "static int  _rpc_health_check(slurm_msg_t *);",
            "static int  _rpc_acct_gather_update(slurm_msg_t *);",
            "static int  _rpc_acct_gather_energy(slurm_msg_t *);",
            "static int  _rpc_step_complete(slurm_msg_t *msg);",
            "static int  _rpc_step_complete_aggr(slurm_msg_t *msg);",
            "static int  _rpc_stat_jobacct(slurm_msg_t *msg);",
            "static int  _rpc_list_pids(slurm_msg_t *msg);",
            "static int  _rpc_daemon_status(slurm_msg_t *msg);",
            "static void _rpc_forward_data(slurm_msg_t *msg);",
            "static int  _rpc_network_callerid(slurm_msg_t *msg);",
            "static int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);",
            "static void _add_job_running_prolog(uint32_t job_id);",
            "static void _remove_job_running_prolog(uint32_t job_id);",
            "static void _wait_for_job_running_prolog(uint32_t job_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic bool _is_batch_job_finished(uint32_t job_id);\nstatic void _job_limits_free(void *x);\nstatic bool _job_still_running(uint32_t job_id);\nstatic void _launch_complete_add(uint32_t job_id);\nstatic void _launch_complete_log(char *type, uint32_t job_id);\nstatic void _launch_complete_rm(uint32_t job_id);\nstatic void _launch_complete_wait(uint32_t job_id);\nstatic bool _launch_job_test(uint32_t job_id);\nstatic void _note_batch_job_finished(uint32_t job_id);\nstatic void _rpc_launch_tasks(slurm_msg_t *);\nstatic void _rpc_abort_job(slurm_msg_t *);\nstatic void _rpc_prolog(slurm_msg_t *msg);\nstatic void _rpc_job_notify(slurm_msg_t *);\nstatic void _rpc_signal_tasks(slurm_msg_t *);\nstatic void _rpc_checkpoint_tasks(slurm_msg_t *);\nstatic void _rpc_complete_batch(slurm_msg_t *);\nstatic void _rpc_terminate_tasks(slurm_msg_t *);\nstatic void _rpc_timelimit(slurm_msg_t *);\nstatic void _rpc_reattach_tasks(slurm_msg_t *);\nstatic void _rpc_signal_job(slurm_msg_t *);\nstatic void _rpc_suspend_job(slurm_msg_t *msg);\nstatic void _rpc_terminate_job(slurm_msg_t *);\nstatic void _rpc_update_time(slurm_msg_t *);\nstatic void _rpc_shutdown(slurm_msg_t *msg);\nstatic void _rpc_reconfig(slurm_msg_t *msg);\nstatic void _rpc_reboot(slurm_msg_t *msg);\nstatic void _rpc_pid2jid(slurm_msg_t *msg);\nstatic int  _rpc_file_bcast(slurm_msg_t *msg);\nstatic int  _rpc_ping(slurm_msg_t *);\nstatic int  _rpc_health_check(slurm_msg_t *);\nstatic int  _rpc_acct_gather_update(slurm_msg_t *);\nstatic int  _rpc_acct_gather_energy(slurm_msg_t *);\nstatic int  _rpc_step_complete(slurm_msg_t *msg);\nstatic int  _rpc_step_complete_aggr(slurm_msg_t *msg);\nstatic int  _rpc_stat_jobacct(slurm_msg_t *msg);\nstatic int  _rpc_list_pids(slurm_msg_t *msg);\nstatic int  _rpc_daemon_status(slurm_msg_t *msg);\nstatic void _rpc_forward_data(slurm_msg_t *msg);\nstatic int  _rpc_network_callerid(slurm_msg_t *msg);\nstatic int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);\nstatic void _add_job_running_prolog(uint32_t job_id);\nstatic void _remove_job_running_prolog(uint32_t job_id);\nstatic void _wait_for_job_running_prolog(uint32_t job_id);\n\nstatic void *_prolog_timer(void *x)\n{\n\tint delay_time, rc = SLURM_SUCCESS;\n\tstruct timespec ts;\n\tstruct timeval now;\n\tslurm_msg_t msg;\n\tjob_notify_msg_t notify_req;\n\tchar srun_msg[128];\n\ttimer_struct_t *timer_struct = (timer_struct_t *) x;\n\n\tdelay_time = MAX(2, (timer_struct->msg_timeout - 2));\n\tgettimeofday(&now, NULL);\n\tts.tv_sec = now.tv_sec + delay_time;\n\tts.tv_nsec = now.tv_usec * 1000;\n\tslurm_mutex_lock(timer_struct->timer_mutex);\n\tif (!timer_struct->prolog_fini) {\n\t\trc = pthread_cond_timedwait(timer_struct->timer_cond,\n\t\t\t\t\t    timer_struct->timer_mutex,\n\t\t\t\t\t    &ts);\n\t}\n\tslurm_mutex_unlock(timer_struct->timer_mutex);\n\n\tif (rc != ETIMEDOUT)\n\t\treturn NULL;\n\n\tslurm_msg_t_init(&msg);\n\tsnprintf(srun_msg, sizeof(srun_msg), \"Prolog hung on node %s\",\n\t\t conf->node_name);\n\tnotify_req.job_id\t= timer_struct->job_id;\n\tnotify_req.job_step_id\t= NO_VAL;\n\tnotify_req.message\t= srun_msg;\n\tmsg.msg_type\t= REQUEST_JOB_NOTIFY;\n\tmsg.data\t= &notify_req;\n\tslurm_send_only_controller_msg(&msg);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&message_lock"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic pthread_mutex_t message_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t message_cond = PTHREAD_COND_INITIALIZER;\nstatic int message_connections;\n\nstatic void _wait_for_connections(void)\n{\n\tstruct timespec ts = {0, 0};\n\tint rc = 0;\n\n\tslurm_mutex_lock(&message_lock);\n\tts.tv_sec = time(NULL) + STEPD_MESSAGE_COMP_WAIT;\n\twhile (message_connections > 0 && rc == 0)\n\t\trc = pthread_cond_timedwait(&message_cond, &message_lock, &ts);\n\n\tslurm_mutex_unlock(&message_lock);\n}"
  },
  {
    "function_name": "msg_thr_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "246-281",
    "snippet": "int\nmsg_thr_create(stepd_step_rec_t *job)\n{\n\tint fd;\n\teio_obj_t *eio_obj;\n\tpthread_attr_t attr;\n\tint rc = SLURM_SUCCESS, retries = 0;\n\terrno = 0;\n\tfd = _domain_socket_create(conf->spooldir, conf->node_name,\n\t\t\t\t   job->jobid, job->stepid);\n\tif (fd == -1)\n\t\treturn SLURM_ERROR;\n\n\tfd_set_nonblocking(fd);\n\n\teio_obj = eio_obj_create(fd, &msg_socket_ops, (void *)job);\n\tjob->msg_handle = eio_handle_create(0);\n\teio_new_initial_obj(job->msg_handle, eio_obj);\n\n\tslurm_attr_init(&attr);\n\n\twhile (pthread_create(&job->msgid, &attr,\n\t\t\t      &_msg_thr_internal, (void *)job)) {\n\t\terror(\"msg_thr_create: pthread_create error %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"msg_thr_create: Can't create pthread\");\n\t\t\trc = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\n\tslurm_attr_destroy(&attr);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "struct io_operations msg_socket_ops = {\n\t.readable = &_msg_socket_readable,\n\t.handle_read = &_msg_socket_accept\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_attr_destroy",
          "args": [
            "&attr"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"msg_thr_create: Can't create pthread\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"msg_thr_create: pthread_create error %m\""
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_create",
          "args": [
            "&job->msgid",
            "&attr",
            "&_msg_thr_internal",
            "(void *)job"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_attr_init",
          "args": [
            "&attr"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eio_new_initial_obj",
          "args": [
            "job->msg_handle",
            "eio_obj"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eio_handle_create",
          "args": [
            "0"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eio_obj_create",
          "args": [
            "fd",
            "&msg_socket_ops",
            "(void *)job"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_nonblocking",
          "args": [
            "fd"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_domain_socket_create",
          "args": [
            "conf->spooldir",
            "conf->node_name",
            "job->jobid",
            "job->stepid"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "_domain_socket_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "173-221",
          "snippet": "static int\n_domain_socket_create(const char *dir, const char *nodename,\n\t\t     uint32_t jobid, uint32_t stepid)\n{\n\tint fd;\n\tchar *name = NULL;\n\tstruct stat stat_buf;\n\n\t/*\n\t * Make sure that \"dir\" exists and is a directory.\n\t */\n\tif (stat(dir, &stat_buf) < 0) {\n\t\terror(\"Domain socket directory %s: %m\", dir);\n\t\treturn -1;\n\t} else if (!S_ISDIR(stat_buf.st_mode)) {\n\t\terror(\"%s is not a directory\", dir);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Now build the name of socket, and create the socket.\n\t */\n\txstrfmtcat(name, \"%s/%s_%u.%u\", dir, nodename, jobid, stepid);\n\n\t/*\n\t * First check to see if the named socket already exists.\n\t */\n\tif (stat(name, &stat_buf) == 0) {\n\t\t/* Vestigial from a slurmd crash or job requeue that did not\n\t\t * happen properly (very rare conditions). Unlink the file\n\t\t * and recreate it.\n\t\t */\n\t\tif (unlink(name) != 0) {\n\t\t\terror(\"%s: failed unlink(%s) job %u step %u %m\",\n\t\t\t      __func__, name, jobid, stepid);\n\t\t\txfree(name);\n\t\t\terrno = ESLURMD_STEP_EXISTS;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfd = _create_socket(name);\n\tif (fd < 0)\n\t\tfatal(\"Could not create domain socket: %m\");\n\n\tchmod(name, 0777);\n\tsocket_name = name;\n\treturn fd;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "static char *socket_name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic char *socket_name;\n\nstatic int\n_domain_socket_create(const char *dir, const char *nodename,\n\t\t     uint32_t jobid, uint32_t stepid)\n{\n\tint fd;\n\tchar *name = NULL;\n\tstruct stat stat_buf;\n\n\t/*\n\t * Make sure that \"dir\" exists and is a directory.\n\t */\n\tif (stat(dir, &stat_buf) < 0) {\n\t\terror(\"Domain socket directory %s: %m\", dir);\n\t\treturn -1;\n\t} else if (!S_ISDIR(stat_buf.st_mode)) {\n\t\terror(\"%s is not a directory\", dir);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Now build the name of socket, and create the socket.\n\t */\n\txstrfmtcat(name, \"%s/%s_%u.%u\", dir, nodename, jobid, stepid);\n\n\t/*\n\t * First check to see if the named socket already exists.\n\t */\n\tif (stat(name, &stat_buf) == 0) {\n\t\t/* Vestigial from a slurmd crash or job requeue that did not\n\t\t * happen properly (very rare conditions). Unlink the file\n\t\t * and recreate it.\n\t\t */\n\t\tif (unlink(name) != 0) {\n\t\t\terror(\"%s: failed unlink(%s) job %u step %u %m\",\n\t\t\t      __func__, name, jobid, stepid);\n\t\t\txfree(name);\n\t\t\terrno = ESLURMD_STEP_EXISTS;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfd = _create_socket(name);\n\tif (fd < 0)\n\t\tfatal(\"Could not create domain socket: %m\");\n\n\tchmod(name, 0777);\n\tsocket_name = name;\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstruct io_operations msg_socket_ops = {\n\t.readable = &_msg_socket_readable,\n\t.handle_read = &_msg_socket_accept\n};\n\nint\nmsg_thr_create(stepd_step_rec_t *job)\n{\n\tint fd;\n\teio_obj_t *eio_obj;\n\tpthread_attr_t attr;\n\tint rc = SLURM_SUCCESS, retries = 0;\n\terrno = 0;\n\tfd = _domain_socket_create(conf->spooldir, conf->node_name,\n\t\t\t\t   job->jobid, job->stepid);\n\tif (fd == -1)\n\t\treturn SLURM_ERROR;\n\n\tfd_set_nonblocking(fd);\n\n\teio_obj = eio_obj_create(fd, &msg_socket_ops, (void *)job);\n\tjob->msg_handle = eio_handle_create(0);\n\teio_new_initial_obj(job->msg_handle, eio_obj);\n\n\tslurm_attr_init(&attr);\n\n\twhile (pthread_create(&job->msgid, &attr,\n\t\t\t      &_msg_thr_internal, (void *)job)) {\n\t\terror(\"msg_thr_create: pthread_create error %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"msg_thr_create: Can't create pthread\");\n\t\t\trc = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\n\tslurm_attr_destroy(&attr);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "_msg_thr_internal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "234-244",
    "snippet": "static void *\n_msg_thr_internal(void *job_arg)\n{\n\tstepd_step_rec_t *job = (stepd_step_rec_t *) job_arg;\n\n\tdebug(\"Message thread started pid = %lu\", (unsigned long) getpid());\n\teio_handle_mainloop(job->msg_handle);\n\tdebug(\"Message thread exited\");\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Message thread exited\""
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_stop_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "120-139",
          "snippet": "void\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "eio_handle_mainloop",
          "args": [
            "job->msg_handle"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Message thread started pid = %lu\"",
            "(unsigned long) getpid()"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_wake_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "187-199",
          "snippet": "void pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid_internal(stepd_step_rec_t *job, pid_t pid);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic void *\n_msg_thr_internal(void *job_arg)\n{\n\tstepd_step_rec_t *job = (stepd_step_rec_t *) job_arg;\n\n\tdebug(\"Message thread started pid = %lu\", (unsigned long) getpid());\n\teio_handle_mainloop(job->msg_handle);\n\tdebug(\"Message thread exited\");\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "_domain_socket_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "223-231",
    "snippet": "static void\n_domain_socket_destroy(int fd)\n{\n\tif (close(fd) < 0)\n\t\terror(\"Unable to close domain socket: %m\");\n\n\tif (unlink(socket_name) == -1)\n\t\terror(\"Unable to unlink domain socket: %m\");\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static char *socket_name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to unlink domain socket: %m\""
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "socket_name"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to close domain socket: %m\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "_file_bcast_close_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "3635-3640",
          "snippet": "static void _file_bcast_close_file(file_bcast_info_t *key)\n{\n\t_fb_wrlock();\n\tlist_delete_all(file_bcast_list, _bcast_find_in_list, key);\n\t_fb_wrunlock();\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _job_limits_match(void *x, void *key);",
            "static int  _step_limits_match(void *x, void *key);",
            "static int  _file_bcast_register_file(slurm_msg_t *msg,\n\t\t\t\t      file_bcast_info_t *key);",
            "static List file_bcast_list = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic int  _job_limits_match(void *x, void *key);\nstatic int  _step_limits_match(void *x, void *key);\nstatic int  _file_bcast_register_file(slurm_msg_t *msg,\n\t\t\t\t      file_bcast_info_t *key);\nstatic List file_bcast_list = NULL;\n\nstatic void _file_bcast_close_file(file_bcast_info_t *key)\n{\n\t_fb_wrlock();\n\tlist_delete_all(file_bcast_list, _bcast_find_in_list, key);\n\t_fb_wrunlock();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic char *socket_name;\n\nstatic void\n_domain_socket_destroy(int fd)\n{\n\tif (close(fd) < 0)\n\t\terror(\"Unable to close domain socket: %m\");\n\n\tif (unlink(socket_name) == -1)\n\t\terror(\"Unable to unlink domain socket: %m\");\n}"
  },
  {
    "function_name": "_domain_socket_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "173-221",
    "snippet": "static int\n_domain_socket_create(const char *dir, const char *nodename,\n\t\t     uint32_t jobid, uint32_t stepid)\n{\n\tint fd;\n\tchar *name = NULL;\n\tstruct stat stat_buf;\n\n\t/*\n\t * Make sure that \"dir\" exists and is a directory.\n\t */\n\tif (stat(dir, &stat_buf) < 0) {\n\t\terror(\"Domain socket directory %s: %m\", dir);\n\t\treturn -1;\n\t} else if (!S_ISDIR(stat_buf.st_mode)) {\n\t\terror(\"%s is not a directory\", dir);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Now build the name of socket, and create the socket.\n\t */\n\txstrfmtcat(name, \"%s/%s_%u.%u\", dir, nodename, jobid, stepid);\n\n\t/*\n\t * First check to see if the named socket already exists.\n\t */\n\tif (stat(name, &stat_buf) == 0) {\n\t\t/* Vestigial from a slurmd crash or job requeue that did not\n\t\t * happen properly (very rare conditions). Unlink the file\n\t\t * and recreate it.\n\t\t */\n\t\tif (unlink(name) != 0) {\n\t\t\terror(\"%s: failed unlink(%s) job %u step %u %m\",\n\t\t\t      __func__, name, jobid, stepid);\n\t\t\txfree(name);\n\t\t\terrno = ESLURMD_STEP_EXISTS;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfd = _create_socket(name);\n\tif (fd < 0)\n\t\tfatal(\"Could not create domain socket: %m\");\n\n\tchmod(name, 0777);\n\tsocket_name = name;\n\treturn fd;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_state(int fd, stepd_step_rec_t *job);",
      "static int _handle_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
      "static int _handle_uid(int fd, stepd_step_rec_t *job);",
      "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
      "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
      "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
      "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
      "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
      "static char *socket_name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chmod",
          "args": [
            "name",
            "0777"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Could not create domain socket: %m\""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_create_socket",
          "args": [
            "name"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "_create_socket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "146-171",
          "snippet": "static int\n_create_socket(const char *name)\n{\n\tint fd;\n\tint len;\n\tstruct sockaddr_un addr;\n\n\t/* create a unix domain stream socket */\n\tif ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn -1;\n\tfd_set_close_on_exec(fd);\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tstrcpy(addr.sun_path, name);\n\tlen = strlen(addr.sun_path)+1 + sizeof(addr.sun_family);\n\n\t/* bind the name to the descriptor */\n\tif (bind(fd, (struct sockaddr *) &addr, len) < 0)\n\t\treturn -2;\n\n\tif (listen(fd, 32) < 0)\n\t\treturn -3;\n\n\treturn fd;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int\n_create_socket(const char *name)\n{\n\tint fd;\n\tint len;\n\tstruct sockaddr_un addr;\n\n\t/* create a unix domain stream socket */\n\tif ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn -1;\n\tfd_set_close_on_exec(fd);\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tstrcpy(addr.sun_path, name);\n\tlen = strlen(addr.sun_path)+1 + sizeof(addr.sun_family);\n\n\t/* bind the name to the descriptor */\n\tif (bind(fd, (struct sockaddr *) &addr, len) < 0)\n\t\treturn -2;\n\n\tif (listen(fd, 32) < 0)\n\t\treturn -3;\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "name"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s: failed unlink(%s) job %u step %u %m\"",
            "__func__",
            "name",
            "jobid",
            "stepid"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlink",
          "args": [
            "name"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stat",
          "args": [
            "name",
            "&stat_buf"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "597-605",
          "snippet": "static int\n_handle_state(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->state, sizeof(slurmstepd_state_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\n\nstatic int\n_handle_state(int fd, stepd_step_rec_t *job)\n{\n\tsafe_write(fd, &job->state, sizeof(slurmstepd_state_t));\n\n\treturn SLURM_SUCCESS;\nrwfail:\n\treturn SLURM_FAILURE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrfmtcat",
          "args": [
            "name",
            "\"%s/%s_%u.%u\"",
            "dir",
            "nodename",
            "jobid",
            "stepid"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"%s is not a directory\"",
            "dir"
          ],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "_prolog_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/req.c",
          "lines": "1386-1434",
          "snippet": "static void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/reverse_tree_math.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/bcast/file_bcast.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_protocol_interface.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_protocol_defs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/siphash.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/callerid.h\"",
            "#include <utime.h>",
            "#include <unistd.h>",
            "#include <sys/wait.h>",
            "#include <sys/un.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <poll.h>",
            "#include <sys/param.h>",
            "#include <time.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <sched.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _is_batch_job_finished(uint32_t job_id);",
            "static bool _job_still_running(uint32_t job_id);",
            "static void _launch_complete_add(uint32_t job_id);",
            "static void _launch_complete_log(char *type, uint32_t job_id);",
            "static void _launch_complete_rm(uint32_t job_id);",
            "static void _launch_complete_wait(uint32_t job_id);",
            "static bool _launch_job_test(uint32_t job_id);",
            "static void _note_batch_job_finished(uint32_t job_id);",
            "static bool _slurm_authorized_user(uid_t uid);",
            "static void _sync_messages_kill(kill_job_msg_t *req);",
            "static int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);",
            "static gids_t *_gids_cache_lookup(char *user, gid_t gid);",
            "static int  _add_starting_step(uint16_t type, void *req);",
            "static int  _remove_starting_step(uint16_t type, void *req);",
            "static void _add_job_running_prolog(uint32_t job_id);",
            "static void _remove_job_running_prolog(uint32_t job_id);",
            "static void _wait_for_job_running_prolog(uint32_t job_id);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/reverse_tree_math.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/bcast/file_bcast.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_protocol_interface.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_protocol_defs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/siphash.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/callerid.h\"\n#include <utime.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <sys/un.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <poll.h>\n#include <sys/param.h>\n#include <time.h>\n#include <string.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <sched.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#  include \"config.h\"\n\nstatic bool _is_batch_job_finished(uint32_t job_id);\nstatic bool _job_still_running(uint32_t job_id);\nstatic void _launch_complete_add(uint32_t job_id);\nstatic void _launch_complete_log(char *type, uint32_t job_id);\nstatic void _launch_complete_rm(uint32_t job_id);\nstatic void _launch_complete_wait(uint32_t job_id);\nstatic bool _launch_job_test(uint32_t job_id);\nstatic void _note_batch_job_finished(uint32_t job_id);\nstatic bool _slurm_authorized_user(uid_t uid);\nstatic void _sync_messages_kill(kill_job_msg_t *req);\nstatic int  _valid_sbcast_cred(file_bcast_msg_t *req, uid_t req_uid,\n\t\t\t       uint16_t block_no, uint32_t *job_id);\nstatic gids_t *_gids_cache_lookup(char *user, gid_t gid);\nstatic int  _add_starting_step(uint16_t type, void *req);\nstatic int  _remove_starting_step(uint16_t type, void *req);\nstatic void _add_job_running_prolog(uint32_t job_id);\nstatic void _remove_job_running_prolog(uint32_t job_id);\nstatic void _wait_for_job_running_prolog(uint32_t job_id);\n\nstatic void\n_prolog_error(batch_job_launch_msg_t *req, int rc)\n{\n\tchar *err_name_ptr, err_name[256], path_name[MAXPATHLEN];\n\tchar *fmt_char;\n\tint fd;\n\n\tif (req->std_err || req->std_out) {\n\t\tif (req->std_err)\n\t\t\tstrncpy(err_name, req->std_err, sizeof(err_name));\n\t\telse\n\t\t\tstrncpy(err_name, req->std_out, sizeof(err_name));\n\t\tif ((fmt_char = strchr(err_name, (int) '%')) &&\n\t\t    (fmt_char[1] == 'j') && !strchr(fmt_char+1, (int) '%')) {\n\t\t\tchar tmp_name[256];\n\t\t\tfmt_char[1] = 'u';\n\t\t\tsnprintf(tmp_name, sizeof(tmp_name), err_name,\n\t\t\t\t req->job_id);\n\t\t\tstrncpy(err_name, tmp_name, sizeof(err_name));\n\t\t}\n\t} else {\n\t\tsnprintf(err_name, sizeof(err_name), \"slurm-%u.out\",\n\t\t\t req->job_id);\n\t}\n\terr_name_ptr = err_name;\n\tif (err_name_ptr[0] == '/')\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s\", err_name_ptr);\n\telse if (req->work_dir)\n\t\tsnprintf(path_name, MAXPATHLEN, \"%s/%s\",\n\t\t\treq->work_dir, err_name_ptr);\n\telse\n\t\tsnprintf(path_name, MAXPATHLEN, \"/%s\", err_name_ptr);\n\n\tif ((fd = open(path_name, (O_CREAT|O_APPEND|O_WRONLY), 0644)) == -1) {\n\t\terror(\"Unable to open %s: %s\", path_name,\n\t\t      slurm_strerror(errno));\n\t\treturn;\n\t}\n\tsnprintf(err_name, sizeof(err_name),\n\t\t \"Error running slurm prolog: %d\\n\", WEXITSTATUS(rc));\n\tsafe_write(fd, err_name, strlen(err_name));\n\tif (fchown(fd, (uid_t) req->uid, (gid_t) req->gid) == -1) {\n\t\tsnprintf(err_name, sizeof(err_name),\n\t\t\t \"Couldn't change fd owner to %u:%u: %m\\n\",\n\t\t\t req->uid, req->gid);\n\t}\nrwfail:\n\tclose(fd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "S_ISDIR",
          "args": [
            "stat_buf.st_mode"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstatic char *socket_name;\n\nstatic int\n_domain_socket_create(const char *dir, const char *nodename,\n\t\t     uint32_t jobid, uint32_t stepid)\n{\n\tint fd;\n\tchar *name = NULL;\n\tstruct stat stat_buf;\n\n\t/*\n\t * Make sure that \"dir\" exists and is a directory.\n\t */\n\tif (stat(dir, &stat_buf) < 0) {\n\t\terror(\"Domain socket directory %s: %m\", dir);\n\t\treturn -1;\n\t} else if (!S_ISDIR(stat_buf.st_mode)) {\n\t\terror(\"%s is not a directory\", dir);\n\t\treturn -1;\n\t}\n\n\t/*\n\t * Now build the name of socket, and create the socket.\n\t */\n\txstrfmtcat(name, \"%s/%s_%u.%u\", dir, nodename, jobid, stepid);\n\n\t/*\n\t * First check to see if the named socket already exists.\n\t */\n\tif (stat(name, &stat_buf) == 0) {\n\t\t/* Vestigial from a slurmd crash or job requeue that did not\n\t\t * happen properly (very rare conditions). Unlink the file\n\t\t * and recreate it.\n\t\t */\n\t\tif (unlink(name) != 0) {\n\t\t\terror(\"%s: failed unlink(%s) job %u step %u %m\",\n\t\t\t      __func__, name, jobid, stepid);\n\t\t\txfree(name);\n\t\t\terrno = ESLURMD_STEP_EXISTS;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n\tfd = _create_socket(name);\n\tif (fd < 0)\n\t\tfatal(\"Could not create domain socket: %m\");\n\n\tchmod(name, 0777);\n\tsocket_name = name;\n\treturn fd;\n}"
  },
  {
    "function_name": "_create_socket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "146-171",
    "snippet": "static int\n_create_socket(const char *name)\n{\n\tint fd;\n\tint len;\n\tstruct sockaddr_un addr;\n\n\t/* create a unix domain stream socket */\n\tif ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn -1;\n\tfd_set_close_on_exec(fd);\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tstrcpy(addr.sun_path, name);\n\tlen = strlen(addr.sun_path)+1 + sizeof(addr.sun_family);\n\n\t/* bind the name to the descriptor */\n\tif (bind(fd, (struct sockaddr *) &addr, len) < 0)\n\t\treturn -2;\n\n\tif (listen(fd, 32) < 0)\n\t\treturn -3;\n\n\treturn fd;\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "listen",
          "args": [
            "fd",
            "32"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bind",
          "args": [
            "fd",
            "(struct sockaddr *) &addr",
            "len"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "addr.sun_path"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "addr.sun_path",
            "name"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&addr",
            "0",
            "sizeof(addr)"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_close_on_exec",
          "args": [
            "fd"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "socket",
          "args": [
            "AF_UNIX",
            "SOCK_STREAM",
            "0"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int\n_create_socket(const char *name)\n{\n\tint fd;\n\tint len;\n\tstruct sockaddr_un addr;\n\n\t/* create a unix domain stream socket */\n\tif ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t\treturn -1;\n\tfd_set_close_on_exec(fd);\n\n\tmemset(&addr, 0, sizeof(addr));\n\taddr.sun_family = AF_UNIX;\n\tstrcpy(addr.sun_path, name);\n\tlen = strlen(addr.sun_path)+1 + sizeof(addr.sun_family);\n\n\t/* bind the name to the descriptor */\n\tif (bind(fd, (struct sockaddr *) &addr, len) < 0)\n\t\treturn -2;\n\n\tif (listen(fd, 32) < 0)\n\t\treturn -3;\n\n\treturn fd;\n}"
  },
  {
    "function_name": "_slurm_authorized_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
    "lines": "136-140",
    "snippet": "static bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}",
    "includes": [
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/pdebug.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/timers.h\"",
      "#include \"src/common/checkpoint.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_acct_gather.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/common/parse_time.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <stdlib.h>",
      "#include <time.h>",
      "#include <signal.h>",
      "#include <unistd.h>",
      "#include <sys/stat.h>",
      "#include <sys/un.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);",
      "static int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_signal_task_local(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_signal_container(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_checkpoint_tasks(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_attach(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_notify_job(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_suspend(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_resume(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_terminate(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_completion(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_stat_jobacct(int fd, stepd_step_rec_t *job, uid_t uid);\nstatic int _handle_reconfig(int fd, stepd_step_rec_t *job, uid_t uid);\n\nstatic bool\n_slurm_authorized_user(uid_t uid)\n{\n\treturn ((uid == (uid_t) 0) || (uid == conf->slurm_user_id));\n}"
  }
]