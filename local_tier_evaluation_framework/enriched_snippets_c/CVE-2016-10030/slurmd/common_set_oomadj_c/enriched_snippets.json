[
  {
    "function_name": "set_oom_adj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/set_oomadj.c",
    "lines": "93-98",
    "snippet": "extern int set_oom_adj(int adj)\n{\n\t/* FreeBSD does not handle OOM the same way Linux does */\n\t(void) adj; /* unused argument */\n\treturn 0;\n}",
    "includes": [
      "#include \"src/common/log.h\"",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"src/common/log.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n\nextern int set_oom_adj(int adj)\n{\n\t/* FreeBSD does not handle OOM the same way Linux does */\n\t(void) adj; /* unused argument */\n\treturn 0;\n}"
  },
  {
    "function_name": "set_oom_adj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/set_oomadj.c",
    "lines": "48-89",
    "snippet": "extern int set_oom_adj(int adj)\n{\n\tint fd;\n\tchar oom_adj[16];\n\tchar *oom_adj_file = \"/proc/self/oom_score_adj\";\n\n\tfd = open(oom_adj_file, O_WRONLY);\n\tif (fd < 0) {\n\t\tif (errno == ENOENT) {\n\t\t\tdebug(\"%s not found. Falling back to oom_adj\",\n\t\t\t      oom_adj_file);\n\t\t\toom_adj_file = \"/proc/self/oom_adj\";\n\t\t\tfd = open(oom_adj_file, O_WRONLY);\n\t\t\tif (fd < 0) {\n\t\t\t\tif (errno == ENOENT)\n\t\t\t\t\terror(\"%s not found\", oom_adj_file);\n\t\t\t\telse\n\t\t\t\t\terror(\"failed to open %s: %m\",\n\t\t\t\t\t      oom_adj_file);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* Convert range from [-1000,1000] to [-17,15]\n\t\t\t * for use with older Linux kernel before 2.6.36 */\n\t\t\tif (adj < 0)\n\t\t\t\tadj = (adj * 17) / 1000;\n\t\t\telse if (adj > 0)\n\t\t\t\tadj = (adj * 15) / 1000;\n\t\t} else {\n\t\t\terror(\"failed to open %s: %m\", oom_adj_file);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (snprintf(oom_adj, 16, \"%d\", adj) >= 16) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\twhile ((write(fd, oom_adj, strlen(oom_adj)) < 0) && (errno == EINTR))\n\t\t;\n\tclose(fd);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"src/common/log.h\"",
      "#include <sys/stat.h>",
      "#include <sys/types.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <errno.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "io_close_local_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1463-1487",
          "snippet": "void\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static bool _task_writable(eio_obj_t *);",
            "static bool _task_readable(eio_obj_t *);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void *_io_thr(void *arg);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nvoid\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "fd",
            "oom_adj",
            "strlen(oom_adj)"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "_file_write_content",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcgroup.c",
          "lines": "1116-1147",
          "snippet": "int _file_write_content(char* file_path, char* content, size_t csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\t/* open file for writing */\n\tfd = open(file_path, O_WRONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for writing : %m\",\n\t\t\t__func__, file_path);\n\t\treturn XCGROUP_ERROR;\n\t}\n\n\t/* write content */\n\tdo {\n\t\trc = write(fd, content, csize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* check read size */\n\tif (rc < csize) {\n\t\tdebug2(\"%s: unable to write %lu bytes to file '%s' : %m\",\n\t\t\t__func__, (long unsigned int) csize, file_path);\n\t\tfstatus = XCGROUP_ERROR;\n\t} else\n\t\tfstatus = XCGROUP_SUCCESS;\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}",
          "includes": [
            "#include \"xcgroup.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "size_t _file_getsize(int fd);",
            "int _file_read_content(char* file_path, char** content, size_t *csize);",
            "int _file_write_content(char* file_path, char* content, size_t csize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcgroup.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <sys/mount.h>\n#include <dirent.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nsize_t _file_getsize(int fd);\nint _file_read_content(char* file_path, char** content, size_t *csize);\nint _file_write_content(char* file_path, char* content, size_t csize);\n\nint _file_write_content(char* file_path, char* content, size_t csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\t/* open file for writing */\n\tfd = open(file_path, O_WRONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for writing : %m\",\n\t\t\t__func__, file_path);\n\t\treturn XCGROUP_ERROR;\n\t}\n\n\t/* write content */\n\tdo {\n\t\trc = write(fd, content, csize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* check read size */\n\tif (rc < csize) {\n\t\tdebug2(\"%s: unable to write %lu bytes to file '%s' : %m\",\n\t\t\t__func__, (long unsigned int) csize, file_path);\n\t\tfstatus = XCGROUP_ERROR;\n\t} else\n\t\tfstatus = XCGROUP_SUCCESS;\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "oom_adj"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "oom_adj",
            "16",
            "\"%d\"",
            "adj"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"failed to open %s: %m\"",
            "oom_adj_file"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "_task_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "641-650",
          "snippet": "static int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static bool _task_writable(eio_obj_t *);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int _task_write_error(eio_obj_t *obj, List objs);",
            "static bool _task_readable(eio_obj_t *);",
            "static int  _task_read(eio_obj_t *, List);",
            "static void _route_msg_task_to_client(eio_obj_t *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "oom_adj_file",
            "O_WRONLY"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"%s not found. Falling back to oom_adj\"",
            "oom_adj_file"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_wake_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "187-199",
          "snippet": "void pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "oom_adj_file",
            "O_WRONLY"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/common/log.h\"\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <string.h>\n#include <stdio.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <errno.h>\n\nextern int set_oom_adj(int adj)\n{\n\tint fd;\n\tchar oom_adj[16];\n\tchar *oom_adj_file = \"/proc/self/oom_score_adj\";\n\n\tfd = open(oom_adj_file, O_WRONLY);\n\tif (fd < 0) {\n\t\tif (errno == ENOENT) {\n\t\t\tdebug(\"%s not found. Falling back to oom_adj\",\n\t\t\t      oom_adj_file);\n\t\t\toom_adj_file = \"/proc/self/oom_adj\";\n\t\t\tfd = open(oom_adj_file, O_WRONLY);\n\t\t\tif (fd < 0) {\n\t\t\t\tif (errno == ENOENT)\n\t\t\t\t\terror(\"%s not found\", oom_adj_file);\n\t\t\t\telse\n\t\t\t\t\terror(\"failed to open %s: %m\",\n\t\t\t\t\t      oom_adj_file);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\t/* Convert range from [-1000,1000] to [-17,15]\n\t\t\t * for use with older Linux kernel before 2.6.36 */\n\t\t\tif (adj < 0)\n\t\t\t\tadj = (adj * 17) / 1000;\n\t\t\telse if (adj > 0)\n\t\t\t\tadj = (adj * 15) / 1000;\n\t\t} else {\n\t\t\terror(\"failed to open %s: %m\", oom_adj_file);\n\t\t\treturn -1;\n\t\t}\n\t}\n\tif (snprintf(oom_adj, 16, \"%d\", adj) >= 16) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\twhile ((write(fd, oom_adj, strlen(oom_adj)) < 0) && (errno == EINTR))\n\t\t;\n\tclose(fd);\n\n\treturn 0;\n}"
  }
]