[
  {
    "function_name": "task_g_add_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "430-443",
    "snippet": "extern int task_g_add_pid(pid_t pid)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].add_pid))(pid);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "pid"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurmd_task_init",
          "args": [],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "103-157",
          "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_add_pid(pid_t pid)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].add_pid))(pid);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "task_g_post_step",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "410-423",
    "snippet": "extern int task_g_post_step(stepd_step_rec_t *job)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].post_step))(job);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "job"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurmd_task_init",
          "args": [],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "103-157",
          "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_post_step(stepd_step_rec_t *job)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].post_step))(job);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "task_g_post_term",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "389-403",
    "snippet": "extern int task_g_post_term(stepd_step_rec_t *job,\n\t\t     stepd_step_task_info_t *task)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].post_term))(job, task);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "job",
            "task"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurmd_task_init",
          "args": [],
          "line": 394
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "103-157",
          "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_post_term(stepd_step_rec_t *job,\n\t\t     stepd_step_task_info_t *task)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].post_term))(job, task);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "task_g_pre_launch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "369-382",
    "snippet": "extern int task_g_pre_launch(stepd_step_rec_t *job)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].pre_launch))(job);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "job"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurmd_task_init",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "103-157",
          "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_pre_launch(stepd_step_rec_t *job)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].pre_launch))(job);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "task_g_pre_launch_priv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "349-362",
    "snippet": "extern int task_g_pre_launch_priv(stepd_step_rec_t *job)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].pre_launch_priv))(job);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "job"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurmd_task_init",
          "args": [],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "103-157",
          "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_pre_launch_priv(stepd_step_rec_t *job)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].pre_launch_priv))(job);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "task_g_pre_setuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "329-342",
    "snippet": "extern int task_g_pre_setuid(stepd_step_rec_t *job)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].pre_setuid))(job);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "job"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurmd_task_init",
          "args": [],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "103-157",
          "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_pre_setuid(stepd_step_rec_t *job)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].pre_setuid))(job);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "task_g_slurmd_release_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "306-321",
    "snippet": "extern int task_g_slurmd_release_resources(uint32_t job_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++) {\n\t\trc = (*(ops[i].slurmd_release_resources))\n\t\t\t\t(job_id);\n\t}\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "job_id"
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurmd_task_init",
          "args": [],
          "line": 310
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "103-157",
          "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_slurmd_release_resources(uint32_t job_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++) {\n\t\trc = (*(ops[i].slurmd_release_resources))\n\t\t\t\t(job_id);\n\t}\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "task_g_slurmd_resume_job",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "286-299",
    "snippet": "extern int task_g_slurmd_resume_job(uint32_t job_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].slurmd_resume_job))(job_id);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "job_id"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurmd_task_init",
          "args": [],
          "line": 290
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "103-157",
          "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_slurmd_resume_job(uint32_t job_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].slurmd_resume_job))(job_id);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "task_g_slurmd_suspend_job",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "266-279",
    "snippet": "extern int task_g_slurmd_suspend_job(uint32_t job_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].slurmd_suspend_job))(job_id);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "job_id"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurmd_task_init",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "103-157",
          "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_slurmd_suspend_job(uint32_t job_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++)\n\t\trc = (*(ops[i].slurmd_suspend_job))(job_id);\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "task_g_slurmd_reserve_resources",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "242-259",
    "snippet": "extern int task_g_slurmd_reserve_resources(uint32_t job_id,\n\t\t\t\t    launch_tasks_request_msg_t *req,\n\t\t\t\t    uint32_t node_id )\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++) {\n\t\trc = (*(ops[i].slurmd_reserve_resources))\n\t\t\t\t\t(job_id, req, node_id);\n\t}\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "job_id",
            "req",
            "node_id"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurmd_task_init",
          "args": [],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "103-157",
          "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_slurmd_reserve_resources(uint32_t job_id,\n\t\t\t\t    launch_tasks_request_msg_t *req,\n\t\t\t\t    uint32_t node_id )\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++) {\n\t\trc = (*(ops[i].slurmd_reserve_resources))\n\t\t\t\t\t(job_id, req, node_id);\n\t}\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "task_g_slurmd_launch_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "218-235",
    "snippet": "extern int task_g_slurmd_launch_request(uint32_t job_id,\n\t\t\t\t launch_tasks_request_msg_t *req,\n\t\t\t\t uint32_t node_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++) {\n\t\trc = (*(ops[i].slurmd_launch_request))\n\t\t\t\t\t(job_id, req, node_id);\n\t}\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "job_id",
            "req",
            "node_id"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurmd_task_init",
          "args": [],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "103-157",
          "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_slurmd_launch_request(uint32_t job_id,\n\t\t\t\t launch_tasks_request_msg_t *req,\n\t\t\t\t uint32_t node_id)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++) {\n\t\trc = (*(ops[i].slurmd_launch_request))\n\t\t\t\t\t(job_id, req, node_id);\n\t}\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "task_g_slurmd_batch_request",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "196-211",
    "snippet": "extern int task_g_slurmd_batch_request(uint32_t job_id,\n\t\t\t\t       batch_job_launch_msg_t *req)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++) {\n\t\trc = (*(ops[i].slurmd_batch_request))(job_id, req);\n\t}\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "job_id",
            "req"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurmd_task_init",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "103-157",
          "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\n\nextern int task_g_slurmd_batch_request(uint32_t job_id,\n\t\t\t\t       batch_job_launch_msg_t *req)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (slurmd_task_init())\n\t\treturn SLURM_ERROR;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tfor (i = 0; ((i < g_task_context_num) && (rc == SLURM_SUCCESS)); i++) {\n\t\trc = (*(ops[i].slurmd_batch_request))(job_id, req);\n\t}\n\tslurm_mutex_unlock( &g_task_context_lock );\n\n\treturn (rc);\n}"
  },
  {
    "function_name": "slurmd_task_fini",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "164-189",
    "snippet": "extern int slurmd_task_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tif (!g_task_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_task_context_num; i++) {\n\t\tif (g_task_context[i]) {\n\t\t\tif (plugin_context_destroy(g_task_context[i]) !=\n\t\t\t    SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_task_context);\n\tg_task_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static slurmd_task_ops_t *ops = NULL;",
      "static plugin_context_t\t**g_task_context = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
      "static bool init_run = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "g_task_context"
          ],
          "line": 183
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "plugin_context_destroy",
          "args": [
            "g_task_context[i]"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tif (!g_task_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_task_context_num; i++) {\n\t\tif (g_task_context[i]) {\n\t\t\tif (plugin_context_destroy(g_task_context[i]) !=\n\t\t\t    SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_task_context);\n\tg_task_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\treturn rc;\n}"
  },
  {
    "function_name": "slurmd_task_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
    "lines": "103-157",
    "snippet": "extern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/common/task_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/slurm_protocol_api.h\"",
      "#include \"src/common/plugrack.h\"",
      "#include \"src/common/plugin.h\"",
      "#include <pthread.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};",
      "static slurmd_task_ops_t *ops = NULL;",
      "static plugin_context_t\t**g_task_context = NULL;",
      "static int\t\t\tg_task_context_num = -1;",
      "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
      "static bool init_run = false;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurmd_task_fini",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "slurmd_task_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/task_plugin.c",
          "lines": "164-189",
          "snippet": "extern int slurmd_task_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tif (!g_task_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_task_context_num; i++) {\n\t\tif (g_task_context[i]) {\n\t\t\tif (plugin_context_destroy(g_task_context[i]) !=\n\t\t\t    SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_task_context);\n\tg_task_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\treturn rc;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static slurmd_task_ops_t *ops = NULL;",
            "static plugin_context_t\t**g_task_context = NULL;",
            "static int\t\t\tg_task_context_num = -1;",
            "static pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\tif (!g_task_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_task_context_num; i++) {\n\t\tif (g_task_context[i]) {\n\t\t\tif (plugin_context_destroy(g_task_context[i]) !=\n\t\t\t    SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_task_context);\n\tg_task_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "task_plugin_type"
          ],
          "line": 151
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"cannot create %s context for %s\"",
            "plugin_type",
            "type"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "plugin_context_create",
          "args": [
            "plugin_type",
            "type",
            "(void **)&ops[g_task_context_num]",
            "syms",
            "sizeof(syms)"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup_printf",
          "args": [
            "\"task/%s\"",
            "type"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrncmp",
          "args": [
            "type",
            "\"task/\"",
            "5"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xrealloc",
          "args": [
            "g_task_context",
            "(sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1))"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xrealloc",
          "args": [
            "ops",
            "sizeof(slurmd_task_ops_t) * (g_task_context_num + 1)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok_r",
          "args": [
            "task_plugin_list",
            "\",\"",
            "&last"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_get_task_plugin",
          "args": [],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&g_task_context_lock"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic const char *syms[] = {\n\t\"task_p_slurmd_batch_request\",\n\t\"task_p_slurmd_launch_request\",\n\t\"task_p_slurmd_reserve_resources\",\n\t\"task_p_slurmd_suspend_job\",\n\t\"task_p_slurmd_resume_job\",\n\t\"task_p_slurmd_release_resources\",\n\t\"task_p_pre_setuid\",\n\t\"task_p_pre_launch_priv\",\n\t\"task_p_pre_launch\",\n\t\"task_p_post_term\",\n\t\"task_p_post_step\",\n\t\"task_p_add_pid\",\n};\nstatic slurmd_task_ops_t *ops = NULL;\nstatic plugin_context_t\t**g_task_context = NULL;\nstatic int\t\t\tg_task_context_num = -1;\nstatic pthread_mutex_t\t\tg_task_context_lock = PTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int slurmd_task_init(void)\n{\n\tint retval = SLURM_SUCCESS;\n\tchar *plugin_type = \"task\";\n\tchar *task_plugin_type = NULL;\n\tchar *last = NULL, *task_plugin_list, *type = NULL;\n\n\tif ( init_run && (g_task_context_num >= 0) )\n\t\treturn retval;\n\n\tslurm_mutex_lock( &g_task_context_lock );\n\n\tif ( g_task_context_num >= 0 )\n\t\tgoto done;\n\n\ttask_plugin_type = slurm_get_task_plugin();\n\tg_task_context_num = 0; /* mark it before anything else */\n\tif (task_plugin_type == NULL || task_plugin_type[0] == '\\0')\n\t\tgoto done;\n\n\ttask_plugin_list = task_plugin_type;\n\twhile ((type = strtok_r(task_plugin_list, \",\", &last))) {\n\t\txrealloc(ops,\n\t\t\t sizeof(slurmd_task_ops_t) * (g_task_context_num + 1));\n\t\txrealloc(g_task_context, (sizeof(plugin_context_t *)\n\t\t\t\t\t  * (g_task_context_num + 1)));\n\t\tif (xstrncmp(type, \"task/\", 5) == 0)\n\t\t\ttype += 5; /* backward compatibility */\n\t\ttype = xstrdup_printf(\"task/%s\", type);\n\t\tg_task_context[g_task_context_num] = plugin_context_create(\n\t\t\tplugin_type, type, (void **)&ops[g_task_context_num],\n\t\t\tsyms, sizeof(syms));\n\t\tif (!g_task_context[g_task_context_num]) {\n\t\t\terror(\"cannot create %s context for %s\",\n\t\t\t      plugin_type, type);\n\t\t\txfree(type);\n\t\t\tretval = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\n\t\txfree(type);\n\t\tg_task_context_num++;\n\t\ttask_plugin_list = NULL; /* for next iteration */\n\t}\n\tinit_run = true;\n\n done:\n\tslurm_mutex_unlock( &g_task_context_lock );\n\txfree(task_plugin_type);\n\n\tif (retval != SLURM_SUCCESS)\n\t\tslurmd_task_fini();\n\n\treturn retval;\n}"
  }
]