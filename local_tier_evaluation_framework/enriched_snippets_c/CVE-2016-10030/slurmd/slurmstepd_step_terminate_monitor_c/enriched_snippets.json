[
  {
    "function_name": "_call_external_program",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/step_terminate_monitor.c",
    "lines": "149-234",
    "snippet": "static int _call_external_program(void)\n{\n\tint status, rc, opt;\n\tpid_t cpid;\n\tint max_wait = 300; /* seconds */\n\tint time_remaining;\n\n\tdebug(\"step_terminate_monitor: unkillable after %d sec, calling: %s\",\n\t     timeout, program_name);\n\n\tif (program_name == NULL || program_name[0] == '\\0')\n\t\treturn 0;\n\n\tif (access(program_name, R_OK | X_OK) < 0) {\n\t\tdebug(\"step_terminate_monitor not running %s: %m\",\n\t\t      program_name);\n\t\treturn 0;\n\t}\n\n\tif ((cpid = fork()) < 0) {\n\t\terror(\"step_terminate_monitor executing %s: fork: %m\",\n\t\t      program_name);\n\t\treturn -1;\n\t}\n\tif (cpid == 0) {\n\t\t/* child */\n\t\tchar *argv[2];\n\t\tchar buf[16];\n\n\t\t/* container_g_add_pid needs to be called in the\n\t\t   forked process part of the fork to avoid a race\n\t\t   condition where if this process makes a file or\n\t\t   detacts itself from a child before we add the pid\n\t\t   to the container in the parent of the fork.\n\t\t*/\n\t\tif (container_g_add_pid(recorded_jobid, getpid(), getuid())\n\t\t    != SLURM_SUCCESS)\n\t\t\terror(\"container_g_add_pid(%u): %m\", recorded_jobid);\n\n\t\tsnprintf(buf, 16, \"%u\", recorded_jobid);\n\t\tsetenv(\"SLURM_JOBID\", buf, 1);\n\t\tsetenv(\"SLURM_JOB_ID\", buf, 1);\n\t\tsnprintf(buf, 16, \"%u\", recorded_stepid);\n\t\tsetenv(\"SLURM_STEPID\", buf, 1);\n\t\tsetenv(\"SLURM_STEP_ID\", buf, 1);\n\n\t\targv[0] = program_name;\n\t\targv[1] = NULL;\n\n#ifdef SETPGRP_TWO_ARGS\n\t\tsetpgrp(0, 0);\n#else\n\t\tsetpgrp();\n#endif\n\t\texecv(program_name, argv);\n\t\terror(\"step_terminate_monitor execv(): %m\");\n\t\texit(127);\n\t}\n\n\topt = WNOHANG;\n\ttime_remaining = max_wait;\n\twhile (1) {\n\t\trc = waitpid(cpid, &status, opt);\n\t\tif (rc < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\t/* waitpid may very well fail under normal conditions\n\t\t\t   because the wait3() in mgr.c:_wait_for_any_task()\n\t\t\t   may have reaped the return code. */\n\t\t\treturn 0;\n\t\t} else if (rc == 0) {\n\t\t\tsleep(1);\n\t\t\tif ((--time_remaining) == 0) {\n\t\t\t\terror(\"step_terminate_monitor: %s still running\"\n\t\t\t\t      \" after %d seconds.  Killing.\",\n\t\t\t\t      program_name, max_wait);\n\t\t\t\tkillpg(cpid, SIGKILL);\n\t\t\t\topt = 0;\n\t\t\t}\n\t\t} else  {\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t/* NOTREACHED */\n}",
    "includes": [
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <sys/errno.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/common/job_container_plugin.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/macros.h\"",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static uint16_t timeout;",
      "static char *program_name;",
      "static uint32_t recorded_jobid = NO_VAL;",
      "static uint32_t recorded_stepid = NO_VAL;",
      "static int _call_external_program(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "killpg",
          "args": [
            "cpid",
            "SIGKILL"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"step_terminate_monitor: %s still running\"\n\t\t\t\t      \" after %d seconds.  Killing.\"",
            "program_name",
            "max_wait"
          ],
          "line": 222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sleep",
          "args": [
            "1"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "_random_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "664-678",
          "snippet": "static void\n_random_sleep(stepd_step_rec_t *job)\n{\n#if !defined HAVE_FRONT_END\n\tlong int delay = 0;\n\tlong int max   = (slurm_get_tcp_timeout() * job->nnodes);\n\n\tmax = MIN(max, 5000);\n\tsrand48((long int) (job->jobid + job->nodeid));\n\n\tdelay = lrand48() % ( max + 1 );\n\tdebug3(\"delaying %ldms\", delay);\n\tpoll(NULL, 0, delay);\n#endif\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int _initgroups(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int _initgroups(stepd_step_rec_t *job);\n\nstatic void\n_random_sleep(stepd_step_rec_t *job)\n{\n#if !defined HAVE_FRONT_END\n\tlong int delay = 0;\n\tlong int max   = (slurm_get_tcp_timeout() * job->nnodes);\n\n\tmax = MIN(max, 5000);\n\tsrand48((long int) (job->jobid + job->nodeid));\n\n\tdelay = lrand48() % ( max + 1 );\n\tdebug3(\"delaying %ldms\", delay);\n\tpoll(NULL, 0, delay);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "waitpid",
          "args": [
            "cpid",
            "&status",
            "opt"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "127"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "_send_pending_exit_msgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "1890-1927",
          "snippet": "static int\n_send_pending_exit_msgs(stepd_step_rec_t *job)\n{\n\tint  i;\n\tint  nsent  = 0;\n\tint  status = 0;\n\tbool set    = false;\n\tuint32_t *tid;\n\n\t/*\n\t * Collect all exit codes with the same status into a\n\t * single message.\n\t */\n\ttid = xmalloc(sizeof(uint32_t) * job->node_tasks);\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tstepd_step_task_info_t *t = job->task[i];\n\n\t\tif (!t->exited || t->esent)\n\t\t\tcontinue;\n\n\t\tif (!set) {\n\t\t\tstatus = t->estatus;\n\t\t\tset    = true;\n\t\t} else if (status != t->estatus)\n\t\t\tcontinue;\n\n\t\ttid[nsent++] = t->gtid;\n\t\tt->esent = true;\n\t}\n\n\tif (nsent) {\n\t\tdebug2(\"Aggregated %d task exit messages\", nsent);\n\t\t_send_exit_msg(job, tid, nsent, status);\n\t}\n\txfree(tid);\n\n\treturn nsent;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static int  _send_exit_msg(stepd_step_rec_t *job, uint32_t *tid, int n,\n\t\t\t   int status);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int    _send_complete_batch_script_msg(stepd_step_rec_t *job,\n\t\t\t\t\t      int err, int status);",
            "static int _initgroups(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic int  _send_exit_msg(stepd_step_rec_t *job, uint32_t *tid, int n,\n\t\t\t   int status);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int    _send_complete_batch_script_msg(stepd_step_rec_t *job,\n\t\t\t\t\t      int err, int status);\nstatic int _initgroups(stepd_step_rec_t *job);\n\nstatic int\n_send_pending_exit_msgs(stepd_step_rec_t *job)\n{\n\tint  i;\n\tint  nsent  = 0;\n\tint  status = 0;\n\tbool set    = false;\n\tuint32_t *tid;\n\n\t/*\n\t * Collect all exit codes with the same status into a\n\t * single message.\n\t */\n\ttid = xmalloc(sizeof(uint32_t) * job->node_tasks);\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tstepd_step_task_info_t *t = job->task[i];\n\n\t\tif (!t->exited || t->esent)\n\t\t\tcontinue;\n\n\t\tif (!set) {\n\t\t\tstatus = t->estatus;\n\t\t\tset    = true;\n\t\t} else if (status != t->estatus)\n\t\t\tcontinue;\n\n\t\ttid[nsent++] = t->gtid;\n\t\tt->esent = true;\n\t}\n\n\tif (nsent) {\n\t\tdebug2(\"Aggregated %d task exit messages\", nsent);\n\t\t_send_exit_msg(job, tid, nsent, status);\n\t}\n\txfree(tid);\n\n\treturn nsent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"step_terminate_monitor execv(): %m\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "execv",
          "args": [
            "program_name",
            "argv"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setpgrp",
          "args": [],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setpgrp",
          "args": [
            "0",
            "0"
          ],
          "line": 199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"SLURM_STEP_ID\"",
            "buf",
            "1"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"SLURM_STEPID\"",
            "buf",
            "1"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "16",
            "\"%u\"",
            "recorded_stepid"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"SLURM_JOB_ID\"",
            "buf",
            "1"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "setenv",
          "args": [
            "\"SLURM_JOBID\"",
            "buf",
            "1"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf",
            "16",
            "\"%u\"",
            "recorded_jobid"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"container_g_add_pid(%u): %m\"",
            "recorded_jobid"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "_task_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "641-650",
          "snippet": "static int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static bool _task_writable(eio_obj_t *);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int _task_write_error(eio_obj_t *obj, List objs);",
            "static bool _task_readable(eio_obj_t *);",
            "static int  _task_read(eio_obj_t *, List);",
            "static void _route_msg_task_to_client(eio_obj_t *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_g_add_pid",
          "args": [
            "recorded_jobid",
            "getpid()",
            "getuid()"
          ],
          "line": 184
        },
        "resolved": true,
        "details": {
          "function_name": "container_g_add_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/job_container_plugin.c",
          "lines": "196-209",
          "snippet": "extern int container_g_add_pid(uint32_t job_id, pid_t pid, uid_t uid)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (job_container_init())\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_container_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].container_p_add_pid))(job_id, pid, uid);\n\t}\n\n\treturn rc;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static job_container_ops_t\t*ops = NULL;",
            "static int\t\t\tg_container_context_num = -1;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic job_container_ops_t\t*ops = NULL;\nstatic int\t\t\tg_container_context_num = -1;\n\nextern int container_g_add_pid(uint32_t job_id, pid_t pid, uid_t uid)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tif (job_container_init())\n\t\treturn SLURM_ERROR;\n\n\tfor (i = 0; ((i < g_container_context_num) && (rc == SLURM_SUCCESS));\n\t     i++) {\n\t\trc = (*(ops[i].container_p_add_pid))(job_id, pid, uid);\n\t}\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "getuid",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fork",
          "args": [],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "_install_fork_handlers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/slurmd.c",
          "lines": "1991-1999",
          "snippet": "static void _install_fork_handlers(void)\n{\n\tint err;\n\n\terr = pthread_atfork(&_atfork_prepare, &_atfork_final, &_atfork_final);\n\tif (err) error (\"pthread_atfork: %m\");\n\n\treturn;\n}",
          "includes": [
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/slurmd/slurmd_plugstack.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/slurmd/req.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_topology.h\"",
            "#include \"src/common/slurm_strcasestr.h\"",
            "#include \"src/common/slurm_route.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_mcs.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_acct_gather_energy.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/proc_args.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/parse_spec.h\"",
            "#include \"src/common/pack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/node_features.h\"",
            "#include \"src/common/node_conf.h\"",
            "#include \"src/common/msg_aggr.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/daemonize.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/bitstring.h\"",
            "#include <unistd.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/time.h>",
            "#include <sys/stat.h>",
            "#include <sys/resource.h>",
            "#include <sys/param.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <pthread.h>",
            "#include <grp.h>",
            "#include <fcntl.h>",
            "#include <dlfcn.h>",
            "#include <dirent.h>",
            "#  include <hwloc.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void      _atfork_final(void);",
            "static void      _atfork_prepare(void);",
            "static void      _install_fork_handlers(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/slurmd/slurmd_plugstack.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/slurmd/req.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_topology.h\"\n#include \"src/common/slurm_strcasestr.h\"\n#include \"src/common/slurm_route.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_mcs.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_acct_gather_energy.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/proc_args.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/parse_spec.h\"\n#include \"src/common/pack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/node_features.h\"\n#include \"src/common/node_conf.h\"\n#include \"src/common/msg_aggr.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/daemonize.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/bitstring.h\"\n#include <unistd.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/time.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/param.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdlib.h>\n#include <pthread.h>\n#include <grp.h>\n#include <fcntl.h>\n#include <dlfcn.h>\n#include <dirent.h>\n#  include <hwloc.h>\n#  include \"config.h\"\n\nstatic void      _atfork_final(void);\nstatic void      _atfork_prepare(void);\nstatic void      _install_fork_handlers(void);\n\nstatic void _install_fork_handlers(void)\n{\n\tint err;\n\n\terr = pthread_atfork(&_atfork_prepare, &_atfork_final, &_atfork_final);\n\tif (err) error (\"pthread_atfork: %m\");\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"step_terminate_monitor not running %s: %m\"",
            "program_name"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_wake_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "187-199",
          "snippet": "void pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "access",
          "args": [
            "program_name",
            "R_OK | X_OK"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"step_terminate_monitor: unkillable after %d sec, calling: %s\"",
            "timeout",
            "program_name"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <time.h>\n#include <pthread.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/macros.h\"\n#  include \"config.h\"\n\nstatic uint16_t timeout;\nstatic char *program_name;\nstatic uint32_t recorded_jobid = NO_VAL;\nstatic uint32_t recorded_stepid = NO_VAL;\nstatic int _call_external_program(void);\n\nstatic int _call_external_program(void)\n{\n\tint status, rc, opt;\n\tpid_t cpid;\n\tint max_wait = 300; /* seconds */\n\tint time_remaining;\n\n\tdebug(\"step_terminate_monitor: unkillable after %d sec, calling: %s\",\n\t     timeout, program_name);\n\n\tif (program_name == NULL || program_name[0] == '\\0')\n\t\treturn 0;\n\n\tif (access(program_name, R_OK | X_OK) < 0) {\n\t\tdebug(\"step_terminate_monitor not running %s: %m\",\n\t\t      program_name);\n\t\treturn 0;\n\t}\n\n\tif ((cpid = fork()) < 0) {\n\t\terror(\"step_terminate_monitor executing %s: fork: %m\",\n\t\t      program_name);\n\t\treturn -1;\n\t}\n\tif (cpid == 0) {\n\t\t/* child */\n\t\tchar *argv[2];\n\t\tchar buf[16];\n\n\t\t/* container_g_add_pid needs to be called in the\n\t\t   forked process part of the fork to avoid a race\n\t\t   condition where if this process makes a file or\n\t\t   detacts itself from a child before we add the pid\n\t\t   to the container in the parent of the fork.\n\t\t*/\n\t\tif (container_g_add_pid(recorded_jobid, getpid(), getuid())\n\t\t    != SLURM_SUCCESS)\n\t\t\terror(\"container_g_add_pid(%u): %m\", recorded_jobid);\n\n\t\tsnprintf(buf, 16, \"%u\", recorded_jobid);\n\t\tsetenv(\"SLURM_JOBID\", buf, 1);\n\t\tsetenv(\"SLURM_JOB_ID\", buf, 1);\n\t\tsnprintf(buf, 16, \"%u\", recorded_stepid);\n\t\tsetenv(\"SLURM_STEPID\", buf, 1);\n\t\tsetenv(\"SLURM_STEP_ID\", buf, 1);\n\n\t\targv[0] = program_name;\n\t\targv[1] = NULL;\n\n#ifdef SETPGRP_TWO_ARGS\n\t\tsetpgrp(0, 0);\n#else\n\t\tsetpgrp();\n#endif\n\t\texecv(program_name, argv);\n\t\terror(\"step_terminate_monitor execv(): %m\");\n\t\texit(127);\n\t}\n\n\topt = WNOHANG;\n\ttime_remaining = max_wait;\n\twhile (1) {\n\t\trc = waitpid(cpid, &status, opt);\n\t\tif (rc < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\t/* waitpid may very well fail under normal conditions\n\t\t\t   because the wait3() in mgr.c:_wait_for_any_task()\n\t\t\t   may have reaped the return code. */\n\t\t\treturn 0;\n\t\t} else if (rc == 0) {\n\t\t\tsleep(1);\n\t\t\tif ((--time_remaining) == 0) {\n\t\t\t\terror(\"step_terminate_monitor: %s still running\"\n\t\t\t\t      \" after %d seconds.  Killing.\",\n\t\t\t\t      program_name, max_wait);\n\t\t\t\tkillpg(cpid, SIGKILL);\n\t\t\t\topt = 0;\n\t\t\t}\n\t\t} else  {\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t/* NOTREACHED */\n}"
  },
  {
    "function_name": "_monitor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/step_terminate_monitor.c",
    "lines": "122-146",
    "snippet": "static void *_monitor(void *notused)\n{\n\tstruct timespec ts = {0, 0};\n\tint rc;\n\n\tinfo(\"_monitor is running\");\n\n\tts.tv_sec = time(NULL) + 1 + timeout;\n\n\tslurm_mutex_lock(&lock);\n\tif (stop_flag)\n\t\tgoto done;\n\n\trc = pthread_cond_timedwait(&cond, &lock, &ts);\n\tif (rc == ETIMEDOUT) {\n\t\t_call_external_program();\n\t} else if (rc != 0) {\n\t\terror(\"Error waiting on condition in _monitor: %m\");\n\t}\ndone:\n\tslurm_mutex_unlock(&lock);\n\n\tinfo(\"_monitor is stopping\");\n\treturn NULL;\n}",
    "includes": [
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <sys/errno.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/common/job_container_plugin.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/macros.h\"",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;",
      "static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;",
      "static int stop_flag = 0;",
      "static uint16_t timeout;",
      "static void *_monitor(void *);",
      "static int _call_external_program(void);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "info",
          "args": [
            "\"_monitor is stopping\""
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "_fork_child_with_wait_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "1464-1486",
          "snippet": "static struct exec_wait_info * _fork_child_with_wait_info (int id)\n{\n\tstruct exec_wait_info *e;\n\n\tif (!(e = _exec_wait_info_create (id)))\n\t\treturn (NULL);\n\n\tif ((e->pid = fork ()) < 0) {\n\t\t_exec_wait_info_destroy (e);\n\t\treturn (NULL);\n\t}\n\t/*\n\t *  Close parentfd in child, and childfd in parent:\n\t */\n\tif (e->pid == 0) {\n\t\tclose (e->parentfd);\n\t\te->parentfd = -1;\n\t} else {\n\t\tclose (e->childfd);\n\t\te->childfd = -1;\n\t}\n\treturn (e);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic struct exec_wait_info * _fork_child_with_wait_info (int id)\n{\n\tstruct exec_wait_info *e;\n\n\tif (!(e = _exec_wait_info_create (id)))\n\t\treturn (NULL);\n\n\tif ((e->pid = fork ()) < 0) {\n\t\t_exec_wait_info_destroy (e);\n\t\treturn (NULL);\n\t}\n\t/*\n\t *  Close parentfd in child, and childfd in parent:\n\t */\n\tif (e->pid == 0) {\n\t\tclose (e->parentfd);\n\t\te->parentfd = -1;\n\t} else {\n\t\tclose (e->childfd);\n\t\te->childfd = -1;\n\t}\n\treturn (e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&lock"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Error waiting on condition in _monitor: %m\""
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_call_external_program",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "_call_external_program",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/step_terminate_monitor.c",
          "lines": "149-234",
          "snippet": "static int _call_external_program(void)\n{\n\tint status, rc, opt;\n\tpid_t cpid;\n\tint max_wait = 300; /* seconds */\n\tint time_remaining;\n\n\tdebug(\"step_terminate_monitor: unkillable after %d sec, calling: %s\",\n\t     timeout, program_name);\n\n\tif (program_name == NULL || program_name[0] == '\\0')\n\t\treturn 0;\n\n\tif (access(program_name, R_OK | X_OK) < 0) {\n\t\tdebug(\"step_terminate_monitor not running %s: %m\",\n\t\t      program_name);\n\t\treturn 0;\n\t}\n\n\tif ((cpid = fork()) < 0) {\n\t\terror(\"step_terminate_monitor executing %s: fork: %m\",\n\t\t      program_name);\n\t\treturn -1;\n\t}\n\tif (cpid == 0) {\n\t\t/* child */\n\t\tchar *argv[2];\n\t\tchar buf[16];\n\n\t\t/* container_g_add_pid needs to be called in the\n\t\t   forked process part of the fork to avoid a race\n\t\t   condition where if this process makes a file or\n\t\t   detacts itself from a child before we add the pid\n\t\t   to the container in the parent of the fork.\n\t\t*/\n\t\tif (container_g_add_pid(recorded_jobid, getpid(), getuid())\n\t\t    != SLURM_SUCCESS)\n\t\t\terror(\"container_g_add_pid(%u): %m\", recorded_jobid);\n\n\t\tsnprintf(buf, 16, \"%u\", recorded_jobid);\n\t\tsetenv(\"SLURM_JOBID\", buf, 1);\n\t\tsetenv(\"SLURM_JOB_ID\", buf, 1);\n\t\tsnprintf(buf, 16, \"%u\", recorded_stepid);\n\t\tsetenv(\"SLURM_STEPID\", buf, 1);\n\t\tsetenv(\"SLURM_STEP_ID\", buf, 1);\n\n\t\targv[0] = program_name;\n\t\targv[1] = NULL;\n\n#ifdef SETPGRP_TWO_ARGS\n\t\tsetpgrp(0, 0);\n#else\n\t\tsetpgrp();\n#endif\n\t\texecv(program_name, argv);\n\t\terror(\"step_terminate_monitor execv(): %m\");\n\t\texit(127);\n\t}\n\n\topt = WNOHANG;\n\ttime_remaining = max_wait;\n\twhile (1) {\n\t\trc = waitpid(cpid, &status, opt);\n\t\tif (rc < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\t/* waitpid may very well fail under normal conditions\n\t\t\t   because the wait3() in mgr.c:_wait_for_any_task()\n\t\t\t   may have reaped the return code. */\n\t\t\treturn 0;\n\t\t} else if (rc == 0) {\n\t\t\tsleep(1);\n\t\t\tif ((--time_remaining) == 0) {\n\t\t\t\terror(\"step_terminate_monitor: %s still running\"\n\t\t\t\t      \" after %d seconds.  Killing.\",\n\t\t\t\t      program_name, max_wait);\n\t\t\t\tkillpg(cpid, SIGKILL);\n\t\t\t\topt = 0;\n\t\t\t}\n\t\t} else  {\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include <time.h>",
            "#include <pthread.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/macros.h\"",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static uint16_t timeout;",
            "static char *program_name;",
            "static uint32_t recorded_jobid = NO_VAL;",
            "static uint32_t recorded_stepid = NO_VAL;",
            "static int _call_external_program(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <time.h>\n#include <pthread.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/macros.h\"\n#  include \"config.h\"\n\nstatic uint16_t timeout;\nstatic char *program_name;\nstatic uint32_t recorded_jobid = NO_VAL;\nstatic uint32_t recorded_stepid = NO_VAL;\nstatic int _call_external_program(void);\n\nstatic int _call_external_program(void)\n{\n\tint status, rc, opt;\n\tpid_t cpid;\n\tint max_wait = 300; /* seconds */\n\tint time_remaining;\n\n\tdebug(\"step_terminate_monitor: unkillable after %d sec, calling: %s\",\n\t     timeout, program_name);\n\n\tif (program_name == NULL || program_name[0] == '\\0')\n\t\treturn 0;\n\n\tif (access(program_name, R_OK | X_OK) < 0) {\n\t\tdebug(\"step_terminate_monitor not running %s: %m\",\n\t\t      program_name);\n\t\treturn 0;\n\t}\n\n\tif ((cpid = fork()) < 0) {\n\t\terror(\"step_terminate_monitor executing %s: fork: %m\",\n\t\t      program_name);\n\t\treturn -1;\n\t}\n\tif (cpid == 0) {\n\t\t/* child */\n\t\tchar *argv[2];\n\t\tchar buf[16];\n\n\t\t/* container_g_add_pid needs to be called in the\n\t\t   forked process part of the fork to avoid a race\n\t\t   condition where if this process makes a file or\n\t\t   detacts itself from a child before we add the pid\n\t\t   to the container in the parent of the fork.\n\t\t*/\n\t\tif (container_g_add_pid(recorded_jobid, getpid(), getuid())\n\t\t    != SLURM_SUCCESS)\n\t\t\terror(\"container_g_add_pid(%u): %m\", recorded_jobid);\n\n\t\tsnprintf(buf, 16, \"%u\", recorded_jobid);\n\t\tsetenv(\"SLURM_JOBID\", buf, 1);\n\t\tsetenv(\"SLURM_JOB_ID\", buf, 1);\n\t\tsnprintf(buf, 16, \"%u\", recorded_stepid);\n\t\tsetenv(\"SLURM_STEPID\", buf, 1);\n\t\tsetenv(\"SLURM_STEP_ID\", buf, 1);\n\n\t\targv[0] = program_name;\n\t\targv[1] = NULL;\n\n#ifdef SETPGRP_TWO_ARGS\n\t\tsetpgrp(0, 0);\n#else\n\t\tsetpgrp();\n#endif\n\t\texecv(program_name, argv);\n\t\terror(\"step_terminate_monitor execv(): %m\");\n\t\texit(127);\n\t}\n\n\topt = WNOHANG;\n\ttime_remaining = max_wait;\n\twhile (1) {\n\t\trc = waitpid(cpid, &status, opt);\n\t\tif (rc < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\t/* waitpid may very well fail under normal conditions\n\t\t\t   because the wait3() in mgr.c:_wait_for_any_task()\n\t\t\t   may have reaped the return code. */\n\t\t\treturn 0;\n\t\t} else if (rc == 0) {\n\t\t\tsleep(1);\n\t\t\tif ((--time_remaining) == 0) {\n\t\t\t\terror(\"step_terminate_monitor: %s still running\"\n\t\t\t\t      \" after %d seconds.  Killing.\",\n\t\t\t\t      program_name, max_wait);\n\t\t\t\tkillpg(cpid, SIGKILL);\n\t\t\t\topt = 0;\n\t\t\t}\n\t\t} else  {\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "pthread_cond_timedwait",
          "args": [
            "&cond",
            "&lock",
            "&ts"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&lock"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time",
          "args": [
            "NULL"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "get_up_time",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmd/get_mach_stat.c",
          "lines": "274-325",
          "snippet": "extern int get_up_time(uint32_t *up_time)\n{\n#if defined(HAVE_AIX) || defined(__sun) || defined(__APPLE__) || defined(__NetBSD__) || defined(__FreeBSD__)\n\tclock_t tm;\n\tstruct tms buf;\n\n\ttm = times(&buf);\n\tif (tm == (clock_t) -1) {\n\t\t*up_time = 0;\n\t\treturn errno;\n\t}\n\n\t*up_time = tm / sysconf(_SC_CLK_TCK);\n#elif defined(__CYGWIN__)\n\tFILE *uptime_file;\n\tchar buffer[128];\n\tchar* _uptime_path = \"/proc/uptime\";\n\n\tif (!(uptime_file = fopen(_uptime_path, \"r\"))) {\n\t\terror(\"get_up_time: error %d opening %s\", errno, _uptime_path);\n\t\treturn errno;\n\t}\n\n\tif (fgets(buffer, sizeof(buffer), uptime_file))\n\t\t*up_time = atoi(buffer);\n\n\tfclose(uptime_file);\n#else\n\t/* NOTE for Linux: The return value of times() may overflow the\n\t * possible range of type clock_t. There is also an offset of\n\t * 429 million seconds on some implementations. We just use the\n\t * simpler sysinfo() function instead. */\n\tstruct sysinfo info;\n\n\tif (sysinfo(&info) < 0) {\n\t\t*up_time = 0;\n\t\treturn errno;\n\t}\n\n\n\tif (conf->boot_time) {\n\t\t/* Make node look like it rebooted when slurmd started */\n\t\tstatic uint32_t orig_uptime = 0;\n\t\tif (orig_uptime == 0)\n\t\t\torig_uptime = info.uptime;\n\t\t*up_time = info.uptime - orig_uptime;\n\t} else {\n\t\t*up_time = info.uptime;\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/slurmd/get_mach_stat.h\"",
            "#include \"src/slurmctld/slurmctld.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/parse_spec.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include <unistd.h>",
            "# include <kstat.h>",
            "#  include <sys/vfs.h>",
            "#  include <sys/statfs.h>",
            "#  include <sys/statvfs.h>",
            "#include <sys/utsname.h>",
            "#  include <sys/sysinfo.h>",
            "#  include <sys/times.h> /* for times(3) */",
            "#  include <sys/types.h>",
            "#  include <sys/times.h>",
            "#include <syslog.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <fcntl.h>",
            "#include <errno.h>",
            "# include <sys/sysctl.h>",
            "#include <sys/types.h>",
            "# include <sys/dr.h>",
            "# include <sys/systemcfg.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/slurmd/get_mach_stat.h\"\n#include \"src/slurmctld/slurmctld.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/parse_spec.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include <unistd.h>\n# include <kstat.h>\n#  include <sys/vfs.h>\n#  include <sys/statfs.h>\n#  include <sys/statvfs.h>\n#include <sys/utsname.h>\n#  include <sys/sysinfo.h>\n#  include <sys/times.h> /* for times(3) */\n#  include <sys/types.h>\n#  include <sys/times.h>\n#include <syslog.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <fcntl.h>\n#include <errno.h>\n# include <sys/sysctl.h>\n#include <sys/types.h>\n# include <sys/dr.h>\n# include <sys/systemcfg.h>\n#  include \"config.h\"\n\nextern int get_up_time(uint32_t *up_time)\n{\n#if defined(HAVE_AIX) || defined(__sun) || defined(__APPLE__) || defined(__NetBSD__) || defined(__FreeBSD__)\n\tclock_t tm;\n\tstruct tms buf;\n\n\ttm = times(&buf);\n\tif (tm == (clock_t) -1) {\n\t\t*up_time = 0;\n\t\treturn errno;\n\t}\n\n\t*up_time = tm / sysconf(_SC_CLK_TCK);\n#elif defined(__CYGWIN__)\n\tFILE *uptime_file;\n\tchar buffer[128];\n\tchar* _uptime_path = \"/proc/uptime\";\n\n\tif (!(uptime_file = fopen(_uptime_path, \"r\"))) {\n\t\terror(\"get_up_time: error %d opening %s\", errno, _uptime_path);\n\t\treturn errno;\n\t}\n\n\tif (fgets(buffer, sizeof(buffer), uptime_file))\n\t\t*up_time = atoi(buffer);\n\n\tfclose(uptime_file);\n#else\n\t/* NOTE for Linux: The return value of times() may overflow the\n\t * possible range of type clock_t. There is also an offset of\n\t * 429 million seconds on some implementations. We just use the\n\t * simpler sysinfo() function instead. */\n\tstruct sysinfo info;\n\n\tif (sysinfo(&info) < 0) {\n\t\t*up_time = 0;\n\t\treturn errno;\n\t}\n\n\n\tif (conf->boot_time) {\n\t\t/* Make node look like it rebooted when slurmd started */\n\t\tstatic uint32_t orig_uptime = 0;\n\t\tif (orig_uptime == 0)\n\t\t\torig_uptime = info.uptime;\n\t\t*up_time = info.uptime - orig_uptime;\n\t} else {\n\t\t*up_time = info.uptime;\n\t}\n#endif\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <time.h>\n#include <pthread.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/macros.h\"\n#  include \"config.h\"\n\nstatic pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nstatic int stop_flag = 0;\nstatic uint16_t timeout;\nstatic void *_monitor(void *);\nstatic int _call_external_program(void);\n\nstatic void *_monitor(void *notused)\n{\n\tstruct timespec ts = {0, 0};\n\tint rc;\n\n\tinfo(\"_monitor is running\");\n\n\tts.tv_sec = time(NULL) + 1 + timeout;\n\n\tslurm_mutex_lock(&lock);\n\tif (stop_flag)\n\t\tgoto done;\n\n\trc = pthread_cond_timedwait(&cond, &lock, &ts);\n\tif (rc == ETIMEDOUT) {\n\t\t_call_external_program();\n\t} else if (rc != 0) {\n\t\terror(\"Error waiting on condition in _monitor: %m\");\n\t}\ndone:\n\tslurm_mutex_unlock(&lock);\n\n\tinfo(\"_monitor is stopping\");\n\treturn NULL;\n}"
  },
  {
    "function_name": "step_terminate_monitor_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/step_terminate_monitor.c",
    "lines": "94-119",
    "snippet": "void step_terminate_monitor_stop(void)\n{\n\tslurm_mutex_lock(&lock);\n\n\tif (!running_flag) {\n\t\tslurm_mutex_unlock(&lock);\n\t\treturn;\n\t}\n\tif (stop_flag) {\n\t\terror(\"step_terminate_monitor_stop: already stopped\");\n\t\tslurm_mutex_unlock(&lock);\n\t\treturn;\n\t}\n\n\tstop_flag = 1;\n\tdebug(\"step_terminate_monitor_stop signalling condition\");\n\tpthread_cond_signal(&cond);\n\tslurm_mutex_unlock(&lock);\n\n\tif (pthread_join(tid, NULL) != 0) {\n\t\terror(\"step_terminate_monitor_stop: pthread_join: %m\");\n\t}\n\n\txfree(program_name);\n\treturn;\n}",
    "includes": [
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <sys/errno.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/common/job_container_plugin.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/macros.h\"",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;",
      "static pthread_cond_t cond = PTHREAD_COND_INITIALIZER;",
      "static int running_flag = 0;",
      "static int stop_flag = 0;",
      "static pthread_t tid;",
      "static char *program_name;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "program_name"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"step_terminate_monitor_stop: pthread_join: %m\""
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_join",
          "args": [
            "tid",
            "NULL"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&lock"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_cond_signal",
          "args": [
            "&cond"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"step_terminate_monitor_stop signalling condition\""
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_stop_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "120-139",
          "snippet": "void\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&lock"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"step_terminate_monitor_stop: already stopped\""
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&lock"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&lock"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <time.h>\n#include <pthread.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/macros.h\"\n#  include \"config.h\"\n\nstatic pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\nstatic pthread_cond_t cond = PTHREAD_COND_INITIALIZER;\nstatic int running_flag = 0;\nstatic int stop_flag = 0;\nstatic pthread_t tid;\nstatic char *program_name;\n\nvoid step_terminate_monitor_stop(void)\n{\n\tslurm_mutex_lock(&lock);\n\n\tif (!running_flag) {\n\t\tslurm_mutex_unlock(&lock);\n\t\treturn;\n\t}\n\tif (stop_flag) {\n\t\terror(\"step_terminate_monitor_stop: already stopped\");\n\t\tslurm_mutex_unlock(&lock);\n\t\treturn;\n\t}\n\n\tstop_flag = 1;\n\tdebug(\"step_terminate_monitor_stop signalling condition\");\n\tpthread_cond_signal(&cond);\n\tslurm_mutex_unlock(&lock);\n\n\tif (pthread_join(tid, NULL) != 0) {\n\t\terror(\"step_terminate_monitor_stop: pthread_join: %m\");\n\t}\n\n\txfree(program_name);\n\treturn;\n}"
  },
  {
    "function_name": "step_terminate_monitor_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/step_terminate_monitor.c",
    "lines": "59-92",
    "snippet": "void step_terminate_monitor_start(uint32_t jobid, uint32_t stepid)\n{\n\tslurm_ctl_conf_t *conf;\n\tpthread_attr_t attr;\n\n\tslurm_mutex_lock(&lock);\n\n\tif (running_flag) {\n\t\tslurm_mutex_unlock(&lock);\n\t\treturn;\n\t}\n\n\tconf = slurm_conf_lock();\n\tif (conf->unkillable_program == NULL) {\n\t\t/* do nothing */\n\t\tslurm_conf_unlock();\n\t\tslurm_mutex_unlock(&lock);\n\t\treturn;\n\t}\n\ttimeout = conf->unkillable_timeout;\n\tprogram_name = xstrdup(conf->unkillable_program);\n\tslurm_conf_unlock();\n\n\tslurm_attr_init(&attr);\n\tpthread_create(&tid, &attr, _monitor, NULL);\n\tslurm_attr_destroy(&attr);\n\trunning_flag = 1;\n\trecorded_jobid = jobid;\n\trecorded_stepid = stepid;\n\n\tslurm_mutex_unlock(&lock);\n\n\treturn;\n}",
    "includes": [
      "#include <time.h>",
      "#include <pthread.h>",
      "#include <sys/errno.h>",
      "#include <sys/wait.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
      "#include \"src/slurmd/common/job_container_plugin.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/macros.h\"",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;",
      "static int running_flag = 0;",
      "static pthread_t tid;",
      "static uint16_t timeout;",
      "static char *program_name;",
      "static uint32_t recorded_jobid = NO_VAL;",
      "static uint32_t recorded_stepid = NO_VAL;",
      "static void *_monitor(void *);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&lock"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_attr_destroy",
          "args": [
            "&attr"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_create",
          "args": [
            "&tid",
            "&attr",
            "_monitor",
            "NULL"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_attr_init",
          "args": [
            "&attr"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_conf_unlock",
          "args": [],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrdup",
          "args": [
            "conf->unkillable_program"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&lock"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_conf_unlock",
          "args": [],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_conf_lock",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&lock"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&lock"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <time.h>\n#include <pthread.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/macros.h\"\n#  include \"config.h\"\n\nstatic pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\nstatic int running_flag = 0;\nstatic pthread_t tid;\nstatic uint16_t timeout;\nstatic char *program_name;\nstatic uint32_t recorded_jobid = NO_VAL;\nstatic uint32_t recorded_stepid = NO_VAL;\nstatic void *_monitor(void *);\n\nvoid step_terminate_monitor_start(uint32_t jobid, uint32_t stepid)\n{\n\tslurm_ctl_conf_t *conf;\n\tpthread_attr_t attr;\n\n\tslurm_mutex_lock(&lock);\n\n\tif (running_flag) {\n\t\tslurm_mutex_unlock(&lock);\n\t\treturn;\n\t}\n\n\tconf = slurm_conf_lock();\n\tif (conf->unkillable_program == NULL) {\n\t\t/* do nothing */\n\t\tslurm_conf_unlock();\n\t\tslurm_mutex_unlock(&lock);\n\t\treturn;\n\t}\n\ttimeout = conf->unkillable_timeout;\n\tprogram_name = xstrdup(conf->unkillable_program);\n\tslurm_conf_unlock();\n\n\tslurm_attr_init(&attr);\n\tpthread_create(&tid, &attr, _monitor, NULL);\n\tslurm_attr_destroy(&attr);\n\trunning_flag = 1;\n\trecorded_jobid = jobid;\n\trecorded_stepid = stepid;\n\n\tslurm_mutex_unlock(&lock);\n\n\treturn;\n}"
  }
]