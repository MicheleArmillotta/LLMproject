[
  {
    "function_name": "_dump_user_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
    "lines": "618-624",
    "snippet": "static void _dump_user_env(void)\n{\n\tint i;\n\n\tfor (i=0; environ[i]; i++)\n\t\tprintf(\"%s\\n\",environ[i]);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/slurmd/common/setproctitle.h\"",
      "#include \"src/slurmd/common/slurmstepd_init.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/slurm_mpi.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/common/plugstack.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <unistd.h>",
      "#include <sys/mman.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _dump_user_env(void);",
      "extern char  ** environ;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"%s\\n\"",
            "environ[i]"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic void _dump_user_env(void);\nextern char  ** environ;\n\nstatic void _dump_user_env(void)\n{\n\tint i;\n\n\tfor (i=0; environ[i]; i++)\n\t\tprintf(\"%s\\n\",environ[i]);\n}"
  },
  {
    "function_name": "_step_cleanup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
    "lines": "588-615",
    "snippet": "static void\n_step_cleanup(stepd_step_rec_t *job, slurm_msg_t *msg, int rc)\n{\n\tif (job) {\n\t\tjobacctinfo_destroy(job->jobacct);\n\t\tif (!job->batch)\n\t\t\tstepd_step_rec_destroy(job);\n\t}\n\t/*\n\t * The message cannot be freed until the jobstep is complete\n\t * because the job struct has pointers into the msg, such\n\t * as the switch jobinfo pointer.\n\t */\n\tswitch(msg->msg_type) {\n\tcase REQUEST_BATCH_JOB_LAUNCH:\n\t\tslurm_free_job_launch_msg(msg->data);\n\t\tbreak;\n\tcase REQUEST_LAUNCH_TASKS:\n\t\tslurm_free_launch_tasks_request_msg(msg->data);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"handle_launch_message: Unrecognized launch RPC\");\n\t\tbreak;\n\t}\n\tjobacctinfo_destroy(step_complete.jobacct);\n\n\txfree(msg);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/slurmd/common/setproctitle.h\"",
      "#include \"src/slurmd/common/slurmstepd_init.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/slurm_mpi.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/common/plugstack.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <unistd.h>",
      "#include <sys/mman.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "msg"
          ],
          "line": 614
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jobacctinfo_destroy",
          "args": [
            "step_complete.jobacct"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"handle_launch_message: Unrecognized launch RPC\""
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_free_launch_tasks_request_msg",
          "args": [
            "msg->data"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_free_job_launch_msg",
          "args": [
            "msg->data"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "stepd_step_rec_destroy",
          "args": [
            "job"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "stepd_step_rec_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd_job.c",
          "lines": "571-599",
          "snippet": "extern void\nstepd_step_rec_destroy(stepd_step_rec_t *job)\n{\n\tint i;\n\n\t_array_free(&job->env);\n\t_array_free(&job->argv);\n\n\tfor (i = 0; i < job->node_tasks; i++)\n\t\t_task_info_destroy(job->task[i], job->multi_prog);\n\teio_handle_destroy(job->eio);\n\tFREE_NULL_LIST(job->sruns);\n\tFREE_NULL_LIST(job->clients);\n\tFREE_NULL_LIST(job->stdout_eio_objs);\n\tFREE_NULL_LIST(job->stderr_eio_objs);\n\tFREE_NULL_LIST(job->free_incoming);\n\tFREE_NULL_LIST(job->free_outgoing);\n\tFREE_NULL_LIST(job->outgoing_cache);\n\txfree(job->envtp);\n\txfree(job->node_name);\n\tmpmd_free(job);\n\txfree(job->task_prolog);\n\txfree(job->task_epilog);\n\txfree(job->job_alloc_cores);\n\txfree(job->step_alloc_cores);\n\txfree(job->task_cnts);\n\txfree(job->user_name);\n\txfree(job);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/multi_prog.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/uid.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include <sys/types.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <grp.h>",
            "#  include <string.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/multi_prog.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/uid.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include <sys/types.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <grp.h>\n#  include <string.h>\n#  include \"config.h\"\n\nstatic void _task_info_destroy(stepd_step_task_info_t *t, uint16_t multi_prog);\n\nextern void\nstepd_step_rec_destroy(stepd_step_rec_t *job)\n{\n\tint i;\n\n\t_array_free(&job->env);\n\t_array_free(&job->argv);\n\n\tfor (i = 0; i < job->node_tasks; i++)\n\t\t_task_info_destroy(job->task[i], job->multi_prog);\n\teio_handle_destroy(job->eio);\n\tFREE_NULL_LIST(job->sruns);\n\tFREE_NULL_LIST(job->clients);\n\tFREE_NULL_LIST(job->stdout_eio_objs);\n\tFREE_NULL_LIST(job->stderr_eio_objs);\n\tFREE_NULL_LIST(job->free_incoming);\n\tFREE_NULL_LIST(job->free_outgoing);\n\tFREE_NULL_LIST(job->outgoing_cache);\n\txfree(job->envtp);\n\txfree(job->node_name);\n\tmpmd_free(job);\n\txfree(job->task_prolog);\n\txfree(job->task_epilog);\n\txfree(job->job_alloc_cores);\n\txfree(job->step_alloc_cores);\n\txfree(job->task_cnts);\n\txfree(job->user_name);\n\txfree(job);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jobacctinfo_destroy",
          "args": [
            "job->jobacct"
          ],
          "line": 592
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);\n\nstatic void\n_step_cleanup(stepd_step_rec_t *job, slurm_msg_t *msg, int rc)\n{\n\tif (job) {\n\t\tjobacctinfo_destroy(job->jobacct);\n\t\tif (!job->batch)\n\t\t\tstepd_step_rec_destroy(job);\n\t}\n\t/*\n\t * The message cannot be freed until the jobstep is complete\n\t * because the job struct has pointers into the msg, such\n\t * as the switch jobinfo pointer.\n\t */\n\tswitch(msg->msg_type) {\n\tcase REQUEST_BATCH_JOB_LAUNCH:\n\t\tslurm_free_job_launch_msg(msg->data);\n\t\tbreak;\n\tcase REQUEST_LAUNCH_TASKS:\n\t\tslurm_free_launch_tasks_request_msg(msg->data);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"handle_launch_message: Unrecognized launch RPC\");\n\t\tbreak;\n\t}\n\tjobacctinfo_destroy(step_complete.jobacct);\n\n\txfree(msg);\n}"
  },
  {
    "function_name": "_step_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
    "lines": "537-585",
    "snippet": "static stepd_step_rec_t *\n_step_setup(slurm_addr_t *cli, slurm_addr_t *self, slurm_msg_t *msg)\n{\n\tstepd_step_rec_t *job = NULL;\n\n\tswitch (msg->msg_type) {\n\tcase REQUEST_BATCH_JOB_LAUNCH:\n\t\tdebug2(\"setup for a batch_job\");\n\t\tjob = mgr_launch_batch_job_setup(msg->data, cli);\n\t\tbreak;\n\tcase REQUEST_LAUNCH_TASKS:\n\t\tdebug2(\"setup for a launch_task\");\n\t\tjob = mgr_launch_tasks_setup(msg->data, cli, self,\n\t\t\t\t\t     msg->protocol_version);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"handle_launch_message: Unrecognized launch RPC\");\n\t\tbreak;\n\t}\n\n\tif (!job) {\n\t\terror(\"_step_setup: no job returned\");\n\t\treturn NULL;\n\t}\n\n\tjob->jmgr_pid = getpid();\n\tjob->jobacct = jobacctinfo_create(NULL);\n\n\t/* Establish GRES environment variables */\n\tif (conf->debug_flags & DEBUG_FLAG_GRES) {\n\t\tgres_plugin_job_state_log(job->job_gres_list, job->jobid);\n\t\tgres_plugin_step_state_log(job->step_gres_list, job->jobid,\n\t\t\t\t\t   job->stepid);\n\t}\n\tif (msg->msg_type == REQUEST_BATCH_JOB_LAUNCH)\n\t\tgres_plugin_job_set_env(&job->env, job->job_gres_list);\n\telse if (msg->msg_type == REQUEST_LAUNCH_TASKS)\n\t\tgres_plugin_step_set_env(&job->env, job->step_gres_list, 0);\n\n\t/*\n\t * Add slurmd node topology informations to job env array\n\t */\n\tenv_array_overwrite(&job->env,\"SLURM_TOPOLOGY_ADDR\",\n\t\t\t    conf->node_topo_addr);\n\tenv_array_overwrite(&job->env,\"SLURM_TOPOLOGY_ADDR_PATTERN\",\n\t\t\t    conf->node_topo_pattern);\n\n\treturn job;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/slurmd/common/setproctitle.h\"",
      "#include \"src/slurmd/common/slurmstepd_init.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/slurm_mpi.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/common/plugstack.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <unistd.h>",
      "#include <sys/mman.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);",
      "slurmd_conf_t * conf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "env_array_overwrite",
          "args": [
            "&job->env",
            "\"SLURM_TOPOLOGY_ADDR_PATTERN\"",
            "conf->node_topo_pattern"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "env_array_overwrite",
          "args": [
            "&job->env",
            "\"SLURM_TOPOLOGY_ADDR\"",
            "conf->node_topo_addr"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gres_plugin_step_set_env",
          "args": [
            "&job->env",
            "job->step_gres_list",
            "0"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gres_plugin_job_set_env",
          "args": [
            "&job->env",
            "job->job_gres_list"
          ],
          "line": 572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gres_plugin_step_state_log",
          "args": [
            "job->step_gres_list",
            "job->jobid",
            "job->stepid"
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gres_plugin_job_state_log",
          "args": [
            "job->job_gres_list",
            "job->jobid"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacctinfo_create",
          "args": [
            "NULL"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"_step_setup: no job returned\""
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"handle_launch_message: Unrecognized launch RPC\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mgr_launch_tasks_setup",
          "args": [
            "msg->data",
            "cli",
            "self",
            "msg->protocol_version"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "mgr_launch_tasks_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "233-260",
          "snippet": "extern stepd_step_rec_t *\nmgr_launch_tasks_setup(launch_tasks_request_msg_t *msg, slurm_addr_t *cli,\n\t\t       slurm_addr_t *self, uint16_t protocol_version)\n{\n\tstepd_step_rec_t *job = NULL;\n\n\tif (!(job = stepd_step_rec_create(msg, protocol_version))) {\n\t\t/* We want to send back to the slurmd the reason we\n\t\t   failed so keep track of it since errno could be\n\t\t   reset in _send_launch_failure.\n\t\t*/\n\t\tint fail = errno;\n\t\t_send_launch_failure(msg, cli, errno, protocol_version);\n\t\terrno = fail;\n\t\treturn NULL;\n\t}\n\n\t_set_job_log_prefix(job);\n\n\t_setargs(job);\n\n\tjob->envtp->cli = cli;\n\tjob->envtp->self = self;\n\tjob->envtp->select_jobinfo = msg->select_jobinfo;\n\tjob->accel_bind_type = msg->accel_bind_type;\n\n\treturn job;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _send_launch_failure(launch_tasks_request_msg_t *,\n\t\t\t\t slurm_addr_t *, int, uint16_t);",
            "static int  _drain_node(char *reason);",
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int _initgroups(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void _send_launch_failure(launch_tasks_request_msg_t *,\n\t\t\t\t slurm_addr_t *, int, uint16_t);\nstatic int  _drain_node(char *reason);\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int _initgroups(stepd_step_rec_t *job);\n\nextern stepd_step_rec_t *\nmgr_launch_tasks_setup(launch_tasks_request_msg_t *msg, slurm_addr_t *cli,\n\t\t       slurm_addr_t *self, uint16_t protocol_version)\n{\n\tstepd_step_rec_t *job = NULL;\n\n\tif (!(job = stepd_step_rec_create(msg, protocol_version))) {\n\t\t/* We want to send back to the slurmd the reason we\n\t\t   failed so keep track of it since errno could be\n\t\t   reset in _send_launch_failure.\n\t\t*/\n\t\tint fail = errno;\n\t\t_send_launch_failure(msg, cli, errno, protocol_version);\n\t\terrno = fail;\n\t\treturn NULL;\n\t}\n\n\t_set_job_log_prefix(job);\n\n\t_setargs(job);\n\n\tjob->envtp->cli = cli;\n\tjob->envtp->self = self;\n\tjob->envtp->select_jobinfo = msg->select_jobinfo;\n\tjob->accel_bind_type = msg->accel_bind_type;\n\n\treturn job;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"setup for a launch_task\""
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mgr_launch_batch_job_setup",
          "args": [
            "msg->data",
            "cli"
          ],
          "line": 545
        },
        "resolved": true,
        "details": {
          "function_name": "mgr_launch_batch_job_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "437-488",
          "snippet": "stepd_step_rec_t *\nmgr_launch_batch_job_setup(batch_job_launch_msg_t *msg, slurm_addr_t *cli)\n{\n\tstepd_step_rec_t *job = NULL;\n\n\tif (!(job = batch_stepd_step_rec_create(msg))) {\n\t\terror(\"batch_stepd_step_rec_create() failed: %m\");\n\t\treturn NULL;\n\t}\n\n\t_set_job_log_prefix(job);\n\n\t_setargs(job);\n\n\tif ((job->batchdir = _make_batch_dir(job)) == NULL) {\n\t\tgoto cleanup;\n\t}\n\n\txfree(job->argv[0]);\n\n\tif ((job->argv[0] = _make_batch_script(msg, job->batchdir)) == NULL) {\n\t\tgoto cleanup;\n\t}\n\n\t/* this is the new way of setting environment variables */\n\tenv_array_for_batch_job(&job->env, msg, conf->node_name);\n\n\t/* this is the old way of setting environment variables (but\n\t * needed) */\n\tjob->envtp->overcommit = msg->overcommit;\n\tjob->envtp->select_jobinfo = msg->select_jobinfo;\n\n\treturn job;\n\ncleanup:\n\terror(\"batch script setup failed for job %u.%u\",\n\t      msg->job_id, msg->step_id);\n\n\tif (job->aborted)\n\t\tverbose(\"job %u abort complete\", job->jobid);\n\n\t/* Do not purge directory until slurmctld is notified of batch job\n\t * completion to avoid race condition with slurmd registering missing\n\t * batch job. */\n\tif (job->batchdir && (rmdir(job->batchdir) < 0))\n\t\terror(\"rmdir(%s): %m\",  job->batchdir);\n\txfree(job->batchdir);\n\n\terrno = ESLURMD_CREATE_BATCH_DIR_ERROR;\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static int  _run_script_as_user(const char *name, const char *path,\n\t\t\t\tstepd_step_rec_t *job,\n\t\t\t\tint max_wait, char **env);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int _initgroups(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic int  _run_script_as_user(const char *name, const char *path,\n\t\t\t\tstepd_step_rec_t *job,\n\t\t\t\tint max_wait, char **env);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int _initgroups(stepd_step_rec_t *job);\n\nstepd_step_rec_t *\nmgr_launch_batch_job_setup(batch_job_launch_msg_t *msg, slurm_addr_t *cli)\n{\n\tstepd_step_rec_t *job = NULL;\n\n\tif (!(job = batch_stepd_step_rec_create(msg))) {\n\t\terror(\"batch_stepd_step_rec_create() failed: %m\");\n\t\treturn NULL;\n\t}\n\n\t_set_job_log_prefix(job);\n\n\t_setargs(job);\n\n\tif ((job->batchdir = _make_batch_dir(job)) == NULL) {\n\t\tgoto cleanup;\n\t}\n\n\txfree(job->argv[0]);\n\n\tif ((job->argv[0] = _make_batch_script(msg, job->batchdir)) == NULL) {\n\t\tgoto cleanup;\n\t}\n\n\t/* this is the new way of setting environment variables */\n\tenv_array_for_batch_job(&job->env, msg, conf->node_name);\n\n\t/* this is the old way of setting environment variables (but\n\t * needed) */\n\tjob->envtp->overcommit = msg->overcommit;\n\tjob->envtp->select_jobinfo = msg->select_jobinfo;\n\n\treturn job;\n\ncleanup:\n\terror(\"batch script setup failed for job %u.%u\",\n\t      msg->job_id, msg->step_id);\n\n\tif (job->aborted)\n\t\tverbose(\"job %u abort complete\", job->jobid);\n\n\t/* Do not purge directory until slurmctld is notified of batch job\n\t * completion to avoid race condition with slurmd registering missing\n\t * batch job. */\n\tif (job->batchdir && (rmdir(job->batchdir) < 0))\n\t\terror(\"rmdir(%s): %m\",  job->batchdir);\n\txfree(job->batchdir);\n\n\terrno = ESLURMD_CREATE_BATCH_DIR_ERROR;\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"setup for a batch_job\""
          ],
          "line": 544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);\nslurmd_conf_t * conf;\n\nstatic stepd_step_rec_t *\n_step_setup(slurm_addr_t *cli, slurm_addr_t *self, slurm_msg_t *msg)\n{\n\tstepd_step_rec_t *job = NULL;\n\n\tswitch (msg->msg_type) {\n\tcase REQUEST_BATCH_JOB_LAUNCH:\n\t\tdebug2(\"setup for a batch_job\");\n\t\tjob = mgr_launch_batch_job_setup(msg->data, cli);\n\t\tbreak;\n\tcase REQUEST_LAUNCH_TASKS:\n\t\tdebug2(\"setup for a launch_task\");\n\t\tjob = mgr_launch_tasks_setup(msg->data, cli, self,\n\t\t\t\t\t     msg->protocol_version);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"handle_launch_message: Unrecognized launch RPC\");\n\t\tbreak;\n\t}\n\n\tif (!job) {\n\t\terror(\"_step_setup: no job returned\");\n\t\treturn NULL;\n\t}\n\n\tjob->jmgr_pid = getpid();\n\tjob->jobacct = jobacctinfo_create(NULL);\n\n\t/* Establish GRES environment variables */\n\tif (conf->debug_flags & DEBUG_FLAG_GRES) {\n\t\tgres_plugin_job_state_log(job->job_gres_list, job->jobid);\n\t\tgres_plugin_step_state_log(job->step_gres_list, job->jobid,\n\t\t\t\t\t   job->stepid);\n\t}\n\tif (msg->msg_type == REQUEST_BATCH_JOB_LAUNCH)\n\t\tgres_plugin_job_set_env(&job->env, job->job_gres_list);\n\telse if (msg->msg_type == REQUEST_LAUNCH_TASKS)\n\t\tgres_plugin_step_set_env(&job->env, job->step_gres_list, 0);\n\n\t/*\n\t * Add slurmd node topology informations to job env array\n\t */\n\tenv_array_overwrite(&job->env,\"SLURM_TOPOLOGY_ADDR\",\n\t\t\t    conf->node_topo_addr);\n\tenv_array_overwrite(&job->env,\"SLURM_TOPOLOGY_ADDR_PATTERN\",\n\t\t\t    conf->node_topo_pattern);\n\n\treturn job;\n}"
  },
  {
    "function_name": "_init_from_slurmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
    "lines": "396-535",
    "snippet": "static int\n_init_from_slurmd(int sock, char **argv,\n\t\t  slurm_addr_t **_cli, slurm_addr_t **_self, slurm_msg_t **_msg,\n\t\t  int *_ngids, gid_t **_gids)\n{\n\tchar *incoming_buffer = NULL;\n\tBuf buffer;\n\tint step_type;\n\tint len, proto;\n\tslurm_addr_t *cli = NULL;\n\tslurm_addr_t *self = NULL;\n\tslurm_msg_t *msg = NULL;\n\tint ngids = 0;\n\tgid_t *gids = NULL;\n\tuint16_t port;\n\tchar buf[16];\n\tlog_options_t lopts = LOG_OPTS_INITIALIZER;\n\n\tlog_init(argv[0], lopts, LOG_DAEMON, NULL);\n\n\t/* receive job type from slurmd */\n\tsafe_read(sock, &step_type, sizeof(int));\n\tdebug3(\"step_type = %d\", step_type);\n\n\t/* receive reverse-tree info from slurmd */\n\tslurm_mutex_lock(&step_complete.lock);\n\tsafe_read(sock, &step_complete.rank, sizeof(int));\n\tsafe_read(sock, &step_complete.parent_rank, sizeof(int));\n\tsafe_read(sock, &step_complete.children, sizeof(int));\n\tsafe_read(sock, &step_complete.depth, sizeof(int));\n\tsafe_read(sock, &step_complete.max_depth, sizeof(int));\n\tsafe_read(sock, &step_complete.parent_addr, sizeof(slurm_addr_t));\n\tstep_complete.bits = bit_alloc(step_complete.children);\n\tstep_complete.jobacct = jobacctinfo_create(NULL);\n\tslurm_mutex_unlock(&step_complete.lock);\n\n\t/* receive conf from slurmd */\n\tif ((conf = read_slurmd_conf_lite (sock)) == NULL)\n\t\tfatal(\"Failed to read conf from slurmd\");\n\n\tlog_alter(conf->log_opts, 0, conf->logfile);\n\tlog_set_timefmt(conf->log_fmt);\n\n\tdebug2(\"debug level is %d.\", conf->debug_level);\n\n\tswitch_g_slurmd_step_init();\n\n\tslurm_get_ip_str(&step_complete.parent_addr, &port, buf, 16);\n\tdebug3(\"slurmstepd rank %d, parent address = %s, port = %u\",\n\t       step_complete.rank, buf, port);\n\n\t/* receive cli from slurmd */\n\tsafe_read(sock, &len, sizeof(int));\n\tincoming_buffer = xmalloc(sizeof(char) * len);\n\tsafe_read(sock, incoming_buffer, len);\n\tbuffer = create_buf(incoming_buffer,len);\n\tcli = xmalloc(sizeof(slurm_addr_t));\n\tif (slurm_unpack_slurm_addr_no_alloc(cli, buffer) == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: problem with unpack of slurmd_conf\");\n\tfree_buf(buffer);\n\n\t/* receive self from slurmd */\n\tsafe_read(sock, &len, sizeof(int));\n\tif (len > 0) {\n\t\t/* receive packed self from main slurmd */\n\t\tincoming_buffer = xmalloc(sizeof(char) * len);\n\t\tsafe_read(sock, incoming_buffer, len);\n\t\tbuffer = create_buf(incoming_buffer,len);\n\t\tself = xmalloc(sizeof(slurm_addr_t));\n\t\tif (slurm_unpack_slurm_addr_no_alloc(self, buffer)\n\t\t    == SLURM_ERROR) {\n\t\t\tfatal(\"slurmstepd: problem with unpack of \"\n\t\t\t      \"slurmd_conf\");\n\t\t}\n\t\tfree_buf(buffer);\n\t}\n\n\t/* Receive GRES information from slurmd */\n\tgres_plugin_recv_stepd(sock);\n\n\t/* Grab the slurmd's spooldir. Has %n expanded. */\n\tcpu_freq_init(conf);\n\n\t/* Receive cpu_frequency info from slurmd */\n\tcpu_freq_recv_info(sock);\n\n\t/* get the protocol version of the srun */\n\tsafe_read(sock, &proto, sizeof(int));\n\n\t/* receive req from slurmd */\n\tsafe_read(sock, &len, sizeof(int));\n\tincoming_buffer = xmalloc(sizeof(char) * len);\n\tsafe_read(sock, incoming_buffer, len);\n\tbuffer = create_buf(incoming_buffer,len);\n\n\tmsg = xmalloc(sizeof(slurm_msg_t));\n\tslurm_msg_t_init(msg);\n\tmsg->protocol_version = (uint16_t)proto;\n\n\tswitch (step_type) {\n\tcase LAUNCH_BATCH_JOB:\n\t\tmsg->msg_type = REQUEST_BATCH_JOB_LAUNCH;\n\t\tbreak;\n\tcase LAUNCH_TASKS:\n\t\tmsg->msg_type = REQUEST_LAUNCH_TASKS;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: Unrecognized launch RPC (%d)\", __func__, step_type);\n\t\tbreak;\n\t}\n\tif (unpack_msg(msg, buffer) == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: we didn't unpack the request correctly\");\n\tfree_buf(buffer);\n\n\t/* receive cached group ids array for the relevant uid */\n\tsafe_read(sock, &ngids, sizeof(int));\n\tif (ngids > 0) {\n\t\tint i;\n\t\tuint32_t tmp32;\n\n\t\tgids = (gid_t *)xmalloc(sizeof(gid_t) * ngids);\n\t\tfor (i = 0; i < ngids; i++) {\n\t\t\tsafe_read(sock, &tmp32, sizeof(uint32_t));\n\t\t\tgids[i] = (gid_t)tmp32;\n\t\t\tdebug2(\"got gid %d\", gids[i]);\n\t\t}\n\t}\n\n\t*_cli = cli;\n\t*_self = self;\n\t*_msg = msg;\n\t*_ngids = ngids;\n\t*_gids = gids;\n\n\treturn 1;\n\nrwfail:\n\tfatal(\"Error reading initialization data from slurmd\");\n\texit(1);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/slurmd/common/setproctitle.h\"",
      "#include \"src/slurmd/common/slurmstepd_init.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/slurm_mpi.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/common/plugstack.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <unistd.h>",
      "#include <sys/mman.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _init_from_slurmd(int sock, char **argv, slurm_addr_t **_cli,\n\t\t\t     slurm_addr_t **_self, slurm_msg_t **_msg,\n\t\t\t     int *_ngids, gid_t **_gids);",
      "static void _send_ok_to_slurmd(int sock);",
      "static void _send_fail_to_slurmd(int sock);",
      "static stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);",
      "static int _process_cmdline (int argc, char *argv[]);",
      "slurmd_conf_t * conf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "1"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "_send_pending_exit_msgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "1890-1927",
          "snippet": "static int\n_send_pending_exit_msgs(stepd_step_rec_t *job)\n{\n\tint  i;\n\tint  nsent  = 0;\n\tint  status = 0;\n\tbool set    = false;\n\tuint32_t *tid;\n\n\t/*\n\t * Collect all exit codes with the same status into a\n\t * single message.\n\t */\n\ttid = xmalloc(sizeof(uint32_t) * job->node_tasks);\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tstepd_step_task_info_t *t = job->task[i];\n\n\t\tif (!t->exited || t->esent)\n\t\t\tcontinue;\n\n\t\tif (!set) {\n\t\t\tstatus = t->estatus;\n\t\t\tset    = true;\n\t\t} else if (status != t->estatus)\n\t\t\tcontinue;\n\n\t\ttid[nsent++] = t->gtid;\n\t\tt->esent = true;\n\t}\n\n\tif (nsent) {\n\t\tdebug2(\"Aggregated %d task exit messages\", nsent);\n\t\t_send_exit_msg(job, tid, nsent, status);\n\t}\n\txfree(tid);\n\n\treturn nsent;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static int  _send_exit_msg(stepd_step_rec_t *job, uint32_t *tid, int n,\n\t\t\t   int status);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int    _send_complete_batch_script_msg(stepd_step_rec_t *job,\n\t\t\t\t\t      int err, int status);",
            "static int _initgroups(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic int  _send_exit_msg(stepd_step_rec_t *job, uint32_t *tid, int n,\n\t\t\t   int status);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int    _send_complete_batch_script_msg(stepd_step_rec_t *job,\n\t\t\t\t\t      int err, int status);\nstatic int _initgroups(stepd_step_rec_t *job);\n\nstatic int\n_send_pending_exit_msgs(stepd_step_rec_t *job)\n{\n\tint  i;\n\tint  nsent  = 0;\n\tint  status = 0;\n\tbool set    = false;\n\tuint32_t *tid;\n\n\t/*\n\t * Collect all exit codes with the same status into a\n\t * single message.\n\t */\n\ttid = xmalloc(sizeof(uint32_t) * job->node_tasks);\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tstepd_step_task_info_t *t = job->task[i];\n\n\t\tif (!t->exited || t->esent)\n\t\t\tcontinue;\n\n\t\tif (!set) {\n\t\t\tstatus = t->estatus;\n\t\t\tset    = true;\n\t\t} else if (status != t->estatus)\n\t\t\tcontinue;\n\n\t\ttid[nsent++] = t->gtid;\n\t\tt->esent = true;\n\t}\n\n\tif (nsent) {\n\t\tdebug2(\"Aggregated %d task exit messages\", nsent);\n\t\t_send_exit_msg(job, tid, nsent, status);\n\t}\n\txfree(tid);\n\n\treturn nsent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Error reading initialization data from slurmd\""
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"got gid %d\"",
            "gids[i]"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&tmp32",
            "sizeof(uint32_t)"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(gid_t) * ngids"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&ngids",
            "sizeof(int)"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buf",
          "args": [
            "buffer"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"slurmstepd: we didn't unpack the request correctly\""
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_msg",
          "args": [
            "msg",
            "buffer"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"%s: Unrecognized launch RPC (%d)\"",
            "__func__",
            "step_type"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_msg_t_init",
          "args": [
            "msg"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(slurm_msg_t)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_buf",
          "args": [
            "incoming_buffer",
            "len"
          ],
          "line": 489
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "incoming_buffer",
            "len"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(char) * len"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&len",
            "sizeof(int)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&proto",
            "sizeof(int)"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_freq_recv_info",
          "args": [
            "sock"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_freq_init",
          "args": [
            "conf"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gres_plugin_recv_stepd",
          "args": [
            "sock"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buf",
          "args": [
            "buffer"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"slurmstepd: problem with unpack of \"\n\t\t\t      \"slurmd_conf\""
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_unpack_slurm_addr_no_alloc",
          "args": [
            "self",
            "buffer"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(slurm_addr_t)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_buf",
          "args": [
            "incoming_buffer",
            "len"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "incoming_buffer",
            "len"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(char) * len"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&len",
            "sizeof(int)"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buf",
          "args": [
            "buffer"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"slurmstepd: problem with unpack of slurmd_conf\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_unpack_slurm_addr_no_alloc",
          "args": [
            "cli",
            "buffer"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(slurm_addr_t)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_buf",
          "args": [
            "incoming_buffer",
            "len"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "incoming_buffer",
            "len"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(char) * len"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&len",
            "sizeof(int)"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"slurmstepd rank %d, parent address = %s, port = %u\"",
            "step_complete.rank",
            "buf",
            "port"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_get_ip_str",
          "args": [
            "&step_complete.parent_addr",
            "&port",
            "buf",
            "16"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "switch_g_slurmd_step_init",
          "args": [],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug2",
          "args": [
            "\"debug level is %d.\"",
            "conf->debug_level"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_set_timefmt",
          "args": [
            "conf->log_fmt"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_alter",
          "args": [
            "conf->log_opts",
            "0",
            "conf->logfile"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Failed to read conf from slurmd\""
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_slurmd_conf_lite",
          "args": [
            "sock"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "read_slurmd_conf_lite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
          "lines": "198-250",
          "snippet": "static slurmd_conf_t * read_slurmd_conf_lite (int fd)\n{\n\tint rc;\n\tint len;\n\tBuf buffer;\n\tslurmd_conf_t *confl;\n\tint tmp_int = 0;\n\n\t/*  First check to see if we've already initialized the\n\t *   global slurmd_conf_t in 'conf'. Allocate memory if not.\n\t */\n\tconfl = conf ? conf : xmalloc (sizeof (*confl));\n\n\tsafe_read(fd, &len, sizeof(int));\n\n\tbuffer = init_buf(len);\n\tsafe_read(fd, buffer->head, len);\n\n\trc = unpack_slurmd_conf_lite_no_alloc(confl, buffer);\n\tif (rc == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: problem with unpack of slurmd_conf\");\n\n\tfree_buf(buffer);\n\n\tconfl->log_opts.prefix_level = 1;\n\tconfl->log_opts.stderr_level = confl->debug_level;\n\tconfl->log_opts.logfile_level = confl->debug_level;\n\tconfl->log_opts.syslog_level = confl->debug_level;\n\t/*\n\t * If daemonizing, turn off stderr logging -- also, if\n\t * logging to a file, turn off syslog.\n\t *\n\t * Otherwise, if remaining in foreground, turn off logging\n\t * to syslog (but keep logfile level)\n\t */\n\tif (confl->daemonize) {\n\t\tconfl->log_opts.stderr_level = LOG_LEVEL_QUIET;\n\t\tif (confl->logfile)\n\t\t\tconfl->log_opts.syslog_level = LOG_LEVEL_QUIET;\n\t} else\n\t\tconfl->log_opts.syslog_level  = LOG_LEVEL_QUIET;\n\n\tconfl->acct_freq_task = (uint16_t)NO_VAL;\n\ttmp_int = acct_gather_parse_freq(PROFILE_TASK,\n\t\t\t\t       confl->job_acct_gather_freq);\n\tif (tmp_int != -1)\n\t\tconfl->acct_freq_task = tmp_int;\n\n\n\treturn (confl);\nrwfail:\n\treturn (NULL);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <unistd.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "slurmd_conf_t * conf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nslurmd_conf_t * conf;\n\nstatic slurmd_conf_t * read_slurmd_conf_lite (int fd)\n{\n\tint rc;\n\tint len;\n\tBuf buffer;\n\tslurmd_conf_t *confl;\n\tint tmp_int = 0;\n\n\t/*  First check to see if we've already initialized the\n\t *   global slurmd_conf_t in 'conf'. Allocate memory if not.\n\t */\n\tconfl = conf ? conf : xmalloc (sizeof (*confl));\n\n\tsafe_read(fd, &len, sizeof(int));\n\n\tbuffer = init_buf(len);\n\tsafe_read(fd, buffer->head, len);\n\n\trc = unpack_slurmd_conf_lite_no_alloc(confl, buffer);\n\tif (rc == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: problem with unpack of slurmd_conf\");\n\n\tfree_buf(buffer);\n\n\tconfl->log_opts.prefix_level = 1;\n\tconfl->log_opts.stderr_level = confl->debug_level;\n\tconfl->log_opts.logfile_level = confl->debug_level;\n\tconfl->log_opts.syslog_level = confl->debug_level;\n\t/*\n\t * If daemonizing, turn off stderr logging -- also, if\n\t * logging to a file, turn off syslog.\n\t *\n\t * Otherwise, if remaining in foreground, turn off logging\n\t * to syslog (but keep logfile level)\n\t */\n\tif (confl->daemonize) {\n\t\tconfl->log_opts.stderr_level = LOG_LEVEL_QUIET;\n\t\tif (confl->logfile)\n\t\t\tconfl->log_opts.syslog_level = LOG_LEVEL_QUIET;\n\t} else\n\t\tconfl->log_opts.syslog_level  = LOG_LEVEL_QUIET;\n\n\tconfl->acct_freq_task = (uint16_t)NO_VAL;\n\ttmp_int = acct_gather_parse_freq(PROFILE_TASK,\n\t\t\t\t       confl->job_acct_gather_freq);\n\tif (tmp_int != -1)\n\t\tconfl->acct_freq_task = tmp_int;\n\n\n\treturn (confl);\nrwfail:\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_mutex_unlock",
          "args": [
            "&step_complete.lock"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jobacctinfo_create",
          "args": [
            "NULL"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bit_alloc",
          "args": [
            "step_complete.children"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&step_complete.parent_addr",
            "sizeof(slurm_addr_t)"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&step_complete.max_depth",
            "sizeof(int)"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&step_complete.depth",
            "sizeof(int)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&step_complete.children",
            "sizeof(int)"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&step_complete.parent_rank",
            "sizeof(int)"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&step_complete.rank",
            "sizeof(int)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_mutex_lock",
          "args": [
            "&step_complete.lock"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"step_type = %d\"",
            "step_type"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&step_type",
            "sizeof(int)"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "log_init",
          "args": [
            "argv[0]",
            "lopts",
            "LOG_DAEMON",
            "NULL"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic int _init_from_slurmd(int sock, char **argv, slurm_addr_t **_cli,\n\t\t\t     slurm_addr_t **_self, slurm_msg_t **_msg,\n\t\t\t     int *_ngids, gid_t **_gids);\nstatic void _send_ok_to_slurmd(int sock);\nstatic void _send_fail_to_slurmd(int sock);\nstatic stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);\nstatic int _process_cmdline (int argc, char *argv[]);\nslurmd_conf_t * conf;\n\nstatic int\n_init_from_slurmd(int sock, char **argv,\n\t\t  slurm_addr_t **_cli, slurm_addr_t **_self, slurm_msg_t **_msg,\n\t\t  int *_ngids, gid_t **_gids)\n{\n\tchar *incoming_buffer = NULL;\n\tBuf buffer;\n\tint step_type;\n\tint len, proto;\n\tslurm_addr_t *cli = NULL;\n\tslurm_addr_t *self = NULL;\n\tslurm_msg_t *msg = NULL;\n\tint ngids = 0;\n\tgid_t *gids = NULL;\n\tuint16_t port;\n\tchar buf[16];\n\tlog_options_t lopts = LOG_OPTS_INITIALIZER;\n\n\tlog_init(argv[0], lopts, LOG_DAEMON, NULL);\n\n\t/* receive job type from slurmd */\n\tsafe_read(sock, &step_type, sizeof(int));\n\tdebug3(\"step_type = %d\", step_type);\n\n\t/* receive reverse-tree info from slurmd */\n\tslurm_mutex_lock(&step_complete.lock);\n\tsafe_read(sock, &step_complete.rank, sizeof(int));\n\tsafe_read(sock, &step_complete.parent_rank, sizeof(int));\n\tsafe_read(sock, &step_complete.children, sizeof(int));\n\tsafe_read(sock, &step_complete.depth, sizeof(int));\n\tsafe_read(sock, &step_complete.max_depth, sizeof(int));\n\tsafe_read(sock, &step_complete.parent_addr, sizeof(slurm_addr_t));\n\tstep_complete.bits = bit_alloc(step_complete.children);\n\tstep_complete.jobacct = jobacctinfo_create(NULL);\n\tslurm_mutex_unlock(&step_complete.lock);\n\n\t/* receive conf from slurmd */\n\tif ((conf = read_slurmd_conf_lite (sock)) == NULL)\n\t\tfatal(\"Failed to read conf from slurmd\");\n\n\tlog_alter(conf->log_opts, 0, conf->logfile);\n\tlog_set_timefmt(conf->log_fmt);\n\n\tdebug2(\"debug level is %d.\", conf->debug_level);\n\n\tswitch_g_slurmd_step_init();\n\n\tslurm_get_ip_str(&step_complete.parent_addr, &port, buf, 16);\n\tdebug3(\"slurmstepd rank %d, parent address = %s, port = %u\",\n\t       step_complete.rank, buf, port);\n\n\t/* receive cli from slurmd */\n\tsafe_read(sock, &len, sizeof(int));\n\tincoming_buffer = xmalloc(sizeof(char) * len);\n\tsafe_read(sock, incoming_buffer, len);\n\tbuffer = create_buf(incoming_buffer,len);\n\tcli = xmalloc(sizeof(slurm_addr_t));\n\tif (slurm_unpack_slurm_addr_no_alloc(cli, buffer) == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: problem with unpack of slurmd_conf\");\n\tfree_buf(buffer);\n\n\t/* receive self from slurmd */\n\tsafe_read(sock, &len, sizeof(int));\n\tif (len > 0) {\n\t\t/* receive packed self from main slurmd */\n\t\tincoming_buffer = xmalloc(sizeof(char) * len);\n\t\tsafe_read(sock, incoming_buffer, len);\n\t\tbuffer = create_buf(incoming_buffer,len);\n\t\tself = xmalloc(sizeof(slurm_addr_t));\n\t\tif (slurm_unpack_slurm_addr_no_alloc(self, buffer)\n\t\t    == SLURM_ERROR) {\n\t\t\tfatal(\"slurmstepd: problem with unpack of \"\n\t\t\t      \"slurmd_conf\");\n\t\t}\n\t\tfree_buf(buffer);\n\t}\n\n\t/* Receive GRES information from slurmd */\n\tgres_plugin_recv_stepd(sock);\n\n\t/* Grab the slurmd's spooldir. Has %n expanded. */\n\tcpu_freq_init(conf);\n\n\t/* Receive cpu_frequency info from slurmd */\n\tcpu_freq_recv_info(sock);\n\n\t/* get the protocol version of the srun */\n\tsafe_read(sock, &proto, sizeof(int));\n\n\t/* receive req from slurmd */\n\tsafe_read(sock, &len, sizeof(int));\n\tincoming_buffer = xmalloc(sizeof(char) * len);\n\tsafe_read(sock, incoming_buffer, len);\n\tbuffer = create_buf(incoming_buffer,len);\n\n\tmsg = xmalloc(sizeof(slurm_msg_t));\n\tslurm_msg_t_init(msg);\n\tmsg->protocol_version = (uint16_t)proto;\n\n\tswitch (step_type) {\n\tcase LAUNCH_BATCH_JOB:\n\t\tmsg->msg_type = REQUEST_BATCH_JOB_LAUNCH;\n\t\tbreak;\n\tcase LAUNCH_TASKS:\n\t\tmsg->msg_type = REQUEST_LAUNCH_TASKS;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: Unrecognized launch RPC (%d)\", __func__, step_type);\n\t\tbreak;\n\t}\n\tif (unpack_msg(msg, buffer) == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: we didn't unpack the request correctly\");\n\tfree_buf(buffer);\n\n\t/* receive cached group ids array for the relevant uid */\n\tsafe_read(sock, &ngids, sizeof(int));\n\tif (ngids > 0) {\n\t\tint i;\n\t\tuint32_t tmp32;\n\n\t\tgids = (gid_t *)xmalloc(sizeof(gid_t) * ngids);\n\t\tfor (i = 0; i < ngids; i++) {\n\t\t\tsafe_read(sock, &tmp32, sizeof(uint32_t));\n\t\t\tgids[i] = (gid_t)tmp32;\n\t\t\tdebug2(\"got gid %d\", gids[i]);\n\t\t}\n\t}\n\n\t*_cli = cli;\n\t*_self = self;\n\t*_msg = msg;\n\t*_ngids = ngids;\n\t*_gids = gids;\n\n\treturn 1;\n\nrwfail:\n\tfatal(\"Error reading initialization data from slurmd\");\n\texit(1);\n}"
  },
  {
    "function_name": "_got_ack_from_slurmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
    "lines": "378-390",
    "snippet": "static void\n_got_ack_from_slurmd(int sock)\n{\n\t/* If running under valgrind/memcheck, this pipe doesn't work correctly\n\t * so just skip it. */\n#if (SLURMSTEPD_MEMCHECK == 0)\n\tint ok;\n\tsafe_read(sock, &ok, sizeof(int));\n\treturn;\nrwfail:\n\terror(\"Unable to receive \\\"ok ack\\\" to slurmd\");\n#endif\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/slurmd/common/setproctitle.h\"",
      "#include \"src/slurmd/common/slurmstepd_init.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/slurm_mpi.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/common/plugstack.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <unistd.h>",
      "#include <sys/mman.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _send_ok_to_slurmd(int sock);",
      "static void _send_fail_to_slurmd(int sock);",
      "static void _got_ack_from_slurmd(int);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to receive \\\"ok ack\\\" to slurmd\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "sock",
            "&ok",
            "sizeof(int)"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic void _send_ok_to_slurmd(int sock);\nstatic void _send_fail_to_slurmd(int sock);\nstatic void _got_ack_from_slurmd(int);\n\nstatic void\n_got_ack_from_slurmd(int sock)\n{\n\t/* If running under valgrind/memcheck, this pipe doesn't work correctly\n\t * so just skip it. */\n#if (SLURMSTEPD_MEMCHECK == 0)\n\tint ok;\n\tsafe_read(sock, &ok, sizeof(int));\n\treturn;\nrwfail:\n\terror(\"Unable to receive \\\"ok ack\\\" to slurmd\");\n#endif\n}"
  },
  {
    "function_name": "_send_fail_to_slurmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
    "lines": "360-376",
    "snippet": "static void\n_send_fail_to_slurmd(int sock)\n{\n\t/* If running under valgrind/memcheck, this pipe doesn't work correctly\n\t * so just skip it. */\n#if (SLURMSTEPD_MEMCHECK == 0)\n\tint fail = SLURM_FAILURE;\n\n\tif (errno)\n\t\tfail = errno;\n\n\tsafe_write(sock, &fail, sizeof(int));\n\treturn;\nrwfail:\n\terror(\"Unable to send \\\"fail\\\" to slurmd\");\n#endif\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/slurmd/common/setproctitle.h\"",
      "#include \"src/slurmd/common/slurmstepd_init.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/slurm_mpi.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/common/plugstack.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <unistd.h>",
      "#include <sys/mman.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _send_ok_to_slurmd(int sock);",
      "static void _send_fail_to_slurmd(int sock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to send \\\"fail\\\" to slurmd\""
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "sock",
            "&fail",
            "sizeof(int)"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic void _send_ok_to_slurmd(int sock);\nstatic void _send_fail_to_slurmd(int sock);\n\nstatic void\n_send_fail_to_slurmd(int sock)\n{\n\t/* If running under valgrind/memcheck, this pipe doesn't work correctly\n\t * so just skip it. */\n#if (SLURMSTEPD_MEMCHECK == 0)\n\tint fail = SLURM_FAILURE;\n\n\tif (errno)\n\t\tfail = errno;\n\n\tsafe_write(sock, &fail, sizeof(int));\n\treturn;\nrwfail:\n\terror(\"Unable to send \\\"fail\\\" to slurmd\");\n#endif\n}"
  },
  {
    "function_name": "_send_ok_to_slurmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
    "lines": "346-358",
    "snippet": "static void\n_send_ok_to_slurmd(int sock)\n{\n\t/* If running under valgrind/memcheck, this pipe doesn't work correctly\n\t * so just skip it. */\n#if (SLURMSTEPD_MEMCHECK == 0)\n\tint ok = SLURM_SUCCESS;\n\tsafe_write(sock, &ok, sizeof(int));\n\treturn;\nrwfail:\n\terror(\"Unable to send \\\"ok\\\" to slurmd\");\n#endif\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/slurmd/common/setproctitle.h\"",
      "#include \"src/slurmd/common/slurmstepd_init.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/slurm_mpi.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/common/plugstack.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <unistd.h>",
      "#include <sys/mman.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _send_ok_to_slurmd(int sock);",
      "static void _send_fail_to_slurmd(int sock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to send \\\"ok\\\" to slurmd\""
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_write",
          "args": [
            "sock",
            "&ok",
            "sizeof(int)"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic void _send_ok_to_slurmd(int sock);\nstatic void _send_fail_to_slurmd(int sock);\n\nstatic void\n_send_ok_to_slurmd(int sock)\n{\n\t/* If running under valgrind/memcheck, this pipe doesn't work correctly\n\t * so just skip it. */\n#if (SLURMSTEPD_MEMCHECK == 0)\n\tint ok = SLURM_SUCCESS;\n\tsafe_write(sock, &ok, sizeof(int));\n\treturn;\nrwfail:\n\terror(\"Unable to send \\\"ok\\\" to slurmd\");\n#endif\n}"
  },
  {
    "function_name": "_process_cmdline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
    "lines": "330-343",
    "snippet": "static int _process_cmdline (int argc, char *argv[])\n{\n\tif ((argc == 2) && (xstrcmp(argv[1], \"getenv\") == 0)) {\n\t\tprint_rlimits();\n\t\t_dump_user_env();\n\t\texit(0);\n\t}\n\tif ((argc == 3) && (xstrcmp(argv[1], \"spank\") == 0)) {\n\t\tif (_handle_spank_mode(argc, argv) < 0)\n\t\t\texit (1);\n\t\texit (0);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/slurmd/common/setproctitle.h\"",
      "#include \"src/slurmd/common/slurmstepd_init.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/slurm_mpi.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/common/plugstack.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <unistd.h>",
      "#include <sys/mman.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _dump_user_env(void);",
      "static int _process_cmdline (int argc, char *argv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "exit",
          "args": [
            "0"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "_send_pending_exit_msgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "1890-1927",
          "snippet": "static int\n_send_pending_exit_msgs(stepd_step_rec_t *job)\n{\n\tint  i;\n\tint  nsent  = 0;\n\tint  status = 0;\n\tbool set    = false;\n\tuint32_t *tid;\n\n\t/*\n\t * Collect all exit codes with the same status into a\n\t * single message.\n\t */\n\ttid = xmalloc(sizeof(uint32_t) * job->node_tasks);\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tstepd_step_task_info_t *t = job->task[i];\n\n\t\tif (!t->exited || t->esent)\n\t\t\tcontinue;\n\n\t\tif (!set) {\n\t\t\tstatus = t->estatus;\n\t\t\tset    = true;\n\t\t} else if (status != t->estatus)\n\t\t\tcontinue;\n\n\t\ttid[nsent++] = t->gtid;\n\t\tt->esent = true;\n\t}\n\n\tif (nsent) {\n\t\tdebug2(\"Aggregated %d task exit messages\", nsent);\n\t\t_send_exit_msg(job, tid, nsent, status);\n\t}\n\txfree(tid);\n\n\treturn nsent;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static int  _send_exit_msg(stepd_step_rec_t *job, uint32_t *tid, int n,\n\t\t\t   int status);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int    _send_complete_batch_script_msg(stepd_step_rec_t *job,\n\t\t\t\t\t      int err, int status);",
            "static int _initgroups(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic int  _send_exit_msg(stepd_step_rec_t *job, uint32_t *tid, int n,\n\t\t\t   int status);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int    _send_complete_batch_script_msg(stepd_step_rec_t *job,\n\t\t\t\t\t      int err, int status);\nstatic int _initgroups(stepd_step_rec_t *job);\n\nstatic int\n_send_pending_exit_msgs(stepd_step_rec_t *job)\n{\n\tint  i;\n\tint  nsent  = 0;\n\tint  status = 0;\n\tbool set    = false;\n\tuint32_t *tid;\n\n\t/*\n\t * Collect all exit codes with the same status into a\n\t * single message.\n\t */\n\ttid = xmalloc(sizeof(uint32_t) * job->node_tasks);\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tstepd_step_task_info_t *t = job->task[i];\n\n\t\tif (!t->exited || t->esent)\n\t\t\tcontinue;\n\n\t\tif (!set) {\n\t\t\tstatus = t->estatus;\n\t\t\tset    = true;\n\t\t} else if (status != t->estatus)\n\t\t\tcontinue;\n\n\t\ttid[nsent++] = t->gtid;\n\t\tt->esent = true;\n\t}\n\n\tif (nsent) {\n\t\tdebug2(\"Aggregated %d task exit messages\", nsent);\n\t\t_send_exit_msg(job, tid, nsent, status);\n\t}\n\txfree(tid);\n\n\treturn nsent;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_handle_spank_mode",
          "args": [
            "argc",
            "argv"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "_handle_spank_mode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
          "lines": "274-325",
          "snippet": "static int _handle_spank_mode (int argc, char *argv[])\n{\n\tchar prefix[64] = \"spank-\";\n\tconst char *mode = argv[2];\n\tuid_t uid = (uid_t) -1;\n\tuint32_t jobid = (uint32_t) -1;\n\tlog_options_t lopts = LOG_OPTS_INITIALIZER;\n\n\t/*\n\t *  Not necessary to log to syslog\n\t */\n\tlopts.syslog_level = LOG_LEVEL_QUIET;\n\n\t/*\n\t *  Make our log prefix into spank-prolog: or spank-epilog:\n\t */\n\tstrcat (prefix, mode);\n\tlog_init(prefix, lopts, LOG_DAEMON, NULL);\n\n\t/*\n\t *  When we are started from slurmd, a lightweight config is\n\t *   sent over the stdin fd. If we are able to read this conf\n\t *   use it to reinitialize the log.\n\t *  It is not a fatal error if we fail to read the conf file.\n\t *   This could happen if slurmstepd is run standalone for\n\t *   testing.\n\t */\n\tif ((conf = read_slurmd_conf_lite (STDIN_FILENO)))\n\t\tlog_alter (conf->log_opts, 0, conf->logfile);\n\tclose (STDIN_FILENO);\n\n\tslurm_conf_init(NULL);\n\n\tif (get_jobid_uid_from_env (&jobid, &uid) < 0)\n\t\treturn error (\"spank environment invalid\");\n\n\tdebug(\"Running spank/%s for jobid [%u] uid [%u]\", mode, jobid, uid);\n\n\tif (xstrcmp (mode, \"prolog\") == 0) {\n\t\tif (spank_job_prolog (jobid, uid) < 0)\n\t\t\treturn (-1);\n\t}\n\telse if (xstrcmp (mode, \"epilog\") == 0) {\n\t\tif (spank_job_epilog (jobid, uid) < 0)\n\t\t\treturn (-1);\n\t}\n\telse {\n\t\terror (\"Invalid mode %s specified!\", mode);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <unistd.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _process_cmdline (int argc, char *argv[]);",
            "slurmd_conf_t * conf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic int _process_cmdline (int argc, char *argv[]);\nslurmd_conf_t * conf;\n\nstatic int _handle_spank_mode (int argc, char *argv[])\n{\n\tchar prefix[64] = \"spank-\";\n\tconst char *mode = argv[2];\n\tuid_t uid = (uid_t) -1;\n\tuint32_t jobid = (uint32_t) -1;\n\tlog_options_t lopts = LOG_OPTS_INITIALIZER;\n\n\t/*\n\t *  Not necessary to log to syslog\n\t */\n\tlopts.syslog_level = LOG_LEVEL_QUIET;\n\n\t/*\n\t *  Make our log prefix into spank-prolog: or spank-epilog:\n\t */\n\tstrcat (prefix, mode);\n\tlog_init(prefix, lopts, LOG_DAEMON, NULL);\n\n\t/*\n\t *  When we are started from slurmd, a lightweight config is\n\t *   sent over the stdin fd. If we are able to read this conf\n\t *   use it to reinitialize the log.\n\t *  It is not a fatal error if we fail to read the conf file.\n\t *   This could happen if slurmstepd is run standalone for\n\t *   testing.\n\t */\n\tif ((conf = read_slurmd_conf_lite (STDIN_FILENO)))\n\t\tlog_alter (conf->log_opts, 0, conf->logfile);\n\tclose (STDIN_FILENO);\n\n\tslurm_conf_init(NULL);\n\n\tif (get_jobid_uid_from_env (&jobid, &uid) < 0)\n\t\treturn error (\"spank environment invalid\");\n\n\tdebug(\"Running spank/%s for jobid [%u] uid [%u]\", mode, jobid, uid);\n\n\tif (xstrcmp (mode, \"prolog\") == 0) {\n\t\tif (spank_job_prolog (jobid, uid) < 0)\n\t\t\treturn (-1);\n\t}\n\telse if (xstrcmp (mode, \"epilog\") == 0) {\n\t\tif (spank_job_epilog (jobid, uid) < 0)\n\t\t\treturn (-1);\n\t}\n\telse {\n\t\terror (\"Invalid mode %s specified!\", mode);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "argv[1]",
            "\"spank\""
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_dump_user_env",
          "args": [],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "_dump_user_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
          "lines": "618-624",
          "snippet": "static void _dump_user_env(void)\n{\n\tint i;\n\n\tfor (i=0; environ[i]; i++)\n\t\tprintf(\"%s\\n\",environ[i]);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <unistd.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _dump_user_env(void);",
            "extern char  ** environ;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic void _dump_user_env(void);\nextern char  ** environ;\n\nstatic void _dump_user_env(void)\n{\n\tint i;\n\n\tfor (i=0; environ[i]; i++)\n\t\tprintf(\"%s\\n\",environ[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_rlimits",
          "args": [],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "argv[1]",
            "\"getenv\""
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic void _dump_user_env(void);\nstatic int _process_cmdline (int argc, char *argv[]);\n\nstatic int _process_cmdline (int argc, char *argv[])\n{\n\tif ((argc == 2) && (xstrcmp(argv[1], \"getenv\") == 0)) {\n\t\tprint_rlimits();\n\t\t_dump_user_env();\n\t\texit(0);\n\t}\n\tif ((argc == 3) && (xstrcmp(argv[1], \"spank\") == 0)) {\n\t\tif (_handle_spank_mode(argc, argv) < 0)\n\t\t\texit (1);\n\t\texit (0);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "_handle_spank_mode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
    "lines": "274-325",
    "snippet": "static int _handle_spank_mode (int argc, char *argv[])\n{\n\tchar prefix[64] = \"spank-\";\n\tconst char *mode = argv[2];\n\tuid_t uid = (uid_t) -1;\n\tuint32_t jobid = (uint32_t) -1;\n\tlog_options_t lopts = LOG_OPTS_INITIALIZER;\n\n\t/*\n\t *  Not necessary to log to syslog\n\t */\n\tlopts.syslog_level = LOG_LEVEL_QUIET;\n\n\t/*\n\t *  Make our log prefix into spank-prolog: or spank-epilog:\n\t */\n\tstrcat (prefix, mode);\n\tlog_init(prefix, lopts, LOG_DAEMON, NULL);\n\n\t/*\n\t *  When we are started from slurmd, a lightweight config is\n\t *   sent over the stdin fd. If we are able to read this conf\n\t *   use it to reinitialize the log.\n\t *  It is not a fatal error if we fail to read the conf file.\n\t *   This could happen if slurmstepd is run standalone for\n\t *   testing.\n\t */\n\tif ((conf = read_slurmd_conf_lite (STDIN_FILENO)))\n\t\tlog_alter (conf->log_opts, 0, conf->logfile);\n\tclose (STDIN_FILENO);\n\n\tslurm_conf_init(NULL);\n\n\tif (get_jobid_uid_from_env (&jobid, &uid) < 0)\n\t\treturn error (\"spank environment invalid\");\n\n\tdebug(\"Running spank/%s for jobid [%u] uid [%u]\", mode, jobid, uid);\n\n\tif (xstrcmp (mode, \"prolog\") == 0) {\n\t\tif (spank_job_prolog (jobid, uid) < 0)\n\t\t\treturn (-1);\n\t}\n\telse if (xstrcmp (mode, \"epilog\") == 0) {\n\t\tif (spank_job_epilog (jobid, uid) < 0)\n\t\t\treturn (-1);\n\t}\n\telse {\n\t\terror (\"Invalid mode %s specified!\", mode);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/slurmd/common/setproctitle.h\"",
      "#include \"src/slurmd/common/slurmstepd_init.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/slurm_mpi.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/common/plugstack.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <unistd.h>",
      "#include <sys/mman.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _process_cmdline (int argc, char *argv[]);",
      "slurmd_conf_t * conf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Invalid mode %s specified!\"",
            "mode"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "_task_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "641-650",
          "snippet": "static int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static bool _task_writable(eio_obj_t *);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int _task_write_error(eio_obj_t *obj, List objs);",
            "static bool _task_readable(eio_obj_t *);",
            "static int  _task_read(eio_obj_t *, List);",
            "static void _route_msg_task_to_client(eio_obj_t *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spank_job_epilog",
          "args": [
            "jobid",
            "uid"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "mode",
            "\"epilog\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spank_job_prolog",
          "args": [
            "jobid",
            "uid"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "mode",
            "\"prolog\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Running spank/%s for jobid [%u] uid [%u]\"",
            "mode",
            "jobid",
            "uid"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"spank environment invalid\""
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_jobid_uid_from_env",
          "args": [
            "&jobid",
            "&uid"
          ],
          "line": 307
        },
        "resolved": true,
        "details": {
          "function_name": "get_jobid_uid_from_env",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
          "lines": "252-272",
          "snippet": "static int get_jobid_uid_from_env (uint32_t *jobidp, uid_t *uidp)\n{\n\tconst char *val;\n\tchar *p;\n\n\tif (!(val = getenv (\"SLURM_JOBID\")))\n\t\treturn error (\"Unable to get SLURM_JOBID in env!\");\n\n\t*jobidp = (uint32_t) strtoul (val, &p, 10);\n\tif (*p != '\\0')\n\t\treturn error (\"Invalid SLURM_JOBID=%s\", val);\n\n\tif (!(val = getenv (\"SLURM_UID\")))\n\t\treturn error (\"Unable to get SLURM_UID in env!\");\n\n\t*uidp = (uid_t) strtoul (val, &p, 10);\n\tif (*p != '\\0')\n\t\treturn error (\"Invalid SLURM_UID=%s\", val);\n\n\treturn (0);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <unistd.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic int get_jobid_uid_from_env (uint32_t *jobidp, uid_t *uidp)\n{\n\tconst char *val;\n\tchar *p;\n\n\tif (!(val = getenv (\"SLURM_JOBID\")))\n\t\treturn error (\"Unable to get SLURM_JOBID in env!\");\n\n\t*jobidp = (uint32_t) strtoul (val, &p, 10);\n\tif (*p != '\\0')\n\t\treturn error (\"Invalid SLURM_JOBID=%s\", val);\n\n\tif (!(val = getenv (\"SLURM_UID\")))\n\t\treturn error (\"Unable to get SLURM_UID in env!\");\n\n\t*uidp = (uid_t) strtoul (val, &p, 10);\n\tif (*p != '\\0')\n\t\treturn error (\"Invalid SLURM_UID=%s\", val);\n\n\treturn (0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_conf_init",
          "args": [
            "NULL"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "io_close_local_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1463-1487",
          "snippet": "void\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static bool _task_writable(eio_obj_t *);",
            "static bool _task_readable(eio_obj_t *);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void *_io_thr(void *arg);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nvoid\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_alter",
          "args": [
            "conf->log_opts",
            "0",
            "conf->logfile"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_slurmd_conf_lite",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "read_slurmd_conf_lite",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
          "lines": "198-250",
          "snippet": "static slurmd_conf_t * read_slurmd_conf_lite (int fd)\n{\n\tint rc;\n\tint len;\n\tBuf buffer;\n\tslurmd_conf_t *confl;\n\tint tmp_int = 0;\n\n\t/*  First check to see if we've already initialized the\n\t *   global slurmd_conf_t in 'conf'. Allocate memory if not.\n\t */\n\tconfl = conf ? conf : xmalloc (sizeof (*confl));\n\n\tsafe_read(fd, &len, sizeof(int));\n\n\tbuffer = init_buf(len);\n\tsafe_read(fd, buffer->head, len);\n\n\trc = unpack_slurmd_conf_lite_no_alloc(confl, buffer);\n\tif (rc == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: problem with unpack of slurmd_conf\");\n\n\tfree_buf(buffer);\n\n\tconfl->log_opts.prefix_level = 1;\n\tconfl->log_opts.stderr_level = confl->debug_level;\n\tconfl->log_opts.logfile_level = confl->debug_level;\n\tconfl->log_opts.syslog_level = confl->debug_level;\n\t/*\n\t * If daemonizing, turn off stderr logging -- also, if\n\t * logging to a file, turn off syslog.\n\t *\n\t * Otherwise, if remaining in foreground, turn off logging\n\t * to syslog (but keep logfile level)\n\t */\n\tif (confl->daemonize) {\n\t\tconfl->log_opts.stderr_level = LOG_LEVEL_QUIET;\n\t\tif (confl->logfile)\n\t\t\tconfl->log_opts.syslog_level = LOG_LEVEL_QUIET;\n\t} else\n\t\tconfl->log_opts.syslog_level  = LOG_LEVEL_QUIET;\n\n\tconfl->acct_freq_task = (uint16_t)NO_VAL;\n\ttmp_int = acct_gather_parse_freq(PROFILE_TASK,\n\t\t\t\t       confl->job_acct_gather_freq);\n\tif (tmp_int != -1)\n\t\tconfl->acct_freq_task = tmp_int;\n\n\n\treturn (confl);\nrwfail:\n\treturn (NULL);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <unistd.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "slurmd_conf_t * conf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nslurmd_conf_t * conf;\n\nstatic slurmd_conf_t * read_slurmd_conf_lite (int fd)\n{\n\tint rc;\n\tint len;\n\tBuf buffer;\n\tslurmd_conf_t *confl;\n\tint tmp_int = 0;\n\n\t/*  First check to see if we've already initialized the\n\t *   global slurmd_conf_t in 'conf'. Allocate memory if not.\n\t */\n\tconfl = conf ? conf : xmalloc (sizeof (*confl));\n\n\tsafe_read(fd, &len, sizeof(int));\n\n\tbuffer = init_buf(len);\n\tsafe_read(fd, buffer->head, len);\n\n\trc = unpack_slurmd_conf_lite_no_alloc(confl, buffer);\n\tif (rc == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: problem with unpack of slurmd_conf\");\n\n\tfree_buf(buffer);\n\n\tconfl->log_opts.prefix_level = 1;\n\tconfl->log_opts.stderr_level = confl->debug_level;\n\tconfl->log_opts.logfile_level = confl->debug_level;\n\tconfl->log_opts.syslog_level = confl->debug_level;\n\t/*\n\t * If daemonizing, turn off stderr logging -- also, if\n\t * logging to a file, turn off syslog.\n\t *\n\t * Otherwise, if remaining in foreground, turn off logging\n\t * to syslog (but keep logfile level)\n\t */\n\tif (confl->daemonize) {\n\t\tconfl->log_opts.stderr_level = LOG_LEVEL_QUIET;\n\t\tif (confl->logfile)\n\t\t\tconfl->log_opts.syslog_level = LOG_LEVEL_QUIET;\n\t} else\n\t\tconfl->log_opts.syslog_level  = LOG_LEVEL_QUIET;\n\n\tconfl->acct_freq_task = (uint16_t)NO_VAL;\n\ttmp_int = acct_gather_parse_freq(PROFILE_TASK,\n\t\t\t\t       confl->job_acct_gather_freq);\n\tif (tmp_int != -1)\n\t\tconfl->acct_freq_task = tmp_int;\n\n\n\treturn (confl);\nrwfail:\n\treturn (NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "log_init",
          "args": [
            "prefix",
            "lopts",
            "LOG_DAEMON",
            "NULL"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "prefix",
            "mode"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic int _process_cmdline (int argc, char *argv[]);\nslurmd_conf_t * conf;\n\nstatic int _handle_spank_mode (int argc, char *argv[])\n{\n\tchar prefix[64] = \"spank-\";\n\tconst char *mode = argv[2];\n\tuid_t uid = (uid_t) -1;\n\tuint32_t jobid = (uint32_t) -1;\n\tlog_options_t lopts = LOG_OPTS_INITIALIZER;\n\n\t/*\n\t *  Not necessary to log to syslog\n\t */\n\tlopts.syslog_level = LOG_LEVEL_QUIET;\n\n\t/*\n\t *  Make our log prefix into spank-prolog: or spank-epilog:\n\t */\n\tstrcat (prefix, mode);\n\tlog_init(prefix, lopts, LOG_DAEMON, NULL);\n\n\t/*\n\t *  When we are started from slurmd, a lightweight config is\n\t *   sent over the stdin fd. If we are able to read this conf\n\t *   use it to reinitialize the log.\n\t *  It is not a fatal error if we fail to read the conf file.\n\t *   This could happen if slurmstepd is run standalone for\n\t *   testing.\n\t */\n\tif ((conf = read_slurmd_conf_lite (STDIN_FILENO)))\n\t\tlog_alter (conf->log_opts, 0, conf->logfile);\n\tclose (STDIN_FILENO);\n\n\tslurm_conf_init(NULL);\n\n\tif (get_jobid_uid_from_env (&jobid, &uid) < 0)\n\t\treturn error (\"spank environment invalid\");\n\n\tdebug(\"Running spank/%s for jobid [%u] uid [%u]\", mode, jobid, uid);\n\n\tif (xstrcmp (mode, \"prolog\") == 0) {\n\t\tif (spank_job_prolog (jobid, uid) < 0)\n\t\t\treturn (-1);\n\t}\n\telse if (xstrcmp (mode, \"epilog\") == 0) {\n\t\tif (spank_job_epilog (jobid, uid) < 0)\n\t\t\treturn (-1);\n\t}\n\telse {\n\t\terror (\"Invalid mode %s specified!\", mode);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}"
  },
  {
    "function_name": "get_jobid_uid_from_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
    "lines": "252-272",
    "snippet": "static int get_jobid_uid_from_env (uint32_t *jobidp, uid_t *uidp)\n{\n\tconst char *val;\n\tchar *p;\n\n\tif (!(val = getenv (\"SLURM_JOBID\")))\n\t\treturn error (\"Unable to get SLURM_JOBID in env!\");\n\n\t*jobidp = (uint32_t) strtoul (val, &p, 10);\n\tif (*p != '\\0')\n\t\treturn error (\"Invalid SLURM_JOBID=%s\", val);\n\n\tif (!(val = getenv (\"SLURM_UID\")))\n\t\treturn error (\"Unable to get SLURM_UID in env!\");\n\n\t*uidp = (uid_t) strtoul (val, &p, 10);\n\tif (*p != '\\0')\n\t\treturn error (\"Invalid SLURM_UID=%s\", val);\n\n\treturn (0);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/slurmd/common/setproctitle.h\"",
      "#include \"src/slurmd/common/slurmstepd_init.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/slurm_mpi.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/common/plugstack.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <unistd.h>",
      "#include <sys/mman.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Invalid SLURM_UID=%s\"",
            "val"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "_task_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "641-650",
          "snippet": "static int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static bool _task_writable(eio_obj_t *);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int _task_write_error(eio_obj_t *obj, List objs);",
            "static bool _task_readable(eio_obj_t *);",
            "static int  _task_read(eio_obj_t *, List);",
            "static void _route_msg_task_to_client(eio_obj_t *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "val",
            "&p",
            "10"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to get SLURM_UID in env!\""
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SLURM_UID\""
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtoul",
          "args": [
            "val",
            "&p",
            "10"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to get SLURM_JOBID in env!\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenv",
          "args": [
            "\"SLURM_JOBID\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic int get_jobid_uid_from_env (uint32_t *jobidp, uid_t *uidp)\n{\n\tconst char *val;\n\tchar *p;\n\n\tif (!(val = getenv (\"SLURM_JOBID\")))\n\t\treturn error (\"Unable to get SLURM_JOBID in env!\");\n\n\t*jobidp = (uint32_t) strtoul (val, &p, 10);\n\tif (*p != '\\0')\n\t\treturn error (\"Invalid SLURM_JOBID=%s\", val);\n\n\tif (!(val = getenv (\"SLURM_UID\")))\n\t\treturn error (\"Unable to get SLURM_UID in env!\");\n\n\t*uidp = (uid_t) strtoul (val, &p, 10);\n\tif (*p != '\\0')\n\t\treturn error (\"Invalid SLURM_UID=%s\", val);\n\n\treturn (0);\n}"
  },
  {
    "function_name": "read_slurmd_conf_lite",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
    "lines": "198-250",
    "snippet": "static slurmd_conf_t * read_slurmd_conf_lite (int fd)\n{\n\tint rc;\n\tint len;\n\tBuf buffer;\n\tslurmd_conf_t *confl;\n\tint tmp_int = 0;\n\n\t/*  First check to see if we've already initialized the\n\t *   global slurmd_conf_t in 'conf'. Allocate memory if not.\n\t */\n\tconfl = conf ? conf : xmalloc (sizeof (*confl));\n\n\tsafe_read(fd, &len, sizeof(int));\n\n\tbuffer = init_buf(len);\n\tsafe_read(fd, buffer->head, len);\n\n\trc = unpack_slurmd_conf_lite_no_alloc(confl, buffer);\n\tif (rc == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: problem with unpack of slurmd_conf\");\n\n\tfree_buf(buffer);\n\n\tconfl->log_opts.prefix_level = 1;\n\tconfl->log_opts.stderr_level = confl->debug_level;\n\tconfl->log_opts.logfile_level = confl->debug_level;\n\tconfl->log_opts.syslog_level = confl->debug_level;\n\t/*\n\t * If daemonizing, turn off stderr logging -- also, if\n\t * logging to a file, turn off syslog.\n\t *\n\t * Otherwise, if remaining in foreground, turn off logging\n\t * to syslog (but keep logfile level)\n\t */\n\tif (confl->daemonize) {\n\t\tconfl->log_opts.stderr_level = LOG_LEVEL_QUIET;\n\t\tif (confl->logfile)\n\t\t\tconfl->log_opts.syslog_level = LOG_LEVEL_QUIET;\n\t} else\n\t\tconfl->log_opts.syslog_level  = LOG_LEVEL_QUIET;\n\n\tconfl->acct_freq_task = (uint16_t)NO_VAL;\n\ttmp_int = acct_gather_parse_freq(PROFILE_TASK,\n\t\t\t\t       confl->job_acct_gather_freq);\n\tif (tmp_int != -1)\n\t\tconfl->acct_freq_task = tmp_int;\n\n\n\treturn (confl);\nrwfail:\n\treturn (NULL);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/slurmd/common/setproctitle.h\"",
      "#include \"src/slurmd/common/slurmstepd_init.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/slurm_mpi.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/common/plugstack.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <unistd.h>",
      "#include <sys/mman.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "slurmd_conf_t * conf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "acct_gather_parse_freq",
          "args": [
            "PROFILE_TASK",
            "confl->job_acct_gather_freq"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buf",
          "args": [
            "buffer"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"slurmstepd: problem with unpack of slurmd_conf\""
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unpack_slurmd_conf_lite_no_alloc",
          "args": [
            "confl",
            "buffer"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "unpack_slurmd_conf_lite_no_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/slurmstepd_init.c",
          "lines": "79-135",
          "snippet": "extern int unpack_slurmd_conf_lite_no_alloc(slurmd_conf_t *conf, Buf buffer)\n{\n\tuint32_t uint32_tmp;\n\n\tsafe_unpackstr_xmalloc(&conf->hostname, &uint32_tmp, buffer);\n\tsafe_unpack16(&conf->cpus, buffer);\n\tsafe_unpack16(&conf->boards, buffer);\n\tsafe_unpack16(&conf->sockets, buffer);\n\tsafe_unpack16(&conf->cores, buffer);\n\tsafe_unpack16(&conf->threads, buffer);\n\tsafe_unpack32(&conf->real_memory_size, buffer);\n\tsafe_unpack16(&conf->block_map_size, buffer);\n\tsafe_unpack16_array(&conf->block_map, &uint32_tmp, buffer);\n\tsafe_unpack16_array(&conf->block_map_inv,  &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->spooldir,    &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->node_name,   &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->logfile,     &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->task_prolog, &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->task_epilog, &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->job_acct_gather_freq, &uint32_tmp,\n\t\t\t       buffer);\n\tsafe_unpackstr_xmalloc(&conf->job_acct_gather_type, &uint32_tmp,\n\t\t\t       buffer);\n\tsafe_unpack16(&conf->propagate_prio, buffer);\n\tsafe_unpack64(&conf->debug_flags, buffer);\n\tsafe_unpack32(&uint32_tmp, buffer);\n\tconf->debug_level = uint32_tmp;\n\tsafe_unpack32(&uint32_tmp, buffer);\n\tconf->daemonize = uint32_tmp;\n\tsafe_unpack32(&uint32_tmp, buffer);\n\tconf->slurm_user_id = (uid_t)uint32_tmp;\n\tsafe_unpack16(&conf->use_pam, buffer);\n\tsafe_unpack32(&conf->task_plugin_param, buffer);\n\tsafe_unpackstr_xmalloc(&conf->node_topo_addr, &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->node_topo_pattern, &uint32_tmp, buffer);\n\tsafe_unpack32(&uint32_tmp, buffer);\n\tconf->port = uint32_tmp;\n\tsafe_unpack16(&conf->log_fmt, buffer);\n\tsafe_unpack16(&conf->mem_limit_enforce, buffer);\n\tsafe_unpack64(&conf->msg_aggr_window_msgs, buffer);\n\n\treturn SLURM_SUCCESS;\n\nunpack_error:\n\terror(\"unpack_error in unpack_slurmd_conf_lite_no_alloc: %m\");\n\txfree(conf->job_acct_gather_freq);\n\txfree(conf->job_acct_gather_type);\n\txfree(conf->hostname);\n\txfree(conf->spooldir);\n\txfree(conf->node_name);\n\txfree(conf->logfile);\n\txfree(conf->task_prolog);\n\txfree(conf->task_epilog);\n\txfree(conf->node_topo_addr);\n\txfree(conf->node_topo_pattern);\n\treturn SLURM_ERROR;\n}",
          "includes": [
            "#include \"src/slurmd/common/slurmstepd_init.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/slurmstepd_init.h\"\n\nextern int unpack_slurmd_conf_lite_no_alloc(slurmd_conf_t *conf, Buf buffer)\n{\n\tuint32_t uint32_tmp;\n\n\tsafe_unpackstr_xmalloc(&conf->hostname, &uint32_tmp, buffer);\n\tsafe_unpack16(&conf->cpus, buffer);\n\tsafe_unpack16(&conf->boards, buffer);\n\tsafe_unpack16(&conf->sockets, buffer);\n\tsafe_unpack16(&conf->cores, buffer);\n\tsafe_unpack16(&conf->threads, buffer);\n\tsafe_unpack32(&conf->real_memory_size, buffer);\n\tsafe_unpack16(&conf->block_map_size, buffer);\n\tsafe_unpack16_array(&conf->block_map, &uint32_tmp, buffer);\n\tsafe_unpack16_array(&conf->block_map_inv,  &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->spooldir,    &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->node_name,   &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->logfile,     &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->task_prolog, &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->task_epilog, &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->job_acct_gather_freq, &uint32_tmp,\n\t\t\t       buffer);\n\tsafe_unpackstr_xmalloc(&conf->job_acct_gather_type, &uint32_tmp,\n\t\t\t       buffer);\n\tsafe_unpack16(&conf->propagate_prio, buffer);\n\tsafe_unpack64(&conf->debug_flags, buffer);\n\tsafe_unpack32(&uint32_tmp, buffer);\n\tconf->debug_level = uint32_tmp;\n\tsafe_unpack32(&uint32_tmp, buffer);\n\tconf->daemonize = uint32_tmp;\n\tsafe_unpack32(&uint32_tmp, buffer);\n\tconf->slurm_user_id = (uid_t)uint32_tmp;\n\tsafe_unpack16(&conf->use_pam, buffer);\n\tsafe_unpack32(&conf->task_plugin_param, buffer);\n\tsafe_unpackstr_xmalloc(&conf->node_topo_addr, &uint32_tmp, buffer);\n\tsafe_unpackstr_xmalloc(&conf->node_topo_pattern, &uint32_tmp, buffer);\n\tsafe_unpack32(&uint32_tmp, buffer);\n\tconf->port = uint32_tmp;\n\tsafe_unpack16(&conf->log_fmt, buffer);\n\tsafe_unpack16(&conf->mem_limit_enforce, buffer);\n\tsafe_unpack64(&conf->msg_aggr_window_msgs, buffer);\n\n\treturn SLURM_SUCCESS;\n\nunpack_error:\n\terror(\"unpack_error in unpack_slurmd_conf_lite_no_alloc: %m\");\n\txfree(conf->job_acct_gather_freq);\n\txfree(conf->job_acct_gather_type);\n\txfree(conf->hostname);\n\txfree(conf->spooldir);\n\txfree(conf->node_name);\n\txfree(conf->logfile);\n\txfree(conf->task_prolog);\n\txfree(conf->task_epilog);\n\txfree(conf->node_topo_addr);\n\txfree(conf->node_topo_pattern);\n\treturn SLURM_ERROR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "buffer->head",
            "len"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_buf",
          "args": [
            "len"
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "safe_read",
          "args": [
            "fd",
            "&len",
            "sizeof(int)"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof (*confl)"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nslurmd_conf_t * conf;\n\nstatic slurmd_conf_t * read_slurmd_conf_lite (int fd)\n{\n\tint rc;\n\tint len;\n\tBuf buffer;\n\tslurmd_conf_t *confl;\n\tint tmp_int = 0;\n\n\t/*  First check to see if we've already initialized the\n\t *   global slurmd_conf_t in 'conf'. Allocate memory if not.\n\t */\n\tconfl = conf ? conf : xmalloc (sizeof (*confl));\n\n\tsafe_read(fd, &len, sizeof(int));\n\n\tbuffer = init_buf(len);\n\tsafe_read(fd, buffer->head, len);\n\n\trc = unpack_slurmd_conf_lite_no_alloc(confl, buffer);\n\tif (rc == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: problem with unpack of slurmd_conf\");\n\n\tfree_buf(buffer);\n\n\tconfl->log_opts.prefix_level = 1;\n\tconfl->log_opts.stderr_level = confl->debug_level;\n\tconfl->log_opts.logfile_level = confl->debug_level;\n\tconfl->log_opts.syslog_level = confl->debug_level;\n\t/*\n\t * If daemonizing, turn off stderr logging -- also, if\n\t * logging to a file, turn off syslog.\n\t *\n\t * Otherwise, if remaining in foreground, turn off logging\n\t * to syslog (but keep logfile level)\n\t */\n\tif (confl->daemonize) {\n\t\tconfl->log_opts.stderr_level = LOG_LEVEL_QUIET;\n\t\tif (confl->logfile)\n\t\t\tconfl->log_opts.syslog_level = LOG_LEVEL_QUIET;\n\t} else\n\t\tconfl->log_opts.syslog_level  = LOG_LEVEL_QUIET;\n\n\tconfl->acct_freq_task = (uint16_t)NO_VAL;\n\ttmp_int = acct_gather_parse_freq(PROFILE_TASK,\n\t\t\t\t       confl->job_acct_gather_freq);\n\tif (tmp_int != -1)\n\t\tconfl->acct_freq_task = tmp_int;\n\n\n\treturn (confl);\nrwfail:\n\treturn (NULL);\n}"
  },
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
    "lines": "98-195",
    "snippet": "int\nmain (int argc, char *argv[])\n{\n\tslurm_addr_t *cli;\n\tslurm_addr_t *self;\n\tslurm_msg_t *msg;\n\tstepd_step_rec_t *job;\n\tint ngids;\n\tgid_t *gids;\n\tint rc = 0;\n\n\tif (_process_cmdline (argc, argv) < 0)\n\t\tfatal (\"Error in slurmstepd command line\");\n\n\txsignal_block(slurmstepd_blocked_signals);\n\tconf = xmalloc(sizeof(*conf));\n\tconf->argv = &argv;\n\tconf->argc = &argc;\n\tinit_setproctitle(argc, argv);\n\tif (slurm_select_init(1) != SLURM_SUCCESS )\n\t\tfatal( \"failed to initialize node selection plugin\" );\n\tif (slurm_auth_init(NULL) != SLURM_SUCCESS)\n\t\tfatal( \"failed to initialize authentication plugin\" );\n\n\t/* Receive job parameters from the slurmd */\n\t_init_from_slurmd(STDIN_FILENO, argv, &cli, &self, &msg,\n\t\t\t  &ngids, &gids);\n\n\t/* Create the stepd_step_rec_t, mostly from info in a\n\t * launch_tasks_request_msg_t or a batch_job_launch_msg_t */\n\tif (!(job = _step_setup(cli, self, msg))) {\n\t\t_send_fail_to_slurmd(STDOUT_FILENO);\n\t\trc = SLURM_FAILURE;\n\t\tgoto ending;\n\t}\n\tjob->ngids = ngids;\n\tjob->gids = gids;\n\n\t/* fork handlers cause mutexes on some global data structures\n\t * to be re-initialized after the fork. */\n\tlist_install_fork_handlers();\n\tslurm_conf_install_fork_handlers();\n\n\t/* sets job->msg_handle and job->msgid */\n\tif (msg_thr_create(job) == SLURM_ERROR) {\n\t\t_send_fail_to_slurmd(STDOUT_FILENO);\n\t\trc = SLURM_FAILURE;\n\t\tgoto ending;\n\t}\n\n\t_send_ok_to_slurmd(STDOUT_FILENO);\n\t_got_ack_from_slurmd(STDIN_FILENO);\n\n\t/* Fancy way of closing stdin that keeps STDIN_FILENO from being\n\t * allocated to any random file.  The slurmd already opened /dev/null\n\t * on STDERR_FILENO for us. */\n\tdup2(STDERR_FILENO, STDIN_FILENO);\n\n\t/* Fancy way of closing stdout that keeps STDOUT_FILENO from being\n\t * allocated to any random file.  The slurmd already opened /dev/null\n\t * on STDERR_FILENO for us. */\n\tdup2(STDERR_FILENO, STDOUT_FILENO);\n\n\t/* This does most of the stdio setup, then launches all the tasks,\n\t * and blocks until the step is complete */\n\trc = job_manager(job);\n\n\tif (job->batch)\n\t\tbatch_finish(job, rc); /* sends batch complete message */\n\n\t/* signal the message thread to shutdown, and wait for it */\n\teio_signal_shutdown(job->msg_handle);\n\tpthread_join(job->msgid, NULL);\n\nending:\n\tmpi_fini();\t/* Remove stale PMI2 sockets */\n#ifdef MEMORY_LEAK_DEBUG\n\tacct_gather_conf_destroy();\n\t(void) core_spec_g_fini();\n\t_step_cleanup(job, msg, rc);\n\n\tfini_setproctitle();\n\n\txfree(cli);\n\txfree(self);\n\txfree(conf->block_map);\n\txfree(conf->block_map_inv);\n\txfree(conf->hostname);\n\txfree(conf->logfile);\n\txfree(conf->node_name);\n\txfree(conf->node_topo_addr);\n\txfree(conf->node_topo_pattern);\n\txfree(conf->spooldir);\n\txfree(conf);\n#endif\n\tinfo(\"done with job\");\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/req.h\"",
      "#include \"src/slurmd/slurmstepd/mgr.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/slurmd/common/proctrack.h\"",
      "#include \"src/slurmd/common/setproctitle.h\"",
      "#include \"src/slurmd/common/slurmstepd_init.h\"",
      "#include \"src/slurmd/common/core_spec_plugin.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/switch.h\"",
      "#include \"src/common/stepd_api.h\"",
      "#include \"src/common/slurm_rlimits_info.h\"",
      "#include \"src/common/slurm_mpi.h\"",
      "#include \"src/common/slurm_acct_gather_profile.h\"",
      "#include \"src/common/slurm_jobacct_gather.h\"",
      "#include \"src/common/slurm_auth.h\"",
      "#include \"src/common/plugstack.h\"",
      "#include \"src/common/node_select.h\"",
      "#include \"src/common/gres.h\"",
      "#include \"src/common/cpu_frequency.h\"",
      "#include <unistd.h>",
      "#include <sys/mman.h>",
      "#include <stdlib.h>",
      "#include <signal.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void _got_ack_from_slurmd(int);",
      "static stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);",
      "static int _process_cmdline (int argc, char *argv[]);",
      "int slurmstepd_blocked_signals[] = {\n\tSIGPIPE, 0\n};",
      "slurmd_conf_t * conf;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "info",
          "args": [
            "\"done with job\""
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "_fork_child_with_wait_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "1464-1486",
          "snippet": "static struct exec_wait_info * _fork_child_with_wait_info (int id)\n{\n\tstruct exec_wait_info *e;\n\n\tif (!(e = _exec_wait_info_create (id)))\n\t\treturn (NULL);\n\n\tif ((e->pid = fork ()) < 0) {\n\t\t_exec_wait_info_destroy (e);\n\t\treturn (NULL);\n\t}\n\t/*\n\t *  Close parentfd in child, and childfd in parent:\n\t */\n\tif (e->pid == 0) {\n\t\tclose (e->parentfd);\n\t\te->parentfd = -1;\n\t} else {\n\t\tclose (e->childfd);\n\t\te->childfd = -1;\n\t}\n\treturn (e);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic struct exec_wait_info * _fork_child_with_wait_info (int id)\n{\n\tstruct exec_wait_info *e;\n\n\tif (!(e = _exec_wait_info_create (id)))\n\t\treturn (NULL);\n\n\tif ((e->pid = fork ()) < 0) {\n\t\t_exec_wait_info_destroy (e);\n\t\treturn (NULL);\n\t}\n\t/*\n\t *  Close parentfd in child, and childfd in parent:\n\t */\n\tif (e->pid == 0) {\n\t\tclose (e->parentfd);\n\t\te->parentfd = -1;\n\t} else {\n\t\tclose (e->childfd);\n\t\te->childfd = -1;\n\t}\n\treturn (e);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "conf"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fini_setproctitle",
          "args": [],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "fini_setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/setproctitle.c",
          "lines": "332-347",
          "snippet": "void fini_setproctitle(void)\n{\n#if SETPROCTITLE_STRATEGY == PS_USE_CLOBBER_ARGV\n\tint i;\n\n\tif (!new_environ)\n\t\treturn;\n\n\tfor (i = 0; new_environ[i] != NULL; i++) {\n\t\tfree(new_environ[i]);\n\t}\n\tfree(new_environ);\n\tnew_environ = (char **) NULL;\n\tenviron = new_environ;\n#endif /* PS_USE_CLOBBER_ARGV */\n}",
          "includes": [
            "#include <sys/exec.h>",
            "#include <machine/vmparam.h>\t/* for old BSD */",
            "#include <sys/pstat.h>\t\t/* for HP-UX */",
            "#include \"src/common/strlcpy.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#    include \"src/common/malloc.h\"",
            "#  include \"config.h\""
          ],
          "macros_used": [
            "#define PS_USE_CLOBBER_ARGV\t\t4"
          ],
          "globals_used": [
            "extern char **environ;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/exec.h>\n#include <machine/vmparam.h>\t/* for old BSD */\n#include <sys/pstat.h>\t\t/* for HP-UX */\n#include \"src/common/strlcpy.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#    include \"src/common/malloc.h\"\n#  include \"config.h\"\n\n#define PS_USE_CLOBBER_ARGV\t\t4\n\nextern char **environ;\n\nvoid fini_setproctitle(void)\n{\n#if SETPROCTITLE_STRATEGY == PS_USE_CLOBBER_ARGV\n\tint i;\n\n\tif (!new_environ)\n\t\treturn;\n\n\tfor (i = 0; new_environ[i] != NULL; i++) {\n\t\tfree(new_environ[i]);\n\t}\n\tfree(new_environ);\n\tnew_environ = (char **) NULL;\n\tenviron = new_environ;\n#endif /* PS_USE_CLOBBER_ARGV */\n}"
        }
      },
      {
        "call_info": {
          "callee": "_step_cleanup",
          "args": [
            "job",
            "msg",
            "rc"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "_step_cleanup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
          "lines": "588-615",
          "snippet": "static void\n_step_cleanup(stepd_step_rec_t *job, slurm_msg_t *msg, int rc)\n{\n\tif (job) {\n\t\tjobacctinfo_destroy(job->jobacct);\n\t\tif (!job->batch)\n\t\t\tstepd_step_rec_destroy(job);\n\t}\n\t/*\n\t * The message cannot be freed until the jobstep is complete\n\t * because the job struct has pointers into the msg, such\n\t * as the switch jobinfo pointer.\n\t */\n\tswitch(msg->msg_type) {\n\tcase REQUEST_BATCH_JOB_LAUNCH:\n\t\tslurm_free_job_launch_msg(msg->data);\n\t\tbreak;\n\tcase REQUEST_LAUNCH_TASKS:\n\t\tslurm_free_launch_tasks_request_msg(msg->data);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"handle_launch_message: Unrecognized launch RPC\");\n\t\tbreak;\n\t}\n\tjobacctinfo_destroy(step_complete.jobacct);\n\n\txfree(msg);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <unistd.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);\n\nstatic void\n_step_cleanup(stepd_step_rec_t *job, slurm_msg_t *msg, int rc)\n{\n\tif (job) {\n\t\tjobacctinfo_destroy(job->jobacct);\n\t\tif (!job->batch)\n\t\t\tstepd_step_rec_destroy(job);\n\t}\n\t/*\n\t * The message cannot be freed until the jobstep is complete\n\t * because the job struct has pointers into the msg, such\n\t * as the switch jobinfo pointer.\n\t */\n\tswitch(msg->msg_type) {\n\tcase REQUEST_BATCH_JOB_LAUNCH:\n\t\tslurm_free_job_launch_msg(msg->data);\n\t\tbreak;\n\tcase REQUEST_LAUNCH_TASKS:\n\t\tslurm_free_launch_tasks_request_msg(msg->data);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"handle_launch_message: Unrecognized launch RPC\");\n\t\tbreak;\n\t}\n\tjobacctinfo_destroy(step_complete.jobacct);\n\n\txfree(msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "core_spec_g_fini",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "core_spec_g_fini",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/core_spec_plugin.c",
          "lines": "144-169",
          "snippet": "extern int core_spec_g_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\tif (!g_core_spec_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_core_spec_context_num; i++) {\n\t\tif (g_core_spec_context[i]) {\n\t\t\tif (plugin_context_destroy(g_core_spec_context[i])\n\t\t\t    != SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_core_spec_context);\n\tg_core_spec_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\treturn rc;\n}",
          "includes": [
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/slurm_protocol_api.h\"",
            "#include \"src/common/plugrack.h\"",
            "#include \"src/common/plugin.h\"",
            "#include <pthread.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static core_spec_ops_t\t\t*ops = NULL;",
            "static plugin_context_t\t\t**g_core_spec_context = NULL;",
            "static int\t\t\tg_core_spec_context_num = -1;",
            "static pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;",
            "static bool init_run = false;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/slurm_protocol_api.h\"\n#include \"src/common/plugrack.h\"\n#include \"src/common/plugin.h\"\n#include <pthread.h>\n\nstatic core_spec_ops_t\t\t*ops = NULL;\nstatic plugin_context_t\t\t**g_core_spec_context = NULL;\nstatic int\t\t\tg_core_spec_context_num = -1;\nstatic pthread_mutex_t\t\tg_core_spec_context_lock =\n\t\t\t\t\tPTHREAD_MUTEX_INITIALIZER;\nstatic bool init_run = false;\n\nextern int core_spec_g_fini(void)\n{\n\tint i, rc = SLURM_SUCCESS;\n\n\tslurm_mutex_lock(&g_core_spec_context_lock);\n\tif (!g_core_spec_context)\n\t\tgoto done;\n\n\tinit_run = false;\n\tfor (i = 0; i < g_core_spec_context_num; i++) {\n\t\tif (g_core_spec_context[i]) {\n\t\t\tif (plugin_context_destroy(g_core_spec_context[i])\n\t\t\t    != SLURM_SUCCESS) {\n\t\t\t\trc = SLURM_ERROR;\n\t\t\t}\n\t\t}\n\t}\n\n\txfree(ops);\n\txfree(g_core_spec_context);\n\tg_core_spec_context_num = -1;\n\ndone:\n\tslurm_mutex_unlock(&g_core_spec_context_lock);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "acct_gather_conf_destroy",
          "args": [],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mpi_fini",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_join",
          "args": [
            "job->msgid",
            "NULL"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eio_signal_shutdown",
          "args": [
            "job->msg_handle"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "batch_finish",
          "args": [
            "job",
            "rc"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "batch_finish",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "395-432",
          "snippet": "extern void\nbatch_finish(stepd_step_rec_t *job, int rc)\n{\n\tstep_complete.step_rc = _get_exit_code(job);\n\n\tif (job->argv[0] && (unlink(job->argv[0]) < 0))\n\t\terror(\"unlink(%s): %m\", job->argv[0]);\n\n#ifdef HAVE_ALPS_CRAY\n\t_call_select_plugin_from_stepd(job, 0, select_g_job_fini);\n#endif\n\n\tif (job->aborted) {\n\t\tif ((job->stepid == NO_VAL) ||\n\t\t    (job->stepid == SLURM_BATCH_SCRIPT)) {\n\t\t\tinfo(\"step %u.%u abort completed\",\n\t\t\t     job->jobid, job->stepid);\n\t\t} else\n\t\t\tinfo(\"job %u abort completed\", job->jobid);\n\t} else if ((job->stepid == NO_VAL) ||\n\t\t   (job->stepid == SLURM_BATCH_SCRIPT)) {\n\t\tverbose(\"job %u completed with slurm_rc = %d, job_rc = %d\",\n\t\t\tjob->jobid, rc, step_complete.step_rc);\n\t\t_send_complete_batch_script_msg(job, rc, step_complete.step_rc);\n\t} else {\n\t\t_wait_for_children_slurmstepd(job);\n\t\tverbose(\"job %u.%u completed with slurm_rc = %d, job_rc = %d\",\n\t\t\tjob->jobid, job->stepid, rc, step_complete.step_rc);\n\t\t_send_step_complete_msgs(job);\n\t}\n\n\t/* Do not purge directory until slurmctld is notified of batch job\n\t * completion to avoid race condition with slurmd registering missing\n\t * batch job. */\n\tif (job->batchdir && (rmdir(job->batchdir) < 0))\n\t\terror(\"rmdir(%s): %m\",  job->batchdir);\n\txfree(job->batchdir);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "step_complete_t step_complete = {\n\tPTHREAD_COND_INITIALIZER,\n\tPTHREAD_MUTEX_INITIALIZER,\n\t-1,\n\t-1,\n\t-1,\n\t{},\n\t-1,\n\t-1,\n\ttrue,\n\t(bitstr_t *)NULL,\n\t0,\n\tNULL\n};",
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static void _send_launch_resp(stepd_step_rec_t *job, int rc);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int _initgroups(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstep_complete_t step_complete = {\n\tPTHREAD_COND_INITIALIZER,\n\tPTHREAD_MUTEX_INITIALIZER,\n\t-1,\n\t-1,\n\t-1,\n\t{},\n\t-1,\n\t-1,\n\ttrue,\n\t(bitstr_t *)NULL,\n\t0,\n\tNULL\n};\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic void _send_launch_resp(stepd_step_rec_t *job, int rc);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int _initgroups(stepd_step_rec_t *job);\n\nextern void\nbatch_finish(stepd_step_rec_t *job, int rc)\n{\n\tstep_complete.step_rc = _get_exit_code(job);\n\n\tif (job->argv[0] && (unlink(job->argv[0]) < 0))\n\t\terror(\"unlink(%s): %m\", job->argv[0]);\n\n#ifdef HAVE_ALPS_CRAY\n\t_call_select_plugin_from_stepd(job, 0, select_g_job_fini);\n#endif\n\n\tif (job->aborted) {\n\t\tif ((job->stepid == NO_VAL) ||\n\t\t    (job->stepid == SLURM_BATCH_SCRIPT)) {\n\t\t\tinfo(\"step %u.%u abort completed\",\n\t\t\t     job->jobid, job->stepid);\n\t\t} else\n\t\t\tinfo(\"job %u abort completed\", job->jobid);\n\t} else if ((job->stepid == NO_VAL) ||\n\t\t   (job->stepid == SLURM_BATCH_SCRIPT)) {\n\t\tverbose(\"job %u completed with slurm_rc = %d, job_rc = %d\",\n\t\t\tjob->jobid, rc, step_complete.step_rc);\n\t\t_send_complete_batch_script_msg(job, rc, step_complete.step_rc);\n\t} else {\n\t\t_wait_for_children_slurmstepd(job);\n\t\tverbose(\"job %u.%u completed with slurm_rc = %d, job_rc = %d\",\n\t\t\tjob->jobid, job->stepid, rc, step_complete.step_rc);\n\t\t_send_step_complete_msgs(job);\n\t}\n\n\t/* Do not purge directory until slurmctld is notified of batch job\n\t * completion to avoid race condition with slurmd registering missing\n\t * batch job. */\n\tif (job->batchdir && (rmdir(job->batchdir) < 0))\n\t\terror(\"rmdir(%s): %m\",  job->batchdir);\n\txfree(job->batchdir);\n}"
        }
      },
      {
        "call_info": {
          "callee": "job_manager",
          "args": [
            "job"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "job_manager",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "1112-1392",
          "snippet": "int\njob_manager(stepd_step_rec_t *job)\n{\n\tint  rc = SLURM_SUCCESS;\n\tbool io_initialized = false;\n\tchar *ckpt_type = slurm_get_checkpoint_type();\n\n\tdebug3(\"Entered job_manager for %u.%u pid=%d\",\n\t       job->jobid, job->stepid, job->jmgr_pid);\n\n#ifdef PR_SET_DUMPABLE\n\tif (prctl(PR_SET_DUMPABLE, 1) < 0)\n\t\tdebug (\"Unable to set dumpable to 1\");\n#endif /* PR_SET_DUMPABLE */\n\n\t/* run now so we don't drop permissions on any of the gather plugins */\n\tacct_gather_conf_init();\n\n\t/*\n\t * Preload all plugins at start time to avoid plugin changes\n\t * (i.e. due to a Slurm upgrade) after the process starts.\n\t */\n\tif ((core_spec_g_init() != SLURM_SUCCESS)\t\t||\n\t    (switch_init() != SLURM_SUCCESS)\t\t\t||\n\t    (slurmd_task_init() != SLURM_SUCCESS)\t\t||\n\t    (slurm_proctrack_init() != SLURM_SUCCESS)\t\t||\n\t    (checkpoint_init(ckpt_type) != SLURM_SUCCESS)\t||\n\t    (jobacct_gather_init() != SLURM_SUCCESS)\t\t||\n\t    (acct_gather_profile_init() != SLURM_SUCCESS)\t||\n\t    (slurm_crypto_init() != SLURM_SUCCESS)\t\t||\n\t    (job_container_init() != SLURM_SUCCESS)\t\t||\n\t    (gres_plugin_init() != SLURM_SUCCESS)) {\n\t\trc = SLURM_PLUGIN_NAME_INVALID;\n\t\tgoto fail1;\n\t}\n\tif (mpi_hook_slurmstepd_init(&job->env) != SLURM_SUCCESS) {\n\t\trc = SLURM_MPI_PLUGIN_NAME_INVALID;\n\t\tgoto fail1;\n\t}\n\n\tif (!job->batch && (job->stepid != SLURM_EXTERN_CONT) &&\n\t    (switch_g_job_preinit(job->switch_job) < 0)) {\n\t\trc = ESLURM_INTERCONNECT_FAILURE;\n\t\tgoto fail1;\n\t}\n\n\tif ((job->cont_id == 0) &&\n\t    (proctrack_g_create(job) != SLURM_SUCCESS)) {\n\t\terror(\"proctrack_g_create: %m\");\n\t\trc = ESLURMD_SETUP_ENVIRONMENT_ERROR;\n\t\tgoto fail1;\n\t}\n\n\tif (job->stepid == SLURM_EXTERN_CONT)\n\t\treturn _spawn_job_container(job);\n\n\tif (!job->batch && job->accel_bind_type) {\n\t\t(void) gres_plugin_node_config_load(conf->cpus, conf->node_name,\n\t\t\t\t\t\t    (void *)&xcpuinfo_abs_to_mac);\n\t}\n\n#ifdef HAVE_ALPS_CRAY\n\t/*\n\t * Note that the previously called proctrack_g_create function is\n\t * mandatory since the select/cray plugin needs the job container\n\t * ID in order to CONFIRM the ALPS reservation.\n\t * It is not a good idea to perform this setup in _fork_all_tasks(),\n\t * since any transient failure of ALPS (which can happen in practice)\n\t * will then set the frontend node to DRAIN.\n\t *\n\t * ALso note that we do not check the reservation for batch jobs with\n\t * a reservation ID of zero and no CPUs. These are SLURM job\n\t * allocations containing no compute nodes and thus have no ALPS\n\t * reservation.\n\t */\n\tif (!job->batch || job->resv_id || job->cpus) {\n\t\trc = _select_cray_plugin_job_ready(job);\n\t\tif (rc != SLURM_SUCCESS) {\n\t\t\t/*\n\t\t\t * Transient error: slurmctld knows this condition to\n\t\t\t * mean that the ALPS (not the SLURM) reservation\n\t\t\t * failed and tries again.\n\t\t\t */\n\t\t\tif (rc == READY_JOB_ERROR)\n\t\t\t\trc = ESLURM_RESERVATION_NOT_USABLE;\n\t\t\telse\n\t\t\t\trc = ESLURMD_SETUP_ENVIRONMENT_ERROR;\n\t\t\terror(\"could not confirm ALPS reservation #%u\",\n\t\t\t      job->resv_id);\n\t\t\tgoto fail1;\n\t\t}\n\t}\n#endif\n\n\tdebug2(\"Before call to spank_init()\");\n\tif (spank_init (job) < 0) {\n\t\terror (\"Plugin stack initialization failed.\");\n\t\trc = SLURM_PLUGIN_NAME_INVALID;\n\t\tgoto fail1;\n\t}\n\tdebug2(\"After call to spank_init()\");\n\n\t/* Call switch_g_job_init() before becoming user */\n\tif (!job->batch && job->argv && (switch_g_job_init(job) < 0)) {\n\t\t/* error(\"switch_g_job_init: %m\"); already logged */\n\t\trc = ESLURM_INTERCONNECT_FAILURE;\n\t\tgoto fail2;\n\t}\n\n\t/* fork necessary threads for checkpoint */\n\tif (checkpoint_stepd_prefork(job) != SLURM_SUCCESS) {\n\t\terror(\"Failed checkpoint_stepd_prefork\");\n\t\trc = SLURM_FAILURE;\n\t\tio_close_task_fds(job);\n\t\tgoto fail2;\n\t}\n\n\t/* fork necessary threads for MPI */\n\tif (mpi_hook_slurmstepd_prefork(job, &job->env) != SLURM_SUCCESS) {\n\t\terror(\"Failed mpi_hook_slurmstepd_prefork\");\n\t\trc = SLURM_FAILURE;\n\t\tgoto fail2;\n\t}\n\n\tif (!job->batch && job->accel_bind_type && (job->node_tasks <= 1))\n\t\tjob->accel_bind_type = 0;\n\tif (!job->batch && job->accel_bind_type && (job->node_tasks > 1)) {\n\t\tuint64_t gpu_cnt, mic_cnt, nic_cnt;\n\t\tgpu_cnt = gres_plugin_step_count(job->step_gres_list, \"gpu\");\n\t\tmic_cnt = gres_plugin_step_count(job->step_gres_list, \"mic\");\n\t\tnic_cnt = gres_plugin_step_count(job->step_gres_list, \"nic\");\n\t\tif ((gpu_cnt <= 1) || (gpu_cnt == NO_VAL64))\n\t\t\tjob->accel_bind_type &= (~ACCEL_BIND_CLOSEST_GPU);\n\t\tif ((mic_cnt <= 1) || (mic_cnt == NO_VAL64))\n\t\t\tjob->accel_bind_type &= (~ACCEL_BIND_CLOSEST_MIC);\n\t\tif ((nic_cnt <= 1) || (nic_cnt == NO_VAL64))\n\t\t\tjob->accel_bind_type &= (~ACCEL_BIND_CLOSEST_NIC);\n\t\tif (job->accel_bind_type == ACCEL_BIND_VERBOSE)\n\t\t\tjob->accel_bind_type = 0;\n\t}\n\n\t/* Calls pam_setup() and requires pam_finish() if\n\t * successful.  Only check for < 0 here since other slurm\n\t * error codes could come that are more descriptive. */\n\tif ((rc = _fork_all_tasks(job, &io_initialized)) < 0) {\n\t\tdebug(\"_fork_all_tasks failed\");\n\t\trc = ESLURMD_EXECVE_FAILED;\n\t\tgoto fail2;\n\t}\n\n\t/*\n\t * If IO initialization failed, return SLURM_SUCCESS (on a\n\t * batch step) or the node will be drain otherwise.  Regular\n\t * srun needs the error sent or it will hang waiting for the\n\t * launch to happen.\n\t */\n\tif ((rc != SLURM_SUCCESS) || !io_initialized)\n\t\tgoto fail2;\n\n\tio_close_task_fds(job);\n\n\txsignal_block (mgr_sigarray);\n\treattach_job = job;\n\n\t_set_job_state(job, SLURMSTEPD_STEP_RUNNING);\n\n\t/* Attach slurmstepd to system cgroups, if configured */\n\tattach_system_cgroup_pid(getpid());\n\n\t/* if we are not polling then we need to make sure we get some\n\t * information here\n\t */\n\tif (!conf->job_acct_gather_freq)\n\t\tjobacct_gather_stat_task(0);\n\n\t/* Send job launch response with list of pids */\n\t_send_launch_resp(job, 0);\n\n#ifdef PR_SET_DUMPABLE\n\t/* RHEL6 requires setting \"dumpable\" flag AGAIN; after euid changes */\n\tif (prctl(PR_SET_DUMPABLE, 1) < 0)\n\t\tdebug (\"Unable to set dumpable to 1\");\n#endif /* PR_SET_DUMPABLE */\n\n\t_wait_for_all_tasks(job);\n\tacct_gather_profile_endpoll();\n\tacct_gather_profile_g_node_step_end();\n\tacct_gather_profile_fini();\n\n\t_set_job_state(job, SLURMSTEPD_STEP_ENDING);\n\n\tif (!job->batch &&\n\t    (switch_g_job_fini(job->switch_job) < 0)) {\n\t\terror(\"switch_g_job_fini: %m\");\n\t}\n\nfail2:\n\t/*\n\t * First call switch_g_job_postfini() - In at least one case,\n\t * this will clean up any straggling processes. If this call\n\t * is moved behind wait_for_io(), we may block waiting for IO\n\t * on a hung process.\n\t *\n\t * Make sure all processes in session are dead. On systems\n\t * with an IBM Federation switch, all processes must be\n\t * terminated before the switch window can be released by\n\t * switch_g_job_postfini().\n\t */\n\t_set_job_state(job, SLURMSTEPD_STEP_ENDING);\n\tstep_terminate_monitor_start(job->jobid, job->stepid);\n\tif (job->cont_id != 0) {\n\t\tproctrack_g_signal(job->cont_id, SIGKILL);\n\t\tproctrack_g_wait(job->cont_id);\n\t}\n\tstep_terminate_monitor_stop();\n\tif (!job->batch) {\n\t\tif (switch_g_job_postfini(job) < 0)\n\t\t\terror(\"switch_g_job_postfini: %m\");\n\t}\n\n\t/*\n\t * Wait for io thread to complete (if there is one)\n\t */\n\tif (!job->batch && !job->user_managed_io && io_initialized)\n\t\t_wait_for_io(job);\n\n\t/*\n\t * Warn task plugin that the user's step have terminated\n\t */\n\ttask_g_post_step(job);\n\n\t/*\n\t * Reset cpu frequency if it was changed\n\t */\n\tif (job->cpu_freq_min != NO_VAL || job->cpu_freq_max != NO_VAL ||\n\t    job->cpu_freq_gov != NO_VAL)\n\t\tcpu_freq_reset(job);\n\n\t/* Notify srun of completion AFTER frequency reset to avoid race\n\t * condition starting another job on these CPUs. */\n\twhile (_send_pending_exit_msgs(job)) {;}\n\n\t/*\n\t * This just cleans up all of the PAM state in case rc == 0\n\t * which means _fork_all_tasks performs well.\n\t * Must be done after IO termination in case of IO operations\n\t * require something provided by the PAM (i.e. security token)\n\t */\n\tif (!rc)\n\t\tpam_finish();\n\n\tdebug2(\"Before call to spank_fini()\");\n\tif (spank_fini (job)  < 0) {\n\t\terror (\"spank_fini failed\");\n\t}\n\tdebug2(\"After call to spank_fini()\");\n\nfail1:\n\t/* If interactive job startup was abnormal,\n\t * be sure to notify client.\n\t */\n\t_set_job_state(job, SLURMSTEPD_STEP_ENDING);\n\tif (rc != 0) {\n\t\terror(\"job_manager exiting abnormally, rc = %d\", rc);\n\t\t_send_launch_resp(job, rc);\n\t}\n\n\tif (!job->batch && (step_complete.rank > -1)) {\n\t\tif (job->aborted)\n\t\t\tinfo(\"job_manager exiting with aborted job\");\n\t\telse\n\t\t\t_wait_for_children_slurmstepd(job);\n\t\t_send_step_complete_msgs(job);\n\t}\n\n\tif (!job->batch && core_spec_g_clear(job->cont_id))\n\t\terror(\"core_spec_g_clear: %m\");\n\n\txfree(ckpt_type);\n\treturn(rc);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int mgr_sigarray[] = {\n\tSIGINT,  SIGTERM, SIGTSTP,\n\tSIGQUIT, SIGPIPE, SIGUSR1,\n\tSIGUSR2, SIGALRM, SIGHUP, 0\n};",
            "step_complete_t step_complete = {\n\tPTHREAD_COND_INITIALIZER,\n\tPTHREAD_MUTEX_INITIALIZER,\n\t-1,\n\t-1,\n\t-1,\n\t{},\n\t-1,\n\t-1,\n\ttrue,\n\t(bitstr_t *)NULL,\n\t0,\n\tNULL\n};",
            "static int  _fork_all_tasks(stepd_step_rec_t *job, bool *io_initialized);",
            "static void  _set_prio_process (stepd_step_rec_t *job);",
            "static void _set_job_log_prefix(stepd_step_rec_t *job);",
            "static int  _setup_normal_io(stepd_step_rec_t *job);",
            "static int  _reclaim_privileges(struct priv_state *state);",
            "static void _send_launch_resp(stepd_step_rec_t *job, int rc);",
            "static int  _slurmd_job_log_init(stepd_step_rec_t *job);",
            "static void _wait_for_io(stepd_step_rec_t *job);",
            "static void _wait_for_children_slurmstepd(stepd_step_rec_t *job);",
            "static int  _send_pending_exit_msgs(stepd_step_rec_t *job);",
            "static void _send_step_complete_msgs(stepd_step_rec_t *job);",
            "static void _wait_for_all_tasks(stepd_step_rec_t *job);",
            "static void _setargs(stepd_step_rec_t *job);",
            "static void _random_sleep(stepd_step_rec_t *job);",
            "static int  _run_script_as_user(const char *name, const char *path,\n\t\t\t\tstepd_step_rec_t *job,\n\t\t\t\tint max_wait, char **env);",
            "static char * _make_batch_dir(stepd_step_rec_t *job);",
            "static int _initgroups(stepd_step_rec_t *job);",
            "static stepd_step_rec_t *reattach_job;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic int mgr_sigarray[] = {\n\tSIGINT,  SIGTERM, SIGTSTP,\n\tSIGQUIT, SIGPIPE, SIGUSR1,\n\tSIGUSR2, SIGALRM, SIGHUP, 0\n};\nstep_complete_t step_complete = {\n\tPTHREAD_COND_INITIALIZER,\n\tPTHREAD_MUTEX_INITIALIZER,\n\t-1,\n\t-1,\n\t-1,\n\t{},\n\t-1,\n\t-1,\n\ttrue,\n\t(bitstr_t *)NULL,\n\t0,\n\tNULL\n};\nstatic int  _fork_all_tasks(stepd_step_rec_t *job, bool *io_initialized);\nstatic void  _set_prio_process (stepd_step_rec_t *job);\nstatic void _set_job_log_prefix(stepd_step_rec_t *job);\nstatic int  _setup_normal_io(stepd_step_rec_t *job);\nstatic int  _reclaim_privileges(struct priv_state *state);\nstatic void _send_launch_resp(stepd_step_rec_t *job, int rc);\nstatic int  _slurmd_job_log_init(stepd_step_rec_t *job);\nstatic void _wait_for_io(stepd_step_rec_t *job);\nstatic void _wait_for_children_slurmstepd(stepd_step_rec_t *job);\nstatic int  _send_pending_exit_msgs(stepd_step_rec_t *job);\nstatic void _send_step_complete_msgs(stepd_step_rec_t *job);\nstatic void _wait_for_all_tasks(stepd_step_rec_t *job);\nstatic void _setargs(stepd_step_rec_t *job);\nstatic void _random_sleep(stepd_step_rec_t *job);\nstatic int  _run_script_as_user(const char *name, const char *path,\n\t\t\t\tstepd_step_rec_t *job,\n\t\t\t\tint max_wait, char **env);\nstatic char * _make_batch_dir(stepd_step_rec_t *job);\nstatic int _initgroups(stepd_step_rec_t *job);\nstatic stepd_step_rec_t *reattach_job;\n\nint\njob_manager(stepd_step_rec_t *job)\n{\n\tint  rc = SLURM_SUCCESS;\n\tbool io_initialized = false;\n\tchar *ckpt_type = slurm_get_checkpoint_type();\n\n\tdebug3(\"Entered job_manager for %u.%u pid=%d\",\n\t       job->jobid, job->stepid, job->jmgr_pid);\n\n#ifdef PR_SET_DUMPABLE\n\tif (prctl(PR_SET_DUMPABLE, 1) < 0)\n\t\tdebug (\"Unable to set dumpable to 1\");\n#endif /* PR_SET_DUMPABLE */\n\n\t/* run now so we don't drop permissions on any of the gather plugins */\n\tacct_gather_conf_init();\n\n\t/*\n\t * Preload all plugins at start time to avoid plugin changes\n\t * (i.e. due to a Slurm upgrade) after the process starts.\n\t */\n\tif ((core_spec_g_init() != SLURM_SUCCESS)\t\t||\n\t    (switch_init() != SLURM_SUCCESS)\t\t\t||\n\t    (slurmd_task_init() != SLURM_SUCCESS)\t\t||\n\t    (slurm_proctrack_init() != SLURM_SUCCESS)\t\t||\n\t    (checkpoint_init(ckpt_type) != SLURM_SUCCESS)\t||\n\t    (jobacct_gather_init() != SLURM_SUCCESS)\t\t||\n\t    (acct_gather_profile_init() != SLURM_SUCCESS)\t||\n\t    (slurm_crypto_init() != SLURM_SUCCESS)\t\t||\n\t    (job_container_init() != SLURM_SUCCESS)\t\t||\n\t    (gres_plugin_init() != SLURM_SUCCESS)) {\n\t\trc = SLURM_PLUGIN_NAME_INVALID;\n\t\tgoto fail1;\n\t}\n\tif (mpi_hook_slurmstepd_init(&job->env) != SLURM_SUCCESS) {\n\t\trc = SLURM_MPI_PLUGIN_NAME_INVALID;\n\t\tgoto fail1;\n\t}\n\n\tif (!job->batch && (job->stepid != SLURM_EXTERN_CONT) &&\n\t    (switch_g_job_preinit(job->switch_job) < 0)) {\n\t\trc = ESLURM_INTERCONNECT_FAILURE;\n\t\tgoto fail1;\n\t}\n\n\tif ((job->cont_id == 0) &&\n\t    (proctrack_g_create(job) != SLURM_SUCCESS)) {\n\t\terror(\"proctrack_g_create: %m\");\n\t\trc = ESLURMD_SETUP_ENVIRONMENT_ERROR;\n\t\tgoto fail1;\n\t}\n\n\tif (job->stepid == SLURM_EXTERN_CONT)\n\t\treturn _spawn_job_container(job);\n\n\tif (!job->batch && job->accel_bind_type) {\n\t\t(void) gres_plugin_node_config_load(conf->cpus, conf->node_name,\n\t\t\t\t\t\t    (void *)&xcpuinfo_abs_to_mac);\n\t}\n\n#ifdef HAVE_ALPS_CRAY\n\t/*\n\t * Note that the previously called proctrack_g_create function is\n\t * mandatory since the select/cray plugin needs the job container\n\t * ID in order to CONFIRM the ALPS reservation.\n\t * It is not a good idea to perform this setup in _fork_all_tasks(),\n\t * since any transient failure of ALPS (which can happen in practice)\n\t * will then set the frontend node to DRAIN.\n\t *\n\t * ALso note that we do not check the reservation for batch jobs with\n\t * a reservation ID of zero and no CPUs. These are SLURM job\n\t * allocations containing no compute nodes and thus have no ALPS\n\t * reservation.\n\t */\n\tif (!job->batch || job->resv_id || job->cpus) {\n\t\trc = _select_cray_plugin_job_ready(job);\n\t\tif (rc != SLURM_SUCCESS) {\n\t\t\t/*\n\t\t\t * Transient error: slurmctld knows this condition to\n\t\t\t * mean that the ALPS (not the SLURM) reservation\n\t\t\t * failed and tries again.\n\t\t\t */\n\t\t\tif (rc == READY_JOB_ERROR)\n\t\t\t\trc = ESLURM_RESERVATION_NOT_USABLE;\n\t\t\telse\n\t\t\t\trc = ESLURMD_SETUP_ENVIRONMENT_ERROR;\n\t\t\terror(\"could not confirm ALPS reservation #%u\",\n\t\t\t      job->resv_id);\n\t\t\tgoto fail1;\n\t\t}\n\t}\n#endif\n\n\tdebug2(\"Before call to spank_init()\");\n\tif (spank_init (job) < 0) {\n\t\terror (\"Plugin stack initialization failed.\");\n\t\trc = SLURM_PLUGIN_NAME_INVALID;\n\t\tgoto fail1;\n\t}\n\tdebug2(\"After call to spank_init()\");\n\n\t/* Call switch_g_job_init() before becoming user */\n\tif (!job->batch && job->argv && (switch_g_job_init(job) < 0)) {\n\t\t/* error(\"switch_g_job_init: %m\"); already logged */\n\t\trc = ESLURM_INTERCONNECT_FAILURE;\n\t\tgoto fail2;\n\t}\n\n\t/* fork necessary threads for checkpoint */\n\tif (checkpoint_stepd_prefork(job) != SLURM_SUCCESS) {\n\t\terror(\"Failed checkpoint_stepd_prefork\");\n\t\trc = SLURM_FAILURE;\n\t\tio_close_task_fds(job);\n\t\tgoto fail2;\n\t}\n\n\t/* fork necessary threads for MPI */\n\tif (mpi_hook_slurmstepd_prefork(job, &job->env) != SLURM_SUCCESS) {\n\t\terror(\"Failed mpi_hook_slurmstepd_prefork\");\n\t\trc = SLURM_FAILURE;\n\t\tgoto fail2;\n\t}\n\n\tif (!job->batch && job->accel_bind_type && (job->node_tasks <= 1))\n\t\tjob->accel_bind_type = 0;\n\tif (!job->batch && job->accel_bind_type && (job->node_tasks > 1)) {\n\t\tuint64_t gpu_cnt, mic_cnt, nic_cnt;\n\t\tgpu_cnt = gres_plugin_step_count(job->step_gres_list, \"gpu\");\n\t\tmic_cnt = gres_plugin_step_count(job->step_gres_list, \"mic\");\n\t\tnic_cnt = gres_plugin_step_count(job->step_gres_list, \"nic\");\n\t\tif ((gpu_cnt <= 1) || (gpu_cnt == NO_VAL64))\n\t\t\tjob->accel_bind_type &= (~ACCEL_BIND_CLOSEST_GPU);\n\t\tif ((mic_cnt <= 1) || (mic_cnt == NO_VAL64))\n\t\t\tjob->accel_bind_type &= (~ACCEL_BIND_CLOSEST_MIC);\n\t\tif ((nic_cnt <= 1) || (nic_cnt == NO_VAL64))\n\t\t\tjob->accel_bind_type &= (~ACCEL_BIND_CLOSEST_NIC);\n\t\tif (job->accel_bind_type == ACCEL_BIND_VERBOSE)\n\t\t\tjob->accel_bind_type = 0;\n\t}\n\n\t/* Calls pam_setup() and requires pam_finish() if\n\t * successful.  Only check for < 0 here since other slurm\n\t * error codes could come that are more descriptive. */\n\tif ((rc = _fork_all_tasks(job, &io_initialized)) < 0) {\n\t\tdebug(\"_fork_all_tasks failed\");\n\t\trc = ESLURMD_EXECVE_FAILED;\n\t\tgoto fail2;\n\t}\n\n\t/*\n\t * If IO initialization failed, return SLURM_SUCCESS (on a\n\t * batch step) or the node will be drain otherwise.  Regular\n\t * srun needs the error sent or it will hang waiting for the\n\t * launch to happen.\n\t */\n\tif ((rc != SLURM_SUCCESS) || !io_initialized)\n\t\tgoto fail2;\n\n\tio_close_task_fds(job);\n\n\txsignal_block (mgr_sigarray);\n\treattach_job = job;\n\n\t_set_job_state(job, SLURMSTEPD_STEP_RUNNING);\n\n\t/* Attach slurmstepd to system cgroups, if configured */\n\tattach_system_cgroup_pid(getpid());\n\n\t/* if we are not polling then we need to make sure we get some\n\t * information here\n\t */\n\tif (!conf->job_acct_gather_freq)\n\t\tjobacct_gather_stat_task(0);\n\n\t/* Send job launch response with list of pids */\n\t_send_launch_resp(job, 0);\n\n#ifdef PR_SET_DUMPABLE\n\t/* RHEL6 requires setting \"dumpable\" flag AGAIN; after euid changes */\n\tif (prctl(PR_SET_DUMPABLE, 1) < 0)\n\t\tdebug (\"Unable to set dumpable to 1\");\n#endif /* PR_SET_DUMPABLE */\n\n\t_wait_for_all_tasks(job);\n\tacct_gather_profile_endpoll();\n\tacct_gather_profile_g_node_step_end();\n\tacct_gather_profile_fini();\n\n\t_set_job_state(job, SLURMSTEPD_STEP_ENDING);\n\n\tif (!job->batch &&\n\t    (switch_g_job_fini(job->switch_job) < 0)) {\n\t\terror(\"switch_g_job_fini: %m\");\n\t}\n\nfail2:\n\t/*\n\t * First call switch_g_job_postfini() - In at least one case,\n\t * this will clean up any straggling processes. If this call\n\t * is moved behind wait_for_io(), we may block waiting for IO\n\t * on a hung process.\n\t *\n\t * Make sure all processes in session are dead. On systems\n\t * with an IBM Federation switch, all processes must be\n\t * terminated before the switch window can be released by\n\t * switch_g_job_postfini().\n\t */\n\t_set_job_state(job, SLURMSTEPD_STEP_ENDING);\n\tstep_terminate_monitor_start(job->jobid, job->stepid);\n\tif (job->cont_id != 0) {\n\t\tproctrack_g_signal(job->cont_id, SIGKILL);\n\t\tproctrack_g_wait(job->cont_id);\n\t}\n\tstep_terminate_monitor_stop();\n\tif (!job->batch) {\n\t\tif (switch_g_job_postfini(job) < 0)\n\t\t\terror(\"switch_g_job_postfini: %m\");\n\t}\n\n\t/*\n\t * Wait for io thread to complete (if there is one)\n\t */\n\tif (!job->batch && !job->user_managed_io && io_initialized)\n\t\t_wait_for_io(job);\n\n\t/*\n\t * Warn task plugin that the user's step have terminated\n\t */\n\ttask_g_post_step(job);\n\n\t/*\n\t * Reset cpu frequency if it was changed\n\t */\n\tif (job->cpu_freq_min != NO_VAL || job->cpu_freq_max != NO_VAL ||\n\t    job->cpu_freq_gov != NO_VAL)\n\t\tcpu_freq_reset(job);\n\n\t/* Notify srun of completion AFTER frequency reset to avoid race\n\t * condition starting another job on these CPUs. */\n\twhile (_send_pending_exit_msgs(job)) {;}\n\n\t/*\n\t * This just cleans up all of the PAM state in case rc == 0\n\t * which means _fork_all_tasks performs well.\n\t * Must be done after IO termination in case of IO operations\n\t * require something provided by the PAM (i.e. security token)\n\t */\n\tif (!rc)\n\t\tpam_finish();\n\n\tdebug2(\"Before call to spank_fini()\");\n\tif (spank_fini (job)  < 0) {\n\t\terror (\"spank_fini failed\");\n\t}\n\tdebug2(\"After call to spank_fini()\");\n\nfail1:\n\t/* If interactive job startup was abnormal,\n\t * be sure to notify client.\n\t */\n\t_set_job_state(job, SLURMSTEPD_STEP_ENDING);\n\tif (rc != 0) {\n\t\terror(\"job_manager exiting abnormally, rc = %d\", rc);\n\t\t_send_launch_resp(job, rc);\n\t}\n\n\tif (!job->batch && (step_complete.rank > -1)) {\n\t\tif (job->aborted)\n\t\t\tinfo(\"job_manager exiting with aborted job\");\n\t\telse\n\t\t\t_wait_for_children_slurmstepd(job);\n\t\t_send_step_complete_msgs(job);\n\t}\n\n\tif (!job->batch && core_spec_g_clear(job->cont_id))\n\t\terror(\"core_spec_g_clear: %m\");\n\n\txfree(ckpt_type);\n\treturn(rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "STDERR_FILENO",
            "STDOUT_FILENO"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "STDERR_FILENO",
            "STDIN_FILENO"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_got_ack_from_slurmd",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 149
        },
        "resolved": true,
        "details": {
          "function_name": "_got_ack_from_slurmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
          "lines": "378-390",
          "snippet": "static void\n_got_ack_from_slurmd(int sock)\n{\n\t/* If running under valgrind/memcheck, this pipe doesn't work correctly\n\t * so just skip it. */\n#if (SLURMSTEPD_MEMCHECK == 0)\n\tint ok;\n\tsafe_read(sock, &ok, sizeof(int));\n\treturn;\nrwfail:\n\terror(\"Unable to receive \\\"ok ack\\\" to slurmd\");\n#endif\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <unistd.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _send_ok_to_slurmd(int sock);",
            "static void _send_fail_to_slurmd(int sock);",
            "static void _got_ack_from_slurmd(int);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic void _send_ok_to_slurmd(int sock);\nstatic void _send_fail_to_slurmd(int sock);\nstatic void _got_ack_from_slurmd(int);\n\nstatic void\n_got_ack_from_slurmd(int sock)\n{\n\t/* If running under valgrind/memcheck, this pipe doesn't work correctly\n\t * so just skip it. */\n#if (SLURMSTEPD_MEMCHECK == 0)\n\tint ok;\n\tsafe_read(sock, &ok, sizeof(int));\n\treturn;\nrwfail:\n\terror(\"Unable to receive \\\"ok ack\\\" to slurmd\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "_send_ok_to_slurmd",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 148
        },
        "resolved": true,
        "details": {
          "function_name": "_send_ok_to_slurmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
          "lines": "346-358",
          "snippet": "static void\n_send_ok_to_slurmd(int sock)\n{\n\t/* If running under valgrind/memcheck, this pipe doesn't work correctly\n\t * so just skip it. */\n#if (SLURMSTEPD_MEMCHECK == 0)\n\tint ok = SLURM_SUCCESS;\n\tsafe_write(sock, &ok, sizeof(int));\n\treturn;\nrwfail:\n\terror(\"Unable to send \\\"ok\\\" to slurmd\");\n#endif\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <unistd.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _send_ok_to_slurmd(int sock);",
            "static void _send_fail_to_slurmd(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic void _send_ok_to_slurmd(int sock);\nstatic void _send_fail_to_slurmd(int sock);\n\nstatic void\n_send_ok_to_slurmd(int sock)\n{\n\t/* If running under valgrind/memcheck, this pipe doesn't work correctly\n\t * so just skip it. */\n#if (SLURMSTEPD_MEMCHECK == 0)\n\tint ok = SLURM_SUCCESS;\n\tsafe_write(sock, &ok, sizeof(int));\n\treturn;\nrwfail:\n\terror(\"Unable to send \\\"ok\\\" to slurmd\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "_send_fail_to_slurmd",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "_send_fail_to_slurmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
          "lines": "360-376",
          "snippet": "static void\n_send_fail_to_slurmd(int sock)\n{\n\t/* If running under valgrind/memcheck, this pipe doesn't work correctly\n\t * so just skip it. */\n#if (SLURMSTEPD_MEMCHECK == 0)\n\tint fail = SLURM_FAILURE;\n\n\tif (errno)\n\t\tfail = errno;\n\n\tsafe_write(sock, &fail, sizeof(int));\n\treturn;\nrwfail:\n\terror(\"Unable to send \\\"fail\\\" to slurmd\");\n#endif\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <unistd.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _send_ok_to_slurmd(int sock);",
            "static void _send_fail_to_slurmd(int sock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic void _send_ok_to_slurmd(int sock);\nstatic void _send_fail_to_slurmd(int sock);\n\nstatic void\n_send_fail_to_slurmd(int sock)\n{\n\t/* If running under valgrind/memcheck, this pipe doesn't work correctly\n\t * so just skip it. */\n#if (SLURMSTEPD_MEMCHECK == 0)\n\tint fail = SLURM_FAILURE;\n\n\tif (errno)\n\t\tfail = errno;\n\n\tsafe_write(sock, &fail, sizeof(int));\n\treturn;\nrwfail:\n\terror(\"Unable to send \\\"fail\\\" to slurmd\");\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg_thr_create",
          "args": [
            "job"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "msg_thr_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/req.c",
          "lines": "246-281",
          "snippet": "int\nmsg_thr_create(stepd_step_rec_t *job)\n{\n\tint fd;\n\teio_obj_t *eio_obj;\n\tpthread_attr_t attr;\n\tint rc = SLURM_SUCCESS, retries = 0;\n\terrno = 0;\n\tfd = _domain_socket_create(conf->spooldir, conf->node_name,\n\t\t\t\t   job->jobid, job->stepid);\n\tif (fd == -1)\n\t\treturn SLURM_ERROR;\n\n\tfd_set_nonblocking(fd);\n\n\teio_obj = eio_obj_create(fd, &msg_socket_ops, (void *)job);\n\tjob->msg_handle = eio_handle_create(0);\n\teio_new_initial_obj(job->msg_handle, eio_obj);\n\n\tslurm_attr_init(&attr);\n\n\twhile (pthread_create(&job->msgid, &attr,\n\t\t\t      &_msg_thr_internal, (void *)job)) {\n\t\terror(\"msg_thr_create: pthread_create error %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"msg_thr_create: Can't create pthread\");\n\t\t\trc = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\n\tslurm_attr_destroy(&attr);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/timers.h\"",
            "#include \"src/common/checkpoint.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_acct_gather.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/common/parse_time.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <stdlib.h>",
            "#include <time.h>",
            "#include <signal.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/un.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _handle_state(int fd, stepd_step_rec_t *job);",
            "static int _handle_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_mem_limits(int fd, stepd_step_rec_t *job);",
            "static int _handle_uid(int fd, stepd_step_rec_t *job);",
            "static int _handle_nodeid(int fd, stepd_step_rec_t *job);",
            "static int _handle_pid_in_container(int fd, stepd_step_rec_t *job);",
            "static int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_daemon_pid(int fd, stepd_step_rec_t *job);",
            "static int _handle_task_info(int fd, stepd_step_rec_t *job);",
            "static int _handle_list_pids(int fd, stepd_step_rec_t *job);",
            "struct io_operations msg_socket_ops = {\n\t.readable = &_msg_socket_readable,\n\t.handle_read = &_msg_socket_accept\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/timers.h\"\n#include \"src/common/checkpoint.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_acct_gather.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/common/parse_time.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <stdlib.h>\n#include <time.h>\n#include <signal.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/un.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#  include \"config.h\"\n\nstatic int _handle_state(int fd, stepd_step_rec_t *job);\nstatic int _handle_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_mem_limits(int fd, stepd_step_rec_t *job);\nstatic int _handle_uid(int fd, stepd_step_rec_t *job);\nstatic int _handle_nodeid(int fd, stepd_step_rec_t *job);\nstatic int _handle_pid_in_container(int fd, stepd_step_rec_t *job);\nstatic int _handle_add_extern_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_daemon_pid(int fd, stepd_step_rec_t *job);\nstatic int _handle_task_info(int fd, stepd_step_rec_t *job);\nstatic int _handle_list_pids(int fd, stepd_step_rec_t *job);\nstruct io_operations msg_socket_ops = {\n\t.readable = &_msg_socket_readable,\n\t.handle_read = &_msg_socket_accept\n};\n\nint\nmsg_thr_create(stepd_step_rec_t *job)\n{\n\tint fd;\n\teio_obj_t *eio_obj;\n\tpthread_attr_t attr;\n\tint rc = SLURM_SUCCESS, retries = 0;\n\terrno = 0;\n\tfd = _domain_socket_create(conf->spooldir, conf->node_name,\n\t\t\t\t   job->jobid, job->stepid);\n\tif (fd == -1)\n\t\treturn SLURM_ERROR;\n\n\tfd_set_nonblocking(fd);\n\n\teio_obj = eio_obj_create(fd, &msg_socket_ops, (void *)job);\n\tjob->msg_handle = eio_handle_create(0);\n\teio_new_initial_obj(job->msg_handle, eio_obj);\n\n\tslurm_attr_init(&attr);\n\n\twhile (pthread_create(&job->msgid, &attr,\n\t\t\t      &_msg_thr_internal, (void *)job)) {\n\t\terror(\"msg_thr_create: pthread_create error %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"msg_thr_create: Can't create pthread\");\n\t\t\trc = SLURM_ERROR;\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\n\tslurm_attr_destroy(&attr);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_conf_install_fork_handlers",
          "args": [],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_install_fork_handlers",
          "args": [],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_step_setup",
          "args": [
            "cli",
            "self",
            "msg"
          ],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "_step_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
          "lines": "537-585",
          "snippet": "static stepd_step_rec_t *\n_step_setup(slurm_addr_t *cli, slurm_addr_t *self, slurm_msg_t *msg)\n{\n\tstepd_step_rec_t *job = NULL;\n\n\tswitch (msg->msg_type) {\n\tcase REQUEST_BATCH_JOB_LAUNCH:\n\t\tdebug2(\"setup for a batch_job\");\n\t\tjob = mgr_launch_batch_job_setup(msg->data, cli);\n\t\tbreak;\n\tcase REQUEST_LAUNCH_TASKS:\n\t\tdebug2(\"setup for a launch_task\");\n\t\tjob = mgr_launch_tasks_setup(msg->data, cli, self,\n\t\t\t\t\t     msg->protocol_version);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"handle_launch_message: Unrecognized launch RPC\");\n\t\tbreak;\n\t}\n\n\tif (!job) {\n\t\terror(\"_step_setup: no job returned\");\n\t\treturn NULL;\n\t}\n\n\tjob->jmgr_pid = getpid();\n\tjob->jobacct = jobacctinfo_create(NULL);\n\n\t/* Establish GRES environment variables */\n\tif (conf->debug_flags & DEBUG_FLAG_GRES) {\n\t\tgres_plugin_job_state_log(job->job_gres_list, job->jobid);\n\t\tgres_plugin_step_state_log(job->step_gres_list, job->jobid,\n\t\t\t\t\t   job->stepid);\n\t}\n\tif (msg->msg_type == REQUEST_BATCH_JOB_LAUNCH)\n\t\tgres_plugin_job_set_env(&job->env, job->job_gres_list);\n\telse if (msg->msg_type == REQUEST_LAUNCH_TASKS)\n\t\tgres_plugin_step_set_env(&job->env, job->step_gres_list, 0);\n\n\t/*\n\t * Add slurmd node topology informations to job env array\n\t */\n\tenv_array_overwrite(&job->env,\"SLURM_TOPOLOGY_ADDR\",\n\t\t\t    conf->node_topo_addr);\n\tenv_array_overwrite(&job->env,\"SLURM_TOPOLOGY_ADDR_PATTERN\",\n\t\t\t    conf->node_topo_pattern);\n\n\treturn job;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <unistd.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);",
            "slurmd_conf_t * conf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);\nslurmd_conf_t * conf;\n\nstatic stepd_step_rec_t *\n_step_setup(slurm_addr_t *cli, slurm_addr_t *self, slurm_msg_t *msg)\n{\n\tstepd_step_rec_t *job = NULL;\n\n\tswitch (msg->msg_type) {\n\tcase REQUEST_BATCH_JOB_LAUNCH:\n\t\tdebug2(\"setup for a batch_job\");\n\t\tjob = mgr_launch_batch_job_setup(msg->data, cli);\n\t\tbreak;\n\tcase REQUEST_LAUNCH_TASKS:\n\t\tdebug2(\"setup for a launch_task\");\n\t\tjob = mgr_launch_tasks_setup(msg->data, cli, self,\n\t\t\t\t\t     msg->protocol_version);\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"handle_launch_message: Unrecognized launch RPC\");\n\t\tbreak;\n\t}\n\n\tif (!job) {\n\t\terror(\"_step_setup: no job returned\");\n\t\treturn NULL;\n\t}\n\n\tjob->jmgr_pid = getpid();\n\tjob->jobacct = jobacctinfo_create(NULL);\n\n\t/* Establish GRES environment variables */\n\tif (conf->debug_flags & DEBUG_FLAG_GRES) {\n\t\tgres_plugin_job_state_log(job->job_gres_list, job->jobid);\n\t\tgres_plugin_step_state_log(job->step_gres_list, job->jobid,\n\t\t\t\t\t   job->stepid);\n\t}\n\tif (msg->msg_type == REQUEST_BATCH_JOB_LAUNCH)\n\t\tgres_plugin_job_set_env(&job->env, job->job_gres_list);\n\telse if (msg->msg_type == REQUEST_LAUNCH_TASKS)\n\t\tgres_plugin_step_set_env(&job->env, job->step_gres_list, 0);\n\n\t/*\n\t * Add slurmd node topology informations to job env array\n\t */\n\tenv_array_overwrite(&job->env,\"SLURM_TOPOLOGY_ADDR\",\n\t\t\t    conf->node_topo_addr);\n\tenv_array_overwrite(&job->env,\"SLURM_TOPOLOGY_ADDR_PATTERN\",\n\t\t\t    conf->node_topo_pattern);\n\n\treturn job;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_init_from_slurmd",
          "args": [
            "STDIN_FILENO",
            "argv",
            "&cli",
            "&self",
            "&msg",
            "&ngids",
            "&gids"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "_init_from_slurmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
          "lines": "396-535",
          "snippet": "static int\n_init_from_slurmd(int sock, char **argv,\n\t\t  slurm_addr_t **_cli, slurm_addr_t **_self, slurm_msg_t **_msg,\n\t\t  int *_ngids, gid_t **_gids)\n{\n\tchar *incoming_buffer = NULL;\n\tBuf buffer;\n\tint step_type;\n\tint len, proto;\n\tslurm_addr_t *cli = NULL;\n\tslurm_addr_t *self = NULL;\n\tslurm_msg_t *msg = NULL;\n\tint ngids = 0;\n\tgid_t *gids = NULL;\n\tuint16_t port;\n\tchar buf[16];\n\tlog_options_t lopts = LOG_OPTS_INITIALIZER;\n\n\tlog_init(argv[0], lopts, LOG_DAEMON, NULL);\n\n\t/* receive job type from slurmd */\n\tsafe_read(sock, &step_type, sizeof(int));\n\tdebug3(\"step_type = %d\", step_type);\n\n\t/* receive reverse-tree info from slurmd */\n\tslurm_mutex_lock(&step_complete.lock);\n\tsafe_read(sock, &step_complete.rank, sizeof(int));\n\tsafe_read(sock, &step_complete.parent_rank, sizeof(int));\n\tsafe_read(sock, &step_complete.children, sizeof(int));\n\tsafe_read(sock, &step_complete.depth, sizeof(int));\n\tsafe_read(sock, &step_complete.max_depth, sizeof(int));\n\tsafe_read(sock, &step_complete.parent_addr, sizeof(slurm_addr_t));\n\tstep_complete.bits = bit_alloc(step_complete.children);\n\tstep_complete.jobacct = jobacctinfo_create(NULL);\n\tslurm_mutex_unlock(&step_complete.lock);\n\n\t/* receive conf from slurmd */\n\tif ((conf = read_slurmd_conf_lite (sock)) == NULL)\n\t\tfatal(\"Failed to read conf from slurmd\");\n\n\tlog_alter(conf->log_opts, 0, conf->logfile);\n\tlog_set_timefmt(conf->log_fmt);\n\n\tdebug2(\"debug level is %d.\", conf->debug_level);\n\n\tswitch_g_slurmd_step_init();\n\n\tslurm_get_ip_str(&step_complete.parent_addr, &port, buf, 16);\n\tdebug3(\"slurmstepd rank %d, parent address = %s, port = %u\",\n\t       step_complete.rank, buf, port);\n\n\t/* receive cli from slurmd */\n\tsafe_read(sock, &len, sizeof(int));\n\tincoming_buffer = xmalloc(sizeof(char) * len);\n\tsafe_read(sock, incoming_buffer, len);\n\tbuffer = create_buf(incoming_buffer,len);\n\tcli = xmalloc(sizeof(slurm_addr_t));\n\tif (slurm_unpack_slurm_addr_no_alloc(cli, buffer) == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: problem with unpack of slurmd_conf\");\n\tfree_buf(buffer);\n\n\t/* receive self from slurmd */\n\tsafe_read(sock, &len, sizeof(int));\n\tif (len > 0) {\n\t\t/* receive packed self from main slurmd */\n\t\tincoming_buffer = xmalloc(sizeof(char) * len);\n\t\tsafe_read(sock, incoming_buffer, len);\n\t\tbuffer = create_buf(incoming_buffer,len);\n\t\tself = xmalloc(sizeof(slurm_addr_t));\n\t\tif (slurm_unpack_slurm_addr_no_alloc(self, buffer)\n\t\t    == SLURM_ERROR) {\n\t\t\tfatal(\"slurmstepd: problem with unpack of \"\n\t\t\t      \"slurmd_conf\");\n\t\t}\n\t\tfree_buf(buffer);\n\t}\n\n\t/* Receive GRES information from slurmd */\n\tgres_plugin_recv_stepd(sock);\n\n\t/* Grab the slurmd's spooldir. Has %n expanded. */\n\tcpu_freq_init(conf);\n\n\t/* Receive cpu_frequency info from slurmd */\n\tcpu_freq_recv_info(sock);\n\n\t/* get the protocol version of the srun */\n\tsafe_read(sock, &proto, sizeof(int));\n\n\t/* receive req from slurmd */\n\tsafe_read(sock, &len, sizeof(int));\n\tincoming_buffer = xmalloc(sizeof(char) * len);\n\tsafe_read(sock, incoming_buffer, len);\n\tbuffer = create_buf(incoming_buffer,len);\n\n\tmsg = xmalloc(sizeof(slurm_msg_t));\n\tslurm_msg_t_init(msg);\n\tmsg->protocol_version = (uint16_t)proto;\n\n\tswitch (step_type) {\n\tcase LAUNCH_BATCH_JOB:\n\t\tmsg->msg_type = REQUEST_BATCH_JOB_LAUNCH;\n\t\tbreak;\n\tcase LAUNCH_TASKS:\n\t\tmsg->msg_type = REQUEST_LAUNCH_TASKS;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: Unrecognized launch RPC (%d)\", __func__, step_type);\n\t\tbreak;\n\t}\n\tif (unpack_msg(msg, buffer) == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: we didn't unpack the request correctly\");\n\tfree_buf(buffer);\n\n\t/* receive cached group ids array for the relevant uid */\n\tsafe_read(sock, &ngids, sizeof(int));\n\tif (ngids > 0) {\n\t\tint i;\n\t\tuint32_t tmp32;\n\n\t\tgids = (gid_t *)xmalloc(sizeof(gid_t) * ngids);\n\t\tfor (i = 0; i < ngids; i++) {\n\t\t\tsafe_read(sock, &tmp32, sizeof(uint32_t));\n\t\t\tgids[i] = (gid_t)tmp32;\n\t\t\tdebug2(\"got gid %d\", gids[i]);\n\t\t}\n\t}\n\n\t*_cli = cli;\n\t*_self = self;\n\t*_msg = msg;\n\t*_ngids = ngids;\n\t*_gids = gids;\n\n\treturn 1;\n\nrwfail:\n\tfatal(\"Error reading initialization data from slurmd\");\n\texit(1);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <unistd.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _init_from_slurmd(int sock, char **argv, slurm_addr_t **_cli,\n\t\t\t     slurm_addr_t **_self, slurm_msg_t **_msg,\n\t\t\t     int *_ngids, gid_t **_gids);",
            "static void _send_ok_to_slurmd(int sock);",
            "static void _send_fail_to_slurmd(int sock);",
            "static stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);",
            "static int _process_cmdline (int argc, char *argv[]);",
            "slurmd_conf_t * conf;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic int _init_from_slurmd(int sock, char **argv, slurm_addr_t **_cli,\n\t\t\t     slurm_addr_t **_self, slurm_msg_t **_msg,\n\t\t\t     int *_ngids, gid_t **_gids);\nstatic void _send_ok_to_slurmd(int sock);\nstatic void _send_fail_to_slurmd(int sock);\nstatic stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);\nstatic int _process_cmdline (int argc, char *argv[]);\nslurmd_conf_t * conf;\n\nstatic int\n_init_from_slurmd(int sock, char **argv,\n\t\t  slurm_addr_t **_cli, slurm_addr_t **_self, slurm_msg_t **_msg,\n\t\t  int *_ngids, gid_t **_gids)\n{\n\tchar *incoming_buffer = NULL;\n\tBuf buffer;\n\tint step_type;\n\tint len, proto;\n\tslurm_addr_t *cli = NULL;\n\tslurm_addr_t *self = NULL;\n\tslurm_msg_t *msg = NULL;\n\tint ngids = 0;\n\tgid_t *gids = NULL;\n\tuint16_t port;\n\tchar buf[16];\n\tlog_options_t lopts = LOG_OPTS_INITIALIZER;\n\n\tlog_init(argv[0], lopts, LOG_DAEMON, NULL);\n\n\t/* receive job type from slurmd */\n\tsafe_read(sock, &step_type, sizeof(int));\n\tdebug3(\"step_type = %d\", step_type);\n\n\t/* receive reverse-tree info from slurmd */\n\tslurm_mutex_lock(&step_complete.lock);\n\tsafe_read(sock, &step_complete.rank, sizeof(int));\n\tsafe_read(sock, &step_complete.parent_rank, sizeof(int));\n\tsafe_read(sock, &step_complete.children, sizeof(int));\n\tsafe_read(sock, &step_complete.depth, sizeof(int));\n\tsafe_read(sock, &step_complete.max_depth, sizeof(int));\n\tsafe_read(sock, &step_complete.parent_addr, sizeof(slurm_addr_t));\n\tstep_complete.bits = bit_alloc(step_complete.children);\n\tstep_complete.jobacct = jobacctinfo_create(NULL);\n\tslurm_mutex_unlock(&step_complete.lock);\n\n\t/* receive conf from slurmd */\n\tif ((conf = read_slurmd_conf_lite (sock)) == NULL)\n\t\tfatal(\"Failed to read conf from slurmd\");\n\n\tlog_alter(conf->log_opts, 0, conf->logfile);\n\tlog_set_timefmt(conf->log_fmt);\n\n\tdebug2(\"debug level is %d.\", conf->debug_level);\n\n\tswitch_g_slurmd_step_init();\n\n\tslurm_get_ip_str(&step_complete.parent_addr, &port, buf, 16);\n\tdebug3(\"slurmstepd rank %d, parent address = %s, port = %u\",\n\t       step_complete.rank, buf, port);\n\n\t/* receive cli from slurmd */\n\tsafe_read(sock, &len, sizeof(int));\n\tincoming_buffer = xmalloc(sizeof(char) * len);\n\tsafe_read(sock, incoming_buffer, len);\n\tbuffer = create_buf(incoming_buffer,len);\n\tcli = xmalloc(sizeof(slurm_addr_t));\n\tif (slurm_unpack_slurm_addr_no_alloc(cli, buffer) == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: problem with unpack of slurmd_conf\");\n\tfree_buf(buffer);\n\n\t/* receive self from slurmd */\n\tsafe_read(sock, &len, sizeof(int));\n\tif (len > 0) {\n\t\t/* receive packed self from main slurmd */\n\t\tincoming_buffer = xmalloc(sizeof(char) * len);\n\t\tsafe_read(sock, incoming_buffer, len);\n\t\tbuffer = create_buf(incoming_buffer,len);\n\t\tself = xmalloc(sizeof(slurm_addr_t));\n\t\tif (slurm_unpack_slurm_addr_no_alloc(self, buffer)\n\t\t    == SLURM_ERROR) {\n\t\t\tfatal(\"slurmstepd: problem with unpack of \"\n\t\t\t      \"slurmd_conf\");\n\t\t}\n\t\tfree_buf(buffer);\n\t}\n\n\t/* Receive GRES information from slurmd */\n\tgres_plugin_recv_stepd(sock);\n\n\t/* Grab the slurmd's spooldir. Has %n expanded. */\n\tcpu_freq_init(conf);\n\n\t/* Receive cpu_frequency info from slurmd */\n\tcpu_freq_recv_info(sock);\n\n\t/* get the protocol version of the srun */\n\tsafe_read(sock, &proto, sizeof(int));\n\n\t/* receive req from slurmd */\n\tsafe_read(sock, &len, sizeof(int));\n\tincoming_buffer = xmalloc(sizeof(char) * len);\n\tsafe_read(sock, incoming_buffer, len);\n\tbuffer = create_buf(incoming_buffer,len);\n\n\tmsg = xmalloc(sizeof(slurm_msg_t));\n\tslurm_msg_t_init(msg);\n\tmsg->protocol_version = (uint16_t)proto;\n\n\tswitch (step_type) {\n\tcase LAUNCH_BATCH_JOB:\n\t\tmsg->msg_type = REQUEST_BATCH_JOB_LAUNCH;\n\t\tbreak;\n\tcase LAUNCH_TASKS:\n\t\tmsg->msg_type = REQUEST_LAUNCH_TASKS;\n\t\tbreak;\n\tdefault:\n\t\tfatal(\"%s: Unrecognized launch RPC (%d)\", __func__, step_type);\n\t\tbreak;\n\t}\n\tif (unpack_msg(msg, buffer) == SLURM_ERROR)\n\t\tfatal(\"slurmstepd: we didn't unpack the request correctly\");\n\tfree_buf(buffer);\n\n\t/* receive cached group ids array for the relevant uid */\n\tsafe_read(sock, &ngids, sizeof(int));\n\tif (ngids > 0) {\n\t\tint i;\n\t\tuint32_t tmp32;\n\n\t\tgids = (gid_t *)xmalloc(sizeof(gid_t) * ngids);\n\t\tfor (i = 0; i < ngids; i++) {\n\t\t\tsafe_read(sock, &tmp32, sizeof(uint32_t));\n\t\t\tgids[i] = (gid_t)tmp32;\n\t\t\tdebug2(\"got gid %d\", gids[i]);\n\t\t}\n\t}\n\n\t*_cli = cli;\n\t*_self = self;\n\t*_msg = msg;\n\t*_ngids = ngids;\n\t*_gids = gids;\n\n\treturn 1;\n\nrwfail:\n\tfatal(\"Error reading initialization data from slurmd\");\n\texit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"failed to initialize authentication plugin\""
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_auth_init",
          "args": [
            "NULL"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"failed to initialize node selection plugin\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_select_init",
          "args": [
            "1"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_setproctitle",
          "args": [
            "argc",
            "argv"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "init_setproctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/setproctitle.c",
          "lines": "263-328",
          "snippet": "void\ninit_setproctitle(int argc, char *argv[])\n{\n#if SETPROCTITLE_STRATEGY == PS_USE_CLOBBER_ARGV\n\tchar *end_of_area = NULL;\n\tint i;\n#endif\n\n\tsave_argc = argc;\n\tsave_argv = argv;\n\n#if defined(__NetBSD__) || defined(__FreeBSD__)\n\tsetprogname (argv[0]);\n#else\n\t_init__progname (argv[0]);\n#endif\n\n#if SETPROCTITLE_STRATEGY == PS_USE_CLOBBER_ARGV\n\t/*\n\t * If we're going to overwrite the argv area, count the available\n\t * space.  Also move the environment to make additional room.\n\t */\n\n\t/*\n\t * check for contiguous argv strings\n\t */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (i == 0 || end_of_area + 1 == argv[i])\n\t\t\tend_of_area = argv[i] + strlen(argv[i]);\n\t}\n\n\t/* probably can't happen? */\n\tif (end_of_area == NULL) {\n\t\tps_buffer = NULL;\n\t\tps_buffer_size = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * check for contiguous environ strings following argv\n\t */\n\tfor (i = 0; environ[i] != NULL; i++) {\n\t\tif (end_of_area + 1 == environ[i])\n\t\t\tend_of_area = environ[i] + strlen(environ[i]);\n\t}\n\n\tps_buffer = argv[0];\n\tps_buffer_size = end_of_area - argv[0] - 1;\n\n\t/*\n\t * Duplicate and move the environment out of the way\n\t */\n\tnew_environ = malloc(sizeof(char *) * (i + 1));\n\tif (!new_environ) {\n\t\tfprintf(stderr, \"ERROR: [%s:%d] %s: %s\\n\",\n\t\t\t__FILE__, __LINE__, \"init_setproctitle\",\n\t\t\tstrerror(errno));\n\t\tabort();\n\t}\n\tfor (i = 0; environ[i] != NULL; i++) {\n\t\tnew_environ[i] = strdup(environ[i]);\n\t}\n\tnew_environ[i] = NULL;\n\tenviron = new_environ;\n#endif /* PS_USE_CLOBBER_ARGV */\n}",
          "includes": [
            "#include <sys/exec.h>",
            "#include <machine/vmparam.h>\t/* for old BSD */",
            "#include <sys/pstat.h>\t\t/* for HP-UX */",
            "#include \"src/common/strlcpy.h\"",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdarg.h>",
            "#include <stdio.h>",
            "#include <stdlib.h>",
            "#include <stdlib.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include <errno.h>",
            "#    include \"src/common/malloc.h\"",
            "#  include \"config.h\""
          ],
          "macros_used": [
            "#define PS_USE_CLOBBER_ARGV\t\t4"
          ],
          "globals_used": [
            "extern char **environ;",
            "static int\tsave_argc;",
            "static char **save_argv;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <sys/exec.h>\n#include <machine/vmparam.h>\t/* for old BSD */\n#include <sys/pstat.h>\t\t/* for HP-UX */\n#include \"src/common/strlcpy.h\"\n#include <unistd.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <errno.h>\n#    include \"src/common/malloc.h\"\n#  include \"config.h\"\n\n#define PS_USE_CLOBBER_ARGV\t\t4\n\nextern char **environ;\nstatic int\tsave_argc;\nstatic char **save_argv;\n\nvoid\ninit_setproctitle(int argc, char *argv[])\n{\n#if SETPROCTITLE_STRATEGY == PS_USE_CLOBBER_ARGV\n\tchar *end_of_area = NULL;\n\tint i;\n#endif\n\n\tsave_argc = argc;\n\tsave_argv = argv;\n\n#if defined(__NetBSD__) || defined(__FreeBSD__)\n\tsetprogname (argv[0]);\n#else\n\t_init__progname (argv[0]);\n#endif\n\n#if SETPROCTITLE_STRATEGY == PS_USE_CLOBBER_ARGV\n\t/*\n\t * If we're going to overwrite the argv area, count the available\n\t * space.  Also move the environment to make additional room.\n\t */\n\n\t/*\n\t * check for contiguous argv strings\n\t */\n\tfor (i = 0; i < argc; i++) {\n\t\tif (i == 0 || end_of_area + 1 == argv[i])\n\t\t\tend_of_area = argv[i] + strlen(argv[i]);\n\t}\n\n\t/* probably can't happen? */\n\tif (end_of_area == NULL) {\n\t\tps_buffer = NULL;\n\t\tps_buffer_size = 0;\n\t\treturn;\n\t}\n\n\t/*\n\t * check for contiguous environ strings following argv\n\t */\n\tfor (i = 0; environ[i] != NULL; i++) {\n\t\tif (end_of_area + 1 == environ[i])\n\t\t\tend_of_area = environ[i] + strlen(environ[i]);\n\t}\n\n\tps_buffer = argv[0];\n\tps_buffer_size = end_of_area - argv[0] - 1;\n\n\t/*\n\t * Duplicate and move the environment out of the way\n\t */\n\tnew_environ = malloc(sizeof(char *) * (i + 1));\n\tif (!new_environ) {\n\t\tfprintf(stderr, \"ERROR: [%s:%d] %s: %s\\n\",\n\t\t\t__FILE__, __LINE__, \"init_setproctitle\",\n\t\t\tstrerror(errno));\n\t\tabort();\n\t}\n\tfor (i = 0; environ[i] != NULL; i++) {\n\t\tnew_environ[i] = strdup(environ[i]);\n\t}\n\tnew_environ[i] = NULL;\n\tenviron = new_environ;\n#endif /* PS_USE_CLOBBER_ARGV */\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(*conf)"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xsignal_block",
          "args": [
            "slurmstepd_blocked_signals"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Error in slurmstepd command line\""
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_process_cmdline",
          "args": [
            "argc",
            "argv"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "_process_cmdline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/slurmstepd.c",
          "lines": "330-343",
          "snippet": "static int _process_cmdline (int argc, char *argv[])\n{\n\tif ((argc == 2) && (xstrcmp(argv[1], \"getenv\") == 0)) {\n\t\tprint_rlimits();\n\t\t_dump_user_env();\n\t\texit(0);\n\t}\n\tif ((argc == 3) && (xstrcmp(argv[1], \"spank\") == 0)) {\n\t\tif (_handle_spank_mode(argc, argv) < 0)\n\t\t\texit (1);\n\t\texit (0);\n\t}\n\treturn (0);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/slurmstepd_init.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/stepd_api.h\"",
            "#include \"src/common/slurm_rlimits_info.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_auth.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include <unistd.h>",
            "#include <sys/mman.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void _dump_user_env(void);",
            "static int _process_cmdline (int argc, char *argv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic void _dump_user_env(void);\nstatic int _process_cmdline (int argc, char *argv[]);\n\nstatic int _process_cmdline (int argc, char *argv[])\n{\n\tif ((argc == 2) && (xstrcmp(argv[1], \"getenv\") == 0)) {\n\t\tprint_rlimits();\n\t\t_dump_user_env();\n\t\texit(0);\n\t}\n\tif ((argc == 3) && (xstrcmp(argv[1], \"spank\") == 0)) {\n\t\tif (_handle_spank_mode(argc, argv) < 0)\n\t\t\texit (1);\n\t\texit (0);\n\t}\n\treturn (0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/slurmstepd_init.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/stepd_api.h\"\n#include \"src/common/slurm_rlimits_info.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_auth.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/cpu_frequency.h\"\n#include <unistd.h>\n#include <sys/mman.h>\n#include <stdlib.h>\n#include <signal.h>\n#  include \"config.h\"\n\nstatic void _got_ack_from_slurmd(int);\nstatic stepd_step_rec_t *_step_setup(slurm_addr_t *cli, slurm_addr_t *self,\n\t\t\t\t     slurm_msg_t *msg);\nstatic int _process_cmdline (int argc, char *argv[]);\nint slurmstepd_blocked_signals[] = {\n\tSIGPIPE, 0\n};\nslurmd_conf_t * conf;\n\nint\nmain (int argc, char *argv[])\n{\n\tslurm_addr_t *cli;\n\tslurm_addr_t *self;\n\tslurm_msg_t *msg;\n\tstepd_step_rec_t *job;\n\tint ngids;\n\tgid_t *gids;\n\tint rc = 0;\n\n\tif (_process_cmdline (argc, argv) < 0)\n\t\tfatal (\"Error in slurmstepd command line\");\n\n\txsignal_block(slurmstepd_blocked_signals);\n\tconf = xmalloc(sizeof(*conf));\n\tconf->argv = &argv;\n\tconf->argc = &argc;\n\tinit_setproctitle(argc, argv);\n\tif (slurm_select_init(1) != SLURM_SUCCESS )\n\t\tfatal( \"failed to initialize node selection plugin\" );\n\tif (slurm_auth_init(NULL) != SLURM_SUCCESS)\n\t\tfatal( \"failed to initialize authentication plugin\" );\n\n\t/* Receive job parameters from the slurmd */\n\t_init_from_slurmd(STDIN_FILENO, argv, &cli, &self, &msg,\n\t\t\t  &ngids, &gids);\n\n\t/* Create the stepd_step_rec_t, mostly from info in a\n\t * launch_tasks_request_msg_t or a batch_job_launch_msg_t */\n\tif (!(job = _step_setup(cli, self, msg))) {\n\t\t_send_fail_to_slurmd(STDOUT_FILENO);\n\t\trc = SLURM_FAILURE;\n\t\tgoto ending;\n\t}\n\tjob->ngids = ngids;\n\tjob->gids = gids;\n\n\t/* fork handlers cause mutexes on some global data structures\n\t * to be re-initialized after the fork. */\n\tlist_install_fork_handlers();\n\tslurm_conf_install_fork_handlers();\n\n\t/* sets job->msg_handle and job->msgid */\n\tif (msg_thr_create(job) == SLURM_ERROR) {\n\t\t_send_fail_to_slurmd(STDOUT_FILENO);\n\t\trc = SLURM_FAILURE;\n\t\tgoto ending;\n\t}\n\n\t_send_ok_to_slurmd(STDOUT_FILENO);\n\t_got_ack_from_slurmd(STDIN_FILENO);\n\n\t/* Fancy way of closing stdin that keeps STDIN_FILENO from being\n\t * allocated to any random file.  The slurmd already opened /dev/null\n\t * on STDERR_FILENO for us. */\n\tdup2(STDERR_FILENO, STDIN_FILENO);\n\n\t/* Fancy way of closing stdout that keeps STDOUT_FILENO from being\n\t * allocated to any random file.  The slurmd already opened /dev/null\n\t * on STDERR_FILENO for us. */\n\tdup2(STDERR_FILENO, STDOUT_FILENO);\n\n\t/* This does most of the stdio setup, then launches all the tasks,\n\t * and blocks until the step is complete */\n\trc = job_manager(job);\n\n\tif (job->batch)\n\t\tbatch_finish(job, rc); /* sends batch complete message */\n\n\t/* signal the message thread to shutdown, and wait for it */\n\teio_signal_shutdown(job->msg_handle);\n\tpthread_join(job->msgid, NULL);\n\nending:\n\tmpi_fini();\t/* Remove stale PMI2 sockets */\n#ifdef MEMORY_LEAK_DEBUG\n\tacct_gather_conf_destroy();\n\t(void) core_spec_g_fini();\n\t_step_cleanup(job, msg, rc);\n\n\tfini_setproctitle();\n\n\txfree(cli);\n\txfree(self);\n\txfree(conf->block_map);\n\txfree(conf->block_map_inv);\n\txfree(conf->hostname);\n\txfree(conf->logfile);\n\txfree(conf->node_name);\n\txfree(conf->node_topo_addr);\n\txfree(conf->node_topo_pattern);\n\txfree(conf->spooldir);\n\txfree(conf);\n#endif\n\tinfo(\"done with job\");\n\treturn rc;\n}"
  }
]