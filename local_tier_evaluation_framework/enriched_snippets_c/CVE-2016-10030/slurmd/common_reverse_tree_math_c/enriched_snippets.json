[
  {
    "function_name": "main",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
    "lines": "196-236",
    "snippet": "int\nmain(int argc, char **argv)\n{\n\tint i, j;\n\tint n = 8192;\n\tint w = 5;\n\n\tint parent, children, depth, maxdepth;\n\n\tfor (i = 0; i < n; i++) {\n\t\tint children1[w], children2[w];\n\t\tint cnt1, cnt2;\n\n\t\treverse_tree_info(i, n, w, &parent,\n\t\t\t\t  &children, &depth, &maxdepth);\n\t\tprintf(\"\\\n%d : par: %d nchild: %d depth: %d, maxdepth: %d\\n\",\n\t\t       i, parent, children, depth, maxdepth);\n\t\tcnt1 = dumb_direct_children(children1, w, i, n);\n\t\tcnt2 = reverce_tree_direct_children(i, n, w, depth, children2);\n\t\tif (cnt1 != cnt2 ) {\n\t\t\tprintf(\"\\\nDirect children sanity check error: cnt1 = %d, cnt2 = %d\\n\", cnt1, cnt2);\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor(j = 0; j < cnt1; j++){\n\n\t\t\tif (children1[j] != children2[j]) {\n\t\t\t\tprintf(\"\\\nDirect children sanity check error: cnt1 = %d, cnt2 = %d\\n\", cnt1, cnt2);\n\t\t\t\tprintf(\"\\\nFailed on %d'th element: children1[%d] = %d, children2[%d] = %d\\n\",\n\t\t\t\t       j, j, children1[j], j, children2[j]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\\nFailed on %d'th element: children1[%d] = %d, children2[%d] = %d\\n\"",
            "j",
            "j",
            "children1[j]",
            "j",
            "children2[j]"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\\nDirect children sanity check error: cnt1 = %d, cnt2 = %d\\n\"",
            "cnt1",
            "cnt2"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\\nDirect children sanity check error: cnt1 = %d, cnt2 = %d\\n\"",
            "cnt1",
            "cnt2"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reverce_tree_direct_children",
          "args": [
            "i",
            "n",
            "w",
            "depth",
            "children2"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dumb_direct_children",
          "args": [
            "children1",
            "w",
            "i",
            "n"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "dumb_direct_children",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
          "lines": "179-194",
          "snippet": "static int dumb_direct_children(int *children, int width, int id,\n\t\t\t\tint max_node_id)\n{\n\tint child;\n\tint count = 0;\n\tfor(child = id+1; child < max_node_id; child++){\n\t\tint parent_id, child_num, depth, max_depth;\n\t\treverse_tree_info(child, max_node_id, width,\n\t\t\t\t  &parent_id, &child_num,\n\t\t\t\t  &depth, &max_depth);\n\t\tif( parent_id == id ){\n\t\t\tchildren[count++] = child;\n\t\t}\n\t}\n\treturn count;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic int dumb_direct_children(int *children, int width, int id,\n\t\t\t\tint max_node_id)\n{\n\tint child;\n\tint count = 0;\n\tfor(child = id+1; child < max_node_id; child++){\n\t\tint parent_id, child_num, depth, max_depth;\n\t\treverse_tree_info(child, max_node_id, width,\n\t\t\t\t  &parent_id, &child_num,\n\t\t\t\t  &depth, &max_depth);\n\t\tif( parent_id == id ){\n\t\t\tchildren[count++] = child;\n\t\t}\n\t}\n\treturn count;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\\n%d : par: %d nchild: %d depth: %d, maxdepth: %d\\n\"",
            "i",
            "parent",
            "children",
            "depth",
            "maxdepth"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "reverse_tree_info",
          "args": [
            "i",
            "n",
            "w",
            "&parent",
            "&children",
            "&depth",
            "&maxdepth"
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "reverse_tree_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
          "lines": "117-152",
          "snippet": "void\nreverse_tree_info(int rank, int num_nodes, int width,\n\t\t  int *parent, int *num_children,\n\t\t  int *depth, int *max_depth)\n{\n\tint max_children;\n\tint p, c;\n\n\t/* sanity check */\n\tif (rank >= num_nodes) {\n\t\t*parent = -1;\n\t\t*num_children = -1;\n\t\t*depth = -1;\n\t\t*max_depth = -1;\n\t\treturn;\n\t}\n\n\t*max_depth = dep(num_nodes, width);\n\tif (rank == 0) {\n\t\t*parent = -1;\n\t\t*num_children = num_nodes - 1;\n\t\t*depth = 0;\n\t\treturn;\n\t}\n\n\tmax_children = geometric_series(width, *max_depth);\n\t*depth = 0;\n\tsearch_tree(rank, 0, max_children, width, &p, &c, depth);\n\n\tif ((rank + c) >= num_nodes)\n\t\tc = num_nodes - rank - 1;\n\n\t*parent = p;\n\t*num_children = c;\n\treturn;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nvoid\nreverse_tree_info(int rank, int num_nodes, int width,\n\t\t  int *parent, int *num_children,\n\t\t  int *depth, int *max_depth)\n{\n\tint max_children;\n\tint p, c;\n\n\t/* sanity check */\n\tif (rank >= num_nodes) {\n\t\t*parent = -1;\n\t\t*num_children = -1;\n\t\t*depth = -1;\n\t\t*max_depth = -1;\n\t\treturn;\n\t}\n\n\t*max_depth = dep(num_nodes, width);\n\tif (rank == 0) {\n\t\t*parent = -1;\n\t\t*num_children = num_nodes - 1;\n\t\t*depth = 0;\n\t\treturn;\n\t}\n\n\tmax_children = geometric_series(width, *max_depth);\n\t*depth = 0;\n\tsearch_tree(rank, 0, max_children, width, &p, &c, depth);\n\n\tif ((rank + c) >= num_nodes)\n\t\tc = num_nodes - rank - 1;\n\n\t*parent = p;\n\t*num_children = c;\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nint\nmain(int argc, char **argv)\n{\n\tint i, j;\n\tint n = 8192;\n\tint w = 5;\n\n\tint parent, children, depth, maxdepth;\n\n\tfor (i = 0; i < n; i++) {\n\t\tint children1[w], children2[w];\n\t\tint cnt1, cnt2;\n\n\t\treverse_tree_info(i, n, w, &parent,\n\t\t\t\t  &children, &depth, &maxdepth);\n\t\tprintf(\"\\\n%d : par: %d nchild: %d depth: %d, maxdepth: %d\\n\",\n\t\t       i, parent, children, depth, maxdepth);\n\t\tcnt1 = dumb_direct_children(children1, w, i, n);\n\t\tcnt2 = reverce_tree_direct_children(i, n, w, depth, children2);\n\t\tif (cnt1 != cnt2 ) {\n\t\t\tprintf(\"\\\nDirect children sanity check error: cnt1 = %d, cnt2 = %d\\n\", cnt1, cnt2);\n\t\t\treturn -1;\n\t\t}\n\n\t\tfor(j = 0; j < cnt1; j++){\n\n\t\t\tif (children1[j] != children2[j]) {\n\t\t\t\tprintf(\"\\\nDirect children sanity check error: cnt1 = %d, cnt2 = %d\\n\", cnt1, cnt2);\n\t\t\t\tprintf(\"\\\nFailed on %d'th element: children1[%d] = %d, children2[%d] = %d\\n\",\n\t\t\t\t       j, j, children1[j], j, children2[j]);\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "dumb_direct_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
    "lines": "179-194",
    "snippet": "static int dumb_direct_children(int *children, int width, int id,\n\t\t\t\tint max_node_id)\n{\n\tint child;\n\tint count = 0;\n\tfor(child = id+1; child < max_node_id; child++){\n\t\tint parent_id, child_num, depth, max_depth;\n\t\treverse_tree_info(child, max_node_id, width,\n\t\t\t\t  &parent_id, &child_num,\n\t\t\t\t  &depth, &max_depth);\n\t\tif( parent_id == id ){\n\t\t\tchildren[count++] = child;\n\t\t}\n\t}\n\treturn count;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "reverse_tree_info",
          "args": [
            "child",
            "max_node_id",
            "width",
            "&parent_id",
            "&child_num",
            "&depth",
            "&max_depth"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "reverse_tree_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
          "lines": "117-152",
          "snippet": "void\nreverse_tree_info(int rank, int num_nodes, int width,\n\t\t  int *parent, int *num_children,\n\t\t  int *depth, int *max_depth)\n{\n\tint max_children;\n\tint p, c;\n\n\t/* sanity check */\n\tif (rank >= num_nodes) {\n\t\t*parent = -1;\n\t\t*num_children = -1;\n\t\t*depth = -1;\n\t\t*max_depth = -1;\n\t\treturn;\n\t}\n\n\t*max_depth = dep(num_nodes, width);\n\tif (rank == 0) {\n\t\t*parent = -1;\n\t\t*num_children = num_nodes - 1;\n\t\t*depth = 0;\n\t\treturn;\n\t}\n\n\tmax_children = geometric_series(width, *max_depth);\n\t*depth = 0;\n\tsearch_tree(rank, 0, max_children, width, &p, &c, depth);\n\n\tif ((rank + c) >= num_nodes)\n\t\tc = num_nodes - rank - 1;\n\n\t*parent = p;\n\t*num_children = c;\n\treturn;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nvoid\nreverse_tree_info(int rank, int num_nodes, int width,\n\t\t  int *parent, int *num_children,\n\t\t  int *depth, int *max_depth)\n{\n\tint max_children;\n\tint p, c;\n\n\t/* sanity check */\n\tif (rank >= num_nodes) {\n\t\t*parent = -1;\n\t\t*num_children = -1;\n\t\t*depth = -1;\n\t\t*max_depth = -1;\n\t\treturn;\n\t}\n\n\t*max_depth = dep(num_nodes, width);\n\tif (rank == 0) {\n\t\t*parent = -1;\n\t\t*num_children = num_nodes - 1;\n\t\t*depth = 0;\n\t\treturn;\n\t}\n\n\tmax_children = geometric_series(width, *max_depth);\n\t*depth = 0;\n\tsearch_tree(rank, 0, max_children, width, &p, &c, depth);\n\n\tif ((rank + c) >= num_nodes)\n\t\tc = num_nodes - rank - 1;\n\n\t*parent = p;\n\t*num_children = c;\n\treturn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic int dumb_direct_children(int *children, int width, int id,\n\t\t\t\tint max_node_id)\n{\n\tint child;\n\tint count = 0;\n\tfor(child = id+1; child < max_node_id; child++){\n\t\tint parent_id, child_num, depth, max_depth;\n\t\treverse_tree_info(child, max_node_id, width,\n\t\t\t\t  &parent_id, &child_num,\n\t\t\t\t  &depth, &max_depth);\n\t\tif( parent_id == id ){\n\t\t\tchildren[count++] = child;\n\t\t}\n\t}\n\treturn count;\n}"
  },
  {
    "function_name": "reverse_tree_direct_children",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
    "lines": "154-174",
    "snippet": "int reverse_tree_direct_children(int rank, int num_nodes, int width,\n\t\t\t\t int depth, int *children)\n{\n\tint current, child_distance;\n\tint max_depth, sub_depth, max_rank_children;\n\tint i;\n\n\tmax_depth = dep(num_nodes, width);\n\tsub_depth = max_depth - depth;\n\tif( sub_depth == 0 ){\n\t\treturn 0;\n\t}\n\tmax_rank_children = geometric_series(width, sub_depth);\n\tcurrent = rank + 1;\n\tchild_distance = (max_rank_children / width);\n\tfor (i = 0; i < width && current < num_nodes; i++) {\n\t\tchildren[i] = current;\n\t\tcurrent += child_distance;\n\t}\n\treturn i;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "geometric_series",
          "args": [
            "width",
            "sub_depth"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "geometric_series",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
          "lines": "64-68",
          "snippet": "static inline int geometric_series(int width, int depth)\n{\n\treturn (width == 1) ?\n\t\t1 : (1 - (int_pow(width, (depth+1)))) / (1 - width);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic inline int geometric_series(int width, int depth)\n{\n\treturn (width == 1) ?\n\t\t1 : (1 - (int_pow(width, (depth+1)))) / (1 - width);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dep",
          "args": [
            "num_nodes",
            "width"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "dep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
          "lines": "70-80",
          "snippet": "static inline int dep(int total, int width)\n{\n\tint i;\n\tint x = 0;\n\n\tfor (i = 1; x < total-1; i++) {\n\t\tx += int_pow(width, i);\n\t}\n\n\treturn i-1;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic inline int dep(int total, int width)\n{\n\tint i;\n\tint x = 0;\n\n\tfor (i = 1; x < total-1; i++) {\n\t\tx += int_pow(width, i);\n\t}\n\n\treturn i-1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nint reverse_tree_direct_children(int rank, int num_nodes, int width,\n\t\t\t\t int depth, int *children)\n{\n\tint current, child_distance;\n\tint max_depth, sub_depth, max_rank_children;\n\tint i;\n\n\tmax_depth = dep(num_nodes, width);\n\tsub_depth = max_depth - depth;\n\tif( sub_depth == 0 ){\n\t\treturn 0;\n\t}\n\tmax_rank_children = geometric_series(width, sub_depth);\n\tcurrent = rank + 1;\n\tchild_distance = (max_rank_children / width);\n\tfor (i = 0; i < width && current < num_nodes; i++) {\n\t\tchildren[i] = current;\n\t\tcurrent += child_distance;\n\t}\n\treturn i;\n}"
  },
  {
    "function_name": "reverse_tree_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
    "lines": "117-152",
    "snippet": "void\nreverse_tree_info(int rank, int num_nodes, int width,\n\t\t  int *parent, int *num_children,\n\t\t  int *depth, int *max_depth)\n{\n\tint max_children;\n\tint p, c;\n\n\t/* sanity check */\n\tif (rank >= num_nodes) {\n\t\t*parent = -1;\n\t\t*num_children = -1;\n\t\t*depth = -1;\n\t\t*max_depth = -1;\n\t\treturn;\n\t}\n\n\t*max_depth = dep(num_nodes, width);\n\tif (rank == 0) {\n\t\t*parent = -1;\n\t\t*num_children = num_nodes - 1;\n\t\t*depth = 0;\n\t\treturn;\n\t}\n\n\tmax_children = geometric_series(width, *max_depth);\n\t*depth = 0;\n\tsearch_tree(rank, 0, max_children, width, &p, &c, depth);\n\n\tif ((rank + c) >= num_nodes)\n\t\tc = num_nodes - rank - 1;\n\n\t*parent = p;\n\t*num_children = c;\n\treturn;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "search_tree",
          "args": [
            "rank",
            "0",
            "max_children",
            "width",
            "&p",
            "&c",
            "depth"
          ],
          "line": 144
        },
        "resolved": true,
        "details": {
          "function_name": "search_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
          "lines": "82-115",
          "snippet": "static int search_tree(int id, int node, int max_children, int width,\n\t\t       int *parent_id, int *next_max_children, int *depth)\n{\n\tint current, next, next_children;\n\tint i;\n\n\t*depth = *depth + 1;\n\tcurrent = node + 1;\n\tnext_children = (max_children / width) - 1;\n\n\tif (id == current) {\n\t\t*parent_id = node;\n\t\t*next_max_children = next_children;\n\t\treturn 1;\n\t}\n\n\tfor (i = 1; i <= width; i++) {\n\t\tnext = current + next_children + 1;\n\t\tif (id == next) {\n\t\t\t*parent_id = node;\n\t\t\t*next_max_children = next_children;\n\t\t\treturn 1;\n\t\t}\n\t\tif (id > current && id < next) {\n\t\t\treturn search_tree(id, current, next_children, width,\n\t\t\t\t\t   parent_id, next_max_children,\n\t\t\t\t\t   depth);\n\t\t}\n\t\tcurrent = next;\n\t}\n\t*parent_id = -1;\n\t*next_max_children = -1;\n\treturn 0;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic int search_tree(int id, int node, int max_children, int width,\n\t\t       int *parent_id, int *next_max_children, int *depth)\n{\n\tint current, next, next_children;\n\tint i;\n\n\t*depth = *depth + 1;\n\tcurrent = node + 1;\n\tnext_children = (max_children / width) - 1;\n\n\tif (id == current) {\n\t\t*parent_id = node;\n\t\t*next_max_children = next_children;\n\t\treturn 1;\n\t}\n\n\tfor (i = 1; i <= width; i++) {\n\t\tnext = current + next_children + 1;\n\t\tif (id == next) {\n\t\t\t*parent_id = node;\n\t\t\t*next_max_children = next_children;\n\t\t\treturn 1;\n\t\t}\n\t\tif (id > current && id < next) {\n\t\t\treturn search_tree(id, current, next_children, width,\n\t\t\t\t\t   parent_id, next_max_children,\n\t\t\t\t\t   depth);\n\t\t}\n\t\tcurrent = next;\n\t}\n\t*parent_id = -1;\n\t*next_max_children = -1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "geometric_series",
          "args": [
            "width",
            "*max_depth"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "geometric_series",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
          "lines": "64-68",
          "snippet": "static inline int geometric_series(int width, int depth)\n{\n\treturn (width == 1) ?\n\t\t1 : (1 - (int_pow(width, (depth+1)))) / (1 - width);\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic inline int geometric_series(int width, int depth)\n{\n\treturn (width == 1) ?\n\t\t1 : (1 - (int_pow(width, (depth+1)))) / (1 - width);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dep",
          "args": [
            "num_nodes",
            "width"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "dep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
          "lines": "70-80",
          "snippet": "static inline int dep(int total, int width)\n{\n\tint i;\n\tint x = 0;\n\n\tfor (i = 1; x < total-1; i++) {\n\t\tx += int_pow(width, i);\n\t}\n\n\treturn i-1;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic inline int dep(int total, int width)\n{\n\tint i;\n\tint x = 0;\n\n\tfor (i = 1; x < total-1; i++) {\n\t\tx += int_pow(width, i);\n\t}\n\n\treturn i-1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nvoid\nreverse_tree_info(int rank, int num_nodes, int width,\n\t\t  int *parent, int *num_children,\n\t\t  int *depth, int *max_depth)\n{\n\tint max_children;\n\tint p, c;\n\n\t/* sanity check */\n\tif (rank >= num_nodes) {\n\t\t*parent = -1;\n\t\t*num_children = -1;\n\t\t*depth = -1;\n\t\t*max_depth = -1;\n\t\treturn;\n\t}\n\n\t*max_depth = dep(num_nodes, width);\n\tif (rank == 0) {\n\t\t*parent = -1;\n\t\t*num_children = num_nodes - 1;\n\t\t*depth = 0;\n\t\treturn;\n\t}\n\n\tmax_children = geometric_series(width, *max_depth);\n\t*depth = 0;\n\tsearch_tree(rank, 0, max_children, width, &p, &c, depth);\n\n\tif ((rank + c) >= num_nodes)\n\t\tc = num_nodes - rank - 1;\n\n\t*parent = p;\n\t*num_children = c;\n\treturn;\n}"
  },
  {
    "function_name": "search_tree",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
    "lines": "82-115",
    "snippet": "static int search_tree(int id, int node, int max_children, int width,\n\t\t       int *parent_id, int *next_max_children, int *depth)\n{\n\tint current, next, next_children;\n\tint i;\n\n\t*depth = *depth + 1;\n\tcurrent = node + 1;\n\tnext_children = (max_children / width) - 1;\n\n\tif (id == current) {\n\t\t*parent_id = node;\n\t\t*next_max_children = next_children;\n\t\treturn 1;\n\t}\n\n\tfor (i = 1; i <= width; i++) {\n\t\tnext = current + next_children + 1;\n\t\tif (id == next) {\n\t\t\t*parent_id = node;\n\t\t\t*next_max_children = next_children;\n\t\t\treturn 1;\n\t\t}\n\t\tif (id > current && id < next) {\n\t\t\treturn search_tree(id, current, next_children, width,\n\t\t\t\t\t   parent_id, next_max_children,\n\t\t\t\t\t   depth);\n\t\t}\n\t\tcurrent = next;\n\t}\n\t*parent_id = -1;\n\t*next_max_children = -1;\n\treturn 0;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "search_tree",
          "args": [
            "id",
            "current",
            "next_children",
            "width",
            "parent_id",
            "next_max_children",
            "depth"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "search_tree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
          "lines": "82-115",
          "snippet": "static int search_tree(int id, int node, int max_children, int width,\n\t\t       int *parent_id, int *next_max_children, int *depth)\n{\n\tint current, next, next_children;\n\tint i;\n\n\t*depth = *depth + 1;\n\tcurrent = node + 1;\n\tnext_children = (max_children / width) - 1;\n\n\tif (id == current) {\n\t\t*parent_id = node;\n\t\t*next_max_children = next_children;\n\t\treturn 1;\n\t}\n\n\tfor (i = 1; i <= width; i++) {\n\t\tnext = current + next_children + 1;\n\t\tif (id == next) {\n\t\t\t*parent_id = node;\n\t\t\t*next_max_children = next_children;\n\t\t\treturn 1;\n\t\t}\n\t\tif (id > current && id < next) {\n\t\t\treturn search_tree(id, current, next_children, width,\n\t\t\t\t\t   parent_id, next_max_children,\n\t\t\t\t\t   depth);\n\t\t}\n\t\tcurrent = next;\n\t}\n\t*parent_id = -1;\n\t*next_max_children = -1;\n\treturn 0;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic int search_tree(int id, int node, int max_children, int width,\n\t\t       int *parent_id, int *next_max_children, int *depth)\n{\n\tint current, next, next_children;\n\tint i;\n\n\t*depth = *depth + 1;\n\tcurrent = node + 1;\n\tnext_children = (max_children / width) - 1;\n\n\tif (id == current) {\n\t\t*parent_id = node;\n\t\t*next_max_children = next_children;\n\t\treturn 1;\n\t}\n\n\tfor (i = 1; i <= width; i++) {\n\t\tnext = current + next_children + 1;\n\t\tif (id == next) {\n\t\t\t*parent_id = node;\n\t\t\t*next_max_children = next_children;\n\t\t\treturn 1;\n\t\t}\n\t\tif (id > current && id < next) {\n\t\t\treturn search_tree(id, current, next_children, width,\n\t\t\t\t\t   parent_id, next_max_children,\n\t\t\t\t\t   depth);\n\t\t}\n\t\tcurrent = next;\n\t}\n\t*parent_id = -1;\n\t*next_max_children = -1;\n\treturn 0;\n}"
  },
  {
    "function_name": "dep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
    "lines": "70-80",
    "snippet": "static inline int dep(int total, int width)\n{\n\tint i;\n\tint x = 0;\n\n\tfor (i = 1; x < total-1; i++) {\n\t\tx += int_pow(width, i);\n\t}\n\n\treturn i-1;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "int_pow",
          "args": [
            "width",
            "i"
          ],
          "line": 76
        },
        "resolved": true,
        "details": {
          "function_name": "int_pow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
          "lines": "46-62",
          "snippet": "static inline int int_pow(int num, int power)\n{\n\tint res;\n\tint i;\n\n\tif (power == 0)\n\t\tres = 1;\n\telse if (power == 1)\n\t\tres = num;\n\telse {\n\t\tres = num;\n\t\tfor (i = 1; i < power; i++)\n\t\t\tres *= num;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic inline int int_pow(int num, int power)\n{\n\tint res;\n\tint i;\n\n\tif (power == 0)\n\t\tres = 1;\n\telse if (power == 1)\n\t\tres = num;\n\telse {\n\t\tres = num;\n\t\tfor (i = 1; i < power; i++)\n\t\t\tres *= num;\n\t}\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic inline int dep(int total, int width)\n{\n\tint i;\n\tint x = 0;\n\n\tfor (i = 1; x < total-1; i++) {\n\t\tx += int_pow(width, i);\n\t}\n\n\treturn i-1;\n}"
  },
  {
    "function_name": "geometric_series",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
    "lines": "64-68",
    "snippet": "static inline int geometric_series(int width, int depth)\n{\n\treturn (width == 1) ?\n\t\t1 : (1 - (int_pow(width, (depth+1)))) / (1 - width);\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "int_pow",
          "args": [
            "width",
            "(depth+1)"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "int_pow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
          "lines": "46-62",
          "snippet": "static inline int int_pow(int num, int power)\n{\n\tint res;\n\tint i;\n\n\tif (power == 0)\n\t\tres = 1;\n\telse if (power == 1)\n\t\tres = num;\n\telse {\n\t\tres = num;\n\t\tfor (i = 1; i < power; i++)\n\t\t\tres *= num;\n\t}\n\n\treturn res;\n}",
          "includes": [
            "#include <stdlib.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic inline int int_pow(int num, int power)\n{\n\tint res;\n\tint i;\n\n\tif (power == 0)\n\t\tres = 1;\n\telse if (power == 1)\n\t\tres = num;\n\telse {\n\t\tres = num;\n\t\tfor (i = 1; i < power; i++)\n\t\t\tres *= num;\n\t}\n\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic inline int geometric_series(int width, int depth)\n{\n\treturn (width == 1) ?\n\t\t1 : (1 - (int_pow(width, (depth+1)))) / (1 - width);\n}"
  },
  {
    "function_name": "int_pow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/reverse_tree_math.c",
    "lines": "46-62",
    "snippet": "static inline int int_pow(int num, int power)\n{\n\tint res;\n\tint i;\n\n\tif (power == 0)\n\t\tres = 1;\n\telse if (power == 1)\n\t\tres = num;\n\telse {\n\t\tres = num;\n\t\tfor (i = 1; i < power; i++)\n\t\t\tres *= num;\n\t}\n\n\treturn res;\n}",
    "includes": [
      "#include <stdlib.h>",
      "#include <stdio.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <stdlib.h>\n#include <stdio.h>\n\nstatic inline int int_pow(int num, int power)\n{\n\tint res;\n\tint i;\n\n\tif (power == 0)\n\t\tres = 1;\n\telse if (power == 1)\n\t\tres = num;\n\telse {\n\t\tres = num;\n\t\tfor (i = 1; i < power; i++)\n\t\t\tres *= num;\n\t}\n\n\treturn res;\n}"
  }
]