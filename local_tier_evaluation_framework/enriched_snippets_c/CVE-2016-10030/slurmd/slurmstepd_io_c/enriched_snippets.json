[
  {
    "function_name": "io_get_file_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "2094-2114",
    "snippet": "int\nio_get_file_flags(stepd_step_rec_t *job)\n{\n\tslurm_ctl_conf_t *conf;\n\tint file_flags;\n\n\t/* set files for opening stdout/err */\n\tif (job->open_mode == OPEN_MODE_APPEND)\n\t\tfile_flags = O_CREAT|O_WRONLY|O_APPEND;\n\telse if (job->open_mode == OPEN_MODE_TRUNCATE)\n\t\tfile_flags = O_CREAT|O_WRONLY|O_APPEND|O_TRUNC;\n\telse {\n\t\tconf = slurm_conf_lock();\n\t\tif (conf->job_file_append)\n\t\t\tfile_flags = O_CREAT|O_WRONLY|O_APPEND;\n\t\telse\n\t\t\tfile_flags = O_CREAT|O_WRONLY|O_APPEND|O_TRUNC;\n\t\tslurm_conf_unlock();\n\t}\n\treturn file_flags;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);",
      "int file_flags = io_get_file_flags(job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_conf_unlock",
          "args": [],
          "line": 2111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_conf_lock",
          "args": [],
          "line": 2106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\nint file_flags = io_get_file_flags(job);\n\nint\nio_get_file_flags(stepd_step_rec_t *job)\n{\n\tslurm_ctl_conf_t *conf;\n\tint file_flags;\n\n\t/* set files for opening stdout/err */\n\tif (job->open_mode == OPEN_MODE_APPEND)\n\t\tfile_flags = O_CREAT|O_WRONLY|O_APPEND;\n\telse if (job->open_mode == OPEN_MODE_TRUNCATE)\n\t\tfile_flags = O_CREAT|O_WRONLY|O_APPEND|O_TRUNC;\n\telse {\n\t\tconf = slurm_conf_lock();\n\t\tif (conf->job_file_append)\n\t\t\tfile_flags = O_CREAT|O_WRONLY|O_APPEND;\n\t\telse\n\t\t\tfile_flags = O_CREAT|O_WRONLY|O_APPEND|O_TRUNC;\n\t\tslurm_conf_unlock();\n\t}\n\treturn file_flags;\n}"
  },
  {
    "function_name": "io_find_filename_pattern",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1981-2091",
    "snippet": "void\nio_find_filename_pattern( stepd_step_rec_t *job,\n\t\t\t  slurmd_filename_pattern_t *outpattern,\n\t\t\t  slurmd_filename_pattern_t *errpattern,\n\t\t\t  bool *same_out_err_files )\n{\n\tint ii, jj;\n\tint of_num_null = 0, ef_num_null = 0;\n\tint of_num_devnull = 0, ef_num_devnull = 0;\n\tint of_lastnull = -1, ef_lastnull = -1;\n\tbool of_all_same = true, ef_all_same = true;\n\tbool of_all_unique = true, ef_all_unique = true;\n\n\t*outpattern = SLURMD_UNKNOWN;\n\t*errpattern = SLURMD_UNKNOWN;\n\t*same_out_err_files = false;\n\n\tfor (ii = 0; ii < job->node_tasks; ii++) {\n\t\tif (job->task[ii]->ofname == NULL) {\n\t\t\tof_num_null++;\n\t\t\tof_lastnull = ii;\n\t\t} else if (xstrcmp(job->task[ii]->ofname, \"/dev/null\")==0) {\n\t\t\tof_num_devnull++;\n\t\t}\n\n\t\tif (job->task[ii]->efname == NULL) {\n\t\t\tef_num_null++;\n\t\t\tef_lastnull = ii;\n\t\t} else if (xstrcmp(job->task[ii]->efname, \"/dev/null\")==0) {\n\t\t\tef_num_devnull++;\n\t\t}\n\t}\n\tif (of_num_null == job->node_tasks)\n\t\t*outpattern = SLURMD_ALL_NULL;\n\n\tif (ef_num_null == job->node_tasks)\n\t\t*errpattern = SLURMD_ALL_NULL;\n\n\tif (of_num_null == 1 && of_num_devnull == job->node_tasks-1)\n\t\t*outpattern = SLURMD_ONE_NULL;\n\n\tif (ef_num_null == 1 && ef_num_devnull == job->node_tasks-1)\n\t\t*errpattern = SLURMD_ONE_NULL;\n\n\tif (*outpattern == SLURMD_ALL_NULL && *errpattern == SLURMD_ALL_NULL)\n\t\t*same_out_err_files = true;\n\n\tif (*outpattern == SLURMD_ONE_NULL && *errpattern == SLURMD_ONE_NULL &&\n\t    of_lastnull == ef_lastnull)\n\t\t*same_out_err_files = true;\n\n\tif (*outpattern != SLURMD_UNKNOWN && *errpattern != SLURMD_UNKNOWN)\n\t\treturn;\n\n\tfor (ii = 1; ii < job->node_tasks; ii++) {\n\t\tif (!job->task[ii]->ofname || !job->task[0]->ofname ||\n\t\t    xstrcmp(job->task[ii]->ofname, job->task[0]->ofname) != 0)\n\t\t\tof_all_same = false;\n\n\t\tif (!job->task[ii]->efname || !job->task[0]->efname ||\n\t\t    xstrcmp(job->task[ii]->efname, job->task[0]->efname) != 0)\n\t\t\tef_all_same = false;\n\t}\n\n\tif (of_all_same && *outpattern == SLURMD_UNKNOWN)\n\t\t*outpattern = SLURMD_ALL_SAME;\n\n\tif (ef_all_same && *errpattern == SLURMD_UNKNOWN)\n\t\t*errpattern = SLURMD_ALL_SAME;\n\n\tif (job->task[0]->ofname && job->task[0]->efname &&\n\t    xstrcmp(job->task[0]->ofname, job->task[0]->efname)==0)\n\t\t*same_out_err_files = true;\n\n\tif (*outpattern != SLURMD_UNKNOWN && *errpattern != SLURMD_UNKNOWN)\n\t\treturn;\n\n\tfor (ii = 0; ii < job->node_tasks-1; ii++) {\n\t\tfor (jj = ii+1; jj < job->node_tasks; jj++) {\n\n\t\t\tif (!job->task[ii]->ofname || !job->task[jj]->ofname ||\n\t\t\t    xstrcmp(job->task[ii]->ofname,\n\t\t\t\t    job->task[jj]->ofname) == 0)\n\t\t\t\tof_all_unique = false;\n\n\t\t\tif (!job->task[ii]->efname || !job->task[jj]->efname ||\n\t\t\t    xstrcmp(job->task[ii]->efname,\n\t\t\t\t    job->task[jj]->efname) == 0)\n\t\t\t\tef_all_unique = false;\n\t\t}\n\t}\n\n\tif (of_all_unique)\n\t\t*outpattern = SLURMD_ALL_UNIQUE;\n\n\tif (ef_all_unique)\n\t\t*errpattern = SLURMD_ALL_UNIQUE;\n\n\tif (of_all_unique && ef_all_unique) {\n\t\t*same_out_err_files = true;\n\t\tfor (ii = 0; ii < job->node_tasks; ii++) {\n\t\t\tif (job->task[ii]->ofname &&\n\t\t\t    job->task[ii]->efname &&\n\t\t\t    xstrcmp(job->task[ii]->ofname,\n\t\t\t\t    job->task[ii]->efname) != 0) {\n\t\t\t\t*same_out_err_files = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "job->task[ii]->ofname",
            "job->task[ii]->efname"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "job->task[ii]->efname",
            "job->task[jj]->efname"
          ],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "job->task[ii]->ofname",
            "job->task[jj]->ofname"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "job->task[0]->ofname",
            "job->task[0]->efname"
          ],
          "line": 2052
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "job->task[ii]->efname",
            "job->task[0]->efname"
          ],
          "line": 2041
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "job->task[ii]->ofname",
            "job->task[0]->ofname"
          ],
          "line": 2037
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "job->task[ii]->efname",
            "\"/dev/null\""
          ],
          "line": 2009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xstrcmp",
          "args": [
            "job->task[ii]->ofname",
            "\"/dev/null\""
          ],
          "line": 2002
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nvoid\nio_find_filename_pattern( stepd_step_rec_t *job,\n\t\t\t  slurmd_filename_pattern_t *outpattern,\n\t\t\t  slurmd_filename_pattern_t *errpattern,\n\t\t\t  bool *same_out_err_files )\n{\n\tint ii, jj;\n\tint of_num_null = 0, ef_num_null = 0;\n\tint of_num_devnull = 0, ef_num_devnull = 0;\n\tint of_lastnull = -1, ef_lastnull = -1;\n\tbool of_all_same = true, ef_all_same = true;\n\tbool of_all_unique = true, ef_all_unique = true;\n\n\t*outpattern = SLURMD_UNKNOWN;\n\t*errpattern = SLURMD_UNKNOWN;\n\t*same_out_err_files = false;\n\n\tfor (ii = 0; ii < job->node_tasks; ii++) {\n\t\tif (job->task[ii]->ofname == NULL) {\n\t\t\tof_num_null++;\n\t\t\tof_lastnull = ii;\n\t\t} else if (xstrcmp(job->task[ii]->ofname, \"/dev/null\")==0) {\n\t\t\tof_num_devnull++;\n\t\t}\n\n\t\tif (job->task[ii]->efname == NULL) {\n\t\t\tef_num_null++;\n\t\t\tef_lastnull = ii;\n\t\t} else if (xstrcmp(job->task[ii]->efname, \"/dev/null\")==0) {\n\t\t\tef_num_devnull++;\n\t\t}\n\t}\n\tif (of_num_null == job->node_tasks)\n\t\t*outpattern = SLURMD_ALL_NULL;\n\n\tif (ef_num_null == job->node_tasks)\n\t\t*errpattern = SLURMD_ALL_NULL;\n\n\tif (of_num_null == 1 && of_num_devnull == job->node_tasks-1)\n\t\t*outpattern = SLURMD_ONE_NULL;\n\n\tif (ef_num_null == 1 && ef_num_devnull == job->node_tasks-1)\n\t\t*errpattern = SLURMD_ONE_NULL;\n\n\tif (*outpattern == SLURMD_ALL_NULL && *errpattern == SLURMD_ALL_NULL)\n\t\t*same_out_err_files = true;\n\n\tif (*outpattern == SLURMD_ONE_NULL && *errpattern == SLURMD_ONE_NULL &&\n\t    of_lastnull == ef_lastnull)\n\t\t*same_out_err_files = true;\n\n\tif (*outpattern != SLURMD_UNKNOWN && *errpattern != SLURMD_UNKNOWN)\n\t\treturn;\n\n\tfor (ii = 1; ii < job->node_tasks; ii++) {\n\t\tif (!job->task[ii]->ofname || !job->task[0]->ofname ||\n\t\t    xstrcmp(job->task[ii]->ofname, job->task[0]->ofname) != 0)\n\t\t\tof_all_same = false;\n\n\t\tif (!job->task[ii]->efname || !job->task[0]->efname ||\n\t\t    xstrcmp(job->task[ii]->efname, job->task[0]->efname) != 0)\n\t\t\tef_all_same = false;\n\t}\n\n\tif (of_all_same && *outpattern == SLURMD_UNKNOWN)\n\t\t*outpattern = SLURMD_ALL_SAME;\n\n\tif (ef_all_same && *errpattern == SLURMD_UNKNOWN)\n\t\t*errpattern = SLURMD_ALL_SAME;\n\n\tif (job->task[0]->ofname && job->task[0]->efname &&\n\t    xstrcmp(job->task[0]->ofname, job->task[0]->efname)==0)\n\t\t*same_out_err_files = true;\n\n\tif (*outpattern != SLURMD_UNKNOWN && *errpattern != SLURMD_UNKNOWN)\n\t\treturn;\n\n\tfor (ii = 0; ii < job->node_tasks-1; ii++) {\n\t\tfor (jj = ii+1; jj < job->node_tasks; jj++) {\n\n\t\t\tif (!job->task[ii]->ofname || !job->task[jj]->ofname ||\n\t\t\t    xstrcmp(job->task[ii]->ofname,\n\t\t\t\t    job->task[jj]->ofname) == 0)\n\t\t\t\tof_all_unique = false;\n\n\t\t\tif (!job->task[ii]->efname || !job->task[jj]->efname ||\n\t\t\t    xstrcmp(job->task[ii]->efname,\n\t\t\t\t    job->task[jj]->efname) == 0)\n\t\t\t\tef_all_unique = false;\n\t\t}\n\t}\n\n\tif (of_all_unique)\n\t\t*outpattern = SLURMD_ALL_UNIQUE;\n\n\tif (ef_all_unique)\n\t\t*errpattern = SLURMD_ALL_UNIQUE;\n\n\tif (of_all_unique && ef_all_unique) {\n\t\t*same_out_err_files = true;\n\t\tfor (ii = 0; ii < job->node_tasks; ii++) {\n\t\t\tif (job->task[ii]->ofname &&\n\t\t\t    job->task[ii]->efname &&\n\t\t\t    xstrcmp(job->task[ii]->ofname,\n\t\t\t\t    job->task[ii]->efname) != 0) {\n\t\t\t\t*same_out_err_files = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "user_managed_io_client_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1957-1978",
    "snippet": "int\nuser_managed_io_client_connect(int node_tasks, srun_info_t *srun,\n\t\t\t       stepd_step_task_info_t **tasks)\n{\n\tint fd;\n\tint i;\n\n\tfor (i = 0; i < node_tasks; i++) {\n\t\tfd = _user_managed_io_connect(srun, tasks[i]->gtid);\n\t\tif (fd == -1)\n\t\t\treturn SLURM_ERROR;\n\t\tfd_set_close_on_exec(fd);\n\t\ttasks[i]->stdin_fd = fd;\n\t\ttasks[i]->to_stdin = -1;\n\t\ttasks[i]->stdout_fd = fd;\n\t\ttasks[i]->from_stdout = -1;\n\t\ttasks[i]->stderr_fd = fd;\n\t\ttasks[i]->from_stderr = -1;\n\t}\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_set_close_on_exec",
          "args": [
            "fd"
          ],
          "line": 1968
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_user_managed_io_connect",
          "args": [
            "srun",
            "tasks[i]->gtid"
          ],
          "line": 1965
        },
        "resolved": true,
        "details": {
          "function_name": "_user_managed_io_connect",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1927-1950",
          "snippet": "static int\n_user_managed_io_connect(srun_info_t *srun, uint32_t gtid)\n{\n\tint fd;\n\ttask_user_managed_io_msg_t user_io_msg;\n\tslurm_msg_t msg;\n\n\tslurm_msg_t_init(&msg);\n\tmsg.protocol_version = srun->protocol_version;\n\tmsg.msg_type = TASK_USER_MANAGED_IO_STREAM;\n\tmsg.data = &user_io_msg;\n\tuser_io_msg.task_id = gtid;\n\n\tfd = slurm_open_msg_conn(&srun->resp_addr);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tnet_set_keep_alive(fd);\n\tif (slurm_send_node_msg(fd, &msg) == -1) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int\n_user_managed_io_connect(srun_info_t *srun, uint32_t gtid)\n{\n\tint fd;\n\ttask_user_managed_io_msg_t user_io_msg;\n\tslurm_msg_t msg;\n\n\tslurm_msg_t_init(&msg);\n\tmsg.protocol_version = srun->protocol_version;\n\tmsg.msg_type = TASK_USER_MANAGED_IO_STREAM;\n\tmsg.data = &user_io_msg;\n\tuser_io_msg.task_id = gtid;\n\n\tfd = slurm_open_msg_conn(&srun->resp_addr);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tnet_set_keep_alive(fd);\n\tif (slurm_send_node_msg(fd, &msg) == -1) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nint\nuser_managed_io_client_connect(int node_tasks, srun_info_t *srun,\n\t\t\t       stepd_step_task_info_t **tasks)\n{\n\tint fd;\n\tint i;\n\n\tfor (i = 0; i < node_tasks; i++) {\n\t\tfd = _user_managed_io_connect(srun, tasks[i]->gtid);\n\t\tif (fd == -1)\n\t\t\treturn SLURM_ERROR;\n\t\tfd_set_close_on_exec(fd);\n\t\ttasks[i]->stdin_fd = fd;\n\t\ttasks[i]->to_stdin = -1;\n\t\ttasks[i]->stdout_fd = fd;\n\t\ttasks[i]->from_stdout = -1;\n\t\ttasks[i]->stderr_fd = fd;\n\t\ttasks[i]->from_stderr = -1;\n\t}\n\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "_user_managed_io_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1927-1950",
    "snippet": "static int\n_user_managed_io_connect(srun_info_t *srun, uint32_t gtid)\n{\n\tint fd;\n\ttask_user_managed_io_msg_t user_io_msg;\n\tslurm_msg_t msg;\n\n\tslurm_msg_t_init(&msg);\n\tmsg.protocol_version = srun->protocol_version;\n\tmsg.msg_type = TASK_USER_MANAGED_IO_STREAM;\n\tmsg.data = &user_io_msg;\n\tuser_io_msg.task_id = gtid;\n\n\tfd = slurm_open_msg_conn(&srun->resp_addr);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tnet_set_keep_alive(fd);\n\tif (slurm_send_node_msg(fd, &msg) == -1) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 1946
        },
        "resolved": true,
        "details": {
          "function_name": "io_close_local_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1463-1487",
          "snippet": "void\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static bool _task_writable(eio_obj_t *);",
            "static bool _task_readable(eio_obj_t *);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void *_io_thr(void *arg);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nvoid\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}"
        }
      },
      {
        "call_info": {
          "callee": "slurm_send_node_msg",
          "args": [
            "fd",
            "&msg"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "net_set_keep_alive",
          "args": [
            "fd"
          ],
          "line": 1944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_open_msg_conn",
          "args": [
            "&srun->resp_addr"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_msg_t_init",
          "args": [
            "&msg"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int\n_user_managed_io_connect(srun_info_t *srun, uint32_t gtid)\n{\n\tint fd;\n\ttask_user_managed_io_msg_t user_io_msg;\n\tslurm_msg_t msg;\n\n\tslurm_msg_t_init(&msg);\n\tmsg.protocol_version = srun->protocol_version;\n\tmsg.msg_type = TASK_USER_MANAGED_IO_STREAM;\n\tmsg.data = &user_io_msg;\n\tuser_io_msg.task_id = gtid;\n\n\tfd = slurm_open_msg_conn(&srun->resp_addr);\n\tif (fd == -1)\n\t\treturn -1;\n\n\tnet_set_keep_alive(fd);\n\tif (slurm_send_node_msg(fd, &msg) == -1) {\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\treturn fd;\n}"
  },
  {
    "function_name": "_outgoing_buf_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1905-1922",
    "snippet": "static bool\n_outgoing_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_outgoing) > 0) {\n\t\treturn true;\n\t} else if (job->outgoing_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_outgoing, buf);\n\t\t\tjob->outgoing_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "job->free_outgoing",
            "buf"
          ],
          "line": 1915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_io_buf",
          "args": [],
          "line": 1913
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_io_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1854-1873",
          "snippet": "struct io_buf *\nalloc_io_buf(void)\n{\n\tstruct io_buf *buf;\n\n\tbuf = (struct io_buf *)xmalloc(sizeof(struct io_buf));\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->ref_count = 0;\n\tbuf->length = 0;\n\t/* The following \"+ 1\" is just temporary so I can stick a \\0 at\n\t   the end and do a printf of the data pointer */\n\tbuf->data = xmalloc(MAX_MSG_LEN + io_hdr_packed_size() + 1);\n\tif (!buf->data) {\n\t\txfree(buf);\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstruct io_buf *\nalloc_io_buf(void)\n{\n\tstruct io_buf *buf;\n\n\tbuf = (struct io_buf *)xmalloc(sizeof(struct io_buf));\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->ref_count = 0;\n\tbuf->length = 0;\n\t/* The following \"+ 1\" is just temporary so I can stick a \\0 at\n\t   the end and do a printf of the data pointer */\n\tbuf->data = xmalloc(MAX_MSG_LEN + io_hdr_packed_size() + 1);\n\tif (!buf->data) {\n\t\txfree(buf);\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_count",
          "args": [
            "job->free_outgoing"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic bool\n_outgoing_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_outgoing) > 0) {\n\t\treturn true;\n\t} else if (job->outgoing_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_outgoing, buf);\n\t\t\tjob->outgoing_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "_incoming_buf_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1886-1903",
    "snippet": "static bool\n_incoming_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_incoming) > 0) {\n\t\treturn true;\n\t} else if (job->incoming_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_incoming, buf);\n\t\t\tjob->incoming_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "job->free_incoming",
            "buf"
          ],
          "line": 1896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_io_buf",
          "args": [],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_io_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1854-1873",
          "snippet": "struct io_buf *\nalloc_io_buf(void)\n{\n\tstruct io_buf *buf;\n\n\tbuf = (struct io_buf *)xmalloc(sizeof(struct io_buf));\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->ref_count = 0;\n\tbuf->length = 0;\n\t/* The following \"+ 1\" is just temporary so I can stick a \\0 at\n\t   the end and do a printf of the data pointer */\n\tbuf->data = xmalloc(MAX_MSG_LEN + io_hdr_packed_size() + 1);\n\tif (!buf->data) {\n\t\txfree(buf);\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstruct io_buf *\nalloc_io_buf(void)\n{\n\tstruct io_buf *buf;\n\n\tbuf = (struct io_buf *)xmalloc(sizeof(struct io_buf));\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->ref_count = 0;\n\tbuf->length = 0;\n\t/* The following \"+ 1\" is just temporary so I can stick a \\0 at\n\t   the end and do a printf of the data pointer */\n\tbuf->data = xmalloc(MAX_MSG_LEN + io_hdr_packed_size() + 1);\n\tif (!buf->data) {\n\t\txfree(buf);\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_count",
          "args": [
            "job->free_incoming"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic bool\n_incoming_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_incoming) > 0) {\n\t\treturn true;\n\t} else if (job->incoming_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_incoming, buf);\n\t\t\tjob->incoming_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "free_io_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1875-1883",
    "snippet": "void\nfree_io_buf(struct io_buf *buf)\n{\n\tif (buf) {\n\t\tif (buf->data)\n\t\t\txfree(buf->data);\n\t\txfree(buf);\n\t}\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "buf"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nvoid\nfree_io_buf(struct io_buf *buf)\n{\n\tif (buf) {\n\t\tif (buf->data)\n\t\t\txfree(buf->data);\n\t\txfree(buf);\n\t}\n}"
  },
  {
    "function_name": "alloc_io_buf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1854-1873",
    "snippet": "struct io_buf *\nalloc_io_buf(void)\n{\n\tstruct io_buf *buf;\n\n\tbuf = (struct io_buf *)xmalloc(sizeof(struct io_buf));\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->ref_count = 0;\n\tbuf->length = 0;\n\t/* The following \"+ 1\" is just temporary so I can stick a \\0 at\n\t   the end and do a printf of the data pointer */\n\tbuf->data = xmalloc(MAX_MSG_LEN + io_hdr_packed_size() + 1);\n\tif (!buf->data) {\n\t\txfree(buf);\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xfree",
          "args": [
            "buf"
          ],
          "line": 1868
        },
        "resolved": true,
        "details": {
          "function_name": "_xfree_f",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "167-170",
          "snippet": "static void _xfree_f (void *x)\n{\n\txfree (x);\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic void _xfree_f (void *x)\n{\n\txfree (x);\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "MAX_MSG_LEN + io_hdr_packed_size() + 1"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_packed_size",
          "args": [],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(struct io_buf)"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstruct io_buf *\nalloc_io_buf(void)\n{\n\tstruct io_buf *buf;\n\n\tbuf = (struct io_buf *)xmalloc(sizeof(struct io_buf));\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->ref_count = 0;\n\tbuf->length = 0;\n\t/* The following \"+ 1\" is just temporary so I can stick a \\0 at\n\t   the end and do a printf of the data pointer */\n\tbuf->data = xmalloc(MAX_MSG_LEN + io_hdr_packed_size() + 1);\n\tif (!buf->data) {\n\t\txfree(buf);\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
  },
  {
    "function_name": "_task_build_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1812-1852",
    "snippet": "static struct io_buf *\n_task_build_message(struct task_read_info *out, stepd_step_rec_t *job, cbuf_t cbuf)\n{\n\tstruct io_buf *msg;\n\tchar *ptr;\n\tBuf packbuf;\n\tstruct slurm_io_header header;\n\tint n;\n\n\tdebug4(\"%s: Entering...\", __func__);\n\n\tif (_outgoing_buf_free(job)) {\n\t\tmsg = list_dequeue(job->free_outgoing);\n\t} else {\n\t\treturn NULL;\n\t}\n\n\tptr = msg->data + io_hdr_packed_size();\n\tn = cbuf_read(cbuf, ptr, MAX_MSG_LEN);\n\theader.type = out->type;\n\theader.ltaskid = out->ltaskid;\n\theader.gtaskid = out->gtaskid;\n\theader.length = n;\n\n\tdebug4(\"%s: header.length %d\", __func__, n);\n\tpackbuf = create_buf(msg->data, io_hdr_packed_size());\n\tif (!packbuf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn msg;\t/* Fix for CLANG false positive error */\n\t}\n\tio_hdr_pack(&header, packbuf);\n\tmsg->length = io_hdr_packed_size() + header.length;\n\tmsg->ref_count = 0; /* make certain it is initialized */\n\n\t/* free the Buf packbuf, but not the memory to which it points */\n\tpackbuf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(packbuf);\n\n\tdebug4(\"%s: Leaving...\", __func__);\n\treturn msg;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _send_eof_msg(struct task_read_info *out);",
      "static struct io_buf *_task_build_message(struct task_read_info *out,\n\t\t\t\t\t  stepd_step_rec_t *job, cbuf_t cbuf);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"%s: Leaving...\"",
            "__func__"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buf",
          "args": [
            "packbuf"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_packed_size",
          "args": [],
          "line": 1843
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_pack",
          "args": [
            "&header",
            "packbuf"
          ],
          "line": 1842
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Failure to allocate memory for a message header\""
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_buf",
          "args": [
            "msg->data",
            "io_hdr_packed_size()"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_packed_size",
          "args": [],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"%s: header.length %d\"",
            "__func__",
            "n"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbuf_read",
          "args": [
            "cbuf",
            "ptr",
            "MAX_MSG_LEN"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_packed_size",
          "args": [],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_dequeue",
          "args": [
            "job->free_outgoing"
          ],
          "line": 1824
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_outgoing_buf_free",
          "args": [
            "job"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "_outgoing_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1905-1922",
          "snippet": "static bool\n_outgoing_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_outgoing) > 0) {\n\t\treturn true;\n\t} else if (job->outgoing_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_outgoing, buf);\n\t\t\tjob->outgoing_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic bool\n_outgoing_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_outgoing) > 0) {\n\t\treturn true;\n\t} else if (job->outgoing_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_outgoing, buf);\n\t\t\tjob->outgoing_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"%s: Entering...\"",
            "__func__"
          ],
          "line": 1821
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic struct io_buf *_task_build_message(struct task_read_info *out,\n\t\t\t\t\t  stepd_step_rec_t *job, cbuf_t cbuf);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic struct io_buf *\n_task_build_message(struct task_read_info *out, stepd_step_rec_t *job, cbuf_t cbuf)\n{\n\tstruct io_buf *msg;\n\tchar *ptr;\n\tBuf packbuf;\n\tstruct slurm_io_header header;\n\tint n;\n\n\tdebug4(\"%s: Entering...\", __func__);\n\n\tif (_outgoing_buf_free(job)) {\n\t\tmsg = list_dequeue(job->free_outgoing);\n\t} else {\n\t\treturn NULL;\n\t}\n\n\tptr = msg->data + io_hdr_packed_size();\n\tn = cbuf_read(cbuf, ptr, MAX_MSG_LEN);\n\theader.type = out->type;\n\theader.ltaskid = out->ltaskid;\n\theader.gtaskid = out->gtaskid;\n\theader.length = n;\n\n\tdebug4(\"%s: header.length %d\", __func__, n);\n\tpackbuf = create_buf(msg->data, io_hdr_packed_size());\n\tif (!packbuf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn msg;\t/* Fix for CLANG false positive error */\n\t}\n\tio_hdr_pack(&header, packbuf);\n\tmsg->length = io_hdr_packed_size() + header.length;\n\tmsg->ref_count = 0; /* make certain it is initialized */\n\n\t/* free the Buf packbuf, but not the memory to which it points */\n\tpackbuf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(packbuf);\n\n\tdebug4(\"%s: Leaving...\", __func__);\n\treturn msg;\n}"
  },
  {
    "function_name": "_send_eof_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1748-1808",
    "snippet": "static void\n_send_eof_msg(struct task_read_info *out)\n{\n\tstruct client_io_info *client;\n\tstruct io_buf *msg = NULL;\n\teio_obj_t *eio;\n\tListIterator clients;\n\tstruct slurm_io_header header;\n\tBuf packbuf;\n\n\tdebug4(\"Entering _send_eof_msg\");\n\tout->eof_msg_sent = true;\n\n\tif (_outgoing_buf_free(out->job)) {\n\t\tmsg = list_dequeue(out->job->free_outgoing);\n\t} else {\n\t\t/* eof message must be allowed to allocate new memory\n\t\t   because _task_readable() will return \"true\" until\n\t\t   the eof message is enqueued.  For instance, if\n\t\t   a poll returns POLLHUP on the incoming task pipe,\n\t\t   put there are no outgoing message buffers available,\n\t\t   the slurmstepd will start spinning. */\n\t\tmsg = alloc_io_buf();\n\t}\n\n\theader.type = out->type;\n\theader.ltaskid = out->ltaskid;\n\theader.gtaskid = out->gtaskid;\n\theader.length = 0; /* eof */\n\n\tpackbuf = create_buf(msg->data, io_hdr_packed_size());\n\tif (!packbuf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn;\t/* Fix for CLANG false positive error */\n\t}\n\n\tio_hdr_pack(&header, packbuf);\n\tmsg->length = io_hdr_packed_size() + header.length;\n\tmsg->ref_count = 0; /* make certain it is initialized */\n\n\t/* free the Buf packbuf, but not the memory to which it points */\n\tpackbuf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(packbuf);\n\n\t/* Add eof message to the msg_queue of all clients */\n\tclients = list_iterator_create(out->job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tdebug5(\"======================== Enqueued eof message\");\n\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\t\t/* Send eof message to all clients.\n\t\t */\n\n\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\tmsg->ref_count++;\n\t}\n\tlist_iterator_destroy(clients);\n\n\tdebug4(\"Leaving  _send_eof_msg\");\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define CLIENT_IO_MAGIC  0x10102"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static bool _task_writable(eio_obj_t *);",
      "static bool _task_readable(eio_obj_t *);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _send_eof_msg(struct task_read_info *out);",
      "static void *_io_thr(void *arg);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"Leaving  _send_eof_msg\""
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_iterator_destroy",
          "args": [
            "clients"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "client->msg_queue",
            "msg"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "client->magic == CLIENT_IO_MAGIC"
          ],
          "line": 1797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"======================== Enqueued eof message\""
          ],
          "line": 1796
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next",
          "args": [
            "clients"
          ],
          "line": 1794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_iterator_create",
          "args": [
            "out->job->clients"
          ],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buf",
          "args": [
            "packbuf"
          ],
          "line": 1790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_packed_size",
          "args": [],
          "line": 1785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_pack",
          "args": [
            "&header",
            "packbuf"
          ],
          "line": 1784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Failure to allocate memory for a message header\""
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_buf",
          "args": [
            "msg->data",
            "io_hdr_packed_size()"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_packed_size",
          "args": [],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_io_buf",
          "args": [],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_io_buf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1854-1873",
          "snippet": "struct io_buf *\nalloc_io_buf(void)\n{\n\tstruct io_buf *buf;\n\n\tbuf = (struct io_buf *)xmalloc(sizeof(struct io_buf));\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->ref_count = 0;\n\tbuf->length = 0;\n\t/* The following \"+ 1\" is just temporary so I can stick a \\0 at\n\t   the end and do a printf of the data pointer */\n\tbuf->data = xmalloc(MAX_MSG_LEN + io_hdr_packed_size() + 1);\n\tif (!buf->data) {\n\t\txfree(buf);\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstruct io_buf *\nalloc_io_buf(void)\n{\n\tstruct io_buf *buf;\n\n\tbuf = (struct io_buf *)xmalloc(sizeof(struct io_buf));\n\tif (!buf)\n\t\treturn NULL;\n\tbuf->ref_count = 0;\n\tbuf->length = 0;\n\t/* The following \"+ 1\" is just temporary so I can stick a \\0 at\n\t   the end and do a printf of the data pointer */\n\tbuf->data = xmalloc(MAX_MSG_LEN + io_hdr_packed_size() + 1);\n\tif (!buf->data) {\n\t\txfree(buf);\n\t\treturn NULL;\n\t}\n\n\treturn buf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_dequeue",
          "args": [
            "out->job->free_outgoing"
          ],
          "line": 1762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_outgoing_buf_free",
          "args": [
            "out->job"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "_outgoing_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1905-1922",
          "snippet": "static bool\n_outgoing_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_outgoing) > 0) {\n\t\treturn true;\n\t} else if (job->outgoing_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_outgoing, buf);\n\t\t\tjob->outgoing_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic bool\n_outgoing_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_outgoing) > 0) {\n\t\treturn true;\n\t} else if (job->outgoing_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_outgoing, buf);\n\t\t\tjob->outgoing_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"Entering _send_eof_msg\""
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void *_io_thr(void *arg);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_send_eof_msg(struct task_read_info *out)\n{\n\tstruct client_io_info *client;\n\tstruct io_buf *msg = NULL;\n\teio_obj_t *eio;\n\tListIterator clients;\n\tstruct slurm_io_header header;\n\tBuf packbuf;\n\n\tdebug4(\"Entering _send_eof_msg\");\n\tout->eof_msg_sent = true;\n\n\tif (_outgoing_buf_free(out->job)) {\n\t\tmsg = list_dequeue(out->job->free_outgoing);\n\t} else {\n\t\t/* eof message must be allowed to allocate new memory\n\t\t   because _task_readable() will return \"true\" until\n\t\t   the eof message is enqueued.  For instance, if\n\t\t   a poll returns POLLHUP on the incoming task pipe,\n\t\t   put there are no outgoing message buffers available,\n\t\t   the slurmstepd will start spinning. */\n\t\tmsg = alloc_io_buf();\n\t}\n\n\theader.type = out->type;\n\theader.ltaskid = out->ltaskid;\n\theader.gtaskid = out->gtaskid;\n\theader.length = 0; /* eof */\n\n\tpackbuf = create_buf(msg->data, io_hdr_packed_size());\n\tif (!packbuf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn;\t/* Fix for CLANG false positive error */\n\t}\n\n\tio_hdr_pack(&header, packbuf);\n\tmsg->length = io_hdr_packed_size() + header.length;\n\tmsg->ref_count = 0; /* make certain it is initialized */\n\n\t/* free the Buf packbuf, but not the memory to which it points */\n\tpackbuf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(packbuf);\n\n\t/* Add eof message to the msg_queue of all clients */\n\tclients = list_iterator_create(out->job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tdebug5(\"======================== Enqueued eof message\");\n\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\t\t/* Send eof message to all clients.\n\t\t */\n\n\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\tmsg->ref_count++;\n\t}\n\tlist_iterator_destroy(clients);\n\n\tdebug4(\"Leaving  _send_eof_msg\");\n}"
  },
  {
    "function_name": "io_dup_stdio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1724-1746",
    "snippet": "int\nio_dup_stdio(stepd_step_task_info_t *t)\n{\n\tif (dup2(t->stdin_fd, STDIN_FILENO  ) < 0) {\n\t\terror(\"dup2(stdin): %m\");\n\t\treturn SLURM_FAILURE;\n\t}\n\tfd_set_noclose_on_exec(STDIN_FILENO);\n\n\tif (dup2(t->stdout_fd, STDOUT_FILENO) < 0) {\n\t\terror(\"dup2(stdout): %m\");\n\t\treturn SLURM_FAILURE;\n\t}\n\tfd_set_noclose_on_exec(STDOUT_FILENO);\n\n\tif (dup2(t->stderr_fd, STDERR_FILENO) < 0) {\n\t\terror(\"dup2(stderr): %m\");\n\t\treturn SLURM_FAILURE;\n\t}\n\tfd_set_noclose_on_exec(STDERR_FILENO);\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fd_set_noclose_on_exec",
          "args": [
            "STDERR_FILENO"
          ],
          "line": 1743
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"dup2(stderr): %m\""
          ],
          "line": 1740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "t->stderr_fd",
            "STDERR_FILENO"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_noclose_on_exec",
          "args": [
            "STDOUT_FILENO"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"dup2(stdout): %m\""
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "t->stdout_fd",
            "STDOUT_FILENO"
          ],
          "line": 1733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_noclose_on_exec",
          "args": [
            "STDIN_FILENO"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"dup2(stdin): %m\""
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "t->stdin_fd",
            "STDIN_FILENO"
          ],
          "line": 1727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nint\nio_dup_stdio(stepd_step_task_info_t *t)\n{\n\tif (dup2(t->stdin_fd, STDIN_FILENO  ) < 0) {\n\t\terror(\"dup2(stdin): %m\");\n\t\treturn SLURM_FAILURE;\n\t}\n\tfd_set_noclose_on_exec(STDIN_FILENO);\n\n\tif (dup2(t->stdout_fd, STDOUT_FILENO) < 0) {\n\t\terror(\"dup2(stdout): %m\");\n\t\treturn SLURM_FAILURE;\n\t}\n\tfd_set_noclose_on_exec(STDOUT_FILENO);\n\n\tif (dup2(t->stderr_fd, STDERR_FILENO) < 0) {\n\t\terror(\"dup2(stderr): %m\");\n\t\treturn SLURM_FAILURE;\n\t}\n\tfd_set_noclose_on_exec(STDERR_FILENO);\n\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "_send_io_init_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1693-1716",
    "snippet": "static int\n_send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job)\n{\n\tstruct slurm_io_init_msg msg;\n\n\tmemcpy(msg.cred_signature, key->data, SLURM_IO_KEY_SIZE);\n\tmsg.nodeid = job->nodeid;\n\tif (job->stdout_eio_objs == NULL)\n\t\tmsg.stdout_objs = 0;\n\telse\n\t\tmsg.stdout_objs = list_count(job->stdout_eio_objs);\n\tif (job->stderr_eio_objs == NULL)\n\t\tmsg.stderr_objs = 0;\n\telse\n\t\tmsg.stderr_objs = list_count(job->stderr_eio_objs);\n\n\tif (io_init_msg_write_to_fd(sock, &msg) != SLURM_SUCCESS) {\n\t\terror(\"Couldn't sent slurm_io_init_msg\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Couldn't sent slurm_io_init_msg\""
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_init_msg_write_to_fd",
          "args": [
            "sock",
            "&msg"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_count",
          "args": [
            "job->stderr_eio_objs"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_count",
          "args": [
            "job->stdout_eio_objs"
          ],
          "line": 1703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "msg.cred_signature",
            "key->data",
            "SLURM_IO_KEY_SIZE"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic int\n_send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job)\n{\n\tstruct slurm_io_init_msg msg;\n\n\tmemcpy(msg.cred_signature, key->data, SLURM_IO_KEY_SIZE);\n\tmsg.nodeid = job->nodeid;\n\tif (job->stdout_eio_objs == NULL)\n\t\tmsg.stdout_objs = 0;\n\telse\n\t\tmsg.stdout_objs = list_count(job->stdout_eio_objs);\n\tif (job->stderr_eio_objs == NULL)\n\t\tmsg.stderr_objs = 0;\n\telse\n\t\tmsg.stderr_objs = list_count(job->stderr_eio_objs);\n\n\tif (io_init_msg_write_to_fd(sock, &msg) != SLURM_SUCCESS) {\n\t\terror(\"Couldn't sent slurm_io_init_msg\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "io_client_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1637-1691",
    "snippet": "int\nio_client_connect(srun_info_t *srun, stepd_step_rec_t *job)\n{\n\tint sock = -1;\n\tstruct client_io_info *client;\n\teio_obj_t *obj;\n\n\tdebug4 (\"adding IO connection (logical node rank %d)\", job->nodeid);\n\n\tif (srun->ioaddr.sin_addr.s_addr) {\n\t\tchar         ip[256];\n\t\tuint16_t     port;\n\t\tslurm_get_ip_str(&srun->ioaddr, &port, ip, sizeof(ip));\n\t\tdebug4(\"connecting IO back to %s:%d\", ip, ntohs(port));\n\t}\n\n\tif ((sock = (int) slurm_open_stream(&srun->ioaddr, true)) < 0) {\n\t\terror(\"connect io: %m\");\n\t\t/* XXX retry or silently fail?\n\t\t *     fail for now.\n\t\t */\n\t\treturn SLURM_ERROR;\n\t}\n\n\tfd_set_blocking(sock);  /* just in case... */\n\n\t_send_io_init_msg(sock, srun->key, job);\n\n\tdebug5(\"  back from _send_io_init_msg\");\n\tfd_set_nonblocking(sock);\n\tfd_set_close_on_exec(sock);\n\n\t/* Now set up the eio object */\n\tclient = xmalloc(sizeof(struct client_io_info));\n#ifndef NDEBUG\n\tclient->magic = CLIENT_IO_MAGIC;\n#endif\n\tclient->job = job;\n\tclient->msg_queue = NULL; /* initialized in _client_writable */\n\n\tclient->ltaskid_stdout = -1;     /* accept from all tasks */\n\tclient->ltaskid_stderr = -1;     /* accept from all tasks */\n\tclient->labelio = false;\n\tclient->label_width = 0;\n\tclient->is_local_file = false;\n\n\t/* client object adds itself to job->clients in _client_writable */\n\n\tobj = eio_obj_create(sock, &client_ops, (void *)client);\n\teio_new_obj(job->eio, (void *)obj);\n\n\tdebug5(\"New IO Client object added\");\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define CLIENT_IO_MAGIC  0x10102"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "struct io_operations client_ops = {\n\t.readable = &_client_readable,\n\t.writable = &_client_writable,\n\t.handle_read = &_client_read,\n\t.handle_write = &_client_write,\n};",
      "static bool _local_file_writable(eio_obj_t *);",
      "static bool _task_writable(eio_obj_t *);",
      "static bool _task_readable(eio_obj_t *);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"New IO Client object added\""
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eio_new_obj",
          "args": [
            "job->eio",
            "(void *)obj"
          ],
          "line": 1686
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eio_obj_create",
          "args": [
            "sock",
            "&client_ops",
            "(void *)client"
          ],
          "line": 1685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(struct client_io_info)"
          ],
          "line": 1670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_close_on_exec",
          "args": [
            "sock"
          ],
          "line": 1667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_nonblocking",
          "args": [
            "sock"
          ],
          "line": 1666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  back from _send_io_init_msg\""
          ],
          "line": 1665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_send_io_init_msg",
          "args": [
            "sock",
            "srun->key",
            "job"
          ],
          "line": 1663
        },
        "resolved": true,
        "details": {
          "function_name": "_send_io_init_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1693-1716",
          "snippet": "static int\n_send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job)\n{\n\tstruct slurm_io_init_msg msg;\n\n\tmemcpy(msg.cred_signature, key->data, SLURM_IO_KEY_SIZE);\n\tmsg.nodeid = job->nodeid;\n\tif (job->stdout_eio_objs == NULL)\n\t\tmsg.stdout_objs = 0;\n\telse\n\t\tmsg.stdout_objs = list_count(job->stdout_eio_objs);\n\tif (job->stderr_eio_objs == NULL)\n\t\tmsg.stderr_objs = 0;\n\telse\n\t\tmsg.stderr_objs = list_count(job->stderr_eio_objs);\n\n\tif (io_init_msg_write_to_fd(sock, &msg) != SLURM_SUCCESS) {\n\t\terror(\"Couldn't sent slurm_io_init_msg\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic int\n_send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job)\n{\n\tstruct slurm_io_init_msg msg;\n\n\tmemcpy(msg.cred_signature, key->data, SLURM_IO_KEY_SIZE);\n\tmsg.nodeid = job->nodeid;\n\tif (job->stdout_eio_objs == NULL)\n\t\tmsg.stdout_objs = 0;\n\telse\n\t\tmsg.stdout_objs = list_count(job->stdout_eio_objs);\n\tif (job->stderr_eio_objs == NULL)\n\t\tmsg.stderr_objs = 0;\n\telse\n\t\tmsg.stderr_objs = list_count(job->stderr_eio_objs);\n\n\tif (io_init_msg_write_to_fd(sock, &msg) != SLURM_SUCCESS) {\n\t\terror(\"Couldn't sent slurm_io_init_msg\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_set_blocking",
          "args": [
            "sock"
          ],
          "line": 1661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"connect io: %m\""
          ],
          "line": 1654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_open_stream",
          "args": [
            "&srun->ioaddr",
            "true"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"connecting IO back to %s:%d\"",
            "ip",
            "ntohs(port)"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "port"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_get_ip_str",
          "args": [
            "&srun->ioaddr",
            "&port",
            "ip",
            "sizeof(ip)"
          ],
          "line": 1649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"adding IO connection (logical node rank %d)\"",
            "job->nodeid"
          ],
          "line": 1644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstruct io_operations client_ops = {\n\t.readable = &_client_readable,\n\t.writable = &_client_writable,\n\t.handle_read = &_client_read,\n\t.handle_write = &_client_write,\n};\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nint\nio_client_connect(srun_info_t *srun, stepd_step_rec_t *job)\n{\n\tint sock = -1;\n\tstruct client_io_info *client;\n\teio_obj_t *obj;\n\n\tdebug4 (\"adding IO connection (logical node rank %d)\", job->nodeid);\n\n\tif (srun->ioaddr.sin_addr.s_addr) {\n\t\tchar         ip[256];\n\t\tuint16_t     port;\n\t\tslurm_get_ip_str(&srun->ioaddr, &port, ip, sizeof(ip));\n\t\tdebug4(\"connecting IO back to %s:%d\", ip, ntohs(port));\n\t}\n\n\tif ((sock = (int) slurm_open_stream(&srun->ioaddr, true)) < 0) {\n\t\terror(\"connect io: %m\");\n\t\t/* XXX retry or silently fail?\n\t\t *     fail for now.\n\t\t */\n\t\treturn SLURM_ERROR;\n\t}\n\n\tfd_set_blocking(sock);  /* just in case... */\n\n\t_send_io_init_msg(sock, srun->key, job);\n\n\tdebug5(\"  back from _send_io_init_msg\");\n\tfd_set_nonblocking(sock);\n\tfd_set_close_on_exec(sock);\n\n\t/* Now set up the eio object */\n\tclient = xmalloc(sizeof(struct client_io_info));\n#ifndef NDEBUG\n\tclient->magic = CLIENT_IO_MAGIC;\n#endif\n\tclient->job = job;\n\tclient->msg_queue = NULL; /* initialized in _client_writable */\n\n\tclient->ltaskid_stdout = -1;     /* accept from all tasks */\n\tclient->ltaskid_stderr = -1;     /* accept from all tasks */\n\tclient->labelio = false;\n\tclient->label_width = 0;\n\tclient->is_local_file = false;\n\n\t/* client object adds itself to job->clients in _client_writable */\n\n\tobj = eio_obj_create(sock, &client_ops, (void *)client);\n\teio_new_obj(job->eio, (void *)obj);\n\n\tdebug5(\"New IO Client object added\");\n\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "io_initial_client_connect",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1572-1629",
    "snippet": "int\nio_initial_client_connect(srun_info_t *srun, stepd_step_rec_t *job,\n\t\t\t  int stdout_tasks, int stderr_tasks)\n{\n\tint sock = -1;\n\tstruct client_io_info *client;\n\teio_obj_t *obj;\n\n\tdebug4 (\"adding IO connection (logical node rank %d)\", job->nodeid);\n\n\tif (srun->ioaddr.sin_addr.s_addr) {\n\t\tchar         ip[256];\n\t\tuint16_t     port;\n\t\tslurm_get_ip_str(&srun->ioaddr, &port, ip, sizeof(ip));\n\t\tif (ntohs(port) == 0) {\n\t\t\tdebug3(\"No IO connection requested\");\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tdebug4(\"connecting IO back to %s:%d\", ip, ntohs(port));\n\t}\n\n\tif ((sock = (int) slurm_open_stream(&srun->ioaddr, true)) < 0) {\n\t\terror(\"connect io: %m\");\n\t\t/* XXX retry or silently fail?\n\t\t *     fail for now.\n\t\t */\n\t\treturn SLURM_ERROR;\n\t}\n\n\tfd_set_blocking(sock);  /* just in case... */\n\n\t_send_io_init_msg(sock, srun->key, job);\n\n\tdebug5(\"  back from _send_io_init_msg\");\n\tfd_set_nonblocking(sock);\n\tfd_set_close_on_exec(sock);\n\n\t/* Now set up the eio object */\n\tclient = xmalloc(sizeof(struct client_io_info));\n#ifndef NDEBUG\n\tclient->magic = CLIENT_IO_MAGIC;\n#endif\n\tclient->job = job;\n\tclient->msg_queue = list_create(NULL); /* FIXME - destructor */\n\n\tclient->ltaskid_stdout = stdout_tasks;\n\tclient->ltaskid_stderr = stderr_tasks;\n\tclient->labelio = false;\n\tclient->label_width = 0;\n\tclient->is_local_file = false;\n\n\tobj = eio_obj_create(sock, &client_ops, (void *)client);\n\tlist_append(job->clients, (void *)obj);\n\teio_new_initial_obj(job->eio, (void *)obj);\n\tdebug5(\"Now handling %d IO Client object(s)\", list_count(job->clients));\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define CLIENT_IO_MAGIC  0x10102"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "struct io_operations client_ops = {\n\t.readable = &_client_readable,\n\t.writable = &_client_writable,\n\t.handle_read = &_client_read,\n\t.handle_write = &_client_write,\n};",
      "static bool _local_file_writable(eio_obj_t *);",
      "static bool _task_writable(eio_obj_t *);",
      "static bool _task_readable(eio_obj_t *);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"Now handling %d IO Client object(s)\"",
            "list_count(job->clients)"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_count",
          "args": [
            "job->clients"
          ],
          "line": 1626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eio_new_initial_obj",
          "args": [
            "job->eio",
            "(void *)obj"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_append",
          "args": [
            "job->clients",
            "(void *)obj"
          ],
          "line": 1624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eio_obj_create",
          "args": [
            "sock",
            "&client_ops",
            "(void *)client"
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_create",
          "args": [
            "NULL"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "_script_list_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "178-210",
          "snippet": "static List _script_list_create (const char *pattern)\n{\n\tglob_t gl;\n\tsize_t i;\n\tList l = NULL;\n\n\tif (pattern == NULL)\n\t\treturn (NULL);\n\n\tint rc = glob (pattern, GLOB_ERR, _ef, &gl);\n\tswitch (rc) {\n\tcase 0:\n\t\tl = list_create ((ListDelF) _xfree_f);\n\t\tfor (i = 0; i < gl.gl_pathc; i++)\n\t\t\tlist_push (l, xstrdup (gl.gl_pathv[i]));\n\t\tbreak;\n\tcase GLOB_NOMATCH:\n\t\tbreak;\n\tcase GLOB_NOSPACE:\n\t\terror (\"run_script: glob(3): Out of memory\");\n\t\tbreak;\n\tcase GLOB_ABORTED:\n\t\terror (\"run_script: cannot read dir %s: %m\", pattern);\n\t\tbreak;\n\tdefault:\n\t\terror (\"Unknown glob(3) return code = %d\", rc);\n\t\tbreak;\n\t}\n\n\tglobfree (&gl);\n\n\treturn l;\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic List _script_list_create (const char *pattern)\n{\n\tglob_t gl;\n\tsize_t i;\n\tList l = NULL;\n\n\tif (pattern == NULL)\n\t\treturn (NULL);\n\n\tint rc = glob (pattern, GLOB_ERR, _ef, &gl);\n\tswitch (rc) {\n\tcase 0:\n\t\tl = list_create ((ListDelF) _xfree_f);\n\t\tfor (i = 0; i < gl.gl_pathc; i++)\n\t\t\tlist_push (l, xstrdup (gl.gl_pathv[i]));\n\t\tbreak;\n\tcase GLOB_NOMATCH:\n\t\tbreak;\n\tcase GLOB_NOSPACE:\n\t\terror (\"run_script: glob(3): Out of memory\");\n\t\tbreak;\n\tcase GLOB_ABORTED:\n\t\terror (\"run_script: cannot read dir %s: %m\", pattern);\n\t\tbreak;\n\tdefault:\n\t\terror (\"Unknown glob(3) return code = %d\", rc);\n\t\tbreak;\n\t}\n\n\tglobfree (&gl);\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(struct client_io_info)"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_close_on_exec",
          "args": [
            "sock"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_nonblocking",
          "args": [
            "sock"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  back from _send_io_init_msg\""
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_send_io_init_msg",
          "args": [
            "sock",
            "srun->key",
            "job"
          ],
          "line": 1603
        },
        "resolved": true,
        "details": {
          "function_name": "_send_io_init_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1693-1716",
          "snippet": "static int\n_send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job)\n{\n\tstruct slurm_io_init_msg msg;\n\n\tmemcpy(msg.cred_signature, key->data, SLURM_IO_KEY_SIZE);\n\tmsg.nodeid = job->nodeid;\n\tif (job->stdout_eio_objs == NULL)\n\t\tmsg.stdout_objs = 0;\n\telse\n\t\tmsg.stdout_objs = list_count(job->stdout_eio_objs);\n\tif (job->stderr_eio_objs == NULL)\n\t\tmsg.stderr_objs = 0;\n\telse\n\t\tmsg.stderr_objs = list_count(job->stderr_eio_objs);\n\n\tif (io_init_msg_write_to_fd(sock, &msg) != SLURM_SUCCESS) {\n\t\terror(\"Couldn't sent slurm_io_init_msg\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic int\n_send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job)\n{\n\tstruct slurm_io_init_msg msg;\n\n\tmemcpy(msg.cred_signature, key->data, SLURM_IO_KEY_SIZE);\n\tmsg.nodeid = job->nodeid;\n\tif (job->stdout_eio_objs == NULL)\n\t\tmsg.stdout_objs = 0;\n\telse\n\t\tmsg.stdout_objs = list_count(job->stdout_eio_objs);\n\tif (job->stderr_eio_objs == NULL)\n\t\tmsg.stderr_objs = 0;\n\telse\n\t\tmsg.stderr_objs = list_count(job->stderr_eio_objs);\n\n\tif (io_init_msg_write_to_fd(sock, &msg) != SLURM_SUCCESS) {\n\t\terror(\"Couldn't sent slurm_io_init_msg\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fd_set_blocking",
          "args": [
            "sock"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"connect io: %m\""
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_open_stream",
          "args": [
            "&srun->ioaddr",
            "true"
          ],
          "line": 1593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"connecting IO back to %s:%d\"",
            "ip",
            "ntohs(port)"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "port"
          ],
          "line": 1590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug3",
          "args": [
            "\"No IO connection requested\""
          ],
          "line": 1587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "port"
          ],
          "line": 1586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_get_ip_str",
          "args": [
            "&srun->ioaddr",
            "&port",
            "ip",
            "sizeof(ip)"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"adding IO connection (logical node rank %d)\"",
            "job->nodeid"
          ],
          "line": 1580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstruct io_operations client_ops = {\n\t.readable = &_client_readable,\n\t.writable = &_client_writable,\n\t.handle_read = &_client_read,\n\t.handle_write = &_client_write,\n};\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nint\nio_initial_client_connect(srun_info_t *srun, stepd_step_rec_t *job,\n\t\t\t  int stdout_tasks, int stderr_tasks)\n{\n\tint sock = -1;\n\tstruct client_io_info *client;\n\teio_obj_t *obj;\n\n\tdebug4 (\"adding IO connection (logical node rank %d)\", job->nodeid);\n\n\tif (srun->ioaddr.sin_addr.s_addr) {\n\t\tchar         ip[256];\n\t\tuint16_t     port;\n\t\tslurm_get_ip_str(&srun->ioaddr, &port, ip, sizeof(ip));\n\t\tif (ntohs(port) == 0) {\n\t\t\tdebug3(\"No IO connection requested\");\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tdebug4(\"connecting IO back to %s:%d\", ip, ntohs(port));\n\t}\n\n\tif ((sock = (int) slurm_open_stream(&srun->ioaddr, true)) < 0) {\n\t\terror(\"connect io: %m\");\n\t\t/* XXX retry or silently fail?\n\t\t *     fail for now.\n\t\t */\n\t\treturn SLURM_ERROR;\n\t}\n\n\tfd_set_blocking(sock);  /* just in case... */\n\n\t_send_io_init_msg(sock, srun->key, job);\n\n\tdebug5(\"  back from _send_io_init_msg\");\n\tfd_set_nonblocking(sock);\n\tfd_set_close_on_exec(sock);\n\n\t/* Now set up the eio object */\n\tclient = xmalloc(sizeof(struct client_io_info));\n#ifndef NDEBUG\n\tclient->magic = CLIENT_IO_MAGIC;\n#endif\n\tclient->job = job;\n\tclient->msg_queue = list_create(NULL); /* FIXME - destructor */\n\n\tclient->ltaskid_stdout = stdout_tasks;\n\tclient->ltaskid_stderr = stderr_tasks;\n\tclient->labelio = false;\n\tclient->label_width = 0;\n\tclient->is_local_file = false;\n\n\tobj = eio_obj_create(sock, &client_ops, (void *)client);\n\tlist_append(job->clients, (void *)obj);\n\teio_new_initial_obj(job->eio, (void *)obj);\n\tdebug5(\"Now handling %d IO Client object(s)\", list_count(job->clients));\n\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "io_create_local_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1519-1560",
    "snippet": "int\nio_create_local_client(const char *filename, int file_flags,\n\t\t       stepd_step_rec_t *job, bool labelio,\n\t\t       int stdout_tasks, int stderr_tasks)\n{\n\tint fd = -1;\n\tstruct client_io_info *client;\n\teio_obj_t *obj;\n\tint tmp;\n\n\tfd = open(filename, file_flags, 0666);\n\tif (fd == -1) {\n\t\treturn ESLURMD_IO_ERROR;\n\t}\n\tfd_set_close_on_exec(fd);\n\n\t/* Now set up the eio object */\n\tclient = xmalloc(sizeof(struct client_io_info));\n#ifndef NDEBUG\n\tclient->magic = CLIENT_IO_MAGIC;\n#endif\n\tclient->job = job;\n\tclient->msg_queue = list_create(NULL); /* FIXME - destructor */\n\n\tclient->ltaskid_stdout = stdout_tasks;\n\tclient->ltaskid_stderr = stderr_tasks;\n\tclient->labelio = labelio;\n\tclient->is_local_file = true;\n\n\tclient->label_width = 1;\n\ttmp = job->node_tasks-1;\n\twhile ((tmp /= 10) > 0)\n\t\tclient->label_width++;\n\n\n\tobj = eio_obj_create(fd, &local_file_ops, (void *)client);\n\tlist_append(job->clients, (void *)obj);\n\teio_new_initial_obj(job->eio, (void *)obj);\n\tdebug5(\"Now handling %d IO Client object(s)\", list_count(job->clients));\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define CLIENT_IO_MAGIC  0x10102"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static bool _local_file_writable(eio_obj_t *);",
      "struct io_operations local_file_ops = {\n\t.writable = &_local_file_writable,\n\t.handle_write = &_local_file_write,\n};",
      "static bool _task_writable(eio_obj_t *);",
      "static bool _task_readable(eio_obj_t *);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);",
      "int file_flags = io_get_file_flags(job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"Now handling %d IO Client object(s)\"",
            "list_count(job->clients)"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_count",
          "args": [
            "job->clients"
          ],
          "line": 1557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eio_new_initial_obj",
          "args": [
            "job->eio",
            "(void *)obj"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_append",
          "args": [
            "job->clients",
            "(void *)obj"
          ],
          "line": 1555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "eio_obj_create",
          "args": [
            "fd",
            "&local_file_ops",
            "(void *)client"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_create",
          "args": [
            "NULL"
          ],
          "line": 1541
        },
        "resolved": true,
        "details": {
          "function_name": "_script_list_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "178-210",
          "snippet": "static List _script_list_create (const char *pattern)\n{\n\tglob_t gl;\n\tsize_t i;\n\tList l = NULL;\n\n\tif (pattern == NULL)\n\t\treturn (NULL);\n\n\tint rc = glob (pattern, GLOB_ERR, _ef, &gl);\n\tswitch (rc) {\n\tcase 0:\n\t\tl = list_create ((ListDelF) _xfree_f);\n\t\tfor (i = 0; i < gl.gl_pathc; i++)\n\t\t\tlist_push (l, xstrdup (gl.gl_pathv[i]));\n\t\tbreak;\n\tcase GLOB_NOMATCH:\n\t\tbreak;\n\tcase GLOB_NOSPACE:\n\t\terror (\"run_script: glob(3): Out of memory\");\n\t\tbreak;\n\tcase GLOB_ABORTED:\n\t\terror (\"run_script: cannot read dir %s: %m\", pattern);\n\t\tbreak;\n\tdefault:\n\t\terror (\"Unknown glob(3) return code = %d\", rc);\n\t\tbreak;\n\t}\n\n\tglobfree (&gl);\n\n\treturn l;\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic List _script_list_create (const char *pattern)\n{\n\tglob_t gl;\n\tsize_t i;\n\tList l = NULL;\n\n\tif (pattern == NULL)\n\t\treturn (NULL);\n\n\tint rc = glob (pattern, GLOB_ERR, _ef, &gl);\n\tswitch (rc) {\n\tcase 0:\n\t\tl = list_create ((ListDelF) _xfree_f);\n\t\tfor (i = 0; i < gl.gl_pathc; i++)\n\t\t\tlist_push (l, xstrdup (gl.gl_pathv[i]));\n\t\tbreak;\n\tcase GLOB_NOMATCH:\n\t\tbreak;\n\tcase GLOB_NOSPACE:\n\t\terror (\"run_script: glob(3): Out of memory\");\n\t\tbreak;\n\tcase GLOB_ABORTED:\n\t\terror (\"run_script: cannot read dir %s: %m\", pattern);\n\t\tbreak;\n\tdefault:\n\t\terror (\"Unknown glob(3) return code = %d\", rc);\n\t\tbreak;\n\t}\n\n\tglobfree (&gl);\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(struct client_io_info)"
          ],
          "line": 1536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fd_set_close_on_exec",
          "args": [
            "fd"
          ],
          "line": 1533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "filename",
            "file_flags",
            "0666"
          ],
          "line": 1529
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstruct io_operations local_file_ops = {\n\t.writable = &_local_file_writable,\n\t.handle_write = &_local_file_write,\n};\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\nint file_flags = io_get_file_flags(job);\n\nint\nio_create_local_client(const char *filename, int file_flags,\n\t\t       stepd_step_rec_t *job, bool labelio,\n\t\t       int stdout_tasks, int stderr_tasks)\n{\n\tint fd = -1;\n\tstruct client_io_info *client;\n\teio_obj_t *obj;\n\tint tmp;\n\n\tfd = open(filename, file_flags, 0666);\n\tif (fd == -1) {\n\t\treturn ESLURMD_IO_ERROR;\n\t}\n\tfd_set_close_on_exec(fd);\n\n\t/* Now set up the eio object */\n\tclient = xmalloc(sizeof(struct client_io_info));\n#ifndef NDEBUG\n\tclient->magic = CLIENT_IO_MAGIC;\n#endif\n\tclient->job = job;\n\tclient->msg_queue = list_create(NULL); /* FIXME - destructor */\n\n\tclient->ltaskid_stdout = stdout_tasks;\n\tclient->ltaskid_stderr = stderr_tasks;\n\tclient->labelio = labelio;\n\tclient->is_local_file = true;\n\n\tclient->label_width = 1;\n\ttmp = job->node_tasks-1;\n\twhile ((tmp /= 10) > 0)\n\t\tclient->label_width++;\n\n\n\tobj = eio_obj_create(fd, &local_file_ops, (void *)client);\n\tlist_append(job->clients, (void *)obj);\n\teio_new_initial_obj(job->eio, (void *)obj);\n\tdebug5(\"Now handling %d IO Client object(s)\", list_count(job->clients));\n\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "_io_thr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1491-1511",
    "snippet": "static void *\n_io_thr(void *arg)\n{\n\tstepd_step_rec_t *job = (stepd_step_rec_t *) arg;\n\tsigset_t set;\n\tint rc;\n\n\t/* A SIGHUP signal signals a reattach to the mgr thread.  We need\n\t * to block SIGHUP from being delivered to this thread so the mgr\n\t * thread will see the signal.\n\t */\n\tsigemptyset(&set);\n\tsigaddset(&set, SIGHUP);\n\tsigaddset(&set, SIGPIPE);\n\tpthread_sigmask(SIG_BLOCK, &set, NULL);\n\n\tdebug(\"IO handler started pid=%lu\", (unsigned long) getpid());\n\trc = eio_handle_mainloop(job->eio);\n\tdebug(\"IO handler exited, rc=%d\", rc);\n\treturn (void *)1;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *_io_thr(void *);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void *_io_thr(void *arg);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"IO handler exited, rc=%d\"",
            "rc"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_wake_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "187-199",
          "snippet": "void pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid pdebug_wake_process(stepd_step_rec_t *job, pid_t pid)\n{\n\tif ((job->task_flags & TASK_PARALLEL_DEBUG) && (pid > (pid_t) 0)) {\n\t\tif (_pid_to_wake(pid)) {\n\t\t\tif (kill(pid, SIGCONT) < 0)\n\t\t\t\terror(\"kill(%lu): %m\", (unsigned long) pid);\n\t\t\telse\n\t\t\t\tdebug(\"woke pid %lu\", (unsigned long) pid);\n\t\t} else {\n\t\t\tdebug(\"pid %lu not stopped\", (unsigned long) pid);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "eio_handle_mainloop",
          "args": [
            "job->eio"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getpid",
          "args": [],
          "line": 1507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_sigmask",
          "args": [
            "SIG_BLOCK",
            "&set",
            "NULL"
          ],
          "line": 1505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&set",
            "SIGPIPE"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&set",
            "SIGHUP"
          ],
          "line": 1503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&set"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic void *_io_thr(void *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void *\n_io_thr(void *arg)\n{\n\tstepd_step_rec_t *job = (stepd_step_rec_t *) arg;\n\tsigset_t set;\n\tint rc;\n\n\t/* A SIGHUP signal signals a reattach to the mgr thread.  We need\n\t * to block SIGHUP from being delivered to this thread so the mgr\n\t * thread will see the signal.\n\t */\n\tsigemptyset(&set);\n\tsigaddset(&set, SIGHUP);\n\tsigaddset(&set, SIGPIPE);\n\tpthread_sigmask(SIG_BLOCK, &set, NULL);\n\n\tdebug(\"IO handler started pid=%lu\", (unsigned long) getpid());\n\trc = eio_handle_mainloop(job->eio);\n\tdebug(\"IO handler exited, rc=%d\", rc);\n\treturn (void *)1;\n}"
  },
  {
    "function_name": "io_close_local_fds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1463-1487",
    "snippet": "void\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static bool _task_writable(eio_obj_t *);",
      "static bool _task_readable(eio_obj_t *);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void *_io_thr(void *arg);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_iterator_destroy",
          "args": [
            "clients"
          ],
          "line": 1486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "eio->fd"
          ],
          "line": 1480
        },
        "resolved": true,
        "details": {
          "function_name": "io_close_local_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1463-1487",
          "snippet": "void\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "list_next",
          "args": [
            "clients"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_iterator_create",
          "args": [
            "job->clients"
          ],
          "line": 1474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nvoid\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}"
  },
  {
    "function_name": "io_close_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1432-1461",
    "snippet": "void\nio_close_all(stepd_step_rec_t *job)\n{\n\tint devnull;\n#if 0\n\tint i;\n\tfor (i = 0; i < job->node_tasks; i++)\n\t\t_io_finalize(job->task[i]);\n#endif\n\n\t/* No more debug info will be received by client after this point\n\t */\n\tdebug(\"Closing debug channel\");\n\n\t/*\n\t * Send stderr to /dev/null since debug channel is closing\n\t *  and log facility may still try to write to stderr.\n\t */\n\tif ((devnull = open(\"/dev/null\", O_RDWR)) < 0) {\n\t\terror(\"Could not open /dev/null: %m\");\n\t} else {\n\t\tif (dup2(devnull, STDERR_FILENO) < 0)\n\t\t\terror(\"Unable to dup /dev/null onto stderr\");\n\t}\n\n\t/* Signal IO thread to close appropriate\n\t * client connections\n\t */\n\teio_signal_shutdown(job->eio);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eio_signal_shutdown",
          "args": [
            "job->eio"
          ],
          "line": 1460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Unable to dup /dev/null onto stderr\""
          ],
          "line": 1454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dup2",
          "args": [
            "devnull",
            "STDERR_FILENO"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Could not open /dev/null: %m\""
          ],
          "line": 1451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "\"/dev/null\"",
            "O_RDWR"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"Closing debug channel\""
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "pdebug_stop_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/pdebug.c",
          "lines": "120-139",
          "snippet": "void\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}",
          "includes": [
            "#  include <linux/sched.h>",
            "#include <signal.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <fcntl.h>",
            "#include \"pdebug.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#  include <linux/sched.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"pdebug.h\"\n\nvoid\npdebug_stop_current(stepd_step_rec_t *job)\n{\n\t/*\n\t * Stop the task on exec for TotalView to connect\n\t */\n\tif ( (job->task_flags & TASK_PARALLEL_DEBUG)\n#ifdef BSD\n\t     && (_PTRACE(PT_TRACE_ME, 0, (caddr_t)0, 0) < 0) )\n#elif defined(PT_TRACE_ME)\n\t     && (_PTRACE(PT_TRACE_ME, 0, NULL, 0) < 0) )\n#elif defined(__sun)\n\t     && (_PTRACE(0, 0, NULL, 0) < 0))\n#elif defined(__CYGWIN__)\n\t     && 0)\n#else\n\t     && (_PTRACE(PTRACE_TRACEME, 0, NULL, 0) < 0) )\n#endif\n\t\terror(\"ptrace: %m\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "_io_finalize",
          "args": [
            "job->task[i]"
          ],
          "line": 1439
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nvoid\nio_close_all(stepd_step_rec_t *job)\n{\n\tint devnull;\n#if 0\n\tint i;\n\tfor (i = 0; i < job->node_tasks; i++)\n\t\t_io_finalize(job->task[i]);\n#endif\n\n\t/* No more debug info will be received by client after this point\n\t */\n\tdebug(\"Closing debug channel\");\n\n\t/*\n\t * Send stderr to /dev/null since debug channel is closing\n\t *  and log facility may still try to write to stderr.\n\t */\n\tif ((devnull = open(\"/dev/null\", O_RDWR)) < 0) {\n\t\terror(\"Could not open /dev/null: %m\");\n\t} else {\n\t\tif (dup2(devnull, STDERR_FILENO) < 0)\n\t\t\terror(\"Unable to dup /dev/null onto stderr\");\n\t}\n\n\t/* Signal IO thread to close appropriate\n\t * client connections\n\t */\n\teio_signal_shutdown(job->eio);\n}"
  },
  {
    "function_name": "io_close_task_fds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1420-1430",
    "snippet": "extern void\nio_close_task_fds(stepd_step_rec_t *job)\n{\n\tint i;\n\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tclose(job->task[i]->stdin_fd);\n\t\tclose(job->task[i]->stdout_fd);\n\t\tclose(job->task[i]->stderr_fd);\n\t}\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "job->task[i]->stderr_fd"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "io_close_local_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1463-1487",
          "snippet": "void\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static bool _task_writable(eio_obj_t *);",
            "static bool _task_readable(eio_obj_t *);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void *_io_thr(void *arg);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nvoid\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nextern void\nio_close_task_fds(stepd_step_rec_t *job)\n{\n\tint i;\n\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\tclose(job->task[i]->stdin_fd);\n\t\tclose(job->task[i]->stdout_fd);\n\t\tclose(job->task[i]->stderr_fd);\n\t}\n}"
  },
  {
    "function_name": "_free_all_outgoing_msgs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1405-1416",
    "snippet": "static void\n_free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job)\n{\n\tListIterator msgs;\n\tstruct io_buf *msg;\n\n\tmsgs = list_iterator_create(msg_queue);\n\twhile((msg = list_next(msgs))) {\n\t\t_free_outgoing_msg(msg, job);\n\t}\n\tlist_iterator_destroy(msgs);\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _client_read(eio_obj_t *, List);",
      "static int  _client_write(eio_obj_t *, List);",
      "static int  _local_file_write(eio_obj_t *, List);",
      "static int  _task_write(eio_obj_t *, List);",
      "static int  _task_read(eio_obj_t *, List);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_iterator_destroy",
          "args": [
            "msgs"
          ],
          "line": 1415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_free_outgoing_msg",
          "args": [
            "msg",
            "job"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "_free_outgoing_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1375-1403",
          "snippet": "static void\n_free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tint i;\n\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_outgoing, msg);\n\n\t\t/* Try packing messages from tasks' output cbufs */\n\t\tif (job->task == NULL)\n\t\t\treturn;\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i]->err != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->err);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (job->task[i]->out != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->out);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int  _task_read(eio_obj_t *, List);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _send_eof_msg(struct task_read_info *out);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tint i;\n\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_outgoing, msg);\n\n\t\t/* Try packing messages from tasks' output cbufs */\n\t\tif (job->task == NULL)\n\t\t\treturn;\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i]->err != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->err);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (job->task[i]->out != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->out);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_next",
          "args": [
            "msgs"
          ],
          "line": 1412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_iterator_create",
          "args": [
            "msg_queue"
          ],
          "line": 1411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job)\n{\n\tListIterator msgs;\n\tstruct io_buf *msg;\n\n\tmsgs = list_iterator_create(msg_queue);\n\twhile((msg = list_next(msgs))) {\n\t\t_free_outgoing_msg(msg, job);\n\t}\n\tlist_iterator_destroy(msgs);\n}"
  },
  {
    "function_name": "_free_outgoing_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1375-1403",
    "snippet": "static void\n_free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tint i;\n\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_outgoing, msg);\n\n\t\t/* Try packing messages from tasks' output cbufs */\n\t\tif (job->task == NULL)\n\t\t\treturn;\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i]->err != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->err);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (job->task[i]->out != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->out);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _client_read(eio_obj_t *, List);",
      "static int  _client_write(eio_obj_t *, List);",
      "static int  _local_file_write(eio_obj_t *, List);",
      "static int  _task_write(eio_obj_t *, List);",
      "static int  _task_read(eio_obj_t *, List);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _send_eof_msg(struct task_read_info *out);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eio_signal_wakeup",
          "args": [
            "job->eio"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_outgoing_buf_free",
          "args": [
            "job"
          ],
          "line": 1396
        },
        "resolved": true,
        "details": {
          "function_name": "_outgoing_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1905-1922",
          "snippet": "static bool\n_outgoing_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_outgoing) > 0) {\n\t\treturn true;\n\t} else if (job->outgoing_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_outgoing, buf);\n\t\t\tjob->outgoing_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic bool\n_outgoing_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_outgoing) > 0) {\n\t\treturn true;\n\t} else if (job->outgoing_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_outgoing, buf);\n\t\t\tjob->outgoing_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "_route_msg_task_to_client",
          "args": [
            "job->task[i]->out"
          ],
          "line": 1395
        },
        "resolved": true,
        "details": {
          "function_name": "_route_msg_task_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1311-1360",
          "snippet": "static void\n_route_msg_task_to_client(eio_obj_t *obj)\n{\n\tstruct task_read_info *out = (struct task_read_info *)obj->arg;\n\tstruct client_io_info *client;\n\tstruct io_buf *msg = NULL;\n\teio_obj_t *eio;\n\tListIterator clients;\n\n\t/* Pack task output into messages for transfer to a client */\n\twhile (cbuf_used(out->buf) > 0\n\t       && _outgoing_buf_free(out->job)) {\n\t\tdebug5(\"cbuf_used = %d\", cbuf_used(out->buf));\n\t\tmsg = _task_build_message(out, out->job, out->buf);\n\t\tif (msg == NULL)\n\t\t\treturn;\n\n\t\t/* Add message to the msg_queue of all clients */\n\t\tclients = list_iterator_create(out->job->clients);\n\t\twhile ((eio = list_next(clients))) {\n\t\t\tclient = (struct client_io_info *)eio->arg;\n\t\t\tif (client->out_eof == true)\n\t\t\t\tcontinue;\n\n\t\t\t/* Some clients only take certain I/O streams */\n\t\t\tif (out->type==SLURM_IO_STDOUT) {\n\t\t\t\tif (client->ltaskid_stdout != -1 &&\n\t\t\t\t    client->ltaskid_stdout != out->ltaskid)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (out->type==SLURM_IO_STDERR) {\n\t\t\t\tif (client->ltaskid_stderr != -1 &&\n\t\t\t\t    client->ltaskid_stderr != out->ltaskid)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug5(\"======================== Enqueued message\");\n\t\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\t\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\t\tmsg->ref_count++;\n\t\t}\n\t\tlist_iterator_destroy(clients);\n\n\t\t/* Update the outgoing message cache */\n\t\tif (list_enqueue(out->job->outgoing_cache, msg)) {\n\t\t\tmsg->ref_count++;\n\t\t\t_shrink_msg_cache(out->job->outgoing_cache, out->job);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [
            "#define CLIENT_IO_MAGIC  0x10102"
          ],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static bool _task_writable(eio_obj_t *);",
            "static bool _task_readable(eio_obj_t *);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _send_eof_msg(struct task_read_info *out);",
            "static void *_io_thr(void *arg);",
            "static void _route_msg_task_to_client(eio_obj_t *obj);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_route_msg_task_to_client(eio_obj_t *obj)\n{\n\tstruct task_read_info *out = (struct task_read_info *)obj->arg;\n\tstruct client_io_info *client;\n\tstruct io_buf *msg = NULL;\n\teio_obj_t *eio;\n\tListIterator clients;\n\n\t/* Pack task output into messages for transfer to a client */\n\twhile (cbuf_used(out->buf) > 0\n\t       && _outgoing_buf_free(out->job)) {\n\t\tdebug5(\"cbuf_used = %d\", cbuf_used(out->buf));\n\t\tmsg = _task_build_message(out, out->job, out->buf);\n\t\tif (msg == NULL)\n\t\t\treturn;\n\n\t\t/* Add message to the msg_queue of all clients */\n\t\tclients = list_iterator_create(out->job->clients);\n\t\twhile ((eio = list_next(clients))) {\n\t\t\tclient = (struct client_io_info *)eio->arg;\n\t\t\tif (client->out_eof == true)\n\t\t\t\tcontinue;\n\n\t\t\t/* Some clients only take certain I/O streams */\n\t\t\tif (out->type==SLURM_IO_STDOUT) {\n\t\t\t\tif (client->ltaskid_stdout != -1 &&\n\t\t\t\t    client->ltaskid_stdout != out->ltaskid)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (out->type==SLURM_IO_STDERR) {\n\t\t\t\tif (client->ltaskid_stderr != -1 &&\n\t\t\t\t    client->ltaskid_stderr != out->ltaskid)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug5(\"======================== Enqueued message\");\n\t\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\t\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\t\tmsg->ref_count++;\n\t\t}\n\t\tlist_iterator_destroy(clients);\n\n\t\t/* Update the outgoing message cache */\n\t\tif (list_enqueue(out->job->outgoing_cache, msg)) {\n\t\t\tmsg->ref_count++;\n\t\t\t_shrink_msg_cache(out->job->outgoing_cache, out->job);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "job->free_outgoing",
            "msg"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tint i;\n\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_outgoing, msg);\n\n\t\t/* Try packing messages from tasks' output cbufs */\n\t\tif (job->task == NULL)\n\t\t\treturn;\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i]->err != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->err);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (job->task[i]->out != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->out);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}"
  },
  {
    "function_name": "_free_incoming_msg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1362-1373",
    "snippet": "static void\n_free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_incoming, msg);\n\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _client_read(eio_obj_t *, List);",
      "static int  _client_write(eio_obj_t *, List);",
      "static int  _local_file_write(eio_obj_t *, List);",
      "static int  _task_write(eio_obj_t *, List);",
      "static int  _task_read(eio_obj_t *, List);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eio_signal_wakeup",
          "args": [
            "job->eio"
          ],
          "line": 1371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "job->free_incoming",
            "msg"
          ],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_incoming, msg);\n\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}"
  },
  {
    "function_name": "_route_msg_task_to_client",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1311-1360",
    "snippet": "static void\n_route_msg_task_to_client(eio_obj_t *obj)\n{\n\tstruct task_read_info *out = (struct task_read_info *)obj->arg;\n\tstruct client_io_info *client;\n\tstruct io_buf *msg = NULL;\n\teio_obj_t *eio;\n\tListIterator clients;\n\n\t/* Pack task output into messages for transfer to a client */\n\twhile (cbuf_used(out->buf) > 0\n\t       && _outgoing_buf_free(out->job)) {\n\t\tdebug5(\"cbuf_used = %d\", cbuf_used(out->buf));\n\t\tmsg = _task_build_message(out, out->job, out->buf);\n\t\tif (msg == NULL)\n\t\t\treturn;\n\n\t\t/* Add message to the msg_queue of all clients */\n\t\tclients = list_iterator_create(out->job->clients);\n\t\twhile ((eio = list_next(clients))) {\n\t\t\tclient = (struct client_io_info *)eio->arg;\n\t\t\tif (client->out_eof == true)\n\t\t\t\tcontinue;\n\n\t\t\t/* Some clients only take certain I/O streams */\n\t\t\tif (out->type==SLURM_IO_STDOUT) {\n\t\t\t\tif (client->ltaskid_stdout != -1 &&\n\t\t\t\t    client->ltaskid_stdout != out->ltaskid)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (out->type==SLURM_IO_STDERR) {\n\t\t\t\tif (client->ltaskid_stderr != -1 &&\n\t\t\t\t    client->ltaskid_stderr != out->ltaskid)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug5(\"======================== Enqueued message\");\n\t\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\t\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\t\tmsg->ref_count++;\n\t\t}\n\t\tlist_iterator_destroy(clients);\n\n\t\t/* Update the outgoing message cache */\n\t\tif (list_enqueue(out->job->outgoing_cache, msg)) {\n\t\t\tmsg->ref_count++;\n\t\t\t_shrink_msg_cache(out->job->outgoing_cache, out->job);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define CLIENT_IO_MAGIC  0x10102"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static bool _task_writable(eio_obj_t *);",
      "static bool _task_readable(eio_obj_t *);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _send_eof_msg(struct task_read_info *out);",
      "static void *_io_thr(void *arg);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_shrink_msg_cache",
          "args": [
            "out->job->outgoing_cache",
            "out->job"
          ],
          "line": 1357
        },
        "resolved": true,
        "details": {
          "function_name": "_shrink_msg_cache",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1221-1238",
          "snippet": "void\n_shrink_msg_cache(List cache, stepd_step_rec_t *job)\n{\n\tstruct io_buf *msg;\n\tint over = 0;\n\tint count;\n\tint i;\n\n\tcount = list_count(cache);\n\tif (count > STDIO_MAX_MSG_CACHE)\n\t\tover = count - STDIO_MAX_MSG_CACHE;\n\n\tfor (i = 0; i < over; i++) {\n\t\tmsg = list_dequeue(cache);\n\t\t/* FIXME - following call MIGHT lead to too much recursion */\n\t\t_free_outgoing_msg(msg, job);\n\t}\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int  _task_read(eio_obj_t *, List);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nvoid\n_shrink_msg_cache(List cache, stepd_step_rec_t *job)\n{\n\tstruct io_buf *msg;\n\tint over = 0;\n\tint count;\n\tint i;\n\n\tcount = list_count(cache);\n\tif (count > STDIO_MAX_MSG_CACHE)\n\t\tover = count - STDIO_MAX_MSG_CACHE;\n\n\tfor (i = 0; i < over; i++) {\n\t\tmsg = list_dequeue(cache);\n\t\t/* FIXME - following call MIGHT lead to too much recursion */\n\t\t_free_outgoing_msg(msg, job);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "out->job->outgoing_cache",
            "msg"
          ],
          "line": 1355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_iterator_destroy",
          "args": [
            "clients"
          ],
          "line": 1352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "client->msg_queue",
            "msg"
          ],
          "line": 1349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "client->magic == CLIENT_IO_MAGIC"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"======================== Enqueued message\""
          ],
          "line": 1347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next",
          "args": [
            "clients"
          ],
          "line": 1330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_iterator_create",
          "args": [
            "out->job->clients"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_task_build_message",
          "args": [
            "out",
            "out->job",
            "out->buf"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "_task_build_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1812-1852",
          "snippet": "static struct io_buf *\n_task_build_message(struct task_read_info *out, stepd_step_rec_t *job, cbuf_t cbuf)\n{\n\tstruct io_buf *msg;\n\tchar *ptr;\n\tBuf packbuf;\n\tstruct slurm_io_header header;\n\tint n;\n\n\tdebug4(\"%s: Entering...\", __func__);\n\n\tif (_outgoing_buf_free(job)) {\n\t\tmsg = list_dequeue(job->free_outgoing);\n\t} else {\n\t\treturn NULL;\n\t}\n\n\tptr = msg->data + io_hdr_packed_size();\n\tn = cbuf_read(cbuf, ptr, MAX_MSG_LEN);\n\theader.type = out->type;\n\theader.ltaskid = out->ltaskid;\n\theader.gtaskid = out->gtaskid;\n\theader.length = n;\n\n\tdebug4(\"%s: header.length %d\", __func__, n);\n\tpackbuf = create_buf(msg->data, io_hdr_packed_size());\n\tif (!packbuf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn msg;\t/* Fix for CLANG false positive error */\n\t}\n\tio_hdr_pack(&header, packbuf);\n\tmsg->length = io_hdr_packed_size() + header.length;\n\tmsg->ref_count = 0; /* make certain it is initialized */\n\n\t/* free the Buf packbuf, but not the memory to which it points */\n\tpackbuf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(packbuf);\n\n\tdebug4(\"%s: Leaving...\", __func__);\n\treturn msg;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _send_eof_msg(struct task_read_info *out);",
            "static struct io_buf *_task_build_message(struct task_read_info *out,\n\t\t\t\t\t  stepd_step_rec_t *job, cbuf_t cbuf);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic struct io_buf *_task_build_message(struct task_read_info *out,\n\t\t\t\t\t  stepd_step_rec_t *job, cbuf_t cbuf);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic struct io_buf *\n_task_build_message(struct task_read_info *out, stepd_step_rec_t *job, cbuf_t cbuf)\n{\n\tstruct io_buf *msg;\n\tchar *ptr;\n\tBuf packbuf;\n\tstruct slurm_io_header header;\n\tint n;\n\n\tdebug4(\"%s: Entering...\", __func__);\n\n\tif (_outgoing_buf_free(job)) {\n\t\tmsg = list_dequeue(job->free_outgoing);\n\t} else {\n\t\treturn NULL;\n\t}\n\n\tptr = msg->data + io_hdr_packed_size();\n\tn = cbuf_read(cbuf, ptr, MAX_MSG_LEN);\n\theader.type = out->type;\n\theader.ltaskid = out->ltaskid;\n\theader.gtaskid = out->gtaskid;\n\theader.length = n;\n\n\tdebug4(\"%s: header.length %d\", __func__, n);\n\tpackbuf = create_buf(msg->data, io_hdr_packed_size());\n\tif (!packbuf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn msg;\t/* Fix for CLANG false positive error */\n\t}\n\tio_hdr_pack(&header, packbuf);\n\tmsg->length = io_hdr_packed_size() + header.length;\n\tmsg->ref_count = 0; /* make certain it is initialized */\n\n\t/* free the Buf packbuf, but not the memory to which it points */\n\tpackbuf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(packbuf);\n\n\tdebug4(\"%s: Leaving...\", __func__);\n\treturn msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"cbuf_used = %d\"",
            "cbuf_used(out->buf)"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbuf_used",
          "args": [
            "out->buf"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_outgoing_buf_free",
          "args": [
            "out->job"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "_outgoing_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1905-1922",
          "snippet": "static bool\n_outgoing_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_outgoing) > 0) {\n\t\treturn true;\n\t} else if (job->outgoing_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_outgoing, buf);\n\t\t\tjob->outgoing_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic bool\n_outgoing_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_outgoing) > 0) {\n\t\treturn true;\n\t} else if (job->outgoing_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_outgoing, buf);\n\t\t\tjob->outgoing_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cbuf_used",
          "args": [
            "out->buf"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_route_msg_task_to_client(eio_obj_t *obj)\n{\n\tstruct task_read_info *out = (struct task_read_info *)obj->arg;\n\tstruct client_io_info *client;\n\tstruct io_buf *msg = NULL;\n\teio_obj_t *eio;\n\tListIterator clients;\n\n\t/* Pack task output into messages for transfer to a client */\n\twhile (cbuf_used(out->buf) > 0\n\t       && _outgoing_buf_free(out->job)) {\n\t\tdebug5(\"cbuf_used = %d\", cbuf_used(out->buf));\n\t\tmsg = _task_build_message(out, out->job, out->buf);\n\t\tif (msg == NULL)\n\t\t\treturn;\n\n\t\t/* Add message to the msg_queue of all clients */\n\t\tclients = list_iterator_create(out->job->clients);\n\t\twhile ((eio = list_next(clients))) {\n\t\t\tclient = (struct client_io_info *)eio->arg;\n\t\t\tif (client->out_eof == true)\n\t\t\t\tcontinue;\n\n\t\t\t/* Some clients only take certain I/O streams */\n\t\t\tif (out->type==SLURM_IO_STDOUT) {\n\t\t\t\tif (client->ltaskid_stdout != -1 &&\n\t\t\t\t    client->ltaskid_stdout != out->ltaskid)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (out->type==SLURM_IO_STDERR) {\n\t\t\t\tif (client->ltaskid_stderr != -1 &&\n\t\t\t\t    client->ltaskid_stderr != out->ltaskid)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug5(\"======================== Enqueued message\");\n\t\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\t\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\t\tmsg->ref_count++;\n\t\t}\n\t\tlist_iterator_destroy(clients);\n\n\t\t/* Update the outgoing message cache */\n\t\tif (list_enqueue(out->job->outgoing_cache, msg)) {\n\t\t\tmsg->ref_count++;\n\t\t\t_shrink_msg_cache(out->job->outgoing_cache, out->job);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "_build_connection_okay_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1275-1307",
    "snippet": "static struct io_buf *\n_build_connection_okay_message(stepd_step_rec_t *job)\n{\n\tstruct io_buf *msg;\n\tBuf packbuf;\n\tstruct slurm_io_header header;\n\n\tif (_outgoing_buf_free(job)) {\n\t\tmsg = list_dequeue(job->free_outgoing);\n\t} else {\n\t\treturn NULL;\n\t}\n\n\theader.type = SLURM_IO_CONNECTION_TEST;\n\theader.ltaskid = 0;  /* Unused */\n\theader.gtaskid = 0;  /* Unused */\n\theader.length = 0;\n\n\tpackbuf = create_buf(msg->data, io_hdr_packed_size());\n\tif (!packbuf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn msg;\t/* Fix for CLANG false positive error */\n\t}\n\tio_hdr_pack(&header, packbuf);\n\tmsg->length = io_hdr_packed_size();\n\tmsg->ref_count = 0; /* make certain it is initialized */\n\n\t/* free the Buf packbuf, but not the memory to which it points */\n\tpackbuf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(packbuf);\n\n\treturn msg;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_buf",
          "args": [
            "packbuf"
          ],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_packed_size",
          "args": [],
          "line": 1299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_pack",
          "args": [
            "&header",
            "packbuf"
          ],
          "line": 1298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Failure to allocate memory for a message header\""
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_buf",
          "args": [
            "msg->data",
            "io_hdr_packed_size()"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_packed_size",
          "args": [],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_dequeue",
          "args": [
            "job->free_outgoing"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_outgoing_buf_free",
          "args": [
            "job"
          ],
          "line": 1282
        },
        "resolved": true,
        "details": {
          "function_name": "_outgoing_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1905-1922",
          "snippet": "static bool\n_outgoing_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_outgoing) > 0) {\n\t\treturn true;\n\t} else if (job->outgoing_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_outgoing, buf);\n\t\t\tjob->outgoing_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic bool\n_outgoing_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_outgoing) > 0) {\n\t\treturn true;\n\t} else if (job->outgoing_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_outgoing, buf);\n\t\t\tjob->outgoing_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic struct io_buf *\n_build_connection_okay_message(stepd_step_rec_t *job)\n{\n\tstruct io_buf *msg;\n\tBuf packbuf;\n\tstruct slurm_io_header header;\n\n\tif (_outgoing_buf_free(job)) {\n\t\tmsg = list_dequeue(job->free_outgoing);\n\t} else {\n\t\treturn NULL;\n\t}\n\n\theader.type = SLURM_IO_CONNECTION_TEST;\n\theader.ltaskid = 0;  /* Unused */\n\theader.gtaskid = 0;  /* Unused */\n\theader.length = 0;\n\n\tpackbuf = create_buf(msg->data, io_hdr_packed_size());\n\tif (!packbuf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn msg;\t/* Fix for CLANG false positive error */\n\t}\n\tio_hdr_pack(&header, packbuf);\n\tmsg->length = io_hdr_packed_size();\n\tmsg->ref_count = 0; /* make certain it is initialized */\n\n\t/* free the Buf packbuf, but not the memory to which it points */\n\tpackbuf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(packbuf);\n\n\treturn msg;\n}"
  },
  {
    "function_name": "_send_connection_okay_response",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1242-1271",
    "snippet": "static int\n_send_connection_okay_response(stepd_step_rec_t *job)\n{\n\teio_obj_t *eio;\n\tListIterator clients;\n\tstruct io_buf *msg;\n\tstruct client_io_info *client;\n\n\tmsg = _build_connection_okay_message(job);\n\tif (!msg) {\n\t\terror(  \"Could not send connection okay message because of \"\n\t\t\t\"lack of buffer space.\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\tclients = list_iterator_create(job->clients);\n\twhile ((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->out_eof || client->is_local_file)\n\t\t\tcontinue;\n\n\t\tdebug5(\"Sent connection okay message\");\n\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\tmsg->ref_count++;\n\t}\n\tlist_iterator_destroy(clients);\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define CLIENT_IO_MAGIC  0x10102"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static bool _task_writable(eio_obj_t *);",
      "static bool _task_readable(eio_obj_t *);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void *_io_thr(void *arg);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_iterator_destroy",
          "args": [
            "clients"
          ],
          "line": 1268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "client->msg_queue",
            "msg"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "client->magic == CLIENT_IO_MAGIC"
          ],
          "line": 1264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"Sent connection okay message\""
          ],
          "line": 1263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next",
          "args": [
            "clients"
          ],
          "line": 1258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_iterator_create",
          "args": [
            "job->clients"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Could not send connection okay message because of \"\n\t\t\t\"lack of buffer space.\""
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_build_connection_okay_message",
          "args": [
            "job"
          ],
          "line": 1250
        },
        "resolved": true,
        "details": {
          "function_name": "_build_connection_okay_message",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1275-1307",
          "snippet": "static struct io_buf *\n_build_connection_okay_message(stepd_step_rec_t *job)\n{\n\tstruct io_buf *msg;\n\tBuf packbuf;\n\tstruct slurm_io_header header;\n\n\tif (_outgoing_buf_free(job)) {\n\t\tmsg = list_dequeue(job->free_outgoing);\n\t} else {\n\t\treturn NULL;\n\t}\n\n\theader.type = SLURM_IO_CONNECTION_TEST;\n\theader.ltaskid = 0;  /* Unused */\n\theader.gtaskid = 0;  /* Unused */\n\theader.length = 0;\n\n\tpackbuf = create_buf(msg->data, io_hdr_packed_size());\n\tif (!packbuf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn msg;\t/* Fix for CLANG false positive error */\n\t}\n\tio_hdr_pack(&header, packbuf);\n\tmsg->length = io_hdr_packed_size();\n\tmsg->ref_count = 0; /* make certain it is initialized */\n\n\t/* free the Buf packbuf, but not the memory to which it points */\n\tpackbuf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(packbuf);\n\n\treturn msg;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic struct io_buf *\n_build_connection_okay_message(stepd_step_rec_t *job)\n{\n\tstruct io_buf *msg;\n\tBuf packbuf;\n\tstruct slurm_io_header header;\n\n\tif (_outgoing_buf_free(job)) {\n\t\tmsg = list_dequeue(job->free_outgoing);\n\t} else {\n\t\treturn NULL;\n\t}\n\n\theader.type = SLURM_IO_CONNECTION_TEST;\n\theader.ltaskid = 0;  /* Unused */\n\theader.gtaskid = 0;  /* Unused */\n\theader.length = 0;\n\n\tpackbuf = create_buf(msg->data, io_hdr_packed_size());\n\tif (!packbuf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn msg;\t/* Fix for CLANG false positive error */\n\t}\n\tio_hdr_pack(&header, packbuf);\n\tmsg->length = io_hdr_packed_size();\n\tmsg->ref_count = 0; /* make certain it is initialized */\n\n\t/* free the Buf packbuf, but not the memory to which it points */\n\tpackbuf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(packbuf);\n\n\treturn msg;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic int\n_send_connection_okay_response(stepd_step_rec_t *job)\n{\n\teio_obj_t *eio;\n\tListIterator clients;\n\tstruct io_buf *msg;\n\tstruct client_io_info *client;\n\n\tmsg = _build_connection_okay_message(job);\n\tif (!msg) {\n\t\terror(  \"Could not send connection okay message because of \"\n\t\t\t\"lack of buffer space.\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\tclients = list_iterator_create(job->clients);\n\twhile ((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->out_eof || client->is_local_file)\n\t\t\tcontinue;\n\n\t\tdebug5(\"Sent connection okay message\");\n\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\tmsg->ref_count++;\n\t}\n\tlist_iterator_destroy(clients);\n\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "_shrink_msg_cache",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1221-1238",
    "snippet": "void\n_shrink_msg_cache(List cache, stepd_step_rec_t *job)\n{\n\tstruct io_buf *msg;\n\tint over = 0;\n\tint count;\n\tint i;\n\n\tcount = list_count(cache);\n\tif (count > STDIO_MAX_MSG_CACHE)\n\t\tover = count - STDIO_MAX_MSG_CACHE;\n\n\tfor (i = 0; i < over; i++) {\n\t\tmsg = list_dequeue(cache);\n\t\t/* FIXME - following call MIGHT lead to too much recursion */\n\t\t_free_outgoing_msg(msg, job);\n\t}\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int  _client_read(eio_obj_t *, List);",
      "static int  _client_write(eio_obj_t *, List);",
      "static int  _local_file_write(eio_obj_t *, List);",
      "static int  _task_write(eio_obj_t *, List);",
      "static int  _task_read(eio_obj_t *, List);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_free_outgoing_msg",
          "args": [
            "msg",
            "job"
          ],
          "line": 1236
        },
        "resolved": true,
        "details": {
          "function_name": "_free_outgoing_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1375-1403",
          "snippet": "static void\n_free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tint i;\n\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_outgoing, msg);\n\n\t\t/* Try packing messages from tasks' output cbufs */\n\t\tif (job->task == NULL)\n\t\t\treturn;\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i]->err != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->err);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (job->task[i]->out != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->out);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int  _task_read(eio_obj_t *, List);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _send_eof_msg(struct task_read_info *out);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tint i;\n\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_outgoing, msg);\n\n\t\t/* Try packing messages from tasks' output cbufs */\n\t\tif (job->task == NULL)\n\t\t\treturn;\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i]->err != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->err);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (job->task[i]->out != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->out);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_dequeue",
          "args": [
            "cache"
          ],
          "line": 1234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_count",
          "args": [
            "cache"
          ],
          "line": 1229
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nvoid\n_shrink_msg_cache(List cache, stepd_step_rec_t *job)\n{\n\tstruct io_buf *msg;\n\tint over = 0;\n\tint count;\n\tint i;\n\n\tcount = list_count(cache);\n\tif (count > STDIO_MAX_MSG_CACHE)\n\t\tover = count - STDIO_MAX_MSG_CACHE;\n\n\tfor (i = 0; i < over; i++) {\n\t\tmsg = list_dequeue(cache);\n\t\t/* FIXME - following call MIGHT lead to too much recursion */\n\t\t_free_outgoing_msg(msg, job);\n\t}\n}"
  },
  {
    "function_name": "io_thread_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1195-1218",
    "snippet": "int\nio_thread_start(stepd_step_rec_t *job)\n{\n\tpthread_attr_t attr;\n\tint rc = 0, retries = 0;\n\n\tslurm_attr_init(&attr);\n\n\twhile (pthread_create(&job->ioid, &attr, &_io_thr, (void *)job)) {\n\t\terror(\"io_thread_start: pthread_create error %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"io_thread_start: Can't create pthread\");\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\n\tslurm_attr_destroy(&attr);\n\n\t/*fatal_add_cleanup(&_fatal_cleanup, (void *) job);*/\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *_io_thr(void *);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slurm_attr_destroy",
          "args": [
            "&attr"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usleep",
          "args": [
            "10"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"io_thread_start: Can't create pthread\""
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"io_thread_start: pthread_create error %m\""
          ],
          "line": 1204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_create",
          "args": [
            "&job->ioid",
            "&attr",
            "&_io_thr",
            "(void *)job"
          ],
          "line": 1203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_attr_init",
          "args": [
            "&attr"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic void *_io_thr(void *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nint\nio_thread_start(stepd_step_rec_t *job)\n{\n\tpthread_attr_t attr;\n\tint rc = 0, retries = 0;\n\n\tslurm_attr_init(&attr);\n\n\twhile (pthread_create(&job->ioid, &attr, &_io_thr, (void *)job)) {\n\t\terror(\"io_thread_start: pthread_create error %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"io_thread_start: Can't create pthread\");\n\t\t\trc = -1;\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\n\tslurm_attr_destroy(&attr);\n\n\t/*fatal_add_cleanup(&_fatal_cleanup, (void *) job);*/\n\n\treturn rc;\n}"
  },
  {
    "function_name": "io_init_tasks_stdio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "1181-1193",
    "snippet": "int\nio_init_tasks_stdio(stepd_step_rec_t *job)\n{\n\tint i, rc = SLURM_SUCCESS, tmprc;\n\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\ttmprc = _init_task_stdio_fds(job->task[i], job);\n\t\tif (tmprc != SLURM_SUCCESS)\n\t\t\trc = tmprc;\n\t}\n\n\treturn rc;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_init_task_stdio_fds",
          "args": [
            "job->task[i]",
            "job"
          ],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nint\nio_init_tasks_stdio(stepd_step_rec_t *job)\n{\n\tint i, rc = SLURM_SUCCESS, tmprc;\n\n\tfor (i = 0; i < job->node_tasks; i++) {\n\t\ttmprc = _init_task_stdio_fds(job->task[i], job);\n\t\tif (tmprc != SLURM_SUCCESS)\n\t\t\trc = tmprc;\n\t}\n\n\treturn rc;\n}"
  },
  {
    "function_name": "_spawn_window_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "871-928",
    "snippet": "static void\n_spawn_window_manager(stepd_step_task_info_t *task, stepd_step_rec_t *job)\n{\n\tchar *host, *port, *rows, *cols;\n\tslurm_fd_t pty_fd;\n\tslurm_addr_t pty_addr;\n\tuint16_t port_u;\n\tstruct window_info *win_info;\n\tpthread_attr_t attr;\n\tpthread_t win_id;\n\n#if 0\n\t/* NOTE: SLURM_LAUNCH_NODE_IPADDR is not available at this point */\n\tif (!(ip_addr = getenvp(job->env, \"SLURM_LAUNCH_NODE_IPADDR\"))) {\n\t\terror(\"SLURM_LAUNCH_NODE_IPADDR env var not set\");\n\t\treturn;\n\t}\n#endif\n\tif (!(host = getenvp(job->env, \"SLURM_SRUN_COMM_HOST\"))) {\n\t\terror(\"SLURM_SRUN_COMM_HOST env var not set\");\n\t\treturn;\n\t}\n\tif (!(port = getenvp(job->env, \"SLURM_PTY_PORT\"))) {\n\t\terror(\"SLURM_PTY_PORT env var not set\");\n\t\treturn;\n\t}\n\tif (!(cols = getenvp(job->env, \"SLURM_PTY_WIN_COL\")))\n\t\terror(\"SLURM_PTY_WIN_COL env var not set\");\n\tif (!(rows = getenvp(job->env, \"SLURM_PTY_WIN_ROW\")))\n\t\terror(\"SLURM_PTY_WIN_ROW env var not set\");\n\n\tif (rows && cols) {\n\t\tstruct winsize ws;\n\t\tws.ws_col = atoi(cols);\n\t\tws.ws_row = atoi(rows);\n\t\tdebug(\"init pty size %u:%u\", ws.ws_row, ws.ws_col);\n\t\tif (ioctl(task->to_stdin, TIOCSWINSZ, &ws))\n\t\t\terror(\"ioctl(TIOCSWINSZ): %s\", strerror(errno));\n\t}\n\n\tport_u = atoi(port);\n\tslurm_set_addr(&pty_addr, port_u, host);\n\tpty_fd = slurm_open_msg_conn(&pty_addr);\n\tif (pty_fd < 0) {\n\t\terror(\"slurm_open_msg_conn(pty_conn) %s,%u: %m\",\n\t\t\thost, port_u);\n\t\treturn;\n\t}\n\n\twin_info = xmalloc(sizeof(struct window_info));\n\twin_info->task   = task;\n\twin_info->job    = job;\n\twin_info->pty_fd = pty_fd;\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\tif (pthread_create(&win_id, &attr, &_window_manager, (void *) win_info))\n\t\terror(\"pthread_create(pty_conn): %m\");\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"pthread_create(pty_conn): %m\""
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_create",
          "args": [
            "&win_id",
            "&attr",
            "&_window_manager",
            "(void *) win_info"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pthread_attr_setdetachstate",
          "args": [
            "&attr",
            "PTHREAD_CREATE_DETACHED"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_attr_init",
          "args": [
            "&attr"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(struct window_info)"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"slurm_open_msg_conn(pty_conn) %s,%u: %m\"",
            "host",
            "port_u"
          ],
          "line": 915
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_open_msg_conn",
          "args": [
            "&pty_addr"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_set_addr",
          "args": [
            "&pty_addr",
            "port_u",
            "host"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "port"
          ],
          "line": 911
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"ioctl(TIOCSWINSZ): %s\"",
            "strerror(errno)"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "_task_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "641-650",
          "snippet": "static int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static bool _task_writable(eio_obj_t *);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int _task_write_error(eio_obj_t *obj, List objs);",
            "static bool _task_readable(eio_obj_t *);",
            "static int  _task_read(eio_obj_t *, List);",
            "static void _route_msg_task_to_client(eio_obj_t *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "task->to_stdin",
            "TIOCSWINSZ",
            "&ws"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"init pty size %u:%u\"",
            "ws.ws_row",
            "ws.ws_col"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "rows"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "cols"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"SLURM_PTY_WIN_ROW env var not set\""
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenvp",
          "args": [
            "job->env",
            "\"SLURM_PTY_WIN_ROW\""
          ],
          "line": 899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"SLURM_PTY_WIN_COL env var not set\""
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenvp",
          "args": [
            "job->env",
            "\"SLURM_PTY_WIN_COL\""
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"SLURM_PTY_PORT env var not set\""
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenvp",
          "args": [
            "job->env",
            "\"SLURM_PTY_PORT\""
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"SLURM_SRUN_COMM_HOST env var not set\""
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenvp",
          "args": [
            "job->env",
            "\"SLURM_SRUN_COMM_HOST\""
          ],
          "line": 889
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"SLURM_LAUNCH_NODE_IPADDR env var not set\""
          ],
          "line": 885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getenvp",
          "args": [
            "job->env",
            "\"SLURM_LAUNCH_NODE_IPADDR\""
          ],
          "line": 884
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_spawn_window_manager(stepd_step_task_info_t *task, stepd_step_rec_t *job)\n{\n\tchar *host, *port, *rows, *cols;\n\tslurm_fd_t pty_fd;\n\tslurm_addr_t pty_addr;\n\tuint16_t port_u;\n\tstruct window_info *win_info;\n\tpthread_attr_t attr;\n\tpthread_t win_id;\n\n#if 0\n\t/* NOTE: SLURM_LAUNCH_NODE_IPADDR is not available at this point */\n\tif (!(ip_addr = getenvp(job->env, \"SLURM_LAUNCH_NODE_IPADDR\"))) {\n\t\terror(\"SLURM_LAUNCH_NODE_IPADDR env var not set\");\n\t\treturn;\n\t}\n#endif\n\tif (!(host = getenvp(job->env, \"SLURM_SRUN_COMM_HOST\"))) {\n\t\terror(\"SLURM_SRUN_COMM_HOST env var not set\");\n\t\treturn;\n\t}\n\tif (!(port = getenvp(job->env, \"SLURM_PTY_PORT\"))) {\n\t\terror(\"SLURM_PTY_PORT env var not set\");\n\t\treturn;\n\t}\n\tif (!(cols = getenvp(job->env, \"SLURM_PTY_WIN_COL\")))\n\t\terror(\"SLURM_PTY_WIN_COL env var not set\");\n\tif (!(rows = getenvp(job->env, \"SLURM_PTY_WIN_ROW\")))\n\t\terror(\"SLURM_PTY_WIN_ROW env var not set\");\n\n\tif (rows && cols) {\n\t\tstruct winsize ws;\n\t\tws.ws_col = atoi(cols);\n\t\tws.ws_row = atoi(rows);\n\t\tdebug(\"init pty size %u:%u\", ws.ws_row, ws.ws_col);\n\t\tif (ioctl(task->to_stdin, TIOCSWINSZ, &ws))\n\t\t\terror(\"ioctl(TIOCSWINSZ): %s\", strerror(errno));\n\t}\n\n\tport_u = atoi(port);\n\tslurm_set_addr(&pty_addr, port_u, host);\n\tpty_fd = slurm_open_msg_conn(&pty_addr);\n\tif (pty_fd < 0) {\n\t\terror(\"slurm_open_msg_conn(pty_conn) %s,%u: %m\",\n\t\t\thost, port_u);\n\t\treturn;\n\t}\n\n\twin_info = xmalloc(sizeof(struct window_info));\n\twin_info->task   = task;\n\twin_info->job    = job;\n\twin_info->pty_fd = pty_fd;\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\tif (pthread_create(&win_id, &attr, &_window_manager, (void *) win_info))\n\t\terror(\"pthread_create(pty_conn): %m\");\n}"
  },
  {
    "function_name": "_window_manager",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "819-869",
    "snippet": "static void *_window_manager(void *arg)\n{\n\tstruct window_info *win_info = (struct window_info *) arg;\n\tpty_winsz_t winsz;\n\tssize_t len;\n\tstruct winsize ws;\n\tstruct pollfd ufds;\n\tchar buf[4];\n\n\tinfo(\"in _window_manager\");\n\tufds.fd = win_info->pty_fd;\n\tufds.events = POLLIN;\n\n\twhile (1) {\n\t\tif (poll(&ufds, 1, -1) <= 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\terror(\"poll(pty): %m\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!(ufds.revents & POLLIN)) {\n\t\t\t/* ((ufds.revents & POLLHUP) ||\n\t\t\t *  (ufds.revents & POLLERR)) */\n\t\t\tbreak;\n\t\t}\n\t\tlen = slurm_read_stream(win_info->pty_fd, buf, 4);\n\t\tif ((len == -1) && ((errno == EINTR) || (errno == EAGAIN)))\n\t\t\tcontinue;\n\t\tif (len < 4) {\n\t\t\tif (errno != SLURM_PROTOCOL_SOCKET_ZERO_BYTES_SENT) {\n\t\t\t\terror(\"%s: read window size error: %m\",\n\t\t\t\t      __func__);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(&winsz.cols, buf, 2);\n\t\tmemcpy(&winsz.rows, buf+2, 2);\n\t\tws.ws_col = ntohs(winsz.cols);\n\t\tws.ws_row = ntohs(winsz.rows);\n\t\tdebug(\"new pty size %u:%u\", ws.ws_row, ws.ws_col);\n\t\tif (ioctl(win_info->task->to_stdin, TIOCSWINSZ, &ws))\n\t\t\terror(\"ioctl(TIOCSWINSZ): %s\", strerror(errno));\n\t\tif (kill(win_info->task->pid, SIGWINCH)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tbreak;\n\t\t\terror(\"kill(%d, SIGWINCH): %m\",\n\t\t\t\t(int)win_info->task->pid);\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void *_io_thr(void *arg);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"kill(%d, SIGWINCH): %m\"",
            "(int)win_info->task->pid"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "_task_write_error",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "641-650",
          "snippet": "static int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static bool _task_writable(eio_obj_t *);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int _task_write_error(eio_obj_t *obj, List objs);",
            "static bool _task_readable(eio_obj_t *);",
            "static int  _task_read(eio_obj_t *, List);",
            "static void _route_msg_task_to_client(eio_obj_t *obj);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill",
          "args": [
            "win_info->task->pid",
            "SIGWINCH"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "_delay_kill_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "2124-2144",
          "snippet": "static void _delay_kill_thread(pthread_t thread_id, int secs)\n{\n\tpthread_t kill_id;\n\tpthread_attr_t attr;\n\tkill_thread_t *kt = xmalloc(sizeof(kill_thread_t));\n\tint retries = 0;\n\n\tkt->thread_id = thread_id;\n\tkt->secs = secs;\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&kill_id, &attr, &_kill_thr, (void *) kt)) {\n\t\terror(\"_delay_kill_thread: pthread_create: %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"_delay_kill_thread: Can't create pthread\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic void _delay_kill_thread(pthread_t thread_id, int secs)\n{\n\tpthread_t kill_id;\n\tpthread_attr_t attr;\n\tkill_thread_t *kt = xmalloc(sizeof(kill_thread_t));\n\tint retries = 0;\n\n\tkt->thread_id = thread_id;\n\tkt->secs = secs;\n\tslurm_attr_init(&attr);\n\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\twhile (pthread_create(&kill_id, &attr, &_kill_thr, (void *) kt)) {\n\t\terror(\"_delay_kill_thread: pthread_create: %m\");\n\t\tif (++retries > MAX_RETRIES) {\n\t\t\terror(\"_delay_kill_thread: Can't create pthread\");\n\t\t\tbreak;\n\t\t}\n\t\tusleep(10);\t/* sleep and again */\n\t}\n\tslurm_attr_destroy(&attr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strerror",
          "args": [
            "errno"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ioctl",
          "args": [
            "win_info->task->to_stdin",
            "TIOCSWINSZ",
            "&ws"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug",
          "args": [
            "\"new pty size %u:%u\"",
            "ws.ws_row",
            "ws.ws_col"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "winsz.rows"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohs",
          "args": [
            "winsz.cols"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&winsz.rows",
            "buf+2",
            "2"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&winsz.cols",
            "buf",
            "2"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slurm_read_stream",
          "args": [
            "win_info->pty_fd",
            "buf",
            "4"
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"poll(pty): %m\""
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "poll",
          "args": [
            "&ufds",
            "1",
            "-1"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "info",
          "args": [
            "\"in _window_manager\""
          ],
          "line": 828
        },
        "resolved": true,
        "details": {
          "function_name": "_fork_child_with_wait_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/mgr.c",
          "lines": "1464-1486",
          "snippet": "static struct exec_wait_info * _fork_child_with_wait_info (int id)\n{\n\tstruct exec_wait_info *e;\n\n\tif (!(e = _exec_wait_info_create (id)))\n\t\treturn (NULL);\n\n\tif ((e->pid = fork ()) < 0) {\n\t\t_exec_wait_info_destroy (e);\n\t\treturn (NULL);\n\t}\n\t/*\n\t *  Close parentfd in child, and childfd in parent:\n\t */\n\tif (e->pid == 0) {\n\t\tclose (e->parentfd);\n\t\te->parentfd = -1;\n\t} else {\n\t\tclose (e->childfd);\n\t\te->childfd = -1;\n\t}\n\treturn (e);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"",
            "#include \"src/slurmd/slurmstepd/ulimits.h\"",
            "#include \"src/slurmd/slurmstepd/pam_ses.h\"",
            "#include \"src/slurmd/slurmstepd/req.h\"",
            "#include \"src/slurmd/slurmstepd/pdebug.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmstepd/task.h\"",
            "#include \"src/slurmd/slurmstepd/mgr.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/common/xcpuinfo.h\"",
            "#include \"src/slurmd/common/set_oomadj.h\"",
            "#include \"src/slurmd/common/reverse_tree.h\"",
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/task_plugin.h\"",
            "#include \"src/slurmd/common/slurmd_cgroup.h\"",
            "#include \"src/slurmd/common/proctrack.h\"",
            "#include \"src/slurmd/common/setproctitle.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/slurmd/common/core_spec_plugin.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/util-net.h\"",
            "#include \"src/common/switch.h\"",
            "#include \"src/common/slurm_mpi.h\"",
            "#include \"src/common/slurm_jobacct_gather.h\"",
            "#include \"src/common/slurm_cred.h\"",
            "#include \"src/common/slurm_acct_gather_profile.h\"",
            "#include \"src/common/safeopen.h\"",
            "#include \"src/common/plugstack.h\"",
            "#include \"src/common/node_select.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/hostlist.h\"",
            "#include \"src/common/gres.h\"",
            "#include \"src/common/forward.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/env.h\"",
            "#include \"src/common/cpu_frequency.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#    include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#include <unistd.h>",
            "#include <time.h>",
            "#include <sys/wait.h>",
            "#include <sys/utsname.h>",
            "#include <sys/types.h>",
            "#include <sys/stat.h>",
            "#include <sys/param.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include <pwd.h>",
            "#include <pthread.h>",
            "#include <poll.h>",
            "#include <grp.h>",
            "#  include \"src/common/unsetenv.h\"",
            "#  include <sys/checkpnt.h>",
            "#  include <sys/prctl.h>",
            "#  include <sys/types.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/step_terminate_monitor.h\"\n#include \"src/slurmd/slurmstepd/ulimits.h\"\n#include \"src/slurmd/slurmstepd/pam_ses.h\"\n#include \"src/slurmd/slurmstepd/req.h\"\n#include \"src/slurmd/slurmstepd/pdebug.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmstepd/task.h\"\n#include \"src/slurmd/slurmstepd/mgr.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/common/xcpuinfo.h\"\n#include \"src/slurmd/common/set_oomadj.h\"\n#include \"src/slurmd/common/reverse_tree.h\"\n#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/task_plugin.h\"\n#include \"src/slurmd/common/slurmd_cgroup.h\"\n#include \"src/slurmd/common/proctrack.h\"\n#include \"src/slurmd/common/setproctitle.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/slurmd/common/core_spec_plugin.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/util-net.h\"\n#include \"src/common/switch.h\"\n#include \"src/common/slurm_mpi.h\"\n#include \"src/common/slurm_jobacct_gather.h\"\n#include \"src/common/slurm_cred.h\"\n#include \"src/common/slurm_acct_gather_profile.h\"\n#include \"src/common/safeopen.h\"\n#include \"src/common/plugstack.h\"\n#include \"src/common/node_select.h\"\n#include \"src/common/log.h\"\n#include \"src/common/hostlist.h\"\n#include \"src/common/gres.h\"\n#include \"src/common/forward.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/env.h\"\n#include \"src/common/cpu_frequency.h\"\n#include \"src/common/cbuf.h\"\n#include \"slurm/slurm_errno.h\"\n#    include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/wait.h>\n#include <sys/utsname.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/param.h>\n#include <string.h>\n#include <stdio.h>\n#include <pwd.h>\n#include <pthread.h>\n#include <poll.h>\n#include <grp.h>\n#  include \"src/common/unsetenv.h\"\n#  include <sys/checkpnt.h>\n#  include <sys/prctl.h>\n#  include <sys/types.h>\n#  include \"config.h\"\n\nstatic struct exec_wait_info * _fork_child_with_wait_info (int id)\n{\n\tstruct exec_wait_info *e;\n\n\tif (!(e = _exec_wait_info_create (id)))\n\t\treturn (NULL);\n\n\tif ((e->pid = fork ()) < 0) {\n\t\t_exec_wait_info_destroy (e);\n\t\treturn (NULL);\n\t}\n\t/*\n\t *  Close parentfd in child, and childfd in parent:\n\t */\n\tif (e->pid == 0) {\n\t\tclose (e->parentfd);\n\t\te->parentfd = -1;\n\t} else {\n\t\tclose (e->childfd);\n\t\te->childfd = -1;\n\t}\n\treturn (e);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic void *_io_thr(void *arg);\n\nstatic void *_window_manager(void *arg)\n{\n\tstruct window_info *win_info = (struct window_info *) arg;\n\tpty_winsz_t winsz;\n\tssize_t len;\n\tstruct winsize ws;\n\tstruct pollfd ufds;\n\tchar buf[4];\n\n\tinfo(\"in _window_manager\");\n\tufds.fd = win_info->pty_fd;\n\tufds.events = POLLIN;\n\n\twhile (1) {\n\t\tif (poll(&ufds, 1, -1) <= 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\terror(\"poll(pty): %m\");\n\t\t\tbreak;\n\t\t}\n\t\tif (!(ufds.revents & POLLIN)) {\n\t\t\t/* ((ufds.revents & POLLHUP) ||\n\t\t\t *  (ufds.revents & POLLERR)) */\n\t\t\tbreak;\n\t\t}\n\t\tlen = slurm_read_stream(win_info->pty_fd, buf, 4);\n\t\tif ((len == -1) && ((errno == EINTR) || (errno == EAGAIN)))\n\t\t\tcontinue;\n\t\tif (len < 4) {\n\t\t\tif (errno != SLURM_PROTOCOL_SOCKET_ZERO_BYTES_SENT) {\n\t\t\t\terror(\"%s: read window size error: %m\",\n\t\t\t\t      __func__);\n\t\t\t}\n\t\t\treturn NULL;\n\t\t}\n\t\tmemcpy(&winsz.cols, buf, 2);\n\t\tmemcpy(&winsz.rows, buf+2, 2);\n\t\tws.ws_col = ntohs(winsz.cols);\n\t\tws.ws_row = ntohs(winsz.rows);\n\t\tdebug(\"new pty size %u:%u\", ws.ws_row, ws.ws_col);\n\t\tif (ioctl(win_info->task->to_stdin, TIOCSWINSZ, &ws))\n\t\t\terror(\"ioctl(TIOCSWINSZ): %s\", strerror(errno));\n\t\tif (kill(win_info->task->pid, SIGWINCH)) {\n\t\t\tif (errno == ESRCH)\n\t\t\t\tbreak;\n\t\t\terror(\"kill(%d, SIGWINCH): %m\",\n\t\t\t\t(int)win_info->task->pid);\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "_task_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "768-813",
    "snippet": "static int\n_task_read(eio_obj_t *obj, List objs)\n{\n\tstruct task_read_info *out = (struct task_read_info *)obj->arg;\n\tint len;\n\tint rc = -1;\n\n\txassert(out->magic == TASK_OUT_MAGIC);\n\n\tdebug4(\"Entering _task_read for obj %zx\", (size_t)obj);\n\tlen = cbuf_free(out->buf);\n\tif (len > 0 && !out->eof) {\nagain:\n\t\tif ((rc = cbuf_write_from_fd(out->buf, obj->fd, len, NULL))\n\t\t    < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto again;\n\t\t\tif ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {\n\t\t\t\tdebug5(\"_task_read returned EAGAIN\");\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\t\t\tdebug5(\"  error in _task_read: %m\");\n\t\t}\n\t\tif (rc <= 0) {  /* got eof */\n\t\t\tdebug5(\"  got eof on task\");\n\t\t\tout->eof = true;\n\t\t}\n\t}\n\n\tdebug5(\"************************ %d bytes read from task %s\", rc,\n\t       out->type == SLURM_IO_STDOUT ? \"STDOUT\" : \"STDERR\");\n\n\t/*\n\t * Put the message in client outgoing queues\n\t */\n\t_route_msg_task_to_client(obj);\n\n\t/*\n\t * Send the eof message\n\t */\n\tif (cbuf_used(out->buf) == 0 && out->eof && !out->eof_msg_sent) {\n\t\t_send_eof_msg(out);\n\t}\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define TASK_OUT_MAGIC  0x10103"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static int  _client_read(eio_obj_t *, List);",
      "static int  _client_write(eio_obj_t *, List);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static int  _local_file_write(eio_obj_t *, List);",
      "static bool _task_writable(eio_obj_t *);",
      "static int  _task_write(eio_obj_t *, List);",
      "static int _task_write_error(eio_obj_t *obj, List objs);",
      "static bool _task_readable(eio_obj_t *);",
      "static int  _task_read(eio_obj_t *, List);",
      "static void _send_eof_msg(struct task_read_info *out);",
      "static void *_io_thr(void *arg);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_send_eof_msg",
          "args": [
            "out"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "_send_eof_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1748-1808",
          "snippet": "static void\n_send_eof_msg(struct task_read_info *out)\n{\n\tstruct client_io_info *client;\n\tstruct io_buf *msg = NULL;\n\teio_obj_t *eio;\n\tListIterator clients;\n\tstruct slurm_io_header header;\n\tBuf packbuf;\n\n\tdebug4(\"Entering _send_eof_msg\");\n\tout->eof_msg_sent = true;\n\n\tif (_outgoing_buf_free(out->job)) {\n\t\tmsg = list_dequeue(out->job->free_outgoing);\n\t} else {\n\t\t/* eof message must be allowed to allocate new memory\n\t\t   because _task_readable() will return \"true\" until\n\t\t   the eof message is enqueued.  For instance, if\n\t\t   a poll returns POLLHUP on the incoming task pipe,\n\t\t   put there are no outgoing message buffers available,\n\t\t   the slurmstepd will start spinning. */\n\t\tmsg = alloc_io_buf();\n\t}\n\n\theader.type = out->type;\n\theader.ltaskid = out->ltaskid;\n\theader.gtaskid = out->gtaskid;\n\theader.length = 0; /* eof */\n\n\tpackbuf = create_buf(msg->data, io_hdr_packed_size());\n\tif (!packbuf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn;\t/* Fix for CLANG false positive error */\n\t}\n\n\tio_hdr_pack(&header, packbuf);\n\tmsg->length = io_hdr_packed_size() + header.length;\n\tmsg->ref_count = 0; /* make certain it is initialized */\n\n\t/* free the Buf packbuf, but not the memory to which it points */\n\tpackbuf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(packbuf);\n\n\t/* Add eof message to the msg_queue of all clients */\n\tclients = list_iterator_create(out->job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tdebug5(\"======================== Enqueued eof message\");\n\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\t\t/* Send eof message to all clients.\n\t\t */\n\n\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\tmsg->ref_count++;\n\t}\n\tlist_iterator_destroy(clients);\n\n\tdebug4(\"Leaving  _send_eof_msg\");\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [
            "#define CLIENT_IO_MAGIC  0x10102"
          ],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static bool _task_writable(eio_obj_t *);",
            "static bool _task_readable(eio_obj_t *);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _send_eof_msg(struct task_read_info *out);",
            "static void *_io_thr(void *arg);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void *_io_thr(void *arg);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_send_eof_msg(struct task_read_info *out)\n{\n\tstruct client_io_info *client;\n\tstruct io_buf *msg = NULL;\n\teio_obj_t *eio;\n\tListIterator clients;\n\tstruct slurm_io_header header;\n\tBuf packbuf;\n\n\tdebug4(\"Entering _send_eof_msg\");\n\tout->eof_msg_sent = true;\n\n\tif (_outgoing_buf_free(out->job)) {\n\t\tmsg = list_dequeue(out->job->free_outgoing);\n\t} else {\n\t\t/* eof message must be allowed to allocate new memory\n\t\t   because _task_readable() will return \"true\" until\n\t\t   the eof message is enqueued.  For instance, if\n\t\t   a poll returns POLLHUP on the incoming task pipe,\n\t\t   put there are no outgoing message buffers available,\n\t\t   the slurmstepd will start spinning. */\n\t\tmsg = alloc_io_buf();\n\t}\n\n\theader.type = out->type;\n\theader.ltaskid = out->ltaskid;\n\theader.gtaskid = out->gtaskid;\n\theader.length = 0; /* eof */\n\n\tpackbuf = create_buf(msg->data, io_hdr_packed_size());\n\tif (!packbuf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn;\t/* Fix for CLANG false positive error */\n\t}\n\n\tio_hdr_pack(&header, packbuf);\n\tmsg->length = io_hdr_packed_size() + header.length;\n\tmsg->ref_count = 0; /* make certain it is initialized */\n\n\t/* free the Buf packbuf, but not the memory to which it points */\n\tpackbuf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(packbuf);\n\n\t/* Add eof message to the msg_queue of all clients */\n\tclients = list_iterator_create(out->job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tdebug5(\"======================== Enqueued eof message\");\n\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\t\t/* Send eof message to all clients.\n\t\t */\n\n\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\tmsg->ref_count++;\n\t}\n\tlist_iterator_destroy(clients);\n\n\tdebug4(\"Leaving  _send_eof_msg\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "cbuf_used",
          "args": [
            "out->buf"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_route_msg_task_to_client",
          "args": [
            "obj"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "_route_msg_task_to_client",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1311-1360",
          "snippet": "static void\n_route_msg_task_to_client(eio_obj_t *obj)\n{\n\tstruct task_read_info *out = (struct task_read_info *)obj->arg;\n\tstruct client_io_info *client;\n\tstruct io_buf *msg = NULL;\n\teio_obj_t *eio;\n\tListIterator clients;\n\n\t/* Pack task output into messages for transfer to a client */\n\twhile (cbuf_used(out->buf) > 0\n\t       && _outgoing_buf_free(out->job)) {\n\t\tdebug5(\"cbuf_used = %d\", cbuf_used(out->buf));\n\t\tmsg = _task_build_message(out, out->job, out->buf);\n\t\tif (msg == NULL)\n\t\t\treturn;\n\n\t\t/* Add message to the msg_queue of all clients */\n\t\tclients = list_iterator_create(out->job->clients);\n\t\twhile ((eio = list_next(clients))) {\n\t\t\tclient = (struct client_io_info *)eio->arg;\n\t\t\tif (client->out_eof == true)\n\t\t\t\tcontinue;\n\n\t\t\t/* Some clients only take certain I/O streams */\n\t\t\tif (out->type==SLURM_IO_STDOUT) {\n\t\t\t\tif (client->ltaskid_stdout != -1 &&\n\t\t\t\t    client->ltaskid_stdout != out->ltaskid)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (out->type==SLURM_IO_STDERR) {\n\t\t\t\tif (client->ltaskid_stderr != -1 &&\n\t\t\t\t    client->ltaskid_stderr != out->ltaskid)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug5(\"======================== Enqueued message\");\n\t\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\t\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\t\tmsg->ref_count++;\n\t\t}\n\t\tlist_iterator_destroy(clients);\n\n\t\t/* Update the outgoing message cache */\n\t\tif (list_enqueue(out->job->outgoing_cache, msg)) {\n\t\t\tmsg->ref_count++;\n\t\t\t_shrink_msg_cache(out->job->outgoing_cache, out->job);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [
            "#define CLIENT_IO_MAGIC  0x10102"
          ],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static bool _task_writable(eio_obj_t *);",
            "static bool _task_readable(eio_obj_t *);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _send_eof_msg(struct task_read_info *out);",
            "static void *_io_thr(void *arg);",
            "static void _route_msg_task_to_client(eio_obj_t *obj);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_route_msg_task_to_client(eio_obj_t *obj)\n{\n\tstruct task_read_info *out = (struct task_read_info *)obj->arg;\n\tstruct client_io_info *client;\n\tstruct io_buf *msg = NULL;\n\teio_obj_t *eio;\n\tListIterator clients;\n\n\t/* Pack task output into messages for transfer to a client */\n\twhile (cbuf_used(out->buf) > 0\n\t       && _outgoing_buf_free(out->job)) {\n\t\tdebug5(\"cbuf_used = %d\", cbuf_used(out->buf));\n\t\tmsg = _task_build_message(out, out->job, out->buf);\n\t\tif (msg == NULL)\n\t\t\treturn;\n\n\t\t/* Add message to the msg_queue of all clients */\n\t\tclients = list_iterator_create(out->job->clients);\n\t\twhile ((eio = list_next(clients))) {\n\t\t\tclient = (struct client_io_info *)eio->arg;\n\t\t\tif (client->out_eof == true)\n\t\t\t\tcontinue;\n\n\t\t\t/* Some clients only take certain I/O streams */\n\t\t\tif (out->type==SLURM_IO_STDOUT) {\n\t\t\t\tif (client->ltaskid_stdout != -1 &&\n\t\t\t\t    client->ltaskid_stdout != out->ltaskid)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (out->type==SLURM_IO_STDERR) {\n\t\t\t\tif (client->ltaskid_stderr != -1 &&\n\t\t\t\t    client->ltaskid_stderr != out->ltaskid)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tdebug5(\"======================== Enqueued message\");\n\t\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\t\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\t\tmsg->ref_count++;\n\t\t}\n\t\tlist_iterator_destroy(clients);\n\n\t\t/* Update the outgoing message cache */\n\t\tif (list_enqueue(out->job->outgoing_cache, msg)) {\n\t\t\tmsg->ref_count++;\n\t\t\t_shrink_msg_cache(out->job->outgoing_cache, out->job);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"************************ %d bytes read from task %s\"",
            "rc",
            "out->type == SLURM_IO_STDOUT ? \"STDOUT\" : \"STDERR\""
          ],
          "line": 797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  got eof on task\""
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  error in _task_read: %m\""
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"_task_read returned EAGAIN\""
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbuf_write_from_fd",
          "args": [
            "out->buf",
            "obj->fd",
            "len",
            "NULL"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbuf_free",
          "args": [
            "out->buf"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"Entering _task_read for obj %zx\"",
            "(size_t)obj"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "out->magic == TASK_OUT_MAGIC"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define TASK_OUT_MAGIC  0x10103\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic int\n_task_read(eio_obj_t *obj, List objs)\n{\n\tstruct task_read_info *out = (struct task_read_info *)obj->arg;\n\tint len;\n\tint rc = -1;\n\n\txassert(out->magic == TASK_OUT_MAGIC);\n\n\tdebug4(\"Entering _task_read for obj %zx\", (size_t)obj);\n\tlen = cbuf_free(out->buf);\n\tif (len > 0 && !out->eof) {\nagain:\n\t\tif ((rc = cbuf_write_from_fd(out->buf, obj->fd, len, NULL))\n\t\t    < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto again;\n\t\t\tif ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {\n\t\t\t\tdebug5(\"_task_read returned EAGAIN\");\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\t\t\tdebug5(\"  error in _task_read: %m\");\n\t\t}\n\t\tif (rc <= 0) {  /* got eof */\n\t\t\tdebug5(\"  got eof on task\");\n\t\t\tout->eof = true;\n\t\t}\n\t}\n\n\tdebug5(\"************************ %d bytes read from task %s\", rc,\n\t       out->type == SLURM_IO_STDOUT ? \"STDOUT\" : \"STDERR\");\n\n\t/*\n\t * Put the message in client outgoing queues\n\t */\n\t_route_msg_task_to_client(obj);\n\n\t/*\n\t * Send the eof message\n\t */\n\tif (cbuf_used(out->buf) == 0 && out->eof && !out->eof_msg_sent) {\n\t\t_send_eof_msg(out);\n\t}\n\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "_task_readable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "742-761",
    "snippet": "static bool\n_task_readable(eio_obj_t *obj)\n{\n\tstruct task_read_info *out = (struct task_read_info *)obj->arg;\n\n\tdebug5(\"Called _task_readable, task %d, %s\", out->gtaskid,\n\t       out->type == SLURM_IO_STDOUT ? \"STDOUT\" : \"STDERR\");\n\n\tif (out->eof_msg_sent) {\n\t\tdebug5(\"  false, eof message sent\");\n\t\treturn false;\n\t}\n\tif (cbuf_free(out->buf) > 0) {\n\t\tdebug5(\"  cbuf_free = %d\", cbuf_free(out->buf));\n\t\treturn true;\n\t}\n\n\tdebug5(\"  false\");\n\treturn false;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static bool _task_writable(eio_obj_t *);",
      "static bool _task_readable(eio_obj_t *);",
      "static void _send_eof_msg(struct task_read_info *out);",
      "static void *_io_thr(void *arg);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  false\""
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  cbuf_free = %d\"",
            "cbuf_free(out->buf)"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbuf_free",
          "args": [
            "out->buf"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbuf_free",
          "args": [
            "out->buf"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  false, eof message sent\""
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"Called _task_readable, task %d, %s\"",
            "out->gtaskid",
            "out->type == SLURM_IO_STDOUT ? \"STDOUT\" : \"STDERR\""
          ],
          "line": 747
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic bool\n_task_readable(eio_obj_t *obj)\n{\n\tstruct task_read_info *out = (struct task_read_info *)obj->arg;\n\n\tdebug5(\"Called _task_readable, task %d, %s\", out->gtaskid,\n\t       out->type == SLURM_IO_STDOUT ? \"STDOUT\" : \"STDERR\");\n\n\tif (out->eof_msg_sent) {\n\t\tdebug5(\"  false, eof message sent\");\n\t\treturn false;\n\t}\n\tif (cbuf_free(out->buf) > 0) {\n\t\tdebug5(\"  cbuf_free = %d\", cbuf_free(out->buf));\n\t\treturn true;\n\t}\n\n\tdebug5(\"  false\");\n\treturn false;\n}"
  },
  {
    "function_name": "_create_task_out_eio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "716-740",
    "snippet": "static eio_obj_t *\n_create_task_out_eio(int fd, uint16_t type,\n\t\t     stepd_step_rec_t *job, stepd_step_task_info_t *task)\n{\n\tstruct task_read_info *out = NULL;\n\teio_obj_t *eio = NULL;\n\n\tout = (struct task_read_info *)xmalloc(sizeof(struct task_read_info));\n#ifndef NDEBUG\n\tout->magic = TASK_OUT_MAGIC;\n#endif\n\tout->type = type;\n\tout->gtaskid = task->gtid;\n\tout->ltaskid = task->id;\n\tout->job = job;\n\tout->buf = cbuf_create(MAX_MSG_LEN, MAX_MSG_LEN*4);\n\tout->eof = false;\n\tout->eof_msg_sent = false;\n\tif (cbuf_opt_set(out->buf, CBUF_OPT_OVERWRITE, CBUF_NO_DROP) == -1)\n\t\terror(\"setting cbuf options\");\n\n\teio = eio_obj_create(fd, &task_read_ops, (void *)out);\n\n\treturn eio;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define TASK_OUT_MAGIC  0x10103"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static bool _task_writable(eio_obj_t *);",
      "static bool _task_readable(eio_obj_t *);",
      "struct io_operations task_read_ops = {\n\t.readable = &_task_readable,\n\t.handle_read = &_task_read,\n};",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _send_eof_msg(struct task_read_info *out);",
      "static struct io_buf *_task_build_message(struct task_read_info *out,\n\t\t\t\t\t  stepd_step_rec_t *job, cbuf_t cbuf);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eio_obj_create",
          "args": [
            "fd",
            "&task_read_ops",
            "(void *)out"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"setting cbuf options\""
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbuf_opt_set",
          "args": [
            "out->buf",
            "CBUF_OPT_OVERWRITE",
            "CBUF_NO_DROP"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cbuf_create",
          "args": [
            "MAX_MSG_LEN",
            "MAX_MSG_LEN*4"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(struct task_read_info)"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define TASK_OUT_MAGIC  0x10103\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstruct io_operations task_read_ops = {\n\t.readable = &_task_readable,\n\t.handle_read = &_task_read,\n};\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic struct io_buf *_task_build_message(struct task_read_info *out,\n\t\t\t\t\t  stepd_step_rec_t *job, cbuf_t cbuf);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic eio_obj_t *\n_create_task_out_eio(int fd, uint16_t type,\n\t\t     stepd_step_rec_t *job, stepd_step_task_info_t *task)\n{\n\tstruct task_read_info *out = NULL;\n\teio_obj_t *eio = NULL;\n\n\tout = (struct task_read_info *)xmalloc(sizeof(struct task_read_info));\n#ifndef NDEBUG\n\tout->magic = TASK_OUT_MAGIC;\n#endif\n\tout->type = type;\n\tout->gtaskid = task->gtid;\n\tout->ltaskid = task->id;\n\tout->job = job;\n\tout->buf = cbuf_create(MAX_MSG_LEN, MAX_MSG_LEN*4);\n\tout->eof = false;\n\tout->eof_msg_sent = false;\n\tif (cbuf_opt_set(out->buf, CBUF_OPT_OVERWRITE, CBUF_NO_DROP) == -1)\n\t\terror(\"setting cbuf options\");\n\n\teio = eio_obj_create(fd, &task_read_ops, (void *)out);\n\n\treturn eio;\n}"
  },
  {
    "function_name": "_task_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "652-708",
    "snippet": "static int\n_task_write(eio_obj_t *obj, List objs)\n{\n\tstruct task_write_info *in = (struct task_write_info *) obj->arg;\n\tvoid *buf;\n\tint n;\n\n\tdebug4(\"Entering _task_write\");\n\txassert(in->magic == TASK_IN_MAGIC);\n\n\t/*\n\t * If we aren't already in the middle of sending a message, get the\n\t * next message from the queue.\n\t */\n\tif (in->msg == NULL) {\n\t\tin->msg = list_dequeue(in->msg_queue);\n\t\tif (in->msg == NULL) {\n\t\t\tdebug5(\"_task_write: nothing in the queue\");\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tif (in->msg->length == 0) { /* eof message */\n\t\t\tclose(obj->fd);\n\t\t\tobj->fd = -1;\n\t\t\t_free_incoming_msg(in->msg, in->job);\n\t\t\tin->msg = NULL;\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tin->remaining = in->msg->length;\n\t}\n\n\t/*\n\t * Write message to pipe.\n\t */\n\tbuf = in->msg->data + (in->msg->length - in->remaining);\nagain:\n\tif ((n = write(obj->fd, buf, in->remaining)) < 0) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\telse if (errno == EAGAIN || errno == EWOULDBLOCK)\n\t\t\treturn SLURM_SUCCESS;\n\t\telse {\n\t\t\tclose(obj->fd);\n\t\t\tobj->fd = -1;\n\t\t\t_free_incoming_msg(in->msg, in->job);\n\t\t\tin->msg = NULL;\n\t\t\treturn SLURM_ERROR;\n\t\t}\n\t}\n\tin->remaining -= n;\n\tif (in->remaining > 0)\n\t\treturn SLURM_SUCCESS;\n\n\t_free_incoming_msg(in->msg, in->job);\n\tin->msg = NULL;\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define TASK_IN_MAGIC  0x10103"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static int  _client_read(eio_obj_t *, List);",
      "static int  _client_write(eio_obj_t *, List);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static int  _local_file_write(eio_obj_t *, List);",
      "static bool _task_writable(eio_obj_t *);",
      "static int  _task_write(eio_obj_t *, List);",
      "static int _task_write_error(eio_obj_t *obj, List objs);",
      "static bool _task_readable(eio_obj_t *);",
      "static int  _task_read(eio_obj_t *, List);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void *_io_thr(void *arg);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_free_incoming_msg",
          "args": [
            "in->msg",
            "in->job"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "_free_incoming_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1362-1373",
          "snippet": "static void\n_free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_incoming, msg);\n\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int  _task_read(eio_obj_t *, List);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_incoming, msg);\n\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "obj->fd"
          ],
          "line": 693
        },
        "resolved": true,
        "details": {
          "function_name": "io_close_local_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1463-1487",
          "snippet": "void\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static bool _task_writable(eio_obj_t *);",
            "static bool _task_readable(eio_obj_t *);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void *_io_thr(void *arg);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nvoid\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "obj->fd",
            "buf",
            "in->remaining"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "_file_write_content",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcgroup.c",
          "lines": "1116-1147",
          "snippet": "int _file_write_content(char* file_path, char* content, size_t csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\t/* open file for writing */\n\tfd = open(file_path, O_WRONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for writing : %m\",\n\t\t\t__func__, file_path);\n\t\treturn XCGROUP_ERROR;\n\t}\n\n\t/* write content */\n\tdo {\n\t\trc = write(fd, content, csize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* check read size */\n\tif (rc < csize) {\n\t\tdebug2(\"%s: unable to write %lu bytes to file '%s' : %m\",\n\t\t\t__func__, (long unsigned int) csize, file_path);\n\t\tfstatus = XCGROUP_ERROR;\n\t} else\n\t\tfstatus = XCGROUP_SUCCESS;\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}",
          "includes": [
            "#include \"xcgroup.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "size_t _file_getsize(int fd);",
            "int _file_read_content(char* file_path, char** content, size_t *csize);",
            "int _file_write_content(char* file_path, char* content, size_t csize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcgroup.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <sys/mount.h>\n#include <dirent.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nsize_t _file_getsize(int fd);\nint _file_read_content(char* file_path, char** content, size_t *csize);\nint _file_write_content(char* file_path, char* content, size_t csize);\n\nint _file_write_content(char* file_path, char* content, size_t csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\t/* open file for writing */\n\tfd = open(file_path, O_WRONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for writing : %m\",\n\t\t\t__func__, file_path);\n\t\treturn XCGROUP_ERROR;\n\t}\n\n\t/* write content */\n\tdo {\n\t\trc = write(fd, content, csize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* check read size */\n\tif (rc < csize) {\n\t\tdebug2(\"%s: unable to write %lu bytes to file '%s' : %m\",\n\t\t\t__func__, (long unsigned int) csize, file_path);\n\t\tfstatus = XCGROUP_ERROR;\n\t} else\n\t\tfstatus = XCGROUP_SUCCESS;\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"_task_write: nothing in the queue\""
          ],
          "line": 669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_dequeue",
          "args": [
            "in->msg_queue"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "in->magic == TASK_IN_MAGIC"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"Entering _task_write\""
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define TASK_IN_MAGIC  0x10103\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic int\n_task_write(eio_obj_t *obj, List objs)\n{\n\tstruct task_write_info *in = (struct task_write_info *) obj->arg;\n\tvoid *buf;\n\tint n;\n\n\tdebug4(\"Entering _task_write\");\n\txassert(in->magic == TASK_IN_MAGIC);\n\n\t/*\n\t * If we aren't already in the middle of sending a message, get the\n\t * next message from the queue.\n\t */\n\tif (in->msg == NULL) {\n\t\tin->msg = list_dequeue(in->msg_queue);\n\t\tif (in->msg == NULL) {\n\t\t\tdebug5(\"_task_write: nothing in the queue\");\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tif (in->msg->length == 0) { /* eof message */\n\t\t\tclose(obj->fd);\n\t\t\tobj->fd = -1;\n\t\t\t_free_incoming_msg(in->msg, in->job);\n\t\t\tin->msg = NULL;\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tin->remaining = in->msg->length;\n\t}\n\n\t/*\n\t * Write message to pipe.\n\t */\n\tbuf = in->msg->data + (in->msg->length - in->remaining);\nagain:\n\tif ((n = write(obj->fd, buf, in->remaining)) < 0) {\n\t\tif (errno == EINTR)\n\t\t\tgoto again;\n\t\telse if (errno == EAGAIN || errno == EWOULDBLOCK)\n\t\t\treturn SLURM_SUCCESS;\n\t\telse {\n\t\t\tclose(obj->fd);\n\t\t\tobj->fd = -1;\n\t\t\t_free_incoming_msg(in->msg, in->job);\n\t\t\tin->msg = NULL;\n\t\t\treturn SLURM_ERROR;\n\t\t}\n\t}\n\tin->remaining -= n;\n\tif (in->remaining > 0)\n\t\treturn SLURM_SUCCESS;\n\n\t_free_incoming_msg(in->msg, in->job);\n\tin->msg = NULL;\n\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "_task_write_error",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "641-650",
    "snippet": "static int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static int  _client_read(eio_obj_t *, List);",
      "static int  _client_write(eio_obj_t *, List);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static int  _local_file_write(eio_obj_t *, List);",
      "static bool _task_writable(eio_obj_t *);",
      "static int  _task_write(eio_obj_t *, List);",
      "static int _task_write_error(eio_obj_t *obj, List objs);",
      "static bool _task_readable(eio_obj_t *);",
      "static int  _task_read(eio_obj_t *, List);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "close",
          "args": [
            "obj->fd"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "io_close_local_fds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1463-1487",
          "snippet": "void\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static bool _task_writable(eio_obj_t *);",
            "static bool _task_readable(eio_obj_t *);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void *_io_thr(void *arg);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nvoid\nio_close_local_fds(stepd_step_rec_t *job)\n{\n\tListIterator clients;\n\teio_obj_t *eio;\n\tint rc;\n\tstruct client_io_info *client;\n\n\tif (job == NULL || job->clients == NULL)\n\t\treturn;\n\n\tclients = list_iterator_create(job->clients);\n\twhile((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->is_local_file) {\n\t\t\tif (eio->fd >= 0) {\n\t\t\t\tdo {\n\t\t\t\t\trc = close(eio->fd);\n\t\t\t\t} while (rc == -1 && errno == EINTR);\n\t\t\t\teio->fd = -1;\n\t\t\t}\n\t\t}\n\t}\n\tlist_iterator_destroy(clients);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"Called _task_write_error, closing fd %d\"",
            "obj->fd"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic int\n_task_write_error(eio_obj_t *obj, List objs)\n{\n\tdebug4(\"Called _task_write_error, closing fd %d\", obj->fd);\n\n\tclose(obj->fd);\n\tobj->fd = -1;\n\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "_task_writable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "620-639",
    "snippet": "static bool\n_task_writable(eio_obj_t *obj)\n{\n\tstruct task_write_info *t = (struct task_write_info *) obj->arg;\n\n\tdebug5(\"Called _task_writable\");\n\n\tif (obj->fd == -1) {\n\t\tdebug5(\"  false, fd == -1\");\n\t\treturn false;\n\t}\n\n\tif (t->msg != NULL || list_count(t->msg_queue) > 0) {\n\t\tdebug5(\"  true, list_count = %d\", list_count(t->msg_queue));\n\t\treturn true;\n\t}\n\n\tdebug5(\"  false (list_count = %d)\", list_count(t->msg_queue));\n\treturn false;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static bool _task_writable(eio_obj_t *);",
      "static bool _task_readable(eio_obj_t *);",
      "static void *_io_thr(void *arg);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  false (list_count = %d)\"",
            "list_count(t->msg_queue)"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_count",
          "args": [
            "t->msg_queue"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  true, list_count = %d\"",
            "list_count(t->msg_queue)"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_count",
          "args": [
            "t->msg_queue"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_count",
          "args": [
            "t->msg_queue"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  false, fd == -1\""
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"Called _task_writable\""
          ],
          "line": 625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic bool\n_task_writable(eio_obj_t *obj)\n{\n\tstruct task_write_info *t = (struct task_write_info *) obj->arg;\n\n\tdebug5(\"Called _task_writable\");\n\n\tif (obj->fd == -1) {\n\t\tdebug5(\"  false, fd == -1\");\n\t\treturn false;\n\t}\n\n\tif (t->msg != NULL || list_count(t->msg_queue) > 0) {\n\t\tdebug5(\"  true, list_count = %d\", list_count(t->msg_queue));\n\t\treturn true;\n\t}\n\n\tdebug5(\"  false (list_count = %d)\", list_count(t->msg_queue));\n\treturn false;\n}"
  },
  {
    "function_name": "_create_task_in_eio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "600-618",
    "snippet": "static eio_obj_t *\n_create_task_in_eio(int fd, stepd_step_rec_t *job)\n{\n\tstruct task_write_info *t = NULL;\n\teio_obj_t *eio = NULL;\n\n\tt = (struct task_write_info *)xmalloc(sizeof(struct task_write_info));\n#ifndef NDEBUG\n\tt->magic = TASK_IN_MAGIC;\n#endif\n\tt->job = job;\n\tt->msg_queue = list_create(NULL); /* FIXME! Add destructor */\n\tt->msg = NULL;\n\tt->remaining = 0;\n\n\teio = eio_obj_create(fd, &task_write_ops, (void *)t);\n\n\treturn eio;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define TASK_IN_MAGIC  0x10103"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static bool _task_writable(eio_obj_t *);",
      "struct io_operations task_write_ops = {\n\t.writable = &_task_writable,\n\t.handle_write = &_task_write,\n\t.handle_error = &_task_write_error,\n};",
      "static bool _task_readable(eio_obj_t *);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "eio_obj_create",
          "args": [
            "fd",
            "&task_write_ops",
            "(void *)t"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_create",
          "args": [
            "NULL"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "_script_list_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "178-210",
          "snippet": "static List _script_list_create (const char *pattern)\n{\n\tglob_t gl;\n\tsize_t i;\n\tList l = NULL;\n\n\tif (pattern == NULL)\n\t\treturn (NULL);\n\n\tint rc = glob (pattern, GLOB_ERR, _ef, &gl);\n\tswitch (rc) {\n\tcase 0:\n\t\tl = list_create ((ListDelF) _xfree_f);\n\t\tfor (i = 0; i < gl.gl_pathc; i++)\n\t\t\tlist_push (l, xstrdup (gl.gl_pathv[i]));\n\t\tbreak;\n\tcase GLOB_NOMATCH:\n\t\tbreak;\n\tcase GLOB_NOSPACE:\n\t\terror (\"run_script: glob(3): Out of memory\");\n\t\tbreak;\n\tcase GLOB_ABORTED:\n\t\terror (\"run_script: cannot read dir %s: %m\", pattern);\n\t\tbreak;\n\tdefault:\n\t\terror (\"Unknown glob(3) return code = %d\", rc);\n\t\tbreak;\n\t}\n\n\tglobfree (&gl);\n\n\treturn l;\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic List _script_list_create (const char *pattern)\n{\n\tglob_t gl;\n\tsize_t i;\n\tList l = NULL;\n\n\tif (pattern == NULL)\n\t\treturn (NULL);\n\n\tint rc = glob (pattern, GLOB_ERR, _ef, &gl);\n\tswitch (rc) {\n\tcase 0:\n\t\tl = list_create ((ListDelF) _xfree_f);\n\t\tfor (i = 0; i < gl.gl_pathc; i++)\n\t\t\tlist_push (l, xstrdup (gl.gl_pathv[i]));\n\t\tbreak;\n\tcase GLOB_NOMATCH:\n\t\tbreak;\n\tcase GLOB_NOSPACE:\n\t\terror (\"run_script: glob(3): Out of memory\");\n\t\tbreak;\n\tcase GLOB_ABORTED:\n\t\terror (\"run_script: cannot read dir %s: %m\", pattern);\n\t\tbreak;\n\tdefault:\n\t\terror (\"Unknown glob(3) return code = %d\", rc);\n\t\tbreak;\n\t}\n\n\tglobfree (&gl);\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xmalloc",
          "args": [
            "sizeof(struct task_write_info)"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define TASK_IN_MAGIC  0x10103\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstruct io_operations task_write_ops = {\n\t.writable = &_task_writable,\n\t.handle_write = &_task_write,\n\t.handle_error = &_task_write_error,\n};\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic eio_obj_t *\n_create_task_in_eio(int fd, stepd_step_rec_t *job)\n{\n\tstruct task_write_info *t = NULL;\n\teio_obj_t *eio = NULL;\n\n\tt = (struct task_write_info *)xmalloc(sizeof(struct task_write_info));\n#ifndef NDEBUG\n\tt->magic = TASK_IN_MAGIC;\n#endif\n\tt->job = job;\n\tt->msg_queue = list_create(NULL); /* FIXME! Add destructor */\n\tt->msg = NULL;\n\tt->remaining = 0;\n\n\teio = eio_obj_create(fd, &task_write_ops, (void *)t);\n\n\treturn eio;\n}"
  },
  {
    "function_name": "_local_file_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "527-589",
    "snippet": "static int\n_local_file_write(eio_obj_t *obj, List objs)\n{\n\tstruct client_io_info *client = (struct client_io_info *) obj->arg;\n\tvoid *buf;\n\tint n;\n\tstruct slurm_io_header header;\n\tBuf header_tmp_buf;\n\n\txassert(client->magic == CLIENT_IO_MAGIC);\n\t/*\n\t * If we aren't already in the middle of sending a message, get the\n\t * next message from the queue.\n\t */\n\tif (client->out_msg == NULL) {\n\t\tclient->out_msg = list_dequeue(client->msg_queue);\n\t\tif (client->out_msg == NULL) {\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tclient->out_remaining = client->out_msg->length -\n\t\t\t\t\tio_hdr_packed_size();\n\t}\n\n\t/* This code to make a buffer, fill it, unpack its contents, and free\n\t   it is just used to read the header to get the global task id. */\n\theader_tmp_buf = create_buf(client->out_msg->data,\n\t\t\t\t    client->out_msg->length);\n\tif (!header_tmp_buf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn SLURM_ERROR;\t/* Fix CLANG false positive error */\n\t}\n\tio_hdr_unpack(&header, header_tmp_buf);\n\theader_tmp_buf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(header_tmp_buf);\n\n\t/* A zero-length message indicates the end of a stream from one\n\t   of the tasks.  Just free the message and return. */\n\tif (header.length == 0) {\n\t\t_free_outgoing_msg(client->out_msg, client->job);\n\t\tclient->out_msg = NULL;\n\t\treturn SLURM_SUCCESS;\n\t}\n\n\t/* Write the message to the file. */\n\tbuf = client->out_msg->data +\n\t\t(client->out_msg->length - client->out_remaining);\n\n\tn = write_labelled_message(obj->fd, buf, client->out_remaining,\n\t\t\t\t   header.gtaskid, client->labelio,\n\t\t\t\t   client->label_width);\n\tif (n < 0) {\n\t\tclient->out_eof = true;\n\t\t_free_all_outgoing_msgs(client->msg_queue, client->job);\n\t\treturn SLURM_ERROR;\n\t}\n\n\tclient->out_remaining -= n;\n\tif (client->out_remaining == 0) {\n\t\t_free_outgoing_msg(client->out_msg, client->job);\n\t\tclient->out_msg = NULL;\n\t}\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define CLIENT_IO_MAGIC  0x10102"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static int  _client_read(eio_obj_t *, List);",
      "static int  _client_write(eio_obj_t *, List);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static int  _local_file_write(eio_obj_t *, List);",
      "static bool _task_writable(eio_obj_t *);",
      "static int  _task_write(eio_obj_t *, List);",
      "static int _task_write_error(eio_obj_t *obj, List objs);",
      "static bool _task_readable(eio_obj_t *);",
      "static int  _task_read(eio_obj_t *, List);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void *_io_thr(void *arg);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_free_outgoing_msg",
          "args": [
            "client->out_msg",
            "client->job"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "_free_outgoing_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1375-1403",
          "snippet": "static void\n_free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tint i;\n\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_outgoing, msg);\n\n\t\t/* Try packing messages from tasks' output cbufs */\n\t\tif (job->task == NULL)\n\t\t\treturn;\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i]->err != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->err);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (job->task[i]->out != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->out);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int  _task_read(eio_obj_t *, List);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _send_eof_msg(struct task_read_info *out);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tint i;\n\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_outgoing, msg);\n\n\t\t/* Try packing messages from tasks' output cbufs */\n\t\tif (job->task == NULL)\n\t\t\treturn;\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i]->err != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->err);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (job->task[i]->out != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->out);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "_free_all_outgoing_msgs",
          "args": [
            "client->msg_queue",
            "client->job"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "_free_all_outgoing_msgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1405-1416",
          "snippet": "static void\n_free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job)\n{\n\tListIterator msgs;\n\tstruct io_buf *msg;\n\n\tmsgs = list_iterator_create(msg_queue);\n\twhile((msg = list_next(msgs))) {\n\t\t_free_outgoing_msg(msg, job);\n\t}\n\tlist_iterator_destroy(msgs);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int  _task_read(eio_obj_t *, List);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job)\n{\n\tListIterator msgs;\n\tstruct io_buf *msg;\n\n\tmsgs = list_iterator_create(msg_queue);\n\twhile((msg = list_next(msgs))) {\n\t\t_free_outgoing_msg(msg, job);\n\t}\n\tlist_iterator_destroy(msgs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "write_labelled_message",
          "args": [
            "obj->fd",
            "buf",
            "client->out_remaining",
            "header.gtaskid",
            "client->labelio",
            "client->label_width"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_buf",
          "args": [
            "header_tmp_buf"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_unpack",
          "args": [
            "&header",
            "header_tmp_buf"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal",
          "args": [
            "\"Failure to allocate memory for a message header\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_buf",
          "args": [
            "client->out_msg->data",
            "client->out_msg->length"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_packed_size",
          "args": [],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_dequeue",
          "args": [
            "client->msg_queue"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "client->magic == CLIENT_IO_MAGIC"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic int\n_local_file_write(eio_obj_t *obj, List objs)\n{\n\tstruct client_io_info *client = (struct client_io_info *) obj->arg;\n\tvoid *buf;\n\tint n;\n\tstruct slurm_io_header header;\n\tBuf header_tmp_buf;\n\n\txassert(client->magic == CLIENT_IO_MAGIC);\n\t/*\n\t * If we aren't already in the middle of sending a message, get the\n\t * next message from the queue.\n\t */\n\tif (client->out_msg == NULL) {\n\t\tclient->out_msg = list_dequeue(client->msg_queue);\n\t\tif (client->out_msg == NULL) {\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tclient->out_remaining = client->out_msg->length -\n\t\t\t\t\tio_hdr_packed_size();\n\t}\n\n\t/* This code to make a buffer, fill it, unpack its contents, and free\n\t   it is just used to read the header to get the global task id. */\n\theader_tmp_buf = create_buf(client->out_msg->data,\n\t\t\t\t    client->out_msg->length);\n\tif (!header_tmp_buf) {\n\t\tfatal(\"Failure to allocate memory for a message header\");\n\t\treturn SLURM_ERROR;\t/* Fix CLANG false positive error */\n\t}\n\tio_hdr_unpack(&header, header_tmp_buf);\n\theader_tmp_buf->head = NULL;\t/* CLANG false positive bug here */\n\tfree_buf(header_tmp_buf);\n\n\t/* A zero-length message indicates the end of a stream from one\n\t   of the tasks.  Just free the message and return. */\n\tif (header.length == 0) {\n\t\t_free_outgoing_msg(client->out_msg, client->job);\n\t\tclient->out_msg = NULL;\n\t\treturn SLURM_SUCCESS;\n\t}\n\n\t/* Write the message to the file. */\n\tbuf = client->out_msg->data +\n\t\t(client->out_msg->length - client->out_remaining);\n\n\tn = write_labelled_message(obj->fd, buf, client->out_remaining,\n\t\t\t\t   header.gtaskid, client->labelio,\n\t\t\t\t   client->label_width);\n\tif (n < 0) {\n\t\tclient->out_eof = true;\n\t\t_free_all_outgoing_msgs(client->msg_queue, client->job);\n\t\treturn SLURM_ERROR;\n\t}\n\n\tclient->out_remaining -= n;\n\tif (client->out_remaining == 0) {\n\t\t_free_outgoing_msg(client->out_msg, client->job);\n\t\tclient->out_msg = NULL;\n\t}\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "_local_file_writable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "507-521",
    "snippet": "static bool\n_local_file_writable(eio_obj_t *obj)\n{\n\tstruct client_io_info *client = (struct client_io_info *) obj->arg;\n\n\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\tif (client->out_eof == true)\n\t\treturn false;\n\n\tif (client->out_msg != NULL || !list_is_empty(client->msg_queue))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define CLIENT_IO_MAGIC  0x10102"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static bool _task_writable(eio_obj_t *);",
      "static bool _task_readable(eio_obj_t *);",
      "static void *_io_thr(void *arg);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_is_empty",
          "args": [
            "client->msg_queue"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "client->magic == CLIENT_IO_MAGIC"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\n\nstatic bool\n_local_file_writable(eio_obj_t *obj)\n{\n\tstruct client_io_info *client = (struct client_io_info *) obj->arg;\n\n\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\tif (client->out_eof == true)\n\t\treturn false;\n\n\tif (client->out_msg != NULL || !list_is_empty(client->msg_queue))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "_client_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "445-504",
    "snippet": "static int\n_client_write(eio_obj_t *obj, List objs)\n{\n\tstruct client_io_info *client = (struct client_io_info *) obj->arg;\n\tvoid *buf;\n\tint n;\n\n\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\tdebug4(\"Entering _client_write\");\n\n\t/*\n\t * If we aren't already in the middle of sending a message, get the\n\t * next message from the queue.\n\t */\n\tif (client->out_msg == NULL) {\n\t\tclient->out_msg = list_dequeue(client->msg_queue);\n\t\tif (client->out_msg == NULL) {\n\t\t\tdebug5(\"_client_write: nothing in the queue\");\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tdebug5(\"  dequeue successful, client->out_msg->length = %d\",\n\t\t\tclient->out_msg->length);\n\t\tclient->out_remaining = client->out_msg->length;\n\t}\n\n\tdebug5(\"  client->out_remaining = %d\", client->out_remaining);\n\n\t/*\n\t * Write message to socket.\n\t */\n\tbuf = client->out_msg->data +\n\t\t(client->out_msg->length - client->out_remaining);\nagain:\n\tif ((n = write(obj->fd, buf, client->out_remaining)) < 0) {\n\t\tif (errno == EINTR) {\n\t\t\tgoto again;\n\t\t} else if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {\n\t\t\tdebug5(\"_client_write returned EAGAIN\");\n\t\t\treturn SLURM_SUCCESS;\n\t\t} else {\n\t\t\tclient->out_eof = true;\n\t\t\t_free_all_outgoing_msgs(client->msg_queue, client->job);\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t}\n\tif (n < client->out_remaining) {\n\t\terror(\"Only wrote %d of %d bytes to socket\",\n\t\t      n, client->out_remaining);\n\t} else\n\t\tdebug5(\"Wrote %d bytes to socket\", n);\n\tclient->out_remaining -= n;\n\tif (client->out_remaining > 0)\n\t\treturn SLURM_SUCCESS;\n\n\t_free_outgoing_msg(client->out_msg, client->job);\n\tclient->out_msg = NULL;\n\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define CLIENT_IO_MAGIC  0x10102"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static int  _client_read(eio_obj_t *, List);",
      "static int  _client_write(eio_obj_t *, List);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static int  _local_file_write(eio_obj_t *, List);",
      "static bool _task_writable(eio_obj_t *);",
      "static int  _task_write(eio_obj_t *, List);",
      "static int _task_write_error(eio_obj_t *obj, List objs);",
      "static bool _task_readable(eio_obj_t *);",
      "static int  _task_read(eio_obj_t *, List);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void *_io_thr(void *arg);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "_free_outgoing_msg",
          "args": [
            "client->out_msg",
            "client->job"
          ],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "_free_outgoing_msg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1375-1403",
          "snippet": "static void\n_free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tint i;\n\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_outgoing, msg);\n\n\t\t/* Try packing messages from tasks' output cbufs */\n\t\tif (job->task == NULL)\n\t\t\treturn;\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i]->err != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->err);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (job->task[i]->out != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->out);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int  _task_read(eio_obj_t *, List);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _send_eof_msg(struct task_read_info *out);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job)\n{\n\tint i;\n\n\tmsg->ref_count--;\n\tif (msg->ref_count == 0) {\n\t\t/* Put the message back on the free List */\n\t\tlist_enqueue(job->free_outgoing, msg);\n\n\t\t/* Try packing messages from tasks' output cbufs */\n\t\tif (job->task == NULL)\n\t\t\treturn;\n\t\tfor (i = 0; i < job->node_tasks; i++) {\n\t\t\tif (job->task[i]->err != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->err);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (job->task[i]->out != NULL) {\n\t\t\t\t_route_msg_task_to_client(job->task[i]->out);\n\t\t\t\tif (!_outgoing_buf_free(job))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t/* Kick the event IO engine */\n\t\teio_signal_wakeup(job->eio);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"Wrote %d bytes to socket\"",
            "n"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Only wrote %d of %d bytes to socket\"",
            "n",
            "client->out_remaining"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_free_all_outgoing_msgs",
          "args": [
            "client->msg_queue",
            "client->job"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "_free_all_outgoing_msgs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1405-1416",
          "snippet": "static void\n_free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job)\n{\n\tListIterator msgs;\n\tstruct io_buf *msg;\n\n\tmsgs = list_iterator_create(msg_queue);\n\twhile((msg = list_next(msgs))) {\n\t\t_free_outgoing_msg(msg, job);\n\t}\n\tlist_iterator_destroy(msgs);\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int  _client_read(eio_obj_t *, List);",
            "static int  _client_write(eio_obj_t *, List);",
            "static int  _local_file_write(eio_obj_t *, List);",
            "static int  _task_write(eio_obj_t *, List);",
            "static int  _task_read(eio_obj_t *, List);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic void\n_free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job)\n{\n\tListIterator msgs;\n\tstruct io_buf *msg;\n\n\tmsgs = list_iterator_create(msg_queue);\n\twhile((msg = list_next(msgs))) {\n\t\t_free_outgoing_msg(msg, job);\n\t}\n\tlist_iterator_destroy(msgs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"_client_write returned EAGAIN\""
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "write",
          "args": [
            "obj->fd",
            "buf",
            "client->out_remaining"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "_file_write_content",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcgroup.c",
          "lines": "1116-1147",
          "snippet": "int _file_write_content(char* file_path, char* content, size_t csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\t/* open file for writing */\n\tfd = open(file_path, O_WRONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for writing : %m\",\n\t\t\t__func__, file_path);\n\t\treturn XCGROUP_ERROR;\n\t}\n\n\t/* write content */\n\tdo {\n\t\trc = write(fd, content, csize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* check read size */\n\tif (rc < csize) {\n\t\tdebug2(\"%s: unable to write %lu bytes to file '%s' : %m\",\n\t\t\t__func__, (long unsigned int) csize, file_path);\n\t\tfstatus = XCGROUP_ERROR;\n\t} else\n\t\tfstatus = XCGROUP_SUCCESS;\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}",
          "includes": [
            "#include \"xcgroup.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "size_t _file_getsize(int fd);",
            "int _file_read_content(char* file_path, char** content, size_t *csize);",
            "int _file_write_content(char* file_path, char* content, size_t csize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcgroup.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <sys/mount.h>\n#include <dirent.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nsize_t _file_getsize(int fd);\nint _file_read_content(char* file_path, char** content, size_t *csize);\nint _file_write_content(char* file_path, char* content, size_t csize);\n\nint _file_write_content(char* file_path, char* content, size_t csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\t/* open file for writing */\n\tfd = open(file_path, O_WRONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for writing : %m\",\n\t\t\t__func__, file_path);\n\t\treturn XCGROUP_ERROR;\n\t}\n\n\t/* write content */\n\tdo {\n\t\trc = write(fd, content, csize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* check read size */\n\tif (rc < csize) {\n\t\tdebug2(\"%s: unable to write %lu bytes to file '%s' : %m\",\n\t\t\t__func__, (long unsigned int) csize, file_path);\n\t\tfstatus = XCGROUP_ERROR;\n\t} else\n\t\tfstatus = XCGROUP_SUCCESS;\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  client->out_remaining = %d\"",
            "client->out_remaining"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  dequeue successful, client->out_msg->length = %d\"",
            "client->out_msg->length"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"_client_write: nothing in the queue\""
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_dequeue",
          "args": [
            "client->msg_queue"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"Entering _client_write\""
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "client->magic == CLIENT_IO_MAGIC"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic int\n_client_write(eio_obj_t *obj, List objs)\n{\n\tstruct client_io_info *client = (struct client_io_info *) obj->arg;\n\tvoid *buf;\n\tint n;\n\n\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\tdebug4(\"Entering _client_write\");\n\n\t/*\n\t * If we aren't already in the middle of sending a message, get the\n\t * next message from the queue.\n\t */\n\tif (client->out_msg == NULL) {\n\t\tclient->out_msg = list_dequeue(client->msg_queue);\n\t\tif (client->out_msg == NULL) {\n\t\t\tdebug5(\"_client_write: nothing in the queue\");\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tdebug5(\"  dequeue successful, client->out_msg->length = %d\",\n\t\t\tclient->out_msg->length);\n\t\tclient->out_remaining = client->out_msg->length;\n\t}\n\n\tdebug5(\"  client->out_remaining = %d\", client->out_remaining);\n\n\t/*\n\t * Write message to socket.\n\t */\n\tbuf = client->out_msg->data +\n\t\t(client->out_msg->length - client->out_remaining);\nagain:\n\tif ((n = write(obj->fd, buf, client->out_remaining)) < 0) {\n\t\tif (errno == EINTR) {\n\t\t\tgoto again;\n\t\t} else if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) {\n\t\t\tdebug5(\"_client_write returned EAGAIN\");\n\t\t\treturn SLURM_SUCCESS;\n\t\t} else {\n\t\t\tclient->out_eof = true;\n\t\t\t_free_all_outgoing_msgs(client->msg_queue, client->job);\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t}\n\tif (n < client->out_remaining) {\n\t\terror(\"Only wrote %d of %d bytes to socket\",\n\t\t      n, client->out_remaining);\n\t} else\n\t\tdebug5(\"Wrote %d bytes to socket\", n);\n\tclient->out_remaining -= n;\n\tif (client->out_remaining > 0)\n\t\treturn SLURM_SUCCESS;\n\n\t_free_outgoing_msg(client->out_msg, client->job);\n\tclient->out_msg = NULL;\n\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "_client_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "311-440",
    "snippet": "static int\n_client_read(eio_obj_t *obj, List objs)\n{\n\tstruct client_io_info *client = (struct client_io_info *) obj->arg;\n\tvoid *buf;\n\tint n;\n\n\tdebug4(\"Entering _client_read\");\n\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\t/*\n\t * Read the header, if a message read is not already in progress\n\t */\n\tif (client->in_msg == NULL) {\n\t\tif (_incoming_buf_free(client->job)) {\n\t\t\tclient->in_msg =\n\t\t\t\tlist_dequeue(client->job->free_incoming);\n\t\t} else {\n\t\t\tdebug5(\"  _client_read free_incoming is empty\");\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tn = io_hdr_read_fd(obj->fd, &client->header);\n\t\tif (n <= 0) { /* got eof or fatal error */\n\t\t\tdebug5(\"  got eof or error _client_read header, n=%d\", n);\n\t\t\tclient->in_eof = true;\n\t\t\tlist_enqueue(client->job->free_incoming, client->in_msg);\n\t\t\tclient->in_msg = NULL;\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tdebug5(\"client->header.length = %u\", client->header.length);\n\t\tif (client->header.length > MAX_MSG_LEN)\n\t\t\terror(\"Message length of %u exceeds maximum of %u\",\n\t\t\t      client->header.length, MAX_MSG_LEN);\n\t\tclient->in_remaining = client->header.length;\n\t\tclient->in_msg->length = client->header.length;\n\t}\n\n\t/*\n\t * Read the body\n\t */\n\tif (client->header.type == SLURM_IO_CONNECTION_TEST) {\n\t\tif (client->header.length != 0) {\n\t\t\tdebug5(\"  error in _client_read: bad connection test\");\n\t\t\tlist_enqueue(client->job->free_incoming, client->in_msg);\n\t\t\tclient->in_msg = NULL;\n\t\t\treturn SLURM_ERROR;\n\t\t}\n\t\tif (_send_connection_okay_response(client->job)) {\n\t\t\t/*\n\t\t\t * If we get here because of a failed\n\t\t\t * _send_connection_okay_response, it's because of a\n\t\t\t * lack of buffer space in the output queue.  Just\n\t\t\t * keep the current input message client->in_msg in\n\t\t\t * place, and resend on the next call.\n\t\t\t */\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tlist_enqueue(client->job->free_incoming, client->in_msg);\n\t\tclient->in_msg = NULL;\n\t\treturn SLURM_SUCCESS;\n\t} else if (client->header.length == 0) { /* zero length is an eof message */\n\t\tdebug5(\"  got stdin eof message!\");\n\t} else {\n\t\tbuf = client->in_msg->data +\n\t\t\t(client->in_msg->length - client->in_remaining);\n\tagain:\n\t\tif ((n = read(obj->fd, buf, client->in_remaining)) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto again;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n\t\t\t\tdebug5(\"_client_read returned %s\",\n\t\t\t\t\terrno == EAGAIN ? \"EAGAIN\" : \"EWOULDBLOCK\");\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\t\t\tdebug5(\"  error in _client_read: %m\");\n\t\t}\n\t\tif (n <= 0) { /* got eof (or unhandled error) */\n\t\t\tdebug5(\"  got eof on _client_read body\");\n\t\t\tclient->in_eof = true;\n\t\t\tlist_enqueue(client->job->free_incoming, client->in_msg);\n\t\t\tclient->in_msg = NULL;\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tclient->in_remaining -= n;\n\t\tif (client->in_remaining > 0)\n\t\t\treturn SLURM_SUCCESS;\n/* \t\t*(char *)(buf + n) = '\\0'; */\n/* \t\tdebug5(\"\\\"%s\\\"\", buf); */\n\t}\n\n\t/*\n\t * Route the message to its destination(s)\n\t */\n\tif (client->header.type != SLURM_IO_STDIN\n\t    && client->header.type != SLURM_IO_ALLSTDIN) {\n\t\terror(\"Input client->header.type is not valid!\");\n\t\tclient->in_msg = NULL;\n\t\treturn SLURM_ERROR;\n\t} else {\n\t\tint i;\n\t\tstepd_step_task_info_t *task;\n\t\tstruct task_write_info *io;\n\n\t\tclient->in_msg->ref_count = 0;\n\t\tif (client->header.type == SLURM_IO_ALLSTDIN) {\n\t\t\tfor (i = 0; i < client->job->node_tasks; i++) {\n\t\t\t\ttask = client->job->task[i];\n\t\t\t\tio = (struct task_write_info *)task->in->arg;\n\t\t\t\tclient->in_msg->ref_count++;\n\t\t\t\tlist_enqueue(io->msg_queue, client->in_msg);\n\t\t\t}\n\t\t\tdebug5(\"  message ref_count = %d\", client->in_msg->ref_count);\n\t\t} else {\n\t\t\tfor (i = 0; i < client->job->node_tasks; i++) {\n\t\t\t\ttask = client->job->task[i];\n\t\t\t\tif (task->in == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tio = (struct task_write_info *)task->in->arg;\n\t\t\t\tif (task->gtid != client->header.gtaskid)\n\t\t\t\t\tcontinue;\n\t\t\t\tclient->in_msg->ref_count++;\n\t\t\t\tlist_enqueue(io->msg_queue, client->in_msg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tclient->in_msg = NULL;\n\tdebug4(\"Leaving  _client_read\");\n\treturn SLURM_SUCCESS;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define CLIENT_IO_MAGIC  0x10102"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static int  _client_read(eio_obj_t *, List);",
      "static int  _client_write(eio_obj_t *, List);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static int  _local_file_write(eio_obj_t *, List);",
      "static bool _task_writable(eio_obj_t *);",
      "static int  _task_write(eio_obj_t *, List);",
      "static int _task_write_error(eio_obj_t *obj, List objs);",
      "static bool _task_readable(eio_obj_t *);",
      "static int  _task_read(eio_obj_t *, List);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void *_io_thr(void *arg);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"Leaving  _client_read\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "io->msg_queue",
            "client->in_msg"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  message ref_count = %d\"",
            "client->in_msg->ref_count"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "io->msg_queue",
            "client->in_msg"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Input client->header.type is not valid!\""
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "client->job->free_incoming",
            "client->in_msg"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  got eof on _client_read body\""
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  error in _client_read: %m\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"_client_read returned %s\"",
            "errno == EAGAIN ? \"EAGAIN\" : \"EWOULDBLOCK\""
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "obj->fd",
            "buf",
            "client->in_remaining"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "_file_read_content",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/xcgroup.c",
          "lines": "1149-1197",
          "snippet": "int _file_read_content(char* file_path, char** content, size_t *csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\tsize_t fsize;\n\tchar* buf;\n\n\tfstatus = XCGROUP_ERROR;\n\n\t/* check input pointers */\n\tif (content == NULL || csize == NULL)\n\t\treturn fstatus;\n\n\t/* open file for reading */\n\tfd = open(file_path, O_RDONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for reading : %m\",\n\t\t\t__func__, file_path);\n\t\treturn fstatus;\n\t}\n\n\t/* get file size */\n\tfsize=_file_getsize(fd);\n\tif (fsize == -1) {\n\t\tclose(fd);\n\t\treturn fstatus;\n\t}\n\n\t/* read file contents */\n\tbuf = (char*) xmalloc((fsize+1)*sizeof(char));\n\tbuf[fsize]='\\0';\n\tdo {\n\t\trc = read(fd, buf, fsize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* set output values */\n\tif (rc >= 0) {\n\t\t*content = buf;\n\t\t*csize = rc;\n\t\tfstatus = XCGROUP_SUCCESS;\n\t}\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}",
          "includes": [
            "#include \"xcgroup.h\"",
            "#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/log.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include \"slurm/slurm.h\"",
            "#include <sys/mount.h>",
            "#include <dirent.h>",
            "#include <strings.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <fcntl.h>",
            "#include <unistd.h>",
            "#include <sys/stat.h>",
            "#include <sys/types.h>",
            "#include <sys/file.h>",
            "#  include <inttypes.h>",
            "#  include <stdint.h>",
            "#   include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "size_t _file_getsize(int fd);",
            "int _file_read_content(char* file_path, char** content, size_t *csize);",
            "int _file_write_content(char* file_path, char* content, size_t csize);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"xcgroup.h\"\n#include \"src/slurmd/slurmstepd/slurmstepd_job.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/log.h\"\n#include \"slurm/slurm_errno.h\"\n#include \"slurm/slurm.h\"\n#include <sys/mount.h>\n#include <dirent.h>\n#include <strings.h>\n#include <string.h>\n#include <stdlib.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/file.h>\n#  include <inttypes.h>\n#  include <stdint.h>\n#   include \"config.h\"\n\nsize_t _file_getsize(int fd);\nint _file_read_content(char* file_path, char** content, size_t *csize);\nint _file_write_content(char* file_path, char* content, size_t csize);\n\nint _file_read_content(char* file_path, char** content, size_t *csize)\n{\n\tint fstatus;\n\tint rc;\n\tint fd;\n\n\tsize_t fsize;\n\tchar* buf;\n\n\tfstatus = XCGROUP_ERROR;\n\n\t/* check input pointers */\n\tif (content == NULL || csize == NULL)\n\t\treturn fstatus;\n\n\t/* open file for reading */\n\tfd = open(file_path, O_RDONLY, 0700);\n\tif (fd < 0) {\n\t\tdebug2(\"%s: unable to open '%s' for reading : %m\",\n\t\t\t__func__, file_path);\n\t\treturn fstatus;\n\t}\n\n\t/* get file size */\n\tfsize=_file_getsize(fd);\n\tif (fsize == -1) {\n\t\tclose(fd);\n\t\treturn fstatus;\n\t}\n\n\t/* read file contents */\n\tbuf = (char*) xmalloc((fsize+1)*sizeof(char));\n\tbuf[fsize]='\\0';\n\tdo {\n\t\trc = read(fd, buf, fsize);\n\t} while (rc < 0 && errno == EINTR);\n\n\t/* set output values */\n\tif (rc >= 0) {\n\t\t*content = buf;\n\t\t*csize = rc;\n\t\tfstatus = XCGROUP_SUCCESS;\n\t}\n\n\t/* close file */\n\tclose(fd);\n\n\treturn fstatus;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  got stdin eof message!\""
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "client->job->free_incoming",
            "client->in_msg"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_send_connection_okay_response",
          "args": [
            "client->job"
          ],
          "line": 358
        },
        "resolved": true,
        "details": {
          "function_name": "_send_connection_okay_response",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1242-1271",
          "snippet": "static int\n_send_connection_okay_response(stepd_step_rec_t *job)\n{\n\teio_obj_t *eio;\n\tListIterator clients;\n\tstruct io_buf *msg;\n\tstruct client_io_info *client;\n\n\tmsg = _build_connection_okay_message(job);\n\tif (!msg) {\n\t\terror(  \"Could not send connection okay message because of \"\n\t\t\t\"lack of buffer space.\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\tclients = list_iterator_create(job->clients);\n\twhile ((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->out_eof || client->is_local_file)\n\t\t\tcontinue;\n\n\t\tdebug5(\"Sent connection okay message\");\n\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\tmsg->ref_count++;\n\t}\n\tlist_iterator_destroy(clients);\n\n\treturn SLURM_SUCCESS;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [
            "#define CLIENT_IO_MAGIC  0x10102"
          ],
          "globals_used": [
            "static bool _client_readable(eio_obj_t *);",
            "static bool _client_writable(eio_obj_t *);",
            "static bool _local_file_writable(eio_obj_t *);",
            "static bool _task_writable(eio_obj_t *);",
            "static bool _task_readable(eio_obj_t *);",
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void *_io_thr(void *arg);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic int\n_send_connection_okay_response(stepd_step_rec_t *job)\n{\n\teio_obj_t *eio;\n\tListIterator clients;\n\tstruct io_buf *msg;\n\tstruct client_io_info *client;\n\n\tmsg = _build_connection_okay_message(job);\n\tif (!msg) {\n\t\terror(  \"Could not send connection okay message because of \"\n\t\t\t\"lack of buffer space.\");\n\t\treturn SLURM_ERROR;\n\t}\n\n\tclients = list_iterator_create(job->clients);\n\twhile ((eio = list_next(clients))) {\n\t\tclient = (struct client_io_info *)eio->arg;\n\t\tif (client->out_eof || client->is_local_file)\n\t\t\tcontinue;\n\n\t\tdebug5(\"Sent connection okay message\");\n\t\txassert(client->magic == CLIENT_IO_MAGIC);\n\t\tif (list_enqueue(client->msg_queue, msg))\n\t\t\tmsg->ref_count++;\n\t}\n\tlist_iterator_destroy(clients);\n\n\treturn SLURM_SUCCESS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "client->job->free_incoming",
            "client->in_msg"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  error in _client_read: bad connection test\""
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "error",
          "args": [
            "\"Message length of %u exceeds maximum of %u\"",
            "client->header.length",
            "MAX_MSG_LEN"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"client->header.length = %u\"",
            "client->header.length"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "client->job->free_incoming",
            "client->in_msg"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  got eof or error _client_read header, n=%d\"",
            "n"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "io_hdr_read_fd",
          "args": [
            "obj->fd",
            "&client->header"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  _client_read free_incoming is empty\""
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_dequeue",
          "args": [
            "client->job->free_incoming"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_incoming_buf_free",
          "args": [
            "client->job"
          ],
          "line": 325
        },
        "resolved": true,
        "details": {
          "function_name": "_incoming_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1886-1903",
          "snippet": "static bool\n_incoming_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_incoming) > 0) {\n\t\treturn true;\n\t} else if (job->incoming_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_incoming, buf);\n\t\t\tjob->incoming_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic bool\n_incoming_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_incoming) > 0) {\n\t\treturn true;\n\t} else if (job->incoming_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_incoming, buf);\n\t\t\tjob->incoming_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "client->magic == CLIENT_IO_MAGIC"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug4",
          "args": [
            "\"Entering _client_read\""
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic int _task_write_error(eio_obj_t *obj, List objs);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic int\n_client_read(eio_obj_t *obj, List objs)\n{\n\tstruct client_io_info *client = (struct client_io_info *) obj->arg;\n\tvoid *buf;\n\tint n;\n\n\tdebug4(\"Entering _client_read\");\n\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\t/*\n\t * Read the header, if a message read is not already in progress\n\t */\n\tif (client->in_msg == NULL) {\n\t\tif (_incoming_buf_free(client->job)) {\n\t\t\tclient->in_msg =\n\t\t\t\tlist_dequeue(client->job->free_incoming);\n\t\t} else {\n\t\t\tdebug5(\"  _client_read free_incoming is empty\");\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tn = io_hdr_read_fd(obj->fd, &client->header);\n\t\tif (n <= 0) { /* got eof or fatal error */\n\t\t\tdebug5(\"  got eof or error _client_read header, n=%d\", n);\n\t\t\tclient->in_eof = true;\n\t\t\tlist_enqueue(client->job->free_incoming, client->in_msg);\n\t\t\tclient->in_msg = NULL;\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tdebug5(\"client->header.length = %u\", client->header.length);\n\t\tif (client->header.length > MAX_MSG_LEN)\n\t\t\terror(\"Message length of %u exceeds maximum of %u\",\n\t\t\t      client->header.length, MAX_MSG_LEN);\n\t\tclient->in_remaining = client->header.length;\n\t\tclient->in_msg->length = client->header.length;\n\t}\n\n\t/*\n\t * Read the body\n\t */\n\tif (client->header.type == SLURM_IO_CONNECTION_TEST) {\n\t\tif (client->header.length != 0) {\n\t\t\tdebug5(\"  error in _client_read: bad connection test\");\n\t\t\tlist_enqueue(client->job->free_incoming, client->in_msg);\n\t\t\tclient->in_msg = NULL;\n\t\t\treturn SLURM_ERROR;\n\t\t}\n\t\tif (_send_connection_okay_response(client->job)) {\n\t\t\t/*\n\t\t\t * If we get here because of a failed\n\t\t\t * _send_connection_okay_response, it's because of a\n\t\t\t * lack of buffer space in the output queue.  Just\n\t\t\t * keep the current input message client->in_msg in\n\t\t\t * place, and resend on the next call.\n\t\t\t */\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tlist_enqueue(client->job->free_incoming, client->in_msg);\n\t\tclient->in_msg = NULL;\n\t\treturn SLURM_SUCCESS;\n\t} else if (client->header.length == 0) { /* zero length is an eof message */\n\t\tdebug5(\"  got stdin eof message!\");\n\t} else {\n\t\tbuf = client->in_msg->data +\n\t\t\t(client->in_msg->length - client->in_remaining);\n\tagain:\n\t\tif ((n = read(obj->fd, buf, client->in_remaining)) < 0) {\n\t\t\tif (errno == EINTR)\n\t\t\t\tgoto again;\n\t\t\tif (errno == EAGAIN || errno == EWOULDBLOCK) {\n\t\t\t\tdebug5(\"_client_read returned %s\",\n\t\t\t\t\terrno == EAGAIN ? \"EAGAIN\" : \"EWOULDBLOCK\");\n\t\t\t\treturn SLURM_SUCCESS;\n\t\t\t}\n\t\t\tdebug5(\"  error in _client_read: %m\");\n\t\t}\n\t\tif (n <= 0) { /* got eof (or unhandled error) */\n\t\t\tdebug5(\"  got eof on _client_read body\");\n\t\t\tclient->in_eof = true;\n\t\t\tlist_enqueue(client->job->free_incoming, client->in_msg);\n\t\t\tclient->in_msg = NULL;\n\t\t\treturn SLURM_SUCCESS;\n\t\t}\n\t\tclient->in_remaining -= n;\n\t\tif (client->in_remaining > 0)\n\t\t\treturn SLURM_SUCCESS;\n/* \t\t*(char *)(buf + n) = '\\0'; */\n/* \t\tdebug5(\"\\\"%s\\\"\", buf); */\n\t}\n\n\t/*\n\t * Route the message to its destination(s)\n\t */\n\tif (client->header.type != SLURM_IO_STDIN\n\t    && client->header.type != SLURM_IO_ALLSTDIN) {\n\t\terror(\"Input client->header.type is not valid!\");\n\t\tclient->in_msg = NULL;\n\t\treturn SLURM_ERROR;\n\t} else {\n\t\tint i;\n\t\tstepd_step_task_info_t *task;\n\t\tstruct task_write_info *io;\n\n\t\tclient->in_msg->ref_count = 0;\n\t\tif (client->header.type == SLURM_IO_ALLSTDIN) {\n\t\t\tfor (i = 0; i < client->job->node_tasks; i++) {\n\t\t\t\ttask = client->job->task[i];\n\t\t\t\tio = (struct task_write_info *)task->in->arg;\n\t\t\t\tclient->in_msg->ref_count++;\n\t\t\t\tlist_enqueue(io->msg_queue, client->in_msg);\n\t\t\t}\n\t\t\tdebug5(\"  message ref_count = %d\", client->in_msg->ref_count);\n\t\t} else {\n\t\t\tfor (i = 0; i < client->job->node_tasks; i++) {\n\t\t\t\ttask = client->job->task[i];\n\t\t\t\tif (task->in == NULL)\n\t\t\t\t\tcontinue;\n\t\t\t\tio = (struct task_write_info *)task->in->arg;\n\t\t\t\tif (task->gtid != client->header.gtaskid)\n\t\t\t\t\tcontinue;\n\t\t\t\tclient->in_msg->ref_count++;\n\t\t\t\tlist_enqueue(io->msg_queue, client->in_msg);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tclient->in_msg = NULL;\n\tdebug4(\"Leaving  _client_read\");\n\treturn SLURM_SUCCESS;\n}"
  },
  {
    "function_name": "_client_writable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "266-309",
    "snippet": "static bool\n_client_writable(eio_obj_t *obj)\n{\n\tstruct client_io_info *client = (struct client_io_info *) obj->arg;\n\n\tdebug5(\"Called _client_writable\");\n\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\tif (client->out_eof == true) {\n\t\tdebug5(\"  false, out_eof\");\n\t\treturn false;\n\t}\n\n\t/* If this is a newly attached client its msg_queue needs\n\t * to be initialized from the outgoing_cache, and then \"obj\" needs\n\t * to be added to the List of clients.\n\t */\n\tif (client->msg_queue == NULL) {\n\t\tListIterator msgs;\n\t\tstruct io_buf *msg;\n\t\tclient->msg_queue = list_create(NULL); /* need destructor */\n\t\tmsgs = list_iterator_create(client->job->outgoing_cache);\n\t\twhile ((msg = list_next(msgs))) {\n\t\t\tmsg->ref_count++;\n\t\t\tlist_enqueue(client->msg_queue, msg);\n\t\t}\n\t\tlist_iterator_destroy(msgs);\n\t\t/* and now make this object visible to tasks */\n\t\tlist_append(client->job->clients, (void *)obj);\n\t}\n\n\tif (client->out_msg != NULL)\n\t\tdebug5(\"  client->out.msg != NULL\");\n\tif (!list_is_empty(client->msg_queue))\n\t\tdebug5(\"  client->out.msg_queue queue length = %d\",\n\t\t       list_count(client->msg_queue));\n\n\tif (client->out_msg != NULL\n\t    || !list_is_empty(client->msg_queue))\n\t\treturn true;\n\n\tdebug5(\"  false\");\n\treturn false;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define CLIENT_IO_MAGIC  0x10102"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static int  _client_read(eio_obj_t *, List);",
      "static int  _client_write(eio_obj_t *, List);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static int  _local_file_write(eio_obj_t *, List);",
      "static bool _task_writable(eio_obj_t *);",
      "static int  _task_write(eio_obj_t *, List);",
      "static bool _task_readable(eio_obj_t *);",
      "static int  _task_read(eio_obj_t *, List);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void _send_eof_msg(struct task_read_info *out);",
      "static void *_io_thr(void *arg);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  false\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_empty",
          "args": [
            "client->msg_queue"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  client->out.msg_queue queue length = %d\"",
            "list_count(client->msg_queue)"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_count",
          "args": [
            "client->msg_queue"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_empty",
          "args": [
            "client->msg_queue"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  client->out.msg != NULL\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_append",
          "args": [
            "client->job->clients",
            "(void *)obj"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_iterator_destroy",
          "args": [
            "msgs"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_enqueue",
          "args": [
            "client->msg_queue",
            "msg"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_next",
          "args": [
            "msgs"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_iterator_create",
          "args": [
            "client->job->outgoing_cache"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_create",
          "args": [
            "NULL"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "_script_list_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/common/run_script.c",
          "lines": "178-210",
          "snippet": "static List _script_list_create (const char *pattern)\n{\n\tglob_t gl;\n\tsize_t i;\n\tList l = NULL;\n\n\tif (pattern == NULL)\n\t\treturn (NULL);\n\n\tint rc = glob (pattern, GLOB_ERR, _ef, &gl);\n\tswitch (rc) {\n\tcase 0:\n\t\tl = list_create ((ListDelF) _xfree_f);\n\t\tfor (i = 0; i < gl.gl_pathc; i++)\n\t\t\tlist_push (l, xstrdup (gl.gl_pathv[i]));\n\t\tbreak;\n\tcase GLOB_NOMATCH:\n\t\tbreak;\n\tcase GLOB_NOSPACE:\n\t\terror (\"run_script: glob(3): Out of memory\");\n\t\tbreak;\n\tcase GLOB_ABORTED:\n\t\terror (\"run_script: cannot read dir %s: %m\", pattern);\n\t\tbreak;\n\tdefault:\n\t\terror (\"Unknown glob(3) return code = %d\", rc);\n\t\tbreak;\n\t}\n\n\tglobfree (&gl);\n\n\treturn l;\n}",
          "includes": [
            "#include \"src/slurmd/common/run_script.h\"",
            "#include \"src/slurmd/common/job_container_plugin.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/xassert.h\"",
            "#include \"src/common/list.h\"",
            "#include \"slurm/slurm_errno.h\"",
            "#include <glob.h>",
            "#include <string.h>",
            "#include <sys/errno.h>",
            "#include <sys/wait.h>",
            "#include <stdlib.h>",
            "#include <signal.h>",
            "#include <poll.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/common/run_script.h\"\n#include \"src/slurmd/common/job_container_plugin.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/xassert.h\"\n#include \"src/common/list.h\"\n#include \"slurm/slurm_errno.h\"\n#include <glob.h>\n#include <string.h>\n#include <sys/errno.h>\n#include <sys/wait.h>\n#include <stdlib.h>\n#include <signal.h>\n#include <poll.h>\n#  include \"config.h\"\n\nstatic List _script_list_create (const char *pattern)\n{\n\tglob_t gl;\n\tsize_t i;\n\tList l = NULL;\n\n\tif (pattern == NULL)\n\t\treturn (NULL);\n\n\tint rc = glob (pattern, GLOB_ERR, _ef, &gl);\n\tswitch (rc) {\n\tcase 0:\n\t\tl = list_create ((ListDelF) _xfree_f);\n\t\tfor (i = 0; i < gl.gl_pathc; i++)\n\t\t\tlist_push (l, xstrdup (gl.gl_pathv[i]));\n\t\tbreak;\n\tcase GLOB_NOMATCH:\n\t\tbreak;\n\tcase GLOB_NOSPACE:\n\t\terror (\"run_script: glob(3): Out of memory\");\n\t\tbreak;\n\tcase GLOB_ABORTED:\n\t\terror (\"run_script: cannot read dir %s: %m\", pattern);\n\t\tbreak;\n\tdefault:\n\t\terror (\"Unknown glob(3) return code = %d\", rc);\n\t\tbreak;\n\t}\n\n\tglobfree (&gl);\n\n\treturn l;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  false, out_eof\""
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "client->magic == CLIENT_IO_MAGIC"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"Called _client_writable\""
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic int  _client_read(eio_obj_t *, List);\nstatic int  _client_write(eio_obj_t *, List);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic int  _local_file_write(eio_obj_t *, List);\nstatic bool _task_writable(eio_obj_t *);\nstatic int  _task_write(eio_obj_t *, List);\nstatic bool _task_readable(eio_obj_t *);\nstatic int  _task_read(eio_obj_t *, List);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _send_eof_msg(struct task_read_info *out);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic bool\n_client_writable(eio_obj_t *obj)\n{\n\tstruct client_io_info *client = (struct client_io_info *) obj->arg;\n\n\tdebug5(\"Called _client_writable\");\n\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\tif (client->out_eof == true) {\n\t\tdebug5(\"  false, out_eof\");\n\t\treturn false;\n\t}\n\n\t/* If this is a newly attached client its msg_queue needs\n\t * to be initialized from the outgoing_cache, and then \"obj\" needs\n\t * to be added to the List of clients.\n\t */\n\tif (client->msg_queue == NULL) {\n\t\tListIterator msgs;\n\t\tstruct io_buf *msg;\n\t\tclient->msg_queue = list_create(NULL); /* need destructor */\n\t\tmsgs = list_iterator_create(client->job->outgoing_cache);\n\t\twhile ((msg = list_next(msgs))) {\n\t\t\tmsg->ref_count++;\n\t\t\tlist_enqueue(client->msg_queue, msg);\n\t\t}\n\t\tlist_iterator_destroy(msgs);\n\t\t/* and now make this object visible to tasks */\n\t\tlist_append(client->job->clients, (void *)obj);\n\t}\n\n\tif (client->out_msg != NULL)\n\t\tdebug5(\"  client->out.msg != NULL\");\n\tif (!list_is_empty(client->msg_queue))\n\t\tdebug5(\"  client->out.msg_queue queue length = %d\",\n\t\t       list_count(client->msg_queue));\n\n\tif (client->out_msg != NULL\n\t    || !list_is_empty(client->msg_queue))\n\t\treturn true;\n\n\tdebug5(\"  false\");\n\treturn false;\n}"
  },
  {
    "function_name": "_client_readable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
    "lines": "232-264",
    "snippet": "static bool\n_client_readable(eio_obj_t *obj)\n{\n\tstruct client_io_info *client = (struct client_io_info *) obj->arg;\n\n\tdebug5(\"Called _client_readable\");\n\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\tif (client->in_eof) {\n\t\tdebug5(\"  false\");\n\t\t/* We no longer want the _client_read() function to handle\n\t\t   errors on write now that the read side of the connection\n\t\t   is closed.  Setting handle_read to NULL will result in\n\t\t   the _client_write function handling errors, and closing\n\t\t   down the write end of the connection. */\n\t\tobj->ops->handle_read = NULL;\n\t\treturn false;\n\t}\n\n\tif (obj->shutdown) {\n\t\tdebug5(\"  false, shutdown\");\n\t\tshutdown(obj->fd, SHUT_RD);\n\t\tclient->in_eof = true;\n\t\treturn false;\n\t}\n\n\tif (client->in_msg != NULL\n\t    || _incoming_buf_free(client->job))\n\t\treturn true;\n\n\tdebug5(\"  false\");\n\treturn false;\n}",
    "includes": [
      "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
      "#include \"src/slurmd/slurmstepd/fname.h\"",
      "#include \"src/slurmd/slurmstepd/io.h\"",
      "#include \"src/slurmd/slurmd/slurmd.h\"",
      "#include \"src/common/xstring.h\"",
      "#include \"src/common/xsignal.h\"",
      "#include \"src/common/xmalloc.h\"",
      "#include \"src/common/write_labelled_message.h\"",
      "#include \"src/common/read_config.h\"",
      "#include \"src/common/net.h\"",
      "#include \"src/common/macros.h\"",
      "#include \"src/common/log.h\"",
      "#include \"src/common/list.h\"",
      "#include \"src/common/io_hdr.h\"",
      "#include \"src/common/fd.h\"",
      "#include \"src/common/eio.h\"",
      "#include \"src/common/cbuf.h\"",
      "#include <errno.h>",
      "#include <unistd.h>",
      "#include <fcntl.h>",
      "#include <sys/stat.h>",
      "#include <sys/socket.h>",
      "#include <sys/types.h>",
      "#include <poll.h>",
      "#  include <utmp.h>",
      "#  include <pty.h>",
      "#  include <stdlib.h>",
      "#  include <string.h>",
      "#  include <unistd.h>",
      "#  include \"config.h\""
    ],
    "macros_used": [
      "#define CLIENT_IO_MAGIC  0x10102"
    ],
    "globals_used": [
      "static bool _client_readable(eio_obj_t *);",
      "static bool _client_writable(eio_obj_t *);",
      "static bool _local_file_writable(eio_obj_t *);",
      "static bool _task_writable(eio_obj_t *);",
      "static bool _task_readable(eio_obj_t *);",
      "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
      "static void *_io_thr(void *arg);",
      "static void _route_msg_task_to_client(eio_obj_t *obj);",
      "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
      "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
      "static bool _incoming_buf_free(stepd_step_rec_t *job);",
      "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
      "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
      "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  false\""
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_incoming_buf_free",
          "args": [
            "client->job"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "_incoming_buf_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2016-10030/repo/src/slurmd/slurmstepd/io.c",
          "lines": "1886-1903",
          "snippet": "static bool\n_incoming_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_incoming) > 0) {\n\t\treturn true;\n\t} else if (job->incoming_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_incoming, buf);\n\t\t\tjob->incoming_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"src/slurmd/slurmstepd/slurmstepd.h\"",
            "#include \"src/slurmd/slurmstepd/fname.h\"",
            "#include \"src/slurmd/slurmstepd/io.h\"",
            "#include \"src/slurmd/slurmd/slurmd.h\"",
            "#include \"src/common/xstring.h\"",
            "#include \"src/common/xsignal.h\"",
            "#include \"src/common/xmalloc.h\"",
            "#include \"src/common/write_labelled_message.h\"",
            "#include \"src/common/read_config.h\"",
            "#include \"src/common/net.h\"",
            "#include \"src/common/macros.h\"",
            "#include \"src/common/log.h\"",
            "#include \"src/common/list.h\"",
            "#include \"src/common/io_hdr.h\"",
            "#include \"src/common/fd.h\"",
            "#include \"src/common/eio.h\"",
            "#include \"src/common/cbuf.h\"",
            "#include <errno.h>",
            "#include <unistd.h>",
            "#include <fcntl.h>",
            "#include <sys/stat.h>",
            "#include <sys/socket.h>",
            "#include <sys/types.h>",
            "#include <poll.h>",
            "#  include <utmp.h>",
            "#  include <pty.h>",
            "#  include <stdlib.h>",
            "#  include <string.h>",
            "#  include <unistd.h>",
            "#  include \"config.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);",
            "static void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);",
            "static void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);",
            "static bool _incoming_buf_free(stepd_step_rec_t *job);",
            "static bool _outgoing_buf_free(stepd_step_rec_t *job);",
            "static int  _send_connection_okay_response(stepd_step_rec_t *job);",
            "static struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic bool\n_incoming_buf_free(stepd_step_rec_t *job)\n{\n\tstruct io_buf *buf;\n\n\tif (list_count(job->free_incoming) > 0) {\n\t\treturn true;\n\t} else if (job->incoming_count < STDIO_MAX_FREE_BUF) {\n\t\tbuf = alloc_io_buf();\n\t\tif (buf != NULL) {\n\t\t\tlist_enqueue(job->free_incoming, buf);\n\t\t\tjob->incoming_count++;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shutdown",
          "args": [
            "obj->fd",
            "SHUT_RD"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  false, shutdown\""
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"  false\""
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "xassert",
          "args": [
            "client->magic == CLIENT_IO_MAGIC"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug5",
          "args": [
            "\"Called _client_readable\""
          ],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"src/slurmd/slurmstepd/slurmstepd.h\"\n#include \"src/slurmd/slurmstepd/fname.h\"\n#include \"src/slurmd/slurmstepd/io.h\"\n#include \"src/slurmd/slurmd/slurmd.h\"\n#include \"src/common/xstring.h\"\n#include \"src/common/xsignal.h\"\n#include \"src/common/xmalloc.h\"\n#include \"src/common/write_labelled_message.h\"\n#include \"src/common/read_config.h\"\n#include \"src/common/net.h\"\n#include \"src/common/macros.h\"\n#include \"src/common/log.h\"\n#include \"src/common/list.h\"\n#include \"src/common/io_hdr.h\"\n#include \"src/common/fd.h\"\n#include \"src/common/eio.h\"\n#include \"src/common/cbuf.h\"\n#include <errno.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <sys/types.h>\n#include <poll.h>\n#  include <utmp.h>\n#  include <pty.h>\n#  include <stdlib.h>\n#  include <string.h>\n#  include <unistd.h>\n#  include \"config.h\"\n\n#define CLIENT_IO_MAGIC  0x10102\n\nstatic bool _client_readable(eio_obj_t *);\nstatic bool _client_writable(eio_obj_t *);\nstatic bool _local_file_writable(eio_obj_t *);\nstatic bool _task_writable(eio_obj_t *);\nstatic bool _task_readable(eio_obj_t *);\nstatic int _send_io_init_msg(int sock, srun_key_t *key, stepd_step_rec_t *job);\nstatic void *_io_thr(void *arg);\nstatic void _route_msg_task_to_client(eio_obj_t *obj);\nstatic void _free_outgoing_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_incoming_msg(struct io_buf *msg, stepd_step_rec_t *job);\nstatic void _free_all_outgoing_msgs(List msg_queue, stepd_step_rec_t *job);\nstatic bool _incoming_buf_free(stepd_step_rec_t *job);\nstatic bool _outgoing_buf_free(stepd_step_rec_t *job);\nstatic int  _send_connection_okay_response(stepd_step_rec_t *job);\nstatic struct io_buf *_build_connection_okay_message(stepd_step_rec_t *job);\n\nstatic bool\n_client_readable(eio_obj_t *obj)\n{\n\tstruct client_io_info *client = (struct client_io_info *) obj->arg;\n\n\tdebug5(\"Called _client_readable\");\n\txassert(client->magic == CLIENT_IO_MAGIC);\n\n\tif (client->in_eof) {\n\t\tdebug5(\"  false\");\n\t\t/* We no longer want the _client_read() function to handle\n\t\t   errors on write now that the read side of the connection\n\t\t   is closed.  Setting handle_read to NULL will result in\n\t\t   the _client_write function handling errors, and closing\n\t\t   down the write end of the connection. */\n\t\tobj->ops->handle_read = NULL;\n\t\treturn false;\n\t}\n\n\tif (obj->shutdown) {\n\t\tdebug5(\"  false, shutdown\");\n\t\tshutdown(obj->fd, SHUT_RD);\n\t\tclient->in_eof = true;\n\t\treturn false;\n\t}\n\n\tif (client->in_msg != NULL\n\t    || _incoming_buf_free(client->job))\n\t\treturn true;\n\n\tdebug5(\"  false\");\n\treturn false;\n}"
  }
]