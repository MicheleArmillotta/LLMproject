[
  {
    "function_name": "load_v4db",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
    "lines": "974-980",
    "snippet": "void\nload_v4db(argc, argv)\n\tint argc;\n\tchar *argv[];\n{\n\tprintf(\"This version of kdb5_util does not support the V4 load command.\\n\");\n}",
    "includes": [
      "#include <netinet/in.h>\t\t\t/* ntohl */",
      "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
      "#include \"kdb5_util.h\"",
      "#include <stdio.h>",
      "#include <kadm5/admin.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"This version of kdb5_util does not support the V4 load command.\\n\""
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nvoid\nload_v4db(argc, argv)\n\tint argc;\n\tchar *argv[];\n{\n\tprintf(\"This version of kdb5_util does not support the V4 load command.\\n\");\n}"
  },
  {
    "function_name": "fixup_database",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
    "lines": "966-971",
    "snippet": "static krb5_error_code fixup_database(context, realm)\n    krb5_context context;\n    char * realm;\n{\n    return 0;\n}",
    "includes": [
      "#include <netinet/in.h>\t\t\t/* ntohl */",
      "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
      "#include \"kdb5_util.h\"",
      "#include <stdio.h>",
      "#include <kadm5/admin.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic krb5_error_code fixup_database(context, realm)\n    krb5_context context;\n    char * realm;\n{\n    return 0;\n}"
  },
  {
    "function_name": "v4_dump_find_default",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
    "lines": "879-964",
    "snippet": "static krb5_error_code\nv4_dump_find_default(context, dumpfile, realm, exptime)\nkrb5_context context;\nchar *dumpfile;\nchar *realm;\nlong *exptime;\n{\n    krb5_error_code retval = 0;\n    FILE *input_file;\n    Principal aprinc;\n    char    exp_date_str[50];\n    char    mod_date_str[50];\n    int     temp1, temp2, temp3;\n    long foundtime, guess1, guess2;\n\n    /* kdb_init is usually the only thing to touch the time in the \n       default entry, and everything else just copies that time.  If\n       the site hasn't changed it, we can assume that \"never\" is an\n       appropriate value for V5.  There have been two values compiled\n       in, typically:\n\n       MIT V4 had the code\n       principal.exp_date = 946702799;\n       strncpy(principal.exp_date_txt, \"12/31/99\", DATE_SZ);\n\n       Cygnus CNS V4 had the code\n       principal.exp_date = 946702799+((365*10+3)*24*60*60);\n       strncpy(principal.exp_date_txt, \"12/31/2009\", DATE_SZ);\n\n       However, the dump files only store minutes -- so these values\n       are 59 seconds high.\n\n       Other values could be added later, but in practice these are\n       likely to be the only ones. */\n\n    guess1 = 946702799-59;\n    guess2 = 946702799+((365*10+3)*24*60*60);\n\n    input_file = fopen(dumpfile, \"r\");\n    if (!input_file)\n\treturn errno;\n\n    for (;;) {\t\t\t/* explicit break on eof from fscanf */\n\tint nread;\n\n\tmemset((char *)&aprinc, 0, sizeof(aprinc));\n\tnread = fscanf(input_file,\n\t\t       \"%s %s %d %d %d %hd %lx %lx %s %s %s %s\\n\",\n\t\t       aprinc.name,\n\t\t       aprinc.instance,\n\t\t       &temp1,\n\t\t       &temp2,\n\t\t       &temp3,\n\t\t       &aprinc.attributes,\n\t\t       &aprinc.key_low,\n\t\t       &aprinc.key_high,\n\t\t       exp_date_str,\n\t\t       mod_date_str,\n\t\t       aprinc.mod_name,\n\t\t       aprinc.mod_instance);\n\tif (nread != 12) {\n\t    retval = nread == EOF ? 0 : KRB5_KDB_DB_CORRUPT;\n\t    break;\n\t}\n\tif (!strcmp(aprinc.name, \"default\")\n\t    && !strcmp(aprinc.instance, \"*\")) {\n\t    foundtime = time_explode(exp_date_str);\n\t    if (foundtime == guess1 || foundtime == guess2)\n\t        *exptime = foundtime;\n\t    if (verbose) {\n\t        printf(\"\\ndefault expiration found: \");\n\t        if (foundtime == guess1) {\n\t\t    printf(\"MIT or pre96q1 value (1999)\");\n\t\t} else if (foundtime == guess2) {\n\t\t    printf(\"Cygnus CNS post 96q1 value (2009)\");\n\t\t} else {\n\t\t    printf(\"non-default start time (%ld,%s)\",\n\t\t\t   foundtime, exp_date_str);\n\t\t}\n\t    }\n\t    break;\n\t}\n    }\n    (void) fclose(input_file);\n    return retval;\n}",
    "includes": [
      "#include <netinet/in.h>\t\t\t/* ntohl */",
      "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
      "#include \"kdb5_util.h\"",
      "#include <stdio.h>",
      "#include <kadm5/admin.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "input_file"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"non-default start time (%ld,%s)\"",
            "foundtime",
            "exp_date_str"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Cygnus CNS post 96q1 value (2009)\""
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"MIT or pre96q1 value (1999)\""
          ],
          "line": 951
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\ndefault expiration found: \""
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_explode",
          "args": [
            "exp_date_str"
          ],
          "line": 945
        },
        "resolved": true,
        "details": {
          "function_name": "time_explode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
          "lines": "770-814",
          "snippet": "static long\ntime_explode(cp)\nregister char *cp;\n{\n    char wbuf[5];\n    struct tm tp;\n    int local;\n\n    memset((char *)&tp, 0, sizeof(tp));\n    \n    if (strlen(cp) > 10) {\t\t/* new format */\n\t(void) strncpy(wbuf, cp, 4);\n\twbuf[4] = 0;\n\ttp.tm_year = atoi(wbuf);\n\tcp += 4;\t\t\t/* step over the year */\n\tlocal = 0;\t\t\t/* GMT */\n    } else {\t\t\t\t/* old format: local time, \n\t\t\t\t\t   year is 2 digits, assuming 19xx */\n\twbuf[0] = *cp++;\n\twbuf[1] = *cp++;\n\twbuf[2] = 0;\n\ttp.tm_year = 1900 + atoi(wbuf);\n\tlocal = 1;\t\t\t/* local */\n    }\n\n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    wbuf[2] = 0;\n    tp.tm_mon = atoi(wbuf)-1;\n\n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_mday = atoi(wbuf);\n    \n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_hour = atoi(wbuf);\n    \n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_min = atoi(wbuf);\n\n\n    return(maketime(&tp, local));\n}",
          "includes": [
            "#include <netinet/in.h>\t\t\t/* ntohl */",
            "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
            "#include \"kdb5_util.h\"",
            "#include <stdio.h>",
            "#include <kadm5/admin.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic long\ntime_explode(cp)\nregister char *cp;\n{\n    char wbuf[5];\n    struct tm tp;\n    int local;\n\n    memset((char *)&tp, 0, sizeof(tp));\n    \n    if (strlen(cp) > 10) {\t\t/* new format */\n\t(void) strncpy(wbuf, cp, 4);\n\twbuf[4] = 0;\n\ttp.tm_year = atoi(wbuf);\n\tcp += 4;\t\t\t/* step over the year */\n\tlocal = 0;\t\t\t/* GMT */\n    } else {\t\t\t\t/* old format: local time, \n\t\t\t\t\t   year is 2 digits, assuming 19xx */\n\twbuf[0] = *cp++;\n\twbuf[1] = *cp++;\n\twbuf[2] = 0;\n\ttp.tm_year = 1900 + atoi(wbuf);\n\tlocal = 1;\t\t\t/* local */\n    }\n\n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    wbuf[2] = 0;\n    tp.tm_mon = atoi(wbuf)-1;\n\n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_mday = atoi(wbuf);\n    \n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_hour = atoi(wbuf);\n    \n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_min = atoi(wbuf);\n\n\n    return(maketime(&tp, local));\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "aprinc.instance",
            "\"*\""
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "aprinc.name",
            "\"default\""
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "input_file",
            "\"%s %s %d %d %d %hd %lx %lx %s %s %s %s\\n\"",
            "aprinc.name",
            "aprinc.instance",
            "&temp1",
            "&temp2",
            "&temp3",
            "&aprinc.attributes",
            "&aprinc.key_low",
            "&aprinc.key_high",
            "exp_date_str",
            "mod_date_str",
            "aprinc.mod_name",
            "aprinc.mod_instance"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&aprinc",
            "0",
            "sizeof(aprinc)"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "dumpfile",
            "\"r\""
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic krb5_error_code\nv4_dump_find_default(context, dumpfile, realm, exptime)\nkrb5_context context;\nchar *dumpfile;\nchar *realm;\nlong *exptime;\n{\n    krb5_error_code retval = 0;\n    FILE *input_file;\n    Principal aprinc;\n    char    exp_date_str[50];\n    char    mod_date_str[50];\n    int     temp1, temp2, temp3;\n    long foundtime, guess1, guess2;\n\n    /* kdb_init is usually the only thing to touch the time in the \n       default entry, and everything else just copies that time.  If\n       the site hasn't changed it, we can assume that \"never\" is an\n       appropriate value for V5.  There have been two values compiled\n       in, typically:\n\n       MIT V4 had the code\n       principal.exp_date = 946702799;\n       strncpy(principal.exp_date_txt, \"12/31/99\", DATE_SZ);\n\n       Cygnus CNS V4 had the code\n       principal.exp_date = 946702799+((365*10+3)*24*60*60);\n       strncpy(principal.exp_date_txt, \"12/31/2009\", DATE_SZ);\n\n       However, the dump files only store minutes -- so these values\n       are 59 seconds high.\n\n       Other values could be added later, but in practice these are\n       likely to be the only ones. */\n\n    guess1 = 946702799-59;\n    guess2 = 946702799+((365*10+3)*24*60*60);\n\n    input_file = fopen(dumpfile, \"r\");\n    if (!input_file)\n\treturn errno;\n\n    for (;;) {\t\t\t/* explicit break on eof from fscanf */\n\tint nread;\n\n\tmemset((char *)&aprinc, 0, sizeof(aprinc));\n\tnread = fscanf(input_file,\n\t\t       \"%s %s %d %d %d %hd %lx %lx %s %s %s %s\\n\",\n\t\t       aprinc.name,\n\t\t       aprinc.instance,\n\t\t       &temp1,\n\t\t       &temp2,\n\t\t       &temp3,\n\t\t       &aprinc.attributes,\n\t\t       &aprinc.key_low,\n\t\t       &aprinc.key_high,\n\t\t       exp_date_str,\n\t\t       mod_date_str,\n\t\t       aprinc.mod_name,\n\t\t       aprinc.mod_instance);\n\tif (nread != 12) {\n\t    retval = nread == EOF ? 0 : KRB5_KDB_DB_CORRUPT;\n\t    break;\n\t}\n\tif (!strcmp(aprinc.name, \"default\")\n\t    && !strcmp(aprinc.instance, \"*\")) {\n\t    foundtime = time_explode(exp_date_str);\n\t    if (foundtime == guess1 || foundtime == guess2)\n\t        *exptime = foundtime;\n\t    if (verbose) {\n\t        printf(\"\\ndefault expiration found: \");\n\t        if (foundtime == guess1) {\n\t\t    printf(\"MIT or pre96q1 value (1999)\");\n\t\t} else if (foundtime == guess2) {\n\t\t    printf(\"Cygnus CNS post 96q1 value (2009)\");\n\t\t} else {\n\t\t    printf(\"non-default start time (%ld,%s)\",\n\t\t\t   foundtime, exp_date_str);\n\t\t}\n\t    }\n\t    break;\n\t}\n    }\n    (void) fclose(input_file);\n    return retval;\n}"
  },
  {
    "function_name": "process_v4_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
    "lines": "816-877",
    "snippet": "static krb5_error_code\nprocess_v4_dump(context, dumpfile, realm, default_exp_time)\nkrb5_context context;\nchar *dumpfile;\nchar *realm;\nlong default_exp_time;\n{\n    krb5_error_code retval;\n    FILE *input_file;\n    Principal aprinc;\n    char    exp_date_str[50];\n    char    mod_date_str[50];\n    int     temp1, temp2, temp3;\n\n    input_file = fopen(dumpfile, \"r\");\n    if (!input_file)\n\treturn errno;\n\n    for (;;) {\t\t\t/* explicit break on eof from fscanf */\n\tint nread;\n\n\tmemset((char *)&aprinc, 0, sizeof(aprinc));\n\tnread = fscanf(input_file,\n\t\t       \"%s %s %d %d %d %hd %lx %lx %s %s %s %s\\n\",\n\t\t       aprinc.name,\n\t\t       aprinc.instance,\n\t\t       &temp1,\n\t\t       &temp2,\n\t\t       &temp3,\n\t\t       &aprinc.attributes,\n\t\t       &aprinc.key_low,\n\t\t       &aprinc.key_high,\n\t\t       exp_date_str,\n\t\t       mod_date_str,\n\t\t       aprinc.mod_name,\n\t\t       aprinc.mod_instance);\n\tif (nread != 12) {\n\t    retval = nread == EOF ? 0 : KRB5_KDB_DB_CORRUPT;\n\t    break;\n\t}\n\taprinc.key_low = ntohl (aprinc.key_low);\n\taprinc.key_high = ntohl (aprinc.key_high);\n\taprinc.max_life = (unsigned char) temp1;\n\taprinc.kdc_key_ver = (unsigned char) temp2;\n\taprinc.key_version = (unsigned char) temp3;\n\taprinc.exp_date = time_explode(exp_date_str);\n\tif (aprinc.exp_date == default_exp_time)\n\t    aprinc.exp_date = 0;\n\taprinc.mod_date = time_explode(mod_date_str);\n\tif (aprinc.instance[0] == '*')\n\t    aprinc.instance[0] = '\\0';\n\tif (aprinc.mod_name[0] == '*')\n\t    aprinc.mod_name[0] = '\\0';\n\tif (aprinc.mod_instance[0] == '*')\n\t    aprinc.mod_instance[0] = '\\0';\n\tretval = enter_in_v5_db(context, realm, &aprinc);\n\tif (retval)\n\t    break;\n    }\n    (void) fclose(input_file);\n    return retval;\n}",
    "includes": [
      "#include <netinet/in.h>\t\t\t/* ntohl */",
      "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
      "#include \"kdb5_util.h\"",
      "#include <stdio.h>",
      "#include <kadm5/admin.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "input_file"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "enter_in_v5_db",
          "args": [
            "context",
            "realm",
            "&aprinc"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "enter_in_v5_db",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
          "lines": "474-620",
          "snippet": "static krb5_error_code\nenter_in_v5_db(context, realm, princ)\nkrb5_context context;\nchar *realm;\nPrincipal *princ;\n{\n    krb5_db_entry entry;\n    krb5_error_code retval;\n    krb5_keyblock v4v5key;\n    int nentries = 1;\n    des_cblock v4key;\n    char *name;\n    krb5_timestamp\tmod_time;\n    krb5_principal\tmod_princ;\n    krb5_keysalt\tkeysalt;\n\n    /* don't convert local TGT if we created a TGT already.... */\n    if (create_local_tgt && !strcmp(princ->name, \"krbtgt\") &&\n\t!strcmp(princ->instance, realm)) {\n\t    if (verbose)\n\t\t    printf(\"\\nignoring local TGT: '%s.%s' ...\",\n\t\t\t   princ->name, princ->instance);\n\t    return 0;\n    }\n    if (!strcmp(princ->name, KERB_M_NAME) &&\n\t!strcmp(princ->instance, KERB_M_INST)) {\n\tdes_cblock key_from_db;\n\tint val;\n\n\t/* here's our chance to verify the master key */\n\t/*\n\t * use the master key to decrypt the key in the db, had better\n\t * be the same! \n\t */\n\tmemcpy(key_from_db, (char *)&princ->key_low, 4);\n\tmemcpy(((char *) key_from_db) + 4, (char *)&princ->key_high, 4);\n\tpcbc_encrypt((C_Block *) &key_from_db,\n\t\t     (C_Block *) &key_from_db,\n\t\t     (long) sizeof(C_Block),\n\t\t     master_key_schedule,\n\t\t     (C_Block *) master_key,\n\t\t     DECRYPT);\n\tval = memcmp((char *) master_key, (char *) key_from_db,\n\t\t     sizeof(master_key));\n\tmemset((char *)key_from_db, 0, sizeof(key_from_db));\n\tif (val) {\n\t    return KRB5_KDB_BADMASTERKEY;\n\t}\n\tif (verbose)\n\t    printf(\"\\nignoring '%s.%s' ...\", princ->name, princ->instance);\n\treturn 0;\n    }\n    memset((char *) &entry, 0, sizeof(entry));\n    retval = krb5_425_conv_principal(context, princ->name, princ->instance,\n\t\t\t\t     realm, &entry.princ);\n    if (retval)\n\treturn retval;\n    if (verbose) {\n\tretval = krb5_unparse_name(context, entry.princ, &name);\n\tif (retval)\n\t   name = strdup(\"<not unparsable name!>\");\n\tif (verbose)\n\t    printf(\"\\ntranslating %s...\", name);\n\tfree(name);\n    }\n\n    retval = krb5_build_principal(context, &mod_princ,\n\t\t\t\t  strlen(realm), realm, princ->mod_name,\n\t\t\t\t  princ->mod_instance[0] ? \n\t\t\t\t    princ->mod_instance : 0,\n\t\t\t\t  0);\n    if (retval) {\n\tkrb5_free_principal(context, entry.princ);\n\treturn retval;\n    }\n    mod_time = princ->mod_date;\n\n    if (!shortlife)\n\tentry.max_life = krb_life_to_time(0, princ->max_life);\n    else\n\tentry.max_life = princ->max_life * 60 * 5;\n    entry.max_renewable_life = rblock.max_rlife;\n    entry.len = KRB5_KDB_V1_BASE_LENGTH;\n    entry.expiration = princ->exp_date;\n    entry.attributes = rblock.flags;\t/* XXX is there a way to convert\n\t\t\t\t\t   the old attrs? */\n\n    memcpy((char *)v4key, (char *)&(princ->key_low), 4);\n    memcpy((char *) (((char *) v4key) + 4), (char *)&(princ->key_high), 4);\n    pcbc_encrypt((C_Block *) &v4key,\n\t\t (C_Block *) &v4key,\n\t\t (long) sizeof(C_Block),\n\t\t master_key_schedule,\n\t\t (C_Block *) master_key,\n\t\t DECRYPT);\n\n    v4v5key.magic = KV5M_KEYBLOCK;\n    v4v5key.contents = (krb5_octet *)v4key;\n    v4v5key.enctype = ENCTYPE_DES_CBC_CRC;\n    v4v5key.length = sizeof(v4key);\n\n    retval = krb5_dbe_create_key_data(context, &entry);\n    if (retval) {\n\tkrb5_free_principal(context, entry.princ);\n\tkrb5_free_principal(context, mod_princ);\n\treturn retval;\n    }\n\n    keysalt.type = KRB5_KDB_SALTTYPE_V4;\n    keysalt.data.length = 0;\n    keysalt.data.data = (char *) NULL;\n    retval = krb5_dbekd_encrypt_key_data(context, rblock.key,\n\t\t\t\t\t &v4v5key, &keysalt, \n\t\t\t\t\t princ->key_version,\n\t\t\t\t\t &entry.key_data[0]);\n    if (!retval)\n\tretval = krb5_dbe_update_mod_princ_data(context, &entry,\n\t\t\t\t\t\tmod_time, mod_princ);\n    if (!retval)\n        retval = krb5_dbe_update_last_pwd_change(context, &entry, mod_time);\n\n    if (retval) {\n\tkrb5_db_free_principal(context, &entry, 1);\n\tkrb5_free_principal(context, mod_princ);\n\treturn retval;\n    }\n    memset((char *)v4key, 0, sizeof(v4key));\n\n    retval = krb5_db_put_principal(context, &entry, &nentries);\n\n    if (!retval && !strcmp(princ->name, \"krbtgt\") &&\n\tstrcmp(princ->instance, realm) && princ->instance[0]) {\n\t    krb5_free_principal(context, entry.princ);\n\t    retval = krb5_build_principal(context, &entry.princ,\n\t\t\t\t\t  strlen(princ->instance),\n\t\t\t\t\t  princ->instance,\n\t\t\t\t\t  \"krbtgt\", realm, 0);\n\t    if (retval)\n\t\t    return retval;\n\t    retval = krb5_db_put_principal(context, &entry, &nentries);\n    }\n\n    krb5_db_free_principal(context, &entry, 1);\n    krb5_free_principal(context, mod_princ);\n\n    return retval;\n}",
          "includes": [
            "#include <netinet/in.h>\t\t\t/* ntohl */",
            "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
            "#include \"kdb5_util.h\"",
            "#include <stdio.h>",
            "#include <kadm5/admin.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic krb5_error_code\nenter_in_v5_db(context, realm, princ)\nkrb5_context context;\nchar *realm;\nPrincipal *princ;\n{\n    krb5_db_entry entry;\n    krb5_error_code retval;\n    krb5_keyblock v4v5key;\n    int nentries = 1;\n    des_cblock v4key;\n    char *name;\n    krb5_timestamp\tmod_time;\n    krb5_principal\tmod_princ;\n    krb5_keysalt\tkeysalt;\n\n    /* don't convert local TGT if we created a TGT already.... */\n    if (create_local_tgt && !strcmp(princ->name, \"krbtgt\") &&\n\t!strcmp(princ->instance, realm)) {\n\t    if (verbose)\n\t\t    printf(\"\\nignoring local TGT: '%s.%s' ...\",\n\t\t\t   princ->name, princ->instance);\n\t    return 0;\n    }\n    if (!strcmp(princ->name, KERB_M_NAME) &&\n\t!strcmp(princ->instance, KERB_M_INST)) {\n\tdes_cblock key_from_db;\n\tint val;\n\n\t/* here's our chance to verify the master key */\n\t/*\n\t * use the master key to decrypt the key in the db, had better\n\t * be the same! \n\t */\n\tmemcpy(key_from_db, (char *)&princ->key_low, 4);\n\tmemcpy(((char *) key_from_db) + 4, (char *)&princ->key_high, 4);\n\tpcbc_encrypt((C_Block *) &key_from_db,\n\t\t     (C_Block *) &key_from_db,\n\t\t     (long) sizeof(C_Block),\n\t\t     master_key_schedule,\n\t\t     (C_Block *) master_key,\n\t\t     DECRYPT);\n\tval = memcmp((char *) master_key, (char *) key_from_db,\n\t\t     sizeof(master_key));\n\tmemset((char *)key_from_db, 0, sizeof(key_from_db));\n\tif (val) {\n\t    return KRB5_KDB_BADMASTERKEY;\n\t}\n\tif (verbose)\n\t    printf(\"\\nignoring '%s.%s' ...\", princ->name, princ->instance);\n\treturn 0;\n    }\n    memset((char *) &entry, 0, sizeof(entry));\n    retval = krb5_425_conv_principal(context, princ->name, princ->instance,\n\t\t\t\t     realm, &entry.princ);\n    if (retval)\n\treturn retval;\n    if (verbose) {\n\tretval = krb5_unparse_name(context, entry.princ, &name);\n\tif (retval)\n\t   name = strdup(\"<not unparsable name!>\");\n\tif (verbose)\n\t    printf(\"\\ntranslating %s...\", name);\n\tfree(name);\n    }\n\n    retval = krb5_build_principal(context, &mod_princ,\n\t\t\t\t  strlen(realm), realm, princ->mod_name,\n\t\t\t\t  princ->mod_instance[0] ? \n\t\t\t\t    princ->mod_instance : 0,\n\t\t\t\t  0);\n    if (retval) {\n\tkrb5_free_principal(context, entry.princ);\n\treturn retval;\n    }\n    mod_time = princ->mod_date;\n\n    if (!shortlife)\n\tentry.max_life = krb_life_to_time(0, princ->max_life);\n    else\n\tentry.max_life = princ->max_life * 60 * 5;\n    entry.max_renewable_life = rblock.max_rlife;\n    entry.len = KRB5_KDB_V1_BASE_LENGTH;\n    entry.expiration = princ->exp_date;\n    entry.attributes = rblock.flags;\t/* XXX is there a way to convert\n\t\t\t\t\t   the old attrs? */\n\n    memcpy((char *)v4key, (char *)&(princ->key_low), 4);\n    memcpy((char *) (((char *) v4key) + 4), (char *)&(princ->key_high), 4);\n    pcbc_encrypt((C_Block *) &v4key,\n\t\t (C_Block *) &v4key,\n\t\t (long) sizeof(C_Block),\n\t\t master_key_schedule,\n\t\t (C_Block *) master_key,\n\t\t DECRYPT);\n\n    v4v5key.magic = KV5M_KEYBLOCK;\n    v4v5key.contents = (krb5_octet *)v4key;\n    v4v5key.enctype = ENCTYPE_DES_CBC_CRC;\n    v4v5key.length = sizeof(v4key);\n\n    retval = krb5_dbe_create_key_data(context, &entry);\n    if (retval) {\n\tkrb5_free_principal(context, entry.princ);\n\tkrb5_free_principal(context, mod_princ);\n\treturn retval;\n    }\n\n    keysalt.type = KRB5_KDB_SALTTYPE_V4;\n    keysalt.data.length = 0;\n    keysalt.data.data = (char *) NULL;\n    retval = krb5_dbekd_encrypt_key_data(context, rblock.key,\n\t\t\t\t\t &v4v5key, &keysalt, \n\t\t\t\t\t princ->key_version,\n\t\t\t\t\t &entry.key_data[0]);\n    if (!retval)\n\tretval = krb5_dbe_update_mod_princ_data(context, &entry,\n\t\t\t\t\t\tmod_time, mod_princ);\n    if (!retval)\n        retval = krb5_dbe_update_last_pwd_change(context, &entry, mod_time);\n\n    if (retval) {\n\tkrb5_db_free_principal(context, &entry, 1);\n\tkrb5_free_principal(context, mod_princ);\n\treturn retval;\n    }\n    memset((char *)v4key, 0, sizeof(v4key));\n\n    retval = krb5_db_put_principal(context, &entry, &nentries);\n\n    if (!retval && !strcmp(princ->name, \"krbtgt\") &&\n\tstrcmp(princ->instance, realm) && princ->instance[0]) {\n\t    krb5_free_principal(context, entry.princ);\n\t    retval = krb5_build_principal(context, &entry.princ,\n\t\t\t\t\t  strlen(princ->instance),\n\t\t\t\t\t  princ->instance,\n\t\t\t\t\t  \"krbtgt\", realm, 0);\n\t    if (retval)\n\t\t    return retval;\n\t    retval = krb5_db_put_principal(context, &entry, &nentries);\n    }\n\n    krb5_db_free_principal(context, &entry, 1);\n    krb5_free_principal(context, mod_princ);\n\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_explode",
          "args": [
            "mod_date_str"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "time_explode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
          "lines": "770-814",
          "snippet": "static long\ntime_explode(cp)\nregister char *cp;\n{\n    char wbuf[5];\n    struct tm tp;\n    int local;\n\n    memset((char *)&tp, 0, sizeof(tp));\n    \n    if (strlen(cp) > 10) {\t\t/* new format */\n\t(void) strncpy(wbuf, cp, 4);\n\twbuf[4] = 0;\n\ttp.tm_year = atoi(wbuf);\n\tcp += 4;\t\t\t/* step over the year */\n\tlocal = 0;\t\t\t/* GMT */\n    } else {\t\t\t\t/* old format: local time, \n\t\t\t\t\t   year is 2 digits, assuming 19xx */\n\twbuf[0] = *cp++;\n\twbuf[1] = *cp++;\n\twbuf[2] = 0;\n\ttp.tm_year = 1900 + atoi(wbuf);\n\tlocal = 1;\t\t\t/* local */\n    }\n\n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    wbuf[2] = 0;\n    tp.tm_mon = atoi(wbuf)-1;\n\n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_mday = atoi(wbuf);\n    \n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_hour = atoi(wbuf);\n    \n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_min = atoi(wbuf);\n\n\n    return(maketime(&tp, local));\n}",
          "includes": [
            "#include <netinet/in.h>\t\t\t/* ntohl */",
            "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
            "#include \"kdb5_util.h\"",
            "#include <stdio.h>",
            "#include <kadm5/admin.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic long\ntime_explode(cp)\nregister char *cp;\n{\n    char wbuf[5];\n    struct tm tp;\n    int local;\n\n    memset((char *)&tp, 0, sizeof(tp));\n    \n    if (strlen(cp) > 10) {\t\t/* new format */\n\t(void) strncpy(wbuf, cp, 4);\n\twbuf[4] = 0;\n\ttp.tm_year = atoi(wbuf);\n\tcp += 4;\t\t\t/* step over the year */\n\tlocal = 0;\t\t\t/* GMT */\n    } else {\t\t\t\t/* old format: local time, \n\t\t\t\t\t   year is 2 digits, assuming 19xx */\n\twbuf[0] = *cp++;\n\twbuf[1] = *cp++;\n\twbuf[2] = 0;\n\ttp.tm_year = 1900 + atoi(wbuf);\n\tlocal = 1;\t\t\t/* local */\n    }\n\n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    wbuf[2] = 0;\n    tp.tm_mon = atoi(wbuf)-1;\n\n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_mday = atoi(wbuf);\n    \n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_hour = atoi(wbuf);\n    \n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_min = atoi(wbuf);\n\n\n    return(maketime(&tp, local));\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "aprinc.key_high"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntohl",
          "args": [
            "aprinc.key_low"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fscanf",
          "args": [
            "input_file",
            "\"%s %s %d %d %d %hd %lx %lx %s %s %s %s\\n\"",
            "aprinc.name",
            "aprinc.instance",
            "&temp1",
            "&temp2",
            "&temp3",
            "&aprinc.attributes",
            "&aprinc.key_low",
            "&aprinc.key_high",
            "exp_date_str",
            "mod_date_str",
            "aprinc.mod_name",
            "aprinc.mod_instance"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&aprinc",
            "0",
            "sizeof(aprinc)"
          ],
          "line": 837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "dumpfile",
            "\"r\""
          ],
          "line": 830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic krb5_error_code\nprocess_v4_dump(context, dumpfile, realm, default_exp_time)\nkrb5_context context;\nchar *dumpfile;\nchar *realm;\nlong default_exp_time;\n{\n    krb5_error_code retval;\n    FILE *input_file;\n    Principal aprinc;\n    char    exp_date_str[50];\n    char    mod_date_str[50];\n    int     temp1, temp2, temp3;\n\n    input_file = fopen(dumpfile, \"r\");\n    if (!input_file)\n\treturn errno;\n\n    for (;;) {\t\t\t/* explicit break on eof from fscanf */\n\tint nread;\n\n\tmemset((char *)&aprinc, 0, sizeof(aprinc));\n\tnread = fscanf(input_file,\n\t\t       \"%s %s %d %d %d %hd %lx %lx %s %s %s %s\\n\",\n\t\t       aprinc.name,\n\t\t       aprinc.instance,\n\t\t       &temp1,\n\t\t       &temp2,\n\t\t       &temp3,\n\t\t       &aprinc.attributes,\n\t\t       &aprinc.key_low,\n\t\t       &aprinc.key_high,\n\t\t       exp_date_str,\n\t\t       mod_date_str,\n\t\t       aprinc.mod_name,\n\t\t       aprinc.mod_instance);\n\tif (nread != 12) {\n\t    retval = nread == EOF ? 0 : KRB5_KDB_DB_CORRUPT;\n\t    break;\n\t}\n\taprinc.key_low = ntohl (aprinc.key_low);\n\taprinc.key_high = ntohl (aprinc.key_high);\n\taprinc.max_life = (unsigned char) temp1;\n\taprinc.kdc_key_ver = (unsigned char) temp2;\n\taprinc.key_version = (unsigned char) temp3;\n\taprinc.exp_date = time_explode(exp_date_str);\n\tif (aprinc.exp_date == default_exp_time)\n\t    aprinc.exp_date = 0;\n\taprinc.mod_date = time_explode(mod_date_str);\n\tif (aprinc.instance[0] == '*')\n\t    aprinc.instance[0] = '\\0';\n\tif (aprinc.mod_name[0] == '*')\n\t    aprinc.mod_name[0] = '\\0';\n\tif (aprinc.mod_instance[0] == '*')\n\t    aprinc.mod_instance[0] = '\\0';\n\tretval = enter_in_v5_db(context, realm, &aprinc);\n\tif (retval)\n\t    break;\n    }\n    (void) fclose(input_file);\n    return retval;\n}"
  },
  {
    "function_name": "time_explode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
    "lines": "770-814",
    "snippet": "static long\ntime_explode(cp)\nregister char *cp;\n{\n    char wbuf[5];\n    struct tm tp;\n    int local;\n\n    memset((char *)&tp, 0, sizeof(tp));\n    \n    if (strlen(cp) > 10) {\t\t/* new format */\n\t(void) strncpy(wbuf, cp, 4);\n\twbuf[4] = 0;\n\ttp.tm_year = atoi(wbuf);\n\tcp += 4;\t\t\t/* step over the year */\n\tlocal = 0;\t\t\t/* GMT */\n    } else {\t\t\t\t/* old format: local time, \n\t\t\t\t\t   year is 2 digits, assuming 19xx */\n\twbuf[0] = *cp++;\n\twbuf[1] = *cp++;\n\twbuf[2] = 0;\n\ttp.tm_year = 1900 + atoi(wbuf);\n\tlocal = 1;\t\t\t/* local */\n    }\n\n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    wbuf[2] = 0;\n    tp.tm_mon = atoi(wbuf)-1;\n\n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_mday = atoi(wbuf);\n    \n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_hour = atoi(wbuf);\n    \n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_min = atoi(wbuf);\n\n\n    return(maketime(&tp, local));\n}",
    "includes": [
      "#include <netinet/in.h>\t\t\t/* ntohl */",
      "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
      "#include \"kdb5_util.h\"",
      "#include <stdio.h>",
      "#include <kadm5/admin.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "maketime",
          "args": [
            "&tp",
            "local"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "maketime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
          "lines": "716-768",
          "snippet": "static long\nmaketime(tp, local)\nregister struct tm *tp;\nint local;\n{\n    register long retval;\n    int foo;\n    int *marray;\n\n    if (tp->tm_mon < 0 || tp->tm_mon > 11 ||\n\ttp->tm_hour < 0 || tp->tm_hour > 23 ||\n\ttp->tm_min < 0 || tp->tm_min > 59 ||\n\ttp->tm_sec < 0 || tp->tm_sec > 59) /* out of range */\n\treturn 0;\n\n    retval = 0;\n    if (tp->tm_year < 1900)\n\tfoo = tp->tm_year + 1900;\n    else\n\tfoo = tp->tm_year;\n\n    if (foo < 1901 || foo > 2038)\t/* year is too small/large */\n\treturn 0;\n\n    if (daysinyear(foo) == 366) {\n\tif (tp->tm_mon > 1)\n\t    retval+= SECSPERDAY;\t/* add leap day */\n\tmarray = leapyear;\n    } else\n\tmarray = nonleapyear;\n\n    if (tp->tm_mday < 0 || tp->tm_mday > marray[tp->tm_mon])\n\treturn 0;\t\t\t/* out of range */\n\n    while (--foo >= 1970)\n\tretval += daysinyear(foo) * SECSPERDAY;\n\n    retval += cumdays[tp->tm_mon] * SECSPERDAY;\n    retval += (tp->tm_mday-1) * SECSPERDAY;\n    retval += tp->tm_hour * SECSPERHOUR + tp->tm_min * SECSPERMIN + tp->tm_sec;\n\n    if (local) {\n\t/* need to use local time, so we retrieve timezone info */\n\tstruct timezone tz;\n\tstruct timeval tv;\n\tif (gettimeofday(&tv, &tz) < 0) {\n\t    /* some error--give up? */\n\t    return(retval);\n\t}\n\tretval += tz.tz_minuteswest * SECSPERMIN;\n    }\n    return(retval);\n}",
          "includes": [
            "#include <netinet/in.h>\t\t\t/* ntohl */",
            "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
            "#include \"kdb5_util.h\"",
            "#include <stdio.h>",
            "#include <kadm5/admin.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [
            "#define SECSPERMIN 60",
            "#define SECSPERHOUR 60*60",
            "#define SECSPERDAY 24*60*60"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\n#define SECSPERMIN 60\n#define SECSPERHOUR 60*60\n#define SECSPERDAY 24*60*60\n\nstatic long\nmaketime(tp, local)\nregister struct tm *tp;\nint local;\n{\n    register long retval;\n    int foo;\n    int *marray;\n\n    if (tp->tm_mon < 0 || tp->tm_mon > 11 ||\n\ttp->tm_hour < 0 || tp->tm_hour > 23 ||\n\ttp->tm_min < 0 || tp->tm_min > 59 ||\n\ttp->tm_sec < 0 || tp->tm_sec > 59) /* out of range */\n\treturn 0;\n\n    retval = 0;\n    if (tp->tm_year < 1900)\n\tfoo = tp->tm_year + 1900;\n    else\n\tfoo = tp->tm_year;\n\n    if (foo < 1901 || foo > 2038)\t/* year is too small/large */\n\treturn 0;\n\n    if (daysinyear(foo) == 366) {\n\tif (tp->tm_mon > 1)\n\t    retval+= SECSPERDAY;\t/* add leap day */\n\tmarray = leapyear;\n    } else\n\tmarray = nonleapyear;\n\n    if (tp->tm_mday < 0 || tp->tm_mday > marray[tp->tm_mon])\n\treturn 0;\t\t\t/* out of range */\n\n    while (--foo >= 1970)\n\tretval += daysinyear(foo) * SECSPERDAY;\n\n    retval += cumdays[tp->tm_mon] * SECSPERDAY;\n    retval += (tp->tm_mday-1) * SECSPERDAY;\n    retval += tp->tm_hour * SECSPERHOUR + tp->tm_min * SECSPERMIN + tp->tm_sec;\n\n    if (local) {\n\t/* need to use local time, so we retrieve timezone info */\n\tstruct timezone tz;\n\tstruct timeval tv;\n\tif (gettimeofday(&tv, &tz) < 0) {\n\t    /* some error--give up? */\n\t    return(retval);\n\t}\n\tretval += tz.tz_minuteswest * SECSPERMIN;\n    }\n    return(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "wbuf"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "wbuf"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "wbuf"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "wbuf"
          ],
          "line": 798
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "wbuf"
          ],
          "line": 791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atoi",
          "args": [
            "wbuf"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "wbuf",
            "cp",
            "4"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)&tp",
            "0",
            "sizeof(tp)"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic long\ntime_explode(cp)\nregister char *cp;\n{\n    char wbuf[5];\n    struct tm tp;\n    int local;\n\n    memset((char *)&tp, 0, sizeof(tp));\n    \n    if (strlen(cp) > 10) {\t\t/* new format */\n\t(void) strncpy(wbuf, cp, 4);\n\twbuf[4] = 0;\n\ttp.tm_year = atoi(wbuf);\n\tcp += 4;\t\t\t/* step over the year */\n\tlocal = 0;\t\t\t/* GMT */\n    } else {\t\t\t\t/* old format: local time, \n\t\t\t\t\t   year is 2 digits, assuming 19xx */\n\twbuf[0] = *cp++;\n\twbuf[1] = *cp++;\n\twbuf[2] = 0;\n\ttp.tm_year = 1900 + atoi(wbuf);\n\tlocal = 1;\t\t\t/* local */\n    }\n\n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    wbuf[2] = 0;\n    tp.tm_mon = atoi(wbuf)-1;\n\n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_mday = atoi(wbuf);\n    \n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_hour = atoi(wbuf);\n    \n    wbuf[0] = *cp++;\n    wbuf[1] = *cp++;\n    tp.tm_min = atoi(wbuf);\n\n\n    return(maketime(&tp, local));\n}"
  },
  {
    "function_name": "maketime",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
    "lines": "716-768",
    "snippet": "static long\nmaketime(tp, local)\nregister struct tm *tp;\nint local;\n{\n    register long retval;\n    int foo;\n    int *marray;\n\n    if (tp->tm_mon < 0 || tp->tm_mon > 11 ||\n\ttp->tm_hour < 0 || tp->tm_hour > 23 ||\n\ttp->tm_min < 0 || tp->tm_min > 59 ||\n\ttp->tm_sec < 0 || tp->tm_sec > 59) /* out of range */\n\treturn 0;\n\n    retval = 0;\n    if (tp->tm_year < 1900)\n\tfoo = tp->tm_year + 1900;\n    else\n\tfoo = tp->tm_year;\n\n    if (foo < 1901 || foo > 2038)\t/* year is too small/large */\n\treturn 0;\n\n    if (daysinyear(foo) == 366) {\n\tif (tp->tm_mon > 1)\n\t    retval+= SECSPERDAY;\t/* add leap day */\n\tmarray = leapyear;\n    } else\n\tmarray = nonleapyear;\n\n    if (tp->tm_mday < 0 || tp->tm_mday > marray[tp->tm_mon])\n\treturn 0;\t\t\t/* out of range */\n\n    while (--foo >= 1970)\n\tretval += daysinyear(foo) * SECSPERDAY;\n\n    retval += cumdays[tp->tm_mon] * SECSPERDAY;\n    retval += (tp->tm_mday-1) * SECSPERDAY;\n    retval += tp->tm_hour * SECSPERHOUR + tp->tm_min * SECSPERMIN + tp->tm_sec;\n\n    if (local) {\n\t/* need to use local time, so we retrieve timezone info */\n\tstruct timezone tz;\n\tstruct timeval tv;\n\tif (gettimeofday(&tv, &tz) < 0) {\n\t    /* some error--give up? */\n\t    return(retval);\n\t}\n\tretval += tz.tz_minuteswest * SECSPERMIN;\n    }\n    return(retval);\n}",
    "includes": [
      "#include <netinet/in.h>\t\t\t/* ntohl */",
      "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
      "#include \"kdb5_util.h\"",
      "#include <stdio.h>",
      "#include <kadm5/admin.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [
      "#define SECSPERMIN 60",
      "#define SECSPERHOUR 60*60",
      "#define SECSPERDAY 24*60*60"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "gettimeofday",
          "args": [
            "&tv",
            "&tz"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daysinyear",
          "args": [
            "foo"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "daysinyear",
          "args": [
            "foo"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\n#define SECSPERMIN 60\n#define SECSPERHOUR 60*60\n#define SECSPERDAY 24*60*60\n\nstatic long\nmaketime(tp, local)\nregister struct tm *tp;\nint local;\n{\n    register long retval;\n    int foo;\n    int *marray;\n\n    if (tp->tm_mon < 0 || tp->tm_mon > 11 ||\n\ttp->tm_hour < 0 || tp->tm_hour > 23 ||\n\ttp->tm_min < 0 || tp->tm_min > 59 ||\n\ttp->tm_sec < 0 || tp->tm_sec > 59) /* out of range */\n\treturn 0;\n\n    retval = 0;\n    if (tp->tm_year < 1900)\n\tfoo = tp->tm_year + 1900;\n    else\n\tfoo = tp->tm_year;\n\n    if (foo < 1901 || foo > 2038)\t/* year is too small/large */\n\treturn 0;\n\n    if (daysinyear(foo) == 366) {\n\tif (tp->tm_mon > 1)\n\t    retval+= SECSPERDAY;\t/* add leap day */\n\tmarray = leapyear;\n    } else\n\tmarray = nonleapyear;\n\n    if (tp->tm_mday < 0 || tp->tm_mday > marray[tp->tm_mon])\n\treturn 0;\t\t\t/* out of range */\n\n    while (--foo >= 1970)\n\tretval += daysinyear(foo) * SECSPERDAY;\n\n    retval += cumdays[tp->tm_mon] * SECSPERDAY;\n    retval += (tp->tm_mday-1) * SECSPERDAY;\n    retval += tp->tm_hour * SECSPERHOUR + tp->tm_min * SECSPERMIN + tp->tm_sec;\n\n    if (local) {\n\t/* need to use local time, so we retrieve timezone info */\n\tstruct timezone tz;\n\tstruct timeval tv;\n\tif (gettimeofday(&tv, &tz) < 0) {\n\t    /* some error--give up? */\n\t    return(retval);\n\t}\n\tretval += tz.tz_minuteswest * SECSPERMIN;\n    }\n    return(retval);\n}"
  },
  {
    "function_name": "add_principal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
    "lines": "622-697",
    "snippet": "static krb5_error_code\nadd_principal(context, princ, op, pblock)\nkrb5_context context;\nkrb5_principal princ;\nenum ap_op op;\nstruct realm_info *pblock;\n{\n    krb5_db_entry entry;\n    krb5_error_code retval;\n    krb5_keyblock rkey;\n    int nentries = 1;\n    krb5_timestamp mod_time;\n\n    memset((char *) &entry, 0, sizeof(entry));\n    retval = krb5_copy_principal(context, princ, &entry.princ);\n    if (retval)\n\treturn(retval);\n    entry.max_life = pblock->max_life;\n    entry.max_renewable_life = pblock->max_rlife;\n    entry.len = KRB5_KDB_V1_BASE_LENGTH;\n    entry.expiration = pblock->expiration;\n    \n    retval = krb5_timeofday(context, &mod_time);\n    if (retval) {\n\tkrb5_db_free_principal(context, &entry, 1);\n\treturn retval;\n    }\n    entry.attributes = pblock->flags;\n\n    retval = krb5_dbe_create_key_data(context, &entry);\n    if (retval) {\n\tkrb5_db_free_principal(context, &entry, 1);\n\treturn(retval);\n    }\n\n    switch (op) {\n    case MASTER_KEY:\n\tentry.attributes |= KRB5_KDB_DISALLOW_ALL_TIX;\n\tretval = krb5_dbekd_encrypt_key_data(context, pblock->key,\n\t\t\t\t\t     &master_keyblock,\n\t\t\t\t\t     (krb5_keysalt *) NULL, 1,\n\t\t\t\t\t     &entry.key_data[0]);\n\tif (retval) {\n\t    krb5_db_free_principal(context, &entry, 1);\n\t    return retval;\n\t}\n\tbreak;\n    case RANDOM_KEY:\n\tretval = krb5_c_make_random_key(context, pblock->key->enctype,\n\t\t\t\t\t&rkey);\n\tif (retval) {\n\t    krb5_db_free_principal(context, &entry, 1);\n\t    return retval;\n\t}\n\tretval = krb5_dbekd_encrypt_key_data(context, pblock->key,\n\t\t\t\t\t     &rkey, (krb5_keysalt *) NULL, \n\t\t\t\t\t     1, &entry.key_data[0]);\n\tif (retval) {\n\t    krb5_db_free_principal(context, &entry, 1);\n\t    return(retval);\n\t}\n\tkrb5_free_keyblock_contents(context, &rkey);\n\tbreak;\n    case NULL_KEY:\n\treturn EOPNOTSUPP;\n    default:\n\tbreak;\n    }\n\n    retval = krb5_dbe_update_mod_princ_data(context, &entry,\n\t\t\t\t\t    mod_time, &db_create_princ);\n    if (!retval)\n\tretval = krb5_db_put_principal(context, &entry, &nentries);\n    krb5_db_free_principal(context, &entry, 1);\n    return retval;\n}",
    "includes": [
      "#include <netinet/in.h>\t\t\t/* ntohl */",
      "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
      "#include \"kdb5_util.h\"",
      "#include <stdio.h>",
      "#include <kadm5/admin.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_db_free_principal",
          "args": [
            "context",
            "&entry",
            "1"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_put_principal",
          "args": [
            "context",
            "&entry",
            "&nentries"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_update_mod_princ_data",
          "args": [
            "context",
            "&entry",
            "mod_time",
            "&db_create_princ"
          ],
          "line": 691
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_keyblock_contents",
          "args": [
            "context",
            "&rkey"
          ],
          "line": 683
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_free_principal",
          "args": [
            "context",
            "&entry",
            "1"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbekd_encrypt_key_data",
          "args": [
            "context",
            "pblock->key",
            "&rkey",
            "(krb5_keysalt *) NULL",
            "1",
            "&entry.key_data[0]"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_free_principal",
          "args": [
            "context",
            "&entry",
            "1"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_c_make_random_key",
          "args": [
            "context",
            "pblock->key->enctype",
            "&rkey"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_free_principal",
          "args": [
            "context",
            "&entry",
            "1"
          ],
          "line": 665
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbekd_encrypt_key_data",
          "args": [
            "context",
            "pblock->key",
            "&master_keyblock",
            "(krb5_keysalt *) NULL",
            "1",
            "&entry.key_data[0]"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_free_principal",
          "args": [
            "context",
            "&entry",
            "1"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_create_key_data",
          "args": [
            "context",
            "&entry"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_free_principal",
          "args": [
            "context",
            "&entry",
            "1"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_timeofday",
          "args": [
            "context",
            "&mod_time"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_copy_principal",
          "args": [
            "context",
            "princ",
            "&entry.princ"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *) &entry",
            "0",
            "sizeof(entry)"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic krb5_error_code\nadd_principal(context, princ, op, pblock)\nkrb5_context context;\nkrb5_principal princ;\nenum ap_op op;\nstruct realm_info *pblock;\n{\n    krb5_db_entry entry;\n    krb5_error_code retval;\n    krb5_keyblock rkey;\n    int nentries = 1;\n    krb5_timestamp mod_time;\n\n    memset((char *) &entry, 0, sizeof(entry));\n    retval = krb5_copy_principal(context, princ, &entry.princ);\n    if (retval)\n\treturn(retval);\n    entry.max_life = pblock->max_life;\n    entry.max_renewable_life = pblock->max_rlife;\n    entry.len = KRB5_KDB_V1_BASE_LENGTH;\n    entry.expiration = pblock->expiration;\n    \n    retval = krb5_timeofday(context, &mod_time);\n    if (retval) {\n\tkrb5_db_free_principal(context, &entry, 1);\n\treturn retval;\n    }\n    entry.attributes = pblock->flags;\n\n    retval = krb5_dbe_create_key_data(context, &entry);\n    if (retval) {\n\tkrb5_db_free_principal(context, &entry, 1);\n\treturn(retval);\n    }\n\n    switch (op) {\n    case MASTER_KEY:\n\tentry.attributes |= KRB5_KDB_DISALLOW_ALL_TIX;\n\tretval = krb5_dbekd_encrypt_key_data(context, pblock->key,\n\t\t\t\t\t     &master_keyblock,\n\t\t\t\t\t     (krb5_keysalt *) NULL, 1,\n\t\t\t\t\t     &entry.key_data[0]);\n\tif (retval) {\n\t    krb5_db_free_principal(context, &entry, 1);\n\t    return retval;\n\t}\n\tbreak;\n    case RANDOM_KEY:\n\tretval = krb5_c_make_random_key(context, pblock->key->enctype,\n\t\t\t\t\t&rkey);\n\tif (retval) {\n\t    krb5_db_free_principal(context, &entry, 1);\n\t    return retval;\n\t}\n\tretval = krb5_dbekd_encrypt_key_data(context, pblock->key,\n\t\t\t\t\t     &rkey, (krb5_keysalt *) NULL, \n\t\t\t\t\t     1, &entry.key_data[0]);\n\tif (retval) {\n\t    krb5_db_free_principal(context, &entry, 1);\n\t    return(retval);\n\t}\n\tkrb5_free_keyblock_contents(context, &rkey);\n\tbreak;\n    case NULL_KEY:\n\treturn EOPNOTSUPP;\n    default:\n\tbreak;\n    }\n\n    retval = krb5_dbe_update_mod_princ_data(context, &entry,\n\t\t\t\t\t    mod_time, &db_create_princ);\n    if (!retval)\n\tretval = krb5_db_put_principal(context, &entry, &nentries);\n    krb5_db_free_principal(context, &entry, 1);\n    return retval;\n}"
  },
  {
    "function_name": "enter_in_v5_db",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
    "lines": "474-620",
    "snippet": "static krb5_error_code\nenter_in_v5_db(context, realm, princ)\nkrb5_context context;\nchar *realm;\nPrincipal *princ;\n{\n    krb5_db_entry entry;\n    krb5_error_code retval;\n    krb5_keyblock v4v5key;\n    int nentries = 1;\n    des_cblock v4key;\n    char *name;\n    krb5_timestamp\tmod_time;\n    krb5_principal\tmod_princ;\n    krb5_keysalt\tkeysalt;\n\n    /* don't convert local TGT if we created a TGT already.... */\n    if (create_local_tgt && !strcmp(princ->name, \"krbtgt\") &&\n\t!strcmp(princ->instance, realm)) {\n\t    if (verbose)\n\t\t    printf(\"\\nignoring local TGT: '%s.%s' ...\",\n\t\t\t   princ->name, princ->instance);\n\t    return 0;\n    }\n    if (!strcmp(princ->name, KERB_M_NAME) &&\n\t!strcmp(princ->instance, KERB_M_INST)) {\n\tdes_cblock key_from_db;\n\tint val;\n\n\t/* here's our chance to verify the master key */\n\t/*\n\t * use the master key to decrypt the key in the db, had better\n\t * be the same! \n\t */\n\tmemcpy(key_from_db, (char *)&princ->key_low, 4);\n\tmemcpy(((char *) key_from_db) + 4, (char *)&princ->key_high, 4);\n\tpcbc_encrypt((C_Block *) &key_from_db,\n\t\t     (C_Block *) &key_from_db,\n\t\t     (long) sizeof(C_Block),\n\t\t     master_key_schedule,\n\t\t     (C_Block *) master_key,\n\t\t     DECRYPT);\n\tval = memcmp((char *) master_key, (char *) key_from_db,\n\t\t     sizeof(master_key));\n\tmemset((char *)key_from_db, 0, sizeof(key_from_db));\n\tif (val) {\n\t    return KRB5_KDB_BADMASTERKEY;\n\t}\n\tif (verbose)\n\t    printf(\"\\nignoring '%s.%s' ...\", princ->name, princ->instance);\n\treturn 0;\n    }\n    memset((char *) &entry, 0, sizeof(entry));\n    retval = krb5_425_conv_principal(context, princ->name, princ->instance,\n\t\t\t\t     realm, &entry.princ);\n    if (retval)\n\treturn retval;\n    if (verbose) {\n\tretval = krb5_unparse_name(context, entry.princ, &name);\n\tif (retval)\n\t   name = strdup(\"<not unparsable name!>\");\n\tif (verbose)\n\t    printf(\"\\ntranslating %s...\", name);\n\tfree(name);\n    }\n\n    retval = krb5_build_principal(context, &mod_princ,\n\t\t\t\t  strlen(realm), realm, princ->mod_name,\n\t\t\t\t  princ->mod_instance[0] ? \n\t\t\t\t    princ->mod_instance : 0,\n\t\t\t\t  0);\n    if (retval) {\n\tkrb5_free_principal(context, entry.princ);\n\treturn retval;\n    }\n    mod_time = princ->mod_date;\n\n    if (!shortlife)\n\tentry.max_life = krb_life_to_time(0, princ->max_life);\n    else\n\tentry.max_life = princ->max_life * 60 * 5;\n    entry.max_renewable_life = rblock.max_rlife;\n    entry.len = KRB5_KDB_V1_BASE_LENGTH;\n    entry.expiration = princ->exp_date;\n    entry.attributes = rblock.flags;\t/* XXX is there a way to convert\n\t\t\t\t\t   the old attrs? */\n\n    memcpy((char *)v4key, (char *)&(princ->key_low), 4);\n    memcpy((char *) (((char *) v4key) + 4), (char *)&(princ->key_high), 4);\n    pcbc_encrypt((C_Block *) &v4key,\n\t\t (C_Block *) &v4key,\n\t\t (long) sizeof(C_Block),\n\t\t master_key_schedule,\n\t\t (C_Block *) master_key,\n\t\t DECRYPT);\n\n    v4v5key.magic = KV5M_KEYBLOCK;\n    v4v5key.contents = (krb5_octet *)v4key;\n    v4v5key.enctype = ENCTYPE_DES_CBC_CRC;\n    v4v5key.length = sizeof(v4key);\n\n    retval = krb5_dbe_create_key_data(context, &entry);\n    if (retval) {\n\tkrb5_free_principal(context, entry.princ);\n\tkrb5_free_principal(context, mod_princ);\n\treturn retval;\n    }\n\n    keysalt.type = KRB5_KDB_SALTTYPE_V4;\n    keysalt.data.length = 0;\n    keysalt.data.data = (char *) NULL;\n    retval = krb5_dbekd_encrypt_key_data(context, rblock.key,\n\t\t\t\t\t &v4v5key, &keysalt, \n\t\t\t\t\t princ->key_version,\n\t\t\t\t\t &entry.key_data[0]);\n    if (!retval)\n\tretval = krb5_dbe_update_mod_princ_data(context, &entry,\n\t\t\t\t\t\tmod_time, mod_princ);\n    if (!retval)\n        retval = krb5_dbe_update_last_pwd_change(context, &entry, mod_time);\n\n    if (retval) {\n\tkrb5_db_free_principal(context, &entry, 1);\n\tkrb5_free_principal(context, mod_princ);\n\treturn retval;\n    }\n    memset((char *)v4key, 0, sizeof(v4key));\n\n    retval = krb5_db_put_principal(context, &entry, &nentries);\n\n    if (!retval && !strcmp(princ->name, \"krbtgt\") &&\n\tstrcmp(princ->instance, realm) && princ->instance[0]) {\n\t    krb5_free_principal(context, entry.princ);\n\t    retval = krb5_build_principal(context, &entry.princ,\n\t\t\t\t\t  strlen(princ->instance),\n\t\t\t\t\t  princ->instance,\n\t\t\t\t\t  \"krbtgt\", realm, 0);\n\t    if (retval)\n\t\t    return retval;\n\t    retval = krb5_db_put_principal(context, &entry, &nentries);\n    }\n\n    krb5_db_free_principal(context, &entry, 1);\n    krb5_free_principal(context, mod_princ);\n\n    return retval;\n}",
    "includes": [
      "#include <netinet/in.h>\t\t\t/* ntohl */",
      "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
      "#include \"kdb5_util.h\"",
      "#include <stdio.h>",
      "#include <kadm5/admin.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "mod_princ"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_free_principal",
          "args": [
            "context",
            "&entry",
            "1"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_put_principal",
          "args": [
            "context",
            "&entry",
            "&nentries"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_build_principal",
          "args": [
            "context",
            "&entry.princ",
            "strlen(princ->instance)",
            "princ->instance",
            "\"krbtgt\"",
            "realm",
            "0"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "princ->instance"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "entry.princ"
          ],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "princ->instance",
            "realm"
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "princ->name",
            "\"krbtgt\""
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_put_principal",
          "args": [
            "context",
            "&entry",
            "&nentries"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)v4key",
            "0",
            "sizeof(v4key)"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "mod_princ"
          ],
          "line": 597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_free_principal",
          "args": [
            "context",
            "&entry",
            "1"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_update_last_pwd_change",
          "args": [
            "context",
            "&entry",
            "mod_time"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_update_mod_princ_data",
          "args": [
            "context",
            "&entry",
            "mod_time",
            "mod_princ"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbekd_encrypt_key_data",
          "args": [
            "context",
            "rblock.key",
            "&v4v5key",
            "&keysalt",
            "princ->key_version",
            "&entry.key_data[0]"
          ],
          "line": 585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "mod_princ"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "entry.princ"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_dbe_create_key_data",
          "args": [
            "context",
            "&entry"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcbc_encrypt",
          "args": [
            "(C_Block *) &v4key",
            "(C_Block *) &v4key",
            "(long) sizeof(C_Block)",
            "master_key_schedule",
            "(C_Block *) master_key",
            "DECRYPT"
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *) (((char *) v4key) + 4)",
            "(char *)&(princ->key_high)",
            "4"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)v4key",
            "(char *)&(princ->key_low)",
            "4"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb_life_to_time",
          "args": [
            "0",
            "princ->max_life"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_principal",
          "args": [
            "context",
            "entry.princ"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_build_principal",
          "args": [
            "context",
            "&mod_princ",
            "strlen(realm)",
            "realm",
            "princ->mod_name",
            "princ->mod_instance[0] ? \n\t\t\t\t    princ->mod_instance : 0",
            "0"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "realm"
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "name"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "free_policy_ent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/testing/util/tcl_ovsec_kadm.c",
          "lines": "939-943",
          "snippet": "static void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}",
          "includes": [
            "#include \"tcl_kadm5.h\"",
            "#include <stdlib.h>",
            "#include <errno.h>",
            "#include <k5-int.h>",
            "#include <com_err.h>",
            "#include <kadm5/admin.h>",
            "#include <tcl/tcl.h>",
            "#include <tcl.h>",
            "#include <string.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tcl_kadm5.h\"\n#include <stdlib.h>\n#include <errno.h>\n#include <k5-int.h>\n#include <com_err.h>\n#include <kadm5/admin.h>\n#include <tcl/tcl.h>\n#include <tcl.h>\n#include <string.h>\n#include <stdio.h>\n\nstatic void free_policy_ent(ovsec_kadm_policy_ent_t *policy)\n{\n     free(*policy);\n     *policy = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\ntranslating %s...\"",
            "name"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "\"<not unparsable name!>\""
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_unparse_name",
          "args": [
            "context",
            "entry.princ",
            "&name"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_425_conv_principal",
          "args": [
            "context",
            "princ->name",
            "princ->instance",
            "realm",
            "&entry.princ"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *) &entry",
            "0",
            "sizeof(entry)"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nignoring '%s.%s' ...\"",
            "princ->name",
            "princ->instance"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)key_from_db",
            "0",
            "sizeof(key_from_db)"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcmp",
          "args": [
            "(char *) master_key",
            "(char *) key_from_db",
            "sizeof(master_key)"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pcbc_encrypt",
          "args": [
            "(C_Block *) &key_from_db",
            "(C_Block *) &key_from_db",
            "(long) sizeof(C_Block)",
            "master_key_schedule",
            "(C_Block *) master_key",
            "DECRYPT"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "((char *) key_from_db) + 4",
            "(char *)&princ->key_high",
            "4"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "key_from_db",
            "(char *)&princ->key_low",
            "4"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "princ->instance",
            "KERB_M_INST"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "princ->name",
            "KERB_M_NAME"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\nignoring local TGT: '%s.%s' ...\"",
            "princ->name",
            "princ->instance"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "princ->instance",
            "realm"
          ],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "princ->name",
            "\"krbtgt\""
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic krb5_error_code\nenter_in_v5_db(context, realm, princ)\nkrb5_context context;\nchar *realm;\nPrincipal *princ;\n{\n    krb5_db_entry entry;\n    krb5_error_code retval;\n    krb5_keyblock v4v5key;\n    int nentries = 1;\n    des_cblock v4key;\n    char *name;\n    krb5_timestamp\tmod_time;\n    krb5_principal\tmod_princ;\n    krb5_keysalt\tkeysalt;\n\n    /* don't convert local TGT if we created a TGT already.... */\n    if (create_local_tgt && !strcmp(princ->name, \"krbtgt\") &&\n\t!strcmp(princ->instance, realm)) {\n\t    if (verbose)\n\t\t    printf(\"\\nignoring local TGT: '%s.%s' ...\",\n\t\t\t   princ->name, princ->instance);\n\t    return 0;\n    }\n    if (!strcmp(princ->name, KERB_M_NAME) &&\n\t!strcmp(princ->instance, KERB_M_INST)) {\n\tdes_cblock key_from_db;\n\tint val;\n\n\t/* here's our chance to verify the master key */\n\t/*\n\t * use the master key to decrypt the key in the db, had better\n\t * be the same! \n\t */\n\tmemcpy(key_from_db, (char *)&princ->key_low, 4);\n\tmemcpy(((char *) key_from_db) + 4, (char *)&princ->key_high, 4);\n\tpcbc_encrypt((C_Block *) &key_from_db,\n\t\t     (C_Block *) &key_from_db,\n\t\t     (long) sizeof(C_Block),\n\t\t     master_key_schedule,\n\t\t     (C_Block *) master_key,\n\t\t     DECRYPT);\n\tval = memcmp((char *) master_key, (char *) key_from_db,\n\t\t     sizeof(master_key));\n\tmemset((char *)key_from_db, 0, sizeof(key_from_db));\n\tif (val) {\n\t    return KRB5_KDB_BADMASTERKEY;\n\t}\n\tif (verbose)\n\t    printf(\"\\nignoring '%s.%s' ...\", princ->name, princ->instance);\n\treturn 0;\n    }\n    memset((char *) &entry, 0, sizeof(entry));\n    retval = krb5_425_conv_principal(context, princ->name, princ->instance,\n\t\t\t\t     realm, &entry.princ);\n    if (retval)\n\treturn retval;\n    if (verbose) {\n\tretval = krb5_unparse_name(context, entry.princ, &name);\n\tif (retval)\n\t   name = strdup(\"<not unparsable name!>\");\n\tif (verbose)\n\t    printf(\"\\ntranslating %s...\", name);\n\tfree(name);\n    }\n\n    retval = krb5_build_principal(context, &mod_princ,\n\t\t\t\t  strlen(realm), realm, princ->mod_name,\n\t\t\t\t  princ->mod_instance[0] ? \n\t\t\t\t    princ->mod_instance : 0,\n\t\t\t\t  0);\n    if (retval) {\n\tkrb5_free_principal(context, entry.princ);\n\treturn retval;\n    }\n    mod_time = princ->mod_date;\n\n    if (!shortlife)\n\tentry.max_life = krb_life_to_time(0, princ->max_life);\n    else\n\tentry.max_life = princ->max_life * 60 * 5;\n    entry.max_renewable_life = rblock.max_rlife;\n    entry.len = KRB5_KDB_V1_BASE_LENGTH;\n    entry.expiration = princ->exp_date;\n    entry.attributes = rblock.flags;\t/* XXX is there a way to convert\n\t\t\t\t\t   the old attrs? */\n\n    memcpy((char *)v4key, (char *)&(princ->key_low), 4);\n    memcpy((char *) (((char *) v4key) + 4), (char *)&(princ->key_high), 4);\n    pcbc_encrypt((C_Block *) &v4key,\n\t\t (C_Block *) &v4key,\n\t\t (long) sizeof(C_Block),\n\t\t master_key_schedule,\n\t\t (C_Block *) master_key,\n\t\t DECRYPT);\n\n    v4v5key.magic = KV5M_KEYBLOCK;\n    v4v5key.contents = (krb5_octet *)v4key;\n    v4v5key.enctype = ENCTYPE_DES_CBC_CRC;\n    v4v5key.length = sizeof(v4key);\n\n    retval = krb5_dbe_create_key_data(context, &entry);\n    if (retval) {\n\tkrb5_free_principal(context, entry.princ);\n\tkrb5_free_principal(context, mod_princ);\n\treturn retval;\n    }\n\n    keysalt.type = KRB5_KDB_SALTTYPE_V4;\n    keysalt.data.length = 0;\n    keysalt.data.data = (char *) NULL;\n    retval = krb5_dbekd_encrypt_key_data(context, rblock.key,\n\t\t\t\t\t &v4v5key, &keysalt, \n\t\t\t\t\t princ->key_version,\n\t\t\t\t\t &entry.key_data[0]);\n    if (!retval)\n\tretval = krb5_dbe_update_mod_princ_data(context, &entry,\n\t\t\t\t\t\tmod_time, mod_princ);\n    if (!retval)\n        retval = krb5_dbe_update_last_pwd_change(context, &entry, mod_time);\n\n    if (retval) {\n\tkrb5_db_free_principal(context, &entry, 1);\n\tkrb5_free_principal(context, mod_princ);\n\treturn retval;\n    }\n    memset((char *)v4key, 0, sizeof(v4key));\n\n    retval = krb5_db_put_principal(context, &entry, &nentries);\n\n    if (!retval && !strcmp(princ->name, \"krbtgt\") &&\n\tstrcmp(princ->instance, realm) && princ->instance[0]) {\n\t    krb5_free_principal(context, entry.princ);\n\t    retval = krb5_build_principal(context, &entry.princ,\n\t\t\t\t\t  strlen(princ->instance),\n\t\t\t\t\t  princ->instance,\n\t\t\t\t\t  \"krbtgt\", realm, 0);\n\t    if (retval)\n\t\t    return retval;\n\t    retval = krb5_db_put_principal(context, &entry, &nentries);\n    }\n\n    krb5_db_free_principal(context, &entry, 1);\n    krb5_free_principal(context, mod_princ);\n\n    return retval;\n}"
  },
  {
    "function_name": "v4init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
    "lines": "449-472",
    "snippet": "static int\nv4init(pname, manual, dumpfile)\nchar *pname;\nint manual;\nchar *dumpfile;\n{\n    int fd;\n    int ok = 0;\n\n    if (!manual) {\n\tfd = open(v4_mkeyfile, O_RDONLY, 0600);\n\tif (fd >= 0) {\n\t    if (read(fd, master_key, sizeof(master_key)) == sizeof(master_key))\n\t\tok = 1;\n\t    close(fd);\n\t}\n    }\n    if (!ok) {\n\tdes_read_password(&master_key, \"V4 Kerberos master key\", 0);\n\tprintf(\"\\n\");\n    }\n    key_sched(master_key, master_key_schedule);\n    return 0;\n}",
    "includes": [
      "#include <netinet/in.h>\t\t\t/* ntohl */",
      "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
      "#include \"kdb5_util.h\"",
      "#include <stdio.h>",
      "#include <kadm5/admin.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_sched",
          "args": [
            "master_key",
            "master_key_schedule"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"\\n\""
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "des_read_password",
          "args": [
            "&master_key",
            "\"V4 Kerberos master key\"",
            "0"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "close",
          "args": [
            "fd"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read",
          "args": [
            "fd",
            "master_key",
            "sizeof(master_key)"
          ],
          "line": 461
        },
        "resolved": true,
        "details": {
          "function_name": "read_octet_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/dump.c",
          "lines": "1232-1250",
          "snippet": "static int\nread_octet_string(f, buf, len)\n    FILE\t*f;\n    krb5_octet\t*buf;\n    int\t\tlen;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tif (fscanf(f, \"%02x\", &c) != 1) {\n\t    retval = 1;\n\t    break;\n\t}\n\tbuf[i] = (krb5_octet) c;\n    }\n    return(retval);\n}",
          "includes": [
            "#include <regexp.h>",
            "#include <regex.h>",
            "#include \"kdb5_util.h\"",
            "#include <com_err.h>",
            "#include <kadm5/adb.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);",
            "static int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);",
            "static int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <regexp.h>\n#include <regex.h>\n#include \"kdb5_util.h\"\n#include <com_err.h>\n#include <kadm5/adb.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nstatic int process_k5beta_record (char *, krb5_context,\n\t\t\t\t  FILE *, int, int *, void *);\nstatic int process_k5beta6_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_k5beta7_record (char *, krb5_context,\n\t\t\t\t   FILE *, int, int *, void *);\nstatic int process_ov_record (char *, krb5_context,\n\t\t\t      FILE *, int, int *, void *);\n\nstatic int\nread_octet_string(f, buf, len)\n    FILE\t*f;\n    krb5_octet\t*buf;\n    int\t\tlen;\n{\n    int c;\n    int i, retval;\n\n    retval = 0;\n    for (i=0; i<len; i++) {\n\tif (fscanf(f, \"%02x\", &c) != 1) {\n\t    retval = 1;\n\t    break;\n\t}\n\tbuf[i] = (krb5_octet) c;\n    }\n    return(retval);\n}"
        }
      },
      {
        "call_info": {
          "callee": "open",
          "args": [
            "v4_mkeyfile",
            "O_RDONLY",
            "0600"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "open_db_and_mkey",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/kdb5_util.c",
          "lines": "300-421",
          "snippet": "static int open_db_and_mkey()\n{\n    krb5_error_code retval;\n    int nentries;\n    krb5_boolean more;\n    krb5_data scratch, pwd, seed;\n\n    dbactive = FALSE;\n    valid_master_key = 0;\n\n    if ((retval = krb5_db_set_name(util_context, global_params.dbname))) {\n\tcom_err(progname, retval, \"while setting active database to '%s'\",\n\t\tglobal_params.dbname);\n\texit_status++;\n\treturn(1);\n    } \n    if ((retval = krb5_db_init(util_context))) {\n\tcom_err(progname, retval, \"while initializing database\");\n\texit_status++;\n\treturn(1);\n    }\n    if ((retval = osa_adb_open_policy(&policy_db, &global_params))) {\n\tcom_err(progname, retval, \"opening policy database\");\n\texit_status++;\n\treturn (1);\n    }\n\n   /* assemble & parse the master key name */\n\n    if ((retval = krb5_db_setup_mkey_name(util_context,\n\t\t\t\t\t  global_params.mkey_name,\n\t\t\t\t\t  global_params.realm, \n\t\t\t\t\t  0, &master_princ))) {\n\tcom_err(progname, retval, \"while setting up master key name\");\n\texit_status++;\n\treturn(1);\n    }\n    nentries = 1;\n    if ((retval = krb5_db_get_principal(util_context, master_princ, \n\t\t\t\t\t&master_entry, &nentries, &more))) {\n\tcom_err(progname, retval, \"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    } else if (more) {\n\tcom_err(progname, KRB5KDC_ERR_PRINCIPAL_NOT_UNIQUE,\n\t\t\"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    } else if (!nentries) {\n\tcom_err(progname, KRB5_KDB_NOENTRY, \"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    }\n\n    krb5_db_free_principal(util_context, &master_entry, nentries);\n\n    /* the databases are now open, and the master principal exists */\n    dbactive = TRUE;\n    \n    if (mkey_password) {\n\tpwd.data = mkey_password;\n\tpwd.length = strlen(mkey_password);\n\tretval = krb5_principal2salt(util_context, master_princ, &scratch);\n\tif (retval) {\n\t    com_err(progname, retval, \"while calculated master key salt\");\n\t    return(1);\n\t}\n\n\t/* If no encryption type is set, use the default */\n\tif (master_keyblock.enctype == ENCTYPE_UNKNOWN) {\n\t    master_keyblock.enctype = DEFAULT_KDC_ENCTYPE;\n\t    if (!krb5_c_valid_enctype(master_keyblock.enctype))\n\t\tcom_err(progname, KRB5_PROG_KEYTYPE_NOSUPP,\n\t\t\t\"while setting up enctype %d\",\n\t\t\tmaster_keyblock.enctype);\n\t}\n\n\tretval = krb5_c_string_to_key(util_context, master_keyblock.enctype, \n\t\t\t\t      &pwd, &scratch, &master_keyblock);\n\tif (retval) {\n\t    com_err(progname, retval,\n\t\t    \"while transforming master key from password\");\n\t    return(1);\n\t}\n\tfree(scratch.data);\n\tmkey_password = 0;\n    } else if ((retval = krb5_db_fetch_mkey(util_context, master_princ, \n\t\t\t\t\t    master_keyblock.enctype,\n\t\t\t\t\t    manual_mkey, FALSE,\n\t\t\t\t\t    global_params.stash_file,\n\t\t\t\t\t    0, &master_keyblock))) {\n\tcom_err(progname, retval, \"while reading master key\");\n\tcom_err(progname, 0, \"Warning: proceeding without master key\");\n\texit_status++;\n\treturn(0);\n    }\n    if ((retval = krb5_db_verify_master_key(util_context, master_princ, \n\t\t\t\t\t    &master_keyblock))) {\n\tcom_err(progname, retval, \"while verifying master key\");\n\texit_status++;\n\tkrb5_free_keyblock_contents(util_context, &master_keyblock);\n\treturn(1);\n    }\n\n    seed.length = master_keyblock.length;\n    seed.data = master_keyblock.contents;\n\n    if ((retval = krb5_c_random_seed(util_context, &seed))) {\n\tcom_err(progname, retval, \"while seeding random number generator\");\n\texit_status++;\n\tmemset((char *)master_keyblock.contents, 0, master_keyblock.length);\n\tkrb5_free_keyblock_contents(util_context, &master_keyblock);\n\treturn(1);\n    }\n\n    valid_master_key = 1;\n    dbactive = TRUE;\n    return 0;\n}",
          "includes": [
            "#include \"kdb5_util.h\"",
            "#include <time.h>",
            "#include <kadm5/adb.h>",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char *mkey_password = 0;",
            "int exit_status = 0;",
            "krb5_context util_context;",
            "osa_adb_policy_t policy_db;",
            "kadm5_config_params global_params;",
            "extern krb5_keyblock master_keyblock;",
            "extern krb5_principal master_princ;",
            "krb5_db_entry master_entry;",
            "int\tvalid_master_key = 0;",
            "char *progname;",
            "krb5_boolean manual_mkey = FALSE;",
            "krb5_boolean dbactive = FALSE;",
            "static int open_db_and_mkey(void);",
            "static struct _cmd_table *cmd_lookup(name)\n   char *name;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb5_util.h\"\n#include <time.h>\n#include <kadm5/adb.h>\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nchar *mkey_password = 0;\nint exit_status = 0;\nkrb5_context util_context;\nosa_adb_policy_t policy_db;\nkadm5_config_params global_params;\nextern krb5_keyblock master_keyblock;\nextern krb5_principal master_princ;\nkrb5_db_entry master_entry;\nint\tvalid_master_key = 0;\nchar *progname;\nkrb5_boolean manual_mkey = FALSE;\nkrb5_boolean dbactive = FALSE;\nstatic int open_db_and_mkey(void);\nstatic struct _cmd_table *cmd_lookup(name)\n   char *name;\n\nstatic int open_db_and_mkey()\n{\n    krb5_error_code retval;\n    int nentries;\n    krb5_boolean more;\n    krb5_data scratch, pwd, seed;\n\n    dbactive = FALSE;\n    valid_master_key = 0;\n\n    if ((retval = krb5_db_set_name(util_context, global_params.dbname))) {\n\tcom_err(progname, retval, \"while setting active database to '%s'\",\n\t\tglobal_params.dbname);\n\texit_status++;\n\treturn(1);\n    } \n    if ((retval = krb5_db_init(util_context))) {\n\tcom_err(progname, retval, \"while initializing database\");\n\texit_status++;\n\treturn(1);\n    }\n    if ((retval = osa_adb_open_policy(&policy_db, &global_params))) {\n\tcom_err(progname, retval, \"opening policy database\");\n\texit_status++;\n\treturn (1);\n    }\n\n   /* assemble & parse the master key name */\n\n    if ((retval = krb5_db_setup_mkey_name(util_context,\n\t\t\t\t\t  global_params.mkey_name,\n\t\t\t\t\t  global_params.realm, \n\t\t\t\t\t  0, &master_princ))) {\n\tcom_err(progname, retval, \"while setting up master key name\");\n\texit_status++;\n\treturn(1);\n    }\n    nentries = 1;\n    if ((retval = krb5_db_get_principal(util_context, master_princ, \n\t\t\t\t\t&master_entry, &nentries, &more))) {\n\tcom_err(progname, retval, \"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    } else if (more) {\n\tcom_err(progname, KRB5KDC_ERR_PRINCIPAL_NOT_UNIQUE,\n\t\t\"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    } else if (!nentries) {\n\tcom_err(progname, KRB5_KDB_NOENTRY, \"while retrieving master entry\");\n\texit_status++;\n\t(void) krb5_db_fini(util_context);\n\treturn(1);\n    }\n\n    krb5_db_free_principal(util_context, &master_entry, nentries);\n\n    /* the databases are now open, and the master principal exists */\n    dbactive = TRUE;\n    \n    if (mkey_password) {\n\tpwd.data = mkey_password;\n\tpwd.length = strlen(mkey_password);\n\tretval = krb5_principal2salt(util_context, master_princ, &scratch);\n\tif (retval) {\n\t    com_err(progname, retval, \"while calculated master key salt\");\n\t    return(1);\n\t}\n\n\t/* If no encryption type is set, use the default */\n\tif (master_keyblock.enctype == ENCTYPE_UNKNOWN) {\n\t    master_keyblock.enctype = DEFAULT_KDC_ENCTYPE;\n\t    if (!krb5_c_valid_enctype(master_keyblock.enctype))\n\t\tcom_err(progname, KRB5_PROG_KEYTYPE_NOSUPP,\n\t\t\t\"while setting up enctype %d\",\n\t\t\tmaster_keyblock.enctype);\n\t}\n\n\tretval = krb5_c_string_to_key(util_context, master_keyblock.enctype, \n\t\t\t\t      &pwd, &scratch, &master_keyblock);\n\tif (retval) {\n\t    com_err(progname, retval,\n\t\t    \"while transforming master key from password\");\n\t    return(1);\n\t}\n\tfree(scratch.data);\n\tmkey_password = 0;\n    } else if ((retval = krb5_db_fetch_mkey(util_context, master_princ, \n\t\t\t\t\t    master_keyblock.enctype,\n\t\t\t\t\t    manual_mkey, FALSE,\n\t\t\t\t\t    global_params.stash_file,\n\t\t\t\t\t    0, &master_keyblock))) {\n\tcom_err(progname, retval, \"while reading master key\");\n\tcom_err(progname, 0, \"Warning: proceeding without master key\");\n\texit_status++;\n\treturn(0);\n    }\n    if ((retval = krb5_db_verify_master_key(util_context, master_princ, \n\t\t\t\t\t    &master_keyblock))) {\n\tcom_err(progname, retval, \"while verifying master key\");\n\texit_status++;\n\tkrb5_free_keyblock_contents(util_context, &master_keyblock);\n\treturn(1);\n    }\n\n    seed.length = master_keyblock.length;\n    seed.data = master_keyblock.contents;\n\n    if ((retval = krb5_c_random_seed(util_context, &seed))) {\n\tcom_err(progname, retval, \"while seeding random number generator\");\n\texit_status++;\n\tmemset((char *)master_keyblock.contents, 0, master_keyblock.length);\n\tkrb5_free_keyblock_contents(util_context, &master_keyblock);\n\treturn(1);\n    }\n\n    valid_master_key = 1;\n    dbactive = TRUE;\n    return 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic int\nv4init(pname, manual, dumpfile)\nchar *pname;\nint manual;\nchar *dumpfile;\n{\n    int fd;\n    int ok = 0;\n\n    if (!manual) {\n\tfd = open(v4_mkeyfile, O_RDONLY, 0600);\n\tif (fd >= 0) {\n\t    if (read(fd, master_key, sizeof(master_key)) == sizeof(master_key))\n\t\tok = 1;\n\t    close(fd);\n\t}\n    }\n    if (!ok) {\n\tdes_read_password(&master_key, \"V4 Kerberos master key\", 0);\n\tprintf(\"\\n\");\n    }\n    key_sched(master_key, master_key_schedule);\n    return 0;\n}"
  },
  {
    "function_name": "load_v4db",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
    "lines": "155-447",
    "snippet": "void\nload_v4db(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n    /* The kdb library will default to this, but it is convenient to\n       make it explicit (error reporting and temporary filename generation\n       use it).  */\n    char *dbname = DEFAULT_KDB_FILE;\n    char *v4dumpfile = 0;\n    char *realm = 0;\n    char *mkey_name = 0;\n    char *mkey_fullname;\n    char *defrealm;\n    int v4manual = 0;\n    krb5_boolean read_mkey = 0;\n    int tempdb = 0;\n    char *tempdbname;\n    krb5_context context;\n    char *stash_file = (char *) NULL;\n    int\tpersist, op_ind;\n    kadm5_config_params newparams;\n    extern kadm5_config_params global_params;\n    long exp_time = 0;\n    krb5_int32 crflags = KRB5_KDB_CREATE_BTREE;\n    krb5_data seed;\n\n    retval = krb5_init_context(&context);\n    if (retval) {\n\tfprintf(stderr, \"%s: Could not initialize krb5 context.\\n\", PROGNAME);\n\treturn;\n    }\n\n    if (strrchr(argv[0], '/'))\n\targv[0] = strrchr(argv[0], '/')+1;\n\n    persist = 1;\n    op_ind = 1;\n    while (persist && (op_ind < argc)) {\n\tif (!strcmp(argv[op_ind], \"-T\")) {\n\t    create_local_tgt = 1;\n\t}\n\telse if (!strcmp(argv[op_ind], \"-t\")) {\n\t    tempdb = 1;\n\t}\n\telse if (!strcmp(argv[op_ind], \"-K\")) {\n\t    read_mkey = 1;\n\t}\n\telse if (!strcmp(argv[op_ind], \"-v\")) {\n\t    verbose = 1;\n\t}\n\telse if (!strcmp(argv[op_ind], \"-n\")) {\n\t    v4manual++;\n\t} \n\telse if (!strcmp(argv[op_ind], \"-S\")) {\n\t    shortlife++;\n\t}\n\telse if (!strcmp(argv[op_ind], \"-s\")) {\n\t    if ((argc - op_ind) >= 1) {\n\t        v4_mkeyfile = argv[op_ind+1];\n\t\top_ind++;\n\t    } else {\n\t\tusage();\n\t    }\n\t}\n\telse if (!strcmp(argv[op_ind], \"-h\")) {\n\t    crflags = KRB5_KDB_CREATE_HASH;\n\t}\n\telse if ((argc - op_ind) >= 1) {\n\t    v4dumpfile = argv[op_ind];\n\t    op_ind++;\n\t}\n\telse\n\t    usage();\n\top_ind++;\n    }\n\n    realm = global_params.realm;\n    dbname = global_params.dbname;\n    mkey_name = global_params.mkey_name;\n    master_keyblock.enctype = global_params.enctype;\n    if (global_params.stash_file)\n\t    stash_file = strdup(global_params.stash_file);\n    rblock.max_life = global_params.max_life;\n    rblock.max_rlife = global_params.max_rlife;\n    rblock.expiration = global_params.expiration;\n    rblock.flags = global_params.flags;\n\n    if (!v4dumpfile) {\n\tusage();\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    if (!krb5_c_valid_enctype(master_keyblock.enctype)) {\n\tcom_err(PROGNAME, KRB5_PROG_KEYTYPE_NOSUPP,\n\t\t\"while setting up enctype %d\", master_keyblock.enctype);\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    /* If the user has not requested locking, don't modify an existing database. */\n    if (! tempdb) {\n\tretval = krb5_db_set_name(context, dbname);\n\tif (retval != ENOENT) {\n\t    fprintf(stderr,\n\t\t    \"%s: The v5 database appears to already exist.\\n\",\n\t\t    PROGNAME);\n\t    krb5_free_context(context);\n\t    return;\n\t}\n\ttempdbname = dbname;\n    } else {\n\tsize_t dbnamelen = strlen(dbname);\n\ttempdbname = malloc(dbnamelen + 2);\n\tif (tempdbname == 0) {\n\t    com_err(PROGNAME, ENOMEM, \"allocating temporary filename\");\n\t    krb5_free_context(context);\n\t    return;\n\t}\n\tstrcpy(tempdbname, dbname);\n\ttempdbname[dbnamelen] = '~';\n\ttempdbname[dbnamelen+1] = 0;\n\t(void) krb5_db_destroy(context, tempdbname);\n    }\n\t\n\n    if (!realm) {\n\tretval = krb5_get_default_realm(context, &defrealm);\n\tif (retval) {\n\t    com_err(PROGNAME, retval, \"while retrieving default realm name\");\n\t    krb5_free_context(context);\n\t    return;\n\t}\t    \n\trealm = defrealm;\n    }\n\n    /* assemble & parse the master key name */\n    \n    retval = krb5_db_setup_mkey_name(context, mkey_name, realm,\n\t\t\t\t     &mkey_fullname, &master_princ);\n    if (retval) {\n\tcom_err(PROGNAME, retval, \"while setting up master key name\");\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    krb5_princ_set_realm_data(context, &db_create_princ, realm);\n    krb5_princ_set_realm_length(context, &db_create_princ, strlen(realm));\n    krb5_princ_set_realm_data(context, &tgt_princ, realm);\n    krb5_princ_set_realm_length(context, &tgt_princ, strlen(realm));\n    krb5_princ_component(context, &tgt_princ,1)->data = realm;\n    krb5_princ_component(context, &tgt_princ,1)->length = strlen(realm);\n\n    printf(\"Initializing database '%s' for realm '%s',\\n\\\nmaster key name '%s'\\n\",\n\t   dbname, realm, mkey_fullname);\n\n    if (read_mkey) {\n\tputs(\"You will be prompted for the version 5 database Master Password.\");\n\tputs(\"It is important that you NOT FORGET this password.\");\n\tfflush(stdout);\n    }\n\n\n    retval = krb5_db_fetch_mkey(context, master_princ,\n\t\t\t\tmaster_keyblock.enctype,\n\t\t\t\tread_mkey, read_mkey, stash_file, 0, \n\t\t\t\t&master_keyblock);\n    if (retval) {\n\tcom_err(PROGNAME, retval, \"while reading master key\");\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    rblock.key = &master_keyblock;\n\n    seed.length = master_keyblock.length;\n    seed.data = master_keyblock.contents;\n\n    retval = krb5_c_random_seed(context, &seed);\n    if (retval) {\n\tcom_err(PROGNAME, retval, \"while initializing random key generator\");\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    retval = krb5_db_create(context, tempdbname, crflags);\n    if (retval) {\n\tcom_err(PROGNAME, retval, \"while creating %sdatabase '%s'\",\n\t\ttempdb ? \"temporary \" : \"\", tempdbname);\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    retval = krb5_db_set_name(context, tempdbname);\n    if (retval) {\n\t(void) krb5_db_destroy(context, tempdbname);\n        com_err(PROGNAME, retval, \"while setting active database to '%s'\",\n                tempdbname);\n\tkrb5_free_context(context);\n        return;\n    }\n    if (v4init(PROGNAME, v4manual, v4dumpfile)) {\n\t(void) krb5_db_destroy(context, tempdbname);\n\tkrb5_free_context(context);\n\treturn;\n    }\n    if ((retval = krb5_db_init(context)) || \n\t(retval = krb5_db_open_database(context))) {\n\t(void) krb5_db_destroy(context, tempdbname);\n\tcom_err(PROGNAME, retval, \"while initializing the database '%s'\",\n\t\ttempdbname);\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    retval = add_principal(context, master_princ, MASTER_KEY, &rblock);\n    if (retval) {\n\t(void) krb5_db_fini(context);\n\t(void) krb5_db_destroy(context, tempdbname);\n\tcom_err(PROGNAME, retval, \"while adding K/M to the database\");\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    if (create_local_tgt &&\n\t(retval = add_principal(context, &tgt_princ, RANDOM_KEY, &rblock))) {\n\t(void) krb5_db_fini(context);\n\t(void) krb5_db_destroy(context, tempdbname);\n\tcom_err(PROGNAME, retval, \"while adding TGT service to the database\");\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    retval = v4_dump_find_default(context, v4dumpfile, realm, &exp_time);\n    if (retval) {\n        com_err(PROGNAME, retval, \"warning: default entry not found\");\n    }\n\n    retval = process_v4_dump(context, v4dumpfile, realm, exp_time);\n    putchar('\\n');\n    if (retval)\n\tcom_err(PROGNAME, retval, \"while translating entries to the database\");\n    else {\n\tretval = fixup_database(context, realm);\n    }\n    \n    /* clean up; rename temporary database if there were no errors */\n    if (retval == 0) {\n\tretval = krb5_db_fini (context);\n\tif (retval)\n\t    com_err(PROGNAME, retval, \"while shutting down database\");\n\telse if (tempdb && (retval = krb5_db_rename(context, tempdbname,\n\t\t\t\t\t\t    dbname)))\n\t    com_err(PROGNAME, retval, \"while renaming temporary database\");\n    } else {\n\t(void) krb5_db_fini (context);\n\tif (tempdb)\n\t    (void) krb5_db_destroy (context, tempdbname);\n    }\n    memset((char *)master_keyblock.contents, 0, master_keyblock.length);\n\n    /*\n     * Cons up config params for new database; using the global_params\n     * is just fine.\n     */\n    newparams = global_params;\n\n    /*\n     * Always create the policy db, even if we are not loading a dump\n     * file with policy info.\n     */\n    if (!tempdb && (retval = osa_adb_create_policy_db(&newparams))) {\n\tcom_err(PROGNAME, retval, \"while creating policy database\");\n\tkadm5_free_config_params(context, &newparams);\n\tkrb5_free_context(context);\n\treturn;\n    }\n    /*\n     * Create the magic principals in the database.\n     */\n    retval = kadm5_create_magic_princs(&newparams, context);\n    if (retval) {\n\tcom_err(PROGNAME, retval, \"while creating KADM5 principals\");\n\tkrb5_free_context(context);\n\treturn;\n    }\n    \n    krb5_free_context(context);\n    return;\n}",
    "includes": [
      "#include <netinet/in.h>\t\t\t/* ntohl */",
      "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
      "#include \"kdb5_util.h\"",
      "#include <stdio.h>",
      "#include <kadm5/admin.h>",
      "#include <kdc.h>",
      "#include <krb_db.h>",
      "#include <krb.h>",
      "#include <des.h>",
      "#include \"com_err.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [
      "#define PROGNAME argv[0]"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while creating KADM5 principals\""
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_create_magic_princs",
          "args": [
            "&newparams",
            "context"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "kadm5_create_magic_princs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/kadm5_create.c",
          "lines": "101-125",
          "snippet": "int kadm5_create_magic_princs(kadm5_config_params *params,\n\t\t\t      krb5_context context)\n{\n     int retval;\n     void *handle;\n     \n     retval = krb5_klog_init(context, \"admin_server\", progname, 0);\n     if (retval)\n\t  return retval;\n     if ((retval = kadm5_init(progname, NULL, NULL, params,\n\t\t\t      KADM5_STRUCT_VERSION,\n\t\t\t      KADM5_API_VERSION_2,\n\t\t\t      &handle))) {\n\t  com_err(progname, retval, \"while initializing the Kerberos admin interface\");\n\t  return retval;\n     }\n\n     retval = add_admin_princs(handle, context, params->realm);\n\n     kadm5_destroy(handle);\n\n     krb5_klog_close(context);\n\n     return retval;\n}",
          "includes": [
            "#include \"kdb5_util.h\"",
            "#include <krb5/kdb.h>",
            "#include <krb5.h>",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <kadm5/adb.h>",
            "#include <string.h>",
            "#include <stdlib.h>",
            "#include <stdio.h>",
            "#include \"string_table.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int add_admin_princs(void *handle, krb5_context context, char *realm);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb5_util.h\"\n#include <krb5/kdb.h>\n#include <krb5.h>\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <kadm5/adb.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include \"string_table.h\"\n\nstatic int add_admin_princs(void *handle, krb5_context context, char *realm);\n\nint kadm5_create_magic_princs(kadm5_config_params *params,\n\t\t\t      krb5_context context)\n{\n     int retval;\n     void *handle;\n     \n     retval = krb5_klog_init(context, \"admin_server\", progname, 0);\n     if (retval)\n\t  return retval;\n     if ((retval = kadm5_init(progname, NULL, NULL, params,\n\t\t\t      KADM5_STRUCT_VERSION,\n\t\t\t      KADM5_API_VERSION_2,\n\t\t\t      &handle))) {\n\t  com_err(progname, retval, \"while initializing the Kerberos admin interface\");\n\t  return retval;\n     }\n\n     retval = add_admin_princs(handle, context, params->realm);\n\n     kadm5_destroy(handle);\n\n     krb5_klog_close(context);\n\n     return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kadm5_free_config_params",
          "args": [
            "context",
            "&newparams"
          ],
          "line": 431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while creating policy database\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "osa_adb_create_policy_db",
          "args": [
            "&newparams"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)master_keyblock.contents",
            "0",
            "master_keyblock.length"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_destroy",
          "args": [
            "context",
            "tempdbname"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_fini",
          "args": [
            "context"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while renaming temporary database\""
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_rename",
          "args": [
            "context",
            "tempdbname",
            "dbname"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while shutting down database\""
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_fini",
          "args": [
            "context"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fixup_database",
          "args": [
            "context",
            "realm"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "fixup_database",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
          "lines": "966-971",
          "snippet": "static krb5_error_code fixup_database(context, realm)\n    krb5_context context;\n    char * realm;\n{\n    return 0;\n}",
          "includes": [
            "#include <netinet/in.h>\t\t\t/* ntohl */",
            "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
            "#include \"kdb5_util.h\"",
            "#include <stdio.h>",
            "#include <kadm5/admin.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic krb5_error_code fixup_database(context, realm)\n    krb5_context context;\n    char * realm;\n{\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while translating entries to the database\""
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "putchar",
          "args": [
            "'\\n'"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_v4_dump",
          "args": [
            "context",
            "v4dumpfile",
            "realm",
            "exp_time"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "process_v4_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
          "lines": "816-877",
          "snippet": "static krb5_error_code\nprocess_v4_dump(context, dumpfile, realm, default_exp_time)\nkrb5_context context;\nchar *dumpfile;\nchar *realm;\nlong default_exp_time;\n{\n    krb5_error_code retval;\n    FILE *input_file;\n    Principal aprinc;\n    char    exp_date_str[50];\n    char    mod_date_str[50];\n    int     temp1, temp2, temp3;\n\n    input_file = fopen(dumpfile, \"r\");\n    if (!input_file)\n\treturn errno;\n\n    for (;;) {\t\t\t/* explicit break on eof from fscanf */\n\tint nread;\n\n\tmemset((char *)&aprinc, 0, sizeof(aprinc));\n\tnread = fscanf(input_file,\n\t\t       \"%s %s %d %d %d %hd %lx %lx %s %s %s %s\\n\",\n\t\t       aprinc.name,\n\t\t       aprinc.instance,\n\t\t       &temp1,\n\t\t       &temp2,\n\t\t       &temp3,\n\t\t       &aprinc.attributes,\n\t\t       &aprinc.key_low,\n\t\t       &aprinc.key_high,\n\t\t       exp_date_str,\n\t\t       mod_date_str,\n\t\t       aprinc.mod_name,\n\t\t       aprinc.mod_instance);\n\tif (nread != 12) {\n\t    retval = nread == EOF ? 0 : KRB5_KDB_DB_CORRUPT;\n\t    break;\n\t}\n\taprinc.key_low = ntohl (aprinc.key_low);\n\taprinc.key_high = ntohl (aprinc.key_high);\n\taprinc.max_life = (unsigned char) temp1;\n\taprinc.kdc_key_ver = (unsigned char) temp2;\n\taprinc.key_version = (unsigned char) temp3;\n\taprinc.exp_date = time_explode(exp_date_str);\n\tif (aprinc.exp_date == default_exp_time)\n\t    aprinc.exp_date = 0;\n\taprinc.mod_date = time_explode(mod_date_str);\n\tif (aprinc.instance[0] == '*')\n\t    aprinc.instance[0] = '\\0';\n\tif (aprinc.mod_name[0] == '*')\n\t    aprinc.mod_name[0] = '\\0';\n\tif (aprinc.mod_instance[0] == '*')\n\t    aprinc.mod_instance[0] = '\\0';\n\tretval = enter_in_v5_db(context, realm, &aprinc);\n\tif (retval)\n\t    break;\n    }\n    (void) fclose(input_file);\n    return retval;\n}",
          "includes": [
            "#include <netinet/in.h>\t\t\t/* ntohl */",
            "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
            "#include \"kdb5_util.h\"",
            "#include <stdio.h>",
            "#include <kadm5/admin.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic krb5_error_code\nprocess_v4_dump(context, dumpfile, realm, default_exp_time)\nkrb5_context context;\nchar *dumpfile;\nchar *realm;\nlong default_exp_time;\n{\n    krb5_error_code retval;\n    FILE *input_file;\n    Principal aprinc;\n    char    exp_date_str[50];\n    char    mod_date_str[50];\n    int     temp1, temp2, temp3;\n\n    input_file = fopen(dumpfile, \"r\");\n    if (!input_file)\n\treturn errno;\n\n    for (;;) {\t\t\t/* explicit break on eof from fscanf */\n\tint nread;\n\n\tmemset((char *)&aprinc, 0, sizeof(aprinc));\n\tnread = fscanf(input_file,\n\t\t       \"%s %s %d %d %d %hd %lx %lx %s %s %s %s\\n\",\n\t\t       aprinc.name,\n\t\t       aprinc.instance,\n\t\t       &temp1,\n\t\t       &temp2,\n\t\t       &temp3,\n\t\t       &aprinc.attributes,\n\t\t       &aprinc.key_low,\n\t\t       &aprinc.key_high,\n\t\t       exp_date_str,\n\t\t       mod_date_str,\n\t\t       aprinc.mod_name,\n\t\t       aprinc.mod_instance);\n\tif (nread != 12) {\n\t    retval = nread == EOF ? 0 : KRB5_KDB_DB_CORRUPT;\n\t    break;\n\t}\n\taprinc.key_low = ntohl (aprinc.key_low);\n\taprinc.key_high = ntohl (aprinc.key_high);\n\taprinc.max_life = (unsigned char) temp1;\n\taprinc.kdc_key_ver = (unsigned char) temp2;\n\taprinc.key_version = (unsigned char) temp3;\n\taprinc.exp_date = time_explode(exp_date_str);\n\tif (aprinc.exp_date == default_exp_time)\n\t    aprinc.exp_date = 0;\n\taprinc.mod_date = time_explode(mod_date_str);\n\tif (aprinc.instance[0] == '*')\n\t    aprinc.instance[0] = '\\0';\n\tif (aprinc.mod_name[0] == '*')\n\t    aprinc.mod_name[0] = '\\0';\n\tif (aprinc.mod_instance[0] == '*')\n\t    aprinc.mod_instance[0] = '\\0';\n\tretval = enter_in_v5_db(context, realm, &aprinc);\n\tif (retval)\n\t    break;\n    }\n    (void) fclose(input_file);\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"warning: default entry not found\""
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4_dump_find_default",
          "args": [
            "context",
            "v4dumpfile",
            "realm",
            "&exp_time"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "v4_dump_find_default",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
          "lines": "879-964",
          "snippet": "static krb5_error_code\nv4_dump_find_default(context, dumpfile, realm, exptime)\nkrb5_context context;\nchar *dumpfile;\nchar *realm;\nlong *exptime;\n{\n    krb5_error_code retval = 0;\n    FILE *input_file;\n    Principal aprinc;\n    char    exp_date_str[50];\n    char    mod_date_str[50];\n    int     temp1, temp2, temp3;\n    long foundtime, guess1, guess2;\n\n    /* kdb_init is usually the only thing to touch the time in the \n       default entry, and everything else just copies that time.  If\n       the site hasn't changed it, we can assume that \"never\" is an\n       appropriate value for V5.  There have been two values compiled\n       in, typically:\n\n       MIT V4 had the code\n       principal.exp_date = 946702799;\n       strncpy(principal.exp_date_txt, \"12/31/99\", DATE_SZ);\n\n       Cygnus CNS V4 had the code\n       principal.exp_date = 946702799+((365*10+3)*24*60*60);\n       strncpy(principal.exp_date_txt, \"12/31/2009\", DATE_SZ);\n\n       However, the dump files only store minutes -- so these values\n       are 59 seconds high.\n\n       Other values could be added later, but in practice these are\n       likely to be the only ones. */\n\n    guess1 = 946702799-59;\n    guess2 = 946702799+((365*10+3)*24*60*60);\n\n    input_file = fopen(dumpfile, \"r\");\n    if (!input_file)\n\treturn errno;\n\n    for (;;) {\t\t\t/* explicit break on eof from fscanf */\n\tint nread;\n\n\tmemset((char *)&aprinc, 0, sizeof(aprinc));\n\tnread = fscanf(input_file,\n\t\t       \"%s %s %d %d %d %hd %lx %lx %s %s %s %s\\n\",\n\t\t       aprinc.name,\n\t\t       aprinc.instance,\n\t\t       &temp1,\n\t\t       &temp2,\n\t\t       &temp3,\n\t\t       &aprinc.attributes,\n\t\t       &aprinc.key_low,\n\t\t       &aprinc.key_high,\n\t\t       exp_date_str,\n\t\t       mod_date_str,\n\t\t       aprinc.mod_name,\n\t\t       aprinc.mod_instance);\n\tif (nread != 12) {\n\t    retval = nread == EOF ? 0 : KRB5_KDB_DB_CORRUPT;\n\t    break;\n\t}\n\tif (!strcmp(aprinc.name, \"default\")\n\t    && !strcmp(aprinc.instance, \"*\")) {\n\t    foundtime = time_explode(exp_date_str);\n\t    if (foundtime == guess1 || foundtime == guess2)\n\t        *exptime = foundtime;\n\t    if (verbose) {\n\t        printf(\"\\ndefault expiration found: \");\n\t        if (foundtime == guess1) {\n\t\t    printf(\"MIT or pre96q1 value (1999)\");\n\t\t} else if (foundtime == guess2) {\n\t\t    printf(\"Cygnus CNS post 96q1 value (2009)\");\n\t\t} else {\n\t\t    printf(\"non-default start time (%ld,%s)\",\n\t\t\t   foundtime, exp_date_str);\n\t\t}\n\t    }\n\t    break;\n\t}\n    }\n    (void) fclose(input_file);\n    return retval;\n}",
          "includes": [
            "#include <netinet/in.h>\t\t\t/* ntohl */",
            "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
            "#include \"kdb5_util.h\"",
            "#include <stdio.h>",
            "#include <kadm5/admin.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic krb5_error_code\nv4_dump_find_default(context, dumpfile, realm, exptime)\nkrb5_context context;\nchar *dumpfile;\nchar *realm;\nlong *exptime;\n{\n    krb5_error_code retval = 0;\n    FILE *input_file;\n    Principal aprinc;\n    char    exp_date_str[50];\n    char    mod_date_str[50];\n    int     temp1, temp2, temp3;\n    long foundtime, guess1, guess2;\n\n    /* kdb_init is usually the only thing to touch the time in the \n       default entry, and everything else just copies that time.  If\n       the site hasn't changed it, we can assume that \"never\" is an\n       appropriate value for V5.  There have been two values compiled\n       in, typically:\n\n       MIT V4 had the code\n       principal.exp_date = 946702799;\n       strncpy(principal.exp_date_txt, \"12/31/99\", DATE_SZ);\n\n       Cygnus CNS V4 had the code\n       principal.exp_date = 946702799+((365*10+3)*24*60*60);\n       strncpy(principal.exp_date_txt, \"12/31/2009\", DATE_SZ);\n\n       However, the dump files only store minutes -- so these values\n       are 59 seconds high.\n\n       Other values could be added later, but in practice these are\n       likely to be the only ones. */\n\n    guess1 = 946702799-59;\n    guess2 = 946702799+((365*10+3)*24*60*60);\n\n    input_file = fopen(dumpfile, \"r\");\n    if (!input_file)\n\treturn errno;\n\n    for (;;) {\t\t\t/* explicit break on eof from fscanf */\n\tint nread;\n\n\tmemset((char *)&aprinc, 0, sizeof(aprinc));\n\tnread = fscanf(input_file,\n\t\t       \"%s %s %d %d %d %hd %lx %lx %s %s %s %s\\n\",\n\t\t       aprinc.name,\n\t\t       aprinc.instance,\n\t\t       &temp1,\n\t\t       &temp2,\n\t\t       &temp3,\n\t\t       &aprinc.attributes,\n\t\t       &aprinc.key_low,\n\t\t       &aprinc.key_high,\n\t\t       exp_date_str,\n\t\t       mod_date_str,\n\t\t       aprinc.mod_name,\n\t\t       aprinc.mod_instance);\n\tif (nread != 12) {\n\t    retval = nread == EOF ? 0 : KRB5_KDB_DB_CORRUPT;\n\t    break;\n\t}\n\tif (!strcmp(aprinc.name, \"default\")\n\t    && !strcmp(aprinc.instance, \"*\")) {\n\t    foundtime = time_explode(exp_date_str);\n\t    if (foundtime == guess1 || foundtime == guess2)\n\t        *exptime = foundtime;\n\t    if (verbose) {\n\t        printf(\"\\ndefault expiration found: \");\n\t        if (foundtime == guess1) {\n\t\t    printf(\"MIT or pre96q1 value (1999)\");\n\t\t} else if (foundtime == guess2) {\n\t\t    printf(\"Cygnus CNS post 96q1 value (2009)\");\n\t\t} else {\n\t\t    printf(\"non-default start time (%ld,%s)\",\n\t\t\t   foundtime, exp_date_str);\n\t\t}\n\t    }\n\t    break;\n\t}\n    }\n    (void) fclose(input_file);\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while adding TGT service to the database\""
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_destroy",
          "args": [
            "context",
            "tempdbname"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_fini",
          "args": [
            "context"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_principal",
          "args": [
            "context",
            "&tgt_princ",
            "RANDOM_KEY",
            "&rblock"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "add_principal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
          "lines": "622-697",
          "snippet": "static krb5_error_code\nadd_principal(context, princ, op, pblock)\nkrb5_context context;\nkrb5_principal princ;\nenum ap_op op;\nstruct realm_info *pblock;\n{\n    krb5_db_entry entry;\n    krb5_error_code retval;\n    krb5_keyblock rkey;\n    int nentries = 1;\n    krb5_timestamp mod_time;\n\n    memset((char *) &entry, 0, sizeof(entry));\n    retval = krb5_copy_principal(context, princ, &entry.princ);\n    if (retval)\n\treturn(retval);\n    entry.max_life = pblock->max_life;\n    entry.max_renewable_life = pblock->max_rlife;\n    entry.len = KRB5_KDB_V1_BASE_LENGTH;\n    entry.expiration = pblock->expiration;\n    \n    retval = krb5_timeofday(context, &mod_time);\n    if (retval) {\n\tkrb5_db_free_principal(context, &entry, 1);\n\treturn retval;\n    }\n    entry.attributes = pblock->flags;\n\n    retval = krb5_dbe_create_key_data(context, &entry);\n    if (retval) {\n\tkrb5_db_free_principal(context, &entry, 1);\n\treturn(retval);\n    }\n\n    switch (op) {\n    case MASTER_KEY:\n\tentry.attributes |= KRB5_KDB_DISALLOW_ALL_TIX;\n\tretval = krb5_dbekd_encrypt_key_data(context, pblock->key,\n\t\t\t\t\t     &master_keyblock,\n\t\t\t\t\t     (krb5_keysalt *) NULL, 1,\n\t\t\t\t\t     &entry.key_data[0]);\n\tif (retval) {\n\t    krb5_db_free_principal(context, &entry, 1);\n\t    return retval;\n\t}\n\tbreak;\n    case RANDOM_KEY:\n\tretval = krb5_c_make_random_key(context, pblock->key->enctype,\n\t\t\t\t\t&rkey);\n\tif (retval) {\n\t    krb5_db_free_principal(context, &entry, 1);\n\t    return retval;\n\t}\n\tretval = krb5_dbekd_encrypt_key_data(context, pblock->key,\n\t\t\t\t\t     &rkey, (krb5_keysalt *) NULL, \n\t\t\t\t\t     1, &entry.key_data[0]);\n\tif (retval) {\n\t    krb5_db_free_principal(context, &entry, 1);\n\t    return(retval);\n\t}\n\tkrb5_free_keyblock_contents(context, &rkey);\n\tbreak;\n    case NULL_KEY:\n\treturn EOPNOTSUPP;\n    default:\n\tbreak;\n    }\n\n    retval = krb5_dbe_update_mod_princ_data(context, &entry,\n\t\t\t\t\t    mod_time, &db_create_princ);\n    if (!retval)\n\tretval = krb5_db_put_principal(context, &entry, &nentries);\n    krb5_db_free_principal(context, &entry, 1);\n    return retval;\n}",
          "includes": [
            "#include <netinet/in.h>\t\t\t/* ntohl */",
            "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
            "#include \"kdb5_util.h\"",
            "#include <stdio.h>",
            "#include <kadm5/admin.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic krb5_error_code\nadd_principal(context, princ, op, pblock)\nkrb5_context context;\nkrb5_principal princ;\nenum ap_op op;\nstruct realm_info *pblock;\n{\n    krb5_db_entry entry;\n    krb5_error_code retval;\n    krb5_keyblock rkey;\n    int nentries = 1;\n    krb5_timestamp mod_time;\n\n    memset((char *) &entry, 0, sizeof(entry));\n    retval = krb5_copy_principal(context, princ, &entry.princ);\n    if (retval)\n\treturn(retval);\n    entry.max_life = pblock->max_life;\n    entry.max_renewable_life = pblock->max_rlife;\n    entry.len = KRB5_KDB_V1_BASE_LENGTH;\n    entry.expiration = pblock->expiration;\n    \n    retval = krb5_timeofday(context, &mod_time);\n    if (retval) {\n\tkrb5_db_free_principal(context, &entry, 1);\n\treturn retval;\n    }\n    entry.attributes = pblock->flags;\n\n    retval = krb5_dbe_create_key_data(context, &entry);\n    if (retval) {\n\tkrb5_db_free_principal(context, &entry, 1);\n\treturn(retval);\n    }\n\n    switch (op) {\n    case MASTER_KEY:\n\tentry.attributes |= KRB5_KDB_DISALLOW_ALL_TIX;\n\tretval = krb5_dbekd_encrypt_key_data(context, pblock->key,\n\t\t\t\t\t     &master_keyblock,\n\t\t\t\t\t     (krb5_keysalt *) NULL, 1,\n\t\t\t\t\t     &entry.key_data[0]);\n\tif (retval) {\n\t    krb5_db_free_principal(context, &entry, 1);\n\t    return retval;\n\t}\n\tbreak;\n    case RANDOM_KEY:\n\tretval = krb5_c_make_random_key(context, pblock->key->enctype,\n\t\t\t\t\t&rkey);\n\tif (retval) {\n\t    krb5_db_free_principal(context, &entry, 1);\n\t    return retval;\n\t}\n\tretval = krb5_dbekd_encrypt_key_data(context, pblock->key,\n\t\t\t\t\t     &rkey, (krb5_keysalt *) NULL, \n\t\t\t\t\t     1, &entry.key_data[0]);\n\tif (retval) {\n\t    krb5_db_free_principal(context, &entry, 1);\n\t    return(retval);\n\t}\n\tkrb5_free_keyblock_contents(context, &rkey);\n\tbreak;\n    case NULL_KEY:\n\treturn EOPNOTSUPP;\n    default:\n\tbreak;\n    }\n\n    retval = krb5_dbe_update_mod_princ_data(context, &entry,\n\t\t\t\t\t    mod_time, &db_create_princ);\n    if (!retval)\n\tretval = krb5_db_put_principal(context, &entry, &nentries);\n    krb5_db_free_principal(context, &entry, 1);\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while adding K/M to the database\""
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_destroy",
          "args": [
            "context",
            "tempdbname"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_fini",
          "args": [
            "context"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while initializing the database '%s'\"",
            "tempdbname"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_destroy",
          "args": [
            "context",
            "tempdbname"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_open_database",
          "args": [
            "context"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_init",
          "args": [
            "context"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_destroy",
          "args": [
            "context",
            "tempdbname"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "v4init",
          "args": [
            "PROGNAME",
            "v4manual",
            "v4dumpfile"
          ],
          "line": 359
        },
        "resolved": true,
        "details": {
          "function_name": "v4init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/loadv4.c",
          "lines": "449-472",
          "snippet": "static int\nv4init(pname, manual, dumpfile)\nchar *pname;\nint manual;\nchar *dumpfile;\n{\n    int fd;\n    int ok = 0;\n\n    if (!manual) {\n\tfd = open(v4_mkeyfile, O_RDONLY, 0600);\n\tif (fd >= 0) {\n\t    if (read(fd, master_key, sizeof(master_key)) == sizeof(master_key))\n\t\tok = 1;\n\t    close(fd);\n\t}\n    }\n    if (!ok) {\n\tdes_read_password(&master_key, \"V4 Kerberos master key\", 0);\n\tprintf(\"\\n\");\n    }\n    key_sched(master_key, master_key_schedule);\n    return 0;\n}",
          "includes": [
            "#include <netinet/in.h>\t\t\t/* ntohl */",
            "#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */",
            "#include \"kdb5_util.h\"",
            "#include <stdio.h>",
            "#include <kadm5/admin.h>",
            "#include <kdc.h>",
            "#include <krb_db.h>",
            "#include <krb.h>",
            "#include <des.h>",
            "#include \"com_err.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\nstatic int\nv4init(pname, manual, dumpfile)\nchar *pname;\nint manual;\nchar *dumpfile;\n{\n    int fd;\n    int ok = 0;\n\n    if (!manual) {\n\tfd = open(v4_mkeyfile, O_RDONLY, 0600);\n\tif (fd >= 0) {\n\t    if (read(fd, master_key, sizeof(master_key)) == sizeof(master_key))\n\t\tok = 1;\n\t    close(fd);\n\t}\n    }\n    if (!ok) {\n\tdes_read_password(&master_key, \"V4 Kerberos master key\", 0);\n\tprintf(\"\\n\");\n    }\n    key_sched(master_key, master_key_schedule);\n    return 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while setting active database to '%s'\"",
            "tempdbname"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_destroy",
          "args": [
            "context",
            "tempdbname"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_set_name",
          "args": [
            "context",
            "tempdbname"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while creating %sdatabase '%s'\"",
            "tempdb ? \"temporary \" : \"\"",
            "tempdbname"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_create",
          "args": [
            "context",
            "tempdbname",
            "crflags"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while initializing random key generator\""
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_c_random_seed",
          "args": [
            "context",
            "&seed"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while reading master key\""
          ],
          "line": 326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_fetch_mkey",
          "args": [
            "context",
            "master_princ",
            "master_keyblock.enctype",
            "read_mkey",
            "read_mkey",
            "stash_file",
            "0",
            "&master_keyblock"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fflush",
          "args": [
            "stdout"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "puts",
          "args": [
            "\"It is important that you NOT FORGET this password.\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "puts",
          "args": [
            "\"You will be prompted for the version 5 database Master Password.\""
          ],
          "line": 315
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Initializing database '%s' for realm '%s',\\n\\\nmaster key name '%s'\\n\"",
            "dbname",
            "realm",
            "mkey_fullname"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "realm"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_princ_component",
          "args": [
            "context",
            "&tgt_princ",
            "1"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_princ_component",
          "args": [
            "context",
            "&tgt_princ",
            "1"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_princ_set_realm_length",
          "args": [
            "context",
            "&tgt_princ",
            "strlen(realm)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "realm"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_princ_set_realm_data",
          "args": [
            "context",
            "&tgt_princ",
            "realm"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_princ_set_realm_length",
          "args": [
            "context",
            "&db_create_princ",
            "strlen(realm)"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "realm"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_princ_set_realm_data",
          "args": [
            "context",
            "&db_create_princ",
            "realm"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while setting up master key name\""
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_setup_mkey_name",
          "args": [
            "context",
            "mkey_name",
            "realm",
            "&mkey_fullname",
            "&master_princ"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "retval",
            "\"while retrieving default realm name\""
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_get_default_realm",
          "args": [
            "context",
            "&defrealm"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_destroy",
          "args": [
            "context",
            "tempdbname"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "tempdbname",
            "dbname"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "ENOMEM",
            "\"allocating temporary filename\""
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "dbnamelen + 2"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbname"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: The v5 database appears to already exist.\\n\"",
            "PROGNAME"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_db_set_name",
          "args": [
            "context",
            "dbname"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "com_err",
          "args": [
            "PROGNAME",
            "KRB5_PROG_KEYTYPE_NOSUPP",
            "\"while setting up enctype %d\"",
            "master_keyblock.enctype"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_c_valid_enctype",
          "args": [
            "master_keyblock.enctype"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_free_context",
          "args": [
            "context"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "usage",
          "args": [],
          "line": 245
        },
        "resolved": true,
        "details": {
          "function_name": "usage",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/dbutil/kdb5_util.c",
          "lines": "82-98",
          "snippet": "void usage()\n{\n     fprintf(stderr, \"Usage: \"\n\t   \"kdb5_util [-r realm] [-d dbname] [-k mkeytype] [-M mkeyname]\\n\"\n\t     \"\\t        [-sf stashfilename] [-m] cmd [cmd_options]\\n\"\n\t     \"\\tcreate\t[-s]\\n\"\n\t     \"\\tdestroy\t[-f]\\n\"\n\t     \"\\tstash\t[-f keyfile]\\n\"\n\t     \"\\tdump\t[-old] [-ov] [-b6] [-verbose]\\n\"\n\t     \"\\t\t[-mkey_convert] [-new_mkey_file mkey_file]\\n\"\n\t     \"\\t\t[-rev] [-recurse] [filename [princs...]]\\n\"\n\t     \"\\tload\t[-old] [-ov] [-b6] [-verbose] [-update] filename\\n\"\n\t     \"\\tdump_v4\t[-S] [filename]\\n\"\n\t     \"\\tload_v4\t[-S] [-t] [-n] [-v] [-K] [-s stashfile] inputfile\\n\"\n\t     \"\\tark\t[-e etype_list] principal\\n\");\n     exit(1);\n}",
          "includes": [
            "#include \"kdb5_util.h\"",
            "#include <time.h>",
            "#include <kadm5/adb.h>",
            "#include <krb5/adm_proto.h>",
            "#include <kadm5/admin.h>",
            "#include <k5-int.h>",
            "#include <stdio.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb5_util.h\"\n#include <time.h>\n#include <kadm5/adb.h>\n#include <krb5/adm_proto.h>\n#include <kadm5/admin.h>\n#include <k5-int.h>\n#include <stdio.h>\n\nvoid usage()\n{\n     fprintf(stderr, \"Usage: \"\n\t   \"kdb5_util [-r realm] [-d dbname] [-k mkeytype] [-M mkeyname]\\n\"\n\t     \"\\t        [-sf stashfilename] [-m] cmd [cmd_options]\\n\"\n\t     \"\\tcreate\t[-s]\\n\"\n\t     \"\\tdestroy\t[-f]\\n\"\n\t     \"\\tstash\t[-f keyfile]\\n\"\n\t     \"\\tdump\t[-old] [-ov] [-b6] [-verbose]\\n\"\n\t     \"\\t\t[-mkey_convert] [-new_mkey_file mkey_file]\\n\"\n\t     \"\\t\t[-rev] [-recurse] [filename [princs...]]\\n\"\n\t     \"\\tload\t[-old] [-ov] [-b6] [-verbose] [-update] filename\\n\"\n\t     \"\\tdump_v4\t[-S] [filename]\\n\"\n\t     \"\\tload_v4\t[-S] [-t] [-n] [-v] [-K] [-s stashfile] inputfile\\n\"\n\t     \"\\tark\t[-e etype_list] principal\\n\");\n     exit(1);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "global_params.stash_file"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[op_ind]",
            "\"-h\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[op_ind]",
            "\"-s\""
          ],
          "line": 213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[op_ind]",
            "\"-S\""
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[op_ind]",
            "\"-n\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[op_ind]",
            "\"-v\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[op_ind]",
            "\"-K\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[op_ind]",
            "\"-t\""
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[op_ind]",
            "\"-T\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "argv[0]",
            "'/'"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"%s: Could not initialize krb5 context.\\n\"",
            "PROGNAME"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_init_context",
          "args": [
            "&context"
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <netinet/in.h>\t\t\t/* ntohl */\n#include \"kadm5/adb.h\"                  /* osa_adb_create_policy_db */\n#include \"kdb5_util.h\"\n#include <stdio.h>\n#include <kadm5/admin.h>\n#include <kdc.h>\n#include <krb_db.h>\n#include <krb.h>\n#include <des.h>\n#include \"com_err.h\"\n#include \"k5-int.h\"\n\n#define PROGNAME argv[0]\n\nvoid\nload_v4db(argc, argv)\n    int argc;\n    char *argv[];\n{\n    krb5_error_code retval;\n    /* The kdb library will default to this, but it is convenient to\n       make it explicit (error reporting and temporary filename generation\n       use it).  */\n    char *dbname = DEFAULT_KDB_FILE;\n    char *v4dumpfile = 0;\n    char *realm = 0;\n    char *mkey_name = 0;\n    char *mkey_fullname;\n    char *defrealm;\n    int v4manual = 0;\n    krb5_boolean read_mkey = 0;\n    int tempdb = 0;\n    char *tempdbname;\n    krb5_context context;\n    char *stash_file = (char *) NULL;\n    int\tpersist, op_ind;\n    kadm5_config_params newparams;\n    extern kadm5_config_params global_params;\n    long exp_time = 0;\n    krb5_int32 crflags = KRB5_KDB_CREATE_BTREE;\n    krb5_data seed;\n\n    retval = krb5_init_context(&context);\n    if (retval) {\n\tfprintf(stderr, \"%s: Could not initialize krb5 context.\\n\", PROGNAME);\n\treturn;\n    }\n\n    if (strrchr(argv[0], '/'))\n\targv[0] = strrchr(argv[0], '/')+1;\n\n    persist = 1;\n    op_ind = 1;\n    while (persist && (op_ind < argc)) {\n\tif (!strcmp(argv[op_ind], \"-T\")) {\n\t    create_local_tgt = 1;\n\t}\n\telse if (!strcmp(argv[op_ind], \"-t\")) {\n\t    tempdb = 1;\n\t}\n\telse if (!strcmp(argv[op_ind], \"-K\")) {\n\t    read_mkey = 1;\n\t}\n\telse if (!strcmp(argv[op_ind], \"-v\")) {\n\t    verbose = 1;\n\t}\n\telse if (!strcmp(argv[op_ind], \"-n\")) {\n\t    v4manual++;\n\t} \n\telse if (!strcmp(argv[op_ind], \"-S\")) {\n\t    shortlife++;\n\t}\n\telse if (!strcmp(argv[op_ind], \"-s\")) {\n\t    if ((argc - op_ind) >= 1) {\n\t        v4_mkeyfile = argv[op_ind+1];\n\t\top_ind++;\n\t    } else {\n\t\tusage();\n\t    }\n\t}\n\telse if (!strcmp(argv[op_ind], \"-h\")) {\n\t    crflags = KRB5_KDB_CREATE_HASH;\n\t}\n\telse if ((argc - op_ind) >= 1) {\n\t    v4dumpfile = argv[op_ind];\n\t    op_ind++;\n\t}\n\telse\n\t    usage();\n\top_ind++;\n    }\n\n    realm = global_params.realm;\n    dbname = global_params.dbname;\n    mkey_name = global_params.mkey_name;\n    master_keyblock.enctype = global_params.enctype;\n    if (global_params.stash_file)\n\t    stash_file = strdup(global_params.stash_file);\n    rblock.max_life = global_params.max_life;\n    rblock.max_rlife = global_params.max_rlife;\n    rblock.expiration = global_params.expiration;\n    rblock.flags = global_params.flags;\n\n    if (!v4dumpfile) {\n\tusage();\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    if (!krb5_c_valid_enctype(master_keyblock.enctype)) {\n\tcom_err(PROGNAME, KRB5_PROG_KEYTYPE_NOSUPP,\n\t\t\"while setting up enctype %d\", master_keyblock.enctype);\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    /* If the user has not requested locking, don't modify an existing database. */\n    if (! tempdb) {\n\tretval = krb5_db_set_name(context, dbname);\n\tif (retval != ENOENT) {\n\t    fprintf(stderr,\n\t\t    \"%s: The v5 database appears to already exist.\\n\",\n\t\t    PROGNAME);\n\t    krb5_free_context(context);\n\t    return;\n\t}\n\ttempdbname = dbname;\n    } else {\n\tsize_t dbnamelen = strlen(dbname);\n\ttempdbname = malloc(dbnamelen + 2);\n\tif (tempdbname == 0) {\n\t    com_err(PROGNAME, ENOMEM, \"allocating temporary filename\");\n\t    krb5_free_context(context);\n\t    return;\n\t}\n\tstrcpy(tempdbname, dbname);\n\ttempdbname[dbnamelen] = '~';\n\ttempdbname[dbnamelen+1] = 0;\n\t(void) krb5_db_destroy(context, tempdbname);\n    }\n\t\n\n    if (!realm) {\n\tretval = krb5_get_default_realm(context, &defrealm);\n\tif (retval) {\n\t    com_err(PROGNAME, retval, \"while retrieving default realm name\");\n\t    krb5_free_context(context);\n\t    return;\n\t}\t    \n\trealm = defrealm;\n    }\n\n    /* assemble & parse the master key name */\n    \n    retval = krb5_db_setup_mkey_name(context, mkey_name, realm,\n\t\t\t\t     &mkey_fullname, &master_princ);\n    if (retval) {\n\tcom_err(PROGNAME, retval, \"while setting up master key name\");\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    krb5_princ_set_realm_data(context, &db_create_princ, realm);\n    krb5_princ_set_realm_length(context, &db_create_princ, strlen(realm));\n    krb5_princ_set_realm_data(context, &tgt_princ, realm);\n    krb5_princ_set_realm_length(context, &tgt_princ, strlen(realm));\n    krb5_princ_component(context, &tgt_princ,1)->data = realm;\n    krb5_princ_component(context, &tgt_princ,1)->length = strlen(realm);\n\n    printf(\"Initializing database '%s' for realm '%s',\\n\\\nmaster key name '%s'\\n\",\n\t   dbname, realm, mkey_fullname);\n\n    if (read_mkey) {\n\tputs(\"You will be prompted for the version 5 database Master Password.\");\n\tputs(\"It is important that you NOT FORGET this password.\");\n\tfflush(stdout);\n    }\n\n\n    retval = krb5_db_fetch_mkey(context, master_princ,\n\t\t\t\tmaster_keyblock.enctype,\n\t\t\t\tread_mkey, read_mkey, stash_file, 0, \n\t\t\t\t&master_keyblock);\n    if (retval) {\n\tcom_err(PROGNAME, retval, \"while reading master key\");\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    rblock.key = &master_keyblock;\n\n    seed.length = master_keyblock.length;\n    seed.data = master_keyblock.contents;\n\n    retval = krb5_c_random_seed(context, &seed);\n    if (retval) {\n\tcom_err(PROGNAME, retval, \"while initializing random key generator\");\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    retval = krb5_db_create(context, tempdbname, crflags);\n    if (retval) {\n\tcom_err(PROGNAME, retval, \"while creating %sdatabase '%s'\",\n\t\ttempdb ? \"temporary \" : \"\", tempdbname);\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    retval = krb5_db_set_name(context, tempdbname);\n    if (retval) {\n\t(void) krb5_db_destroy(context, tempdbname);\n        com_err(PROGNAME, retval, \"while setting active database to '%s'\",\n                tempdbname);\n\tkrb5_free_context(context);\n        return;\n    }\n    if (v4init(PROGNAME, v4manual, v4dumpfile)) {\n\t(void) krb5_db_destroy(context, tempdbname);\n\tkrb5_free_context(context);\n\treturn;\n    }\n    if ((retval = krb5_db_init(context)) || \n\t(retval = krb5_db_open_database(context))) {\n\t(void) krb5_db_destroy(context, tempdbname);\n\tcom_err(PROGNAME, retval, \"while initializing the database '%s'\",\n\t\ttempdbname);\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    retval = add_principal(context, master_princ, MASTER_KEY, &rblock);\n    if (retval) {\n\t(void) krb5_db_fini(context);\n\t(void) krb5_db_destroy(context, tempdbname);\n\tcom_err(PROGNAME, retval, \"while adding K/M to the database\");\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    if (create_local_tgt &&\n\t(retval = add_principal(context, &tgt_princ, RANDOM_KEY, &rblock))) {\n\t(void) krb5_db_fini(context);\n\t(void) krb5_db_destroy(context, tempdbname);\n\tcom_err(PROGNAME, retval, \"while adding TGT service to the database\");\n\tkrb5_free_context(context);\n\treturn;\n    }\n\n    retval = v4_dump_find_default(context, v4dumpfile, realm, &exp_time);\n    if (retval) {\n        com_err(PROGNAME, retval, \"warning: default entry not found\");\n    }\n\n    retval = process_v4_dump(context, v4dumpfile, realm, exp_time);\n    putchar('\\n');\n    if (retval)\n\tcom_err(PROGNAME, retval, \"while translating entries to the database\");\n    else {\n\tretval = fixup_database(context, realm);\n    }\n    \n    /* clean up; rename temporary database if there were no errors */\n    if (retval == 0) {\n\tretval = krb5_db_fini (context);\n\tif (retval)\n\t    com_err(PROGNAME, retval, \"while shutting down database\");\n\telse if (tempdb && (retval = krb5_db_rename(context, tempdbname,\n\t\t\t\t\t\t    dbname)))\n\t    com_err(PROGNAME, retval, \"while renaming temporary database\");\n    } else {\n\t(void) krb5_db_fini (context);\n\tif (tempdb)\n\t    (void) krb5_db_destroy (context, tempdbname);\n    }\n    memset((char *)master_keyblock.contents, 0, master_keyblock.length);\n\n    /*\n     * Cons up config params for new database; using the global_params\n     * is just fine.\n     */\n    newparams = global_params;\n\n    /*\n     * Always create the policy db, even if we are not loading a dump\n     * file with policy info.\n     */\n    if (!tempdb && (retval = osa_adb_create_policy_db(&newparams))) {\n\tcom_err(PROGNAME, retval, \"while creating policy database\");\n\tkadm5_free_config_params(context, &newparams);\n\tkrb5_free_context(context);\n\treturn;\n    }\n    /*\n     * Create the magic principals in the database.\n     */\n    retval = kadm5_create_magic_princs(&newparams, context);\n    if (retval) {\n\tcom_err(PROGNAME, retval, \"while creating KADM5 principals\");\n\tkrb5_free_context(context);\n\treturn;\n    }\n    \n    krb5_free_context(context);\n    return;\n}"
  }
]