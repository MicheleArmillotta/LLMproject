[
  {
    "function_name": "ktutil_write_srvtab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
    "lines": "462-555",
    "snippet": "krb5_error_code ktutil_write_srvtab(context, list, name)\n    krb5_context context;\n    krb5_kt_list list;\n    char *name;\n{\n    krb5_kt_list lp, lp1, prev, pruned = NULL;\n    krb5_error_code retval = 0;\n    FILE *fp;\n    char sname[SNAME_SZ];\n    char sinst[INST_SZ];\n    char srealm[REALM_SZ];\n\n    /* First do heinous stuff to prune the list. */\n    for (lp = list; lp; lp = lp->next) {\n\tif ((lp->entry->key.enctype != ENCTYPE_DES_CBC_CRC) &&\n\t    (lp->entry->key.enctype != ENCTYPE_DES_CBC_MD5) &&\n\t    (lp->entry->key.enctype != ENCTYPE_DES_CBC_MD4) &&\n\t    (lp->entry->key.enctype != ENCTYPE_DES_CBC_RAW))\n\t    continue;\n\n\tfor (lp1 = pruned; lp1; prev = lp1, lp1 = lp1->next) {\n\t    /* Hunt for the current principal in the pruned list */\n\t    if (krb5_principal_compare(context,\n\t\t\t\t       lp->entry->principal,\n\t\t\t\t       lp1->entry->principal))\n\t\t    break;\n\t}\n\tif (!lp1) {\t\t/* need to add entry to tail of pruned list */\n\t    if (!pruned) {\n\t\tpruned = (krb5_kt_list) malloc(sizeof (*pruned));\n\t\tif (!pruned)\n\t\t    return ENOMEM;\n\t\tmemset((char *) pruned, 0, sizeof(*pruned));\n\t\tlp1 = pruned;\n\t    } else {\n\t\tprev->next\n\t\t    = (krb5_kt_list) malloc(sizeof (*pruned));\n\t\tif (!prev->next) {\n\t\t    retval = ENOMEM;\n\t\t    goto free_pruned;\n\t\t}\n\t\tmemset((char *) prev->next, 0, sizeof(*pruned));\n\t\tlp1 = prev->next;\n\t    }\n\t    lp1->entry = lp->entry;\n\t} else {\n\t    /* This heuristic should be roughly the same as in the\n\t       keytab-reading code in libkrb5.  */\n\t    int offset = 0;\n\t    if (lp1->entry->vno > 240 || lp->entry->vno > 240) {\n\t\toffset = 128;\n\t    }\n#define M(X) (((X) + offset) % 256)\n\t    if (M(lp1->entry->vno) < M(lp->entry->vno))\n\t\t/* Check if lp->entry is newer kvno; if so, update */\n\t\tlp1->entry = lp->entry;\n\t}\n    }\n    umask(0077); /*Changing umask for all of ktutil is OK\n\t\t  * We don't ever write out anything that should use\n\t\t  * default umask.*/\n    fp = fopen(name, \"w\");\n    if (!fp) {\n\tretval = EIO;\n\tgoto free_pruned;\n    }\n    for (lp = pruned; lp; lp = lp->next) {\n\tunsigned char  kvno;\n\tkvno = (unsigned char) lp->entry->vno;\n\tretval = krb5_524_conv_principal(context,\n\t\t\t\t\t lp->entry->principal,\n\t\t\t\t\t sname, sinst, srealm);\n\tif (retval)\n\t    break;\n\tfwrite(sname, strlen(sname) + 1, 1, fp);\n\tfwrite(sinst, strlen(sinst) + 1, 1, fp);\n\tfwrite(srealm, strlen(srealm) + 1, 1, fp);\n\tfwrite((char *)&kvno, 1, 1, fp);\n\tfwrite((char *)lp->entry->key.contents,\n\t       sizeof (des_cblock), 1, fp);\n    }\n    fclose(fp);\n free_pruned:\n    /*\n     * Loop over and free the pruned list; don't use free_kt_list\n     * because that kills the entries.\n     */\n    for (lp = pruned; lp;) {\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"kerberosIV/krb.h\"",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "(char *)prev"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_free_kt_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "41-58",
          "snippet": "krb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"kerberosIV/krb.h\"",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "(char *)lp->entry->key.contents",
            "sizeof (des_cblock)",
            "1",
            "fp"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "(char *)&kvno",
            "1",
            "1",
            "fp"
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "srealm",
            "strlen(srealm) + 1",
            "1",
            "fp"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "srealm"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "sinst",
            "strlen(sinst) + 1",
            "1",
            "fp"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sinst"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fwrite",
          "args": [
            "sname",
            "strlen(sname) + 1",
            "1",
            "fp"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "sname"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_524_conv_principal",
          "args": [
            "context",
            "lp->entry->principal",
            "sname",
            "sinst",
            "srealm"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "name",
            "\"w\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "umask",
          "args": [
            "0077"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M",
          "args": [
            "lp->entry->vno"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "M",
          "args": [
            "lp1->entry->vno"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *) prev->next",
            "0",
            "sizeof(*pruned)"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (*pruned)"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *) pruned",
            "0",
            "sizeof(*pruned)"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (*pruned)"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principal_compare",
          "args": [
            "context",
            "lp->entry->principal",
            "lp1->entry->principal"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_write_srvtab(context, list, name)\n    krb5_context context;\n    krb5_kt_list list;\n    char *name;\n{\n    krb5_kt_list lp, lp1, prev, pruned = NULL;\n    krb5_error_code retval = 0;\n    FILE *fp;\n    char sname[SNAME_SZ];\n    char sinst[INST_SZ];\n    char srealm[REALM_SZ];\n\n    /* First do heinous stuff to prune the list. */\n    for (lp = list; lp; lp = lp->next) {\n\tif ((lp->entry->key.enctype != ENCTYPE_DES_CBC_CRC) &&\n\t    (lp->entry->key.enctype != ENCTYPE_DES_CBC_MD5) &&\n\t    (lp->entry->key.enctype != ENCTYPE_DES_CBC_MD4) &&\n\t    (lp->entry->key.enctype != ENCTYPE_DES_CBC_RAW))\n\t    continue;\n\n\tfor (lp1 = pruned; lp1; prev = lp1, lp1 = lp1->next) {\n\t    /* Hunt for the current principal in the pruned list */\n\t    if (krb5_principal_compare(context,\n\t\t\t\t       lp->entry->principal,\n\t\t\t\t       lp1->entry->principal))\n\t\t    break;\n\t}\n\tif (!lp1) {\t\t/* need to add entry to tail of pruned list */\n\t    if (!pruned) {\n\t\tpruned = (krb5_kt_list) malloc(sizeof (*pruned));\n\t\tif (!pruned)\n\t\t    return ENOMEM;\n\t\tmemset((char *) pruned, 0, sizeof(*pruned));\n\t\tlp1 = pruned;\n\t    } else {\n\t\tprev->next\n\t\t    = (krb5_kt_list) malloc(sizeof (*pruned));\n\t\tif (!prev->next) {\n\t\t    retval = ENOMEM;\n\t\t    goto free_pruned;\n\t\t}\n\t\tmemset((char *) prev->next, 0, sizeof(*pruned));\n\t\tlp1 = prev->next;\n\t    }\n\t    lp1->entry = lp->entry;\n\t} else {\n\t    /* This heuristic should be roughly the same as in the\n\t       keytab-reading code in libkrb5.  */\n\t    int offset = 0;\n\t    if (lp1->entry->vno > 240 || lp->entry->vno > 240) {\n\t\toffset = 128;\n\t    }\n#define M(X) (((X) + offset) % 256)\n\t    if (M(lp1->entry->vno) < M(lp->entry->vno))\n\t\t/* Check if lp->entry is newer kvno; if so, update */\n\t\tlp1->entry = lp->entry;\n\t}\n    }\n    umask(0077); /*Changing umask for all of ktutil is OK\n\t\t  * We don't ever write out anything that should use\n\t\t  * default umask.*/\n    fp = fopen(name, \"w\");\n    if (!fp) {\n\tretval = EIO;\n\tgoto free_pruned;\n    }\n    for (lp = pruned; lp; lp = lp->next) {\n\tunsigned char  kvno;\n\tkvno = (unsigned char) lp->entry->vno;\n\tretval = krb5_524_conv_principal(context,\n\t\t\t\t\t lp->entry->principal,\n\t\t\t\t\t sname, sinst, srealm);\n\tif (retval)\n\t    break;\n\tfwrite(sname, strlen(sname) + 1, 1, fp);\n\tfwrite(sinst, strlen(sinst) + 1, 1, fp);\n\tfwrite(srealm, strlen(srealm) + 1, 1, fp);\n\tfwrite((char *)&kvno, 1, 1, fp);\n\tfwrite((char *)lp->entry->key.contents,\n\t       sizeof (des_cblock), 1, fp);\n    }\n    fclose(fp);\n free_pruned:\n    /*\n     * Loop over and free the pruned list; don't use free_kt_list\n     * because that kills the entries.\n     */\n    for (lp = pruned; lp;) {\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}"
  },
  {
    "function_name": "ktutil_read_srvtab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
    "lines": "365-455",
    "snippet": "krb5_error_code ktutil_read_srvtab(context, name, list)\n    krb5_context context;\n    char *name;\n    krb5_kt_list *list;\n{\n    krb5_kt_list lp = NULL, tail = NULL, back = NULL;\n    krb5_keytab_entry *entry;\n    krb5_error_code retval = 0;\n    char sname[SNAME_SZ];\t/* name of service */\n    char sinst[INST_SZ];\t/* instance of service */\n    char srealm[REALM_SZ];\t/* realm of service */\n    unsigned char kvno;\t\t/* key version number */\n    des_cblock key;\n    FILE *fp;\n\n    if (*list) {\n\t/* point lp at the tail of the list */\n\tfor (lp = *list; lp->next; lp = lp->next);\n\tback = lp;\n    }\n    fp = fopen(name, \"r\");\n    if (!fp)\n\treturn EIO;\n    for (;;) {\n\tentry = (krb5_keytab_entry *)malloc(sizeof (krb5_keytab_entry));\n\tif (!entry) {\n\t    retval = ENOMEM;\n\t    break;\n\t}\n\tmemset((char *)entry, 0, sizeof (*entry));\n\tmemset(sname, 0, sizeof (sname));\n\tmemset(sinst, 0, sizeof (sinst));\n\tmemset(srealm, 0, sizeof (srealm));\n\tif (!(getstr(fp, sname, SNAME_SZ) > 0 &&\n\t      getstr(fp, sinst, INST_SZ) > 0 &&\n\t      getstr(fp, srealm, REALM_SZ) > 0 &&\n\t      fread(&kvno, 1, 1, fp) > 0 &&\n\t      fread((char *)key, sizeof (key), 1, fp) > 0))\n\t    break;\n\tentry->magic = KV5M_KEYTAB_ENTRY;\n\tentry->timestamp = 0;\t/* XXX */\n\tentry->vno = kvno;\n\tretval = krb5_425_conv_principal(context,\n\t\t\t\t\t sname, sinst, srealm,\n\t\t\t\t\t &entry->principal);\n\tif (retval)\n\t    break;\n\tentry->key.magic = KV5M_KEYBLOCK;\n\tentry->key.enctype = ENCTYPE_DES_CBC_CRC;\n\tentry->key.length = sizeof (key);\n\tentry->key.contents = (krb5_octet *)malloc(sizeof (key));\n\tif (!entry->key.contents) {\n\t    retval = ENOMEM;\n\t    break;\n\t}\n\tmemcpy((char *)entry->key.contents, (char *)key, sizeof (key));\n\tif (!lp) {\t\t/* if list is empty, start one */\n\t    lp = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t} else {\n\t    lp->next = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp->next) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t    lp = lp->next;\n\t}\n\tlp->next = NULL;\n\tlp->entry = entry;\n\tif (!tail)\n\t    tail = lp;\n    }\n    if (entry) {\n\tif (entry->magic == KV5M_KEYTAB_ENTRY)\n\t    krb5_kt_free_entry(context, entry);\n\tfree((char *)entry);\n    }\n    if (retval) {\n\tktutil_free_kt_list(context, tail);\n\ttail = NULL;\n\tif (back)\n\t    back->next = NULL;\n    }\n    if (!*list)\n\t*list = tail;\n    fclose(fp);\n    return retval;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"kerberosIV/krb.h\"",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fclose",
          "args": [
            "fp"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktutil_free_kt_list",
          "args": [
            "context",
            "tail"
          ],
          "line": 446
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_free_kt_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "41-58",
          "snippet": "krb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"kerberosIV/krb.h\"",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "krb5_kt_free_entry",
          "args": [
            "context",
            "entry"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (*lp)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (*lp)"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "(char *)entry->key.contents",
            "(char *)key",
            "sizeof (key)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (key)"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_425_conv_principal",
          "args": [
            "context",
            "sname",
            "sinst",
            "srealm",
            "&entry->principal"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "(char *)key",
            "sizeof (key)",
            "1",
            "fp"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "&kvno",
            "1",
            "1",
            "fp"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "getstr",
          "args": [
            "fp",
            "srealm",
            "REALM_SZ"
          ],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "getstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "348-359",
          "snippet": "static int getstr(fp, s, n)\n    FILE *fp;\n    register char *s;\n    int n;\n{\n    register int count = n;\n    while (fread(s, 1, 1, fp) > 0 && --count)\n        if (*s++ == '\\0')\n            return (n - count);\n    *s = '\\0';\n    return (n - count);\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"kerberosIV/krb.h\"",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nstatic int getstr(fp, s, n)\n    FILE *fp;\n    register char *s;\n    int n;\n{\n    register int count = n;\n    while (fread(s, 1, 1, fp) > 0 && --count)\n        if (*s++ == '\\0')\n            return (n - count);\n    *s = '\\0';\n    return (n - count);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "srealm",
            "0",
            "sizeof (srealm)"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sinst",
            "0",
            "sizeof (sinst)"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sname",
            "0",
            "sizeof (sname)"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)entry",
            "0",
            "sizeof (*entry)"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (krb5_keytab_entry)"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fopen",
          "args": [
            "name",
            "\"r\""
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_read_srvtab(context, name, list)\n    krb5_context context;\n    char *name;\n    krb5_kt_list *list;\n{\n    krb5_kt_list lp = NULL, tail = NULL, back = NULL;\n    krb5_keytab_entry *entry;\n    krb5_error_code retval = 0;\n    char sname[SNAME_SZ];\t/* name of service */\n    char sinst[INST_SZ];\t/* instance of service */\n    char srealm[REALM_SZ];\t/* realm of service */\n    unsigned char kvno;\t\t/* key version number */\n    des_cblock key;\n    FILE *fp;\n\n    if (*list) {\n\t/* point lp at the tail of the list */\n\tfor (lp = *list; lp->next; lp = lp->next);\n\tback = lp;\n    }\n    fp = fopen(name, \"r\");\n    if (!fp)\n\treturn EIO;\n    for (;;) {\n\tentry = (krb5_keytab_entry *)malloc(sizeof (krb5_keytab_entry));\n\tif (!entry) {\n\t    retval = ENOMEM;\n\t    break;\n\t}\n\tmemset((char *)entry, 0, sizeof (*entry));\n\tmemset(sname, 0, sizeof (sname));\n\tmemset(sinst, 0, sizeof (sinst));\n\tmemset(srealm, 0, sizeof (srealm));\n\tif (!(getstr(fp, sname, SNAME_SZ) > 0 &&\n\t      getstr(fp, sinst, INST_SZ) > 0 &&\n\t      getstr(fp, srealm, REALM_SZ) > 0 &&\n\t      fread(&kvno, 1, 1, fp) > 0 &&\n\t      fread((char *)key, sizeof (key), 1, fp) > 0))\n\t    break;\n\tentry->magic = KV5M_KEYTAB_ENTRY;\n\tentry->timestamp = 0;\t/* XXX */\n\tentry->vno = kvno;\n\tretval = krb5_425_conv_principal(context,\n\t\t\t\t\t sname, sinst, srealm,\n\t\t\t\t\t &entry->principal);\n\tif (retval)\n\t    break;\n\tentry->key.magic = KV5M_KEYBLOCK;\n\tentry->key.enctype = ENCTYPE_DES_CBC_CRC;\n\tentry->key.length = sizeof (key);\n\tentry->key.contents = (krb5_octet *)malloc(sizeof (key));\n\tif (!entry->key.contents) {\n\t    retval = ENOMEM;\n\t    break;\n\t}\n\tmemcpy((char *)entry->key.contents, (char *)key, sizeof (key));\n\tif (!lp) {\t\t/* if list is empty, start one */\n\t    lp = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t} else {\n\t    lp->next = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp->next) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t    lp = lp->next;\n\t}\n\tlp->next = NULL;\n\tlp->entry = entry;\n\tif (!tail)\n\t    tail = lp;\n    }\n    if (entry) {\n\tif (entry->magic == KV5M_KEYTAB_ENTRY)\n\t    krb5_kt_free_entry(context, entry);\n\tfree((char *)entry);\n    }\n    if (retval) {\n\tktutil_free_kt_list(context, tail);\n\ttail = NULL;\n\tif (back)\n\t    back->next = NULL;\n    }\n    if (!*list)\n\t*list = tail;\n    fclose(fp);\n    return retval;\n}"
  },
  {
    "function_name": "getstr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
    "lines": "348-359",
    "snippet": "static int getstr(fp, s, n)\n    FILE *fp;\n    register char *s;\n    int n;\n{\n    register int count = n;\n    while (fread(s, 1, 1, fp) > 0 && --count)\n        if (*s++ == '\\0')\n            return (n - count);\n    *s = '\\0';\n    return (n - count);\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"kerberosIV/krb.h\"",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fread",
          "args": [
            "s",
            "1",
            "1",
            "fp"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nstatic int getstr(fp, s, n)\n    FILE *fp;\n    register char *s;\n    int n;\n{\n    register int count = n;\n    while (fread(s, 1, 1, fp) > 0 && --count)\n        if (*s++ == '\\0')\n            return (n - count);\n    *s = '\\0';\n    return (n - count);\n}"
  },
  {
    "function_name": "ktutil_write_keytab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
    "lines": "311-335",
    "snippet": "krb5_error_code ktutil_write_keytab(context, list, name)\n    krb5_context context;\n    krb5_kt_list list;\n    char *name;\n{\n    krb5_kt_list lp;\n    krb5_keytab kt;\n    char ktname[MAXPATHLEN+sizeof(\"WRFILE:\")+1];\n    krb5_error_code retval = 0;\n\n    strcpy(ktname, \"WRFILE:\");\n    if (strlen (name) >= MAXPATHLEN)\n\treturn ENAMETOOLONG;\n    strncat (ktname, name, MAXPATHLEN);\n    retval = krb5_kt_resolve(context, ktname, &kt);\n    if (retval)\n\treturn retval;\n    for (lp = list; lp; lp = lp->next) {\n\tretval = krb5_kt_add_entry(context, kt, lp->entry);\n\tif (retval)\n\t    break;\n    }\n    krb5_kt_close(context, kt);\n    return retval;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"kerberosIV/krb.h\"",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_kt_close",
          "args": [
            "context",
            "kt"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_add_entry",
          "args": [
            "context",
            "kt",
            "lp->entry"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_resolve",
          "args": [
            "context",
            "ktname",
            "&kt"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "ktname",
            "name",
            "MAXPATHLEN"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "name"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "ktname",
            "\"WRFILE:\""
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_write_keytab(context, list, name)\n    krb5_context context;\n    krb5_kt_list list;\n    char *name;\n{\n    krb5_kt_list lp;\n    krb5_keytab kt;\n    char ktname[MAXPATHLEN+sizeof(\"WRFILE:\")+1];\n    krb5_error_code retval = 0;\n\n    strcpy(ktname, \"WRFILE:\");\n    if (strlen (name) >= MAXPATHLEN)\n\treturn ENAMETOOLONG;\n    strncat (ktname, name, MAXPATHLEN);\n    retval = krb5_kt_resolve(context, ktname, &kt);\n    if (retval)\n\treturn retval;\n    for (lp = list; lp; lp = lp->next) {\n\tretval = krb5_kt_add_entry(context, kt, lp->entry);\n\tif (retval)\n\t    break;\n    }\n    krb5_kt_close(context, kt);\n    return retval;\n}"
  },
  {
    "function_name": "ktutil_read_keytab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
    "lines": "236-306",
    "snippet": "krb5_error_code ktutil_read_keytab(context, name, list)\n    krb5_context context;\n    char *name;\n    krb5_kt_list *list;\n{\n    krb5_kt_list lp = NULL, tail = NULL, back = NULL;\n    krb5_keytab kt;\n    krb5_keytab_entry *entry;\n    krb5_kt_cursor cursor;\n    krb5_error_code retval = 0;\n\n    if (*list) {\n\t/* point lp at the tail of the list */\n\tfor (lp = *list; lp->next; lp = lp->next);\n\tback = lp;\n    }\n    retval = krb5_kt_resolve(context, name, &kt);\n    if (retval)\n\treturn retval;\n    retval = krb5_kt_start_seq_get(context, kt, &cursor);\n    if (retval)\n\tgoto close_kt;\n    for (;;) {\n\tentry = (krb5_keytab_entry *)malloc(sizeof (krb5_keytab_entry));\n\tif (!entry) {\n\t    retval = ENOMEM;\n\t    break;\n\t}\n\tmemset((char *)entry, 0, sizeof (*entry));\n\tretval = krb5_kt_next_entry(context, kt, entry, &cursor);\n\tif (retval)\n\t    break;\n\n\tif (!lp) {\t\t/* if list is empty, start one */\n\t    lp = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t} else {\n\t    lp->next = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp->next) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t    lp = lp->next;\n\t}\n\tif (!tail)\n\t    tail = lp;\n\tlp->next = NULL;\n\tlp->entry = entry;\n    }\n    if (entry)\n\tfree((char *)entry);\n    if (retval) {\n\tif (retval == KRB5_KT_END)\n\t    retval = 0;\n\telse {\n\t    ktutil_free_kt_list(context, tail);\n\t    tail = NULL;\n\t    if (back)\n\t\tback->next = NULL;\n\t}\n    }\n    if (!*list)\n\t*list = tail;\n    krb5_kt_end_seq_get(context, kt, &cursor);\n close_kt:\n    krb5_kt_close(context, kt);\n    return retval;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"kerberosIV/krb.h\"",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "krb5_kt_close",
          "args": [
            "context",
            "kt"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_end_seq_get",
          "args": [
            "context",
            "kt",
            "&cursor"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktutil_free_kt_list",
          "args": [
            "context",
            "tail"
          ],
          "line": 294
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_free_kt_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "41-58",
          "snippet": "krb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"kerberosIV/krb.h\"",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (*lp)"
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (*lp)"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_next_entry",
          "args": [
            "context",
            "kt",
            "entry",
            "&cursor"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *)entry",
            "0",
            "sizeof (*entry)"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof (krb5_keytab_entry)"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_start_seq_get",
          "args": [
            "context",
            "kt",
            "&cursor"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_kt_resolve",
          "args": [
            "context",
            "name",
            "&kt"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_read_keytab(context, name, list)\n    krb5_context context;\n    char *name;\n    krb5_kt_list *list;\n{\n    krb5_kt_list lp = NULL, tail = NULL, back = NULL;\n    krb5_keytab kt;\n    krb5_keytab_entry *entry;\n    krb5_kt_cursor cursor;\n    krb5_error_code retval = 0;\n\n    if (*list) {\n\t/* point lp at the tail of the list */\n\tfor (lp = *list; lp->next; lp = lp->next);\n\tback = lp;\n    }\n    retval = krb5_kt_resolve(context, name, &kt);\n    if (retval)\n\treturn retval;\n    retval = krb5_kt_start_seq_get(context, kt, &cursor);\n    if (retval)\n\tgoto close_kt;\n    for (;;) {\n\tentry = (krb5_keytab_entry *)malloc(sizeof (krb5_keytab_entry));\n\tif (!entry) {\n\t    retval = ENOMEM;\n\t    break;\n\t}\n\tmemset((char *)entry, 0, sizeof (*entry));\n\tretval = krb5_kt_next_entry(context, kt, entry, &cursor);\n\tif (retval)\n\t    break;\n\n\tif (!lp) {\t\t/* if list is empty, start one */\n\t    lp = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t} else {\n\t    lp->next = (krb5_kt_list)malloc(sizeof (*lp));\n\t    if (!lp->next) {\n\t\tretval = ENOMEM;\n\t\tbreak;\n\t    }\n\t    lp = lp->next;\n\t}\n\tif (!tail)\n\t    tail = lp;\n\tlp->next = NULL;\n\tlp->entry = entry;\n    }\n    if (entry)\n\tfree((char *)entry);\n    if (retval) {\n\tif (retval == KRB5_KT_END)\n\t    retval = 0;\n\telse {\n\t    ktutil_free_kt_list(context, tail);\n\t    tail = NULL;\n\t    if (back)\n\t\tback->next = NULL;\n\t}\n    }\n    if (!*list)\n\t*list = tail;\n    krb5_kt_end_seq_get(context, kt, &cursor);\n close_kt:\n    krb5_kt_close(context, kt);\n    return retval;\n}"
  },
  {
    "function_name": "ktutil_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
    "lines": "91-230",
    "snippet": "krb5_error_code ktutil_add(context, list, princ_str, kvno,\n\t\t\t   enctype_str, use_pass)\n    krb5_context context;\n    krb5_kt_list *list;\n    char *princ_str;\n    krb5_kvno kvno;\n    char *enctype_str;\n    int use_pass;\n{\n    krb5_keytab_entry *entry;\n    krb5_kt_list lp = NULL, prev = NULL;\n    krb5_principal princ;\n    krb5_enctype enctype;\n    krb5_timestamp now;\n    krb5_error_code retval;\n    krb5_data password, salt;\n    krb5_keyblock key;\n    char buf[BUFSIZ];\n    char promptstr[1024];\n\n    char *cp;\n    int i, tmp;\n    unsigned int pwsize = BUFSIZ;\n\n    retval = krb5_parse_name(context, princ_str, &princ);\n    if (retval)\n        return retval;\n    /* now unparse in order to get the default realm appended\n       to princ_str, if no realm was specified */\n    retval = krb5_unparse_name(context, princ, &princ_str);\n    if (retval)\n        return retval;\n    retval = krb5_string_to_enctype(enctype_str, &enctype);\n    if (retval) \n        return KRB5_BAD_ENCTYPE;\n    retval = krb5_timeofday(context, &now);\n    if (retval)\n        return retval;\n\n    if (*list) {\n        /* point lp at the tail of the list */\n        for (lp = *list; lp->next; lp = lp->next);\n    }\n    entry = (krb5_keytab_entry *) malloc(sizeof(krb5_keytab_entry));\n    if (!entry) {\n        return ENOMEM;\n    }\n    memset((char *) entry, 0, sizeof(*entry));\n\n    if (!lp) {\t\t/* if list is empty, start one */\n        lp = (krb5_kt_list) malloc(sizeof(krb5_kt_list));\n\tif (!lp) {\n\t    return ENOMEM;\n\t}\n    } else {\n        lp->next = (krb5_kt_list) malloc(sizeof(krb5_kt_list));\n\tif (!lp->next) {\n\t    return ENOMEM;\n\t}\n\tprev = lp;\n\tlp = lp->next;\n    }          \n    lp->next = NULL;\n    lp->entry = entry;\n\n    if (use_pass) {\n        password.length = pwsize;\n\tpassword.data = (char *) malloc(pwsize);\n\tif (!password.data) {\n\t    retval = ENOMEM;\n\t    goto cleanup;\n\t}\n\n\tsprintf(promptstr, \"Password for %.1000s\", princ_str);\n        retval = krb5_read_password(context, promptstr, NULL, password.data,\n\t\t\t\t    &password.length);\n\tif (retval)\n\t    goto cleanup;\n\tretval = krb5_principal2salt(context, princ, &salt);\n\tif (retval)\n\t    goto cleanup;\n\tretval = krb5_c_string_to_key(context, enctype, &password,\n\t\t\t\t      &salt, &key);\n\tif (retval)\n\t    goto cleanup;\n\tmemset(password.data, 0, password.length);\n\tpassword.length = 0;\n\tmemcpy(&lp->entry->key, &key, sizeof(krb5_keyblock));\n    } else {\n        printf(\"Key for %s (hex): \", princ_str);\n\tfgets(buf, BUFSIZ, stdin);\n\t/*\n\t * We need to get rid of the trailing '\\n' from fgets.\n\t * If we have an even number of hex digits (as we should),\n\t * write a '\\0' over the '\\n'.  If for some reason we have\n\t * an odd number of hex digits, force an even number of hex\n\t * digits by writing a '0' into the last position (the string\n\t * will still be null-terminated).\n\t */\n\tbuf[strlen(buf) - 1] = strlen(buf) % 2 ? '\\0' : '0';\n\tif (strlen(buf) == 0) {\n\t    fprintf(stderr, \"addent: Error reading key.\\n\");\n\t    retval = 0;\n\t    goto cleanup;\n\t}\n\t\n        lp->entry->key.enctype = enctype;\n\tlp->entry->key.contents = (krb5_octet *) malloc((strlen(buf) + 1) / 2);\n\tif (!lp->entry->key.contents) {\n\t    retval = ENOMEM;\n\t    goto cleanup;\n\t}\n\n\ti = 0;\n\tfor (cp = buf; *cp; cp += 2) {\n\t    if (!isxdigit((int) cp[0]) || !isxdigit((int) cp[1])) {\n\t        fprintf(stderr, \"addent: Illegal character in key.\\n\");\n\t\tretval = 0;\n\t\tgoto cleanup;\n\t    }\n\t    sscanf(cp, \"%02x\", &tmp);\n\t    lp->entry->key.contents[i++] = (krb5_octet) tmp;\n\t}\n\tlp->entry->key.length = i;\n    }\n    lp->entry->principal = princ;\n    lp->entry->vno = kvno;\n    lp->entry->timestamp = now;\n\n    if (!*list)\n\t*list = lp;\n\n    return 0;\n\n cleanup:\n    if (prev)\n        prev->next = NULL;\n    ktutil_free_kt_list(context, lp);\n    return retval;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"kerberosIV/krb.h\"",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktutil_free_kt_list",
          "args": [
            "context",
            "lp"
          ],
          "line": 228
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_free_kt_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "41-58",
          "snippet": "krb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"kerberosIV/krb.h\"",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "cp",
            "\"%02x\"",
            "&tmp"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"addent: Illegal character in key.\\n\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "(int) cp[1]"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isxdigit",
          "args": [
            "(int) cp[0]"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "(strlen(buf) + 1) / 2"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fprintf",
          "args": [
            "stderr",
            "\"addent: Error reading key.\\n\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fgets",
          "args": [
            "buf",
            "BUFSIZ",
            "stdin"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printf",
          "args": [
            "\"Key for %s (hex): \"",
            "princ_str"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&lp->entry->key",
            "&key",
            "sizeof(krb5_keyblock)"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "password.data",
            "0",
            "password.length"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_c_string_to_key",
          "args": [
            "context",
            "enctype",
            "&password",
            "&salt",
            "&key"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_principal2salt",
          "args": [
            "context",
            "princ",
            "&salt"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_read_password",
          "args": [
            "context",
            "promptstr",
            "NULL",
            "password.data",
            "&password.length"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "promptstr",
            "\"Password for %.1000s\"",
            "princ_str"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "pwsize"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(krb5_kt_list)"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(krb5_kt_list)"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "(char *) entry",
            "0",
            "sizeof(*entry)"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "malloc",
          "args": [
            "sizeof(krb5_keytab_entry)"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_timeofday",
          "args": [
            "context",
            "&now"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_string_to_enctype",
          "args": [
            "enctype_str",
            "&enctype"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_unparse_name",
          "args": [
            "context",
            "princ",
            "&princ_str"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "krb5_parse_name",
          "args": [
            "context",
            "princ_str",
            "&princ"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_add(context, list, princ_str, kvno,\n\t\t\t   enctype_str, use_pass)\n    krb5_context context;\n    krb5_kt_list *list;\n    char *princ_str;\n    krb5_kvno kvno;\n    char *enctype_str;\n    int use_pass;\n{\n    krb5_keytab_entry *entry;\n    krb5_kt_list lp = NULL, prev = NULL;\n    krb5_principal princ;\n    krb5_enctype enctype;\n    krb5_timestamp now;\n    krb5_error_code retval;\n    krb5_data password, salt;\n    krb5_keyblock key;\n    char buf[BUFSIZ];\n    char promptstr[1024];\n\n    char *cp;\n    int i, tmp;\n    unsigned int pwsize = BUFSIZ;\n\n    retval = krb5_parse_name(context, princ_str, &princ);\n    if (retval)\n        return retval;\n    /* now unparse in order to get the default realm appended\n       to princ_str, if no realm was specified */\n    retval = krb5_unparse_name(context, princ, &princ_str);\n    if (retval)\n        return retval;\n    retval = krb5_string_to_enctype(enctype_str, &enctype);\n    if (retval) \n        return KRB5_BAD_ENCTYPE;\n    retval = krb5_timeofday(context, &now);\n    if (retval)\n        return retval;\n\n    if (*list) {\n        /* point lp at the tail of the list */\n        for (lp = *list; lp->next; lp = lp->next);\n    }\n    entry = (krb5_keytab_entry *) malloc(sizeof(krb5_keytab_entry));\n    if (!entry) {\n        return ENOMEM;\n    }\n    memset((char *) entry, 0, sizeof(*entry));\n\n    if (!lp) {\t\t/* if list is empty, start one */\n        lp = (krb5_kt_list) malloc(sizeof(krb5_kt_list));\n\tif (!lp) {\n\t    return ENOMEM;\n\t}\n    } else {\n        lp->next = (krb5_kt_list) malloc(sizeof(krb5_kt_list));\n\tif (!lp->next) {\n\t    return ENOMEM;\n\t}\n\tprev = lp;\n\tlp = lp->next;\n    }          \n    lp->next = NULL;\n    lp->entry = entry;\n\n    if (use_pass) {\n        password.length = pwsize;\n\tpassword.data = (char *) malloc(pwsize);\n\tif (!password.data) {\n\t    retval = ENOMEM;\n\t    goto cleanup;\n\t}\n\n\tsprintf(promptstr, \"Password for %.1000s\", princ_str);\n        retval = krb5_read_password(context, promptstr, NULL, password.data,\n\t\t\t\t    &password.length);\n\tif (retval)\n\t    goto cleanup;\n\tretval = krb5_principal2salt(context, princ, &salt);\n\tif (retval)\n\t    goto cleanup;\n\tretval = krb5_c_string_to_key(context, enctype, &password,\n\t\t\t\t      &salt, &key);\n\tif (retval)\n\t    goto cleanup;\n\tmemset(password.data, 0, password.length);\n\tpassword.length = 0;\n\tmemcpy(&lp->entry->key, &key, sizeof(krb5_keyblock));\n    } else {\n        printf(\"Key for %s (hex): \", princ_str);\n\tfgets(buf, BUFSIZ, stdin);\n\t/*\n\t * We need to get rid of the trailing '\\n' from fgets.\n\t * If we have an even number of hex digits (as we should),\n\t * write a '\\0' over the '\\n'.  If for some reason we have\n\t * an odd number of hex digits, force an even number of hex\n\t * digits by writing a '0' into the last position (the string\n\t * will still be null-terminated).\n\t */\n\tbuf[strlen(buf) - 1] = strlen(buf) % 2 ? '\\0' : '0';\n\tif (strlen(buf) == 0) {\n\t    fprintf(stderr, \"addent: Error reading key.\\n\");\n\t    retval = 0;\n\t    goto cleanup;\n\t}\n\t\n        lp->entry->key.enctype = enctype;\n\tlp->entry->key.contents = (krb5_octet *) malloc((strlen(buf) + 1) / 2);\n\tif (!lp->entry->key.contents) {\n\t    retval = ENOMEM;\n\t    goto cleanup;\n\t}\n\n\ti = 0;\n\tfor (cp = buf; *cp; cp += 2) {\n\t    if (!isxdigit((int) cp[0]) || !isxdigit((int) cp[1])) {\n\t        fprintf(stderr, \"addent: Illegal character in key.\\n\");\n\t\tretval = 0;\n\t\tgoto cleanup;\n\t    }\n\t    sscanf(cp, \"%02x\", &tmp);\n\t    lp->entry->key.contents[i++] = (krb5_octet) tmp;\n\t}\n\tlp->entry->key.length = i;\n    }\n    lp->entry->principal = princ;\n    lp->entry->vno = kvno;\n    lp->entry->timestamp = now;\n\n    if (!*list)\n\t*list = lp;\n\n    return 0;\n\n cleanup:\n    if (prev)\n        prev->next = NULL;\n    ktutil_free_kt_list(context, lp);\n    return retval;\n}"
  },
  {
    "function_name": "ktutil_delete",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
    "lines": "64-83",
    "snippet": "krb5_error_code ktutil_delete(context, list, idx)\n    krb5_context context;\n    krb5_kt_list *list;\n    int idx;\n{\n    krb5_kt_list lp, prev;\n    int i;\n\n    for (lp = *list, i = 1; lp; prev = lp, lp = lp->next, i++) {\n\tif (i == idx) {\n\t    if (i == 1)\n\t\t*list = lp->next;\n\t    else\n\t\tprev->next = lp->next;\n\t    lp->next = NULL;\n\t    return ktutil_free_kt_list(context, lp);\n\t}\n    }\n    return EINVAL;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"kerberosIV/krb.h\"",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktutil_free_kt_list",
          "args": [
            "context",
            "lp"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_free_kt_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "41-58",
          "snippet": "krb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}",
          "includes": [
            "#include <ctype.h>",
            "#include <string.h>",
            "#include <stdio.h>",
            "#include \"kerberosIV/krb.h\"",
            "#include \"ktutil.h\"",
            "#include \"k5-int.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_delete(context, list, idx)\n    krb5_context context;\n    krb5_kt_list *list;\n    int idx;\n{\n    krb5_kt_list lp, prev;\n    int i;\n\n    for (lp = *list, i = 1; lp; prev = lp, lp = lp->next, i++) {\n\tif (i == idx) {\n\t    if (i == 1)\n\t\t*list = lp->next;\n\t    else\n\t\tprev->next = lp->next;\n\t    lp->next = NULL;\n\t    return ktutil_free_kt_list(context, lp);\n\t}\n    }\n    return EINVAL;\n}"
  },
  {
    "function_name": "ktutil_free_kt_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
    "lines": "41-58",
    "snippet": "krb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}",
    "includes": [
      "#include <ctype.h>",
      "#include <string.h>",
      "#include <stdio.h>",
      "#include \"kerberosIV/krb.h\"",
      "#include \"ktutil.h\"",
      "#include \"k5-int.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "(char *)prev"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "ktutil_free_kt_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_cpp_ICV/CVE-2014-9422/repo/src/kadmin/ktutil/ktutil_funcs.c",
          "lines": "41-58",
          "snippet": "krb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "krb5_kt_free_entry",
          "args": [
            "context",
            "lp->entry"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <ctype.h>\n#include <string.h>\n#include <stdio.h>\n#include \"kerberosIV/krb.h\"\n#include \"ktutil.h\"\n#include \"k5-int.h\"\n\nkrb5_error_code ktutil_free_kt_list(context, list)\n    krb5_context context;\n    krb5_kt_list list;\n{\n    krb5_kt_list lp, prev;\n    krb5_error_code retval = 0;\n\n    for (lp = list; lp;) {\n\tretval = krb5_kt_free_entry(context, lp->entry);\n\tfree((char *)lp->entry);\n\tif (retval)\n\t    break;\n\tprev = lp;\n\tlp = lp->next;\n\tfree((char *)prev);\n    }\n    return retval;\n}"
  }
]